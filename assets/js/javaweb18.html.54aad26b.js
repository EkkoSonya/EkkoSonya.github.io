"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[9117],{83671:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}},81414:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>d});var t=a(7847);const e=a.p+"assets/img/24.4b3ddf57.png",p=a.p+"assets/img/25.5da66672.png",o=a.p+"assets/img/26.c24e5959.png",c=a.p+"assets/img/27.ab7e8f4c.png",l=a.p+"assets/img/28.f641cacc.png",i=[(0,t.Fv)('<h2 id="mybatis详解6" tabindex="-1"><a class="header-anchor" href="#mybatis详解6"><span>Mybatis详解6</span></a></h2><h3 id="缓存机制" tabindex="-1"><a class="header-anchor" href="#缓存机制"><span>缓存机制</span></a></h3><p>其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。</p><p>Mybatis为了查询效率，同样内置了一个缓存机制，我们在查询时，如果Mybatis缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求，节省性能开销。</p><figure><img src="'+e+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><code>Mybatis</code>的缓存机制有些复杂，存在<strong>一级缓存(本地缓存)<strong>和</strong>二级缓存</strong></p><h4 id="一级缓存-作用在sqlsession" tabindex="-1"><a class="header-anchor" href="#一级缓存-作用在sqlsession"><span>一级缓存 (作用在<code>SqlSession</code>)</span></a></h4><p>我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，也就是一级缓存，<strong>它仅仅对一个会话中的数据进行缓存</strong>（一级缓存强制启用，无法关闭，只能做调整）</p><p>也就是每一个<code>SqlSession</code>都有有一个对应的缓存</p><p>我们来看看下面这段代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">TestMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//再次获取</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们连续获取了两次ID为1的用户，我们会在日志中惊奇地发现，这里的查询操作实际上只进行了一次：</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>我们去掉类上的<code>@Data</code>注解，会发现得到的两个对象实际上就是同一个：</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>也就是说我们第二次查询不仅压根就<strong>没执行SQL语句</strong>，甚至直接没有<strong>重新构造对象，而是直接获取之前创建好的</strong>。</p><p>可见，<code>Mybatis</code>确实存在着缓存机制来进行性能优化。</p><p>那么如果我修改了数据库中的内容，缓存还会生效吗：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nmapper<span class="token punctuation">.</span><span class="token function">updateAgeById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时由于我们更新了数据库中的数据，那么之前缓存的内容也会跟着失效，第二次获取的时候会进行重新查询。</p><p>也就是说<code>Mybatis</code>知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。</p><p>但是一定注意，一级缓存只针对于<strong>单个会话</strong>，<strong>多个会话之间不相通</strong>。</p><p>因此， 一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，我们可以来试验一下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> s1 <span class="token operator">=</span> <span class="token class-name">MybatisUtils</span><span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">SqlSession</span> s2 <span class="token operator">=</span> <span class="token class-name">MybatisUtils</span><span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">TestMapper</span> m1 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">TestMapper</span> m2 <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    m2<span class="token punctuation">.</span><span class="token function">updateAgeById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，会话1在重复查询数据时，即使会话2已经修改了数据，但是依然没有影响会话1之中的缓存。</p><p>这导致尽管会话2更新了数据，但是会话1中的数据是从缓存得到的，没有更新。</p><p>一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，<strong>如果一个会话结束，那么之前的缓存就全部失效了</strong>，但是我们希望缓存能够扩展到所有会话都能使用，无论哪个会话对于数据的查询缓存都可以直接被所有会话使用。</p><h4 id="二级缓存-作用在mapper" tabindex="-1"><a class="header-anchor" href="#二级缓存-作用在mapper"><span>二级缓存 (作用在<code>Mapper</code>)</span></a></h4><p>我们可以通过<strong>二级缓存</strong>来实现，二级缓存<strong>默认是关闭状态</strong>，要开启二级缓存，我们需要在映射器XML文件中添加：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>二级缓存是<code>Mapper</code>级别的，<strong>只要是使用这个<code>Mapper</code>的会话，都会关联到这个二级缓存</strong></p><p>无论哪个会话失效，它之前查询的缓存依然会存在于二级缓存中，依然可以被其他会话直接使用。</p><p>我们可以对<code>cache</code>标签进行一些配置：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span>\n  <span class="token attr-name">eviction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>FIFO<span class="token punctuation">&quot;</span></span>\n  <span class="token attr-name">flushInterval</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>60000<span class="token punctuation">&quot;</span></span>\n  <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>512<span class="token punctuation">&quot;</span></span>\n  <span class="token attr-name">readOnly</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>size</code>表示最大的缓存对象数量，当缓存达到上限时，会根据<code>eviction</code>配置的策略进行清理：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p><code>flushInterval</code>用于控制缓存刷新时间，当到达指定时间时会自动清理所有缓存，默认情况下如果不配置此项则不会进行定时清理。</p><p><code>readOnly</code>（只读）属性可以被设置为 true 或 false，只读的缓存会给所有调用者返回<strong>相同的缓存对象</strong>，且<strong>对象不能被修改</strong>。这就提供了可观的性能提升。</p><p>而可读写的缓存会（通过序列化）返回<strong>缓存对象的拷贝</strong>。 速度上会慢一些，但是更安全，因此默认值是 false。</p><blockquote><p><strong>注意：</strong> 二级缓存是<strong>事务性</strong>的，这意味着，当 SqlSession 结束并提交时，或是结束并回滚，而且没有执行 <code>flushCache=true</code> 的 <code>insert/delete/update</code> 语句时，<strong>二级缓存才会被更新</strong>。</p></blockquote><p>即：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> session <span class="token operator">=</span> <span class="token class-name">MybatisUtil</span><span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">SqlSession</span> session2 <span class="token operator">=</span> <span class="token class-name">MybatisUtil</span><span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token class-name">TestMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectStuById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    session2<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">TestMapper</span> mapper2 <span class="token operator">=</span> session2<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper2<span class="token punctuation">.</span><span class="token function">selectStuById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有<code>commit</code>了，才会保存在二级缓存，这样用<code>mapper2</code>时，才不会重新读取，如果没有<code>commit</code>，就会重新读取，因为并没有保存在缓存中</p><p>开启二级缓存后，再次执行我们之前的操作，就可以直接在二级缓存中命中了：</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="查找顺序" tabindex="-1"><a class="header-anchor" href="#查找顺序"><span>查找顺序</span></a></h5><p>实际上，添加了二级缓存之后，Mybatis会<strong>先从二级缓存中查找数据</strong>，当二级缓存中没有时，<strong>才会从一级缓存中获取</strong>，当一级缓存中都还没有数据时，才<strong>会请求数据库</strong>。</p><h5 id="单独配置取消二级缓存-usecache-false" tabindex="-1"><a class="header-anchor" href="#单独配置取消二级缓存-usecache-false"><span>单独配置取消二级缓存 <code>useCache=&#39;false&#39;</code></span></a></h5><p>当我们开启二级缓存后，默认情况下一个Mapper中所有的操作都会使用二级缓存</p><p>我们也可以单独配置其不使用二级缓存，只需要修改<code>useCache</code>属性即可：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectUserById<span class="token punctuation">&quot;</span></span> <span class="token attr-name">useCache</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.test.User<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    select * from user where id = #{id}\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="操作结束-清除所有缓存-flushcache" tabindex="-1"><a class="header-anchor" href="#操作结束-清除所有缓存-flushcache"><span>操作结束，清除所有缓存 <code>flushCache</code></span></a></h5><p>有些操作可能比较特殊，比如我们希望某个操作执行完成后，直接清除所有缓存，无论是一级缓存还是二级缓存，那么此时就可以开启<code>flushCache</code>属性：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectUserById<span class="token punctuation">&quot;</span></span> <span class="token attr-name">flushCache</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.test.User<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    select * from user where id = #{id}\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开启此选项后，调用此操作将直接导致一级和二级缓存被清除。</p><h4 id="缓存一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存一致性问题"><span>缓存一致性问题</span></a></h4><p>虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在<code>计算机组成原理</code>中可能学习过<strong>缓存一致性问题</strong></p><p>当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题。</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>而<code>Mybatis</code>也会这样，我们来看看这个例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">TestMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在循环地每三秒读取一次，而在这个过程中，我们使用其他软件手动修改数据库中的数据，将1号用户的ID改成100，那么理想情况下，下一次读取将直接无法获取到这行数据，因为ID已经发生变化了。</p><p>但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的</p><p>因此，如果存在多台服务器或者是多个程序都在使用<code>Mybatis</code>操作同一个数据库，并且都开启了<strong>缓存</strong>，需要解决这个问题</p><p>我们只能关闭所有二级缓存，并且在<code>Mybatis</code>每个操作都配置<code>flushCache</code>为true来保证刷新。</p><p>只不过这种操作实际上是治标不治本的，<strong>实现多服务器缓存共用</strong>才是最终解决方案，也就是让所有的Mybatis都使用<strong>同一个缓存进行数据存取</strong></p><p>在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。</p>',67)],u={},r=(0,a(83671).A)(u,[["render",function(n,s){return(0,t.uX)(),(0,t.CE)("div",null,i)}]]),d=JSON.parse('{"path":"/code/javaweb/4-Mybatis/javaweb18.html","title":"javaweb - Mybatis8","lang":"zh-CN","frontmatter":{"title":"javaweb - Mybatis8","date":"2025-06-17T00:00:00.000Z","category":["code"],"tag":["javaweb","mybatis"],"order":-0.748,"description":"Mybatis详解6 缓存机制 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。 Mybatis为了查询效率，同样内置...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/javaweb/4-Mybatis/javaweb18.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"javaweb - Mybatis8"}],["meta",{"property":"og:description","content":"Mybatis详解6 缓存机制 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。 Mybatis为了查询效率，同样内置..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T16:02:13.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"javaweb"}],["meta",{"property":"article:tag","content":"mybatis"}],["meta",{"property":"article:published_time","content":"2025-06-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T16:02:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"javaweb - Mybatis8\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-07T16:02:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"Mybatis详解6","slug":"mybatis详解6","link":"#mybatis详解6","children":[{"level":3,"title":"缓存机制","slug":"缓存机制","link":"#缓存机制","children":[{"level":4,"title":"一级缓存 (作用在SqlSession)","slug":"一级缓存-作用在sqlsession","link":"#一级缓存-作用在sqlsession","children":[]},{"level":4,"title":"二级缓存 (作用在Mapper)","slug":"二级缓存-作用在mapper","link":"#二级缓存-作用在mapper","children":[{"level":5,"title":"查找顺序","slug":"查找顺序","link":"#查找顺序","children":[]},{"level":5,"title":"单独配置取消二级缓存 useCache=\'false\'","slug":"单独配置取消二级缓存-usecache-false","link":"#单独配置取消二级缓存-usecache-false","children":[]},{"level":5,"title":"操作结束，清除所有缓存 flushCache","slug":"操作结束-清除所有缓存-flushcache","link":"#操作结束-清除所有缓存-flushcache","children":[]}]},{"level":4,"title":"缓存一致性问题","slug":"缓存一致性问题","link":"#缓存一致性问题","children":[]}]}]}],"git":{"createdTime":1751904133000,"updatedTime":1751904133000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":7.42,"words":2226},"filePathRelative":"code/javaweb/4-Mybatis/javaweb18.md","localizedDate":"2025年6月17日","excerpt":"<h2>Mybatis详解6</h2>\\n<h3>缓存机制</h3>\\n<p>其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。</p>\\n<p>Mybatis为了查询效率，同样内置了一个缓存机制，我们在查询时，如果Mybatis缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求，节省性能开销。</p>\\n<figure><figcaption>alt text</figcaption></figure>","autoDesc":true}')}}]);