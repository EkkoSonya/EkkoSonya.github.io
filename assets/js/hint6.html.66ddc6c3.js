"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[7323],{83671:(n,a)=>{a.A=(n,a)=>{const s=n.__vccOpts||n;for(const[n,e]of a)s[n]=e;return s}},47422:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>p,data:()=>l});var e=s(7847);const t=[(0,e.Fv)('<p><code>i++</code> 对应的 Java 字节码指令主要取决于 <strong>变量 <code>i</code> 的类型</strong>（是局部变量还是成员变量）以及 <strong>它在代码中的使用方式</strong>（是单独作为语句还是作为表达式的一部分）</p><h3 id="_1-局部变量" tabindex="-1"><a class="header-anchor" href="#_1-局部变量"><span>1. 局部变量</span></a></h3><p>当 <code>i</code> 是方法内的局部 <code>int</code> 变量时，Java 编译器会使用专门的指令 <code>iinc</code> 进行优化。</p><h4 id="情况-a-单独语句-i" tabindex="-1"><a class="header-anchor" href="#情况-a-单独语句-i"><span>情况 A：单独语句 (<code>i++;</code>)</span></a></h4><p>如果只是单纯的自增，不涉及赋值给其他变量：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        i<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对应的字节码：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token number">0</span><span class="token operator">:</span> aload_0          <span class="token comment">// 加载 &#39;this&#39; 引用</span>\n<span class="token number">1</span><span class="token operator">:</span> dup              <span class="token comment">// 复制引用（为了 get 和 put）</span>\n<span class="token number">2</span><span class="token operator">:</span> getfield #<span class="token number">2</span>      <span class="token comment">// 获取字段 i 的值 (压入栈)</span>\n<span class="token number">5</span><span class="token operator">:</span> iconst_1         <span class="token comment">// 准备常量 1</span>\n<span class="token number">6</span><span class="token operator">:</span> iadd             <span class="token comment">// 执行加法 (栈顶值 + 1)</span>\n<span class="token number">7</span><span class="token operator">:</span> putfield #<span class="token number">2</span>      <span class="token comment">// 将结果写回字段 i</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>指令解读：</strong> <code>iinc</code> 是一个非常高效的指令，它<strong>直接在局部变量表（Local Variable Table）中修改值</strong>，不需要将数据加载到操作数栈（Operand Stack）上进行计算，再存回去。</li></ul><h4 id="情况-b-赋值语句-int-a-i" tabindex="-1"><a class="header-anchor" href="#情况-b-赋值语句-int-a-i"><span>情况 B：赋值语句 (<code>int a = i++;</code>)</span></a></h4><p>这里涉及“先赋值，后自增”的逻辑，字节码会变得复杂一些：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对应的字节码：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token number">0</span><span class="token operator">:</span> iconst_1\n<span class="token number">1</span><span class="token operator">:</span> istore_1        <span class="token comment">// i = 1</span>\n<span class="token number">2</span><span class="token operator">:</span> iload_1         <span class="token comment">// 步骤1：将 i 的当前值 (1) 压入操作数栈（保留副本用于赋值）</span>\n<span class="token number">3</span><span class="token operator">:</span> iinc <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>       <span class="token comment">// 步骤2：局部变量表中的 i 自增为 2 (此时栈顶还是 1)</span>\n<span class="token number">6</span><span class="token operator">:</span> istore_2        <span class="token comment">// 步骤3：将栈顶的值 (1) 存入局部变量 a</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>关键点：</strong> 这完美解释了为什么 <code>a = i++</code> 时，<code>a</code> 得到的是旧值。因为 <code>iload</code> 在 <code>iinc</code> 之前执行，保留了旧值的快照。</li></ul><h3 id="_2-成员变量" tabindex="-1"><a class="header-anchor" href="#_2-成员变量"><span>2. 成员变量</span></a></h3><p>如果 <code>i</code> 是类的成员变量（实例变量或静态变量），<strong>不能使用 <code>iinc</code> 指令</strong>。因为成员变量存储在堆（Heap）或方法区中，而不是线程私有的局部变量表中</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        i<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对应的字节码</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token number">0</span><span class="token operator">:</span> aload_0          <span class="token comment">// 加载 &#39;this&#39; 引用</span>\n<span class="token number">1</span><span class="token operator">:</span> dup              <span class="token comment">// 复制引用（为了 get 和 put）</span>\n<span class="token number">2</span><span class="token operator">:</span> getfield #<span class="token number">2</span>      <span class="token comment">// 获取字段 i 的值 (压入栈)</span>\n<span class="token number">5</span><span class="token operator">:</span> iconst_1         <span class="token comment">// 准备常量 1</span>\n<span class="token number">6</span><span class="token operator">:</span> iadd             <span class="token comment">// 执行加法 (栈顶值 + 1)</span>\n<span class="token number">7</span><span class="token operator">:</span> putfield #<span class="token number">2</span>      <span class="token comment">// 将结果写回字段 i</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>区别：</strong> 这里需要 <code>getfield</code> -&gt; <code>iadd</code> -&gt; <code>putfield</code> 这一套组合拳。</li><li><strong>并发安全问题：</strong> 正因为成员变量的 <code>i++</code> 不是单条指令（原子操作），而是“读-改-写”三个步骤，所以在多线程环境下，<strong><code>i++</code> 是线程不安全的</strong>。</li></ul><h3 id="_3-i-与-i-的字节码对比" tabindex="-1"><a class="header-anchor" href="#_3-i-与-i-的字节码对比"><span>3. <code>i++</code> 与 <code>++i</code> 的字节码对比</span></a></h3><p>很多面试题喜欢问这个，从字节码层面看非常清晰：</p>',23),(0,e.Lk)("table",null,[(0,e.Lk)("thead",null,[(0,e.Lk)("tr",null,[(0,e.Lk)("th",null,[(0,e.Lk)("strong",null,"源代码")]),(0,e.Lk)("th",null,[(0,e.Lk)("strong",null,"逻辑顺序")]),(0,e.Lk)("th",null,[(0,e.Lk)("strong",null,"关键字节码顺序")])])]),(0,e.Lk)("tbody",null,[(0,e.Lk)("tr",null,[(0,e.Lk)("td",null,[(0,e.Lk)("strong",null,[(0,e.Lk)("code",null,"a = i++")])]),(0,e.Lk)("td",null,"先用旧值，再自增"),(0,e.Lk)("td",null,[(0,e.Lk)("code",null,"iload"),(0,e.eW)(" (压栈) "),(0,e.Lk)("span",{class:"katex"},[(0,e.Lk)("span",{class:"katex-mathml"},[(0,e.Lk)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,e.Lk)("semantics",null,[(0,e.Lk)("mrow",null,[(0,e.Lk)("mo",null,"→")]),(0,e.Lk)("annotation",{encoding:"application/x-tex"},"\\rightarrow")])])]),(0,e.Lk)("span",{class:"katex-html","aria-hidden":"true"},[(0,e.Lk)("span",{class:"base"},[(0,e.Lk)("span",{class:"strut",style:{height:"0.3669em"}}),(0,e.Lk)("span",{class:"mrel"},"→")])])]),(0,e.eW)(),(0,e.Lk)("code",null,"iinc"),(0,e.eW)(" (自增) "),(0,e.Lk)("span",{class:"katex"},[(0,e.Lk)("span",{class:"katex-mathml"},[(0,e.Lk)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,e.Lk)("semantics",null,[(0,e.Lk)("mrow",null,[(0,e.Lk)("mo",null,"→")]),(0,e.Lk)("annotation",{encoding:"application/x-tex"},"\\rightarrow")])])]),(0,e.Lk)("span",{class:"katex-html","aria-hidden":"true"},[(0,e.Lk)("span",{class:"base"},[(0,e.Lk)("span",{class:"strut",style:{height:"0.3669em"}}),(0,e.Lk)("span",{class:"mrel"},"→")])])]),(0,e.eW)(),(0,e.Lk)("code",null,"istore"),(0,e.eW)(" (赋值)")])]),(0,e.Lk)("tr",null,[(0,e.Lk)("td",null,[(0,e.Lk)("strong",null,[(0,e.Lk)("code",null,"a = ++i")])]),(0,e.Lk)("td",null,"先自增，再用新值"),(0,e.Lk)("td",null,[(0,e.Lk)("code",null,"iinc"),(0,e.eW)(" (自增) "),(0,e.Lk)("span",{class:"katex"},[(0,e.Lk)("span",{class:"katex-mathml"},[(0,e.Lk)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,e.Lk)("semantics",null,[(0,e.Lk)("mrow",null,[(0,e.Lk)("mo",null,"→")]),(0,e.Lk)("annotation",{encoding:"application/x-tex"},"\\rightarrow")])])]),(0,e.Lk)("span",{class:"katex-html","aria-hidden":"true"},[(0,e.Lk)("span",{class:"base"},[(0,e.Lk)("span",{class:"strut",style:{height:"0.3669em"}}),(0,e.Lk)("span",{class:"mrel"},"→")])])]),(0,e.eW)(),(0,e.Lk)("code",null,"iload"),(0,e.eW)(" (压栈) "),(0,e.Lk)("span",{class:"katex"},[(0,e.Lk)("span",{class:"katex-mathml"},[(0,e.Lk)("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[(0,e.Lk)("semantics",null,[(0,e.Lk)("mrow",null,[(0,e.Lk)("mo",null,"→")]),(0,e.Lk)("annotation",{encoding:"application/x-tex"},"\\rightarrow")])])]),(0,e.Lk)("span",{class:"katex-html","aria-hidden":"true"},[(0,e.Lk)("span",{class:"base"},[(0,e.Lk)("span",{class:"strut",style:{height:"0.3669em"}}),(0,e.Lk)("span",{class:"mrel"},"→")])])]),(0,e.eW)(),(0,e.Lk)("code",null,"istore"),(0,e.eW)(" (赋值)")])])])],-1),(0,e.Fv)('<blockquote><p>注意： 如果只是单独写一行 i++; 或 ++i;（不赋值给别人），现代编译器生成的字节码通常是完全一样的，都是单纯的 iinc</p></blockquote><hr><h3 id="总结表" tabindex="-1"><a class="header-anchor" href="#总结表"><span>总结表</span></a></h3><table><thead><tr><th><strong>变量位置</strong></th><th><strong>核心指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>局部变量 (<code>int</code>)</strong></td><td><strong><code>iinc</code></strong></td><td>直接在局部变量槽位修改，极快。</td></tr><tr><td><strong>成员变量 (实例)</strong></td><td><code>getfield</code> + <code>iadd</code> + <code>putfield</code></td><td>需要进出操作数栈，非原子操作。</td></tr><tr><td><strong>静态变量 (类)</strong></td><td><code>getstatic</code> + <code>iadd</code> + <code>putstatic</code></td><td>同上，操作的是静态字段。</td></tr></tbody></table><p>其实对于 <code>i++</code> 以及 <code>++i</code> 用在赋值操作时</p><p>后++ 会先将旧值压入操作数栈，然后自增，而赋值就是对应操作数栈里的旧值</p><p>先++ 则是先自增，然后将自增完的值入栈，所以对应赋值得到的就是自增后的值了</p><h3 id="int-a-i-i" tabindex="-1"><a class="header-anchor" href="#int-a-i-i"><span><code>int a = i++ + ++i</code></span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span> <span class="token operator">+</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>赋值运算符: 在 <code>a = b = c</code> 这种情况下，赋值确实是从右往左进行的（先算 b = c，再算 a = b）</p><p>赋值表达式的结果就是所赋的值</p><p>这种情况下，最终的结果是 <code>4</code>，因为首先执行顺序是 从左往右的，所以必然是 先 <code>i++</code> 然后 <code>++i</code></p><p><code>i++</code> 其是将原值放到栈里，然后自增自己，所以栈里的第一个元素是 <code>1</code> 然后 i 自增到 <code>2</code></p><p>而 <code>++i</code> 是先自增再存储到栈，所以栈里第二个元素放的是 <code>3</code>, 同样 i 也自增到3</p><p>因此最终 a 的值对应是 4, i 对应是 3</p><h4 id="对应编译字节码" tabindex="-1"><a class="header-anchor" href="#对应编译字节码"><span>对应编译字节码</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>ekko<span class="token punctuation">.</span></span>Main</span> <span class="token punctuation">{</span>\n  <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>ekko<span class="token punctuation">.</span></span>Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">Code</span><span class="token operator">:</span>\n         <span class="token number">0</span><span class="token operator">:</span> aload_0\n         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>\n         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>\n\n  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>InterruptedException</span><span class="token punctuation">;</span>\n    <span class="token class-name">Code</span><span class="token operator">:</span>\n         <span class="token number">0</span><span class="token operator">:</span> iconst_1\n         <span class="token comment">// a = 1</span>\n         <span class="token number">1</span><span class="token operator">:</span> istore_1 \n         <span class="token comment">// 将 a 放入栈顶</span>\n         <span class="token number">2</span><span class="token operator">:</span> iload_1\n         <span class="token comment">// 直接自增两次 a = 3</span>\n         <span class="token number">3</span><span class="token operator">:</span> iinc          <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>\n         <span class="token number">6</span><span class="token operator">:</span> iinc          <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>\n         <span class="token comment">// 再把 a 放入栈顶 栈里两个元素 3 1</span>\n         <span class="token number">9</span><span class="token operator">:</span> iload_1\n        <span class="token number">10</span><span class="token operator">:</span> iadd\n        <span class="token comment">// 相加 为4</span>\n        <span class="token number">11</span><span class="token operator">:</span> istore_2\n        <span class="token number">12</span><span class="token operator">:</span> getstatic     #<span class="token number">2</span>                  <span class="token comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>\n        <span class="token number">15</span><span class="token operator">:</span> iload_2\n        <span class="token number">16</span><span class="token operator">:</span> invokevirtual #<span class="token number">3</span>                  <span class="token comment">// Method java/io/PrintStream.println:(I)V</span>\n        <span class="token number">19</span><span class="token operator">:</span> <span class="token keyword">return</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="反编译结果" tabindex="-1"><a class="header-anchor" href="#反编译结果"><span>反编译结果</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> var10000 <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token operator">++</span>i<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> var10000 <span class="token operator">+</span> i<span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',19)],o={},p=(0,s(83671).A)(o,[["render",function(n,a){return(0,e.uX)(),(0,e.CE)("div",null,t)}]]),l=JSON.parse('{"path":"/code/java_hint/hint6.html","title":"hint - i++与++i","lang":"zh-CN","frontmatter":{"title":"hint - i++与++i","date":"2025-12-27T00:00:00.000Z","category":["code"],"tag":["java hint"],"order":-0.74,"description":"i++ 对应的 Java 字节码指令主要取决于 变量 i 的类型（是局部变量还是成员变量）以及 它在代码中的使用方式（是单独作为语句还是作为表达式的一部分） 1. 局部变量 当 i 是方法内的局部 int 变量时，Java 编译器会使用专门的指令 iinc 进行优化。 情况 A：单独语句 (i++;) 如果只是单纯的自增，不涉及赋值给其他变量： 对应的...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_hint/hint6.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"hint - i++与++i"}],["meta",{"property":"og:description","content":"i++ 对应的 Java 字节码指令主要取决于 变量 i 的类型（是局部变量还是成员变量）以及 它在代码中的使用方式（是单独作为语句还是作为表达式的一部分） 1. 局部变量 当 i 是方法内的局部 int 变量时，Java 编译器会使用专门的指令 iinc 进行优化。 情况 A：单独语句 (i++;) 如果只是单纯的自增，不涉及赋值给其他变量： 对应的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-10T06:49:04.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java hint"}],["meta",{"property":"article:published_time","content":"2025-12-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-10T06:49:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"hint - i++与++i\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-27T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-10T06:49:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":3,"title":"1. 局部变量","slug":"_1-局部变量","link":"#_1-局部变量","children":[{"level":4,"title":"情况 A：单独语句 (i++;)","slug":"情况-a-单独语句-i","link":"#情况-a-单独语句-i","children":[]},{"level":4,"title":"情况 B：赋值语句 (int a = i++;)","slug":"情况-b-赋值语句-int-a-i","link":"#情况-b-赋值语句-int-a-i","children":[]}]},{"level":3,"title":"2. 成员变量","slug":"_2-成员变量","link":"#_2-成员变量","children":[]},{"level":3,"title":"3. i++ 与 ++i 的字节码对比","slug":"_3-i-与-i-的字节码对比","link":"#_3-i-与-i-的字节码对比","children":[]},{"level":3,"title":"总结表","slug":"总结表","link":"#总结表","children":[]},{"level":3,"title":"int a = i++ + ++i","slug":"int-a-i-i","link":"#int-a-i-i","children":[{"level":4,"title":"对应编译字节码","slug":"对应编译字节码","link":"#对应编译字节码","children":[]},{"level":4,"title":"反编译结果","slug":"反编译结果","link":"#反编译结果","children":[]}]}],"git":{"createdTime":1766769055000,"updatedTime":1768027744000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":2}]},"readingTime":{"minutes":4.24,"words":1271},"filePathRelative":"code/java_hint/hint6.md","localizedDate":"2025年12月27日","excerpt":"<p><code>i++</code> 对应的 Java 字节码指令主要取决于 <strong>变量 <code>i</code> 的类型</strong>（是局部变量还是成员变量）以及 <strong>它在代码中的使用方式</strong>（是单独作为语句还是作为表达式的一部分）</p>\\n<h3>1. 局部变量</h3>\\n<p>当 <code>i</code> 是方法内的局部 <code>int</code> 变量时，Java 编译器会使用专门的指令 <code>iinc</code> 进行优化。</p>\\n<h4>情况 A：单独语句 (<code>i++;</code>)</h4>\\n<p>如果只是单纯的自增，不涉及赋值给其他变量：</p>","autoDesc":true}')}}]);