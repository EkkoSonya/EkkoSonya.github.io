"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[4204],{83671:(n,a)=>{a.A=(n,a)=>{const s=n.__vccOpts||n;for(const[n,t]of a)s[n]=t;return s}},62898:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>c,data:()=>l});var t=s(7847);const p=s.p+"assets/img/1.c5f20f7a.png",e=[(0,t.Fv)('<h2 id="java8" tabindex="-1"><a class="header-anchor" href="#java8"><span>Java8</span></a></h2><h3 id="lambda-表达式" tabindex="-1"><a class="header-anchor" href="#lambda-表达式"><span>Lambda 表达式</span></a></h3><h4 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类"><span>匿名内部类</span></a></h4><p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//现在我们想新建一个线程来搞事情</span>\n    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   \n        <span class="token comment">//创建一个实现Runnable的匿名内部类</span>\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//具体的实现逻辑</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在创建<code>Thread</code>时，我们需要传入一个<code>Runnable</code>接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在<code>run()</code>方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p><h4 id="lambda-使用" tabindex="-1"><a class="header-anchor" href="#lambda-使用"><span>Lambda 使用</span></a></h4><p>在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减。</p><p>真正有用的那一部分代码，实际上就是我们对<code>run()</code>方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，现在只需要一个简短的lambda表达式即可：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//现在我们想新建一个线程来做事情</span>\n    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//只需留下我们需要具体实现的方法体</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即 原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于<code>() ‐&gt; { 代码语句 }</code>的形式进行替换即可。</p><p>这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p><blockquote><p>但是注意，它的底层其实并不只是<strong>简简单单的语法糖替换</strong>，而是通过<code>invokedynamic</code>指令实现的</p><p>匿名内部类会在编译时<strong>创建一个单独</strong>的class文件，但是lambda却不会，间接说明编译之后lambda并不是<strong>以匿名内部类的形式存在</strong>的：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//现在我们想新建一个线程来做事情</span>\n<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   \n    <span class="token comment">//这里我们拋个异常看看</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nthread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>可以看到，实际上是Main类中的<code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。 所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。 比如Runnable接口需要一个方法体对它的<code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p></blockquote><h4 id="lambda-具体规范" tabindex="-1"><a class="header-anchor" href="#lambda-具体规范"><span>Lambda 具体规范</span></a></h4><p>Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; { 代码语句，包括返回值 }</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须<strong>有且仅有一个抽象方法</strong>（可以有多个方法，但是必须保证<strong>其他方法有默认实现</strong>，必须留一个抽象方法出来）</li></ul><p>Java中接口的方法默认是 <code>public abstract</code>, 变量默认是 <code>public static final</code></p><p>比如我们之前使用的Runable类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>   \n<span class="token comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   \n    <span class="token comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，Runable的的匿名内部类实现，就可以简写为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们也可以写一个：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   \n  <span class="token comment">//接口类型</span>\n    <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    \n    <span class="token comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的Lambda表达式的实现就可以写为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//这里我们就简单将i转换为字符串形式</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不过还可以进行优化，首先方法参数类型是可以省略的：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> i <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> i <span class="token operator">-&gt;</span> i<span class="token operator">+</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="应用现有的方法函数作为方法体-方法引用" tabindex="-1"><a class="header-anchor" href="#应用现有的方法函数作为方法体-方法引用"><span>应用现有的方法函数作为方法体 (方法引用)</span></a></h5><p>Lambda 本质是：我们为所需要的接口<strong>提供了一个方法作为它的实现</strong></p><p>除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//接口中的定义</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token operator">::</span><span class="token function">impl</span><span class="token punctuation">;</span>    \n    <span class="token comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">impl</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">&quot;我是已经存在的实现&quot;</span><span class="token operator">+</span>i<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来）</p><h4 id="方法引用-举例" tabindex="-1"><a class="header-anchor" href="#方法引用-举例"><span>方法引用 举例</span></a></h4><p>比如我们现在需要对一个数组进行排序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//来个数组</span>\n    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span>\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> o1 <span class="token operator">-</span> o2<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//按从小到大的顺序排列</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是我们发现，Integer类中有一个叫做<code>compare</code>的静态方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回正数，第二个参数排前面，返回负数，第一个参数排前面</p><p>这个方法是一个静态方法，但是它却和<code>Comparator</code>需要实现的方法返回值和参数定义一模一样，所以：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//直接指定一手，效果和上面是一模一样</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="非静态方法作为方法引用" tabindex="-1"><a class="header-anchor" href="#非静态方法作为方法引用"><span>非静态方法作为方法引用</span></a></h4><h5 id="默认使用-类-方法" tabindex="-1"><a class="header-anchor" href="#默认使用-类-方法"><span>默认使用 <code>类::方法</code></span></a></h5><p>如果使用非静态方法，依然采用 <code>类::方法</code> 的情况</p><p>Lambda 会识别，然后使用相应接口的抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数来尝试调用</p><p>我们注意到Comparator要求我们实现的方法为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token keyword">return</span> o1 <span class="token operator">-</span> o2<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中o1和o2都是Integer类型的，我们发现Integer类中有一个<code>compareTo</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> anotherInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> anotherInteger<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只不过这个方法并不是静态的，而是对象所有：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//这样进行比较也行，和上面效果依然是一样的</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，<code>o1</code>作为目标对象，<code>o2</code>作为参数，正好匹配了<code>compareTo</code>方法，所以，直接缩写：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compareTo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//注意这里调用的不是静态方法</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="对象-方法" tabindex="-1"><a class="header-anchor" href="#对象-方法"><span><code>对象::方法</code></span></a></h5><p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法</p><p>通过具体对象，即 <code>对象::方法</code>，这样就仿造了静态方法时的情况，此时就不会使用默认的情况(即用参数1调用方法，该方法参数为参数2)</p><p>而是类似 静态方法作为方法引用时，两个参数对应。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Main</span> mainObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mainObject<span class="token operator">::</span><span class="token function">reserve</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reserve</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> a<span class="token punctuation">,</span> <span class="token class-name">Integer</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//现在Main类中有一个刚好匹配的方法</span>\n    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="构造方法作为方法引用" tabindex="-1"><a class="header-anchor" href="#构造方法作为方法引用"><span>构造方法作为方法引用</span></a></h4><p>当然，类的构造方法 <code>类::new</code> 同样可以作为方法引用传递：</p><p>类的构造方法默认返回自身对象</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>\n    <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//现在我们需要一个参数为String返回值为String的实现</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现，String类中刚好有一个：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token class-name">String</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span>   \n  <span class="token comment">//由于String类的构造方法返回的肯定是一个String类型的对象，</span>\n  <span class="token comment">//且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>coder <span class="token operator">=</span> original<span class="token punctuation">.</span>coder<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于是：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>   \n    <span class="token comment">//没错，构造方法直接使用new关键字就行</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。</p><p>Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。</p><h3 id="optional类" tabindex="-1"><a class="header-anchor" href="#optional类"><span>Optional类</span></a></h3><p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。</p><p>我们先来看看下面这个例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>   \n  <span class="token comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token comment">//那太简单了吧，直接转换打印一气呵成</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样实现的话，我们少考虑了一个问题，万一给进来的<code>str</code>是<code>null</code>呢？</p><p>如果是<code>null</code>的话，在调用<code>toLowerCase</code>方法时岂不是直接空指针异常了？</p><p>所以我们还得判空一下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决</p><p>这时，<code>Optional</code>来了，我们可以将任何的变量包装进Optional类中使用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token class-name">Optional</span>\n            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>   <span class="token comment">//将str包装进Optional</span>\n            <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>   \n              <span class="token comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span>\n                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>   \n            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于这里只有一句打印，所以我们来优化一下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token class-name">Optional</span>\n            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>   <span class="token comment">//将str包装进Optional</span>\n            <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p><p>除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;VVV&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">//orElse表示如果为空就返回里面的内容</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>',90)],o={},c=(0,s(83671).A)(o,[["render",function(n,a){return(0,t.uX)(),(0,t.CE)("div",null,e)}]]),l=JSON.parse('{"path":"/code/java%209-17/javainfo.html","title":"Java8回顾","lang":"zh-CN","frontmatter":{"title":"Java8回顾","date":"2025-07-27T00:00:00.000Z","category":["code"],"tag":["java新特性"],"order":-0.746,"description":"Java8 Lambda 表达式 匿名内部类 在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如： 在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在run()方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。 ...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java%209-17/javainfo.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Java8回顾"}],["meta",{"property":"og:description","content":"Java8 Lambda 表达式 匿名内部类 在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如： 在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在run()方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T12:08:06.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java新特性"}],["meta",{"property":"article:published_time","content":"2025-07-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-28T12:08:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java8回顾\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-28T12:08:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"Java8","slug":"java8","link":"#java8","children":[{"level":3,"title":"Lambda 表达式","slug":"lambda-表达式","link":"#lambda-表达式","children":[{"level":4,"title":"匿名内部类","slug":"匿名内部类","link":"#匿名内部类","children":[]},{"level":4,"title":"Lambda 使用","slug":"lambda-使用","link":"#lambda-使用","children":[]},{"level":4,"title":"Lambda 具体规范","slug":"lambda-具体规范","link":"#lambda-具体规范","children":[{"level":5,"title":"应用现有的方法函数作为方法体 (方法引用)","slug":"应用现有的方法函数作为方法体-方法引用","link":"#应用现有的方法函数作为方法体-方法引用","children":[]}]},{"level":4,"title":"方法引用 举例","slug":"方法引用-举例","link":"#方法引用-举例","children":[]},{"level":4,"title":"非静态方法作为方法引用","slug":"非静态方法作为方法引用","link":"#非静态方法作为方法引用","children":[{"level":5,"title":"默认使用 类::方法","slug":"默认使用-类-方法","link":"#默认使用-类-方法","children":[]},{"level":5,"title":"对象::方法","slug":"对象-方法","link":"#对象-方法","children":[]}]},{"level":4,"title":"构造方法作为方法引用","slug":"构造方法作为方法引用","link":"#构造方法作为方法引用","children":[]}]},{"level":3,"title":"Optional类","slug":"optional类","link":"#optional类","children":[]}]}],"git":{"createdTime":1753704486000,"updatedTime":1753704486000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":9.53,"words":2859},"filePathRelative":"code/java 9-17/javainfo.md","localizedDate":"2025年7月27日","excerpt":"<h2>Java8</h2>\\n<h3>Lambda 表达式</h3>\\n<h4>匿名内部类</h4>\\n<p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> args<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//现在我们想新建一个线程来搞事情</span>\\n    <span class=\\"token class-name\\">Thread</span> thread <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Thread</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Runnable</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>   \\n        <span class=\\"token comment\\">//创建一个实现Runnable的匿名内部类</span>\\n        <span class=\\"token annotation punctuation\\">@Override</span>\\n        <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">run</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>   <span class=\\"token comment\\">//具体的实现逻辑</span>\\n            <span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"Hello World!\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    thread<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">start</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}')},23727:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>u,data:()=>r});var t=s(7847);const p=s.p+"assets/img/1.453543e6.png",e=s.p+"assets/img/2.2dde77c2.png",o=s.p+"assets/img/3.732ab8aa.png",c=s.p+"assets/img/4.e323530e.png",l=[(0,t.Fv)('<h2 id="网络基础1" tabindex="-1"><a class="header-anchor" href="#网络基础1"><span>网络基础1</span></a></h2><p>在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：</p><blockquote><p>万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称<code>Web</code>，万维网用<strong>链接</strong>的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>，在一个客户程序主窗口上显示出的万维网文档称为页面。</p></blockquote><p>URL的格式为：</p><blockquote><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。</p><p>主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问）</p><p>端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。</p><p>路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。</p></blockquote><p>接着了解一下什么是HTTP协议：</p><blockquote><p>HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。</p></blockquote><p>HTTP的传输原理：</p><blockquote><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。</p></blockquote><p>HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理：</p><figure><img src="'+p+'" alt="点击查看源网页" tabindex="0" loading="lazy"><figcaption>点击查看源网页</figcaption></figure><p>TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。</p><p>而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。</p><figure><img src="'+e+'" alt="点击查看源网页" tabindex="0" loading="lazy"><figcaption>点击查看源网页</figcaption></figure><p>HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？</p><p>我们来看一下HTTP的传输过程：</p><figure><img src="'+o+'" alt="点击查看源网页" tabindex="0" loading="lazy"><figcaption>点击查看源网页</figcaption></figure><blockquote><p>用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。 当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把<strong>HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器</strong>。 服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p></blockquote><p>因此，我们的浏览器请求一个页面，需要两倍的往返时间。</p><p>最后，我们再来了解一下HTTP的报文结构：</p><figure><img src="'+c+'" alt="image-20230306164008613" tabindex="0" loading="lazy"><figcaption>image-20230306164008613</figcaption></figure><p>由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。</p>',22)],i={},u=(0,s(83671).A)(i,[["render",function(n,a){return(0,t.uX)(),(0,t.CE)("div",null,l)}]]),r=JSON.parse('{"path":"/code/javaweb/8-%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9/javainfo.html","title":"Content - 网络基础1","lang":"zh-CN","frontmatter":{"title":"Content - 网络基础1","date":"2025-07-20T00:00:00.000Z","category":["code"],"tag":["javaweb"],"order":-0.7466,"description":"网络基础1 在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的： 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用链接的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 万维网以客户服务器的方式工作，浏览器就是安装在用户...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/javaweb/8-%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9/javainfo.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Content - 网络基础1"}],["meta",{"property":"og:description","content":"网络基础1 在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的： 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用链接的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 万维网以客户服务器的方式工作，浏览器就是安装在用户..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T12:08:06.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"javaweb"}],["meta",{"property":"article:published_time","content":"2025-07-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-28T12:08:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Content - 网络基础1\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-28T12:08:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"网络基础1","slug":"网络基础1","link":"#网络基础1","children":[]}],"git":{"createdTime":1753033405000,"updatedTime":1753704486000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":2}]},"readingTime":{"minutes":4.06,"words":1219},"filePathRelative":"code/javaweb/8-网络内容/javainfo.md","localizedDate":"2025年7月20日","excerpt":"<h2>网络基础1</h2>\\n<p>在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：</p>\\n<blockquote>\\n<p>万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称<code>Web</code>，万维网用<strong>链接</strong>的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。\\n万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>，在一个客户程序主窗口上显示出的万维网文档称为页面。</p>\\n</blockquote>","autoDesc":true}')}}]);