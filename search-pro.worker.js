const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":1359,\"nextId\":1359,\"documentIds\":{\"0\":\"2\",\"1\":\"2@0\",\"2\":\"2@1\",\"3\":\"3\",\"4\":\"3#主要动机\",\"5\":\"3#主要贡献\",\"6\":\"3#主要内容\",\"7\":\"3#系统结构\",\"8\":\"3#基本设置\",\"9\":\"3#信号模型\",\"10\":\"3#quality-of-experience-model\",\"11\":\"3#优化问题建立\",\"12\":\"3#解决方案\",\"13\":\"3#无人机的3d部署\",\"14\":\"3#无人机的动态移动设计\",\"15\":\"3@0\",\"16\":\"3@1\",\"17\":\"4\",\"18\":\"4#强化学习框架图\",\"19\":\"4#_1-基本概念\",\"20\":\"4#_2-markov-decision-process-mdp\",\"21\":\"4@0\",\"22\":\"4@1\",\"23\":\"5\",\"24\":\"5#_1-the-simplest-actor-critic-qac\",\"25\":\"5#_2-advantage-actor-critic-a2c\",\"26\":\"5#_2-1-baseline\",\"27\":\"5#_2-2-最好的-baseline\",\"28\":\"5#_2-3-对应算法\",\"29\":\"5#_3-off-policy-actor-critic\",\"30\":\"5#_3-1-重要性采样-importance-sampling\",\"31\":\"5#_3-2-off-policy\",\"32\":\"5#_3-3-伪代码\",\"33\":\"5#_4-deterministic-actor-critic-dpg\",\"34\":\"5@0\",\"35\":\"5@1\",\"36\":\"6\",\"37\":\"6#核心内容\",\"38\":\"6#_1-state-value\",\"39\":\"6#_1-1\",\"40\":\"6#_1-2-state-value\",\"41\":\"6#_1-3-state-value-与-return-的区别\",\"42\":\"6#_2-bellman-equation\",\"43\":\"6#_2-1-the-mean-of-immediate-rewards\",\"44\":\"6#_2-2-the-mean-of-future-rewards\",\"45\":\"6#_2-3-bellman-equation\",\"46\":\"6#_2-4-bellman-equation-matrix-vector-form\",\"47\":\"6#_3-why-to-slove-state-value\",\"48\":\"6#_4-action-value\",\"49\":\"6#_5-总结\",\"50\":\"6@0\",\"51\":\"6@1\",\"52\":\"7\",\"53\":\"7#_1-optimal-policy\",\"54\":\"7#_2-bellman-optimality-equation-boe\",\"55\":\"7#_2-1-基本形式\",\"56\":\"7#_2-2-如何求解\",\"57\":\"7#_2-2-1-如何处理等式右边的-最优策略\",\"58\":\"7#_2-求解-state-value\",\"59\":\"7@0\",\"60\":\"7@1\",\"61\":\"8\",\"62\":\"8#_1-value-iteration-algorithm\",\"63\":\"8#_1-1-具体步骤\",\"64\":\"8#_1-2-伪代码\",\"65\":\"8#_2-policy-iteration-algorithm\",\"66\":\"8#_2-1-算法描述\",\"67\":\"8#_2-2-伪代码\",\"68\":\"8#_2-3-一些问题\",\"69\":\"8#_3-truncated-policy-iteration-algorithm\",\"70\":\"8#_3-1-value-iteration-与-policy-iteration-算法比较\",\"71\":\"8#_3-2-truncated-policy-iteration-algorithm\",\"72\":\"8#truncated-policy-iteration-algorithm-是否是收敛的\",\"73\":\"8@0\",\"74\":\"8@1\",\"75\":\"9\",\"76\":\"9#_1-mc-basic\",\"77\":\"9#_1-1-算法思路\",\"78\":\"9#_1-2-如何估计\",\"79\":\"9#_1-3-具体算法\",\"80\":\"9#_2-mc-exploring-starts\",\"81\":\"9#_2-1-episode-的高效利用\",\"82\":\"9#_2-2-高效地更新-policy\",\"83\":\"9#_2-3-mc-exploring-starts\",\"84\":\"9#_2-4-exploring-statrts的解释\",\"85\":\"9#_3-mc-eplison-greedy\",\"86\":\"9#_3-1-soft-policy\",\"87\":\"9#_3-2-greedy-policy\",\"88\":\"9#_3-3-greedy-policy-引入-mc-based-算法中\",\"89\":\"9#_3-3-算法流程\",\"90\":\"9@0\",\"91\":\"9@1\",\"92\":\"10\",\"93\":\"10#_1-引言\",\"94\":\"10#_1-1-求均值的方法\",\"95\":\"10#_2-robbins-monto-rm-algorithm\",\"96\":\"10#_2-1-问题引入\",\"97\":\"10#_2-2-算法介绍\",\"98\":\"10#_2-3-收敛性分析\",\"99\":\"10#_2-4-应用于-mean-estimation-中\",\"100\":\"10#_3-stochastic-gradient-descent\",\"101\":\"10#_3-1-问题引入\",\"102\":\"10#_3-2-sgd-分析\",\"103\":\"10#mean-estimation-问题转化\",\"104\":\"10#sgd-正确性和收敛性分析\",\"105\":\"10#_3-3-sgd-另一种问题描述方法-deterministic-formulation\",\"106\":\"10#_3-4-bgd-mbgd-sgdw\",\"107\":\"10@0\",\"108\":\"10@1\",\"109\":\"11\",\"110\":\"11#_1-引入\",\"111\":\"11#_2-td-learning-of-state-value\",\"112\":\"11#_2-1-算法描述\",\"113\":\"11#_2-2-算法分析\",\"114\":\"11#_2-3-td-算法-与-mc-算法的比较\",\"115\":\"11#_3-td-learning-of-action-value\",\"116\":\"11#_3-1-sarsa\",\"117\":\"11#_3-2-n-step-sarsa\",\"118\":\"11#_3-3-expected-sarsa\",\"119\":\"11#_4-td-learning-of-optimal-action-value\",\"120\":\"11#_4-1-q-learning\",\"121\":\"11#_4-2-off-policy-on-policy\",\"122\":\"11#on-policy\",\"123\":\"11#off-policy\",\"124\":\"11#_4-3-q-learning-伪代码\",\"125\":\"11#off-poicy-版本\",\"126\":\"11#on-policy-版本\",\"127\":\"11#_5-td-算法的统一形式和总结\",\"128\":\"11@0\",\"129\":\"11@1\",\"130\":\"12\",\"131\":\"12#_1-引入\",\"132\":\"12#_2-alogorithm-of-state-value-estimation\",\"133\":\"12#_2-1-obejctive-function\",\"134\":\"12#uniform-distributon\",\"135\":\"12#stationary-distribution\",\"136\":\"12#_2-2-optimization-algorithms-优化算法\",\"137\":\"12#monte-carlo-learning-with-function-approximation\",\"138\":\"12#td-learning-with-function-approximation\",\"139\":\"12#_3-sarsa-with-function-approximation\",\"140\":\"12#_4-q-learning-with-function-approximation\",\"141\":\"12#_5-deep-q-learning-dqn\",\"142\":\"12#优化方法\",\"143\":\"12#经验回放-replay-buffer\",\"144\":\"12#伪代码\",\"145\":\"12@0\",\"146\":\"12@1\",\"147\":\"13\",\"148\":\"13#_1-基本思路\",\"149\":\"13#_2-目标函数定义\",\"150\":\"13#_2-1-average-state-value\",\"151\":\"13#另一种表达\",\"152\":\"13#d-s-的选择\",\"153\":\"13#_2-2-average-return-value\",\"154\":\"13#另一种表达-1\",\"155\":\"13#_3-目标函数梯度求解\",\"156\":\"13#_4-reinforce-梯度上升算法\",\"157\":\"13#reinforce-算法\",\"158\":\"13@0\",\"159\":\"13@1\",\"160\":\"14\",\"161\":\"14#类与对象\",\"162\":\"14#方法的创建与使用\",\"163\":\"14#方法的进阶使用\",\"164\":\"14#this-的使用\",\"165\":\"14#方法的重载\",\"166\":\"14#构造方法\",\"167\":\"14@0\",\"168\":\"14@1\",\"169\":\"15\",\"170\":\"15#泛型-2\",\"171\":\"15#泛型方法\",\"172\":\"15#泛型界限\",\"173\":\"15#类型擦除\",\"174\":\"15@0\",\"175\":\"15@1\",\"176\":\"16\",\"177\":\"16#集合类-1\",\"178\":\"16#集合类\",\"179\":\"16#集合类与数组区别\",\"180\":\"16#集合根接口\",\"181\":\"16#list-列表\",\"182\":\"16#arraylist\",\"183\":\"16@0\",\"184\":\"16@1\",\"185\":\"17\",\"186\":\"17#集合类-2\",\"187\":\"17#迭代器\",\"188\":\"17#iterator-简介\",\"189\":\"17#源码定义\",\"190\":\"17#不同集合类-迭代器-实现用例\",\"191\":\"17#使用示例\",\"192\":\"17#其他遍历-集合类-的方式\",\"193\":\"17#iterable-介绍\",\"194\":\"17#listiterator-介绍\",\"195\":\"17@0\",\"196\":\"17@1\",\"197\":\"18\",\"198\":\"18#集合类-3\",\"199\":\"18#quene-和-deque\",\"200\":\"18#quene-队列\",\"201\":\"18#deque-双端队列\",\"202\":\"18#其他集合类实现-队列\",\"203\":\"18#优先级队列\",\"204\":\"18#set-集合\",\"205\":\"18#hashset\",\"206\":\"18#linkedhashset\",\"207\":\"18#treeset\",\"208\":\"18@0\",\"209\":\"18@1\",\"210\":\"19\",\"211\":\"19#集合类-4\",\"212\":\"19#map\",\"213\":\"19#map-基本定义\",\"214\":\"19#hashmap\",\"215\":\"19#hashmap-底层实现\",\"216\":\"19#put-方法\",\"217\":\"19#resize-方法\",\"218\":\"19#linkedhashmap\",\"219\":\"19#treemap\",\"220\":\"19#map-的一些方法\",\"221\":\"19#compute\",\"222\":\"19#merge\",\"223\":\"19#replace\",\"224\":\"19#hashset-底层实现\",\"225\":\"19@0\",\"226\":\"19@1\",\"227\":\"20\",\"228\":\"20#stream流\",\"229\":\"20@0\",\"230\":\"20@1\",\"231\":\"21\",\"232\":\"21#collections-工具类\",\"233\":\"21#最大-最小\",\"234\":\"21#二分搜索\",\"235\":\"21#快速填充\",\"236\":\"21#空集合\",\"237\":\"21#查找位置\",\"238\":\"21@0\",\"239\":\"21@1\",\"240\":\"22\",\"241\":\"22#集合类对象相等判定\",\"242\":\"22@0\",\"243\":\"22@1\",\"244\":\"23\",\"245\":\"23#io流1\",\"246\":\"23#文件字节流\",\"247\":\"23#输入流-java-io-fileinputstream\",\"248\":\"23#文件读取\",\"249\":\"23#输出流-java-io-fileoutputstream\",\"250\":\"23#追加操作\",\"251\":\"23#文件拷贝操作实现\",\"252\":\"23#文件字符流\",\"253\":\"23#filereader\",\"254\":\"23#filewriter\",\"255\":\"23#file类\",\"256\":\"23@0\",\"257\":\"23@1\",\"258\":\"24\",\"259\":\"24#io流2\",\"260\":\"24#缓冲流\",\"261\":\"24#缓冲字节流\",\"262\":\"24#缓冲字节读取流-bufferedinputstream\",\"263\":\"24#缓冲流特性\",\"264\":\"24#_1-装饰着模式\",\"265\":\"24#_2-缓冲机制\",\"266\":\"24#_3-缓冲流可以叠加\",\"267\":\"24#缓冲字节输出流-bufferedoutputstream\",\"268\":\"24#缓冲字符流\",\"269\":\"24#缓冲字符读取流-bufferedreader\",\"270\":\"24#缓冲字符输出流-bufferedwriter\",\"271\":\"24@0\",\"272\":\"24@1\",\"273\":\"25\",\"274\":\"25#静态变量和静态方法\",\"275\":\"25#静态变量初始化\",\"276\":\"25#包的访问与控制\",\"277\":\"25#包的声明和导入\",\"278\":\"25#访问权限控制\",\"279\":\"25@0\",\"280\":\"25@1\",\"281\":\"26\",\"282\":\"26#io流3\",\"283\":\"26#转换流\",\"284\":\"26#打印流-printstream\",\"285\":\"26#输入流\",\"286\":\"26#数据流-datainputstream\",\"287\":\"26#对象流\",\"288\":\"26#对象序列化\",\"289\":\"26#serialversionuid\",\"290\":\"26#transient关键字\",\"291\":\"26@0\",\"292\":\"26@1\",\"293\":\"27\",\"294\":\"27#多线程\",\"295\":\"27#进程与线程概念\",\"296\":\"27#线程的创建和启动\",\"297\":\"27#start方法\",\"298\":\"27#run方法\",\"299\":\"27#sleep方法\",\"300\":\"27#线程的休眠和中断\",\"301\":\"27#中断\",\"302\":\"27#线程优先级\",\"303\":\"27#线程的礼让和加入\",\"304\":\"27#yield-主动让出cpu资源\",\"305\":\"27#join\",\"306\":\"27@0\",\"307\":\"27@1\",\"308\":\"28\",\"309\":\"28#多线程2\",\"310\":\"28#线程锁和线程同步\",\"311\":\"28#多线程下java内存管理\",\"312\":\"28#线程锁-synchronized\",\"313\":\"28#死锁\",\"314\":\"28@0\",\"315\":\"28@1\",\"316\":\"29\",\"317\":\"29#多线程3\",\"318\":\"29#wait-和-notify-方法\",\"319\":\"29#threadlocal\",\"320\":\"29#inheritablethreadlocal\",\"321\":\"29#定时器-timer\",\"322\":\"29#自己定义的定时器\",\"323\":\"29#timer\",\"324\":\"29#timer-不会终止\",\"325\":\"29@0\",\"326\":\"29@1\",\"327\":\"30\",\"328\":\"30#多线程4\",\"329\":\"30#守护线程\",\"330\":\"30#集合类\",\"331\":\"30#生产者与消费者\",\"332\":\"30@0\",\"333\":\"30@1\",\"334\":\"31\",\"335\":\"31#反射1\",\"336\":\"31#反射\",\"337\":\"31#java-类加载机制\",\"338\":\"31#class-类\",\"339\":\"31#获取相应类的class对象\",\"340\":\"31#基本数据类型的-class-对象\",\"341\":\"31#数组的-class-对象\",\"342\":\"31#class-对象与多态\",\"343\":\"31#类型比较\",\"344\":\"31@0\",\"345\":\"31@1\",\"346\":\"32\",\"347\":\"32#反射2\",\"348\":\"32#创建类对象-getconstructor-newinstance\",\"349\":\"32#调用类方法-getmethod-getdeclaredmethod\",\"350\":\"32#修改类的属性-getfield\",\"351\":\"32@0\",\"352\":\"32@1\",\"353\":\"33\",\"354\":\"33#反射3\",\"355\":\"33#类加载器-appclassloader-extclassloader-bootstarpclassloader\",\"356\":\"33#自己编译的类加载到-jvm-中\",\"357\":\"33@0\",\"358\":\"33@1\",\"359\":\"34\",\"360\":\"34#注解\",\"361\":\"34#预设注解\",\"362\":\"34#元注解\",\"363\":\"34#override定义\",\"364\":\"34#注解的使用\",\"365\":\"34#反射获取注解-getannotation\",\"366\":\"34@0\",\"367\":\"34@1\",\"368\":\"35\",\"369\":\"35#封装-继承和多态\",\"370\":\"35#封装\",\"371\":\"35#继承\",\"372\":\"35#object-类\",\"373\":\"35#方法重写-override\",\"374\":\"35#控制符-final\",\"375\":\"35#抽象类-abstract\",\"376\":\"35#接口-interface\",\"377\":\"35#object类中的-克隆方法\",\"378\":\"35#枚举类-enum\",\"379\":\"35@0\",\"380\":\"35@1\",\"381\":\"36\",\"382\":\"36#面向对象高级篇1\",\"383\":\"36#基本类型包装类\",\"384\":\"36#所有包装类如下\",\"385\":\"36#包装类的方法\",\"386\":\"36#特殊包装类\",\"387\":\"36@0\",\"388\":\"36@1\",\"389\":\"37\",\"390\":\"37#面向对象高级篇-2\",\"391\":\"37#数组\",\"392\":\"37#定义\",\"393\":\"37#方法\",\"394\":\"37#访问元素\",\"395\":\"37#特性\",\"396\":\"37#final性质\",\"397\":\"37#多维数组\",\"398\":\"37#可变长参数\",\"399\":\"37#main函数的-string-args\",\"400\":\"37#字符串\",\"401\":\"37#string-类\",\"402\":\"37#stringbuilder-类\",\"403\":\"37#正则表达式\",\"404\":\"37@0\",\"405\":\"37@1\",\"406\":\"38\",\"407\":\"38#内部类\",\"408\":\"38#成员内部类-属于-对象\",\"409\":\"38#静态内部类-属于-类\",\"410\":\"38#局部内部类\",\"411\":\"38#静态内部类编译特性\",\"412\":\"38#匿名内部类\",\"413\":\"38#匿名内部类特性\",\"414\":\"38#lambda表达式\",\"415\":\"38#方法引用\",\"416\":\"38@0\",\"417\":\"38@1\",\"418\":\"39\",\"419\":\"39#面向对象高级篇-4\",\"420\":\"39#异常机制\",\"421\":\"39#异常类型\",\"422\":\"39#自定义异常\",\"423\":\"39#抛出异常-throw\",\"424\":\"39#异常的处理-try-catch-finally\",\"425\":\"39#断言表达式-assert\",\"426\":\"39@0\",\"427\":\"39@1\",\"428\":\"40\",\"429\":\"40#面向对象高级篇-6\",\"430\":\"40#常用工具类\",\"431\":\"40#数学工具类-math\",\"432\":\"40#数组工具类-arrays\",\"433\":\"40@0\",\"434\":\"40@1\",\"435\":\"41\",\"436\":\"41#泛型-1\",\"437\":\"41#使用泛型的原因\",\"438\":\"41#泛型类-classname-t\",\"439\":\"41#泛型和多态\",\"440\":\"41@0\",\"441\":\"41@1\",\"442\":\"42\",\"443\":\"42#java8\",\"444\":\"42#lambda-表达式\",\"445\":\"42#匿名内部类\",\"446\":\"42#lambda-使用\",\"447\":\"42#lambda-具体规范\",\"448\":\"42#应用现有的方法函数作为方法体-方法引用\",\"449\":\"42#方法引用-举例\",\"450\":\"42#非静态方法作为方法引用\",\"451\":\"42#默认使用-类-方法\",\"452\":\"42#对象-方法\",\"453\":\"42#构造方法作为方法引用\",\"454\":\"42#optional类\",\"455\":\"42@0\",\"456\":\"42@1\",\"457\":\"43\",\"458\":\"43#java9\",\"459\":\"43#模块机制\",\"460\":\"43#简介\",\"461\":\"43#实现包的分离管理\",\"462\":\"43#提高安全性\",\"463\":\"43#介绍\",\"464\":\"43#例子\",\"465\":\"43#依赖传递-transitive\",\"466\":\"43#开启反射-open\",\"467\":\"43#指定实现-uses-provides\",\"468\":\"43#简单使用\",\"469\":\"43@0\",\"470\":\"43@1\",\"471\":\"44\",\"472\":\"44#java9\",\"473\":\"44#jshell交互式编程\",\"474\":\"44#接口中的private方法\",\"475\":\"44#集合类新增工厂方法-xx-of\",\"476\":\"44#改进的-stream-api\",\"477\":\"44#ofnullable\",\"478\":\"44#利用-stream-来迭代生成数据-iterate\",\"479\":\"44#数据截断-takewhile-dropwhile\",\"480\":\"44#其他小型变动\",\"481\":\"44@0\",\"482\":\"44@1\",\"483\":\"45\",\"484\":\"45#java10\",\"485\":\"45#局部变量类型推断-var\",\"486\":\"45#java11\",\"487\":\"45#用于lambda的形参局部变量语法\",\"488\":\"45#针对于string类的方法增强\",\"489\":\"45#全新的httpclient使用\",\"490\":\"45#httpclient类使用\",\"491\":\"45@0\",\"492\":\"45@1\",\"493\":\"46\",\"494\":\"46#java-12-16-新特性\",\"495\":\"46#新的switch语法\",\"496\":\"46#switch-新语法\",\"497\":\"46#详细规则\",\"498\":\"46#文本块-三引号\",\"499\":\"46#新的instanceof语法\",\"500\":\"46#空指针异常的改进\",\"501\":\"46#记录类型-record\",\"502\":\"46#java-17-新特性\",\"503\":\"46#密封类型-sealed-permits\",\"504\":\"46#要求\",\"505\":\"46@0\",\"506\":\"46@1\",\"507\":\"47\",\"508\":\"47#consumer\",\"509\":\"47#接口声明\",\"510\":\"47#accept\",\"511\":\"47#addthen\",\"512\":\"47#optional\",\"513\":\"47#stream\",\"514\":\"47#特点\",\"515\":\"47#操作\",\"516\":\"47#创建流\",\"517\":\"47#操作流\",\"518\":\"47#过滤-filter\",\"519\":\"47#映射-map\",\"520\":\"47#匹配\",\"521\":\"47#组合-reduce\",\"522\":\"47#转换流-collect\",\"523\":\"47#builder\",\"524\":\"47#建造者模式\",\"525\":\"47#lombok-中的-builder\",\"526\":\"47@0\",\"527\":\"47@1\",\"528\":\"48\",\"529\":\"48@0\",\"530\":\"48@1\",\"531\":\"49\",\"532\":\"49@0\",\"533\":\"49@1\",\"534\":\"50\",\"535\":\"50#写一个运行期的注解使用\",\"536\":\"50#编译期的注解使用\",\"537\":\"50@0\",\"538\":\"50@1\",\"539\":\"51\",\"540\":\"51#mvc理论基础\",\"541\":\"51#mvc介绍\",\"542\":\"51#配置环境并搭建项目\",\"543\":\"51#传统xml配置形式\",\"544\":\"51#添加依赖\",\"545\":\"51#配置-web-xml\",\"546\":\"51#配置spring上下文环境\",\"547\":\"51#resource-spring-xml\",\"548\":\"51#webapp-wrb-inf-web-xml\",\"549\":\"51#测试-编写controller\",\"550\":\"51#全注解配置形式\",\"551\":\"51#添加依赖1\",\"552\":\"51#配置初始化接口\",\"553\":\"51#配置相应配置类-enablewebmvc\",\"554\":\"51#编写对应controller\",\"555\":\"51@0\",\"556\":\"51@1\",\"557\":\"52\",\"558\":\"52#controller控制器1\",\"559\":\"52#配置视图解析器和控制器\",\"560\":\"52#编写配置项\",\"561\":\"52#创建对应controller\",\"562\":\"52#创建对应页面文件\",\"563\":\"52#前后端数据交互\",\"564\":\"52#配置静态资源\",\"565\":\"52@0\",\"566\":\"52@1\",\"567\":\"53\",\"568\":\"53#controller控制器2\",\"569\":\"53#requestmapping详解\",\"570\":\"53#辅助功能\",\"571\":\"53#通配符匹配\",\"572\":\"53#method属性\",\"573\":\"53#postmapping、-getmapping\",\"574\":\"53#params属性\",\"575\":\"53#获取请求参数\",\"576\":\"53#header属性\",\"577\":\"53#其余属性\",\"578\":\"53#requestparam和-requestheader详解\",\"579\":\"53#requestparam\",\"580\":\"53#require属性\",\"581\":\"53#defaultvalue\",\"582\":\"53#httpservletrequest\",\"583\":\"53#直接参数传递实体类\",\"584\":\"53#cookievalue和-sessionattrbutie\",\"585\":\"53#cookievalue\",\"586\":\"53#sessionattribute\",\"587\":\"53#重定向和请求转发\",\"588\":\"53#bean的web作用域\",\"589\":\"53#restful风格-pathvariable\",\"590\":\"53@0\",\"591\":\"53@1\",\"592\":\"54\",\"593\":\"54#interceptor拦截器\",\"594\":\"54#创建拦截器\",\"595\":\"54#handlerinterceptor接口\",\"596\":\"54#配置类注册\",\"597\":\"54#执行结果\",\"598\":\"54#返回-false-情况\",\"599\":\"54#发生异常情况\",\"600\":\"54#多级拦截器\",\"601\":\"54#order\",\"602\":\"54#异常处理\",\"603\":\"54#controlleradvice\",\"604\":\"54#exceptionhandler-exception-class\",\"605\":\"54#应用\",\"606\":\"54@0\",\"607\":\"54@1\",\"608\":\"55\",\"609\":\"55#json数据格式与axios请求\",\"610\":\"55#json数据格式\",\"611\":\"55#后端处理-json-格式数据\",\"612\":\"55#jsonobject\",\"613\":\"55#jsonarray\",\"614\":\"55#循环引用情况\",\"615\":\"55#实体类转换json\",\"616\":\"55#自动转换\",\"617\":\"55#axios异步请求\",\"618\":\"55#实现文件上传和下载\",\"619\":\"55#文件上传\",\"620\":\"55#文件下载\",\"621\":\"55@0\",\"622\":\"55@1\",\"623\":\"56\",\"624\":\"56#解读dispatcherservlet源码\",\"625\":\"56#源码分析\",\"626\":\"56#dispatcherservlet调度\",\"627\":\"56@0\",\"628\":\"56@1\",\"629\":\"57\",\"630\":\"57#mvc\",\"631\":\"57#handlemapping\",\"632\":\"57@0\",\"633\":\"57@1\",\"634\":\"58\",\"635\":\"58#springsecurity\",\"636\":\"58#测试环境搭建\",\"637\":\"58@0\",\"638\":\"58@1\",\"639\":\"59\",\"640\":\"59#springsecurity2\",\"641\":\"59#csrf跨站请求伪造攻击\",\"642\":\"59#sfa会话固定攻击\",\"643\":\"59#xss跨站脚本攻击\",\"644\":\"59@0\",\"645\":\"59@1\",\"646\":\"60\",\"647\":\"60#springsecurity3\",\"648\":\"60#springsecurity-环境配置\",\"649\":\"60#模块导入\",\"650\":\"60#初始化器配置\",\"651\":\"60#配置类\",\"652\":\"60#添加配置类\",\"653\":\"60@0\",\"654\":\"60@1\",\"655\":\"61\",\"656\":\"61#认证\",\"657\":\"61#基于内存验证\",\"658\":\"61#userdetailsservice\",\"659\":\"61#加密工具-bcrypt\",\"660\":\"61#_403-权限问题-csrf\",\"661\":\"61#基于数据库验证\",\"662\":\"61#建立数据库\",\"663\":\"61#添加依赖\",\"664\":\"61#配置类\",\"665\":\"61#userdetailsmanager-接口\",\"666\":\"61#简单重置密码接口\",\"667\":\"61#自定义验证\",\"668\":\"61#自行实现-userdetailsservice-接口\",\"669\":\"61#构建实体类\",\"670\":\"61#构建对应-mapper-接口\",\"671\":\"61#注册对应包扫描\",\"672\":\"61#service端进行查询\",\"673\":\"61@0\",\"674\":\"61@1\",\"675\":\"62\",\"676\":\"62#其他配置\",\"677\":\"62#自定义登录界面\",\"678\":\"62#注册静态资源\",\"679\":\"62#添加路径匹配\",\"680\":\"62#自定义登录设置-securityfilterchain-formlogin\",\"681\":\"62#静态资源权限处理-requestmatchers\",\"682\":\"62#前端登录设置\",\"683\":\"62#退出登录操作配置-logout\",\"684\":\"62#取消-csrf-校验\",\"685\":\"62#记住我功能\",\"686\":\"62#rememberme\",\"687\":\"62#persistenttokenrepository-tokenrespository\",\"688\":\"62@0\",\"689\":\"62@1\",\"690\":\"63\",\"691\":\"63#授权\",\"692\":\"63#基于角色授权\",\"693\":\"63#基于权限授权\",\"694\":\"63#使用注解权限判断\",\"695\":\"63#enablemethodsecurity\",\"696\":\"63#preauthorize注解\",\"697\":\"63#postauthorize注解\",\"698\":\"63#其它\",\"699\":\"63#prefilter和-postfilter-过滤\",\"700\":\"63@0\",\"701\":\"63@1\",\"702\":\"64\",\"703\":\"64#内部机制探究\",\"704\":\"64#授权校验流程\",\"705\":\"64#abstractsecuritywebapplicationinitializer\",\"706\":\"64#delegatingfilterproxy\",\"707\":\"64#dofilter-操作\",\"708\":\"64#filterchainproxy\",\"709\":\"64#this-filterchaindecorator\",\"710\":\"64#虚拟过滤器链-filterchainproxy-virtualfilterchain\",\"711\":\"64#具体内部过滤器举例-usernamepasswordauthenticationfilter\",\"712\":\"64#successfulauthentication和unsuccessfulauthentication\",\"713\":\"64#unsuccessfulauthentication\",\"714\":\"64#其他过滤器\",\"715\":\"64@0\",\"716\":\"64@1\",\"717\":\"65\",\"718\":\"65#socket\",\"719\":\"65#socket-连接示例\",\"720\":\"65#使用socket进行数据传输\",\"721\":\"65#杂项\",\"722\":\"65@0\",\"723\":\"65@1\",\"724\":\"66\",\"725\":\"66#socket2\",\"726\":\"66#socket-传输文件\",\"727\":\"66#使用浏览器访问socket服务器\",\"728\":\"66@0\",\"729\":\"66@1\",\"730\":\"67\",\"731\":\"67#数据库-1\",\"732\":\"67#简介\",\"733\":\"67#数据模型\",\"734\":\"67#数据库创建\",\"735\":\"67#数据库的规范化\",\"736\":\"67#第一范式-1nf\",\"737\":\"67#第二范式-2nf\",\"738\":\"67#第三范式-3nf\",\"739\":\"67#bcnf\",\"740\":\"67@0\",\"741\":\"67@1\",\"742\":\"68\",\"743\":\"68#数据库-2\",\"744\":\"68#sql-语句\",\"745\":\"68#数据库定义语言-ddl\",\"746\":\"68#sql数据类型\",\"747\":\"68#列级约束条件\",\"748\":\"68#表级约束条件\",\"749\":\"68#数据库操作\",\"750\":\"68#创建表-create\",\"751\":\"68#修改表-alter\",\"752\":\"68#删除表-drop\",\"753\":\"68#数据库操纵语言-dml\",\"754\":\"68#插入数据-insert-into\",\"755\":\"68#修改数据-update\",\"756\":\"68#删除数据\",\"757\":\"68@0\",\"758\":\"68@1\",\"759\":\"69\",\"760\":\"69#数据库-3\",\"761\":\"69#数据库查询语言-dql\",\"762\":\"69#单表查询-selecet\",\"763\":\"69#常用where查询条件\",\"764\":\"69#排序查询-order-by\",\"765\":\"69#聚集函数\",\"766\":\"69#分组和分页查询\",\"767\":\"69#多表查询\",\"768\":\"69#自身连接查询\",\"769\":\"69#外连接查询\",\"770\":\"69#嵌套查询\",\"771\":\"69#数据库控制语言-dcl\",\"772\":\"69#创建用户\",\"773\":\"69#登陆用户\",\"774\":\"69#用户授权\",\"775\":\"69@0\",\"776\":\"69@1\",\"777\":\"70\",\"778\":\"70#数据库-4\",\"779\":\"70#视图\",\"780\":\"70#索引\",\"781\":\"70#触发器\",\"782\":\"70#事务\",\"783\":\"70@0\",\"784\":\"70@1\",\"785\":\"71\",\"786\":\"71#主要内容\",\"787\":\"71#jdbc\",\"788\":\"71#使用jdbc连接数据库\",\"789\":\"71#drivermanager\",\"790\":\"71#了解connection\",\"791\":\"71#了解statement\",\"792\":\"71@0\",\"793\":\"71@1\",\"794\":\"72\",\"795\":\"72#jdbc\",\"796\":\"72#执行dml操作-executeupdate\",\"797\":\"72#执行dql操作-executequery\",\"798\":\"72#执行批处理操作-addbatch\",\"799\":\"72#将查询结果映射为对象\",\"800\":\"72@0\",\"801\":\"72@1\",\"802\":\"73\",\"803\":\"73#jdbc\",\"804\":\"73#实现登陆与sql注入攻击\",\"805\":\"73#使用preparedstatement\",\"806\":\"73#管理事务\",\"807\":\"73@0\",\"808\":\"73@1\",\"809\":\"74\",\"810\":\"74#lombok1\",\"811\":\"74#配置lombok\",\"812\":\"74#使用lombok\",\"813\":\"74@0\",\"814\":\"74@1\",\"815\":\"75\",\"816\":\"75#mybatis1\",\"817\":\"75#xml语言\",\"818\":\"75#转义字符\",\"819\":\"75#解析xml文件\",\"820\":\"75@0\",\"821\":\"75@1\",\"822\":\"76\",\"823\":\"76#mybatis2\",\"824\":\"76#初次使用-mybatis\",\"825\":\"76#sqlsessionfactory\",\"826\":\"76#直接读取实体类\",\"827\":\"76@0\",\"828\":\"76@1\",\"829\":\"77\",\"830\":\"77#mybatis详解1\",\"831\":\"77#查询操作\",\"832\":\"77#别名\",\"833\":\"77#hashmap-转换\",\"834\":\"77#多参数查询\",\"835\":\"77#resultmap\",\"836\":\"77#查询列表操作\",\"837\":\"77@0\",\"838\":\"77@1\",\"839\":\"78\",\"840\":\"78#mybatis详解2\",\"841\":\"78#指定构造方法\",\"842\":\"78#接口绑定-sqlsession-getmapper-xxx-class\",\"843\":\"78#多参数表示\",\"844\":\"78@0\",\"845\":\"78@1\",\"846\":\"79\",\"847\":\"79#mybatis详解3\",\"848\":\"79#复杂查询\",\"849\":\"79#一对一查询\",\"850\":\"79#嵌套结果映射-association\",\"851\":\"79#嵌套-select-查询-select-association\",\"852\":\"79#mybatis日志\",\"853\":\"79#一对多查询-查询一个-返回多个\",\"854\":\"79#嵌套查询\",\"855\":\"79#多对一查询-多-多\",\"856\":\"79@0\",\"857\":\"79@1\",\"858\":\"80\",\"859\":\"80#mybatis详解4\",\"860\":\"80#dml-操作\",\"861\":\"80#插入-insert标签\",\"862\":\"80#自增主键id-usegeneratedkeys\",\"863\":\"80#修改-update标签\",\"864\":\"80#删除\",\"865\":\"80#事务操作\",\"866\":\"80@0\",\"867\":\"80@1\",\"868\":\"81\",\"869\":\"81#mybatis详解5\",\"870\":\"81#动态sql\",\"871\":\"81#批处理-executortype-batch\",\"872\":\"81#动态sql介绍\",\"873\":\"81#条件判断-if标签\",\"874\":\"81#选择判断-choose\",\"875\":\"81#实现批量处理-foreach\",\"876\":\"81#批量删除\",\"877\":\"81#批量插入\",\"878\":\"81@0\",\"879\":\"81@1\",\"880\":\"82\",\"881\":\"82#mybatis详解6\",\"882\":\"82#缓存机制\",\"883\":\"82#一级缓存-作用在sqlsession\",\"884\":\"82#二级缓存-作用在mapper\",\"885\":\"82#查找顺序\",\"886\":\"82#单独配置取消二级缓存-usecache-false\",\"887\":\"82#操作结束-清除所有缓存-flushcache\",\"888\":\"82#缓存一致性问题\",\"889\":\"82@0\",\"890\":\"82@1\",\"891\":\"83\",\"892\":\"83#mybatis详解7\",\"893\":\"83#使用注解开发\",\"894\":\"83#调整-mybatis-config-xml\",\"895\":\"83#修改对应接口-注解\",\"896\":\"83#举例\",\"897\":\"83#配置这些额外的参数-options\",\"898\":\"83#实体类字段名称与数据库不同-results\",\"899\":\"83#结合xml配置\",\"900\":\"83#指定构造方法-constructorargs\",\"901\":\"83#关联查询-注解只支持嵌套查询\",\"902\":\"83#动态sql配置-selectprovider注解\",\"903\":\"83#二级缓存配置-cachenamespace\",\"904\":\"83#configuration\",\"905\":\"83@0\",\"906\":\"83@1\",\"907\":\"84\",\"908\":\"84#jul日志系统\",\"909\":\"84#jul基本使用\",\"910\":\"84#级别划分\",\"911\":\"84#自定义级别设置-logger-log\",\"912\":\"84#修改日志的默认打印级别\",\"913\":\"84@0\",\"914\":\"84@1\",\"915\":\"85\",\"916\":\"85#jul日志系统2\",\"917\":\"85#日志核心内容\",\"918\":\"85#核心部分-handler\",\"919\":\"85#consolehandler\",\"920\":\"85#filehandler\",\"921\":\"85#修改输出格式-formatter\",\"922\":\"85@0\",\"923\":\"85@1\",\"924\":\"86\",\"925\":\"86#jul日志系统3\",\"926\":\"86#日志继承关系\",\"927\":\"86#rootlogger\",\"928\":\"86#修改默认情况下的打印等级\",\"929\":\"86#重复logger问题\",\"930\":\"86#名称分级-自动构建继承关系\",\"931\":\"86@0\",\"932\":\"86@1\",\"933\":\"87\",\"934\":\"87#jul日志系统4\",\"935\":\"87#日志默认配置\",\"936\":\"87#properties-格式\",\"937\":\"87#java读取properties\",\"938\":\"87#获取系统数据getproperties\",\"939\":\"87#jul设置默认配置-logmanger\",\"940\":\"87@0\",\"941\":\"87@1\",\"942\":\"88\",\"943\":\"88#jul日志系统5\",\"944\":\"88#自定义日志格式\",\"945\":\"88#修改对应formatter\",\"946\":\"88#手动修改-setformatter\",\"947\":\"88#配置文件修改\",\"948\":\"88#自定义例子\",\"949\":\"88#第三方框架兼容性\",\"950\":\"88#lombok日志注解\",\"951\":\"88#mybatis日志\",\"952\":\"88@0\",\"953\":\"88@1\",\"954\":\"89\",\"955\":\"89#junit单元测试1\",\"956\":\"89#单元测试\",\"957\":\"89#junit使用\",\"958\":\"89#导入依赖\",\"959\":\"89#使用-注解-test\",\"960\":\"89#跳过某个测试-disable\",\"961\":\"89#测试自定义名称-displayname\",\"962\":\"89#预设的名称生成器-displaynamegeneration\",\"963\":\"89#判断测试是否成功-—-断言-assertions\",\"964\":\"89@0\",\"965\":\"89@1\",\"966\":\"90\",\"967\":\"90#junit单元测试2\",\"968\":\"90#断言工具-assertions\",\"969\":\"90#值判断-assertions-assertequals\",\"970\":\"90#真假判断-assertions-assertture-false\",\"971\":\"90#对象判断-assertions-assertsame\",\"972\":\"90#复杂判断\",\"973\":\"90#异常判断-assertions-assertthrows\",\"974\":\"90#假设工具-assumptions\",\"975\":\"90#条件测试和执行\",\"976\":\"90#指定操作系统-enabledonos\",\"977\":\"90#指定jdk版本-enableonjre\",\"978\":\"90#指定jdk版本范围-enableonjrerange-min-xxx-max-xxx\",\"979\":\"90#系统属性判断-enabledifsystemproperty\",\"980\":\"90#自定义方法-enabledif-xxx\",\"981\":\"90@0\",\"982\":\"90@1\",\"983\":\"91\",\"984\":\"91#junit单元测试3\",\"985\":\"91#生命周期\",\"986\":\"91#测试类的生命周期\",\"987\":\"91#测试顺序控制-testmethodorder-xxx-class\",\"988\":\"91#嵌套测试-nested\",\"989\":\"91#重复和参数化测试\",\"990\":\"91#重复测试-repeatedtest-x\",\"991\":\"91#参数化测试-parameterizedtest-valuesource\",\"992\":\"91#空值-nullsource\",\"993\":\"91#枚举值-enumsource-xx-class\",\"994\":\"91#特定的方法来生成参数\",\"995\":\"91#字段\",\"996\":\"91@0\",\"997\":\"91@1\",\"998\":\"92\",\"999\":\"92#maven1-简介与项目结构\",\"1000\":\"92#简介\",\"1001\":\"92#maven项目结构\",\"1002\":\"92#核心配置-pom-xml\",\"1003\":\"92#项目标识\",\"1004\":\"92@0\",\"1005\":\"92@1\",\"1006\":\"93\",\"1007\":\"93#maven2\",\"1008\":\"93#maven依赖导入\",\"1009\":\"93#maven依赖管理原理\",\"1010\":\"93#修改国内镜像源\",\"1011\":\"93@0\",\"1012\":\"93@1\",\"1013\":\"94\",\"1014\":\"94#maven3-依赖作用域\",\"1015\":\"94#maven依赖作用域\",\"1016\":\"94#scope-属性\",\"1017\":\"94#测试导入\",\"1018\":\"94#第四个作用域-导入本地jar包\",\"1019\":\"94@0\",\"1020\":\"94@1\",\"1021\":\"95\",\"1022\":\"95#maven4-导入本地依赖\",\"1023\":\"95#maven项目导入自己项目-mvn-install\",\"1024\":\"95#依赖传递\",\"1025\":\"95#可选依赖-optional\",\"1026\":\"95#排除依赖中的不必要依赖-exclusion\",\"1027\":\"95@0\",\"1028\":\"95@1\",\"1029\":\"96\",\"1030\":\"96#maven5-继承、多模块-测试和打包\",\"1031\":\"96#maven继承和多模块\",\"1032\":\"96#继承\",\"1033\":\"96#多模块-dependencymanagement\",\"1034\":\"96#maven测试和打包\",\"1035\":\"96#test-命令\",\"1036\":\"96#package-命令\",\"1037\":\"96#打包成可执行文件-maven-assembly-plugin\",\"1038\":\"96#多模块测试打包\",\"1039\":\"96@0\",\"1040\":\"96@1\",\"1041\":\"97\",\"1042\":\"97#网络基础1\",\"1043\":\"97@0\",\"1044\":\"97@1\",\"1045\":\"98\",\"1046\":\"98#网络基础2\",\"1047\":\"98#tomact-安装\",\"1048\":\"98#idea-maven-构建-web-项目\",\"1049\":\"98@0\",\"1050\":\"98@1\",\"1051\":\"99\",\"1052\":\"99#网络基础3\",\"1053\":\"99#servlet\",\"1054\":\"99#创建servlet\",\"1055\":\"99#servlet-的生命周期\",\"1056\":\"99#service-方法\",\"1057\":\"99#servletrequest-内容\",\"1058\":\"99#servletresponse-内容\",\"1059\":\"99#httpservlet\",\"1060\":\"99#webservlet注解详解\",\"1061\":\"99#不同路径配置\",\"1062\":\"99#替换默认路径\",\"1063\":\"99#配置多个访问路径\",\"1064\":\"99#loadonstartup-属性\",\"1065\":\"99@0\",\"1066\":\"99@1\",\"1067\":\"100\",\"1068\":\"100#servlet2\",\"1069\":\"100#使用post请求完成登陆\",\"1070\":\"100#实现简单登录功能\",\"1071\":\"100#mybatis-配置\",\"1072\":\"100#实现登录功能\",\"1073\":\"100#上传和下载文件\",\"1074\":\"100#下载\",\"1075\":\"100#上传\",\"1076\":\"100#使用xhr请求数据\",\"1077\":\"100@0\",\"1078\":\"100@1\",\"1079\":\"101\",\"1080\":\"101#servlet3\",\"1081\":\"101#重定向与请求转发\",\"1082\":\"101#重定向-302-resp-sendredirect\",\"1083\":\"101#请求转发\",\"1084\":\"101#servletcontext对象-全局存储通信\",\"1085\":\"101#初始化参数-webinitparam\",\"1086\":\"101#全局定义初始化参数\",\"1087\":\"101@0\",\"1088\":\"101@1\",\"1089\":\"102\",\"1090\":\"102#cookie\",\"1091\":\"102#简单使用\",\"1092\":\"102#属性\",\"1093\":\"102#应用\",\"1094\":\"102#session\",\"1095\":\"102#原理\",\"1096\":\"102#应用-session\",\"1097\":\"102#session-配置\",\"1098\":\"102@0\",\"1099\":\"102@1\",\"1100\":\"103\",\"1101\":\"103#filter\",\"1102\":\"103#添加过滤器-filter\",\"1103\":\"103#允许请求通过-filterchain-dofilter\",\"1104\":\"103#httpfilter-接口\",\"1105\":\"103#listener\",\"1106\":\"103@0\",\"1107\":\"103@1\",\"1108\":\"104\",\"1109\":\"104#tomcat类加载机制\",\"1110\":\"104@0\",\"1111\":\"104@1\",\"1112\":\"105\",\"1113\":\"105#spring-简介\",\"1114\":\"105#ioc理论基础-1\",\"1115\":\"105#ioc理论介绍\",\"1116\":\"105#以前耦合情况\",\"1117\":\"105#ioc理论\",\"1118\":\"105#第一个spring项目\",\"1119\":\"105#使用-bean\",\"1120\":\"105@0\",\"1121\":\"105@1\",\"1122\":\"106\",\"1123\":\"106#ioc理论基础-2\",\"1124\":\"106#bean注册与配置\",\"1125\":\"106#配置并注册bean\",\"1126\":\"106#创建对象的类存在多个对应bean\",\"1127\":\"106#name属性\",\"1128\":\"106#alias别名\",\"1129\":\"106#ioc容器对象生成原理\",\"1130\":\"106#懒加载-lazy-init\",\"1131\":\"106#规定加载顺序-depends-on\",\"1132\":\"106#依赖注入\",\"1133\":\"106#property-标签\",\"1134\":\"106#构造注入-constructor-arg-标签\",\"1135\":\"106#多种构造函数情况\",\"1136\":\"106#集合类型情况\",\"1137\":\"106#自动装配-autowire-属性\",\"1138\":\"106#byname-bytype\",\"1139\":\"106#constructor\",\"1140\":\"106#候选名单-autowire-candidate\",\"1141\":\"106#优先选择-primary\",\"1142\":\"106@0\",\"1143\":\"106@1\",\"1144\":\"107\",\"1145\":\"107#ioc理论基础-3\",\"1146\":\"107#bean生命周期与继承\",\"1147\":\"107#初始化-init-method-和-销毁-destroy-method\",\"1148\":\"107#初始化和销毁的时机\",\"1149\":\"107#继承-属性继承-parent\",\"1150\":\"107#单独配置其他属性\",\"1151\":\"107#抽象bean\",\"1152\":\"107#默认全局配置\",\"1153\":\"107@0\",\"1154\":\"107@1\",\"1155\":\"108\",\"1156\":\"108#ioc理论基础-4\",\"1157\":\"108#工厂模式和工厂bean\",\"1158\":\"108#factory-method\",\"1159\":\"108#工厂bean-factory-bean\",\"1160\":\"108#直接继承factorybean\",\"1161\":\"108@0\",\"1162\":\"108@1\",\"1163\":\"109\",\"1164\":\"109#ioc理论基础-5\",\"1165\":\"109#使用注解开发\",\"1166\":\"109#annotationconfigapplicationcontext\",\"1167\":\"109#注册bean-bean-xxx\",\"1168\":\"109#引入其他配置类-import\",\"1169\":\"109#具体使用\",\"1170\":\"109#bean设置的配置\",\"1171\":\"109#其他注解设置的配置-lazy-单例-原型-scope-等\",\"1172\":\"109#依赖注入的配置\",\"1173\":\"109#自动装配-autowired\",\"1174\":\"109#指定装配-qualifier\",\"1175\":\"109#resource-移除\",\"1176\":\"109#初始化和销毁注解\",\"1177\":\"109#component-常用注册bean方式\",\"1178\":\"109#默认name命名\",\"1179\":\"109#其他\",\"1180\":\"109#工厂模式处理\",\"1181\":\"109#讨论\",\"1182\":\"109@0\",\"1183\":\"109@1\",\"1184\":\"110\",\"1185\":\"110#spring高级特性1\",\"1186\":\"110#bean-aware\",\"1187\":\"110#任务调度\",\"1188\":\"110#异步任务执行-async\",\"1189\":\"110#原理\",\"1190\":\"110#定时任务-scheduled\",\"1191\":\"110#监听器-applicationlistener-xxx\",\"1192\":\"110#自定义事件-applicationevent\",\"1193\":\"110@0\",\"1194\":\"110@1\",\"1195\":\"111\",\"1196\":\"111#springel表达式\",\"1197\":\"111#外部属性注入\",\"1198\":\"111#propertysource\",\"1199\":\"111#value\",\"1200\":\"111#方法参数注入\",\"1201\":\"111#spel表达式\",\"1202\":\"111#创建spel表达式\",\"1203\":\"111#exp-getvalue\",\"1204\":\"111#exp-setvalue\",\"1205\":\"111#导入-t\",\"1206\":\"111#集合操作相关语法\",\"1207\":\"111#选取元素\",\"1208\":\"111#创建\",\"1209\":\"111#条件获取\",\"1210\":\"111#投影集合\",\"1211\":\"111#安全导航运算符\",\"1212\":\"111@0\",\"1213\":\"111@1\",\"1214\":\"112\",\"1215\":\"112#aop面向切片\",\"1216\":\"112#使用配置实现aop\",\"1217\":\"112#准备\",\"1218\":\"112#例子\",\"1219\":\"112#建立切点-aop-pointcut\",\"1220\":\"112#选择增强方法-aop-aspect\",\"1221\":\"112#测试\",\"1222\":\"112#分析\",\"1223\":\"112#joinpoint-获取切点信息\",\"1224\":\"112#around环绕方法\",\"1225\":\"112#实现异步效果\",\"1226\":\"112#术语\",\"1227\":\"112@0\",\"1228\":\"112@1\",\"1229\":\"113\",\"1230\":\"113#aop面向切片2\",\"1231\":\"113#使用接口实现aop\",\"1232\":\"113#使用注解实现aop\",\"1233\":\"113#定义增强方法-aspect-before\",\"1234\":\"113#添加joinpoint参数\",\"1235\":\"113#命名绑定模式\",\"1236\":\"113#其他注解\",\"1237\":\"113#环绕\",\"1238\":\"113@0\",\"1239\":\"113@1\",\"1240\":\"114\",\"1241\":\"114#数据库框架整合1\",\"1242\":\"114#数据源-datasource接口\",\"1243\":\"114#mybatis数据源实现\",\"1244\":\"114#不使用池化的数据源-unpooleddatasource\",\"1245\":\"114#池化的数据源-pooleddatasource\",\"1246\":\"114#popconnection方法\",\"1247\":\"114#getproxyconnection-代理对象\",\"1248\":\"114@0\",\"1249\":\"114@1\",\"1250\":\"115\",\"1251\":\"115#数据库框架整合2\",\"1252\":\"115#整合mybatis框架\",\"1253\":\"115#使用例子\",\"1254\":\"115#sqlsessiontemplate类\",\"1255\":\"115#其他配置\",\"1256\":\"115#测试\",\"1257\":\"115#自动管理mapper-mapperscan\",\"1258\":\"115#全注解配置\",\"1259\":\"115#继承sqlsessionfactorybean类\",\"1260\":\"115#hikaricp连接池\",\"1261\":\"115@0\",\"1262\":\"115@1\",\"1263\":\"116\",\"1264\":\"116#数据库框架整合3\",\"1265\":\"116#mybatis事务管理\",\"1266\":\"116#事务机制回顾\",\"1267\":\"116#隔离机制\",\"1268\":\"116#读未提交\",\"1269\":\"116#读已提交\",\"1270\":\"116#可重复读\",\"1271\":\"116#串行化\",\"1272\":\"116#mybatis事务封装介绍\",\"1273\":\"116#transaction接口实现1-——-jdbctransaction\",\"1274\":\"116#spring事务管理\",\"1275\":\"116#例子\",\"1276\":\"116#_1-事务管理器-transactionmanager\",\"1277\":\"116#_2-对应示例操作\",\"1278\":\"116#_3-测试\",\"1279\":\"116#transactional\",\"1280\":\"116#事务传播规则\",\"1281\":\"116#propagation-required级别\",\"1282\":\"116#propagation-supprots级别\",\"1283\":\"116#propagation-mandatory级别\",\"1284\":\"116#其他级别\",\"1285\":\"116@0\",\"1286\":\"116@1\",\"1287\":\"117\",\"1288\":\"117#junit整合\",\"1289\":\"117#springtest模块\",\"1290\":\"117#导入依赖\",\"1291\":\"117#加入注解-extendwith-contextconfuguration\",\"1292\":\"117@0\",\"1293\":\"117@1\",\"1294\":\"118\",\"1295\":\"118#bean工厂与bean定义\",\"1296\":\"118#beanfactory\",\"1297\":\"118#applicationcontext实现方式\",\"1298\":\"118#beanfactory继承\",\"1299\":\"118#单例bean的创建与循环依赖\",\"1300\":\"118#beanfactory分析\",\"1301\":\"118#循环依赖的解决\",\"1302\":\"118@0\",\"1303\":\"118@1\",\"1304\":\"119\",\"1305\":\"119#后置处理器与aop\",\"1306\":\"119#postprocessor\",\"1307\":\"119#beanpostprocessor\",\"1308\":\"119#执行顺序分析\",\"1309\":\"119#bean加载流程\",\"1310\":\"119#aop实现过程\",\"1311\":\"119#importbeandefinitionregistrar\",\"1312\":\"119@0\",\"1313\":\"119@1\",\"1314\":\"120\",\"1315\":\"120#应用程序上下文详解\",\"1316\":\"120#applicationcontext接口\",\"1317\":\"120#分析\",\"1318\":\"120#调用无参构造\",\"1319\":\"120#注册配置类\",\"1320\":\"120#refresh机制\",\"1321\":\"120#finishbeanfactoryinitialization-方法\",\"1322\":\"120@0\",\"1323\":\"120@1\",\"1324\":\"121\",\"1325\":\"121#mybatis整合原理\",\"1326\":\"121#mapperscan实现\",\"1327\":\"121#mapperscannerconfigurer-类\",\"1328\":\"121#factorybean和beanfactory\",\"1329\":\"121@0\",\"1330\":\"121@1\",\"1331\":\"122\",\"1332\":\"123\",\"1333\":\"124\",\"1334\":\"125\",\"1335\":\"126\",\"1336\":\"127\",\"1337\":\"128\",\"1338\":\"129\",\"1339\":\"130\",\"1340\":\"131\",\"1341\":\"132\",\"1342\":\"133\",\"1343\":\"134\",\"1344\":\"135\",\"1345\":\"136\",\"1346\":\"137\",\"1347\":\"138\",\"1348\":\"139\",\"1349\":\"140\",\"1350\":\"141\",\"1351\":\"142\",\"1352\":\"143\",\"1353\":\"144\",\"1354\":\"145\",\"1355\":\"146\",\"1356\":\"147\",\"1357\":\"148\",\"1358\":\"149\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[10,6],\"4\":[1,45],\"5\":[1,29],\"6\":[1],\"7\":[1],\"8\":[1,44],\"9\":[1,105],\"10\":[4,82],\"11\":[1,34],\"12\":[1],\"13\":[1,157],\"14\":[1,67],\"15\":[null,null,1],\"16\":[null,null,6],\"17\":[2],\"18\":[1,1],\"19\":[2,118],\"20\":[6,54],\"21\":[null,null,1],\"22\":[null,null,1],\"23\":[4,19],\"24\":[7,2],\"25\":[6,8],\"26\":[3,28],\"27\":[3,8],\"28\":[3,3],\"29\":[5,10],\"30\":[6,3],\"31\":[4,4],\"32\":[2,1],\"33\":[6,3],\"34\":[null,null,1],\"35\":[null,null,1],\"36\":[2],\"37\":[1,5],\"38\":[3],\"39\":[1,16],\"40\":[4,27],\"41\":[7,36],\"42\":[3,35],\"43\":[8,10],\"44\":[7,23],\"45\":[4,47],\"46\":[8,34],\"47\":[6,34],\"48\":[3,72],\"49\":[2,29],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[2,16],\"53\":[3,36],\"54\":[6],\"55\":[3,28],\"56\":[2,8],\"57\":[5,21],\"58\":[4,75],\"59\":[null,null,1],\"60\":[null,null,1],\"61\":[4,6],\"62\":[4,18],\"63\":[2,53],\"64\":[3,1],\"65\":[4,3],\"66\":[3,70],\"67\":[2,1],\"68\":[3,44],\"69\":[5,6],\"70\":[7,71],\"71\":[6,23],\"72\":[5,1],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[6,51],\"76\":[3,16],\"77\":[2,61],\"78\":[3,33],\"79\":[3,49],\"80\":[4,10],\"81\":[4,63],\"82\":[3,52],\"83\":[5,1],\"84\":[4,33],\"85\":[4,9],\"86\":[4,25],\"87\":[4,39],\"88\":[7,12],\"89\":[2,1],\"90\":[null,null,1],\"91\":[null,null,1],\"92\":[2,33],\"93\":[2],\"94\":[2,32],\"95\":[5],\"96\":[3,17],\"97\":[2,31],\"98\":[3,44],\"99\":[6,41],\"100\":[4],\"101\":[3,57],\"102\":[4],\"103\":[3,8],\"104\":[2,67],\"105\":[6,11],\"106\":[5,1],\"107\":[null,null,1],\"108\":[null,null,1],\"109\":[4],\"110\":[2,50],\"111\":[6,10],\"112\":[3,36],\"113\":[2,37],\"114\":[7],\"115\":[6,23],\"116\":[3,37],\"117\":[5,3],\"118\":[3,2],\"119\":[7,21],\"120\":[4,24],\"121\":[6,7],\"122\":[2,9],\"123\":[2,17],\"124\":[5,17],\"125\":[3,10],\"126\":[3,1],\"127\":[3,2],\"128\":[null,null,1],\"129\":[null,null,1],\"130\":[6,11],\"131\":[2,12],\"132\":[6,9],\"133\":[4,15],\"134\":[2,22],\"135\":[2,52],\"136\":[4,40],\"137\":[6,19],\"138\":[5,15],\"139\":[5,10],\"140\":[6,13],\"141\":[6,21],\"142\":[1,110],\"143\":[4,3],\"144\":[1,13],\"145\":[null,null,1],\"146\":[null,null,1],\"147\":[5,10],\"148\":[2,38],\"149\":[2],\"150\":[5,22],\"151\":[1,5],\"152\":[3,21],\"153\":[4,20],\"154\":[1,27],\"155\":[2,60],\"156\":[3,40],\"157\":[2,1],\"158\":[null,null,1],\"159\":[null,null,1],\"160\":[2],\"161\":[1,85],\"162\":[1,56],\"163\":[1],\"164\":[2,23],\"165\":[1,20],\"166\":[1,75],\"167\":[null,null,1],\"168\":[null,null,1],\"169\":[3],\"170\":[2],\"171\":[1,100],\"172\":[1,79],\"173\":[1,46],\"174\":[null,null,1],\"175\":[null,null,1],\"176\":[3],\"177\":[2],\"178\":[1,17],\"179\":[1,14],\"180\":[1,138],\"181\":[2,112],\"182\":[1,229],\"183\":[null,null,1],\"184\":[null,null,1],\"185\":[3],\"186\":[2],\"187\":[1,36],\"188\":[1,20],\"189\":[1,31],\"190\":[3,30],\"191\":[1,35],\"192\":[3,51],\"193\":[1,64],\"194\":[1,37],\"195\":[null,null,1],\"196\":[null,null,1],\"197\":[3],\"198\":[2],\"199\":[3,18],\"200\":[2,55],\"201\":[2,72],\"202\":[2,22],\"203\":[1,43],\"204\":[2,67],\"205\":[1,44],\"206\":[1,30],\"207\":[1,41],\"208\":[null,null,1],\"209\":[null,null,1],\"210\":[3],\"211\":[2],\"212\":[1,15],\"213\":[2,84],\"214\":[1,65],\"215\":[2,69],\"216\":[2,104],\"217\":[2,89],\"218\":[1,36],\"219\":[1,9],\"220\":[2],\"221\":[1,49],\"222\":[1,65],\"223\":[1,33],\"224\":[2,72],\"225\":[null,null,1],\"226\":[null,null,1],\"227\":[2],\"228\":[1,181],\"229\":[null,null,1],\"230\":[null,null,1],\"231\":[3],\"232\":[2,9],\"233\":[3,16],\"234\":[1,30],\"235\":[1,29],\"236\":[1,33],\"237\":[1,57],\"238\":[null,null,1],\"239\":[null,null,1],\"240\":[2],\"241\":[1,108],\"242\":[null,null,1],\"243\":[null,null,1],\"244\":[2],\"245\":[1,49],\"246\":[1],\"247\":[1,43],\"248\":[1,60],\"249\":[1,45],\"250\":[1,26],\"251\":[1,37],\"252\":[1,4],\"253\":[1,40],\"254\":[1,30],\"255\":[1,60],\"256\":[null,null,1],\"257\":[null,null,1],\"258\":[2],\"259\":[1],\"260\":[1,19],\"261\":[1],\"262\":[1,28],\"263\":[1],\"264\":[2,38],\"265\":[2,60],\"266\":[2,9],\"267\":[1,24],\"268\":[1,3],\"269\":[1,39],\"270\":[1,26],\"271\":[null,null,1],\"272\":[null,null,1],\"273\":[2],\"274\":[1,52],\"275\":[1,27],\"276\":[1],\"277\":[1,90],\"278\":[1,60],\"279\":[null,null,1],\"280\":[null,null,1],\"281\":[2],\"282\":[1],\"283\":[1,49],\"284\":[1,48],\"285\":[1,24],\"286\":[1,39],\"287\":[1,7],\"288\":[1,41],\"289\":[1,24],\"290\":[1,55],\"291\":[null,null,1],\"292\":[null,null,1],\"293\":[2],\"294\":[1],\"295\":[1,71],\"296\":[1,69],\"297\":[1,29],\"298\":[1,5],\"299\":[1,59],\"300\":[1,36],\"301\":[1,65],\"302\":[1,37],\"303\":[1],\"304\":[1,43],\"305\":[1,54],\"306\":[null,null,1],\"307\":[null,null,1],\"308\":[2],\"309\":[1],\"310\":[1],\"311\":[1,72],\"312\":[1,91],\"313\":[1,75],\"314\":[null,null,1],\"315\":[null,null,1],\"316\":[2],\"317\":[1],\"318\":[2,92],\"319\":[1,54],\"320\":[1,25],\"321\":[1],\"322\":[1,39],\"323\":[1,37],\"324\":[1,110],\"325\":[null,null,1],\"326\":[null,null,1],\"327\":[2],\"328\":[1],\"329\":[1,50],\"330\":[1,79],\"331\":[1,75],\"332\":[null,null,1],\"333\":[null,null,1],\"334\":[2],\"335\":[1],\"336\":[1,17],\"337\":[2,26],\"338\":[2,5],\"339\":[1,36],\"340\":[3,59],\"341\":[3,30],\"342\":[2],\"343\":[1,105],\"344\":[null,null,1],\"345\":[null,null,1],\"346\":[2],\"347\":[1],\"348\":[1,81],\"349\":[1,123],\"350\":[1,81],\"351\":[null,null,1],\"352\":[null,null,1],\"353\":[2],\"354\":[1],\"355\":[1,50],\"356\":[3,106],\"357\":[null,null,1],\"358\":[null,null,1],\"359\":[2],\"360\":[1,18],\"361\":[1,26],\"362\":[1,22],\"363\":[1,39],\"364\":[1,50],\"365\":[1,65],\"366\":[null,null,1],\"367\":[null,null,1],\"368\":[2],\"369\":[2,16],\"370\":[1],\"371\":[1,4],\"372\":[2,79],\"373\":[1,74],\"374\":[1,14],\"375\":[1,73],\"376\":[1,141],\"377\":[2,73],\"378\":[1,72],\"379\":[null,null,1],\"380\":[null,null,1],\"381\":[2],\"382\":[1],\"383\":[1,9],\"384\":[1,97],\"385\":[1,25],\"386\":[1,69],\"387\":[null,null,1],\"388\":[null,null,1],\"389\":[5],\"390\":[2],\"391\":[1,5],\"392\":[1,47],\"393\":[1,40],\"394\":[1,29],\"395\":[1,32],\"396\":[1,22],\"397\":[1,24],\"398\":[1,43],\"399\":[1,25],\"400\":[1,15],\"401\":[2,65],\"402\":[2,60],\"403\":[1,148],\"404\":[null,null,1],\"405\":[null,null,1],\"406\":[2,6],\"407\":[1,3],\"408\":[4,93],\"409\":[4,34],\"410\":[1,35],\"411\":[1,42],\"412\":[1,84],\"413\":[1,35],\"414\":[1,53],\"415\":[1,67],\"416\":[null,null,1],\"417\":[null,null,1],\"418\":[2],\"419\":[2],\"420\":[1],\"421\":[1,50],\"422\":[1,23],\"423\":[1,57],\"424\":[1,104],\"425\":[1,26],\"426\":[null,null,1],\"427\":[null,null,1],\"428\":[2],\"429\":[2,5],\"430\":[1],\"431\":[1,59],\"432\":[1,45],\"433\":[null,null,1],\"434\":[null,null,1],\"435\":[3],\"436\":[2],\"437\":[1,79],\"438\":[1,106],\"439\":[1,44],\"440\":[null,null,1],\"441\":[null,null,1],\"442\":[1],\"443\":[1],\"444\":[2],\"445\":[1,35],\"446\":[2,63],\"447\":[2,60],\"448\":[3,34],\"449\":[2,54],\"450\":[1],\"451\":[1,66],\"452\":[1,52],\"453\":[1,42],\"454\":[1,61],\"455\":[null,null,1],\"456\":[null,null,1],\"457\":[2],\"458\":[1,5],\"459\":[1],\"460\":[1,21],\"461\":[1,61],\"462\":[1,59],\"463\":[1,37],\"464\":[1,59],\"465\":[1,33],\"466\":[1,18],\"467\":[2,33],\"468\":[1,43],\"469\":[null,null,1],\"470\":[null,null,1],\"471\":[2],\"472\":[1],\"473\":[1,24],\"474\":[1,31],\"475\":[1,55],\"476\":[3,37],\"477\":[1,19],\"478\":[2,45],\"479\":[2,33],\"480\":[1,110],\"481\":[null,null,1],\"482\":[null,null,1],\"483\":[3],\"484\":[1,5],\"485\":[1,39],\"486\":[1,9],\"487\":[1,22],\"488\":[1,48],\"489\":[1,7],\"490\":[1,126],\"491\":[null,null,1],\"492\":[null,null,1],\"493\":[4],\"494\":[4,16],\"495\":[1,45],\"496\":[1,29],\"497\":[1,59],\"498\":[2,30],\"499\":[1,46],\"500\":[1,34],\"501\":[1,71],\"502\":[3,2],\"503\":[2,42],\"504\":[1,68],\"505\":[null,null,1],\"506\":[null,null,1],\"507\":[2],\"508\":[1,12],\"509\":[1,59],\"510\":[1,21],\"511\":[1,32],\"512\":[1,60],\"513\":[1,16],\"514\":[1,12],\"515\":[1,48],\"516\":[1,34],\"517\":[1],\"518\":[1,30],\"519\":[1,47],\"520\":[1,15],\"521\":[1,55],\"522\":[1,74],\"523\":[1,63],\"524\":[1,41],\"525\":[1,66],\"526\":[null,null,1],\"527\":[null,null,1],\"528\":[2,76],\"529\":[null,null,1],\"530\":[null,null,2],\"531\":[1,48],\"532\":[null,null,1],\"533\":[null,null,2],\"534\":[2,26],\"535\":[1,2],\"536\":[1,2],\"537\":[null,null,1],\"538\":[null,null,2],\"539\":[2],\"540\":[1,30],\"541\":[1,22],\"542\":[1,6],\"543\":[1,3],\"544\":[1,15],\"545\":[1,54],\"546\":[1,4],\"547\":[1,34],\"548\":[1,26],\"549\":[2,69],\"550\":[1,37],\"551\":[1,14],\"552\":[1,34],\"553\":[1,37],\"554\":[1,16],\"555\":[null,null,1],\"556\":[null,null,2],\"557\":[2],\"558\":[1,56],\"559\":[1,18],\"560\":[1,83],\"561\":[1,21],\"562\":[1,21],\"563\":[1,71],\"564\":[1,71],\"565\":[null,null,1],\"566\":[null,null,2],\"567\":[2],\"568\":[1],\"569\":[2,52],\"570\":[1,3],\"571\":[1,16],\"572\":[1,24],\"573\":[1,16],\"574\":[1,25],\"575\":[1,24],\"576\":[1,17],\"577\":[1,15],\"578\":[3,3],\"579\":[1,28],\"580\":[1,22],\"581\":[1,24],\"582\":[1,31],\"583\":[1,28],\"584\":[3],\"585\":[1,27],\"586\":[1,29],\"587\":[1,22],\"588\":[1,56],\"589\":[1,75],\"590\":[null,null,1],\"591\":[null,null,2],\"592\":[2],\"593\":[1,13],\"594\":[1],\"595\":[1,35],\"596\":[1,19],\"597\":[1,14],\"598\":[2,6],\"599\":[1,23],\"600\":[1,64],\"601\":[1,26],\"602\":[1,23],\"603\":[1,28],\"604\":[1,30],\"605\":[1,62],\"606\":[null,null,1],\"607\":[null,null,2],\"608\":[2],\"609\":[1,16],\"610\":[1,41],\"611\":[3,22],\"612\":[1,28],\"613\":[1,29],\"614\":[1,4],\"615\":[1,40],\"616\":[1,49],\"617\":[1,149],\"618\":[1,2],\"619\":[1,86],\"620\":[1,43],\"621\":[null,null,1],\"622\":[null,null,2],\"623\":[2],\"624\":[1,3],\"625\":[1,170],\"626\":[1,153],\"627\":[null,null,1],\"628\":[null,null,2],\"629\":[4],\"630\":[1,2],\"631\":[1,38],\"632\":[null,null,1],\"633\":[null,null,2],\"634\":[2],\"635\":[1,9],\"636\":[1,144],\"637\":[null,null,1],\"638\":[null,null,2],\"639\":[2],\"640\":[1],\"641\":[1,123],\"642\":[1,123],\"643\":[1,85],\"644\":[null,null,1],\"645\":[null,null,2],\"646\":[2],\"647\":[1],\"648\":[2],\"649\":[1,22],\"650\":[1,13],\"651\":[1,8],\"652\":[1,24],\"653\":[null,null,1],\"654\":[null,null,2],\"655\":[2],\"656\":[1,4],\"657\":[1,2],\"658\":[1,88],\"659\":[1,63],\"660\":[2,93],\"661\":[1,5],\"662\":[1,29],\"663\":[1,30],\"664\":[1,54],\"665\":[1,29],\"666\":[1,95],\"667\":[1,9],\"668\":[2,29],\"669\":[1,12],\"670\":[2,15],\"671\":[1,29],\"672\":[1,38],\"673\":[null,null,1],\"674\":[null,null,2],\"675\":[2],\"676\":[1,4],\"677\":[1,5],\"678\":[1,15],\"679\":[1,14],\"680\":[2,62],\"681\":[1,27],\"682\":[1,45],\"683\":[1,63],\"684\":[2,37],\"685\":[1,13],\"686\":[1,78],\"687\":[1,39],\"688\":[null,null,1],\"689\":[null,null,2],\"690\":[2],\"691\":[1,50],\"692\":[1,87],\"693\":[1,19],\"694\":[1],\"695\":[1,28],\"696\":[1,9],\"697\":[1,29],\"698\":[1,7],\"699\":[2,47],\"700\":[null,null,1],\"701\":[null,null,2],\"702\":[2],\"703\":[1],\"704\":[1,7],\"705\":[1,56],\"706\":[1,55],\"707\":[1,38],\"708\":[1,102],\"709\":[1,36],\"710\":[1,71],\"711\":[1,70],\"712\":[1,46],\"713\":[1,33],\"714\":[1,74],\"715\":[null,null,1],\"716\":[null,null,2],\"717\":[2],\"718\":[1,9],\"719\":[2,52],\"720\":[1,83],\"721\":[1,64],\"722\":[null,null,1],\"723\":[null,null,1],\"724\":[2],\"725\":[1],\"726\":[2,65],\"727\":[1,179],\"728\":[null,null,1],\"729\":[null,null,1],\"730\":[2],\"731\":[2],\"732\":[1,24],\"733\":[1,37],\"734\":[1,24],\"735\":[1,12],\"736\":[3,11],\"737\":[3,15],\"738\":[3,17],\"739\":[1,22],\"740\":[null,null,1],\"741\":[null,null,2],\"742\":[2],\"743\":[2],\"744\":[2,64],\"745\":[3],\"746\":[1,36],\"747\":[1,82],\"748\":[1,52],\"749\":[1,22],\"750\":[1,16],\"751\":[1,25],\"752\":[1,8],\"753\":[3],\"754\":[1,19],\"755\":[1,13],\"756\":[1,11],\"757\":[null,null,1],\"758\":[null,null,2],\"759\":[2],\"760\":[2],\"761\":[3],\"762\":[1,17],\"763\":[2,19],\"764\":[1,20],\"765\":[1,26],\"766\":[1,22],\"767\":[1,24],\"768\":[1,13],\"769\":[1,32],\"770\":[1,11],\"771\":[3,3],\"772\":[1,14],\"773\":[1,15],\"774\":[1,21],\"775\":[null,null,1],\"776\":[null,null,2],\"777\":[2],\"778\":[2],\"779\":[1,62],\"780\":[1,35],\"781\":[1,49],\"782\":[1,72],\"783\":[null,null,1],\"784\":[null,null,2],\"785\":[2],\"786\":[1,1],\"787\":[1,34],\"788\":[1,90],\"789\":[1,157],\"790\":[1,17],\"791\":[1,19],\"792\":[null,null,1],\"793\":[null,null,2],\"794\":[2],\"795\":[1],\"796\":[1,64],\"797\":[1,16],\"798\":[1,36],\"799\":[1,94],\"800\":[null,null,1],\"801\":[null,null,2],\"802\":[2],\"803\":[1],\"804\":[1,64],\"805\":[1,81],\"806\":[1,85],\"807\":[null,null,1],\"808\":[null,null,2],\"809\":[2],\"810\":[1,48],\"811\":[1,33],\"812\":[1,44],\"813\":[null,null,1],\"814\":[null,null,2],\"815\":[2],\"816\":[1,39],\"817\":[1,49],\"818\":[1,15],\"819\":[1,77],\"820\":[null,null,1],\"821\":[null,null,2],\"822\":[2],\"823\":[1],\"824\":[2,116],\"825\":[1,19],\"826\":[1,110],\"827\":[null,null,1],\"828\":[null,null,2],\"829\":[2],\"830\":[1,53],\"831\":[1,61],\"832\":[1,35],\"833\":[2,31],\"834\":[1,34],\"835\":[1,62],\"836\":[1,88],\"837\":[null,null,1],\"838\":[null,null,2],\"839\":[2],\"840\":[1],\"841\":[1,153],\"842\":[1,89],\"843\":[1,87],\"844\":[null,null,1],\"845\":[null,null,2],\"846\":[2],\"847\":[1],\"848\":[1],\"849\":[1,51],\"850\":[1,47],\"851\":[3,42],\"852\":[1,79],\"853\":[4,64],\"854\":[1,41],\"855\":[3,77],\"856\":[null,null,1],\"857\":[null,null,2],\"858\":[2],\"859\":[1],\"860\":[2,19],\"861\":[2,40],\"862\":[1,40],\"863\":[2,23],\"864\":[1,17],\"865\":[1,50],\"866\":[null,null,1],\"867\":[null,null,2],\"868\":[2],\"869\":[1],\"870\":[1],\"871\":[1,77],\"872\":[1,21],\"873\":[2,43],\"874\":[1,40],\"875\":[1,5],\"876\":[1,56],\"877\":[1,53],\"878\":[null,null,1],\"879\":[null,null,2],\"880\":[2],\"881\":[1],\"882\":[1,21],\"883\":[3,74],\"884\":[3,98],\"885\":[1,8],\"886\":[1,23],\"887\":[2,26],\"888\":[1,55],\"889\":[null,null,1],\"890\":[null,null,2],\"891\":[2],\"892\":[1],\"893\":[1,14],\"894\":[1,21],\"895\":[1,20],\"896\":[1,29],\"897\":[1,56],\"898\":[1,39],\"899\":[2,13],\"900\":[1,38],\"901\":[3,41],\"902\":[4,80],\"903\":[1,32],\"904\":[1,45],\"905\":[null,null,1],\"906\":[null,null,2],\"907\":[2],\"908\":[1,41],\"909\":[1,4],\"910\":[1,61],\"911\":[1,27],\"912\":[1,41],\"913\":[null,null,1],\"914\":[null,null,2],\"915\":[2],\"916\":[1],\"917\":[1],\"918\":[1,46],\"919\":[1,24],\"920\":[1,22],\"921\":[1,24],\"922\":[null,null,1],\"923\":[null,null,2],\"924\":[2],\"925\":[1],\"926\":[1],\"927\":[1,31],\"928\":[1,15],\"929\":[2,30],\"930\":[2,27],\"931\":[null,null,1],\"932\":[null,null,2],\"933\":[2],\"934\":[1],\"935\":[1],\"936\":[1,30],\"937\":[1,24],\"938\":[1,24],\"939\":[1,59],\"940\":[null,null,1],\"941\":[null,null,2],\"942\":[2],\"943\":[1],\"944\":[1,35],\"945\":[1],\"946\":[1,13],\"947\":[1,9],\"948\":[1,45],\"949\":[1,10],\"950\":[1,30],\"951\":[1,48],\"952\":[null,null,1],\"953\":[null,null,2],\"954\":[2],\"955\":[1],\"956\":[1,49],\"957\":[1],\"958\":[1,10],\"959\":[2,32],\"960\":[2,13],\"961\":[2,13],\"962\":[2,17],\"963\":[2,31],\"964\":[null,null,1],\"965\":[null,null,2],\"966\":[2],\"967\":[1],\"968\":[1,5],\"969\":[1,31],\"970\":[1,13],\"971\":[1,6],\"972\":[1,25],\"973\":[1,23],\"974\":[1,18],\"975\":[1,5],\"976\":[2,26],\"977\":[1,22],\"978\":[1,27],\"979\":[1,27],\"980\":[1,36],\"981\":[null,null,1],\"982\":[null,null,2],\"983\":[2],\"984\":[1],\"985\":[1,33],\"986\":[1,47],\"987\":[1,45],\"988\":[2,38],\"989\":[1,2],\"990\":[1,23],\"991\":[2,48],\"992\":[1,23],\"993\":[1,27],\"994\":[1,32],\"995\":[1,43],\"996\":[null,null,1],\"997\":[null,null,2],\"998\":[2],\"999\":[2],\"1000\":[1,46],\"1001\":[1,17],\"1002\":[1,65],\"1003\":[1,37],\"1004\":[null,null,1],\"1005\":[null,null,2],\"1006\":[2],\"1007\":[1],\"1008\":[1,58],\"1009\":[1,27],\"1010\":[1,47],\"1011\":[null,null,1],\"1012\":[null,null,2],\"1013\":[2],\"1014\":[2],\"1015\":[1,22],\"1016\":[1,39],\"1017\":[1,165],\"1018\":[2,32],\"1019\":[null,null,1],\"1020\":[null,null,2],\"1021\":[2],\"1022\":[2],\"1023\":[1,64],\"1024\":[1,25],\"1025\":[1,38],\"1026\":[1,31],\"1027\":[null,null,1],\"1028\":[null,null,2],\"1029\":[4],\"1030\":[5],\"1031\":[1],\"1032\":[1,86],\"1033\":[1,55],\"1034\":[1,21],\"1035\":[1,19],\"1036\":[1,27],\"1037\":[1,63],\"1038\":[1,19],\"1039\":[null,null,1],\"1040\":[null,null,2],\"1041\":[2],\"1042\":[1,106],\"1043\":[null,null,1],\"1044\":[null,null,1],\"1045\":[2],\"1046\":[1],\"1047\":[2,269],\"1048\":[5,17],\"1049\":[null,null,1],\"1050\":[null,null,1],\"1051\":[2],\"1052\":[1],\"1053\":[1,27],\"1054\":[1,84],\"1055\":[2,27],\"1056\":[1,24],\"1057\":[1,47],\"1058\":[1,39],\"1059\":[1,137],\"1060\":[2,5],\"1061\":[1,18],\"1062\":[1,10],\"1063\":[1,5],\"1064\":[1,47],\"1065\":[null,null,1],\"1066\":[null,null,1],\"1067\":[2],\"1068\":[1],\"1069\":[1,78],\"1070\":[1,3],\"1071\":[2,111],\"1072\":[1,86],\"1073\":[1],\"1074\":[1,62],\"1075\":[1,70],\"1076\":[1,89],\"1077\":[null,null,1],\"1078\":[null,null,1],\"1079\":[2],\"1080\":[1],\"1081\":[1],\"1082\":[2,38],\"1083\":[1,79],\"1084\":[2,35],\"1085\":[1,22],\"1086\":[1,28],\"1087\":[null,null,1],\"1088\":[null,null,1],\"1089\":[4],\"1090\":[1,5],\"1091\":[1,128],\"1092\":[1,66],\"1093\":[1,102],\"1094\":[1,12],\"1095\":[1,15],\"1096\":[1,152],\"1097\":[1,22],\"1098\":[null,null,1],\"1099\":[null,null,1],\"1100\":[4],\"1101\":[1,20],\"1102\":[1,39],\"1103\":[1,52],\"1104\":[1,75],\"1105\":[1,28],\"1106\":[null,null,1],\"1107\":[null,null,1],\"1108\":[2],\"1109\":[1,76],\"1110\":[null,null,1],\"1111\":[null,null,1],\"1112\":[2,3],\"1113\":[2,18],\"1114\":[2,1],\"1115\":[1,11],\"1116\":[1,67],\"1117\":[1,70],\"1118\":[1,43],\"1119\":[1,147],\"1120\":[null,null,1],\"1121\":[null,null,2],\"1122\":[6],\"1123\":[2],\"1124\":[1,19],\"1125\":[1,43],\"1126\":[1,44],\"1127\":[1,39],\"1128\":[1,21],\"1129\":[1,49],\"1130\":[1,20],\"1131\":[1,23],\"1132\":[1,56],\"1133\":[1,71],\"1134\":[2,50],\"1135\":[1,34],\"1136\":[1,61],\"1137\":[2,25],\"1138\":[1,14],\"1139\":[1,18],\"1140\":[1,37],\"1141\":[1,23],\"1142\":[null,null,1],\"1143\":[null,null,2],\"1144\":[4],\"1145\":[2],\"1146\":[1],\"1147\":[3,18],\"1148\":[1,109],\"1149\":[3,51],\"1150\":[1,26],\"1151\":[1,31],\"1152\":[1,12],\"1153\":[null,null,1],\"1154\":[null,null,2],\"1155\":[4],\"1156\":[2],\"1157\":[1,24],\"1158\":[1,42],\"1159\":[2,59],\"1160\":[1,28],\"1161\":[null,null,1],\"1162\":[null,null,2],\"1163\":[2],\"1164\":[2],\"1165\":[1,9],\"1166\":[1,21],\"1167\":[2,70],\"1168\":[1,13],\"1169\":[1,19],\"1170\":[1,16],\"1171\":[7,22],\"1172\":[1,36],\"1173\":[1,27],\"1174\":[1,24],\"1175\":[2,73],\"1176\":[1,34],\"1177\":[2,46],\"1178\":[2,29],\"1179\":[1,18],\"1180\":[1,25],\"1181\":[1,254],\"1182\":[null,null,1],\"1183\":[null,null,2],\"1184\":[4],\"1185\":[1],\"1186\":[2,39],\"1187\":[1,10],\"1188\":[1,82],\"1189\":[1,29],\"1190\":[1,61],\"1191\":[1,31],\"1192\":[1,71],\"1193\":[null,null,1],\"1194\":[null,null,2],\"1195\":[2],\"1196\":[1,13],\"1197\":[1,13],\"1198\":[1,18],\"1199\":[1,48],\"1200\":[1,36],\"1201\":[1,4],\"1202\":[1,29],\"1203\":[1,62],\"1204\":[1,29],\"1205\":[1,29],\"1206\":[1],\"1207\":[1,39],\"1208\":[1,37],\"1209\":[1,38],\"1210\":[1,17],\"1211\":[1,91],\"1212\":[null,null,1],\"1213\":[null,null,3],\"1214\":[2],\"1215\":[1,36],\"1216\":[1],\"1217\":[1,57],\"1218\":[1,53],\"1219\":[1,98],\"1220\":[1,45],\"1221\":[1,29],\"1222\":[1,22],\"1223\":[1,53],\"1224\":[1,108],\"1225\":[1,74],\"1226\":[1,37],\"1227\":[null,null,1],\"1228\":[null,null,3],\"1229\":[2],\"1230\":[1],\"1231\":[1,103],\"1232\":[1,24],\"1233\":[2,44],\"1234\":[2,25],\"1235\":[1,32],\"1236\":[1,32],\"1237\":[1,30],\"1238\":[null,null,1],\"1239\":[null,null,3],\"1240\":[2],\"1241\":[1,8],\"1242\":[2,195],\"1243\":[1,4],\"1244\":[1,74],\"1245\":[1,81],\"1246\":[1,200],\"1247\":[1,142],\"1248\":[null,null,1],\"1249\":[null,null,3],\"1250\":[2],\"1251\":[1],\"1252\":[1,7],\"1253\":[1,42],\"1254\":[1,38],\"1255\":[1,81],\"1256\":[1,34],\"1257\":[1,44],\"1258\":[1,5],\"1259\":[2,51],\"1260\":[1,165],\"1261\":[null,null,1],\"1262\":[null,null,3],\"1263\":[2],\"1264\":[1],\"1265\":[1,4],\"1266\":[1,44],\"1267\":[1,48],\"1268\":[1,14],\"1269\":[1,13],\"1270\":[1,22],\"1271\":[1,29],\"1272\":[1,41],\"1273\":[2,72],\"1274\":[1,12],\"1275\":[1],\"1276\":[2,44],\"1277\":[2,50],\"1278\":[2,82],\"1279\":[1,55],\"1280\":[1,6],\"1281\":[1,38],\"1282\":[1,30],\"1283\":[1,70],\"1284\":[1,9],\"1285\":[null,null,1],\"1286\":[null,null,3],\"1287\":[2],\"1288\":[1,24],\"1289\":[1],\"1290\":[1,25],\"1291\":[2,36],\"1292\":[null,null,1],\"1293\":[null,null,3],\"1294\":[2],\"1295\":[1,7],\"1296\":[1,111],\"1297\":[1,49],\"1298\":[1,65],\"1299\":[1,22],\"1300\":[1,98],\"1301\":[1,129],\"1302\":[null,null,1],\"1303\":[null,null,2],\"1304\":[2],\"1305\":[1],\"1306\":[1,12],\"1307\":[1,40],\"1308\":[1,26],\"1309\":[1,16],\"1310\":[1,88],\"1311\":[1,70],\"1312\":[null,null,1],\"1313\":[null,null,2],\"1314\":[2],\"1315\":[1,4],\"1316\":[1,29],\"1317\":[1,18],\"1318\":[1,71],\"1319\":[1,35],\"1320\":[1,91],\"1321\":[1,55],\"1322\":[null,null,1],\"1323\":[null,null,2],\"1324\":[2],\"1325\":[1],\"1326\":[1,52],\"1327\":[1,131],\"1328\":[1,82],\"1329\":[null,null,1],\"1330\":[null,null,2],\"1331\":[1,3],\"1332\":[1],\"1333\":[1],\"1334\":[1],\"1335\":[1],\"1336\":[1],\"1337\":[1],\"1338\":[3],\"1339\":[2],\"1340\":[2],\"1341\":[2],\"1342\":[2],\"1343\":[2],\"1344\":[1],\"1345\":[2],\"1346\":[2],\"1347\":[2],\"1348\":[2],\"1349\":[2],\"1350\":[2],\"1351\":[2],\"1352\":[3],\"1353\":[1],\"1354\":[2],\"1355\":[2],\"1356\":[2],\"1357\":[2],\"1358\":[2]},\"averageFieldLength\":[1.7375053882712963,40.43992891974286,1.0746631017775463],\"storedFields\":{\"0\":{\"h\":\"daily1\",\"t\":[\"a+b=c\"]},\"1\":{\"c\":[\"daily\"]},\"2\":{\"c\":[\"d1\"]},\"3\":{\"h\":\"Reinforcement Learning in Multiple-UAV Networks:Deployment and Movement Design\",\"t\":[\"2019 IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"4\":{\"h\":\"主要动机\",\"t\":[\"A novel framework is proposed for quality of experience driven deployment and dynamic movement of multiple unmanned aerial vehicles (UAVs).\",\"过去研究大多没有基于用户的移动(movement of users)来考虑无人机的机动性，更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署。\",\"考虑QoE, 而不是仅考虑吞吐量(throughput)，即需要考虑地面不同用户的具体需求。(QoE is invoked for demonstrating the users’ satisfaction, and it is supposed to be considered in UAV-assisted wireless networks)\",\"该文设计的是3D部署，过去研究主要考虑的是2D部署。\"]},\"5\":{\"h\":\"主要贡献\",\"t\":[\"提出了一个理想的由QoE驱动的多无人机协助通信框架。该框架将无人机部署在三维空间内，以 mean opinion score(MOS) 为指标。通过优化无人机的部署和动态移动来解决总用户MOS最大化问题。\",\"提出解决总用户MOS最大化问题的三步骤: \",\"通过GAK-mean算法获得初始单元划分。\",\"设计一种基于 q-learning 的部署方法，在初始时间假设用户处于静止下不断调整 UAVs 3D位置进行优化处理。\",\"设计一种基于 q-learning 的无人机3D动态运动设计算法。\",\"该文基于q-learning的方案来解决无人机的NP-hard 3D部署和移动问题，并与传统的基于遗传的学习算法进行对比。\",\"该文提出的算法具较快的收敛性，与K-means和IGK算法比具有较低的复杂度。\"]},\"6\":{\"h\":\"主要内容\"},\"7\":{\"h\":\"系统结构\"},\"8\":{\"h\":\"基本设置\",\"t\":[\"考虑无人机辅助无线网络的下行链路传输(down-link transmission)，即无人机作为空中基站。\",\"对于指定区域，会将其划分为N个簇，其中用户表示为K=K1​,…,KN​，其中KN​表示划分到集群N的用户，N∈1,2,…,N。\",\"每个用户只能属于一个集群，Kn​∩Kn′​=ϕ,n′=n,\",\"在任意时刻t，同一无人机通过FDMA同时为同一集群中的多个用户提供服务\",\"对于用户kn​∈Kn​，其坐标表示为wkn​​=[xkn​​(t),ykn​​(t)]T∈R2×1\",\"对于无人机n(飞行速度恒定)，其垂直高度表示为hn​(t)∈[hmin​,hmax​],0≤t≤Ts​，其水平坐标表示为qn​(t)=[xn​(t),yn​(t)]T∈R2×1,0≤t≤Ts​\",\"无人机n与用户kn​在时间t的距离表示为:\",\"dkn​​=hn2​(t)+[xn​(t)−xkn​​(t)]2+[yn​(t)−ykn​​(t)]2​\"]},\"9\":{\"h\":\"信号模型\",\"t\":[\"无人机往往有更高的LoS链接概率，该文中表示为:\",\"PLoS​(θkn​​)=b1​(π180​θkn​​−ζ)b2​PNLoS​=1−PLoS​\",\"其中θkn​​(t)=sin−1[dkn​(t)​hn​(t)​]，表示无人机与用户之间的仰角。b1​,b2​,ζ是由环境决定的常数。在实际应用中，为了在LoS信道概率和路径损耗之间取得平衡，需要合理选择无人机n的垂直高度hn​(t)。\",\"在时间t，从无人机n到用户kn​的信道功率增益(the channel power gain)为:\",\"gkn​​(t)=K0​−1dkn​​−α[t](PLos​μLoS​+PNLos​μNLoS​)−1\",\"其中K0​=(c4πfc​​)2，α是表示路径损耗指数(常数)，μLoS​,μNLoS​是表示LoS和NLoS链路的衰减因子，fc​是载波频率，c是光速。\",\"对于无人机n，其可用带宽为Bn​，将其平均分配给其∣Kn​∣个关联用户，其每个用户带宽表示为: Bkn​​=Bn​/Kn​. 该文中不同集群所利用的频谱是不同的，且无人机向关联用户的发射功率是恒定的。 同样，对于无人机的总发射功率也均匀地分配给每个用户，pkn​​=Pmax​/Kn​\",\"由于不同集群的频谱不同，可以减轻无人机对用户接收到的干扰。因此，在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为:\",\"Γkn​​(t)=σ2pkn​​gkn​​(t)​\",\"其中σ2=Bkn​​N0​, N0​为用户所在位置的加性高斯白噪声(AWGN)的功率谱密度。\",\"为了满足不同用户传输速率要求，对于用户kn​存在特定的信噪比目标γkn​​, 即Γ≥γkn​​.\",\"由此，存在Lemma1： 为了保证所有用户都能连接到网络，我们对无人机的发射功率有一个约束，可以表示为\",\"Pmax​≥γσ2K0​dkn​​α(t)μNLoS​\",\"根据香农定理: 信道容量C=B∗log(1+NS​)，且传输率永远都不可能超过信道容量C。 因此对于用户kn​的在时刻t的传输速率rkn​​(t)，表示为rkn​​(t)=Bkn​​log2​[1+σ2pkn​​gkn​​(t)​].\",\"Proposition1: 无人机n的高度需满足:\",\"dkn​​(t)sin[180π​(ζ+eM(t))]≤hn​(t)≤(γK0​σ2μLoS​Pmax​​)\",\"其中\",\"M(t)=b2​ln(b1​(μLoS​−μNLoS​)S(t)​−μLoS​−μNLoS​μNLoS​​​S(t)=γK0​σ2dkn​​α(t)Pm​ax​\",\"Proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件。 可知，其高度的下界是距离dkn​​(t)的函数；高度的上界是最大发射功率Pmax​的函数。 因此，随着无人机与用户之间距离和发射功率的变化，需要调整相应无人机的高度，以向用户提供可靠的服务。\"]},\"10\":{\"h\":\"Quality-of-Experience Model\",\"t\":[\"由于不同用户对于传输速率的需求是不同的，所以在无人机辅助通信网络中我们需要考虑QoE模型。\",\"在该文中，采用MOS作为用户QoS衡量的标准，具体如下:\",\"MOSkn​​(t)=ζ1​MOSkn​​delay(t)+ζ2​MOSkn​​rate(t)\",\"其中，ζ1​,ζ2​是系数，且ζ1​+ζ2​=1。\",\"根据MOS数值，共划分5个等级: excellent(4.5) very good(2~3.5) fair(1~2) poor(1)。\",\"在该文中考虑的是网页浏览应用传输情况，因此MOSkn​​delay(t)可以忽略，因此，此时的MOS模型定义如下:\",\"MOSkn​​(t)=−C1​ln[d(rkn​​(t))]+C2​\",\"d(rkn​​(t))是与传输速率有关的延迟时间，MOSkn​​(t)为t时刻的MOS评分，取值范围从1−4.5。C1​和C2​是通过分析web浏览应用程序的实验结果确定的常数，分别设为1.120和4.6746。\",\"d(rkn​​(t))=3RTT+rkn​​(t)FS​+L(rkn​​MSS​)+RTT−rkn​​(t)2MSS(2L−1)​\",\"其中，RTT[s]表示round trip time(数据包从发送端-接收端-发送端的时间)，FS[bit]是网页大小，MSS[bit]是最大报文长度，L=min[L1​,L2​]表示 the number of slow start cycles with idle periods。\",\"L1​=log2​(MSSrkn​​RTT​+1)−1,L2​=log2​(2MSSFS​+1)−1.\",\"用户rkn​​在一段时间Ts​内的MOS总和为:\",\"MOSrkn​​​=t=0∑Ts​​MOSkn​​(t)\"]},\"11\":{\"h\":\"优化问题建立\",\"t\":[\"假设功率Q=qn​(t),0≤t≤Ts​, 高度H=hn​(t),0≤t≤Ts​\",\"本文目的是优化无人机在每个时隙的位置，从而最大化所有用户的总MOS值。具体表述如下:\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​∑t=0Ts​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"该优化问题是一个non-convex问题，因为目标函数对于无人机的3D坐标是非凸的。\",\"总用户的MOS取决于无人机的发射功率、数量和位置(水平位置和高度)。\"]},\"12\":{\"h\":\"解决方案\"},\"13\":{\"h\":\"无人机的3D部署\",\"t\":[\"考虑以下场景，将上述优化问题简化:\",\"无人机n以可变高度悬停在用户上方，用户是保持静态的。 每架无人机的带宽和发射功率都均匀分配给每个用户。 因此我们将优化问题简化为区域分割问题。\",\"描述如下: 但即使仅考虑用户聚类，该问题依然是NP-hard问题\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"无人机-用户关联策略(用户区域划分算法)\",\"采用基于遗传算法的GAK-means算法 由于特定用户的MOS与该用户与无人机之间的距离有关，因此GAK-means可以视为获得无人机部署的低复杂度方案。\",\"根据N个用户，根据遗传算法找到CN​个最优个体作为簇的中心。\",\"将无人机部署在每个中心内，再将用户划分给距离最近的无人机\",\"重复步骤，再找到新的簇的各中心，再根据欧几里得距离重新划分，直到各个簇的成员没有太大变化，划分完毕。\",\"无人机3D部署算法\",\"根据所给定的用户划分情况，目标是获得无人机的最佳3D位置，来最大化MOS总和。 由于GAK-means的优化目标是最小化无人机与对应集群用户的欧氏距离，MOS主要是有关传输速率rkn​​的函数，因此MOS不仅与欧氏距离有关，还与LoS的概率有关。\",\"采用Q-learning算法\",\"智能体(agent): UAVn,n∈N={1,2,…,N}\",\"状态(state): 对于每个智能体，其状态为其3D坐标，定义为ξ=(xUAV​,yUAV​,hUAV​)\",\"状态空间(state space S): 这里采用离散化空间坐标，即xUAV​:{0,1,…,Xd​},yUAV​:0,1,…,Yd​,hUAV​:{hmin​,…,hmax​}，所以状态其实共有(XD​+1)×(Yd​+1)×(hmax​−hmin​+1)个\",\"动作空间(action space): 每次无人机会根据当前状态st​∈S，按照所给定策略J来执行一个动作at​∈A从而获得奖励rt​以及下一个状态st+1​ 该论文中在精度和模型复杂型上作出平衡，共考虑7个方向。 (1,0,0)：右转 (−1,0,0)：左转 (0,1,0)：前进 (0,−1,0)：后退 (0,0,1)：上行 (0,0,−1)：下行 (0,0,0)：静止\",\"状态转换模型: 当执行动作at​时，从状态st​到st+1​，并获得奖励rt​的这一过程可以用条件转移概率p(st+1​,rt​∣st​,at​)来表示。 Q-learning的优化目标是最大化长期收益\",\"Gt​=E[n=0∑∞​βnrt+n​]\",\"奖励(reward): 如果agent在当前时刻t所执行的动作能够提高总MOS，则无人机将获得正奖励。否则，agent将获得负奖励。\",\"xt​=⎩⎨⎧​1,−0.1,−1,​ifMOSnew​>MOSold​ifMOSnew​=MOSold​ifMOSnew​<MOSold​​\",\"具体代码：（策略为贪心策略）\",\"算法1\",\"个人理解：\",\"通过K-means来划分各个无人机所管理的用户簇。无人机的位置初始化也是随机部署的\",\"但每个无人机所管理的用户不同，其目标也应该不一样，不能用同一个Q-table管理，这里是每个无人机都有一张自己的Q-table，来进行迭代？ 还是同一张Q-table，只不过根据区域划分，不同的无人机agent的Q(s,a)的s是有范围的？(个人感觉是这个)\",\"最终输出的结果，应该是无人机最终停的位置即是部署的最佳位置(因为q-learning是优化长期目标)，发现在该位置静止是最优的，表示是最佳部署位置。\",\"最终输出结果，是根据Q-table来找出对应q(s,a)当a为静止时，最大的q(s,a)值，对应s就是UAV的部署位置\"]},\"14\":{\"h\":\"无人机的动态移动设计\",\"t\":[\"考虑用户在每个时隙移动的情况，由于用户在每个时隙都处于漫游状态，因此随着用户位置的变化，每个集群中无人机的最优位置也会发生变化，无人机需要进行移动。\",\"在本文中不考虑用户移动到其他集群的情况 因为在不考虑用户自由穿梭集群的情况，对于动作空间而言，仅需要考虑无人机的7个移动方向即可；但若考虑集群情况，动作空间包含两个部分：选择移动方向和选择关联用户。设无人机总数为N，∣Kn​∣为第n个簇的用户总数，则用户的关联动作数为2N∑n=1N​∣Kn​∣，∑n=1N​∣Kn​∣是总用户数，每个用户都需要判断是否与每个无人机关联，因此是2N 则总动作空间的大小为7+2N∑n=1N​∣Kn​∣会导致动作空间过大，Q-table过大。\",\"1.用户漫游模型 在设计无人机的移动之前，需考虑用户的移动性，这里有多种mobility modles可选择，如a deterministic approach, a hybrid approach, and a random walk model. 在本文中，采用的是the random walk model(Markovian mobility model) 每个用户的移动方向均匀分布在左、右、前、后四个方向。 用户的速度设为[0,cmax​]，其中cmax​表示用户的最大速度。\",\"2.基于q-learning的移动算法 与基于q-learning的部署算法不同的是，在此情况下，状态除了要考虑无人机的3D位置外，还需要考虑所有用户的2D位置。即ξ={xUAV​,yUAV​,hUAV​,xuser​,yuser​}(xuser​,yuser​)由用户的初始位置和运动模型决定，(xUAV​,yUAV​,hUAV​)由无人机的位置和它们在最后时隙采取的动作决定.\",\"训练阶段: \",\"测试阶段:\\n\"]},\"15\":{\"c\":[\"academic\"]},\"16\":{\"c\":[\"UAV\",\"IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"17\":{\"h\":\"RL1 - 基本概念\"},\"18\":{\"h\":\"强化学习框架图\",\"t\":[\"主要框架\"]},\"19\":{\"h\":\"1. 基本概念\",\"t\":[\"State(状态)：The status of the agent with respect to the environment.\",\"State Space(状态空间): 所有状态的集合。S={si​}i=1n​。\",\"Action(动作): 对于每一个状态，都有可选择的动作。\",\"Action space of a state: 对应状态中所有可选择的动作集合。A(si​)={ai​}i=1n​\",\"State transition(状态转换): s1​→a1​s2​。定义了agent与环境的交互行为。\",\"State transition probability: p(s2​∣s1​,a1​)，即状态s1​采用动作a1​转到状态s2​的概率。\",\"Policy π: 指导agent在当前状态下选择哪个动作。\",\"Reward(奖励): 在执行一个动作后获得的一个常数(依赖于当前状态和所采取的动作)。同样可以用条件概率的形式进行描述，如p(r=1∣s1​,a1​)，即在状态s1​下采用动作a1​获得的奖励r=1的概率。\",\"Trajectory：a state-action-reward chain.(可以有限，也可以是无限长的trajectory) s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​. 个人理解，trajectory是在策略给定下，agent可能走出的全部轨迹，并非只是一个单一的轨迹。\",\"Return of a trajectory：将对应的轨迹所获得的所有reward的总和，可以粗步衡量一个策略的好坏。\",\"Discounted return(of a trajectory)：为了应对具有无限步的trajectory的return=∞的情况。 s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​…. 此时该trajectory的return=0+0+0+1+1+⋯=∞。 引入discount rate, γ∈[0,1). 此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​ 显然，如果γ接近0，即此时的discounted return越短视，注重近期的reward；γ接近1，更远视，更注重长远的reward。\",\"Episode(trial)：When interacting with the environment following a policy, the agent may stop at some terminal states. The resulting trajectory is called an episode(or a trial)/ 即表示具有终止状态terminal states的trajectory，通常是具有有限步长的trajectory. 同理，这样的任务称为episodic tasks。\",\"continuing tasks：即不具备terminal states的任务，会与环境一直交互下去。 可以通过设置将episodic tasks转换成continuing tasks，如可以在target states中限制action space，控制其一直待在target states中。 Deterministic — Stochastic\"]},\"20\":{\"h\":\"2.Markov decision process(MDP)\",\"t\":[\"关键元素：\",\"Sets： \",\"State：the set of states S\",\"Action：the set of actions A(s) is associate for state s∈S\",\"Reward：the set of rewards R(s,a).\",\"Probability distribution： \",\"State transition probability p(s′∣s,a): 表示在状态s下采取动作a，转换到状态s′的概率。\",\"Reward probability p(r∣s,a): 表示在状态s下采取动作a，获得reward r 的概率。\",\"Policy：at state s, the probability to choose action a is π(a∣s). 表示在各状态执行各动作的概率。\",\"Markov property：即无记忆的特性。 p(st+1​∣at+1​,st​,…,a1​,s0​)=p(st+1​∣at+1​,st​)r(st+1​∣at+1​,st​,…,a1​,s0​)=p(rt+1​∣at+1​,st​)\",\"Markov process：在policy是确定的情况下，MDP就变为MP。\"]},\"21\":{\"c\":[\"academic\"]},\"22\":{\"c\":[\"强化学习\"]},\"23\":{\"h\":\"RL10 - Actor-Critic 方法\",\"t\":[\"actor: 对应 policy update\",\"critic: 对应 policy evaluation 或者 value evaluation\",\"20240830184236\",\"显然，是在基于 策略梯度上升 算法的基础上，将对于 Q 值的估计通过一个网络来进行描述，这个便成为 critic, 而对应的策略梯度上升算法就是对应 actor。\",\"20240830184312\"]},\"24\":{\"h\":\"1. The simplest actor-critic (QAC)\",\"t\":[\"20240830184330\",\"20240830184424\"]},\"25\":{\"h\":\"2. Advantage actor-critic (A2C)\",\"t\":[\"核心思想：在 QAC 的基础上来引入偏置量(baseline)，从而减小方差，提升采样的效率。\"]},\"26\":{\"h\":\"2.1 baseline\",\"t\":[\"在策略梯度算法中引入一个 baseline, 不会影响所求的梯度。 即:\",\"▽θ​J(θ)​=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)]=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)−b(S)]​\",\"证明: 要证明加入baseline成立，只需要保证:\",\"ES∼η,A∼π​[▽θ​ln(A∣S,θ)b(S)]=0\",\"20240830185127\",\"作用:\",\"因此，我们需要找到一个 baseline 来保证这个梯度的方差最小即可。\"]},\"27\":{\"h\":\"2.2 最好的 baseline\",\"t\":[\"20240830185324\",\"在实际情况中，我们通常将 baseline 设置为 vπ​(s)\"]},\"28\":{\"h\":\"2.3 对应算法\",\"t\":[\"20240830185537\",\"20240830185556\",\"20240830185629\"]},\"29\":{\"h\":\"3. off-policy actor-critic\",\"t\":[\"通过 重要性采样 的方法，将处于 另一分布下 的策略所采集的数据来 运用到 策略更新 中。\"]},\"30\":{\"h\":\"3.1 重要性采样 (Importance sampling)\",\"t\":[\"20240830200056\",\"20240830200118\",\"20240830200138\"]},\"31\":{\"h\":\"3.2 off-policy\",\"t\":[\"20240830200248\",\"20240830200305\",\"20240830200320\",\"20240830200343\"]},\"32\":{\"h\":\"3.3 伪代码\",\"t\":[\"20240830200406\"]},\"33\":{\"h\":\"4. Deterministic actor-critic (DPG)\",\"t\":[\"1234\",\"20240830200608\",\"20240830200624\"]},\"34\":{\"c\":[\"academic\"]},\"35\":{\"c\":[\"强化学习\"]},\"36\":{\"h\":\"RL2 - 贝尔曼公式\"},\"37\":{\"h\":\"核心内容\",\"t\":[\"state value\",\"the Bellman equation\"]},\"38\":{\"h\":\"1.State value\"},\"39\":{\"h\":\"1.1\",\"t\":[\"引入随机变量后对应的discounted return的描述。 即一个trajectory下的discounted return。 由此可以推导出一个多步的trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的discounted return为：Gt​=Rt+1​+γRt+2​+γ2Rt+3​+…\",\"γ 为discounted rate\",\"Gt​也是一个随机变量\"]},\"40\":{\"h\":\"1.2 State value\",\"t\":[\"State value 是 Gt​ 的期望, 也称为 state value function 表示为 The expection(expected value or mean) of Gt​:\",\"vπ​(s)=E[Gt​∣St​=s]\",\"是一个有关状态s的函数.\",\"vπ​(s) 是基于一个给定策略 π , 对于不同的策略，所得到的 state value 是不同的.\",\"state value 可以用来衡量一个状态的价值.\"]},\"41\":{\"h\":\"1.3 State value 与 return 的区别\",\"t\":[\"Return 是针对一条trajectory所求的，而 State value 则是对多个 trajectory 求 return 再求平均值。 The state value is the mean of all possible returns that can be obtained starting from a state. 只有当所有东西都是确定性的(π(a∣s),p(r∣s,a),p(s′∣s,a))，state value 与 return 是一致的.\"]},\"42\":{\"h\":\"2. Bellman equation\",\"t\":[\"用来描述所有状态的state value的关系. 根据一个 random trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的 discounted return Gt​ 为:\",\"Gt​​=Rt+1​+γRt+2​+γ2Rt+3​+…=Rt+1​+γ(Rt+2​+γRt+3​+…)=Rt+1​+γGt+1​​\",\"因此，对应的 state value 为:\",\"vπ​(s)​=E[Gt​∣St​=s]=E[Rt+1​+γGt+1​∣St​=s]=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s]​\",\"需要推导E[Rt+1​∣St​=s]和E[Gt+1​∣St​=s]的计算即可。\"]},\"43\":{\"h\":\"2.1 The mean of immediate rewards:\",\"t\":[\"E[Rt+1​∣St​=s]​=a∑​π(a∣s)E[Rt+1​∣St​=s,At​=a]=a∑​π(a∣s)r∑​p(r∣s,a)r​\"]},\"44\":{\"h\":\"2.2 The mean of future rewards:\",\"t\":[\"E[Gt+1​∣St​=s]​=s′∑​E[Gt+1​∣St​=s,St+1​=s′]=s′∑​E[Gt+1​∣St+1​=s′](无记忆性)=s′∑​vπ​(s′)p(s′∣s)=s′∑​vπ​(s′)a∑​p(s′∣s,a)π(a∣s)​\",\"个人推导：\",\"E[Gt+1​∣St​=s]​=a∑​π(a∣s)E[Gt+1​∣St​=s,At​=a]=a∑​π(a∣s)s′∑​E[Gt+1​∣St​=s,At​=a,St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)E[Gt+1​∣St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​\"]},\"45\":{\"h\":\"2.3 Bellman equation\",\"t\":[\"vπ​(s)​=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s],=mean of immediate rewards a∑​π(a∣s)r∑​p(r∣s,a)r​​+mean of future rewards γa∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​​,=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)],∀s∈S.​\",\"该式子针对状态空间中的所有状态均成立.\",\"通过 Bootstrapping , 可以求解 state value.\",\"π(a∣s) 表示一个给定的策略. 求解Bellman equation 称为策略评估(Policy evaluation).\",\"p(r∣s,a),p(s′∣s,a) 是由环境决定的(dynamic model|environment model). 后续可能是未知的(model-free)，需要通过采样解决.\"]},\"46\":{\"h\":\"2.4 Bellman equation (Matrix-vector form)\",\"t\":[\" 此时,对于所有状态s，对应的 Bellman equation 为\",\"vπ​(s)=rπ​(s)+γs′∑​pπ​(s′∣s)vπ​(s′)​\",\"将所有状态的 Bellman equation 整合，重新修改为 matrix-vector form.\",\"vπ​=rπ​+γPπ​vπ​​\",\"其中,\",\"vπ​=[vπ​(s1​),…,vπ​(sn​)]T∈Rn\",\"rπ​=[rπ​(s1​),…,rπ​(sn​)]T∈Rn\",\"Pπ​∈Rn×n, where [Pπ​]ij​=pπ​(sj​∣si​), 表示状态转移矩阵.\"]},\"47\":{\"h\":\"3. Why to slove state value\",\"t\":[\"为了进行 Policy evaluation, 即对于给定策略，求出其对应状态的 state value 的过程。\",\"通过 Bellman euqation 进行求解。\",\"The closed-form solution(不常用):\",\"vπ​=(I−γpπ​)−1rπ​​\",\"An iterative solution(一种迭代策略):\",\"vk+1​=rπ​+γPπ​vk​​\",\"可以最开始均初始化为 0 , 然后进行不断迭代，可以得到一个序列v0​,v1​,v2​,…. 最终可以证明：vk​→vπ​=(I−γpπ​)−1rπ​,k→∞\"]},\"48\":{\"h\":\"4. Action value\",\"t\":[\"State value: agent从一个状态出发可以得到的平均return. the average return the agent can get starting from a state\",\"Action value: agent从一个状态出发，采取一个指定的action可以得到的平均return。 the average return the agent can get starting from a state and taking an action.\",\"通过求解 action value 我们可以分析出在该状态下采取哪个 action 收益最大. Action value 定义:\",\"qπ​(s,a)=E[Gt​∣St​=s,At​=a]​\",\"同样地，qπ​(s,a)是依赖于策略π的，并且与状态 s 和动作 a 有关.\",\"vπ​(s)E[Gt​∣St​=s]​​=a∑​qπ​(s,a)E[Gt​∣St​=s,At​=a]​​π(a∣s)\",\"因此，vπ​(s)=∑a​qπ​(s,a)π(a∣s) 由于,\",\"vπ​(s)=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)]​\",\"所以，qπ​(s,a)=∑r​p(r∣s,a)r+γ∑s′​p(s′∣s,a)vπ​(s′)\",\"实际意义是：在当前状态s下采取动作 a 所获得的均值，加上 γ 的转到下一个状态的 state value 加权均值。\",\"引入 action value 后，对于 state value 实际意义的解释：在当前状态s下，根据策略π, 所有可能动作的 action value 的加权均值。\",\"state value 和 action value 可以互相转化。\"]},\"49\":{\"h\":\"5. 总结\",\"t\":[\"State value: vπ​(s)=E[Gt​∣St​=s]\",\"Action value: qπ​(s,a)=E[Gt​∣St​=s,At​=a]\",\"State value 是 action value 的根据策略π加权平均，即vπ​(s)=∑a​π(a∣s)q(s,a)\",\"The Bellman equation (elementwise form and matrix-vector form)\",\"求解 the Bellman equation (2种方法)\"]},\"50\":{\"c\":[\"academic\"]},\"51\":{\"c\":[\"强化学习\"]},\"52\":{\"h\":\"RL3 - 贝尔曼最优公式\",\"t\":[\"Core concepts: optimal state value and optimal policy\",\"A fundamental tool: the Bellman optimality equation (BOE)\"]},\"53\":{\"h\":\"1. Optimal policy\",\"t\":[\"最优策略的定义: A policy π∗ is optimal if π∗(s)≥vπ​(s) for all s and for any other policy π. 需要确定几件事:\",\"最优策略是否存在 存在，根据 the contraction mapping Theorem.\",\"最优策略是否唯一 唯一，根据 the contraction mapping Theorem.\",\"最优策略是 stochastic 还是 deterministic deterministic 且 greedy\",\"如何得到最优策略 选取状态中最大的 action value 作为下一步的 action\"]},\"54\":{\"h\":\"2. Bellman optimality equation (BOE)\"},\"55\":{\"h\":\"2.1 基本形式\",\"t\":[\"对于贝尔曼最优公式而言，其策略π表示的是最优策略，除了需要求解 state value 外，还需要求解最优策略π.elementwise form:\",\"vπ​(s)​=πmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)),∀s∈S=πmax​a∑​π(a∣s)q(a,s),∀s∈S​\",\"matrix-vector foem:\",\"v=πmax​(rπ​+γPπ​v)​\"]},\"56\":{\"h\":\"2.2 如何求解\",\"t\":[\"对于贝尔曼最优公式而言，区别于贝尔曼公式，只是求解各状态的 state value, 我们还需要理解其所描述的最优策略π∗ 具体分两步:\"]},\"57\":{\"h\":\"2.2.1 如何处理等式右边的 (最优策略)\",\"t\":[\"vπ​(s)=maxπ​∑a​π(a∣s)q(s,a), 为了让右边取到最大值的情况，我们只需要在当前状态下，保证选取最大的 action value 即可，对应策略表示为:\",\"π(a∣s)={10​a=a∗a=a∗​\",\"其中a∗表示在该状态下计算出来的最大 action value 对应的动作，即a∗=argmaxa​q(s∣a)\"]},\"58\":{\"h\":\"2. 求解 state value\",\"t\":[\"将 BOE 转换为 v=f(v) 的形式，其中f(v):=maxπ​(rπ​+γPπ​v)f(v)对应一个向量, [f(v)]s​=maxπ​∑a​π(a∣s)q(s∣a),∀s∈S\",\"求解方法：\",\"Fix point: f(x)=x\",\"Contraction mapping(contractive function): ∣∣f(x1​)−f(x2​)∣∣≤γ∣∣x1​−x2​∣∣\",\"由此可以根据Contraction Mapping Theorem: For any equation that has the form of x=f(x), if f is a contraction mapping, then\",\"Existence: 存在不动点x∗，满足f(x∗)=x∗\",\"Uniqueness: 不动点x∗是唯一的\",\"Algorithm: Consider a sequence xk​ where xk+1​=f(xk​), then xk​→x∗ as k→∞. Moreover, the convergence rate is exponentially fast.\",\"因此，可以通过Contraction Mapping Theorem来求解贝尔曼最优公式，因为其满足该理论，即f(v)是一个contraction mapping。\"]},\"59\":{\"c\":[\"academic\"]},\"60\":{\"c\":[\"强化学习\"]},\"61\":{\"h\":\"RL4 - 值迭代和策略迭代(动态规划)\",\"t\":[\"贝尔曼最优公式:\",\"v=f(v)=πmax​(rπ​+γPπ​v)\"]},\"62\":{\"h\":\"1. Value iteration algorithm\",\"t\":[\"根据 chapter 3 中涉及的 contraction mapping theorem, 我们可以通过对应的迭代算法来求解贝尔曼最优公式\",\"vk+1​=f(vk​)=πmax​(rπ​+γPπ​vk​),k=1,2,3…\",\"这种迭代算法称为 value iteration.\"]},\"63\":{\"h\":\"1.1 具体步骤\",\"t\":[\"共分为 2 步：\",\"Policy update 这步是更新策略π，即求解右边的式子，πk+1​=argmaxπ​(rπ​+γPπ​vk​), 其中vk​是给定的。 其对应的 elementwise form:\",\"πk+1​(s)=πargmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)v(s′)),s∈S 由于 p(s′∣s,a),p(r∣s,a),v(s′) 是已知的，显然，这里的最优策略πk+1​是一个 greedy policy，我们只需要挑选在当前迭代下最大的 action value 就好了, 即:\",\"πk+1​(a∣s)={10​a=ak∗​(s)a=ak∗​(s)​ 其中ak∗​(s)=argmaxa​qk​(a,s).\",\"value update 根据 Policy update 的策略πk+1​, 求解下一步的vk+1​, 即\",\"vk+1​=rπk+1​​+γPπk+1​​vk​这里的vk​并不是 state value 由于πk+1​是 greedy 的，对应的vk+1​(s)=maxa​qk​(a,s)\"]},\"64\":{\"h\":\"1.2 伪代码\",\"t\":[\"20240810190018\"]},\"65\":{\"h\":\"2. Policy iteration algorithm\",\"t\":[\"算法迭代示意图:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\"]},\"66\":{\"h\":\"2.1 算法描述\",\"t\":[\"首先随机设计一个初始的策略π0​\",\"Step 1: policy evaluation (PE) 策略评估 该步骤是用来计算当前策略 πk​ 的 state value. 可以通过 Bellman equation 进行求解，即:\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"根据对应的 Elementwise form:\",\"vπk​(j+1)​(s)=a∑​πk​(a∣s)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​(j)​(s′)),s∈S\",\"由此进行迭代，直到设置的收敛条件为止，即j→∞ 或者 ∣∣vπk+1​(j+1)​(s)−vπk​(j)​(s)∣∣≤δ.\",\"Step 2: policy improvement (PI) 策略提升 该步骤是根据 PE 所求出的 state value, 根据 action value，来提升当前策略 πk​\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"对应的 Elementwise form:\",\"πk+1​(s)=πargmax​a∑​πk​(a∣s)qπk​​(s,a)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​​(s′))​​,s∈S\",\"这里，显然是可以通过一个 greedy 的策略来进行选择，即:\",\"πk+1​(a∣s)={10​a=ak∗​(s),a=ak∗​(s).​\",\"其中 aK∗​(s)=argmaxa​qπk​​(s,a).\"]},\"67\":{\"h\":\"2.2 伪代码\",\"t\":[\"20240811002219\"]},\"68\":{\"h\":\"2.3 一些问题\",\"t\":[\"在 PE 步骤中，如何通过 Bellman equation 得到 state value vπk​​. 根据 chapter 2 中求解 Bellman equation 的方法 一种是可以直接通过矩阵求逆进行求解，即 vπk​​=(I−γPπk​​)−1rπk​​，实际不常用. 一种是通过迭代算法来求解\",\"vπk​(j+1)​=rπk​​+γPπk​​vπk​(j)​\",\"在 PI 步骤中，如何确保策略 πk+1​ 是优于 πk​的.\",\"为什么这个迭代算法最终可以找到最优策略 每次迭代都会使得策略进行提升，那么\",\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",\"我们需要保证策略是不断提升，且最终会收敛到最优策略v∗\",\"policy iteration algorithm 与 value iteration algorithm 之间存在什么关系.\"]},\"69\":{\"h\":\"3. Truncated policy iteration algorithm\",\"t\":[\"该算法是 value iteration 以及 policy iteration 一般化的推广\"]},\"70\":{\"h\":\"3.1 value iteration 与 policy iteration 算法比较\",\"t\":[\"Policy iteration: 需要初始化策略π0​, 之后进行迭代\",\"Policy evaluation (PE): 通过 Bellman equation 求解当前策略的 state value.\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"内嵌迭代算法求解.\",\"Policy improvement (PI): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"Value iteration: 需要初始化猜测的 state value v0​\",\"Policy update (PU): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vk​)\",\"Value update (VU): 进行迭代\",\"vk+1​=rπk+1​​+γPπk+1​​vk​\",\"两个算法迭代过程十分类似: Policy iteration:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\",\"Value iteration:\",\"u0​PU​π1′​VU​u1​PU​π2′​VU​u2​PU​…\",\"Policy iteration algorithm\",\"Value iteration algorithm\",\"Comments\",\"1) Policy:\",\"π0​\",\"N/A\",\"2) Value:\",\"vπ0​​=rπ0​​+γPπ0​​vπ0​​\",\"v0​:=vπ0​​\",\"对于 policy iteration，vπ0​​是通过迭代算法来求的; 而 value iteration 我们这里强行初始化为vπ0​​，方便后续比较\",\"3) Policy:\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"在策略更新上，这两个算法是一致的。\",\"4) Value:\",\"vπ1​​=rπ1​​+γPπ1​​vπ1​​\",\"v1​=rπ1​​+γPπ1​​v0​\",\"对于 Policy iteration 而言, 这里需要通过迭代算法来精确求出 vπ1​​; 对于 Value iteration，则只是进行一次带入求解。\",\"5) Policy:\",\"π2​=argmaxπ​(rπ​+γPπ​vπ1​​)\",\"π2′​=argmaxπ​(rπ​+γPπ​v1​)\",\"⋮\",\"⋮\",\"⋮\",\"⋮\"]},\"71\":{\"h\":\"3.2 Truncated policy iteration algorithm\",\"t\":[\"20240811010933\",\"显然，在求解 Bellman equation 中，Value iteration 只是进行了一步求解，而 Policy iteration 进行了无穷多步来进行了真实的求解 state value，显然在现实运行算法中是无法做到的。 因此 Truncated policy iteration algorithm 就是进行迭代 n 步来求解。\"]},\"72\":{\"h\":\"truncated policy iteration algorithm 是否是收敛的\",\"t\":[\"20240811011334\"]},\"73\":{\"c\":[\"academic\"]},\"74\":{\"c\":[\"强化学习\"]},\"75\":{\"h\":\"RL5 - 蒙特卡洛方法 (Monte Carlo) model-free\",\"t\":[\"如何在没有模型 (即p(r∣s,a),p(s′∣s,a)等均未知) 的情况下进行估计 通过 Monte Carlo estimation. 其核心思想是： 若有一系列(i.i.d)样本采样，得到一个样本序列x1​,x2​,…,xN​ 那么对于随机变量X的估计可以为：\",\"E[x]≈xˉ=N1​j=1∑N​xj​\",\"该方法成立的数学依据是 大数定理 (Law of Large Numbers)样本必须是独立同分布(iid, independent and identically distributed)\",\"为什么考虑 mean estimation. 因为无论是 state value 还是 action value 其原始定义都是从期望出发的。\",\"vπ​(s)=E[Gt​∣St​=s];qπ​(s,a)=E[Gt​∣St​=s,At​=a]\"]},\"76\":{\"h\":\"1. MC Basic\",\"t\":[\"最简单的示例算法，用于解释 MC 的原理，但现实场景中不太经常使用，效率过低。\",\"核心思想：如何将 Policy iteration algorithm 转换为 model-free 的情况。\"]},\"77\":{\"h\":\"1.1 算法思路\",\"t\":[\"Policy iteration 算法的核心是 先根据当前策略计算出各个状态的 state value， 再将 state value 转换为 action value，更新策略的步骤就是选择此时 action value 最大的 action.\",\"{Policyevaluation:vπk​​=rπk​​+γPπk​​vπk​​Policyimprovement:πk+1​=argmaxπ​(rπ​+γPπ​vπk​​)​\",\"显然其核心关键就是在 PE 中 通过迭代算法求解 Bellman equation 的 state value后：\",\"对于 model-based 的情况, 因为 p(r∣s,a),p(s′∣s,a) 已知，我们可以很轻松的求出各个情况下的q(s,a)，从而选择每个状态下最大的 action value 即可。\",\"qπk​​(s,a)=r∑​p(r∣s,a)+γs′∑​p(s′∣s,a)vπk​​(s)\",\"对于 model-free 的情况，此时 p(r∣s,a),p(s′∣s,a) 未知，我们不能通过之前的方法来求出q(s,a)，需要从 action value 的定义出发，即：\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]\",\"从此可以发现，我们可以通过前面所引入的 mean estimation 方法，来进行求解 q(s,a).\"]},\"78\":{\"h\":\"1.2 如何估计\",\"t\":[\"从指定的 (s,a) 出发，根据策略 πk​, 我们可以生成一个 episode.\",\"这个 episode 的 return 为 g(s,a).\",\"显然，g(s,a) 就是前面 Gt​ 的一个 sample.\",\"假设我们有了一系列 从状态 s 出发, 采取动作 a 的 episodes, 即 g(j)(s,a). 那么我们可以对 qπk​​(s,a) 进行估计，即\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]≈N1​i=1∑N​g(i)(s,a).\"]},\"79\":{\"h\":\"1.3 具体算法\",\"t\":[\"与 Policy iteration algorithm 步骤类似 首先初始化一个随机的策略π0​，然后进行迭代，对于 kth 迭代，有：\",\"Step 1: Policy evaluation. 求在策略πk​下所有的 action value, q(s,a). 具体求解方法，如 1.2 节所述，只不过我们此时需要遍历所有的 action-state pair. 为什么不去求 state value，因为最终策略更新的核心仍然是 action value, 即使先估计了 state value, 我们仍需要估计 action value.\",\"Step 2: Policy improvement. 这是来求解 πk+1​(s)=argmaxπ​∑a​π(a∣s)qπk​​(s,a),foralls∈S 这个仍然与之前一致，采用 greedy policy，即对于每个状态，我们选取其 action value 最大的 action.πk+1​(ak∗​∣s)=1，其中ak∗​=argmaxa​qπk​​(s,a)\",\"20240811233346\"]},\"80\":{\"h\":\"2. MC Exploring Starts\",\"t\":[\"MC Exploring Starts 是针对 MC Basic 的一些改进，即对于数据(experience)更加高效利用。\"]},\"81\":{\"h\":\"2.1 Episode 的高效利用\",\"t\":[\"Visit: every time a state-action pair appears in the episode, it is called a visit of that state-action pair.\",\"考虑一个 episode, 跟随策略π,\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…\",\"对于 MC-Basic, 这一条 episode 仅用作估计 state-action pair (s1​,a2​) 的 action value q(s1​,a2​)，但存在一定的浪费, 对于一个 episode, 可以拆分为多个 episode, 从而进行多次利用.\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s1​a2​​s2​a3​​s5​a1​​…s2​a3​​s5​a1​​…s5​a1​​…​[originalepisode][episodestartingfrom(s2​,a4​)][episodestartingfrom(s1​,a2​)][episodestartingfrom(s2​,a3​)][episodestartingfrom(s5​,a1​)]​\",\"这样，我们不仅可以用来估计q(s1​,a2​), 还可以估计q(s2​,a4​),q(s2​,a3​)…\",\"Data-efficient methods:\",\"first-visit method 记录在 episode 中第一次出现的 state-action pair, 如果该 state-action pair 再次出现, 不记录 action value 估计中.\",\"every-visit method 对于每个 state-action pair, 都记录 action value 估计中.\"]},\"82\":{\"h\":\"2.2 高效地更新 Policy\",\"t\":[\"什么时候更新策略也是一个影响效率的因素。\",\"方法1：如 MC Based 一样，在收集到了足够多的 从给定的 state-action pair 出发的 episodes 后, 通过 mean estimation 估计了q(s,a)后, 才进行更新。 缺点，等候时间过长，只有当所有 episodes 均收集完，才能进行 策略更新。\",\"方法2：直接 uses the return of a single episode to approximate the action value. 这类算法统称为：Generalized policy iteration (GPI). 它会在 Policy-evaluation 和 policy-improvement 中不断切换，即不需要完全精确地求出 action value，就直接去更新策略。\"]},\"83\":{\"h\":\"2.3 MC Exploring Starts\",\"t\":[\"20240812004534\"]},\"84\":{\"h\":\"2.4 Exploring Statrts的解释\",\"t\":[\"Exploring 表示对于每一个 action-state pair (s,a), 都需要有多个 episodes, 这样才能去估计相应的qπ​(s,a). 如果存在一个 action value 未能访问，就不能确保所选择的 action 是最优的。\",\"Starts 表示对于对应 action-state pair (s,a) 的 episodes，每次都是从对应的状态 s 出发，选择对应的动作 a 进行的采样。 如果从其他状态出发，得到的 episode，如果经过了 (s,a)，那么这称为 visit , 但目前无法保证 visit 一定可以遍历所给定的 (s,a).\",\"据目前而言，Exploring Starts 是一个必要条件.\"]},\"85\":{\"h\":\"3. MC Eplison-Greedy\",\"t\":[\"将 Exploring Starts 条件转换掉，通过采取 Soft Policies 的方法。\"]},\"86\":{\"h\":\"3.1 Soft Policy\",\"t\":[\"A policy is called soft if the probability to take any action is positive. 显然 soft policy 是 stochastic 的，并且如果按照这样一个策略，在 episode 足够长的情况下，我们可以确保其可以遍历所有的 state-action pair.\"]},\"87\":{\"h\":\"3.2 -greedy policy\",\"t\":[\"在这里，我们采用的是 ϵ-greedy policies, 其属于 soft policies.\",\"π(a∣s)={1−∣A(s)∣ϵ​(∣A(s)∣−1),∣A(s)∣ϵ​,​forthegreedyaction,fortheother∣A(s)∣−1action,​\",\"其中 ϵ∈[0,1] 且 ∣A(s)∣ 为状态 s 的动作数量.ϵ-greedy policy 可以平衡 exploitation 和 exploration. 显然ϵ=0, policy 就是 greedy 的; 如果ϵ=1, 此时就是随机策略，其探索性就很强.\"]},\"88\":{\"h\":\"3.3 -greedy policy 引入 MC-based 算法中\",\"t\":[\"对于 MC Basic 以及 MC Exploring 中的 policy improvement 中，找的是在所有可能策略中的最优策略，因此是一个确定的贪心策略。\",\"20240812011140\"]},\"89\":{\"h\":\"3.3 算法流程\",\"t\":[\"20240812010538\"]},\"90\":{\"c\":[\"academic\"]},\"91\":{\"c\":[\"强化学习\"]},\"92\":{\"h\":\"RL6 - 随机近似理论与随机梯度下降算法\",\"t\":[\"针对 mean estimation 问题进行研究，因为在 RL 中 无论是 state value 还是 action value 其定义都是一个均值 (means)\",\"Stochastic approximation(SA): SA refers to a broad class of stochastic iterative algorithms soloving root finding or optimization problems.\"]},\"93\":{\"h\":\"1. 引言\"},\"94\":{\"h\":\"1.1 求均值的方法\",\"t\":[\"第一种：直接通过 E[x]≈xˉ:=N1​∑i=1N​xi​，进行估计，只有当样本全部收集完才能估计.\",\"第二种: 增量式的迭代算法. 假设:\",\"wk+1​=k1​i=1∑k​xi​,k=1,2,…\",\"对应的\",\"wk​=k−11​i=1∑k−1​xi​,k=2,3,…\",\"那么，wk+1​可以由wk​推导出来，即\",\"wk+1​​=k1​∑i=1k​xi​​=k1​(∑i=1k−1​xi​+xk​)=k1​((k−1)wk​+xk​)​=wk​−k1​(wk​−xk​)​\",\"因此，wk+1​=wk​−k1​(wk​−xk​)\"]},\"95\":{\"h\":\"2. Robbins-Monto(RM) algorithm\"},\"96\":{\"h\":\"2.1 问题引入\",\"t\":[\"假设我们需要求解如下方程:\",\"g(w)=0\",\"其中, w∈R 且需要被求解出来，g:R→R 为一个函数方程. 显然，如果对于 g(w) 已知的情况，我们可以通过一些特定的算法进行求解。 如果 g(w) 未知，就需要新的算法进行解决。\"]},\"97\":{\"h\":\"2.2 算法介绍\",\"t\":[\"RM 算法就可以用来求解当 g(w) 未知时的情况，即函数 g(w) 是一个黑盒，我们只能通过 输入序列: wk​, 得到含有噪音的观测值序列: g​(wk​,ηk​) 具体解决如下:\",\"wk+1​=wk​−ak​g​(wk​,ηk​),k=1,2,3,…\",\"其中:\",\"wk​ 是第 k 次方程根的估计.\",\"g​(wk​,ηk​)=g(wk​)+ηk​ 是第 k 次的观测值(含噪音).\",\"ak​ 是一个 positive coefficient.\"]},\"98\":{\"h\":\"2.3 收敛性分析\",\"t\":[\"Robbins-Monro Theorem In the Robbins-Monro algorithm, if\",\"0<c1​≤▽w​g(w)≤c2​,forallw; 要求g(w)必须是递增的，确保根是存在且唯一的。\",\"∑k=1∞​ak​=∞ 且 ∑k=1∞​ak2​<∞;∑k=1∞​ak2​=∞ 保证 ak​→0,k→0∑k=1∞​ak​=∞ 保证 ak​→0不要过快.\",\"E[ηk​∣Hk​]=0 且 E[ηk2​∣Hk​]<∞; 其中Hk​=wk​,wk−1​,…, 那么 wk​ converges with probability 1 (w.p.1) to the root w∗ satisfying g(w∗)=0.\",\"ak​=k1​是满足上面三个条件的. 但实际上我们往往是选择一个非常小的常数。\"]},\"99\":{\"h\":\"2.4 应用于 mean estimation 中\",\"t\":[\"比如我们要估计某个随机变量X的 E[X] 我们可以设计如下方程:\",\"g(w)≐w−E[X].\",\"那么只要求解 g(w)=0, 我们就可以得到 E[X] 的值。 同样，我们不能直接得到随机变量的值，而是对应的样本 x，sample of X. 即，我们得到的观测值是:\",\"g​(w,x)≐w−x\",\"我们可以修改为噪音 η 的形式，\",\"g​(w,η)​=w−x​=w−x+E[X]−E[X]=(w−E[X])+(E[X]−x)​≐g(w)+η​\",\"因此我们可以通过 RM 算法来进行求解\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​(wk​−xk​)\"]},\"100\":{\"h\":\"3. Stochastic gradient descent\"},\"101\":{\"h\":\"3.1 问题引入\",\"t\":[\"需要求解一个优化问题:\",\"wargmin​J(w)=E[f(w,X)]\",\"其中，\",\"w 是需要被优化的参数\",\"X 是一个随机变量\",\"w 和 X 可以是标量，也可以是向量. 对于函数 f(⋅) 输出为标量.\",\"对于这个问题，我们有以下几种方法:\",\"Method 1: 梯度下降法 (gradient descent, GD)\",\"wk+1​=wk​−αk​▽w​E[f(wk​,X)]=wk​−αk​E[▽w​f(wk​,X)]\",\"但由于 j(w) 是一个期望值，我们很难直接获得.\",\"Method 2: batch gradient descent (BGD) 借用 MC 的思想，我们可以将:\",\"E[▽w​f(wk​,X)]≈n1​i=1∑n​▽w​f(wk​,xi​).\",\"因此\",\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f(wk​,xi​)\",\"但需要大量的 samples 收集完毕才能进行一次迭代.\",\"Method 3: 随机梯度下降(SGD) 考虑能否仅用一次 sample 进行迭代.\",\"wk+1​=wk​−αk​▽w​f(wk​,xk​)\",\"但能否保证其精确度，以及是否可以到最后优化的成果。\"]},\"102\":{\"h\":\"3.2 SGD 分析\"},\"103\":{\"h\":\"mean estimation 问题转化\",\"t\":[\"我们可以将 均值估计 问题 转化为 一个 优化问题 进行求解：\",\"20240814014058\"]},\"104\":{\"h\":\"SGD 正确性和收敛性分析\",\"t\":[\"从 GD 到 SGD:\",\"wk+1​=wk​−αk​E[▽w​f(wk​,X)]⇓wk+1​=wk​−αk​▽w​f(wk​,x)​\",\"显然我们可以将 ▽w​f(wk​,x) 视为 E[▽w​f(wk​,x)] 的一个观测值(含噪声):\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]+η▽w​f(wk​,x)−E[▽w​f(wk​,x)]​​\",\"因为\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]\",\"因此，我们需要思考使用 SGD 时wk​→w∗ as k→∞ 是否成立。\",\"我们可以将 SGD 视为一个特殊情况下的 RM 算法 SGD的目标是 minimize\",\"J(w)=E[f(w,X)]\",\"而最小值问题，往往可以转化为导数为 0 的情况,\",\"▽w​J(w)=E[▽w​f(w,X)]=0\",\"显然，可以参考 RM 算法, 让\",\"g(w)=▽w​J(w)=E[▽w​f(w,X)]\",\"从而转换为一个 root-finding 问题. 相应的，对于观测值g​(w,η),\",\"g~​(w,η)​=∇w​f(w,x)=g(w)E[∇w​f(w,X)]​​+η∇w​f(w,x)−E[∇w​f(w,X)]​​.​\",\"因此，我们就可以通过 RM 算法进行求解g(w)=0,\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​▽w​f(wk​,xk​)\",\"对应收敛性证明\"]},\"105\":{\"h\":\"3.3 SGD 另一种问题描述方法 (deterministic formulation)\",\"t\":[\"在之前关于使用 SGD 算法的问题描述中，我们是引入了 随机变量 和 期望的情况. 我们可以将这个问题可以转化为一个随机变量的方法，从而引入 SGD 算法.\"]},\"106\":{\"h\":\"3.4 BGD MBGD SGDw\",\"t\":[\"20240814230747\"]},\"107\":{\"c\":[\"academic\"]},\"108\":{\"c\":[\"强化学习\"]},\"109\":{\"h\":\"RL7 - Temporal-Difference Learning\"},\"110\":{\"h\":\"1. 引入\",\"t\":[\"考虑一个复杂的均值估计问题: 计算\",\"ω=E[R+γv(X)],\",\"其中, R, X 均是随机变量，γ 是常数，v(⋅) 表示一个函数。 显然我们仍然可以通过 RM 算法进行求解，假设我们可以得到有关随机变量 R, X 的采样 {x},{r}\",\"g(w)g~​(w,η)​=w−E[R+γv(X)]=w−[r+γv(x)]=(w−E[R+γv(X)])+(E[R+γv(X)]−[r+γv(x)])≐g(w)+η​\",\"因此，我们可以将该问题定义为一个 root-finding 问题: g(w)=0. 相应的 RM 算法为:\",\"wk+1​=wk​−αk​g~​(wk​,ηk​)=wk​−αk​[wk​−[rk​+γv(xk​)]]\"]},\"111\":{\"h\":\"2. TD Learning of state value\",\"t\":[\"求解给定策略 π 的 state value，这样就可以与 policy improvement 结合去寻找最优策略。\"]},\"112\":{\"h\":\"2.1 算法描述\",\"t\":[\"算法所需的数据(experience): 根据给定的策略 π 所生成的数据 (s0​,r1​,s1​,…,st​,rt+1​,st+1​,…) or {(st​,rt+1​,st+1​)}\",\"相应的算法是:\",\"vt+1​(st​)vt+1​(s)​=vt​(st​)−αt​(st​)[vt​(st​)−[rt+1​+γvt​(st+1​)]]=vt​(s),∀s=st​,​\",\"其中 t=0,1,2,…, vt​(st​)是关于 vπ​(st​) 的估计。\",\"newestimatevt+1​(st​)​​=currentestimatevt​(st​)​​−αt​(st​)[vt​(st​)−TDtargetvt​ˉ​[rt+1​+γvt​(st+1​)]​​]​TDerrorδt​​\"]},\"113\":{\"h\":\"2.2 算法分析\",\"t\":[\"TD 算法是用来求解一个 给定策略 π 的 Bellman equation.\",\"根据 state value 的定义，对于策略 π 的 state value\",\"vπ​(s)=E[R+γG∣S=s],s∈S\",\"其中 G 是 discounted return。\",\"E[G∣S=s]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s)=E[vπ​(S′)∣S=s]\",\"因此，我们可以写出 Bellman equation 的新形式，称为 Bellman expection equation\",\"vπ​(s)=E[E+γvπ​(S′)∣S=s],s∈S\"]},\"114\":{\"h\":\"2.3 TD 算法 与 MC 算法的比较\"},\"115\":{\"h\":\"3. TD Learning of action value\",\"t\":[\"Sarsa (state-action-reward-state-action) Sarsa 算法其目的是用于直接估计 action value, 从而可以在 policy improvement 中直接根据 action value 进行更新即可。\",\"Sarsa 算法同样是来求解 Bellman equation:\",\"qπ​(s,a)=E[R+γqπ​(S′,A′)∣s,a],∀s,a\"]},\"116\":{\"h\":\"3.1 Sarsa\",\"t\":[\"假设我们具有 some experience {(st​,at​,rt+1​,st+1​,at+1​)} 对应的 Sarsa 算法如下来进行估计 action value:\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(sa​,at​)−αt​(st​,at​)[qt​(sa​,at​)−[rt+1​+γqt​(st+1​,at+1​)]]=qt​(s,a),∀(s,a)=(st​,at​)​\",\"其中 t=0,1,2,…, qt​(st​,at​) 是qπ​(st​,at​)的估计。\",\"收敛性情况\",\"20240817000114\",\"伪代码\",\"20240817000134\",\"20240817000230\"]},\"117\":{\"h\":\"3.2 n-step Sarsa\",\"t\":[\"20240817000500\",\"20240817000601\",\"20240817000642\"]},\"118\":{\"h\":\"3.3 Expected Sarsa\",\"t\":[\"20240817000331\",\"20240817000409\"]},\"119\":{\"h\":\"4. TD Learning of optimal action value\",\"t\":[\"Q-learning 算法是用来解决 action value 形式下的贝尔曼最优公式 (Bellman optimality equation in terms of action value)\",\"q(s,a)=E[Rt+1​+γamax​q(St+1​,a)∣St​=s,At​=a],∀s,a\"]},\"120\":{\"h\":\"4.1 Q-learning\",\"t\":[\"Q-learning 直接估计的是 optimal action value，因此不需要进行 policy improvement。\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(st​,at​)−αt​(st​,at​)[qt​(st​,at​)−[rt+1​+γa∈Amax​qt​(st+1​,a)]]=qt​(s,a),∀(s,a)=(st​,at​)​\"]},\"121\":{\"h\":\"4.2. off-policy | on-policy\",\"t\":[\"behavior policy: 是用来与环境进行交互，从而生成经验数据的策略\",\"target policy: 是我们不断进行更新的策略，最终优化的策略\"]},\"122\":{\"h\":\"on - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是一致的，即我通过这个策略与环境进行交互生成一系列经验，在通过经验来更新这个策略。\"]},\"123\":{\"h\":\"off - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是不同的，即我通过一个策略与环境进行交互生成一系列经验。再通过这些经验来不断改进更新另一个策略，这另一个策略会更新到最优的策略。\",\"Sarsa，MC 是 on-policy 的 Q-learning 是 off-policy 的\"]},\"124\":{\"h\":\"4.3 Q-learning 伪代码\",\"t\":[\"因为 Q-learning 是 off-policy 的，因此，如果我们强制让 target policy 与 behavior ppolicy 一致也是可以的，此时也可以是 on-policy 的。\"]},\"125\":{\"h\":\"off-poicy 版本\",\"t\":[\"20240818182057\",\"此时 target policy 就不需要是 ϵ−greedy 策略了，因为不需要 target policy 进行生成数据。\"]},\"126\":{\"h\":\"on-policy 版本\",\"t\":[\"20240818181917\"]},\"127\":{\"h\":\"5. TD 算法的统一形式和总结\",\"t\":[\"20240818182301\",\"20240818182231\"]},\"128\":{\"c\":[\"academic\"]},\"129\":{\"c\":[\"强化学习\"]},\"130\":{\"h\":\"RL8 - 值函数近似(Value Function Approximation)\",\"t\":[\"对于 q-value 的估计从 基于表格的 (tabular representation) 转换到 基于函数的 (function representation)\"]},\"131\":{\"h\":\"1. 引入\",\"t\":[\"通过使用一个函数来进行拟合 state values 或者 action values: v^(s,w)≈vπ​(s)， 其中w∈Rm是参数向量。\",\"可以提高存储效率\",\"提高泛化能力\"]},\"132\":{\"h\":\"2. Alogorithm of state value estimation\",\"t\":[\"目标: 寻找一个最优的参数w，使得v^(s,w)最接近真实的vπ​(s).\",\"共两步:\",\"定义目标函数\",\"优化目标函数的算法\"]},\"133\":{\"h\":\"2.1 Obejctive function\",\"t\":[\"J(w)=E[(vπ​(S)−v^(S,w))2]\",\"分析随机变量 S 的 probability distribution (即对于损失函数中的 expection 需要考虑怎样对状态进行平均):\"]},\"134\":{\"h\":\"uniform distributon\",\"t\":[\"认为所有状态都是同等重要的，即各个状态的可能性为∣S∣1​ 因此这种情况下的 objective function 可以写成:\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=∣S∣1​s∈S∑​(vπ​(s)−v^(s,w))2\",\"但实际情况可能并不是所有状态的概率都是一致的，基于给定策略下，一些状态可能很少被访问，另一些则频繁被访问，因此采用这种 objective function 就不太可行。\"]},\"135\":{\"h\":\"stationary distribution\",\"t\":[\"stationary: 表示是一种长时间的交互行为\",\"distributon: 表示是 状态 的分布\",\"通常也称为 steady-state distributon or limiting distributon.\",\"describes the long-run behavior of a Markov process. 即基于一个策略，我们不断地与环境进行交互，最终会达到一个平稳的状态，此时可以分析每一个状态在这个策略下的概率。\",\"设 {dπ​(s)}s∈S​ 表示 基于策略 π 下的 stationary distribution。其中 dπ​(s)≥0 且 ∑s∈S​dπ​(s)=1\",\"那么此时的 objective function 可以表示为：\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=s∈S∑​dπ​(s)(vπ​(s)−v^(s,w))2\",\"20240820181406\",\"20240820181718\"]},\"136\":{\"h\":\"2.2 Optimization algorithms 优化算法\",\"t\":[\"目前的优化算法只是在估计给定策略的 statevalue\",\"minisize obejctive function J(w), 采用 梯度下降 算法:\",\"wk+1​=wk​−αk​▽w​J(wk​)\",\"对应目标函数的真实梯度是：\",\"▽w​j(w)​=▽w​E[(vπ​(S)−v^(S,w))2]=E[▽w​(vπ​(S)−v^(S,w))2]=−2E[(vπ​(S)−v^(S,w))▽w​v^(S,w)]​\",\"这里包含了一个 Expection，因此可以考虑 SGD 方法进行求解：\",\"wk+1​=wk​+αk​(vπ​(st​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\",\"其中st​是随机变量S的一个样本。 但这里还有一个难点，vπ​(st​) 我们是无法估计的，这是我们所求的量，因此需要用近似算法来进行替代，从而使得算法可行。\"]},\"137\":{\"h\":\"Monte Carlo learning with function approximation\",\"t\":[\"设 gt​ 表示在一个 episode 中，从状态 st​ 出发的 discounted return。因此我们用 gt​ 来近似 vπ​(st​), 即：\",\"wk+1​=wk​+αk​(gt​−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"138\":{\"h\":\"TD Learning with function approximation\",\"t\":[\"在 TD 算法中，我们将 rt+1​+γv^(st+1​,wt​) 来近似 vπ​(st​), 因此对应算法为：\",\"wk+1​=wk​+αk​(rt+1​+γv^(st+1​,wt​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"139\":{\"h\":\"3. Sarsa with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γq^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"20240820184127\"]},\"140\":{\"h\":\"4. Q-learning with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γa∈A(st+1​)max​q^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"on-policy版本：\",\"20240820184405\"]},\"141\":{\"h\":\"5. Deep Q-learning (DQN)\",\"t\":[\"Deep Q-learning 目的是最小化目标函数(objective/loss function):\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"其中 (S,A,R,S′) 均是随机变量。\"]},\"142\":{\"h\":\"优化方法\",\"t\":[\"采用梯度下降。\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"对于 q^​(S,A,w) 求解梯度还是很好求的。 但对于 maxa∈A(S′)​q^​(S′,a,w) 其求解梯度比较难求，在 DQN 中采用一个 固定 的方法进行解决。 尝试将 y≐R+γmaxa∈A(S′)​q^​(S′,a,w) 中的 w 进行固定求解，具体如下：\",\"引入两个网络：\",\"main network q^​(s,a,w)w 会一直进行更新，根据梯度下降的公式。\",\"target network q^​(s′,a,wT​) 并不是一直进行更新，而是等 main network 更新一定次数后，将该网络的 w 复制到 wT​ 中\",\"将 objective function 修改为：\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))2]\",\"在计算 main network q^​(s,a,w) 的梯度时，将 q^​(S′,a,wT​) 中的 wT​ 固定不动，因此左侧那个类似 TD target 的就不是有关 w 的函数，不用进行求导，从而方便计算。 然后在更新了一定次数之后，在将 wT​=w 进行赋值。\",\"因此对应的损失函数的梯度可以修改为：\",\"▽w​J​=E[−2(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))▽w​q^​(S,A,w)]=E[−2(YT​−q^​(S,A,w))▽w​q^​(S,A,w)]​\",\"一些细节:\",\"w 和 wT​ 表示 the main and target networks 的参数，在初始化的时候是设为相同的。\",\"在每一次迭代时，我们需要从经验池 (the replay buffer) 中取出一定数量的样本 (a mini-batch of samples {(s,a,r,s')}) 进行训练。\",\"网络的输入包括 状态 s 和 动作 a. 在训练求解梯度时，我们先直接求解 target network 的输出，视为 yT​≐r+γmaxa∈A(s′)​q^​(s′,a,wT​)。 然后我们通过 mini-batch 样本 {(s,a,yT​)}, 通过梯度的算法来最小化对应的损失函数, 假设有 N 个样本，那么对应的损失函数求解为：\",\"J(w)=i=1∑N​yT​−q^​(s,a,w) 即可以通过梯度下降，来更新参数值\",\"wt+1​=wt​+αt​N1​i=1∑N​(yT​−q^​(si​,ai​,wt​))⋅▽w​q^​(si​,ai​,wt​)\"]},\"143\":{\"h\":\"经验回放 (replay buffer)\",\"t\":[\"20240820230827\",\"20240820230920\",\"20240820230944\"]},\"144\":{\"h\":\"伪代码\",\"t\":[\"20240820231024\",\"但在发表 DQN 的文章中，不太一样，在原文是 on-policy 且 main network 的输出是不一样的。\",\"20240820231205\"]},\"145\":{\"c\":[\"academic\"]},\"146\":{\"c\":[\"强化学习\"]},\"147\":{\"h\":\"RL9 - 策略梯度法(Policy gradient)\",\"t\":[\"之前介绍的方法都是 value-based 的方法，从这章开始时基于 policy-based 的方法。\",\"policy function approximation 是直接建立一个基于策略的目标函数来进行梯度上升的优化。\"]},\"148\":{\"h\":\"1. 基本思路\",\"t\":[\"将基于表格表示的策略 转换为 基于函数表示的策略。 即此时策略 π 可以描述为：\",\"π(a∣s,θ)\",\"其中，θ∈Rm表示参数向量，是我们需要进行优化的。\",\"当策略是以表格的形式保存时，我们定义最优的策略为 在该策略下的所有 state value 都是最大的。\",\"当策略是以函数的形式存在时，我们定义 最优的策略 为 可以最大化一个确定的常数指标(certain scalar metrics).\",\"Policy gradient 的基本步骤：\",\"确定 metrics/objective function，来定义最优的策略：J(θ)\",\"进行优化，如梯度上升算法\",\"θt+1​=θt​+α▽θ​J(θt​)\"]},\"149\":{\"h\":\"2. 目标函数定义\"},\"150\":{\"h\":\"2.1 average state value\",\"t\":[\"vˉπ​=s∈S∑​d(s)vπ​(s)=dTvπ​\",\"vˉπ​ 显然是 state value 的加权平均。\",\"d(s)≥0 是各个 state 的权重\",\"∑s∈S​d(s)=1, 我们可以认为 d(s) 是 概率分布，因此该指标可以描述为:\",\"vˉπ​=ES∼d​[vπ​(S)]\"]},\"151\":{\"h\":\"另一种表达\",\"t\":[\"J(θ)=E[t=0∑∞​γtRt+1​]\",\"20240826173749\"]},\"152\":{\"h\":\"d(s)的选择\",\"t\":[\"d 与策略 π 无关 这种情况我们将 d 表示为 d0​, vˉπ​ 表示为 vˉπ0​. 这种情况下的 d 可以根据对各个状态的重要程度进行选择： 一种是将所有状态视为同等重要，一种则是有所偏向。\",\"d 与策略 π 有关 d 表示为 dπ​(s), 即在策略 π 下的 stationary distribution。\"]},\"153\":{\"h\":\"2.2 average return value\",\"t\":[\"rˉπ​=s∈S∑​dπ​(s)rπ​(s)=ES∼d​[rπ​(s)]\",\"其中:\",\"rπ​(s)r(s,a)​≐a∈A∑​π(a∣s)r(s,a)=E[R∣s,a]=r∑​rp(r∣s,a)​\",\"rπ​(s)表示在策略π下 状态s时可以得到的平均reward。r(s,a)表示在单步情况下(在状态s采用动作a)时的平均reward。\"]},\"154\":{\"h\":\"另一种表达\",\"t\":[\"假设 agent 跟随一个 给定的策略 然后生成了一个 trajectory以及对应的 rewards (Rt+1​,Rt+2​,…)\",\"对应 average single-step reward along this trajectory is\",\"====​n→∞lim​n1​E[Rt+1​+Rt+2​+⋯+Rt+n​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​]s∑​dπ​(s)rπ​(s)rˉπ​​\"]},\"155\":{\"h\":\"3. 目标函数梯度求解\",\"t\":[\"这里在视频没有详细介绍，只给出了梯度的公式：\",\"▽θ​J(θ)​=s∈S∑​η(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"其中\",\"J(θ) 可以是 vˉπ​,rˉπ​,vˉπ0​ 任何一种。\",\"\\\"=\\\" 有表示 严格等于 近似 以及 成比例等于\",\"η 表示 state 的权重或者分布\",\"具体推导过程:\",\"▽θ​lnπ(a∣s,θ)▽θ​J(θ)​=π(a∣s,θ)▽θ​π(a∣s,θ)​=s∈S∑​d(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=s∈S∑​d(s)a∈A∑​π(a∣s,θ)▽θ​lnπ(a∣s,θ)qπ​(s,a)=ES∼d​[a∑​π(s∣S,θ)▽θ​lnπ(a∣S,θ)qπ​(S,a)]=ES∼d,A∼π​[▽θ​lnπ(A∣S,θ)qπ​(S,A)]≐E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"根据这个式子我们就可以通过 SGD 方法，从而可以进行近似求解：\",\"▽θ​J(θ)≈▽θ​lnπ(a∣s,θ)qπ​(s,a)\",\"一些特性 这里的策略是随机性 的，因为我们需要计算的是 lnπ(a∣s,θ), 因此我们需要保证对于所有的 s,a,θ\",\"π(a∣s,θ)≥0\",\"20240826180244\"]},\"156\":{\"h\":\"4. REINFORCE 梯度上升算法\",\"t\":[\"梯度上升算法的本质就是最大化目标函数 J(θ)\",\"θt+1​​=θt​+α▽θ​J(θ)=θt​+αE[▽θ​lnπ(A∣S,θt​)qπ​(S,A)]​\",\"而对应的真实梯度可以用一个估计的梯度来替代:\",\"θt+1​=θt​+α▽θ​lnπ(at​∣st​,θt​)qπ​(s,a)\",\"但还存在 qπ​(s,a) 是未知的，我们也可以进行近似：\",\"θt+1​=θt​+α▽θ​lnπ(a∣s,θt​)qt​(st​,at​)\",\"这里可以用不同的方法来近似 qπ​(s,a).\",\"Monte-Carlo based method， 我们便称为 REINFORCE\",\"也可以采用基于 TD 的算法 或者 其他的算法。\",\"一些细节\",\"20240826181340\",\"20240826181538\",\"20240826181638\"]},\"157\":{\"h\":\"REINFORCE 算法\",\"t\":[\"20240826181712\"]},\"158\":{\"c\":[\"academic\"]},\"159\":{\"c\":[\"强化学习\"]},\"160\":{\"h\":\"Java - 类与对象1\"},\"161\":{\"h\":\"类与对象\",\"t\":[\"类: 是对一类事物的描述，是抽象的、概念上的定义.对象: 是某一类事物实际存在的每个个体，因而也被称为实例（instance）， 是类的一个具体化个体.\",\"类的创建: 类名的首字母通常是大写的.\",\"public class Person {//这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } \",\"对象实例的创建 new Person() :\",\"public static void main(String[] args) { Person p = new Person(); } \",\"对于对象而言，其变量名存储的是对象的引用（类似于c++指针的情况），并非是所对应的对象本身，即\",\"public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p1存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p1 = new Person(); Person p2 = p1; // 我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制 } \",\"在创建了对象之后，就可以进行一定操作，如: 访问、修改对象的属性. 不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象. 关于对象类型的变量，我们也可以不对任何对象进行引用：\",\"public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \\\"小红\\\"; //我任性，就是要操作 System.out.println(p.name); } \",\"会出现异常，即空指针异常. 对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\"]},\"162\":{\"h\":\"方法的创建与使用\",\"t\":[\"类除了具有属性外，还可以定义一些方法来描述同一类的行为。 方法是语句的集合，是为了完成某件事情而存在的。 方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\",\"方法的定义如下:\",\"返回值类型 方法名称() { 方法体... } \",\"具体而言:\",\"public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\\\"我叫 \\\"+name+\\\" 今年 \\\"+age+\\\" 岁了！\\\"); } } \",\"方法的调用:\",\"public static void main(String[] args) { Person p = new Person(); p.name = \\\"小明\\\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } \"]},\"163\":{\"h\":\"方法的进阶使用\"},\"164\":{\"h\":\"this 的使用\",\"t\":[\"有时候我们的方法中可能会出现一些与成员变量重名的变量：\",\"void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的 //这里实际上是将方法参数的局部变量name赋值为本身 } \",\"我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\",\"void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } \",\"当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\",\"String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } \"]},\"165\":{\"h\":\"方法的重载\",\"t\":[\"有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况。\",\"一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\",\"int sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } \"]},\"166\":{\"h\":\"构造方法\",\"t\":[\"我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？ 要在对象创建时进行处理，我们可以使用**构造方法（构造器）**来完成。\",\"构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\",\"public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \\\"小明\\\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \\\"男\\\"; } } \",\"构造方法会在new的时候自动执行, 当然，我们也可以为构造方法设定参数：\",\"public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } \",\"注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法.\",\"当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\",\"public class Person { String name = \\\"未知\\\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \\\"男\\\"; } \",\"这里需要特别注意，成员变量的初始化，并不是在构造方法之后，而是在这之前就已经完成了.\",\"Person(String name, int age, String sex){ System.out.println(this.age); // 在赋值之前看看是否有初始值 // 这里是 this.age 而非 age // 此时this.age已经初始化完，但还未复制，this.age = 0 this.name = name; this.age = age; this.sex = sex; } \",\"我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\",\"public class Person { String name; int age; String sex; { System.out.println(\\\"我是代码块\\\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\\\"我被构造了\\\"); this.name = name; this.age = age; this.sex = sex; } } \"]},\"167\":{\"c\":[\"code\"]},\"168\":{\"c\":[\"java\"]},\"169\":{\"h\":\"Java - 泛型 2\"},\"170\":{\"h\":\"泛型 2\"},\"171\":{\"h\":\"泛型方法\",\"t\":[\"当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。\",\"当某个方法（无论是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：\",\"public class Main { public static void main(String[] args) { String str = test(\\\"Hello World!\\\"); } private static <T> T test(T t){ //在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法 return t; } } \",\"泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型 T 作为参数，同样的类型 T 作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成 String 类型，因此返回值也是 String 类型。\",\"public static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \\\"Hello\\\"); System.out.println(Arrays.toString(strings)); } private <T> void add(T[] arr, T t){ arr[0] = t; } \",\"实际上泛型方法在很多工具类中也有，比如说 Arrays 的排序方法：\",\"Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; } }); \",\"比如现在我们想要让数据从大到小排列，我们就可以自定义：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr)); } \",\"因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -> o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr)); } \",\"包括数组复制方法：\",\"public static void main(String[] args) { String[] arr = {\\\"AAA\\\", \\\"BBB\\\", \\\"CCC\\\"}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr)); } \",\"因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。\"]},\"172\":{\"h\":\"泛型界限\",\"t\":[\"上界 extend\",\"下界 super 仅适用于通配符，对于类型变量来说是不支持的\",\"现在有一个新的需求，现在没有 String 类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\",\"public class Score<T extends Number> { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; } } \",\"只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：\",\"实际上就像这样：\",\"20241106133117\",\"同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：\",\"public static void main(String[] args) { Score<? extends Integer> score = new Score<>(\\\"数据结构与算法\\\", \\\"EP074512\\\", 60); } \",\"那么既然泛型有上界，那么有没有下界呢？肯定的啊：\",\"20241106133159\",\"只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：\",\"20241106133211\",\"那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\",\"public static void main(String[] args) { Score<? extends Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 } \",\"但是我们限定下界的话，因为还是有可能是 Object，所以说依然是跟之前一样：\",\"public static void main(String[] args) { Score<? super Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Object o = score.getValue(); } \",\"通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。\"]},\"173\":{\"h\":\"类型擦除\",\"t\":[\"前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？\",\"public abstract class A <T>{ abstract T test(T t); } \",\"实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：\",\"public abstract class A { abstract Object test(Object t); //默认就是Object } \",\"当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：\",\"public abstract class A <T extends Number>{ //设定上界为Number abstract T test(T t); } \",\"那么编译之后：\",\"public abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类 } \",\"因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：\",\"public static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型 } \",\"只不过此时编译器会给出警告\"]},\"174\":{\"c\":[\"code\"]},\"175\":{\"c\":[\"java\"]},\"176\":{\"h\":\"Java - 集合类 1\"},\"177\":{\"h\":\"集合类 1\"},\"178\":{\"h\":\"集合类\",\"t\":[\"集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\",\"集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。\"]},\"179\":{\"h\":\"集合类与数组区别\",\"t\":[\"集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\",\"相同之处：\",\"它们都是容器，都能够容纳一组元素。\",\"不同之处：\",\"数组的大小是固定的，集合的大小是可变的。\",\"数组可以存放基本数据类型，但集合只能存放对象。\",\"数组存放的类型只能是一种，但集合可以有不同种类的元素。\"]},\"180\":{\"h\":\"集合根接口\",\"t\":[\"所有的集合类最终都是实现自集合根接口的\",\"Java 中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\",\"import java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"树脂666\\\"); } } \",\"比如 ArrayList 类，它的祖先就是Collection接口：\",\"20241120130452\",\"public interface Collection<E> extends Iterable<E> { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator<E> iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 <T> T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection<?> c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection<? extends E> c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection<?> c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate<? super E> filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator<E> each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection<?> c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); } } \"]},\"181\":{\"h\":\"List 列表\",\"t\":[\"List 列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。\",\"List 是集合类型的一个分支，它的主要特性有：\",\"是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置\",\"列表中允许存在重复元素 (只要 集合的 equal 方法判定为 True 就是重复)\",\"List 直接继承自前面介绍的 Collection 接口，其中很多地方重新定义了一次 Collection 接口中定义的方法，这样做是为了更加明确方法的具体功能\",\"可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作\",\"//List是一个有序的集合类，每个元素都有一个自己的下标位置 //List中可插入重复元素 //针对于这些特性，扩展了Collection接口中一些额外的操作 public interface List<E> extends Collection<E> { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection<? extends E> c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator<E> operator) { Objects.requireNonNull(operator); final ListIterator<E> li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\\\"unchecked\\\", \\\"rawtypes\\\"}) default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(); //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List<E> subList(int fromIndex, int toIndex); ... } \"]},\"182\":{\"h\":\"ArrayList\",\"t\":[\"在 ArrayList 中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity < 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 } } \",\"一般的，如果我们要使用一个集合类，我们会使用接口的引用：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\\\"科技与狠活\\\"); //使用add添加元素 list.add(\\\"上头啊\\\"); System.out.println(list); //打印集合类，可以得到一个非常规范的结果 } \",\"集合的各种功能我们都可以来测试一下\",\"特别注意一下，我们在使用 Integer 时，要注意传参问题：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除 } \",\"那要是这样写呢？\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list); } \",\"可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象：\",\"//ArrayList源码部分 public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false; } \",\"列表中允许存在相同元素，所以说我们可以添加两个一模一样的：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); System.out.println(list); } \",\"那要是此时我们删除对象呢，是一起删除还是只删除一个呢？\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); list.remove(str); System.out.println(list); } \",\"这种情况下，只会删除排在前面的第一个元素。\",\"集合类是支持嵌套使用的，一个集合中可以存放多个集合\",\"public static void main(String[] args) { List<List<String>> list = new LinkedList<>(); list.add(new LinkedList<>()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty()); } \",\"在 Arrays 工具类中，我们可以快速生成一个只读的List：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); //非常方便 System.out.println(list); } \",\"注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\")); System.out.println(list); } \",\"当然，也可以利用静态代码块：\",\"public static void main(String[] args) { List<String> list = new ArrayList<String>() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\\\"A\\\"); add(\\\"B\\\"); add(\\\"C\\\"); }}; System.out.println(list); } \",\"这里我们接着介绍另一个列表实现类，LinkedList 同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { transient int size = 0; //引用首结点 transient Node<E> first; //引用尾结点 transient Node<E> last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node<E> { //内部使用的结点类 E item; Node<E> next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node<E> prev; Node(Node<E> prev, E element, Node<E> next) { this.item = element; this.next = next; this.prev = prev; } } ... } \",\"LinkedList 的使用和 ArrayList 的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。\",\"只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。\"]},\"183\":{\"c\":[\"code\"]},\"184\":{\"c\":[\"java\"]},\"185\":{\"h\":\"Java - 集合类 2\"},\"186\":{\"h\":\"集合类 2\"},\"187\":{\"h\":\"迭代器\",\"t\":[\"实际上我们的集合类都是支持使用foreach语法 (增强 for 语法) 的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); } } \",\"但是由于仅仅是语法糖，实际上编译之后会修改为 迭代器 iterator 的形式：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } \"]},\"188\":{\"h\":\"简介\",\"t\":[\"通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：\",\"20241126232114\",\"一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：\",\"20241126232128\",\"每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。\",\"至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。\"]},\"189\":{\"h\":\"源码定义\",\"t\":[\"主要方法： next() | hasNext() | remove()\",\"public interface Iterator<E> { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\\\"remove\\\"); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } } \"]},\"190\":{\"h\":\"不同集合类 迭代器 实现用例\",\"t\":[\"ArrayList 就是直接按下标访问：\",\"public E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素 } \",\"LinkedList 就是不断向后寻找结点：\",\"public E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素 } \",\"虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现.\"]},\"191\":{\"h\":\"使用示例\",\"t\":[\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 } } \",\"注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。\",\"为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { System.out.println(s); } } \"]},\"192\":{\"h\":\"其他遍历 集合类 的方式\",\"t\":[\"在 Java8 提供了一个支持 Lambda 表达式的 forEach 方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作\",\"即对于 集合类 自身存在一个 forEach 的方法：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); list.forEach(System.out::println); } \",\"这个效果跟上面的写法是完全一样的，因为 forEach 方法内部本质上也是迭代器在处理，这个方法是在 Iterable 接口中定义的：\",\"default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 } } \"]},\"193\":{\"h\":\"介绍\",\"t\":[\"20241120130452\",\"//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了 public interface Iterable<T> { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator<T> iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator<T> spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } \",\"得益于 Iterable 提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用 foreach 语法：\",\"public class Test implements Iterable<String>{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator<String> iterator() { return new Iterator<String>() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \\\"测试\\\"; } }; } } \"]},\"194\":{\"h\":\"介绍\",\"t\":[\"这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：\",\"这种迭代器因为能够双向遍历，所以说可以反复使用。\",\"public interface ListIterator<E> extends Iterator<E> { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e); } \"]},\"195\":{\"c\":[\"code\"]},\"196\":{\"c\":[\"java\"]},\"197\":{\"h\":\"Java - 集合类 3\"},\"198\":{\"h\":\"集合类 3\"},\"199\":{\"h\":\"Quene 和 Deque\",\"t\":[\"其中 LinkedList 除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable \"]},\"200\":{\"h\":\"Quene 队列\",\"t\":[\"20241127001435\",\"我们先来看看队列接口，它扩展了大量队列相关操作：\",\"public interface Queue<E> extends Collection<E> { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek(); } \",\"我们可以直接将一个 LinkedList 当做一个队列来使用：\",\"public static void main(String[] args) { Queue<String> queue = new LinkedList<>(); //当做队列使用，还是很方便的 queue.offer(\\\"AAA\\\"); queue.offer(\\\"BBB\\\"); System.out.println(queue.poll()); System.out.println(queue.poll()); } \"]},\"201\":{\"h\":\"Deque 双端队列\",\"t\":[\"普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作\",\"利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用\",\"//在双端队列中，所有的操作都有分别对应队首和队尾的 public interface Deque<E> extends Queue<E> { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator<E> descendingIterator(); } \",\"我们可以来测试一下，比如我们可以直接当做栈来进行使用：\",\"public static void main(String[] args) { Deque<String> deque = new LinkedList<>(); deque.push(\\\"AAA\\\"); deque.push(\\\"BBB\\\"); System.out.println(deque.pop()); System.out.println(deque.pop()); } \"]},\"202\":{\"h\":\"其他集合类实现 队列\",\"t\":[\"当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：\",\"public static void main(String[] args) { Deque<String> deque = new ArrayDeque<>(); //数组实现的栈和队列 Queue<String> queue = new PriorityQueue<>(); //优先级队列 } \"]},\"203\":{\"h\":\"优先级队列\",\"t\":[\"这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的(4/5/10)，类似于VIP用户可以优先结束排队。\",\"我们也可以自定义比较规则，同样需要给一个 Comparator 的实现(10/5/4)：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的\",\"想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。\"]},\"204\":{\"h\":\"Set 集合\",\"t\":[\"Set集合，这种集合类型比较特殊\",\"set 接口中定义的方法都是 Collection 中直接继承的，因此，Set支持的功能其实也就和 Collection 中定义的差不多，只不过：\",\"不允许出现重复元素\",\"不支持随机访问（不允许通过下标访问）\",\"public interface Set<E> extends Collection<E> { // Set 集合中基本都是从 Collection 直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator<E> iterator(); Object[] toArray(); <T> T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection<?> c); //同样是只能插入那些不重复的元素 boolean addAll(Collection<? extends E> c); boolean retainAll(Collection<?> c); boolean removeAll(Collection<?> c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); } } \"]},\"205\":{\"h\":\"HashSet\",\"t\":[\"它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个 HashMap 在实现，这个需要我们学习了Map之后再来讨论）\",\"我们可以非常高效的从 HashSet 中存取元素，我们先来测试一下它的特性：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\\\"AAA\\\")); System.out.println(set); //可以看到，最后实际上只有一个成功插入了 } \",\"在 Set 接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除 Set 中的某个对象：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); System.out.println(set.remove(\\\"AAA\\\")); System.out.println(set); } \",\"由于底层采用哈希表实现，所以说无法维持插入元素的顺序：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"206\":{\"h\":\"LinkedHashSet\",\"t\":[\"那要是我们就是想要使用维持顺序的Set集合呢？\",\"我们可以使用 LinkedHashSet，LinkedHashSet 底层维护的不再是一个 HashMap，而是 LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\",\"public static void main(String[] args) { Set<String> set = new LinkedHashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"207\":{\"h\":\"TreeSet\",\"t\":[\"还有一种Set叫做TreeSet，它会在元素插入时进行排序：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>(); set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>((a, b) -> b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"目前，Set 集合只是粗略的进行了讲解，但是学习 Map 之后，我们还会回来看我们 Set 的底层实现，所以说最重要的还是 Map目前只需要记住 Set 的性质、使用即可。\"]},\"208\":{\"c\":[\"code\"]},\"209\":{\"c\":[\"java\"]},\"210\":{\"h\":\"Java - 集合类 4\"},\"211\":{\"h\":\"集合类 4\"},\"212\":{\"h\":\"Map\",\"t\":[\"映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\",\"Map 就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值\",\"Map 并不是 Collection 体系下的接口，而是单独的一个体系，因为操作特殊\"]},\"213\":{\"h\":\"Map 基本定义\",\"t\":[\"在 Map 中，这些映射关系被存储为键值对，Map 接口中定义的操作：\",\"// Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊 // 这里需要填写两个泛型参数， // 其中K就是键的类型，V就是值的类型， // 比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的 public interface Map<K,V> { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map<? extends K, ? extends V> m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set<K> keySet(); //返回Map中存放的所有值 Collection<V> values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set<Map.Entry<K, V>> entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry<K,V> { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ... } \"]},\"214\":{\"h\":\"HashMap\",\"t\":[\"底层采用哈希表实现\",\"基本示例\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \\\"小红\\\"); System.out.println(map.get(2)); //使用get方法根据键获取对应的值 } \",\"Map 中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的\",\"为了防止意外将之前的键值对覆盖掉，我们可以使用 putIfAbsent：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); map.putIfAbsent(1, \\\"小红\\\"); //Java8 新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); } \",\"我们在获取一个不存在的映射时，默认会返回 null 作为结果：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null } \",\"我们也可以为这种情况添加一个预备方案 getOrDefault，当 Map 中不存在时，可以返回一个备选的返回值：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); System.out.println(map.getOrDefault(3, \\\"备胎\\\")); //Java8新增操作，当不存在对应的键值对时，返回备选方案 } \",\"因为 HashMap 底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的\",\"如果需要维护顺序，我们同样可以使用 LinkedHashMap，它的内部对插入顺序进行了维护\"]},\"215\":{\"h\":\"HashMap 底层实现\",\"t\":[\"HashMap 的底层实现是由 哈希表 实现的。\",\"哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：\",\"20241130000528\",\"实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... static class Node<K,V> implements Map.Entry<K,V> { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node<K,V> next; ... } ... transient Node<K,V>[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } \",\"可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：\",\"HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板\",\"HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构\"]},\"216\":{\"h\":\"put 方法\",\"t\":[\"public V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; // 通过resize方法初始化底层哈希表，初始容量为16， // 后续会根据情况扩容，底层哈希表的长度永远是2的n次方 // 因为传入的哈希值可能会很大，这里同样是进行取余操作 // (n - 1) & hash 等价于 hash % n // 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果这个位置上什么都没有，那就直接放一个新的结点 else { // 这种情况就是哈希冲突了 Node<K,V> e; K k; // 如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount >= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash); //那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size > threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null } \"]},\"217\":{\"h\":\"resize 方法\",\"t\":[\"resize 在初始化时会调用一次，此外在每次扩容时会调用。\",\"根据上面的推导，我们在正常插入一个键值对时，会得到 null 返回值，而冲突时会得到一个被覆盖的值.\",\"HashMap的一个链表长度过大时，会自动转换为红黑树：\",\"20241130001811\",\"但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap > 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap >= MAXIMUM_CAPACITY) { // 如果旧的容量已经大于最大限制了， // 那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr << 1; //新的阈值也提升到原来的两倍 } else if (oldThr > 0) // 旧容量不大于0只可能是还没初始化 // 这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参 new 出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; // 新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值为负载因子乘以默认容量，负载因子默认为0.75 // 也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了， // 反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 } } \"]},\"218\":{\"h\":\"LinkedHashMap\",\"t\":[\"HashMap 并不会维持插入的顺序，LinkedHashMap 是直接继承自HashMap，具有 HashMap 的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序\",\"static class Entry<K,V> extends HashMap.Node<K,V> { // LinkedHashMap中的结点实现 Entry<K,V> before, after; // 这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); } } \",\"这样我们在遍历 LinkedHashMap 时，顺序就同我们的插入顺序一致。\",\"当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\"]},\"219\":{\"h\":\"TreeMap\",\"t\":[\"它的内部直接维护了一个红黑树（没有使用哈希表）\",\"因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的 TreeSet 是一样的\"]},\"220\":{\"h\":\"Map 的一些方法\"},\"221\":{\"h\":\"\",\"t\":[\"compute 会将指定 Key 的值进行重新计算，若 Key 不存在，v 会返回 null\",\"computeIfPresent 当 Key 存在时存在则计算并赋予新的值\",\"computeIfAbsent 不存在Key时，计算并将键值对放入Map中：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.compute(1, (k, v) -> { //compute 会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\\\"M\\\"; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -> { // 当Key存在时存在则计算并赋予新的值 return v+\\\"M\\\"; //这里返回原来的value+M }); System.out.println(map); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.computeIfAbsent(0, (k) -> { //若不存在则计算并插入新的值 return \\\"M\\\"; //这里返回M }); System.out.println(map); } \"]},\"222\":{\"h\":\"\",\"t\":[\"merge方法用于处理数据：\",\"public static void main(String[] args) { List<Student> students = Arrays.asList( new Student(\\\"yoni\\\", \\\"English\\\", 80), new Student(\\\"yoni\\\", \\\"Chiness\\\", 98), new Student(\\\"yoni\\\", \\\"Math\\\", 95), new Student(\\\"taohai.wang\\\", \\\"English\\\", 50), new Student(\\\"taohai.wang\\\", \\\"Chiness\\\", 72), new Student(\\\"taohai.wang\\\", \\\"Math\\\", 41), new Student(\\\"Seely\\\", \\\"English\\\", 88), new Student(\\\"Seely\\\", \\\"Chiness\\\", 89), new Student(\\\"Seely\\\", \\\"Math\\\", 92) ); Map<String, Integer> scoreMap = new HashMap<>(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -> scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -> System.out.println(\\\"key:\\\" + k + \\\"总分\\\" + \\\"value:\\\" + v)); } static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; } } \"]},\"223\":{\"h\":\"\",\"t\":[\"replace方法可以快速替换某个映射的值\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\">>>\\\"); //直接替换为新的 System.out.println(map); } \",\"也可以精准匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\"巴卡\\\", \\\"玛卡\\\"); //只有键和值都匹配时，才进行替换 System.out.println(map); } \",\"包括 remove 方法，也支持键值同时匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.remove(0, \\\"单走\\\"); //只有同时匹配时才移除 System.out.println(map); } \"]},\"224\":{\"h\":\"HashSet 底层实现\",\"t\":[\"它的底层很简单，底层是直接用 HashMap 套壳实现的。\",\"因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value\",\"public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable { private transient HashMap<E,Object> map; //对，你没看错，底层直接用 map 来做事 // 因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value private static final Object PRESENT = new Object(); // 直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap<>(); } ... // 你会发现所有的方法全是替身攻击 public Iterator<E> iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } } \",\"通过观察 HashSet 的源码发现，HashSet 几乎都在操作内部维护的一个HashMap ，也就是说，HashSet 只是一个表壳，而内部维护的 HashMap 才是灵魂！\",\"就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。\",\"所以说，HashSet 利用了 HashMap 内部的数据结构，轻松地就实现了 Set 定义的全部功能！\",\"再来看 TreeSet，实际上用的就是我们的 TreeMap\",\"LinkedSet 用的就是 LinkedMap\"]},\"225\":{\"c\":[\"code\"]},\"226\":{\"c\":[\"java\"]},\"227\":{\"h\":\"Java - Stream流\"},\"228\":{\"h\":\"Stream流\",\"t\":[\"Java 8 API添加了一个新的抽象称为 流Stream，可以让你以一种声明的方式处理数据。\",\"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\",\"Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\",\"这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\",\"元素流在管道中经过 中间操作（intermediate operation）的处理，最后由 最终操作(terminal operation)得到前面处理的结果。\",\"20241130004116\",\"我们就可以把一个 Stream 当做流水线处理：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"aaaa\\\", \\\"asdasda\\\", \\\"AssdW\\\", \\\"xx\\\", \\\"add\\\", \\\"Xss\\\", \\\"sdawErs\\\")); // 过滤 长度不超过 3 // 过滤 首字母不是大写字母 // 去除 重复字符串 // filter(...) 里面条件为 true 的会保留 // distinct 去重 list = list.stream() .filter(str -> str.length() > 3) .filter(str -> str.charAt(0) >= 'A' && str.charAt(0) <= 'Z') .distinct() .collect(Collectors.toList()); System.out.println(list); } \",\"类似\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); list.add(3); list = list.stream() .distinct() //去重（使用equals判断） .sorted((a, b) -> b - a) //进行倒序排列 .map(e -> e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } \",\"当遇到大量的复杂操作时，我们就可以使用 Stream 来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\",\"注意：不能认为每一步是直接依次执行的！\",\"实际上，stream 会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。\",\"接下来，我们用一堆随机数来进行更多流操作的演示：\",\"public static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random.ints(-100, 100) // 生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -> i < 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } \",\"我们可以生成一个统计实例来帮助我们快速进行统计：\",\"public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } \",\"普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -> i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } \",\"我们还可以通过flat来对整个流进行进一步细分：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"A,B\\\"); list.add(\\\"C,D\\\"); list.add(\\\"E,F\\\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -> Arrays.stream(e.split(\\\",\\\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } \",\"我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -> a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum); } \"]},\"229\":{\"c\":[\"code\"]},\"230\":{\"c\":[\"java\"]},\"231\":{\"h\":\"Java - Collections 工具类\"},\"232\":{\"h\":\"Collections 工具类\",\"t\":[\"我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。\",\"既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的 Collocations 类就是专用于集合的工具类\"]},\"233\":{\"h\":\"最大 | 最小\",\"t\":[\"我们想快速求得List中的最大值和最小值：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); Collections.max(list); Collections.min(list); } \"]},\"234\":{\"h\":\"二分搜索\",\"t\":[\"同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现 Comparable 接口的类）：\",\"public static void main(String[] args) { List<Integer> list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8)); } \"]},\"235\":{\"h\":\"快速填充\",\"t\":[\"我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list); } \",\"如果集合中本身没有元素，那么fill操作不会生效。\"]},\"236\":{\"h\":\"空集合\",\"t\":[\"有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：\",\"public static void main(String[] args) { List<Integer> list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常 } \",\"### 只读集合\",\"我们也可以将一个可修改的集合变成只读的集合：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); List<Integer> newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常 } \"]},\"237\":{\"h\":\"查找位置\",\"t\":[\"我们也可以寻找子集合的位置：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5))); } \",\"得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：\",\"public static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list.add(\\\"aaa\\\"); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list); } \",\"没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：\",\"public static void main(String[] args) { List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\\\"aaa\\\"); System.out.println(list); } \",\"checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：\",\"20241130005736\",\"是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。\"]},\"238\":{\"c\":[\"code\"]},\"239\":{\"c\":[\"java\"]},\"240\":{\"h\":\"Java - 集合类对象相等判定\"},\"241\":{\"h\":\"集合类对象相等判定\",\"t\":[\"Oject类中的 equals 方法比较的是地址，所以自己定义的类要自己重写 equals 等方法，否则给你当成 Object 类\",\"equals 方法 和 == 的区别\",\"集合类中并不是通过 == 进行判断的，都是根据 equals 方法进行判断的\",\"remove 也是根据 equals 进行判断来删除元素\",\"20241130012855\",\"对于 List 列表 判断两个元素是否相同，是根据 元素中的 equals 方法判断的\",\"public class Main { public static void main(String[] args) { List<Test> list = new ArrayList<>(); Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); list.add(t1); System.out.println(list.remove(t2)); // 这样会把 t1 移除，因为 Test 的 equals 判断修改成根据 name 进行判断 } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } } } \",\"对于 Map 以及 Set 而言 两个对象只有 equals 方法判断相同后，还需要判断 hashCode 方法也相同，才认为这两个元素是相同的\",\"对于 Object 定义中提到，如果两个对象通过 equals 判断相同，那么它们的 hashCode 也需要相同。\",\"因此，在重写 equals 方法时，也需要考虑重写 hashCode 方法，保证当两个对象通过 equals 方法判断相同时，它们通过 hashCode 得到的 hash 值也相同\",\"如下，因为重写了 equals 和 hashCode 所以只要 name 一致，通过 map 操作就是相同的\",\"public class Main { public static void main(String[] args) { Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); Map<Test, Integer> map = new HashMap<>(); map.put(t1, 2); System.out.println(map.get(t2)); } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } @Override public int hashCode() { return Objects.hashCode(name); } } } \"]},\"242\":{\"c\":[\"code\"]},\"243\":{\"c\":[\"java\"]},\"244\":{\"h\":\"Java - IO1\"},\"245\":{\"h\":\"IO流1\",\"t\":[\"一般在java.io中\",\"字节流：\",\"处理单位：以字节（8 位）为单位进行读写操作。\",\"适用场景：适用于处理所有类型的数据，包括文本、图片、音频、视频等二进制数据。\",\"主要类：InputStream 和 OutputStream 及其子类，如 FileInputStream 和 FileOutputStream。\",\"编码处理：不涉及字符编码转换，直接处理原始字节数据。\",\"字符流：\",\"处理单位：以字符（16 位）为单位进行读写操作。\",\"适用场景：专门用于处理文本数据，如读取和写入文本文件。\",\"主要类：Reader 和 Writer 及其子类，如 FileReader 和 FileWriter。\",\"编码处理：自动处理字符编码转换，适用于处理文本文件。\",\"主要区别：处理单位：字节流以字节为单位，字符流以字符为单位。 适用范围：字节流适用于所有类型的数据，字符流仅适用于文本数据。 编码处理：字节流不处理字符编码，字符流自动处理字符编码转换。 性能：字符流在处理文本数据时通常更高效，因为它们直接操作字符，减少了字节到字符的转换时间。\"]},\"246\":{\"h\":\"文件字节流\"},\"247\":{\"h\":\"输入流\",\"t\":[\"我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用\",\"public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\\\"路径\\\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } \",\"不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法：\",\"public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\\\"路径\\\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } \",\"这种语法只支持实现了AutoCloseable接口的类\"]},\"248\":{\"h\":\"文件读取\",\"t\":[\"read 方法 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } \",\"available 方法 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量） 因此与read结合，可以一次直接读取全部数据：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } \",\"也可以控制读取的数量：\",\"System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 \",\"skip 方法 可以跳过指定数量的字节\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } \"]},\"249\":{\"h\":\"输出流\",\"t\":[\"public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } \",\"输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容:\",\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\\\"lbwnb\\\".getBytes()); //也可以直接写入byte[] outputStream.write(\\\"lbwnb\\\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"250\":{\"h\":\"追加操作\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\", true)) { //true表示开启追加模式 outputStream.write(\\\"lb\\\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } \"]},\"251\":{\"h\":\"文件拷贝操作实现\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\"); FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); } } \"]},\"252\":{\"h\":\"文件字符流\",\"t\":[\"java.io.FileReader & java.io.FileWriter\"]},\"253\":{\"h\":\"\",\"t\":[\"字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用.\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } \",\"同理，字符流只支持char[]类型作为存储：\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"254\":{\"h\":\"\",\"t\":[\"writer除了write方法外，还有一个append方法，但效果是一致的\",\"public static void main(String[] args) { try(FileWriter writer = new FileWriter(\\\"output.txt\\\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } \"]},\"255\":{\"h\":\"类\",\"t\":[\"专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\",\"public static void main(String[] args) { File file = new File(\\\"test.txt\\\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } \",\"通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容:\",\"File file = new File(\\\"/\\\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } \",\"如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\",\"File file = new File(\\\"test.txt\\\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } \"]},\"256\":{\"c\":[\"code\"]},\"257\":{\"c\":[\"java\"]},\"258\":{\"h\":\"Java - IO2\"},\"259\":{\"h\":\"IO流2\"},\"260\":{\"h\":\"缓冲流\",\"t\":[\"虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，**提前将部分内容存入内存（缓冲区）**在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\",\"20250225181159\"]},\"261\":{\"h\":\"缓冲字节流\"},\"262\":{\"h\":\"缓冲字节读取流\",\"t\":[\"要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可:\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } \"]},\"263\":{\"h\":\"缓冲流特性\"},\"264\":{\"h\":\"1. 装饰着模式\",\"t\":[\"实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式\",\"对应缓冲流的close源码：\",\"public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } \",\"实际上这种模式是父类FilterInputStream提供的规范\"]},\"265\":{\"h\":\"2. 缓冲机制\",\"t\":[\"I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存BufferedInputStream 支持 reset() 和 mark() 操作 即通过 mark 标记位置, reset 可以返回之前标记过的位置。\",\"当调用 mark(readlimit) 之后，输入流会以某种方式保留之后读取的readlimit 数量的内容，当读取的内容数量超过 readlimit 则之后的内容不会被保留，当调用 reset() 之后，会使得当前的读取位置回到 mark() 调用时的位置。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \"]},\"266\":{\"h\":\"3. 缓冲流可以叠加\",\"t\":[\"即可以进行套娃：BufferedInputStream stream = new BufferedInputStream(new BufferedInputStream(new FileInputStream(\\\"test.txt\\\")))\"]},\"267\":{\"h\":\"缓冲字节输出流\",\"t\":[\"其实和BufferedInputStream原理差不多，只是反向操作\",\"try (BufferedOutputStream stream = new BufferedOutputStream(Files.newOutputStream(Paths.get(\\\"src/1.txt\\\")))){ stream.write(\\\"Hello Penguin!\\\".getBytes()); } catch (IOException e) { throw new RuntimeException(e); } \"]},\"268\":{\"h\":\"缓冲字符流\",\"t\":[\"BufferedReader | BufferedWriter\"]},\"269\":{\"h\":\"缓冲字符读取流\",\"t\":[\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"相比Reader更方便的是，它支持按行读取\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } \",\"读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } \",\"它同样也支持mark()和reset()操作\"]},\"270\":{\"h\":\"缓冲字符输出流\",\"t\":[\"public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\\\"output.txt\\\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\\\"汉堡做滴彳亍不彳亍\\\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } \"]},\"271\":{\"c\":[\"code\"]},\"272\":{\"c\":[\"java\"]},\"273\":{\"h\":\"Java - 类与对象2\"},\"274\":{\"h\":\"静态变量和静态方法\",\"t\":[\"Static 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。 我们通过使用 static 关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\",\"一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\",\"public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } \",\"public static void main(String[] args) { Person.info = \\\"让我看看\\\"; System.out.println(Person.info); } \",\"同样的，我们可以将方法标记为静态：\",\"static void test(){ System.out.println(\\\"我是静态方法\\\"); } \",\"静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样:\",\"因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值, 同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的.\"]},\"275\":{\"h\":\"静态变量初始化\",\"t\":[\"我们实际上是将 .class 文件丢给 JVM 去执行的，而每一个 .class 文件其实就是我们编写的一个类，我们在 Java 中使用一个类之前， JVM 并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\",\"访问类的静态变量，或者为静态变量赋值\",\"new 创建类的实例（隐式加载）\",\"调用类的静态方法\",\"子类初始化时\",\"其他的情况会在讲到反射时介绍\",\"所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\"]},\"276\":{\"h\":\"包的访问与控制\"},\"277\":{\"h\":\"包的声明和导入\",\"t\":[\"包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\",\"包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的 www.baidu.com ，后面的 baidu.com 就是域名，我们的包就可以命名为com.baidu，其中的.就是用于分割的，对应多个文件夹，比如com.test\",\"20240815234719\",\"我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 需要通过关键字 package，用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\",\"package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } \",\"当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中） 而当我们需要使用其他包中的类时，需要先进行导入才可以： 需要通过关键字 import 导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类:\",\"import com.test.entity.Person; //使用import关键字导入其他包中的类 import com.test.entity.*; \",\"Java会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\",\"不同类的重名问题 在不同包下的类，即使类名相同，也是不同的两个类：\",\"package com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } \",\"由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\",\"public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } \",\"我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\"]},\"278\":{\"h\":\"访问权限控制\",\"t\":[\"Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\",\"private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。\",\"什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。\",\"protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）\",\"public - 公共，标记为公共的内容，允许在任何地方被访问。\",\"当前类\",\"同一个包下的类\",\"不同包下的子类\",\"不同包下的类\",\"public\",\"✅\",\"✅\",\"✅\",\"✅\",\"protected\",\"✅\",\"✅\",\"✅\",\"❌\",\"默认\",\"✅\",\"✅\",\"❌\",\"❌\",\"private\",\"✅\",\"❌\",\"❌\",\"❌\",\"默认的情况下，在当前包以外的其他包中无法访问。\",\"如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\",\"public class Person { String name; int age; String sex; public static void test(){ System.out.println(\\\"我是静态方法！\\\"); } } \",\"静态导入：\",\"import static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } \"]},\"279\":{\"c\":[\"code\"]},\"280\":{\"c\":[\"java\"]},\"281\":{\"h\":\"Java - IO3\"},\"282\":{\"h\":\"IO流3\"},\"283\":{\"h\":\"转换流\",\"t\":[\"有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦\",\"public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\\\"test.txt\\\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\\\"lbwnb\\\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } \",\"同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现\",\"public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\\\"test.txt\\\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } \",\"InputStreamReader 和 OutputStreamWriter 本质也是Reader和Writer，因此可以直接放入 BufferedReader 来实现更加方便的操作。\"]},\"284\":{\"h\":\"打印流\",\"t\":[\"打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类\",\"public final static PrintStream out = null; \",\"因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。\",\"PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\",\"可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\",\"public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\\\"test.txt\\\"))){ stream.println(\\\"penguin\\\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } \",\"我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\",\"20250225192918\"]},\"285\":{\"h\":\"输入流\",\"t\":[\"之前使用的Scanner，使用的是系统提供的输入流\",\"public static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入 } \",\"我们也可以使用Scanner来扫描其他的输入流：\",\"public static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\\\"秘制小汉堡.txt\\\")); //将文件内容作为输入流进行扫描 } \"]},\"286\":{\"h\":\"数据流\",\"t\":[\"数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\",\"public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\\\"test.txt\\\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } \",\"用于写入基本数据类型:\",\"public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\\\"output.txt\\\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } \",\"注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\"]},\"287\":{\"h\":\"对象流\",\"t\":[\"ObjectOutputStream不仅支持基本数据类型，而且通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\"]},\"288\":{\"h\":\"对象序列化\",\"t\":[\"自己定义的类要序列化保存，则必须实现Serializable接口才能被序列化\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"penguin\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } \"]},\"289\":{\"h\":\"\",\"t\":[\"在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\",\"static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } \"]},\"290\":{\"h\":\"关键字\",\"t\":[\"如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"lbw\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } \",\"其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\"]},\"291\":{\"c\":[\"code\"]},\"292\":{\"c\":[\"java\"]},\"293\":{\"h\":\"Java - 多线程与反射1\"},\"294\":{\"h\":\"多线程\"},\"295\":{\"h\":\"进程与线程概念\",\"t\":[\"进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\",\"20250226173747\",\"在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时。\",\"线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\",\"在Java中，我们从开始，一直以来编写的都是单线程应用程序(运行main()方法的内容), 也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程:\",\"public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } \"]},\"296\":{\"h\":\"线程的创建和启动\",\"t\":[\"线程之间是同时运行的 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式\",\" /** * Creates a new Thread that inherits the given AccessControlContext. * This is not a public constructor. */ Thread(Runnable target, AccessControlContext acc) { init(null, target, \\\"Thread-\\\" + nextThreadNum(), 0, acc, false); } //Runnable @FunctionalInterface public interface Runnable { /** * When an object implementing interface <code>Runnable</code> is used * to create a thread, starting the thread causes the object's * <code>run</code> method to be called in that separately executing * thread. * <p> * The general contract of the method <code>run</code> is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } \"]},\"297\":{\"h\":\"方法\",\"t\":[\"20250226175843\",\"创建好后，通过调用start()方法来运行此线程:\",\"public static void main(String[] args) { Thread t = new Thread(() -> { //直接编写逻辑 System.out.println(\\\"我是另一个线程！\\\"); }); t.start(); //调用此方法来开始执行此线程 } \",\"Thread.currentThread() // 获取当前线程对象 Thread t = new Thread(() -> { //自定义线程名称 System.out.println(\\\"我是另一个线程！\\\"); }, \\\"name\\\"); Thread.currentThread().getName() // 获取线程名称 \"]},\"298\":{\"h\":\"方法\",\"t\":[\"run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\"]},\"299\":{\"h\":\"方法\",\"t\":[\"实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间\",\"Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s \",\"我们也可以使用stop()方法来强行终止此线程\",\"public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i < 50; i++) { System.out.println(\\\"打印:\\\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } \",\"虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\"]},\"300\":{\"h\":\"线程的休眠和中断\",\"t\":[\"20250226175843\",\"一个线程处于运行状态下，线程的下一个状态会出现以下情况：\",\"当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。\",\"当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。\",\"当线程出现异常或错误 / 被 stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。\",\"通过调用sleep()方法可以将当前线程进入休眠，使得线程处于等待状态一段时间。\",\"在sleep代码中可以发现，显示声明了会抛出一个InterruptedException异常\",\"public static native void sleep(long millis) throws InterruptedException; \"]},\"301\":{\"h\":\"中断\",\"t\":[\"每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。\",\"interrupt用法：\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\\\"线程被中断了！\\\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } \",\"通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\",\"Thread.interrupted(); /复位中断标记（返回值是当前是否有中断标记） \"]},\"302\":{\"h\":\"线程优先级\",\"t\":[\"Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！ 我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\",\"MIN_PRIORITY 最低优先级\",\"MAX_PRIORITY 最高优先级\",\"NOM_PRIORITY 常规优先级\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } \",\"优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\"]},\"303\":{\"h\":\"线程的礼让和加入\"},\"304\":{\"h\":\"主动让出CPU资源\",\"t\":[\"我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { if(i % 5 == 0) { System.out.println(\\\"让位！\\\"); Thread.yield(); } System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); } }); t1.start(); t2.start(); } \",\"观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\"]},\"305\":{\"h\":\"\",\"t\":[\"当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入:\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); if(i == 10){ try { System.out.println(\\\"线程1加入到此线程！\\\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } \",\"我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！\"]},\"306\":{\"c\":[\"code\"]},\"307\":{\"c\":[\"java\"]},\"308\":{\"h\":\"Java - 多线程与反射2\"},\"309\":{\"h\":\"多线程2\"},\"310\":{\"h\":\"线程锁和线程同步\"},\"311\":{\"h\":\"多线程下java内存管理\",\"t\":[\"20250226223324\",\"线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。\",\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：\",\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\",\"实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！ 好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\",\"比如我们可以来看看下面这个问题：\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\"]},\"312\":{\"h\":\"线程锁\",\"t\":[\"为了避免上面的这个现象，引入 线程锁 的概念\",\"synchronized(对象 | 类){ 代码块 } \",\"synchronized需要在括号中填入一个内容，必须是一个对象或是一个类，因此有对象锁和类锁区别（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\",\"当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC中我们还会讲到乐观锁，如CAS算法）\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\",\"synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\",\"private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"我们发现实际上效果是相同的，只不过这个锁不用你去给， 如果是静态方法，就是使用的类锁，\",\"public class Main { private static int i = 0; private static synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (Main.class){ // Main.class 就保证三个线程的锁是一致的 类锁 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"而如果是普通成员方法，就是使用的对象锁。\",\"public class Main { private static int i = 0; private synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { Main main = new Main(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (main){ // 使用 main 才正确 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。\"]},\"313\":{\"h\":\"死锁\",\"t\":[\"死锁是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\",\"20250226231025\",\"我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\\\"线程1\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\\\"线程2\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } \",\"所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？ 我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程号，然后 jstack pid 即可\",\"jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。\",\"因此，前面说不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\"]},\"314\":{\"c\":[\"code\"]},\"315\":{\"c\":[\"java\"]},\"316\":{\"h\":\"Java - 多线程与反射3\"},\"317\":{\"h\":\"多线程3\"},\"318\":{\"h\":\"和 方法\",\"t\":[\"Object 类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()\",\"他们其实是需要配合synchronized来使用的，平常环境下是无法使用的，只有当对象作为锁时，才能用这三个方法。\",\"实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了。\",\"wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁。wait需要捕获 InterruptedException终止异常。\",\"当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\",\"notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\",\"wait()方法是让该线程从 运行态 -> 等待(waiting)态; notify()则是让处于 等待态的线程变为 阻塞态，所以仍然需要等在运行的线程结束才会转为运行态。\",\"wait()支持参数，可以给他传一个时间参数进去的，是一种自动唤醒机制：在指定时间内，如果没有其他线程唤醒自己，则主动唤醒自己。\",\"如果是 wait() | wait(0) 则表示永久等待，必须要有 notify()才会转换\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { System.out.println(\\\"开始等待\\\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\\\"等待结束！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o1){ System.out.println(\\\"开始唤醒！\\\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i < 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } \"]},\"319\":{\"h\":\"\",\"t\":[\"专门创建一个独属于某个线程的变量\",\"20250309155822\",\"我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部只能存储一个变量，不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。\",\"ThreadLocal定义在主线程中\",\"public static void main(String[] args) throws InterruptedException { ThreadLocal<String> local = new ThreadLocal<>(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -> { local.set(\\\"penguin\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程1变量值已设定！\\\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"线程1读取变量值：\\\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -> { local.set(\\\"pig\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程2变量值已设定！\\\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } \",\"不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\"]},\"320\":{\"h\":\"\",\"t\":[\"为子线程的 local 设置初始值，如果子线程修改了也是可以\",\"public static void main(String[] args) { ThreadLocal<String> local = new InheritableThreadLocal<>(); Thread t = new Thread(() -> { local.set(\\\"lbwnb\\\"); new Thread(() -> { System.out.println(local.get()); }).start(); }); t.start(); } \"]},\"321\":{\"h\":\"定时器\"},\"322\":{\"h\":\"自己定义的定时器\",\"t\":[\"public static void main(String[] args) { new TimerTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -> { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \",\"public static void main(String[] args) { new TimerLoopTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -> { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \"]},\"323\":{\"h\":\"\",\"t\":[\"我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等\",\"public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000, 500); //执行一个延时任务 // 运行函数，延迟，循环间隔 } \"]},\"324\":{\"h\":\"不会终止\",\"t\":[\"虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\",\"public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } \",\"TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\",\"public Timer(String name) { thread.setName(name); thread.start(); } \",\"而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\",\"public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() && newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } } } \",\"我们可以通过调用cancel()方法来关闭它的工作线程：\",\"public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } \"]},\"325\":{\"c\":[\"code\"]},\"326\":{\"c\":[\"java\"]},\"327\":{\"h\":\"Java - 多线程与反射4\"},\"328\":{\"h\":\"多线程4\"},\"329\":{\"h\":\"守护线程\",\"t\":[\"t.setDaemon(true);\",\"守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。\",\"而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂。\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \",\"在守护线程中产生的新线程也是守护的：\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { Thread it = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \"]},\"330\":{\"h\":\"集合类\",\"t\":[\"java中也有些使用并行来进行操作的\",\"集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。\",\"并行流 parallelStream()\",\" default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作 } \",\"并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\",\" public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -> System.out.println(Thread.currentThread().getName()+\\\" -> \\\"+i)); } \",\"我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序。\",\"在Arrays数组工具类中，也包含大量的并行方法：\",\" public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } \",\"集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题\"]},\"331\":{\"h\":\"生产者与消费者\",\"t\":[\"所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\",\"通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\",\"public class Main { private static final Queue<Object> queue = new LinkedList<>(); public static void main(String[] args) { new Thread(Main::add, \\\"厨师1\\\").start(); new Thread(Main::add, \\\"厨师2\\\").start(); new Thread(Main::take, \\\"顾客1\\\").start(); new Thread(Main::take, \\\"顾客2\\\").start(); new Thread(Main::take, \\\"顾客3\\\").start(); } private static void add(){ while (true){ try { Thread.sleep(3000); synchronized (queue) { String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"put menu\\\"); queue.offer(new Object()); queue.notifyAll(); } } catch (InterruptedException e) { e.printStackTrace(); } } } private static void take(){ while (true) { try { synchronized (queue){ while(queue.isEmpty())queue.wait(); queue.poll(); String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"eat\\\"); } Thread.sleep(4000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \"]},\"332\":{\"c\":[\"code\"]},\"333\":{\"c\":[\"java\"]},\"334\":{\"h\":\"Java - 反射1\"},\"335\":{\"h\":\"反射1\"},\"336\":{\"h\":\"反射\",\"t\":[\"反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\",\"简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\"]},\"337\":{\"h\":\"JAVA 类加载机制\",\"t\":[\"20250310160214\",\"在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\",\"简单理解为： 默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。\",\"Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。\"]},\"338\":{\"h\":\"Class 类\",\"t\":[\"在类加载过程的同时，会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。\"]},\"339\":{\"h\":\"获取相应类的Class对象\",\"t\":[\"共有三种方法，无论哪种方法所获取到的 Class 对象始终是相同的。 所以类锁本质上就是对应的类的 Class 对象。\",\"public static void main(String[] args) throws ClassNotFoundException { Class<String> clazz = String.class; //使用class关键字，通过类名获取 Class<?> clazz2 = Class.forName(\\\"java.lang.String\\\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class<?> Class<?> clazz3 = new String(\\\"cpdd\\\").getClass(); //通过实例对象获取 } \"]},\"340\":{\"h\":\"基本数据类型的 Class 对象\",\"t\":[\"基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的.\",\"/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\\\"unchecked\\\") public static final Class<Integer> TYPE = (Class<Integer>) Class.getPrimitiveClass(\\\"int\\\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class<?> getPrimitiveClass(String name); //C++实现，并非Java定义 \",\"每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\",\"包装类型都有一个TYPE，其实也就是基本类型的Class，但包装类的Class和基本类的Class显然是不同的。\",\"public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } \"]},\"341\":{\"h\":\"数组的 Class 对象\",\"t\":[\"数组类型也是一种类型，只是编程不可见\",\"public static void main(String[] args) { Class<String[]> clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\\\"10\\\"))); //强制类型转换（会报错） } \"]},\"342\":{\"h\":\"Class 对象与多态\"},\"343\":{\"h\":\"类型比较\",\"t\":[\"正常情况下，我们使用instanceof进行类型比较, 它可以判断一个对象是否为此接口或是类的实现或是子类：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str instanceof String); } \",\"有了 Class 后，可以有其他方式判断类型：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } \",\"asSubClass()，判断是否为子类或是接口/抽象类的实现\",\" public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } \",\"getSuperclass()，可以获取到父类的Class对象\",\" public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } \",\"getGenericSuperclass()，获取父类的原始类型的Type\",\" public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } \",\"我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class\",\" public static void main(String[] args) { Integer i = 10; for (Class<?> anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } \",\"泛型的参数获取 ParameterizedType | TypeVariableImpl\",\"如果一个类的父类是泛型，其对应的 class 就不是正常的 class， 而是一个参数化类型:\",\"class sun.reflect.generics.reflectiveObjects.TypeVariableImpl\",\"对应地，我们从 参数化类型中可以获取到泛型在定义过程中的参数类型 getActualTypeArguments。\",\" public static void main(String[] args) { ParameterizedType type = (ParameterizedType) ArrayList.class.getGenericSuperclass(); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"在这种情况下，对应的 type 由于泛型中未定义，所以是 E, 对应的class 类型为 TypeVariableImpl\",\"20250310165216\",\"如果我们已经明确了继承的泛型的类型，那么对应返回的就是确定的类型 class\",\" <!-- Test.java --> public class Test <T> { } <!-- Student.java --> public class Student extends Test<String> { String name; int age; } <!-- Main.java --> public static void main(String[] args) { ParameterizedType type = (ParameterizedType) Student.class.getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170039\",\"此外，如果这种情况，由于类型擦除机制，仍然是获取不到具体的 class 的, 返回的仍然是 E\",\" public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"ASDF\\\")); ParameterizedType type = (ParameterizedType) list.getClass().getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170551\"]},\"344\":{\"c\":[\"code\"]},\"345\":{\"c\":[\"java\"]},\"346\":{\"h\":\"Java - 反射2\"},\"347\":{\"h\":\"反射2\"},\"348\":{\"h\":\"创建类对象\",\"t\":[\"可以通过Class对象来创建对象、调用方法、修改变量。\",\"我们通过 newInstance() 即可创建对应的对象实例。\",\"通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常\",\"当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。\",\"当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class<Student> clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\\\"萨日朗\\\"); } } \",\"在JDK9之后，不再推荐使用newInstance()方法, 而是通过获取构造器 getConstructor()，来实例化对象，通过获取类的构造方法（构造器）来创建对象实例，会更加合理。 我们可以使用getConstructor()方法来获取类的权限为 public 的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型\",\" public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getConstructor(String.class); Student student = constructor.newInstance(\\\"penguin\\\"); student.test(); } public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(){ System.out.println(this.name); } } \",\"当访问权限不是public的时候, 会无法找到此构造方法, 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）.\",\" Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\\\"what's up\\\"); student.test(); \"]},\"349\":{\"h\":\"调用类方法\",\"t\":[\"我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用。\",\"通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。\",\"// Student.java package com.test; public class Student { public void test(String str){ System.out.println(\\\"Penguin \\\"+str); } } // Main.java public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \\\"!!!\\\"); //通过Method对象的invoke方法来调用方法 } \",\"我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。\",\"同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用, 即通过 getDeclaredMethod + setAccessible 组合。\",\"// 将test()方法的权限修饰符改为private后 public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \\\"what's up\\\"); //通过Method对象的invoke方法来调用方法 } \",\"Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息(``)：\",\"// Student.java public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(String s, int i){ System.out.println(this.name); } } // Main.java public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Constructor<?> constructor = clazz.getConstructor(String.class); Object penguin = constructor.newInstance(\\\"penguin\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class, int.class); method.invoke(penguin, \\\"qq\\\", 123); System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 for (Parameter parameter : method.getParameters()) { System.out.println(parameter); } } \",\"20250312002044\",\"当方法的参数为可变参数时, 变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：\",\"Method method = clazz.getDeclaredMethod(\\\"test\\\", String[].class); \",\"当方法是静态方法时，invoke不需要对象参数，因为是属于类的。\",\"反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。\"]},\"350\":{\"h\":\"修改类的属性\",\"t\":[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段，在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，当访问private字段时，同样可以按照上面的操作进行越权访问（JAVA高版本不行，对反射进行了限制）\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, NoSuchFieldException { Integer i = 10; Field value = Integer.class.getDeclaredField(\\\"value\\\"); value.setAccessible(true); System.out.println(value.get(i)); value.set(i, 20); System.out.println(i); } \",\"通过反射可以直接将final修饰符直接去除\",\"public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\\\"value\\\"); Field modifiersField = Field.class.getDeclaredField(\\\"modifiers\\\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()&~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } \",\"我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：\",\"public static void main(String[] args) throws ReflectiveOperationException { List<String> i = new ArrayList<>(); Field field = ArrayList.class.getDeclaredField(\\\"size\\\"); field.setAccessible(true); field.set(i, 10); i.add(\\\"测试\\\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } \",\"实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！\",\"再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！\"]},\"351\":{\"c\":[\"code\"]},\"352\":{\"c\":[\"java\"]},\"353\":{\"h\":\"Java - 反射3\"},\"354\":{\"h\":\"反射3\"},\"355\":{\"h\":\"类加载器\",\"t\":[\"类加载器就是用于加载一个类的，但是类加载器并不是只有一个。\",\"思考： 既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？\",\"package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\\\"我姓🐴，我叫🐴nb\\\"); } } \",\"会出现以下报错：\",\"错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) \",\"但是我们明明在自己写的String类中定义了main方法，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行\",\"20250312005934\",\"实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了。\",\"public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } \"]},\"356\":{\"h\":\"自己编译的类加载到 JVM 中\",\"t\":[\"既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：\",\"package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\\\" > 我是测试方法！\\\"+str); } } \",\"通过javac命令，手动编译一个.class文件：\",\"javac src/main/java/com/test/Test.java \",\"编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：\",\"//定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class<?> defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\\\"Test.class\\\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class<?> clazz = classLoader.defineClass(\\\"com.test.Test\\\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } \",\"现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：\",\"try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"我们来试试看修改成员字段之后，再来调用此方法：\",\"try { Object obj = clazz.newInstance(); Field field = clazz.getField(\\\"text\\\"); //获取成员变量 String text; field.set(obj, \\\"华强\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。\"]},\"357\":{\"c\":[\"code\"]},\"358\":{\"c\":[\"java\"]},\"359\":{\"h\":\"Java - 注解\"},\"360\":{\"h\":\"注解\",\"t\":[\"注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。\",\"比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。\"]},\"361\":{\"h\":\"预设注解\",\"t\":[\"JDK预设了以下注解，作用于代码：\",\"@Override- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\",\"@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。\",\"@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）\",\"@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。\",\"@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\"]},\"362\":{\"h\":\"元注解\",\"t\":[\"元注解是作用于注解上的注解，用于我们编写自定义的注解：\",\"@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\",\"@Documented - 标记这些注解是否包含在用户文档中。\",\"@Target - 标记这个注解应该是哪种 Java 成员。\",\"@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\",\"@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\"]},\"363\":{\"h\":\"定义\",\"t\":[\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。\",\"@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。\",\"既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } \",\"这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：\",\"@Test public class Main { @Test public static void main(String[] args) { } } \",\"这样，一个最简单的注解就被我们创建了。\"]},\"364\":{\"h\":\"注解的使用\",\"t\":[\"我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } \",\"默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } \",\"public class Main { @Test(test = \\\"\\\") public static void main(String[] args) { } } \",\"我们也可以使用default关键字来为这些属性指定默认值：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \\\"ppenguin！\\\"; } \",\"当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } \",\"当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：\",\"@Test(\\\"aasd\\\") public static void main(String[] args) { } \",\"public class Main { @Test({\\\"value1\\\", \\\"value2\\\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } \"]},\"365\":{\"h\":\"反射获取注解\",\"t\":[\"既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：\",\" // Test.java import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } // Main.java public static void main(String[] args) { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：\",\"public static void main(String[] args) throws NoSuchMethodException { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getMethod(\\\"test\\\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。\",\"所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。\"]},\"366\":{\"c\":[\"code\"]},\"367\":{\"c\":[\"java\"]},\"368\":{\"h\":\"Java - 类与对象3\"},\"369\":{\"h\":\"封装 继承和多态\",\"t\":[\"封装、继承和多态是面向对象编程的三大特性。\",\"封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\",\"继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\",\"多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\",\"正是这三大特性，让我们的Java程序更加生动形象。\"]},\"370\":{\"h\":\"封装\"},\"371\":{\"h\":\"继承\",\"t\":[\"父类是 super 子类是 this\"]},\"372\":{\"h\":\"Object 类\",\"t\":[\"Object 是最顶层的类，所有其他类都是继承它的 方法： euqals toString clone hashcode\",\"public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class<?> getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } \"]},\"373\":{\"h\":\"方法重写\",\"t\":[\"方法的重载是为某个方法提供更多种类 而方法的重写是覆盖原有的方法实现,重写方法要求与父类的定义完全一致 比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了\",\"public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) && //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age && //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } \",\"在修改后 即使强制类型转换 但实际上还是在调用本身的方法\",\" Person p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); Person p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 \",\"我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用 super 关键字： satic 成员方法中不能用 super\",\"@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } \",\"如果父类的方法是 private, 那么无法重写\"]},\"374\":{\"h\":\"控制符\",\"t\":[\"final 对于成员变量，则表示只能赋一次值。只能在构造函数进行赋值(如果有初始值，构造函数也不能赋值)，其他地方不能修改 对于成员方法，会限制其子类不允许其重写所对应的成员变量 在 类 上 加 final, 表示这个类不能再被继承了\"]},\"375\":{\"h\":\"抽象类\",\"t\":[\"抽象类具有 抽象方法，正常实例化方法是无法创造抽象类的实例\",\"抽象方法是指：只保留方法的定义，并不编写方法的主体，具体的实现由 子类 来实现.\",\"要使用抽象类，我们只能去创建它的子类对象。\",\"抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类\",\"抽象方法的访问权限不能为 private, 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\",\"public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } \",\"而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法 不过如果子类也是抽象类，就不一定需要实现。\",\"public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \\\"工人\\\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } } \",\"发现对于 抽象类 中定义的 抽象方法，其子类的对应的方法的访问权限需要高于抽象类中的方法，且同样不能使用 private。 即 如果抽象方法在抽象类定义的是 public, 子类对应必须是 public 不能是 protected; 而如果抽象类定义的是 protected，子类也可以定义 public\"]},\"376\":{\"h\":\"接口\",\"t\":[\"接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\",\"接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\",\"实际上接口的目标就是将类所具有某些的行为抽象出来。\",\"可以理解为 接口 相当于 只有抽象类中的抽象方法，甚至都不是一个类了。\",\"接口里只能定义对应的抽象方法，不过可以省略 abstract 定义 并且默认在类中实现的权限是 public\",\"定义接口 interface\",\"实现接口 implements\",\"接口可以实现很多个，只需要用 逗号 隔开即可，类只能继承一个、\",\"所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\",\"java8开始，接口中的方法可以存在默认实现，default 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\",\"接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法 接口中定义的静态变量只能是public static final的 接口中定义的静态方法也只能是public的 这些可以省 直接int a = 1static void test()这种即可 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容\",\"接口是可以继承 (extends) 自其他接口的, 并且接口没有继承数量限制，接口支持多继承 接口的继承相当于是对接口功能的融合罢了\",\"接口的默认方法是保底的，只要一个类的父类或者自身有对应方法，就不会执行接口的默认方法\",\"接口中如果定义了与 Object 同名的方法，不能使用默认，因为其他类就算继承这个接口，由于类本身都是继承 Object 的，这个默认方法没有任何作用\",\"比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\",\"接口定义:\",\"public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } \",\"让类来使用这个接口\",\"public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\\\"我会学习！\\\"); } } \",\"接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用，即\",\"public class Main { public static void main(String[] args) { Study study = new Teacher(\\\"penguin\\\",18,\\\"male\\\"); study.study() //这里的话只能使用接口中的方法，以及Object的方法 } } \",\"接口同样支持向下转型：\",\"public static void main(String[] args) { Study study = new Teacher(\\\"小王\\\", 27, \\\"男\\\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } \",\"从Java8开始，接口中可以存在让抽象方法的默认实现：\",\"public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\\\"我是默认实现\\\"); } } \"]},\"377\":{\"h\":\"Object类中的 克隆方法\",\"t\":[\"这是浅拷贝，克隆出来的与原来的对象不是一个对象，但对象中的属性都是同一个地址\",\"克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\",\"浅拷贝： 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。\",\"深拷贝： 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。\",\"package java.lang; public interface Cloneable { //这个接口中什么都没定义 } \",\"具体实现克隆:\",\"public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\\\"我会学习！\\\"); } } \",\"克隆实现：\",\"public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } \"]},\"378\":{\"h\":\"枚举类\",\"t\":[\"public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } \",\"使用枚举类也非常方便，就像使用普通类型那样：\",\"public class Student { private Status status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } \",\"使用就像对象的参数一样:\",\"Status.RUNNING Status.STUDY Status.SLEEP \",\"枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\",\"//这里使用javap命令对class文件进行反编译得到 Compiled from \\\"Status.java\\\" public final class com.test.Status extends java.lang.Enum<com.test.Status> { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } \",\"枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\",\"public enum Status { RUNNING(\\\"睡觉\\\"), STUDY(\\\"学习\\\"), SLEEP(\\\"睡觉\\\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } \",\"public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } \"]},\"379\":{\"c\":[\"code\"]},\"380\":{\"c\":[\"java\"]},\"381\":{\"h\":\"Java - 类与对象4\"},\"382\":{\"h\":\"面向对象高级篇1\"},\"383\":{\"h\":\"基本类型包装类\",\"t\":[\"Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\"]},\"384\":{\"h\":\"所有包装类如下\",\"t\":[\"20241017002218\",\"其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\",\"byte -> Byte\",\"boolean -> Boolean\",\"short -> Short\",\"char -> Character\",\"int -> Integer\",\"long -> Long\",\"float -> Float\",\"double -> Double\",\"包装类型的自动装箱和拆箱机制 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想） 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\",\" public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 // 不需要 Integer i = new Integer(10) // 这里本质上就是被自动包装成了一个Integer类型的对象， // 只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的 Integer i = 10; int a = i; } \",\"因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\",\" public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } \",\"那么自动装箱的呢？\",\" public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\",\"但是如果超出这个缓存范围的话，就会得到不同的对象了：\",\"public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制。\"]},\"385\":{\"h\":\"包装类的方法\",\"t\":[\"包装类支持字符串直接转换\",\" public static void main(String[] args) { Integer i = new Integer(\\\"666\\\"); //直接将字符串的666，转换为数字666 System.out.println(i); // 字符串转Integer有多个方法： Integer i = Integer.valueOf(\\\"5555\\\"); Integer i = Integer.decode(\\\"0xA6\\\"); Integer.toHexString(166) } \"]},\"386\":{\"h\":\"特殊包装类\",\"t\":[\"BigInteger 和 BigDecimal 都在 java.math 中\",\"Void类 没啥意义 不能 new 只能 Void v = null\",\"BigInteger import java.math.BigInteger 用于计算超大数字，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字。 但不支持 自动装箱|拆箱机制，计算的话也只能通过 BigInteger 提供的方法进行计算。 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\",\" public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); BigInteger h = BigInteger.valueOf(100) // 乘法 BigInteger a = h.multiply(BigInteger.TEN) } \",\"BigDecimal import java.math.BigDecimal 浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算\",\"public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } \"]},\"387\":{\"c\":[\"code\"]},\"388\":{\"c\":[\"java\"]},\"389\":{\"h\":\"Java - 数组 | 字符串 | 正则表达式\"},\"390\":{\"h\":\"面向对象高级篇 2\"},\"391\":{\"h\":\"数组\",\"t\":[\"数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素。\"]},\"392\":{\"h\":\"定义\",\"t\":[\"数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建） 即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用 new 关键字\",\"public static void main(String[] args) { int[] array = new int[10]; //类型[]就表示这个是一个数组类型 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } \",\"创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的 其他定义方法:\",\"类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 \"]},\"393\":{\"h\":\"方法\",\"t\":[\"数组的 length 是在一开始就确定的，而且是 final类型 的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\",\" public static void main(String[] args) { int[] array = new int[10]; System.out.println(\\\"当前数组长度为：\\\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } \",\"array 虽然是继承于 Object，但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现，所以可能不满足真实需求。\"]},\"394\":{\"h\":\"访问元素\",\"t\":[\"for 或者 foreach\",\" public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i < array.length; i++) { System.out.print(array[i] + \\\" \\\"); } for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\\\" \\\"); //每一轮循环，i都会更新成数组中下一个元素 } } \"]},\"395\":{\"h\":\"特性\",\"t\":[\"这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\",\" public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; // 这样是不能赋值的 会报错 } \",\"由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的, 即 int[] arr = new int[10] 是不能 Object[] arrav = arr 这样的\",\"但是如果是引用类型的话，是可以的,因为父类都是 Object\",\" public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } \"]},\"396\":{\"h\":\"性质\",\"t\":[\" public static void main(String[] args) { final int[] a = {1,2,3,4}; // 值还是可以修改，只是数组的地址不准修改 a[0] = 4; // 允许 a = {2,4,8,7}; //不允许 } \"]},\"397\":{\"h\":\"多维数组\",\"t\":[\"既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的\",\"public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } \"]},\"398\":{\"h\":\"可变长参数\",\"t\":[\"public void function(参数类型...参数名称) 这样参数名称所表示的就是一个数组\",\"public class Person { String name; int age; String sex; // 可以传入 0 - N 个类型的实参 public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } } public static void main(String[] args) { Person person = new Person(); person.test(\\\"1！\\\", \\\"5！\\\", \\\"哥们在这跟你说唱\\\"); //这里我们可以自由传入任意数量的字符串 } \",\"注意，如果同时存在其他参数，那么可变长参数只能放在最后：\",\"public void test(int a, int b, String... strings){ } \"]},\"399\":{\"h\":\"函数的\",\"t\":[\"public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } \",\"可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：java com/test/Main lbwnb aaaa xxxxx 因此会读取命令行中的指令参数进行存储到 args 中。\"]},\"400\":{\"h\":\"字符串\",\"t\":[\"字符串类是一个比较特殊的类，它用于保存字符串。 我们知道，基本类型 char 可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组） Java中没有字符串这种基本类型，因此只能使用类来进行定义。 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\"]},\"401\":{\"h\":\"String 类\",\"t\":[\"String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象, 也可以象征性 new 不过没必要 如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了\",\"public static void main(String[] args) { String str1 = \\\"Hello World\\\"; String str2 = \\\"Hello World\\\"; System.out.println(str1 == str2); // 这样就不同 String str3 = new String(\\\"Hello World\\\"); String str4 = new String(\\\"Hello World\\\"); System.out.println(str3 == str4); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } \",\"因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用 ==， String类重载了equals方法用于判断和比较内容是否相同\",\"获取长度 str.length()\",\"public static void main(String[] args) { String str = \\\"Hello World\\\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } \",\"字符串类中提供了很多方便我们操作的方法， 比如字符串的裁剪 (substring)、分割操作 (split)\",\" public static void main(String[] args) { String str = \\\"Hello World\\\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); String[] strings = str.split(\\\" \\\"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } \",\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组: char[] chars = str.toCharArray()字符数组转字符串: String str = new String(chars)\"]},\"402\":{\"h\":\"StringBuilder 类\",\"t\":[\"StringBuilder 就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足\",\"public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\\\"AAA\\\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\\\"BBB\\\"); builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } \",\"字符串支持使用 + 和 += 进行拼接操作, 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\",\"对于变量来说\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } \",\"如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？ 这种情况实际上会被优化为下面的写法：\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } \"]},\"403\":{\"h\":\"正则表达式\",\"t\":[\"str.match(正则表达式)\",\"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\",\"public static void main(String[] args) { String str = \\\"oooo\\\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\\\"o+\\\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } \",\"用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\",\"字符\",\"描述\",\"*\",\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \\\"z\\\" 以及 \\\"zoo\\\"。***** 等价于 {0,}。\",\"+\",\"匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \\\"zo\\\" 以及 \\\"zoo\\\"，但不能匹配 \\\"z\\\"。+ 等价于 {1,}。\",\"?\",\"匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \\\"do\\\" 、 \\\"does\\\"、 \\\"doxy\\\" 中的 \\\"do\\\" 。? 等价于 {0,1}。\",\"{n}\",\"n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \\\"Bob\\\" 中的 o，但是能匹配 \\\"food\\\" 中的两个 o。\",\"{n,}\",\"n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \\\"Bob\\\" 中的 o，但能匹配 \\\"foooood\\\" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\",\"{n,m}\",\"m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \\\"fooooood\\\" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\",\"如果我们想要表示一个范围内的字符，可以使用方括号：\",\"public static void main(String[] args) { String str = \\\"abcabccaa\\\"; System.out.println(str.matches(\\\"[abc]*\\\")); //表示abc这几个字符可以出现 0 - N 次 } \",\"对于普通字符来说，我们可以下面的方式实现多种字符匹配：\",\"字符\",\"描述\",\"[ABC]\",\"匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中所有的 e o u a 字母。\",\"[^ABC]\",\"匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中除了 e o u a 字母的所有字母。\",\"[A-Z]\",\"[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。\",\".\",\"匹配除换行符（\\\\n、\\\\r）之外的任何单个字符，相等于 [^\\\\n\\\\r]\",\"[\\\\s\\\\S]\",\"匹配所有。\\\\s 是匹配所有空白符，包括换行，\\\\S 非空白符，不包括换行。\",\"\\\\w\",\"匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\",\"当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\",\"正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\"]},\"404\":{\"c\":[\"code\"]},\"405\":{\"c\":[\"java\"]},\"406\":{\"h\":\"Java - 内部类\",\"t\":[\"静态 属于 类， 成员 属于 对象。\"]},\"407\":{\"h\":\"内部类\",\"t\":[\"内部类顾名思义，就是创建在内部的类。\"]},\"408\":{\"h\":\"成员内部类 (属于 对象)\",\"t\":[\"成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用\",\"成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的， 如果我们要使用成员内部类，那么就需要创造一个对象，才能去 new 一个成员内部类。\",\"我们可以直接在类的内部定义成员内部类：\",\"public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\\\"我是成员内部类！\\\"); } } } \",\"public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 inner.test(); } \",\"注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.\",\"这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\\\"我是成员内部类：\\\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } \",\"每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\",\"20241027012950\",\"public static void main(String[] args) { Test a = new Test(\\\"小明\\\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\\\"小红\\\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } \",\"那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个 (就近原则) 如果需要指定为外部的对象，那么需要在前面添加外部类型名称Test.this.\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\\\"方法参数的name = \\\"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\\\"成员内部类的name = \\\"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\\\"成员内部类的name = \\\"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } \",\"包括对方法的调用和super关键字的使用，也是一样的：\",\"public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } \"]},\"409\":{\"h\":\"静态内部类 (属于 类)\",\"t\":[\"静态内部类就像静态方法和静态变量一样，是属于类的，不需要，依附任何对象我们可以直接创建使用。\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\\\"我是静态内部类！\\\"); } } } \",\"不需要依附任何对象，我们可以直接创建静态内部类的对象：\",\"public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } \",\"静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的\"]},\"410\":{\"h\":\"局部内部类\",\"t\":[\"(这种局部内部类的形式，使用频率很低，基本上不会用到) 局部内部类就像局部变量一样，可以在方法中定义。 基本定义是：(不需要声明访问权限，因为它作用范围就只是方法内)\",\"public 方法名(){ class 局部内部类名 { 内容 } } \",\"既然是在方法中声明的类，那作用范围也就只能在方法中了\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 public void test(){ System.out.println(\\\"我是局部内部类\\\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } \"]},\"411\":{\"h\":\"静态内部类编译特性\",\"t\":[\"package com.test; import com.test.entity.Test; public class Main { public static void main(String[] args) { Test.Inner.test(); } } \",\"package com.test.entity; public class Test { static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"内部类静态方法\\\"); } } } \",\"结果是：\",\"20241027015244\",\"说明这种情况下，只是初始化了内部类的，并没有初始化内部类，因为并没有使用到外部类的任何静态变量，所以只初始化了内部类。 因为在编译的时候，类的内部类它会单独生成一个 .class，当你使用内部类静态方法，不会调用外部类的 class 只有在你使用到外部类的静态变量或方法后，才会初始化外部类, 但还是先初始化内部类。\",\"package com.test.entity; public class Test { public static String name = \\\"penguin\\\"; static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"使用外部静态变量\\\" + name); System.out.println(\\\"内部类静态方法\\\"); } } } \",\"输出为：\",\"20241027015718\"]},\"412\":{\"h\":\"匿名内部类\",\"t\":[\"匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\",\"不能直接通过 new 的方式去创建一个抽象类或是接口对象，正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\",\"但我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象\",\"public abstract class Student { public abstract void test(); } \",\"public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\\\"我是匿名内部类的实现!\\\"); } }; student.test(); } \",\"此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）\",\"同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类 这样就是一个实现 接口 中方法 的匿名类，但类名必须与接口一致。\",\"package com.test.entity; public interface Study { void study(); } \",\"public class Main { public static void main(String[] args) { Study ss = new Study() { @Override public void study() { System.out.println(\\\"penguin\\\"); } }; ss.study(); } } \",\"匿名对象本身不能定义新的属性。匿名对象的类是在创建时匿名生成的，但它继承自一个现有的类或实现了一个接口。因此，匿名类只能访问其父类的属性或方法，无法直接定义新的属性.\",\"在 Java 中，匿名对象通常不能直接给属性赋值，因为匿名对象没有类名，无法显式定义构造函数或初始化块 因此，为了在创建匿名对象时进行属性初始化，Java 提供了一种特殊的语法，即使用初始化块 {}。\",\"当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 类似：\",\"package com.test.entity; public class Penguin { protected String apple; public void test(){ System.out.println(apple); } } \",\"public class Main { public static void main(String[] args) { Penguin pp = new Penguin(){ { apple = \\\"ppp\\\"; } }; pp.test(); } } \"]},\"413\":{\"h\":\"匿名内部类特性\",\"t\":[\"对于 匿名内部类 或者 Lambda 中，如果想用外部变量，只能使用 final 的变量，如果不是 final，会隐式修改为 final 即之后不能修改\",\"public static void main(String[] args) { int a = 10; // a = 20; // 如果修改了a 就会报错 Study pp = new Study{ @Override public void study(){ System.out.println(a); } } pp.test(); } \"]},\"414\":{\"h\":\"Lambda表达式\",\"t\":[\"如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式\",\"public static void main(String[] args) { Study study = () -> System.out.println(\\\"我是学习方法！\\\"); //是不是感觉非常简洁！ study.study(); } \",\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda 仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"如果有一个参数和返回值的话：\",\"public static void main(String[] args) { Study study = (a) -> { System.out.println(\\\"我是学习方法\\\"); return \\\"今天学会了\\\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } \",\"如果参数只有一个，那么可以省去小括号 如果方法体中只有一个返回语句，可以直接省去花括号和return关键字\",\"Study study = (a) -> { return \\\"今天学会了\\\"+a; //这种情况是可以简化的 }; ==================================== Study study = (a) -> \\\"今天学会了\\\"+a; ==================================== Study study = a -> \\\"今天学会了\\\"+a; \",\"如果一个方法的参数需要的是一个接口的实现:\",\"public static void main(String[] args) { test(a -> \\\"今天学会了\\\"+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } \",\"对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\"]},\"415\":{\"h\":\"方法引用\",\"t\":[\"方法引用 类名::方法名 就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义 参数一样，返回值一样 一样才行）\",\"public interface Study { int sum(int a, int b); //待实现的求和方法 } \",\"那么使用时候，可以直接使用Lambda表达式：\",\"public static void main(String[] args) { Study study = (a, b) -> a + b; } \",\"只不过还能更简单，因为Integer类中默认提供了求两个int值之和的静态方法：\",\"public static void main(String[] args) { Study study = (a, b) -> Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } ================= 方法引用 类名::方法名 ========================= public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } \",\"方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。\",\"任何方法都可以通过方法引用作为实现：\",\"public interface Study { String study(); } \",\"如果是普通成员方法 (成员方法只能通过 对象 调用，不是静态方法)，我们同样需要使用对象来进行方法引用：\",\"public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \\\"卡布奇诺今犹在，不见当年倒茶人。\\\"; } \",\"因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\",\"public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } \",\"反正只要是符合接口中方法的定义的，都可以直接进行方法引用。\"]},\"416\":{\"c\":[\"code\"]},\"417\":{\"c\":[\"java\"]},\"418\":{\"h\":\"Java - 异常\"},\"419\":{\"h\":\"面向对象高级篇 4\"},\"420\":{\"h\":\"异常机制\"},\"421\":{\"h\":\"异常类型\",\"t\":[\"我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等. 他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自 Exception 类\",\"运行时异常 继承自 RuntimeException 在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。 所有的运行时异常都继承自 RuntimeExceptionRuntimeException 是继承 Exception\",\"编译时异常 继承 Exception 编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！ 默认继承自 Exception 类的异常都是编译时异常。 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\",\"protected native Object clone() throws CloneNotSupportedException; \",\"20241029001425\",\"错误 Error错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了。 比如 OutOfMemoryError 就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\"]},\"422\":{\"h\":\"自定义异常\",\"t\":[\"异常其实就两大类，一个是编译时异常 Exception，一个是运行时异常 RuntimeException。 我们自定义异常也是从这两类中进行选择。\",\"自定义编译时异常 编译时异常只需要继承 Exception 就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\",\"public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } \",\"自定义运行时异常 运行时异常只需要继承 RuntimeException 就行了\",\"public class TestException extends RuntimeException{ public TestException(String message){ super(message); } } \"]},\"423\":{\"h\":\"抛出异常\",\"t\":[\"当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\",\"public static int test(int a, int b) { if(b == 0) throw new ArithmeticException(\\\"被除数不能为0\\\"); //throw new RuntimeException(\\\"被除数不能为0\\\"); //使用throw关键字来抛出异常 return a / b; } \",\"异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在 RuntimeException 的构造方法中我们可以写入原因。\",\"注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以，因为不这样就无法编译了： throws Exception\",\"就是说如果这个函数结束时有异常，要么自己处理好，要么就往上一级函数上 throw\",\"private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\\\"我是编译时异常！\\\"); } \",\"如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\",\"private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } \",\"最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\",\"@Override protected Object clone() { return new Object(); } \"]},\"424\":{\"h\":\"异常的处理\",\"t\":[\"当程序没有按照我们理想的样子运行而出现异常时（默认会交给 JVM 来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息） 现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获\",\"异常处理：要么一直 throw 交给上一级函数 最终到 main 给 jvm 处理; 要么在当前函数通过 try-catch 进行捕获。\",\"无论是否出现异常，都会在最后执行任务，可以交给 finally 语句块来处理，可以只跟 try 使用。\",\"public static void main(String[] args) { // try...catch 进行异常捕获 try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\\\"异常错误信息：\\\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\\\"程序继续正常运行！\\\"); } \",\"如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用 try-catch 语句块进行异常的捕获，不然就无法通过编译.\",\"public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } \",\"当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\",\"public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } \",\"注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到\",\"public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\\\"捕获到异常\\\"); } } \",\"当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 但是要注意一下顺序 try {} catch { xxxException | xxxException e }{ }\",\"try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } // 可以简写为 try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } \"]},\"425\":{\"h\":\"断言表达式\",\"t\":[\"我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下。\",\"assert断言表达式，如果 assert 后面的表达式判断结果为 false，将抛出 AssertionError 错误。\",\"比如我们可以判断变量的值，如果大于10就抛出错误：\",\"public static void main(String[] args) { int a = 10; assert a > 10; } \"]},\"426\":{\"c\":[\"code\"]},\"427\":{\"c\":[\"java\"]},\"428\":{\"h\":\"Java - 工具类\"},\"429\":{\"h\":\"面向对象高级篇 6\",\"t\":[\"工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\"]},\"430\":{\"h\":\"常用工具类\"},\"431\":{\"h\":\"数学工具类\",\"t\":[\"Math类 是在 java.util 中，因此可以直接调用。\",\"public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } \",\"随机数生成 Random 类\",\"import java.util.Random; public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i < 30; i++) { System.out.print(random.nextInt(100)+\\\" \\\"); //nextInt方法可以指定创建0 - x之内的随机数 } } \"]},\"432\":{\"h\":\"数组工具类\",\"t\":[\"Arrays类 是在 java.util 中，因此可以直接调用。\",\"一些方法：Arrays.toString | Arrays.sort | Arrays.fill | Arrays.copyOfArrays.deepToString 可以对 多维数组 打印\",\"Arrays类 用于便捷操作数组，比如我们想要打印数组，可以直接通过 toString 方法转换字符串：\",\"public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } \"]},\"433\":{\"c\":[\"code\"]},\"434\":{\"c\":[\"java\"]},\"435\":{\"h\":\"Java - 泛型 1\"},\"436\":{\"h\":\"泛型 1\"},\"437\":{\"h\":\"使用泛型的原因\",\"t\":[\"为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个 Score 类呢？\",\"现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\",\"可以直接使用一个 Object 类进行存储成绩\",\"public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } \",\"以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\",\"public static void main(String[] args) { Score score = new Score(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", \\\"优秀\\\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } \",\"使用Object类型作为引用，对于使用者来说，由于是 Object 类型，所以说并不能直接判断存储的类型到底是 String 还是 Integer ，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\",\"所以说这种解决办法虽然可行，但并不是最好的方案。\",\"为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效 率。\"]},\"438\":{\"h\":\"泛型类\",\"t\":[\"泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\",\"我们可以将一个类定义为一个泛型类：\",\"public class Score<T> { //泛型类需要使用<>，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; } } \",\"具体使用:\",\"public static void main(String[] args) { Score<String> score = new Score<String>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); // 因为现在有了类型变量，在使用时同样需要跟上<>并在其中填写明确要使用的类型 // 这样我们就可以根据不同的类型进行选择了 // 这种形式也可以 Score<String> score = new Score<>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value); } \",\"泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！\",\"因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用对象定义的泛型的\",\"我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个 Object 类型的变量，因为无论具体类型是什么，一定是 Object 类的子类。\",\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组.\",\"具体类型不同的泛型类变量，不能使用不同的变量进行接收 \",\"如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 ? 通配符 就好像默认其是 Object 类型\",\" public static void main(String[] args) { Test<?> test = new Test<Integer>(); test = new Test<String>(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成 Object } \",\"泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个 那么在使用时，就需要将这三种类型都进行明确指定\",\" public class Test<A, B, C> { //多个类型变量使用逗号隔开 public A a; public B b; public C c; } ------------------------------------- public static void main(String[] args) { Test<String, Integer, Character> test = new Test<>(); //使用钻石运算符可以省略其中的类型 test.a = \\\"lbwnb\\\"; test.b = 10; test.c = '淦'; } \",\"泛型只能确定为一个引用类型，基本类型是不支持的, 如果要存放基本数据类型的值，我们只能使用对应的包装类\",\"当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的\"]},\"439\":{\"h\":\"泛型和多态\",\"t\":[\"不只是类，包括接口、抽象类，都是可以支持泛型的：\",\"public interface Study<T> { T test(); } \",\"当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：\",\"public class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study<Integer> { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } } } \",\"或者是继续摆烂，依然使用泛型：\",\"public class Main { public static void main(String[] args) { A<String> a = new A<>(); String i = a.test(); } static class A<T> implements Study<T> { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } } } \",\"继承也是同样的：\",\"static class A<T> { } static class B extends A<String> { } \"]},\"440\":{\"c\":[\"code\"]},\"441\":{\"c\":[\"java\"]},\"442\":{\"h\":\"Java8回顾\"},\"443\":{\"h\":\"Java8\"},\"444\":{\"h\":\"Lambda 表达式\"},\"445\":{\"h\":\"匿名内部类\",\"t\":[\"在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：\",\"public static void main(String[] args) { //现在我们想新建一个线程来搞事情 Thread thread = new Thread(new Runnable() { //创建一个实现Runnable的匿名内部类 @Override public void run() { //具体的实现逻辑 System.out.println(\\\"Hello World!\\\"); } }); thread.start(); } \",\"在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在run()方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。\"]},\"446\":{\"h\":\"Lambda 使用\",\"t\":[\"在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减。\",\"真正有用的那一部分代码，实际上就是我们对run()方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，现在只需要一个简短的lambda表达式即可：\",\"public static void main(String[] args) { //现在我们想新建一个线程来做事情 Thread thread = new Thread(() -> { System.out.println(\\\"Hello World!\\\"); //只需留下我们需要具体实现的方法体 }); thread.start(); } \",\"即 原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于() ‐> { 代码语句 }的形式进行替换即可。\",\"这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。\",\"但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过invokedynamic指令实现的\",\"匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：\",\"//现在我们想新建一个线程来做事情 Thread thread = new Thread(() -> { throw new UnsupportedOperationException(); //这里我们拋个异常看看 }); thread.start(); \",\"alt text\",\"可以看到，实际上是Main类中的lambda$main$0()方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。 所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。 比如Runnable接口需要一个方法体对它的run()方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。\"]},\"447\":{\"h\":\"Lambda 具体规范\",\"t\":[\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"Java中接口的方法默认是 public abstract, 变量默认是 public static final\",\"比如我们之前使用的Runable类：\",\"@FunctionalInterface //添加了此注解的接口，都支持lambda表达式，符合函数式接口定义 public interface Runnable { public abstract void run(); //有且仅有一个抽象方法，此方法返回值为void，且没有参数 } \",\"因此，Runable的的匿名内部类实现，就可以简写为：\",\"Runnable runnable = () -> { }; \",\"我们也可以写一个：\",\"@FunctionalInterface public interface Test { //接口类型 String test(Integer i); //只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果 } \",\"它的Lambda表达式的实现就可以写为：\",\"Test test = (Integer i) -> { return i+\\\"\\\"; }; //这里我们就简单将i转换为字符串形式 \",\"不过还可以进行优化，首先方法参数类型是可以省略的：\",\"Test test = (i) -> { return i+\\\"\\\"; }; \",\"由于只有一个参数，可以不用添加小括号（多个参数时需要）：\",\"Test test = i -> { return i+\\\"\\\"; }; \",\"由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：\",\"Test test = i -> i+\\\"\\\"; \"]},\"448\":{\"h\":\"应用现有的方法函数作为方法体 (方法引用)\",\"t\":[\"Lambda 本质是：我们为所需要的接口提供了一个方法作为它的实现\",\"除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：\",\"String test(Integer i); //接口中的定义 \",\"public static void main(String[] args) { Test test = Main::impl; //使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现 } public static String impl(Integer i){ return \\\"我是已经存在的实现\\\"+i; } \",\"所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来）\"]},\"449\":{\"h\":\"方法引用 举例\",\"t\":[\"比如我们现在需要对一个数组进行排序：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; //来个数组 Arrays.sort(array, new Comparator<Integer>() { //Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可 @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); System.out.println(Arrays.toString(array)); //按从小到大的顺序排列 } \",\"但是我们发现，Integer类中有一个叫做compare的静态方法：\",\"public static int compare(int x, int y) { return (x < y) ? -1 : ((x == y) ? 0 : 1); } \",\"返回正数，第二个参数排前面，返回负数，第一个参数排前面\",\"这个方法是一个静态方法，但是它却和Comparator需要实现的方法返回值和参数定义一模一样，所以：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, Integer::compare); //直接指定一手，效果和上面是一模一样 System.out.println(Arrays.toString(array)); } \"]},\"450\":{\"h\":\"非静态方法作为方法引用\"},\"451\":{\"h\":\"默认使用\",\"t\":[\"如果使用非静态方法，依然采用 类::方法 的情况\",\"Lambda 会识别，然后使用相应接口的抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数来尝试调用\",\"我们注意到Comparator要求我们实现的方法为：\",\"public int compare(Integer o1, Integer o2) { return o1 - o2; } \",\"其中o1和o2都是Integer类型的，我们发现Integer类中有一个compareTo方法：\",\"public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } \",\"只不过这个方法并不是静态的，而是对象所有：\",\"Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); //这样进行比较也行，和上面效果依然是一样的 } }); System.out.println(Arrays.toString(array)); \",\"实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，o1作为目标对象，o2作为参数，正好匹配了compareTo方法，所以，直接缩写：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, Integer::compareTo); //注意这里调用的不是静态方法 System.out.println(Arrays.toString(array)); } \"]},\"452\":{\"h\":\"\",\"t\":[\"成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法\",\"通过具体对象，即 对象::方法，这样就仿造了静态方法时的情况，此时就不会使用默认的情况(即用参数1调用方法，该方法参数为参数2)\",\"而是类似 静态方法作为方法引用时，两个参数对应。\",\"public static void main(String[] args) { Main mainObject = new Main(); Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, mainObject::reserve); //使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法 System.out.println(Arrays.toString(array)); } public int reserve(Integer a, Integer b){ //现在Main类中有一个刚好匹配的方法 return b.compareTo(a); } \"]},\"453\":{\"h\":\"构造方法作为方法引用\",\"t\":[\"当然，类的构造方法 类::new 同样可以作为方法引用传递：\",\"类的构造方法默认返回自身对象\",\"public interface Test { String test(String str); //现在我们需要一个参数为String返回值为String的实现 } \",\"我们发现，String类中刚好有一个：\",\"public String(String original) { //由于String类的构造方法返回的肯定是一个String类型的对象， //且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的 this.value = original.value; this.coder = original.coder; this.hash = original.hash; } \",\"于是：\",\"public static void main(String[] args) { Test test = String::new; //没错，构造方法直接使用new关键字就行 } \",\"当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。\",\"Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。\"]},\"454\":{\"h\":\"Optional类\",\"t\":[\"Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。\",\"我们先来看看下面这个例子：\",\"public static void hello(String str){ //现在我们要实现一个方法，将传入的字符串转换为小写并打印 System.out.println(str.toLowerCase()); //那太简单了吧，直接转换打印一气呵成 } \",\"但是这样实现的话，我们少考虑了一个问题，万一给进来的str是null呢？\",\"如果是null的话，在调用toLowerCase方法时岂不是直接空指针异常了？\",\"所以我们还得判空一下：\",\"public static void hello(String str){ if(str != null) { System.out.println(str.toLowerCase()); } } \",\"但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决\",\"这时，Optional来了，我们可以将任何的变量包装进Optional类中使用：\",\"public static void hello(String str){ Optional .ofNullable(str) //将str包装进Optional .ifPresent(s -> { //ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void） System.out.println(s); }); } \",\"由于这里只有一句打印，所以我们来优化一下：\",\"public static void hello(String str){ Optional .ofNullable(str) //将str包装进Optional .ifPresent(System.out::println); //println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法 } \",\"这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。\",\"除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：\",\"System.out.println(Optional.ofNullable(str).get()); \",\"不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：\",\"System.out.println(Optional.ofNullable(str).orElse(\\\"VVV\\\")); //orElse表示如果为空就返回里面的内容 \"]},\"455\":{\"c\":[\"code\"]},\"456\":{\"c\":[\"java新特性\"]},\"457\":{\"h\":\"Java9 - 模块机制\"},\"458\":{\"h\":\"Java9\",\"t\":[\"Java 9的主要特性有，全新的模块机制、接口的private方法等。\"]},\"459\":{\"h\":\"模块机制\"},\"460\":{\"h\":\"简介\",\"t\":[\"当我们导入一个jar包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库\",\"实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。\",\"于是，Java 9引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：\",\"alt text\",\"而在引入模块机制之后：\",\"alt text\",\"可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。\"]},\"461\":{\"h\":\"实现包的分离管理\",\"t\":[\"这里我们创建一个新的项目，并在src目录下，新建module-info.java文件表示此项目采用模块管理机制：\",\"module NewHelloWorld { //模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同 } \",\"接着我们来创建一个主类：\",\"package com.ekko; public class Main { public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); } } \",\"程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了\",\"Java为我们提供的logging相关日志库，即 java.util.loggin\",\"我们发现现在不见了，实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：\",\"module NewHelloWorld { //模块名称随便起一个就可以 requires java.logging; //除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库 //当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se; 即可 } \",\"这里我们导入java.logging相关模块后，就可以正常使用Logger了\",\"否则，如果未在 module-info.java 中导入，会提示找不到\",\"alt text\",\"模块化机制提供了另一个级别的Java代码可见性、可访问性的控制。\"]},\"462\":{\"h\":\"提高安全性\",\"t\":[\"尝试通过反射获取JDK提供的类中的字段：\",\"//Java17版本的String类 public final class String implements java.io.Serializable, Comparable<String>, CharSequence, Constable, ConstantDesc { @Stable private final byte[] value; //自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[] .... } \",\"public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class<String> stringClass = String.class; Field field = stringClass.getDeclaredField(\\\"value\\\"); //这里我们通过反射来获取String类中的value字段 field.setAccessible(true); //由于是private访问权限，所以我们修改一下 System.out.println(field.get(\\\"ABCD\\\")); } \",\"但是我们发现，在程序运行之后，修改操作被阻止了：\",\"alt text\",\"反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的。\"]},\"463\":{\"h\":\"介绍\",\"t\":[\"首先模块具有四种类型：\",\"系统模块： 来自JDK和JRE的模块（官方提供的模块，比如我们上面用的） 我们也可以直接使用java --list-modules命令来列出所有的模块，不同的模块会导出不同的包供我们使用。\",\"应用程序模块： 我们自己写的Java模块项目。\",\"自动模块： 可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。\",\"未命名模块： 我们自己创建的一个Java项目，如果没有创建module-info.java，那么会按照未命名模块进行处理 未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。 不过，由于没有使用Java 9的模块新特性，未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）\"]},\"464\":{\"h\":\"例子\",\"t\":[\"这里我们就来创建两个项目，看看如何使用模块机制\",\"首先我们在项目A中，添加一个User类，然后在项目B使用：\",\"package com.test; public class User { String name; int age; public User(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return name+\\\" (\\\"+age+\\\"岁)\\\"; } } \",\"接着我们编写一下项目A的模块设置：\",\"module module.a { exports com.test; } \",\"这里我们将com.test包下所有内容都暴露出去，默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用。\",\"接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：\",\"module module.b { requires module.a; } \",\"现在我们就可以在Main类中使用模块module.a中暴露出来的包内容了：\",\"import com.test.User; //如果模块module.a不暴露，那么将无法导入 public class Main { public static void main(String[] args) { User user = new User(\\\"penguin\\\", 18); System.out.println(user); } } \",\"当然除了普通的exports进行包的暴露之外，我们也可以直接指定将包暴露给指定的模块：\",\"module module.a { exports com.test to module.b; //这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用 } \"]},\"465\":{\"h\":\"依赖传递\",\"t\":[\"如果模块module.a依赖于其他模块，那么会不会传递给依赖于模块module.a的模块呢？\",\"默认是不传递的\",\"module module.a { exports com.test to module.b; //使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入 requires java.logging; //这里添加一个模块的依赖 } \",\"alt text\",\"可以看到，在模块module.b中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用\",\"但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：\",\"module module.a { exports com.test to module.b; //使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入 requires transitive java.logging; //使用transitive来向其他模块传递此依赖 } \",\"现在就可以使用了：\",\"alt text\"]},\"466\":{\"h\":\"开启反射\",\"t\":[\"还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的\",\"那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：\",\"open module module.a { //直接添加open关键字开放整个模块的反射权限 exports com.test to module.b; } \",\"module module.a { exports com.test to module.b; opens com.test; //通过使用opens关键字来为其他模块开放反射权限 //也可以指定目标开放反射 opens com.test to module.b; } \"]},\"467\":{\"h\":\"指定实现 +\",\"t\":[\"我们还可以指定模块需要使用的抽象类或是接口实现：\",\"package com.test; public interface Test { } \",\"open module module.a { exports com.test to module.b; uses com.test.Test; //使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到 } \",\"我们可以在模块B中去实现一下，然后声明我们提供了实现类：\",\"package com.main; import com.test.Test; public class TestImpl implements Test { } \",\"module module.b { requires module.a; //导入项目A的模块，此模块暴露了com.test包 provides com.test.Test with com.main.TestImpl; //声明此模块提供了Test的实现类 } \"]},\"468\":{\"h\":\"简单使用\",\"t\":[\"了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目\",\"然后我们导入了lombok框架的依赖，如果我们不创建module-info.java文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：\",\"package com.test; import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\\\"Hello World!\\\"); //使用lombok提供的注解，可以正常运行 } } \",\"现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好module-info.java文件：\",\"module com.test { } \",\"我们还需要去依赖对应的模块：\",\"module com.test { requires lombok; //lombok模块 requires java.logging; //JUL日志模块，也需要使用到 } \",\"这样我们就可以正常使用了。\"]},\"469\":{\"c\":[\"code\"]},\"470\":{\"c\":[\"java新特性\"]},\"471\":{\"h\":\"Java9 - 2\"},\"472\":{\"h\":\"Java9\"},\"473\":{\"h\":\"JShell交互式编程\",\"t\":[\"Java 9为我们通过了一种交互式编程工具JShell\",\"alt text\",\"环境配置完成后，我们只需要输入jshell命令即可开启交互式编程了，它支持我们一条一条命令进行操作。\",\"比如我们来做一个简单的计算：\",\"alt text\",\"我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。\",\"alt text\",\"我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：\",\"alt text\",\"除了直接运行我们写进去的代码之外，它还支持使用命令，输入help来查看命令列表：\",\"alt text\",\"比如我们可以使用/vars命令来展示当前定义的变量列表：\",\"alt text\",\"当我们不想使用jshell时，直接输入/exit退出即可\"]},\"474\":{\"h\":\"接口中的private方法\",\"t\":[\"接口中的方法默认是 public abstract\",\"在Java 8中，接口中 的方法支持添加default关键字来添加默认实现：\",\"public interface Test { default void test(){ System.out.println(\\\"我是test方法默认实现\\\"); } } \",\"而在Java 9中，接口再次得到强化，现在接口中可以存在私有方法了：\",\"public interface Test { default void test(){ System.out.println(\\\"我是test方法默认实现\\\"); this.inner(); //接口中方法的默认实现可以直接调用接口中的私有方法 } private void inner(){ //声明一个私有方法 System.out.println(\\\"我是接口中的私有方法！\\\"); } } \",\"注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。\"]},\"475\":{\"h\":\"集合类新增工厂方法\",\"t\":[\"在之前，如果我们想要快速创建一个Map只能：\",\"public static void main(String[] args) { Map<String, Integer> map = new HashMap<>(); //要快速使用Map，需要先创建一个Map对象，然后再添加数据 map.put(\\\"AAA\\\", 19); map.put(\\\"BBB\\\", 23); System.out.println(map); } \",\"而在Java 9之后，我们可以直接通过of方法来快速创建了：\",\"public static void main(String[] args) { Map<String, Integer> map = Map.of(\\\"AAA\\\", 18, \\\"BBB\\\", 20); //直接一句搞定 System.out.println(map); } \",\"是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：\",\"alt text\",\"但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是无法进行修改的。\",\"当然，除了Map之外，其他的集合类都有相应的of方法：\",\"public static void main(String[] args) { Set<String> set = Set.of(\\\"BBB\\\", \\\"CCC\\\", \\\"AAA\\\"); //注意Set中元素顺序并不一定你的添加顺序 List<String> list = List.of(\\\"AAA\\\", \\\"CCC\\\", \\\"BBB\\\"); //好耶，再也不用Arrays了 } \"]},\"476\":{\"h\":\"改进的 Stream API\",\"t\":[\"这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。\",\"public static void main(String[] args) { Stream .of(\\\"A\\\", \\\"B\\\", \\\"B\\\", \\\"C\\\") //这里我们可以直接将一些元素封装到Stream中 .filter(s -> s.equals(\\\"B\\\")) //通过过滤器过滤 .distinct() //去重 .forEach(System.out::println); //最后打印 } \",\"自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成\",\"如此方便的框架，在Java 9得到了进一步的增强：\"]},\"477\":{\"h\":\"\",\"t\":[\"public static void main(String[] args) { Stream .of(null) //如果传入null会报错 .forEach(System.out::println); Stream .ofNullable(null) //使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了 .forEach(System.out::println); } \"]},\"478\":{\"h\":\"利用 来迭代生成数据\",\"t\":[\"还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：\",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) //Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。 .limit(20) //这里限制生成20个 .forEach(System.out::println); } \",\"public static void main(String[] args) { Stream //不知道怎么写？参考一下：for (int i = 0;i < 20;i++) .iterate(0, i -> i < 20, i -> i + 1) //快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成 .forEach(System.out::println); } \"]},\"479\":{\"h\":\"数据截断 +\",\"t\":[\"Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：\",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) .limit(20) .takeWhile(i -> i < 10) //当i小于10时正常通过，一旦大于等于10直接截断 .forEach(System.out::println); } \",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) .limit(20) .dropWhile(i -> i < 10) //和上面相反，上来就是截断状态，只有当满足条件时再开始通过 .forEach(System.out::println); } \",\"但实际上还是遍历了20个，只不过会删除其他不符合条件的\"]},\"480\":{\"h\":\"其他小型变动\",\"t\":[\"Try-with-resource语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：\",\"public static void main(String[] args) throws IOException { InputStream inputStream = Files.newInputStream(Paths.get(\\\"pom.xml\\\")); try (inputStream) { //单独丢进try中，效果是一样的 for (int i = 0; i < 100; i++) System.out.print((char) inputStream.read()); } } \",\"在Java 8中引入了Optional类，它很好的解决了判空问题：\",\"public static void main(String[] args) throws IOException { test(null); } public static void test(String s){ //比如现在我们想执行 System.out.println(str.toLowerCase()) //但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常 //但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装 Optional .ofNullable(s) .ifPresent(str -> System.out.println(str.toLowerCase())); } \",\"这种写法就有点像Kotlin或是JS中的语法：\",\"fun main() { test(null) } fun test(str : String?){ //传入的String对象可能为null，这里类型写为String? println(str?.lowercase()) // ?.表示只有不为空才进行调用 } \",\"在Java 9新增了一些更加方便的操作：\",\"public static void main(String[] args) { String str = null; Optional.ofNullable(str).ifPresentOrElse(s -> { //通过使用ifPresentOrElse，我们同时处理两种情况 System.out.println(\\\"被包装的元素为：\\\"+s); //第一种情况和ifPresent是一样的 }, () -> { System.out.println(\\\"被包装的元素为null\\\"); //第二种情况是如果为null的情况 }); } \",\"我们也可以使用or()方法快速替换为另一个Optional类：\",\"public static void main(String[] args) { String str = null; Optional.ofNullable(str) .or(() -> Optional.of(\\\"AAA\\\")) //如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装 .ifPresent(System.out::println); } \",\"当然还支持直接转换为Stream，这里就不多说了。\",\"在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：\",\"public abstract class Test<T>{ //这里我们写一个泛型类 public T t; public Test(T t) { this.t = t; } public abstract T test(); } \",\"public static void main(String[] args) throws IOException { Test<String> test = new Test<>(\\\"AAA\\\") { //在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢 //在Java 9之后，这样的写法终于可以编译通过了 @Override public String test() { return t; } }; } \",\"当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。\"]},\"481\":{\"c\":[\"code\"]},\"482\":{\"c\":[\"java新特性\"]},\"483\":{\"h\":\"Java10-11 - 1\"},\"484\":{\"h\":\"Java10\",\"t\":[\"Java 10主要带来的是一些内部更新，相比Java 9带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了\"]},\"485\":{\"h\":\"局部变量类型推断\",\"t\":[\"在Java中，我们可以使用自动类型推断：\",\"public static void main(String[] args) { // String a = \\\"Hello World!\\\"; 之前我们定义变量必须指定类型 var a = \\\"Hello World!\\\"; //现在我们使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型 } \",\"但是注意，var关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。\",\"alt text\",\"我们来看看是不是类型也能正常获取：\",\"public static void main(String[] args) { var a = \\\"Hello World!\\\"; System.out.println(a.getClass()); } \",\"这里虽然是有了var关键字进行自动类型推断，但是最终还是会变成String类型，得到的Class也是String类型。\",\"但是Java终究不像JS那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：\",\"alt text\",\"并且var关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：\",\"alt text\",\"有关Java 10新增的一些其他改进，这里就不提了。\"]},\"486\":{\"h\":\"Java11\",\"t\":[\"Java 11 是继Java 8之后的又一个TLS长期维护版本，在Java 17出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于Lambda的形参局部变量语法。\"]},\"487\":{\"h\":\"用于Lambda的形参局部变量语法\",\"t\":[\"在Java 10我们认识了var关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在lambda中使用\",\"但是实际上这里是完全可以进行类型推断的，所以在Java 11，终于是支持了，这样编写就不会报错了：\",\"public static void main(String[] args){ Consumer<String> consumer = (var str) -> {}; } \"]},\"488\":{\"h\":\"针对于String类的方法增强\",\"t\":[\"在Java 11为String新增一些更加方便的操作：\",\"str.isBlank(): 判断字符串是否为空或者仅包含空格\",\"str.lines(): 返回的是一个 Stream<String> 类型，根据字符串中的\\\\n换行符进行切割，分为多个字符串，并转换为Stream进行操作\",\"public static void main(String[] args) { var str = \\\"AB\\\\nC\\\\nD\\\"; System.out.println(str.isBlank()); //isBlank方法用于判断是否字符串为空或者是仅包含空格 str.lines().forEach(System.out::println); //根据字符串中的\\\\n换行符进行切割，分为多个字符串，并转换为Stream进行操作 } \",\"str.repeat(): 让字符串重复拼接\",\"public static void main(String[] args) { String str = \\\"ABCD\\\"; //比如现在我们有一个ABCD，但是现在我们想要一个ABCDABCD这样的基于原本字符串的重复字符串 System.out.println(str.repeat(2)); //一个repeat就搞定了 } \",\"快速地进行空格去除操作：\",\"public static void main(String[] args) { String str = \\\" A B C D \\\"; System.out.println(str.strip()); //去除首尾空格 System.out.println(str.stripLeading()); //去除首部空格 System.out.println(str.stripTrailing()); //去除尾部空格 } \"]},\"489\":{\"h\":\"全新的HttpClient使用\",\"t\":[\"在Java 9的时候其实就已经引入了全新的Http Client API，用于取代之前比较老旧的HttpURLConnection类\",\"新的API支持最新的HTTP2和WebSocket协议。\"]},\"490\":{\"h\":\"类使用\",\"t\":[\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { //直接创建一个新的HttpClient HttpClient client = HttpClient.newHttpClient(); //现在我们只需要构造一个Http请求实体 // 就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似） HttpRequest request = HttpRequest.newBuilder().uri(new URI(\\\"https://www.baidu.com\\\")).build(); //现在我们就可以把请求发送出去了 // 注意send方法后面参数，还需要一个响应体处理器（内置了很多） // 这里我们选择ofString直接响应实体转换为String字符串 HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } \",\"利用全新的客户端，我们甚至可以轻松地做一个爬虫\",\"比如现在我们想去批量下载某个网站的壁纸：\",\"网站地址：https://pic.netbian.com/4kmeinv/\",\"不同的壁纸似乎都是这样：https://pic.netbian.com/tupian/数字.html\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { //先不要一次性获取太多，先来10个 HttpRequest request = HttpRequest.newBuilder().uri(new URI(\\\"https://pic.netbian.com/tupian/\\\"+(29327 + i)+\\\".html\\\")).build(); //这里我们按照规律，批量获取 HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); //这里打印一下看看网页 } } \",\"接着我们需要来观察一下网站的HTML具体怎么写的，把图片的地址提取出来：\",\"好了，知道图片在哪里直接字符串截取：\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { ... String html = response.body(); String prefix = \\\"<a href=\\\\\\\"\\\\\\\" id=\\\\\\\"img\\\\\\\"><img src=\\\\\\\"\\\"; //先找好我们要截取的前面一段，作为前缀去匹配位置 String suffix = \\\"\\\\\\\" data-pic=\\\"; //再找好我们要截取的屁股后面紧接着的位置，作为后缀去匹配位置 //直接定位，然后前后截取，得到最终的图片地址 html = html.substring(html.indexOf(prefix) + prefix.length()); html = html.substring(0, html.indexOf(suffix)); System.out.println(html); //最终的图片地址就有了 } } \",\"好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { ... //创建请求，把图片取到 HttpRequest imageRequest = HttpRequest.newBuilder().uri(new URI(\\\"https://pic.netbian.com\\\"+html)).build(); //这里以输入流的方式获取，不过貌似可以直接下载文件 HttpResponse<InputStream> imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream()); //拿到输入流和文件输出流 InputStream imageInput = imageResponse.body(); FileOutputStream stream = new FileOutputStream(\\\"images/\\\"+i+\\\".jpg\\\"); //一会要保存的格式 try (stream;imageInput){ //直接把要close的变量放进来就行，简洁一些了 int size; //下面具体保存过程的不用我多说了吧 byte[] data = new byte[1024]; while ((size = imageInput.read(data)) > 0) { stream.write(data, 0, size); } } } } \"]},\"491\":{\"c\":[\"code\"]},\"492\":{\"c\":[\"java新特性\"]},\"493\":{\"h\":\"Java 12-16 - 1\"},\"494\":{\"h\":\"Java 12-16 新特性\",\"t\":[\"由于Java版本的更新迭代速度自Java 9开始为半年更新一次\",\"Java 8到Java 9隔了整整三年，所以各个版本之间的更新内容比较少了。\",\"alt text\",\"Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能\",\"12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用。\"]},\"495\":{\"h\":\"新的switch语法\",\"t\":[\"在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活\",\"比如我们想要编写一个根据成绩得到等级的方法：\",\"/** * 传入分数（范围 0 - 100）返回对应的等级： * 100-90：优秀 * 70-80：良好 * 60-70：及格 * 0-60：寄 * @param score 分数 * @return 等级 */ public static String grade(int score){ } \",\"现在我们想要使用switch来实现这个功能，之前的写法是：\",\"public static String grade(int score){ score /= 10; //既然分数段都是整数，那就直接整除10 String res = null; switch (score) { case 10: case 9: res = \\\"优秀\\\"; break; case 8: case 7: res = \\\"良好\\\"; break; case 6: res = \\\"及格\\\"; break; default: res = \\\"不及格\\\"; break; } return res; } \"]},\"496\":{\"h\":\"新语法\",\"t\":[\"但是现在我们可以使用新的特性了：\",\"public static String grade(int score){ score /= 10; //既然分数段都是整数，那就直接整除10 return switch (score) { //增强版switch语法 case 10, 9 -> \\\"优秀\\\"; //语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了 case 8, 7 -> \\\"良好\\\"; case 6 -> \\\"及格\\\"; default -> \\\"不及格\\\"; }; } \",\"不过最后编译出来的样子，貌似还是和之前是一样的\"]},\"497\":{\"h\":\"详细规则\",\"t\":[\"这种全新的switch语法称为switch表达式，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：\",\"var res = switch (obj) { //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收 case [匹配值, ...] -> \\\"优秀\\\"; // case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开 // 使用 -> 来返回如果匹配此case语句的结果 case ... //根据不同的分支，可以存在多个case default -> \\\"不及格\\\"; //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的 }; \",\"那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？\",\"var res = switch (obj) { //增强版switch语法 case [匹配值, ...] -> \\\"优秀\\\"; default -> { //我们可以使用花括号来将整套逻辑括起来 //... 我是其他要做的事情 yield \\\"不及格\\\"; //注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字 } }; \",\"当然，也可以像这样：\",\"var res = switch (args.length) { //增强版switch语法 case [匹配值, ...]: yield \\\"AAA\\\"; //传统的:写法，通过yield指定返回结果，同样不需要break default: System.out.println(\\\"默认情况\\\"); yield \\\"BBB\\\"; }; \",\"这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。\",\"注意： switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。\"]},\"498\":{\"h\":\"文本块 - 三引号\",\"t\":[\"如果你学习过Python，一定知道三引号：\",\"#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串 multi_line = \\\"\\\"\\\" nice to meet you! nice to meet you! nice to meet you! \\\"\\\"\\\" print multi_line \",\"没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：\",\"alt text\",\"可以看到，Java中也可以使用这样的三引号来表示字符串\",\"我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：\",\"alt text\",\"注意： 文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。\"]},\"499\":{\"h\":\"新的instanceof语法\",\"t\":[\"在Java 14，instanceof迎来了一波小更新\",\"比如我们之前要重写一个类的equals方法：\",\"public class Student { private final String name; public Student(String name) { this.name = name; } @Override public boolean equals(Object obj) { if(obj instanceof Student) { //首先判断是否为Student类型 Student student = (Student) obj; //如果是，那么就类型转换 return student.name.equals(this.name); //最后比对属性是否一样 } return false; } } \",\"在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式\",\"但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量, 只需要在比较后面加个变量名，等于比较完就强制转换\",\"public class Student { private final String name; public Student(String name) { this.name = name; } @Override public boolean equals(Object obj) { if(obj instanceof Student student) { //在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的 return student.name.equals(this.name); } return false; } } \",\"在使用instanceof判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤。\",\"注意： 新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。\"]},\"500\":{\"h\":\"空指针异常的改进\",\"t\":[\"相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：\",\"public static void test(String a, String b){ int length = a.length() + b.length(); //可能给进来的a或是b为null System.out.println(length); } \",\"那么为空时，就会直接：\",\"alt text\",\"但是由于我们这里a和b都调用了length()方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）\",\"但是当我们在Java 14或更高版本运行时：\",\"alt text\",\"这里会明确指出是哪一个变量调用出现了空指针。\"]},\"501\":{\"h\":\"记录类型\",\"t\":[\"继类、接口、枚举、注解之后的又一新类型，\\\"记录 record\\\"\",\"在Java 14中首次出场，这一出场，Lombok的噩梦来了。\",\"在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据\",\"比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：\",\"@Data public class Account { //使用Lombok，一个注解就搞定了 String username; String password; } \",\"Lombok可以说是简化代码的神器了，他能在编译时自动生成getter和setter、构造方法、toString()方法等实现\",\"而记录类型本质上也是一个普通的类\",\"是final类型且继承自java.lang.Record抽象类\",\"它会在编译时，会自动编译出 public gethashcode 、equals、toString 等方法。\",\"public record Account(String username, String password) { //直接把字段写在括号中 } \",\"使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：\",\"alt text\",\"并且toString也是被重写了的：\",\"alt text\",\"equals()方法仅做成员字段之间的值比较，也是帮助我们实现好了的：\",\"Account account0 = new Account(\\\"Admin\\\", \\\"123456\\\"); Account account1 = new Account(\\\"Admin\\\", \\\"123456\\\"); //两个属性都是一模一样的 System.out.println(account0.equals(account1)); //得到true \",\"是不是感觉这种类型就是专门为这种实体类而生的。\",\"public record Account(String username, String password) implements Runnable { //支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了 @Override public void run() { } } \",\"注意： 记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。\"]},\"502\":{\"h\":\"Java 17 新特性\",\"t\":[\"Java 17作为新的LTS长期维护版本\"]},\"503\":{\"h\":\"密封类型 +\",\"t\":[\"密封类型可以说是Java 17正式推出的又一重磅类型\",\"它在Java 15首次提出并测试了两个版本。\",\"在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。\",\"但有的时候，可能并不是所有的类我们都希望能够被继承。\",\"所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是限制类的继承。\",\"实际上在之前我们如果不希望别人继承我们的类，可以直接添加final关键字：\",\"public final class A{ //添加final关键字后，不允许对此类继承 } \",\"这样有一个缺点，如果添加了final关键字，那么无论是谁，包括我们自己也是没办法实现继承的\",\"但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。\",\"但是现在我们可以使用密封类型sealed 来实现这个功能：\",\"public sealed class A permits B{ //在class关键字前添加sealed关键字，表示此类为密封类型 // permits后面跟上允许继承的类型，多个子类使用逗号隔开 } \"]},\"504\":{\"h\":\"要求\",\"t\":[\"密封类型有以下要求：\",\"可以基于普通类、抽象类、接口，也可以是继承自其他抽象类的子类或是实现其他接口的类等。\",\"必须有子类继承，且不能是匿名内部类或是lambda的形式。\",\"sealed写在原来final的位置，但是不能和final、non-sealed关键字同时出现，只能选择其一。\",\"继承的子类必须显式标记为final、sealed或是non-sealed类型。\",\"标准的声明格式如下：\",\"public sealed [abstract] [class/interface] 类名 [extends 父类] [implements 接口, ...] permits [子类, ...]{ //里面的该咋写咋写 } \",\"注意子类格式为：\",\"public [final/sealed/non-sealed] class 子类 extends 父类 { //必须继承自父类 //final类型：任何类不能再继承当前类，到此为止，已经封死了。 //sealed类型：同父类，需要指定由哪些类继承。 //non-sealed类型：重新开放为普通类，任何类都可以继承。 } \",\"比如现在我们写了这些类：\",\"public sealed class A permits B{ //指定B继承A } \",\"public final class B extends A { //在子类final，彻底封死 } \",\"我们可以看到其他的类无论是继承A还是继承B都无法通过编译：\",\"alt text\",\"alt text\",\"但是如果此时我们主动将B设定为non-sealed类型：\",\"public non-sealed class B extends A { } \",\"这样就可以正常继承了，因为B指定了non-sealed主动放弃了密封特性，这样就显得非常灵活了。\",\"当然我们也可以通过反射来获取类是否为密封类型：\",\"public static void main(String[] args) { Class<A> a = A.class; System.out.println(a.isSealed()); //是否为密封 } \"]},\"505\":{\"c\":[\"code\"]},\"506\":{\"c\":[\"java新特性\"]},\"507\":{\"h\":\"Java 杂\"},\"508\":{\"h\":\"\",\"t\":[\"Consumer是Java 8中的一个函数式接口，它位于java.util.function包中。\",\"定义了一个名为accept的抽象方法，该方法接受一个参数并且不返回任何结果。\",\"换句话说，Consumer接口表示一个消费者，它可以对给定的对象执行某些操作，但不产生任何结果。\"]},\"509\":{\"h\":\"接口声明\",\"t\":[\"public interface Consumer<T> { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed {@code Consumer} that performs, in sequence, this * operation followed by the {@code after} operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the {@code after} operation will not be performed. * * @param after the operation to perform after this operation * @return a composed {@code Consumer} that performs in sequence this * operation followed by the {@code after} operation * @throws NullPointerException if {@code after} is null */ default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"主要就两个方法：\"]},\"510\":{\"h\":\"\",\"t\":[\"核心方法是accept，该方法接受一个参数，并在方法体内定义具体的操作\",\"这是抽象方法，也是我们需要给的\",\"具体示例：\",\"// Lambda表达式简化 Consumer<String> printer = (s) -> System.out.println(s); // 使用 accept 方法执行操作 printer.accept(\\\"Hello, World!\\\"); \"]},\"511\":{\"h\":\"\",\"t\":[\"第二个是 addThen，为了方便 Consumer 链式操作\",\"Consumer接口还支持链式操作，也就是将多个Consumer组合在一起，形成一个新的Consumer。\",\"这可以通过andThen方法来实现，该方法允许将两个Consumer连接在一起，顺序执行。\",\"Consumer<String> upperCasePrinter = (s) -> System.out.println(s.toUpperCase()); Consumer<String> lowerCasePrinter = (s) -> System.out.println(s.toLowerCase()); // 使用 andThen 方法连接两个 Consumer Consumer<String> combinedPrinter = upperCasePrinter.andThen(lowerCasePrinter); combinedPrinter.accept(\\\"Hello, World!\\\"); \",\"传递的参数都是一样的不会被上一个影响，都是Hello, World!\"]},\"512\":{\"h\":\"\",\"t\":[\"Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\",\"Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。\",\"Optional 类的引入很好的解决空指针异常。\",\"import java.util.Optional; public class Java8Tester { public static void main(String args[]){ Java8Tester java8Tester = new Java8Tester(); Integer value1 = null; Integer value2 = new Integer(10); // Optional.ofNullable - 允许传递为 null 参数 Optional<Integer> a = Optional.ofNullable(value1); // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException Optional<Integer> b = Optional.of(value2); System.out.println(java8Tester.sum(a,b)); } public Integer sum(Optional<Integer> a, Optional<Integer> b){ // Optional.isPresent - 判断值是否存在 System.out.println(\\\"第一个参数值存在: \\\" + a.isPresent()); System.out.println(\\\"第二个参数值存在: \\\" + b.isPresent()); // Optional.orElse - 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); //Optional.get - 获取值，值需要存在 Integer value2 = b.get(); return value1 + value2; } } \"]},\"513\":{\"h\":\"\",\"t\":[\"Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。\",\"使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。\"]},\"514\":{\"h\":\"特点\",\"t\":[\"不是数据结构，不会保存数据。\",\"不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）\",\"惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。\"]},\"515\":{\"h\":\"操作\",\"t\":[\"Stream可以由数组或集合创建，对流的操作分为两种：\",\"中间操作，每次返回一个新的流，可以有多个 （筛选filter、映射map、排序sorted、去重组合skip—limit）\",\"终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。 终端操作会产生一个新的集合或值。（遍历foreach、匹配find–match、规约reduce、聚合max–min–count、收集collect）\",\"alt text\",\"List<String> list = new ArrayList<>(); list.add(\\\"武汉加油\\\"); list.add(\\\"中国加油\\\"); list.add(\\\"世界加油\\\"); list.add(\\\"世界加油\\\"); long count = list.stream().distinct().count(); System.out.println(count); \",\"中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。\"]},\"516\":{\"h\":\"创建流\",\"t\":[\"如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of()创建流\",\"如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。\",\"查看 Stream 源码的话，你会发现 of() 方法内部其实调用了Arrays.stream() 方法。\",\"public static<T> Stream<T> of(T... values) { return Arrays.stream(values); } \",\"另外，集合还可以调用 parallelStream() 方法创建并发流，默认使用的是 ForkJoinPool.commonPool()线程池。\"]},\"517\":{\"h\":\"操作流\"},\"518\":{\"h\":\"过滤\",\"t\":[\"public class FilterStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); Stream<String> stream = list.stream().filter(element -> element.contains(\\\"王\\\")); stream.forEach(System.out::println); } } \"]},\"519\":{\"h\":\"映射\",\"t\":[\"把一个流中的元素转化成新的流中的元素\",\"map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法\",\"也就是把 Stream<String> 的流转成一个 Stream<Integer> 的流\",\"新的流中的内容被修改为对应字符串的长度\",\"public class MapStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); Stream<Integer> stream = list.stream().map(String::length); stream.forEach(System.out::println); } } \"]},\"520\":{\"h\":\"匹配\",\"t\":[\"Stream 类提供了三个方法可供进行元素匹配，它们分别是：\",\"anyMatch()，只要有一个元素匹配传入的条件，就返回 true。\",\"allMatch()，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。\",\"noneMatch()，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。\"]},\"521\":{\"h\":\"组合\",\"t\":[\"reduce() 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：\",\"Optional<T> reduce(BinaryOperator<T> accumulator) 没有起始值，只有一个参数，就是运算规则，此时返回 Optional。\",\"T reduce(T identity, BinaryOperator<T> accumulator) 有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。\",\"public class ReduceStreamDemo { public static void main(String[] args) { Integer[] ints = {0, 1, 2, 3}; List<Integer> list = Arrays.asList(ints); Optional<Integer> optional = list.stream().reduce((a, b) -> a + b); Optional<Integer> optional1 = list.stream().reduce(Integer::sum); System.out.println(optional.orElse(0)); System.out.println(optional1.orElse(0)); int reduce = list.stream().reduce(6, (a, b) -> a + b); System.out.println(reduce); int reduce1 = list.stream().reduce(6, Integer::sum); System.out.println(reduce1); } } \"]},\"522\":{\"h\":\"转换流\",\"t\":[\"public class CollectStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); String[] strArray = list.stream().toArray(String[]::new); System.out.println(Arrays.toString(strArray)); List<Integer> list1 = list.stream().map(String::length).collect(Collectors.toList()); List<String> list2 = list.stream().collect(Collectors.toCollection(ArrayList::new)); System.out.println(list1); System.out.println(list2); String str = list.stream().collect(Collectors.joining(\\\", \\\")).toString(); System.out.println(str); } } \",\"toArray() 方法可以将流转换成数组\",\"来看一下 toArray() 方法的源码。\",\"<A> A[] toArray(IntFunction<A[]> generator); \",\"也就是说 String[]::new 是一个 IntFunction，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：\",\"String[] strArray = (String[])list.stream().toArray((x$0) -> { return new String[x$0]; }); System.out.println(Arrays.toString(strArray)); \",\"也就是相当于返回了一个指定长度的字符串数组。\",\"当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 map() 方法和 collect() 方法。\",\"List<Integer> list1 = list.stream().map(String::length).collect(Collectors.toList()); \",\"通过 stream() 方法创建集合的流后，再通过 map(String:length) 将其映射为字符串长度的一个新流，最后通过 collect()方法将其转换成新的集合。\",\"Collectors 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。\"]},\"523\":{\"h\":\"\",\"t\":[\"一般构建对象时会有两种方法：\",\"通过构造函数来构建\",\"一个默认的构造函数，然后用 setter 方法设置\",\"比如一个api结果返回值的类Result，其在代码中频繁被使用：\",\"public class Result<T> { private int code; private String message; private T data; public Result(int code, String message, T data) { this.code = code; this.message = message; this.data = data; } public Result() { } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public T getData() { return data; } public void setData(T data) { this.data = data; } @Override public String toString() { return \\\"Result{\\\" + \\\"code=\\\" + code + \\\", message='\\\" + message + '\\\\'' + \\\", data=\\\" + data + '}'; } } \",\"如果要使用它，一般的方法是：\",\"public class Main { public static void main(String[] args) { //方法1，使用全量的构造函数 Result<String> result1 = new Result<>(200, \\\"success\\\", \\\"\\\"); //方法2，使用空的构造函数加setter函数赋值 Result<String> result2 = new Result<>(); result2.setCode(200); result2.setMessage(\\\"success\\\"); result2.setData(\\\"\\\"); } } \",\"这两种使用方法的弊端有：\",\"方法一：当只需要部分参数的时候需要再定义个构造函数（比如失败的情况只需要code和message，结果肯定是空，因此不需要data），且一旦参数较多，则构造函数冗长；\",\"方法二：setter冗长；\"]},\"524\":{\"h\":\"建造者模式\",\"t\":[\"其实是一种设计模式，叫做建造者模式，它的含义是将一个复杂的对象的构建与它的表示分离，同样的构建过程可以创建不同的表示\",\"可以在 Result 内加入一个 Builder 类:\",\"public static final class Builder<T> { private int code; private String message; private T data; private Builder() { } public Builder code(int val) { code = val; return this; } public Builder message(String val) { message = val; return this; } public Builder data(T val) { data = val; return this; } public Result build() { return new Result(this); } } \",\"然后使用的时候：\",\"Result<String> result3 = new Result.Builder<>().code(404).message(\\\"failure\\\").build(); Result<String> result4 = Result.newBuilder().code(404).message(\\\"failure\\\").build(); \",\"所以只需要构造一个 builder，通过 Result.builder() 然后根据属性调用对应的方法进行修改，最后使用 build() 就可以创造出不同的对象\"]},\"525\":{\"h\":\"中的\",\"t\":[\"lombok 用 @Builder 来辅助设计\",\"@Builder可以让你以下面显示的那样调用你的代码，来初始化你的实例对象：\",\"Person.builder() .name(\\\"Adam Savage\\\") .city(\\\"San Francisco\\\") .job(\\\"Mythbusters\\\") .job(\\\"Unchained Reaction\\\") .build(); \",\"@Builder可以放在类，构造函数或方法上。 虽然放在类上和放在构造函数上这两种模式是最常见的用例，但@Builder最容易用放在方法的用例来解释\",\"具体操作：\",\"使用@Builder注释的方法具体实现了：\",\"一个名为FooBuilder的内部静态类，并具有和实体类一致的属性（称为构建器）。\",\"在构建器中：对于目标类中的所有的属性和未初始化的final字段，都会在构建器中创建对应属性；\",\"在构建器中：创建一个无参的default构造函数。\",\"在构建器中：对于实体类中的每个参数，都会对应创建类似于setter的方法，方法名与该参数名相同。 并且返回值是构建器本身（便于链式调用）\",\"在构建器中：一个build()方法，调用此方法，就会根据设置的值进行创建实体对象。\",\"在构建器中：同时也会生成一个toString()方法。\",\"在实体类中：会创建一个builder()方法，它的目的是用来创建构建器。\",\"@Builder public class User { private String username; private String password; } // 编译后： public class User { private String username; private String password; User(String username, String password) { this.username = username; this.password = password; } public static User.UserBuilder builder() { return new User.UserBuilder(); } public static class UserBuilder { private String username; private String password; UserBuilder() {} public User.UserBuilder username(String username) { this.username = username; return this; } public User.UserBuilder password(String password) { this.password = password; return this; } public User build() { return new User(this.username, this.password); } public String toString() { return \\\"User.UserBuilder(username=\\\" + this.username + \\\", password=\\\" + this.password + \\\")\\\"; } } } \"]},\"526\":{\"c\":[\"code\"]},\"527\":{\"c\":[\"java新特性\"]},\"528\":{\"h\":\"hint - List初始化\",\"t\":[\"带初始值的初始化\",\"如果是 java 9+, 可以直接使用 list.of\",\"List<String> list = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"); \",\"List<String> list = List.of( new Student(\\\"aaa\\\",1), new Student(\\\"bbb\\\",2), new Student(\\\"ccc\\\",3), ); \",\"这种方式创建的列表 不可修改，add() 和 remove() 都会抛出 UnsupportedOperationException。\",\"但如果是 java 8，就没有这个，可以使用 Stream\",\" List<Student> list1 = Stream.of( new Student(\\\"Alice\\\", 20), new Student(\\\"Bob\\\", 21), new Student(\\\"Charlie\\\", 22) ).collect(Collectors.toList()); \",\"特性\",\"List.of(...)\",\"Stream.of(...).collect(Collectors.toList())\",\"Java 版本要求\",\"Java 9 及以上\",\"Java 8 及以上\",\"是否可变\",\"❌ 不可变（immutable）\",\"✅ 可变（mutable）\",\"是否支持增删元素\",\"❌ 抛出 UnsupportedOperationException\",\"✅ 支持 .add() / .remove() 等操作\",\"是否允许包含 null\",\"❌ 不允许，包含会抛出 NullPointerException\",\"✅ 允许包含 null\",\"是否简洁\",\"✅ 更简洁\",\"较繁琐，但功能灵活\",\"实际返回的 List 类型\",\"通常为 ImmutableCollections.ListN\",\"通常为 ArrayList\"]},\"529\":{\"c\":[\"code\"]},\"530\":{\"c\":[\"java hint\"]},\"531\":{\"h\":\"hint2\",\"t\":[\"-128 到 +127 以内的int值都是自动包装好，所以对象都是一个 \",\"Scanner 的 nextIntScanner scanner = new Scanner(System.in);scanner.nextInt() 只读整数，不读换行符（\\\\n） 换行符仍然留在输入缓冲区中，需要清理对应的换行符\",\"Java 中 finally 的行为\",\"不论 try 里是正常结束、遇到 return、遇到异常，finally 块里的内容都会被执行。\",\" try { System.out.println(prompt); return scanner.nextInt(); } catch (InputMismatchException e) { System.err.println(\\\"输入的不是数字，重新输入\\\"); } finally { scanner.nextLine(); // 关键：清除输入缓冲区的换行符 } \",\"即使这样，也会执行 finally，这样解决了缓冲区存在 \\\\n 的问题\",\"consume\"]},\"532\":{\"c\":[\"code\"]},\"533\":{\"c\":[\"java hint\"]},\"534\":{\"h\":\"hint - 注解理解\",\"t\":[\"首先，注解的使用分成两类\",\"编译期生效（Lombok：改写字节码，帮你生成方法）\",\"运行期生效（Spring：反射 + AOP，帮你注入 Bean、加事务、AoP等）\",\"个人目前感觉\",\"注解就是一个标记，在代码编译或者运行时可以通过一些手段找到对应标记的东西\",\"然后基于此，相当于打了个坐标，然后在此上面进行一些自己的处理\",\"主要就是定义注解，然后使用注解，最后写个注解处理器来捕获并处理\",\"alt text\",\"alt text\"]},\"535\":{\"h\":\"写一个运行期的注解使用\",\"t\":[\"alt text\"]},\"536\":{\"h\":\"编译期的注解使用\",\"t\":[\"alt text\"]},\"537\":{\"c\":[\"code\"]},\"538\":{\"c\":[\"java hint\"]},\"539\":{\"h\":\"Javassm - SpringMVC1\"},\"540\":{\"h\":\"MVC理论基础\",\"t\":[\"SpringMVC - 表示层框架\",\"MVC三层架构包括：\",\"alt text\",\"每一层都有着各自的职责\",\"其中最关键的当属表示层，因为它相当于就是直接与用户的浏览器打交道的一层\",\"并且所有的请求都会经过它进行解析，然后再告知业务层进行处理，任何页面的返回和数据填充也全靠表示层来完成，因此它实际上是整个三层架构中最关键的一层\",\"而在之前的实战开发中，我们编写了大量的Servlet（也就是表示层实现）来处理来自浏览器的各种请求，但是我们发现，仅仅是几个很小的功能，以及几个很基本的页面，我们都要编写将近十个Servlet\",\"如果是更加大型的网站系统，比如淘宝、B站，光是一个页面中可能就包含了几十甚至上百个功能，想想那样的话写起来得多恐怖。\",\"因此，SpringMVC正是为了解决这种问题而生的，它是一个非常优秀的表示层框架，采用MVC思想设计实现。\"]},\"541\":{\"h\":\"MVC介绍\",\"t\":[\"MVC详细解释如下：\",\"M是指业务模型（Model）：通俗的讲就是我们之前用于封装数据传递的实体类。\",\"V是指用户界面（View）：一般指的是前端页面。\",\"C则是控制器（Controller）：控制器就相当于Servlet的基本功能，处理请求，返回响应。\",\"alt text\",\"SpringMVC正是希望这三者之间进行解耦，实现各干各的，更加精细地划分对应的职责。\",\"最后再将View和Model进行渲染，得到最终的页面并返回给前端（就像之前使用Thymeleaf那样，把实体数据对象和前端页面都给到Thymeleaf，然后它会将其进行整合渲染得到最终有数据的页面\"]},\"542\":{\"h\":\"配置环境并搭建项目\",\"t\":[\"这里我们继续使用之前的Tomcat10服务器，Spring6之后要求必须使用Tomcat10或更高版本\",\"我们直接创建一个新的JakartaEE项目。\",\"创建完成后会自动生成相关文件，但是还是请注意检查运行配置中的URL和应用程序上下文名称是否一致。\"]},\"543\":{\"h\":\"传统XML配置形式\",\"t\":[\"SpringMvc项目依然支持多种配置形式，这里我们首先讲解最传统的XML配置形式。\"]},\"544\":{\"h\":\"添加依赖\",\"t\":[\"首先我们需要添加Mvc相关依赖：\",\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>6.1.13</version> </dependency> \"]},\"545\":{\"h\":\"配置\",\"t\":[\"用 DispatcherServlet 来替换 Tomcat自带的Servlet\",\"这里url-pattern需要写为/，即可完成替换：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <web-app xmlns=\\\"https://jakarta.ee/xml/ns/jakartaee\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\\\" version=\\\"5.0\\\"> <servlet> <servlet-name>mvc</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>mvc</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> </web-app> \"]},\"546\":{\"h\":\"配置Spring上下文环境\",\"t\":[\"接着需要为整个Web应用程序配置一个Spring上下文环境（也就是容器），因为SpringMVC是基于Spring开发的，它直接利用Spring提供的容器来实现各种功能\"]},\"547\":{\"h\":\"\",\"t\":[\"那么第一步依然跟之前一样，需要编写一个配置文件(在 resource/spring.xml)：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\\\"> </beans> \"]},\"548\":{\"h\":\"\",\"t\":[\"接着我们需要为DispatcherServlet配置一些初始化参数来指定刚刚创建的配置文件：\",\"<servlet> <servlet-name>mvc</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <!-- 指定我们刚刚创建在类路径下的XML配置文件 --> <param-name>contextConfigLocation</param-name> <param-value>classpath:spring.xml</param-value> </init-param> </servlet> \"]},\"549\":{\"h\":\"测试，编写\",\"t\":[\"这样我们就完成了基本的配置，现在我们可以来测试一下是否配置正确\",\"我们删除项目自带的Servlet类，创建一个Mvc中使用的Controller类：\",\"@Controller public class HelloController { @ResponseBody @RequestMapping(\\\"/\\\") public String hello(){ return \\\"HelloWorld!\\\"; } } \",\"接着我们需要将这个类注册为Bean才能正常使用，我们来编写一下Spring的配置文件，这里我们直接配置包扫描，XML下的包扫描需要这样开启：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\\\"> <!-- 需要先引入context命名空间，然后直接配置base-package属性就可以了 --> <context:component-scan base-package=\\\"com.ekko\\\"/> </beans> \",\"如果可以成功在浏览器中出现HelloWorld则说明配置成功\",\"实际上我们上面编写的Controller就是负责Servlet基本功能的，比如这里我们返回的是HelloWorld字符串，那么我们在访问这个地址的时候，的到的就是这里返回的字符串\",\"可以看到写法非常简洁，至于这是怎么做到的的，怎么使用，我们会在本章进行详细介绍。\"]},\"550\":{\"h\":\"全注解配置形式\",\"t\":[\"如果你希望完完全全丢弃配置文件，使用纯注解开发，可以直接添加一个类\",\"Tomcat会在类路径中查找实现 ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器\",\"Spring提供了这个接口的实现类 SpringServletContainerInitializer\",\"@HandlesTypes({WebApplicationInitializer.class}) public class SpringServletContainerInitializer implements ServletContainerInitializer { public void onStartup(@Nullable Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException { List<WebApplicationInitializer> initializers = Collections.emptyList(); ... } } \",\"通过@HandlesTypes(WebApplicationInitializer.class)设置，这个类反过来会查找实现 WebApplicationInitializer 的类，并将配置的任务交给他们来完成，\",\"alt text\"]},\"551\":{\"h\":\"添加依赖1\",\"t\":[\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>6.1.13</version> </dependency> \"]},\"552\":{\"h\":\"配置初始化接口\",\"t\":[\"这里的 AbstractAnnotationConfigDispatcherServletInitializer 类 不断往上找最终继承的就是 WebApplicationInitializer 的类\",\"因此直接实现接口即可：\",\"public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?>[] getRootConfigClasses() { return new Class[]{WebConfiguration.class}; //基本的Spring配置类，一般用于业务层配置 } @Override protected Class<?>[] getServletConfigClasses() { return new Class[0]; //配置DispatcherServlet的配置类、主要用于Controller等配置，这里为了教学简单，就不分这么详细了，只使用上面的基本配置类 } @Override protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; //匹配路径，与上面一致 } } \"]},\"553\":{\"h\":\"配置相应配置类\",\"t\":[\"接着我们需要再配置类中添加一些必要的注解：\",\"@Configuration @EnableWebMvc //快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置 @ComponentScan(\\\"com.example.controller\\\") public class WebConfiguration { } \",\"@EnableWebMvc 来启动 SpringMV\",\"@EnableWebMvc 的本质是导入 DelegatingWebMvcConfiguration；\",\"它会注册 Spring MVC 的 核心 Bean（HandlerMapping、HandlerAdapter、MessageConverter等）；\",\"同时允许你通过实现 WebMvcConfigurer 去扩展默认配置；\",\"在 Spring Boot 里一般不用加，否则会屏蔽自动配置；\",\"在 传统 Spring MVC 项目里必须加，否则注解模式跑不起来。\",\"alt text\"]},\"554\":{\"h\":\"编写对应\",\"t\":[\"@Controller public class MainController { @ResponseBody @RequestMapping(\\\"/\\\") public String hello(){ return \\\"HelloWorld!\\\"; } } \",\"这样我们同样可以正常访问\",\"之后为了方便，我们就统一使用全注解形式编写。\",\"alt text\"]},\"555\":{\"c\":[\"code\"]},\"556\":{\"c\":[\"javassm\",\"Spring\"]},\"557\":{\"h\":\"Javassm - SpringMVC2\"},\"558\":{\"h\":\"Controller控制器1\",\"t\":[\"alt text\",\"alt text\",\"有了SpringMVC之后，我们不必再像之前那样一个请求地址创建一个Servlet了\",\"SpringMVC 使用 DispatcherServlet 替代Tomcat为我们提供的默认的静态资源Servlet，也就是说，现在所有的请求（除了jsp，因为Tomcat还提供了一个jsp的Servlet）都会经过DispatcherServlet进行处理。\",\"那么DispatcherServlet会帮助我们做什么呢？\",\"alt text\",\"我们的请求到达Tomcat服务器之后，会交给当前的Web应用程序进行处理，而SpringMVC使用DispatcherServlet来处理所有的请求\",\"也就是说它被作为一个统一的访问点，所有的请求全部由它来进行调度。\",\"当一个请求经过DispatcherServlet之后，会先走HandlerMapping，它会将请求映射为HandlerExecutionChain, 依次经过HandlerInterceptor有点类似于之前我们所学的过滤器，不过在SpringMVC中我们使用的是拦截器，然后再交给HandlerAdapter\",\"根据请求的路径选择合适的控制器进行处理，控制器处理完成之后，会返回一个ModelAndView对象，包括数据模型和视图，通俗的讲就是页面中数据和页面本身（只包含视图名称即可）。\",\"返回ModelAndView之后，会交给ViewResolver（视图解析器）进行处理，视图解析器会对整个视图页面进行解析\",\"SpringMVC自带了一些视图解析器，但是只适用于JSP页面，我们也可以像之前一样使用Thymeleaf作为视图解析器，这样我们就可以根据给定的视图名称，直接读取HTML编写的页面，解析为一个真正的View。\",\"解析完成后，就需要将页面中的数据全部渲染到View中\",\"最后返回给DispatcherServlet一个包含所有数据的成形页面，再响应给浏览器，完成整个过程。\",\"因此，实际上整个过程\",\"我们首先需要编写对应请求路径的Controller (方便可以根据对应的请求路径找到对应的Controller来进行处理)\",\"之后要配置好我们需要的ViewResolver即可 (来解析生成最终页面)，之后还可以继续补充添加拦截器，而其他的流程已经由SpringMVC帮助我们完成了。\"]},\"559\":{\"h\":\"配置视图解析器和控制器\",\"t\":[\"首先我们需要实现最基本的页面解析并返回\",\"第一步就是配置视图解析器，这里我们使用Thymeleaf为我们提供的视图解析器，导入需要的依赖：\",\"<dependency> <groupId>org.thymeleaf</groupId> <artifactId>thymeleaf-spring6</artifactId> <version>3.1.1.RELEASE</version> </dependency> \"]},\"560\":{\"h\":\"编写配置项\",\"t\":[\"配置视图解析器非常简单，我们只需要将对应的ViewResolver注册为Bean即可\",\"因为 ThymeleafViewResolver 实现了 SpringMVC 的ViewResolver接口，所以：\",\"Spring MVC 启动时，DispatcherServlet 去容器里找所有 ViewResolver 类型的 Bean。\",\"发现 thymeleafViewResolver，加入解析链。\",\"请求返回时，如果 Controller 返回 String \\\"index\\\"，Spring MVC 会调用这些 ViewResolver，直到有一个能把 \\\"index\\\" 解析成一个真正的 View 对象（Thymeleaf 模板）。\",\"最终渲染视图 → 输出到浏览器。\",\"这里我们直接在配置类中编写：\",\"@Configuration @EnableWebMvc @ComponentScan(\\\"com.example.controller\\\") public class WebConfiguration { //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面 @Bean public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setOrder(1); //可以存在多个视图解析器，并且可以为他们设定解析顺序 resolver.setCharacterEncoding(\\\"UTF-8\\\"); //编码格式是重中之重 resolver.setTemplateEngine(springTemplateEngine); //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎 return resolver; } //配置模板解析器 @Bean public SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setSuffix(\\\".html\\\"); //需要解析的后缀名称 resolver.setPrefix(\\\"/\\\"); //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀 resolver.setCharacterEncoding(\\\"UTF-8\\\"); return resolver; } //配置模板引擎Bean @Bean public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(resolver); //模板解析器，默认即可 return engine; } } \",\"现在我们就完成了视图解析器的配置\"]},\"561\":{\"h\":\"创建对应\",\"t\":[\"接着来创建一个Controller，创建Controller也非常简单\",\"只需在一个类上添加一个@Controller注解即可，它会被Spring扫描并自动注册为Controller类型的Bean\",\"然后我们只需要在类中编写方法用于处理对应地址的请求即可：\",\"@Controller //直接添加注解即可 public class HelloController { @RequestMapping(\\\"/\\\") //直接填写访问路径 public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); //返回ModelAndView对象，这里填入了视图的名称 //返回后会经过视图解析器进行处理 } } \"]},\"562\":{\"h\":\"创建对应页面文件\",\"t\":[\"接着我们在类路径根目录下创建一个简单html文件：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>测试</title> </head> <body> <p>Penguin</p> </body> </html> \"]},\"563\":{\"h\":\"前后端数据交互\",\"t\":[\"我们在之前，使用Thymeleaf解析后端的一些数据时，需要通过Context进行传递，而使用SpringMvc后\",\"数据我们可以直接向Model模型层进行提供：\",\"@RequestMapping(value = \\\"/\\\") public ModelAndView index(){ ModelAndView modelAndView = new ModelAndView(\\\"index\\\"); modelAndView.getModel().put(\\\"name\\\", \\\"啊这\\\"); //将name传递给Model return modelAndView; } \",\"这样Thymeleaf就能收到我们传递的数据进行解析：\",\"<!DOCTYPE html> <html lang=\\\"en\\\" xmlns:th=\\\"http://www.thymeleaf.org\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Title</title> <script src=\\\"static/test.js\\\"></script> </head> <body> HelloWorld！ <div th:text=\\\"${name}\\\"></div> </body> </html> \",\"当然，为了简便，我们可以直接返回View名称，SpringMVC会将其自动包装为ModelAndView对象：\",\"@RequestMapping(value = \\\"/\\\") public String index(){ return \\\"index\\\"; } \",\"我们还可以单独添加一个Model作为形参进行设置，SpringMVC通过依赖注入会自动帮助我们传递实例对象：\",\"@RequestMapping(value = \\\"/\\\") public String index(Model model){ //这里不仅仅可以是Model，还可以是Map、ModelMap model.addAttribute(\\\"name\\\", \\\"yyds\\\"); return \\\"index\\\"; } \"]},\"564\":{\"h\":\"配置静态资源\",\"t\":[\"我们的页面中可能还会包含一些静态资源，比如js、css，因此这里我们还需要配置一下，让静态资源通过Tomcat提供的默认Servlet进行解析\",\"我们需要让配置类实现一下WebMvcConfigurer接口，这样在Web应用程序启动时，会根据我们重写方法里面的内容进行进一步的配置：\",\"@Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); //开启默认的Servlet } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\\\"/static/**\\\").addResourceLocations(\\\"/static/\\\"); //配置静态资源的访问路径 } \",\"我们编写一下前端内容：\",\"<!DOCTYPE html> <html lang=\\\"en\\\" xmlns:th=\\\"http://www.thymeleaf.org\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>测试</title> <!-- 引用静态资源，这里使用Thymeleaf的网址链接表达式，Thymeleaf会自动添加web应用程序的名称到链接前面 --> <script th:src=\\\"@{/static/test.js}\\\"></script> </head> <body> <p>Penguin！</p> </body> </html> \",\"创建test.js并编写如下内容：\",\"window.alert(\\\"PPP\\\") \",\"最后访问页面，页面在加载时就会显示一个弹窗，这样我们就完成了最基本的页面配置。\",\"相比之前的方式，这样就简单很多了，直接避免了编写大量的Servlet来处理请求。\"]},\"565\":{\"c\":[\"code\"]},\"566\":{\"c\":[\"javassm\",\"Spring\"]},\"567\":{\"h\":\"Javassm - SpringMVC3\"},\"568\":{\"h\":\"Controller控制器2\"},\"569\":{\"h\":\"@RequestMapping详解\",\"t\":[\"前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可\",\"之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个@RequestMapping即可实现\",\"从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法\",\"注解定义如下：\",\"@Mapping public @interface RequestMapping { String name() default \\\"\\\"; @AliasFor(\\\"path\\\") String[] value() default {}; @AliasFor(\\\"value\\\") String[] path() default {}; RequestMethod[] method() default {}; String[] params() default {}; String[] headers() default {}; String[] consumes() default {}; String[] produces() default {}; } \",\"其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：\",\"@RequestMapping({\\\"/index\\\", \\\"/test\\\"}) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"现在我们访问/index或是/test都会经过此方法进行处理。\",\"我们也可以直接将@RequestMapping添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：\",\"@Controller @RequestMapping(\\\"/yyds\\\") public class MainController { @RequestMapping({\\\"/index\\\", \\\"/test\\\"}) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } } \",\"那么现在我们需要访问/yyds/index或是/yyds/test才可以得到此页面。\"]},\"570\":{\"h\":\"辅助功能\",\"t\":[\"我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。\"]},\"571\":{\"h\":\"通配符匹配\",\"t\":[\"路径还支持使用通配符进行匹配：\",\"?：表示任意一个字符，比如@RequestMapping(\\\"/index/x?\\\")可以匹配/index/xa、/index/xb等等。\",\"*：表示任意0-n个字符，比如@RequestMapping(\\\"/index/*\\\")可以匹配/index/lbwnb、/index/yyds等。\",\"**：表示当前目录或基于当前目录的多级目录，比如@RequestMapping(\\\"/index/**\\\")可以匹配/index、/index/xxx等。\"]},\"572\":{\"h\":\"属性\",\"t\":[\"我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式\",\"比如：\",\"@RequestMapping(value = \\\"/index\\\", method = RequestMethod.POST) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"现在我们如果直接使用浏览器访问此页面，会显示405方法不支持\",\"因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。\"]},\"573\":{\"h\":\"、\",\"t\":[\"我们也可以使用衍生注解直接设定为指定类型的请求映射：\",\"@PostMapping(value = \\\"/index\\\") public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"这里使用了@PostMapping直接指定为POST请求类型的请求映射，同样的，还有@GetMapping可以直接指定为GET请求方式，这里就不一一列举了。\"]},\"574\":{\"h\":\"属性\",\"t\":[\"我们可以使用params属性来指定请求必须携带哪些请求参数，比如：\",\"@RequestMapping(value = \\\"/index\\\", params = {\\\"username\\\", \\\"password\\\"}) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"比如这里我们要求请求中必须携带username和password属性，否则无法访问。\",\"它还支持表达式，比如我们可以这样编写：\",\"@RequestMapping(value = \\\"/index\\\", params = {\\\"!username\\\", \\\"password\\\"}) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：\",\"@RequestMapping(value = \\\"/index\\\", params = {\\\"username!=test\\\", \\\"password=123\\\"}) public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"这样，请求参数username不允许为test，并且password必须为123，否则无法访问。\"]},\"575\":{\"h\":\"获取请求参数\",\"t\":[\"想要获取对应的参数，可以用 @RequestParam 注解\",\"@RequestMapping(value = \\\"/pp\\\", params = {\\\"text\\\"}) public String pp(@RequestParam(\\\"text\\\") String text, Model model){ model.addAttribute(\\\"name\\\", text); return \\\"index\\\"; } \",\"或者从 HttpServletRequest 拿\",\"@RequestMapping(value = \\\"/pp\\\", params = {\\\"text\\\"}) public String pp(HttpServletRequest request, Model model){ String text = request.getParameter(\\\"text\\\"); model.addAttribute(\\\"name\\\", text); return \\\"index\\\"; } \"]},\"576\":{\"h\":\"属性\",\"t\":[\"header属性用法与params一致，但是它要求的是请求头中需要携带什么内容，比如：\",\"@RequestMapping(value = \\\"/index\\\", headers = \\\"!Connection\\\") public ModelAndView index(){ return new ModelAndView(\\\"index\\\"); } \",\"那么，如果请求头中携带了Connection属性，将无法访问。\"]},\"577\":{\"h\":\"\",\"t\":[\"其他两个属性：\",\"consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\",\"produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\"]},\"578\":{\"h\":\"@RequestParam和@RequestHeader详解\",\"t\":[\"我们接着来看，如何获取到请求中的参数。\"]},\"579\":{\"h\":\"\",\"t\":[\"我们只需要为方法添加一个形式参数，并在形式参数前面添加@RequestParam注解即可：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(@RequestParam(\\\"username\\\") String username){ System.out.println(\\\"接受到请求参数：\\\"+username); return new ModelAndView(\\\"index\\\"); } \",\"我们需要在@RequestParam中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用\",\"注意，如果参数名称与形式参数名称相同，即使不添加@RequestParam也能获取到参数值。\"]},\"580\":{\"h\":\"属性\",\"t\":[\"一旦添加@RequestParam，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(@RequestParam(value = \\\"username\\\", required = false) String username){ System.out.println(\\\"接受到请求参数：\\\"+username); return new ModelAndView(\\\"index\\\"); } \"]},\"581\":{\"h\":\"\",\"t\":[\"我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(@RequestParam(value = \\\"username\\\", required = false, defaultValue = \\\"伞兵一号\\\") String username){ System.out.println(\\\"接受到请求参数：\\\"+username); return new ModelAndView(\\\"index\\\"); } \"]},\"582\":{\"h\":\"\",\"t\":[\"如果需要使用Servlet原本的一些类，比如：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(HttpServletRequest request){ System.out.println(\\\"接受到请求参数：\\\"+request.getParameterMap().keySet()); return new ModelAndView(\\\"index\\\"); } \",\"直接添加HttpServletRequest为形式参数即可，SpringMVC会自动传递该请求原本的HttpServletRequest对象\",\"同理，我们也可以添加HttpServletResponse作为形式参数，甚至可以直接将HttpSession也作为参数传递：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(HttpSession session){ System.out.println(session.getAttribute(\\\"test\\\")); session.setAttribute(\\\"test\\\", \\\"鸡你太美\\\"); return new ModelAndView(\\\"index\\\"); } \"]},\"583\":{\"h\":\"直接参数传递实体类\",\"t\":[\"我们还可以直接将请求参数传递给一个实体类：\",\"@Data public class User { String username; String password; } \",\"注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(User user){ System.out.println(\\\"获取到cookie值为：\\\"+user); return new ModelAndView(\\\"index\\\"); } \",\"@RequestHeader与@RequestParam用法一致，不过它是用于获取请求头参数的，这里就不再演示了。\"]},\"584\":{\"h\":\"@CookieValue和@SessionAttrbutie\"},\"585\":{\"h\":\"\",\"t\":[\"通过使用@CookieValue注解，我们也可以快速获取请求携带的Cookie信息：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(HttpServletResponse response, @CookieValue(value = \\\"test\\\", required = false) String test){ System.out.println(\\\"获取到cookie值为：\\\"+test); response.addCookie(new Cookie(\\\"test\\\", \\\"lbwnb\\\")); return new ModelAndView(\\\"index\\\"); } \"]},\"586\":{\"h\":\"\",\"t\":[\"同样的，Session也能使用注解快速获取：\",\"@RequestMapping(value = \\\"/index\\\") public ModelAndView index(@SessionAttribute(value = \\\"test\\\", required = false) String test, HttpSession session){ session.setAttribute(\\\"test\\\", \\\"xxxx\\\"); System.out.println(test); return new ModelAndView(\\\"index\\\"); } \",\"可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。\"]},\"587\":{\"h\":\"重定向和请求转发\",\"t\":[\"重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可\",\"比如重定向 redirect：\",\"@RequestMapping(\\\"/index\\\") public String index(){ return \\\"redirect:home\\\"; } @RequestMapping(\\\"/home\\\") public String home(){ return \\\"home\\\"; } \",\"通过添加redirect:前缀，就可以很方便地实现重定向\",\"请求转发，其实也是一样的，使用forward:前缀表示转发给其他请求映射：\",\"@RequestMapping(\\\"/index\\\") public String index(){ return \\\"forward:home\\\"; } @RequestMapping(\\\"/home\\\") public String home(){ return \\\"home\\\"; } \",\"使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。\"]},\"588\":{\"h\":\"Bean的Web作用域\",\"t\":[\"在学习Spring时我们讲解了Bean的作用域，包括singleton和prototype，Bean分别会以单例和多例模式进行创建\",\"在SpringMVC中，它的作用域被继续细分：\",\"request：对于每次HTTP请求，使用request作用域定义的Bean都将产生一个新实例，请求结束后Bean也消失。\",\"session：对于每一个会话(一个页面)，使用session作用域定义的Bean都将产生一个新实例，会话过期后Bean也消失。\",\"global session：不常用，不做讲解。\",\"这里我们创建一个测试类来试试看：\",\"public class TestBean { } \",\"接着将其注册为Bean，注意这里需要添加@RequestScope或是@SessionScope表示此Bean的Web作用域：\",\"@Bean @RequestScope public TestBean testBean(){ return new TestBean(); } \",\"接着我们将其自动注入到Controller中：\",\"@Controller public class MainController { @Resource TestBean bean; @RequestMapping(value = \\\"/index\\\") public ModelAndView index(){ System.out.println(bean); return new ModelAndView(\\\"index\\\"); } } \",\"我们发现，每次发起得到的Bean实例都不同，接着我们将其作用域修改为@SessionScope，这样作用域就上升到Session，只要清理浏览器的Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么Bean实例始终不变。\",\"实际上，它也是通过代理实现的，我们调用Bean中的方法会被转发到真正的Bean对象去执行。\"]},\"589\":{\"h\":\"RestFul风格\",\"t\":[\"中文释义为表现层状态转换（名字挺高大上的），它不是一种标准，而是一种设计风格。\",\"它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。\",\"通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端\",\"目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST/GET/PUT/DELETE），来执行相同请求地址的不同类型操作。\",\"因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：\",\"http://localhost:8080/mvc/index/123456 \",\"我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：\",\"@RequestMapping(\\\"/index/{str}\\\") public String index(@PathVariable String str) { System.out.println(str); return \\\"index\\\"; } \",\"注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了@PathVariable注解的参数，或是由@PathVariable注解指定为占位符名称：\",\"@RequestMapping(\\\"/index/{str}\\\") public String index(@PathVariable(\\\"str\\\") String text){ System.out.println(text); return \\\"index\\\"; } \",\"如果没有配置正确，方法名称上会出现黄线。\",\"我们可以按照不同功能进行划分：\",\"POST http://localhost:8080/mvc/index - 添加用户信息，携带表单数据\",\"GET http://localhost:8080/mvc/index/{id} - 获取用户信息，id直接放在请求路径中\",\"PUT http://localhost:8080/mvc/index - 修改用户信息，携带表单数据\",\"DELETE http://localhost:8080/mvc/index/{id} - 删除用户信息，id直接放在请求路径中\",\"我们分别编写四个请求映射：\",\"@Controller public class MainController { @RequestMapping(value = \\\"/index/{id}\\\", method = RequestMethod.GET) public String get(@PathVariable(\\\"id\\\") String text){ System.out.println(\\\"获取用户：\\\"+text); return \\\"index\\\"; } @RequestMapping(value = \\\"/index\\\", method = RequestMethod.POST) public String post(String username){ System.out.println(\\\"添加用户：\\\"+username); return \\\"index\\\"; } @RequestMapping(value = \\\"/index/{id}\\\", method = RequestMethod.DELETE) public String delete(@PathVariable(\\\"id\\\") String text){ System.out.println(\\\"删除用户：\\\"+text); return \\\"index\\\"; } @RequestMapping(value = \\\"/index\\\", method = RequestMethod.PUT) public String put(String username){ System.out.println(\\\"修改用户：\\\"+username); return \\\"index\\\"; } } \",\"这只是一种设计风格而已，了解即可。\"]},\"590\":{\"c\":[\"code\"]},\"591\":{\"c\":[\"javassm\",\"Spring\"]},\"592\":{\"h\":\"Javassm - SpringMVC4\"},\"593\":{\"h\":\"Interceptor拦截器\",\"t\":[\"拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求\",\"但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的过滤器才可以成功到达Servlet\",\"而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理\",\"它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。\",\"alt text\"]},\"594\":{\"h\":\"创建拦截器\"},\"595\":{\"h\":\"接口\",\"t\":[\"创建一个拦截器我们需要实现一个HandlerInterceptor接口：\",\"public class MainInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"我是处理之前！\\\"); return true; //只有返回true才会继续，否则直接结束 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"我是处理之后！\\\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //在DispatcherServlet完全处理完请求后被调用 System.out.println(\\\"我是完成之后！\\\"); } } \"]},\"596\":{\"h\":\"配置类注册\",\"t\":[\"接着我们需要在配置类中进行注册：\",\"@Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MainInterceptor()) .addPathPatterns(\\\"/**\\\") //添加拦截器的匹配路径，只要匹配一律拦截 .excludePathPatterns(\\\"/home\\\"); //拦截器不进行拦截的路径 } \",\"现在我们在浏览器中访问index页面，拦截器已经生效。\"]},\"597\":{\"h\":\"执行结果\",\"t\":[\"得到整理拦截器的执行顺序：\",\"我是处理之前！ 我是处理！ 我是处理之后！ 我是完成之后！ \",\"也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次afterCompletion方法\",\"其实整个过程与我们之前所认识的Filter类似，不过在处理前，我们只需要返回true或是false表示是否被拦截即可，而不是再去使用FilterChain进行向下传递。\"]},\"598\":{\"h\":\"返回 情况\",\"t\":[\"那么我们就来看看，如果处理前返回false，会怎么样：\",\"我是处理之前！ \",\"通过结果发现一旦返回false，之后的所有流程全部取消\"]},\"599\":{\"h\":\"发生异常情况\",\"t\":[\"那么如果是在处理中发生异常了呢？\",\"@RequestMapping(\\\"/index\\\") public String index(){ System.out.println(\\\"我是处理！\\\"); if(true) throw new RuntimeException(\\\"\\\"); return \\\"index\\\"; } \",\"结果为：\",\"我是处理之前！ 我是处理！ 我是完成之后！ \",\"我们发现如果处理过程中抛出异常，那么不会执行处理后postHandle方法\",\"但是会执行afterCompletion方法，我们可以在此方法中获取到抛出的异常。\"]},\"600\":{\"h\":\"多级拦截器\",\"t\":[\"前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：\",\"public class SubInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"二号拦截器：我是处理之前！\\\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"二号拦截器：我是处理之后！\\\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"二号拦截器：我是完成之后！\\\"); } } \",\"注册二号拦截器：\",\"@Override public void addInterceptors(InterceptorRegistry registry) { //一号拦截器 registry.addInterceptor(new MainInterceptor()).addPathPatterns(\\\"/**\\\").excludePathPatterns(\\\"/home\\\"); //二号拦截器 registry.addInterceptor(new SubInterceptor()).addPathPatterns(\\\"/**\\\"); } \",\"注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：\",\"一号拦截器：我是处理之前！ 二号拦截器：我是处理之前！ 我是处理！ 二号拦截器：我是处理之后！ 一号拦截器：我是处理之后！ 二号拦截器：我是完成之后！ 一号拦截器：我是完成之后！ \",\"和多级Filter相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法\",\"而完成后是在所有的postHandle执行之后再同样的以倒序方式执行。\",\"那么如果这时一号拦截器在处理前就返回了false呢？\",\"@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"一号拦截器：我是处理之前！\\\"); return false; } \",\"得到结果如下：\",\"一号拦截器：我是处理之前！ \",\"我们发现，与单个拦截器的情况一样，一旦拦截器返回false，那么之后无论有无拦截器，都不再继续。\"]},\"601\":{\"h\":\"\",\"t\":[\"我们可以添加 order 来规定拦截器的顺序，order越小，先拦截\",\"@Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new FirstInterceptor()).addPathPatterns(\\\"/**\\\").order(2); //二号拦截器 registry.addInterceptor(new SecondInterceptor()).addPathPatterns(\\\"/**\\\").order(1); } \",\"结果为\",\"二号拦截器：我是处理之前！ 一号拦截器：我是处理之前！ 我是处理！ 一号拦截器：我是处理之后！ 二号拦截器：我是处理之后！ 一号拦截器：我是完成之后！ 二号拦截器：我是完成之后！ \"]},\"602\":{\"h\":\"异常处理\",\"t\":[\"当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为SpringMVC为我们提供了默认的异常处理页面\",\"当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。\",\"@ControllerAdvice，是Spring3.2提供的新注解，它是一个Controller增强器，可对controller进行增强处理。\",\"配合@ExceptionHandler注解，进行全局异常处理。\",\"配合@InitBinder注解，用来设置WebDataBinder，用于自动绑定前台请求参数到Model中，全局数据预处理，多用于表单提交数据或者url传参。\",\"配合@ModelAttribute注解，让Controller类中所有的方法都可以获取到通过@ModelAttribute注解设置的值，进行全局数据绑定。\"]},\"603\":{\"h\":\"\",\"t\":[\"作用：这是 Spring MVC 提供的“全局控制器增强”注解。\",\"特点：\",\"可以用来定义全局的异常处理（Exception Handling）、全局数据绑定（Data Binding）、全局数据预处理（Model Attribute）等。\",\"一旦在类上加了 @ControllerAdvice，该类就能拦截所有带有 @Controller 或 @RestController 的控制器请求，做统一处理。\",\"常见用法就是集中定义全局异常处理逻辑。\"]},\"604\":{\"h\":\"\",\"t\":[\"作用：这是 Spring MVC 提供的异常处理注解。\",\"特点：\",\"标注在方法上，表示该方法用来捕获并处理指定类型的异常。\",\"上例中 @ExceptionHandler(Exception.class) 表示 捕获所有 Exception 及其子类异常。\",\"当控制器方法抛出异常时，会优先匹配合适的 @ExceptionHandler 方法进行处理。\",\"方法返回值可以是一个视图名（如 \\\"500\\\"），也可以是一个 JSON 对象（常与 @ResponseBody 或 @RestControllerAdvice 配合使用）。\"]},\"605\":{\"h\":\"应用\",\"t\":[\"我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：\",\"@ControllerAdvice public class ErrorController { @ExceptionHandler(Exception.class) public String error(Exception e, Model model){ //可以直接添加形参来获取异常 e.printStackTrace(); model.addAttribute(\\\"e\\\", e); return \\\"500\\\"; } } \",\"接着我们编写一个专门显示异常的页面：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Title</title> </head> <body> 500 - 服务器出现了一个内部错误QAQ <div th:text=\\\"${e}\\\"></div> </body> </html> \",\"接着给一个报错：\",\"@RequestMapping(\\\"/index\\\") public String index(){ System.out.println(\\\"我是处理！\\\"); if(true) throw new RuntimeException(\\\"您的氪金力度不足，无法访问！\\\"); return \\\"index\\\"; } \",\"访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。\"]},\"606\":{\"c\":[\"code\"]},\"607\":{\"c\":[\"javassm\",\"Spring\"]},\"608\":{\"h\":\"Javassm - SpringMVC5\"},\"609\":{\"h\":\"JSON数据格式与Axios请求\",\"t\":[\"JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。\",\"我们现在推崇的是前后端分离的开发模式，而不是所有的内容全部交给后端渲染再发送给浏览器\",\"也就是说，整个Web页面的内容在一开始就编写完成了，而其中的数据由前端执行JS代码来向服务器动态获取，再到前端进行渲染（填充），这样可以大幅度减少后端的压力，并且后端只需要传输关键数据即可\"]},\"610\":{\"h\":\"JSON数据格式\",\"t\":[\"既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。\",\"因此JSON横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过JSON格式承载的。\",\"一个JSON格式的数据长这样，以学生对象为例：\",\"{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18} \",\"多个学生可以以数组的形式表示：\",\"[{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18}, {\\\"name\\\": \\\"阿伟\\\", \\\"age\\\": 18}] \",\"嵌套关系可以表示为：\",\"{\\\"studentList\\\": [{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18}, {\\\"name\\\": \\\"阿伟\\\", \\\"age\\\": 18}], \\\"count\\\": 2} \",\"它直接包括了属性的名称和属性的值，与JavaScript的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个JS对象，我们可以直接在控制台窗口中测试：\",\"let obj = JSON.parse('{\\\"studentList\\\": [{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18}, {\\\"name\\\": \\\"阿伟\\\", \\\"age\\\": 18}], \\\"count\\\": 2}') //将JSON格式字符串转换为JS对象 obj.studentList[0].name //直接访问第一个学生的名称 \",\"我们也可以将JS对象转换为JSON字符串：\",\"JSON.stringify(obj) \",\"我们后端就可以以JSON字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。\"]},\"611\":{\"h\":\"后端处理 JSON 格式数据\",\"t\":[\"那么后端如何快速创建一个JSON格式的数据呢？\",\"我们首先需要导入以下依赖：\",\"<dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2</artifactId> <version>2.0.34</version> </dependency> \",\"JSON解析框架有很多种，比较常用的是Jackson和FastJSON，这里我们使用阿里巴巴的FastJSON进行解析，这是目前号称最快的JSON解析框架，并且现在已经强势推出FastJSON 2版本。\"]},\"612\":{\"h\":\"\",\"t\":[\"首先要介绍的是JSONObject，它和Map的使用方法一样，并且是有序的（实现了LinkedHashMap接口），比如我们向其中存放几个数据：\",\"@RequestMapping(value = \\\"/index\\\") public String index(){ JSONObject object = new JSONObject(); object.put(\\\"name\\\", \\\"杰哥\\\"); object.put(\\\"age\\\", 18); System.out.println(object.toJSONString()); //以JSON格式输出JSONObject字符串 return \\\"index\\\"; } \",\"最后我们得到的结果为：\",\"{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18} \",\"实际上JSONObject就是对JSON数据的一种对象表示。\"]},\"613\":{\"h\":\"\",\"t\":[\"同样的还有JSONArray，它表示一个数组，用法和List一样，是继承于ArrayList,数组中可以嵌套其他的JSONObject或是JSONArray：\",\"@RequestMapping(value = \\\"/index\\\") public String index(){ JSONObject object = new JSONObject(); object.put(\\\"name\\\", \\\"杰哥\\\"); object.put(\\\"age\\\", 18); JSONArray array = new JSONArray(); array.add(object); System.out.println(array.toJSONString()); return \\\"index\\\"; } \",\"得到的结果为：\",\"[{\\\"name\\\": \\\"杰哥\\\", \\\"age\\\": 18}] \"]},\"614\":{\"h\":\"循环引用情况\",\"t\":[\"当出现循环引用时，会按照以下语法来解析：\",\"alt text\"]},\"615\":{\"h\":\"实体类转换JSON\",\"t\":[\"我们可以也直接创建一个实体类，将实体类转换为JSON格式的数据：\",\"@RequestMapping(value = \\\"/index\\\", produces = \\\"application/json\\\") @ResponseBody public String data(){ Student student = new Student(); student.setName(\\\"杰哥\\\"); student.setAge(18); return JSON.toJSONString(student); } \",\"这里我们修改了produces的值，将返回的内容类型设定为application/json，表示服务器端返回了一个JSON格式的数据（当然不设置也行，也能展示，这样是为了规范）\",\"然后我们在方法上添加一个@ResponseBody表示方法返回（也可以在类上添加@RestController表示此Controller默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。\",\"接着我们使用JSON工具类将其转换为JSON格式的字符串，打开浏览器，得到JSON格式数据。\"]},\"616\":{\"h\":\"自动转换\",\"t\":[\"SpringMVC非常智能，我们可以直接返回一个对象类型，它会被自动转换为JSON字符串格式：\",\"@RequestMapping(value = \\\"/data\\\", produces = \\\"application/json\\\") @ResponseBody public Student data(){ Student student = new Student(); student.setName(\\\"杰哥\\\"); student.setAge(18); return student; } \",\"注意需要在配置类中添加一下FastJSON转换器，这里需要先添加一个依赖：\",\"<dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2-extension-spring6</artifactId> <version>2.0.34</version> </dependency> \",\"然后编写配置：\",\"@Override public void configureMessageConverters(List<HttpMessageConverter<?>> converters) { converters.add(new FastJsonHttpMessageConverter()); } \",\"再次尝试，内容就会自动转换为JSON格式响应给客户端了。\"]},\"617\":{\"h\":\"Axios异步请求\",\"t\":[\"前面我们讲解了如何向浏览器发送一个JSON格式的数据，那么我们现在来看看如何向服务器请求数据。\",\"alt text\",\"前端为什么需要用到异步请求，这是因为我们的网页是动态的（这里的动态不是指有动画效果，而是能够实时更新内容）比如我们点击一个按钮会弹出新的内容、或是跳转到新的页面、更新页面中的数据等等，这些都需要通过JS完成异步请求来实现。\",\"前端异步请求指的是在前端中发送请求至服务器或其他资源，并且不阻塞用户界面或其他操作。在传统的同步请求中，当发送请求时，浏览器会等待服务器响应，期间用户无法进行其他操作。而异步请求通过将请求发送到后台，在等待响应的同时，允许用户继续进行其他操作。这种机制能够提升用户体验，并且允许页面进行实时更新。常见的前端异步请求方式包括使用XMLHttpRequest对象、Fetch API、以及使用jQuery库中的AJAX方法，以及目前最常用的Axios框架等。\",\"假设我们后端有一个需要实时刷新的数据（随时间而变化）现在需要再前端实时更新展示，这里我们以axios框架的简单使用为例子，带各位小伙伴体验如何发起异步请求并更新我们页面中的数据。\",\"首先是前端页面：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>测试</title> <script src=\\\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\\\"></script> </head> <body> <p>欢迎来到GayHub全球最大同性交友网站</p> <p>用户名: <span id=\\\"username\\\"></span></p> <p>密码: <span id=\\\"password\\\"></span></p> </body> </html> \",\"接着我们使用axios框架直接对后端请求JSON数据：\",\"<script> function getInfo() { axios.get('/mvc/test').then(({data}) => { document.getElementById('username').innerText = data.username document.getElementById('password').innerText = data.password }) } </script> \",\"这样，我们就实现了从服务端获取数据并更新到页面中，前端开发者利用JS发起异步请求，可以实现各种各样的效果\",\"而我们后端开发者只需要关心接口返回正确的数据即可，这就已经有前后端分离开发的雏形了\",\"那么我们接着来看，如何向服务端发送一个JS对象数据并进行解析，这里以简单的登录为例：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>测试</title> <script src=\\\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\\\"></script> </head> <body> <p>欢迎来到GayHub全球最大同性交友网站</p> <button onclick=\\\"login()\\\">立即登录</button> </body> </html> \",\"这里依然使用axios发送POST请求：\",\"<script> function login() { axios.post('/mvc/test', { username: 'test', password: '123456' }, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }).then(({data}) => { if(data.success) { alert('登录成功') } else { alert('登录失败') } }) } </script> \",\"服务器端只需要在请求参数位置添加一个对象接收即可（和前面是一样的，因为这里也是提交的表单数据）：\",\"@ResponseBody @PostMapping(value = \\\"/test\\\", produces = \\\"application/json\\\") public String hello(String username, String password){ boolean success = \\\"test\\\".equals(user.getUsername()) && \\\"123456\\\".equals(user.getPassword()); JSONObject object = new JSONObject(); object.put(\\\"success\\\", success); return object.toString(); } \",\"我们也可以将js对象转换为JSON字符串的形式进行传输，这里需要使用ajax方法来处理：\",\"<script> function login() { axios.post('/mvc/test', { username: 'test', password: '123456' }).then(({data}) => { if(data.success) { alert('登录成功') } else { alert('登录失败') } }) } </script> \",\"如果我们需要读取前端发送给我们的JSON格式数据，那么这个时候就需要添加@RequestBody注解：\",\"@ResponseBody @PostMapping(value = \\\"/test\\\", produces = \\\"application/json\\\") public String hello(@RequestBody User user){ boolean success = \\\"test\\\".equals(user.getUsername()) && \\\"123456\\\".equals(user.getPassword()); JSONObject object = new JSONObject(); object.put(\\\"success\\\", success); return object.toString(); } \",\"这样，我们就实现了前后端使用JSON字符串进行通信。\"]},\"618\":{\"h\":\"实现文件上传和下载\",\"t\":[\"利用SpringMVC，我们可以很轻松地实现文件上传和下载\"]},\"619\":{\"h\":\"文件上传\",\"t\":[\"alt text\",\"Spring MVC 里要启用文件上传，底层其实还是依赖 Servlet 的 multipart 机制。\",\"我们需要在MainInitializer中添加一个新的方法：\",\"public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { ... @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) { // 直接通过registration配置Multipart相关配置，必须配置临时上传路径，建议选择方便打开的 // 同样可以设置其他属性：maxFileSize, maxRequestSize, fileSizeThreshold registration.setMultipartConfig(new MultipartConfigElement(\\\"/Users/nagocoler/Download\\\")); } } \",\"接着我们直接编写Controller即可：\",\"@RequestMapping(value = \\\"/upload\\\", method = RequestMethod.POST) @ResponseBody public String upload(@RequestParam(\\\"penguin\\\") MultipartFile file) throws IOException { File fileObj = new File(\\\"test.png\\\"); file.transferTo(fileObj); System.out.println(\\\"用户上传的文件已保存到：\\\"+fileObj.getAbsolutePath()); return \\\"文件上传成功！\\\"; } \",\"最后在前端添加一个文件的上传点：\",\"<div> <form action=\\\"upload\\\" method=\\\"post\\\" enctype=\\\"multipart/form-data\\\"> <input type=\\\"file\\\" name=\\\"penguin\\\"> <input type=\\\"submit\\\"> </form> </div> \",\"这样，点击提交之后，文件就会上传到服务器了。\"]},\"620\":{\"h\":\"文件下载\",\"t\":[\"下载其实和我们之前的写法大致一样，直接使用HttpServletResponse，并向输出流中传输数据即可。\",\"@RequestMapping(value = \\\"/download\\\", method = RequestMethod.GET) @ResponseBody public void download(HttpServletResponse response){ response.setContentType(\\\"multipart/form-data\\\"); try(OutputStream stream = response.getOutputStream(); InputStream inputStream = new FileInputStream(\\\"test.png\\\")){ IOUtils.copy(inputStream, stream); }catch (IOException e){ e.printStackTrace(); } } \",\"在前端页面中添加一个下载点：\",\"<a href=\\\"download\\\" download=\\\"test.png\\\">下载最新资源</a> \",\"alt text\"]},\"621\":{\"c\":[\"code\"]},\"622\":{\"c\":[\"javassm\",\"Spring\"]},\"623\":{\"h\":\"Javassm - SpringMVC6\"},\"624\":{\"h\":\"解读DispatcherServlet源码\",\"t\":[\"到目前为止，关于SpringMVC的相关内容就学习得差不多了\",\"了解一下DispatcherServlet底层是如何进行调度的\"]},\"625\":{\"h\":\"源码分析\",\"t\":[\"首先我们需要找到DispatcherServlet的最顶层HttpServletBean，在这里直接继承的HttpServlet\",\"那么我们首先来看一下，它在初始化方法中做了什么：\",\"public final void init() throws ServletException { //读取配置参数，并进行配置 PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment())); this.initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException var4) { if (this.logger.isErrorEnabled()) { this.logger.error(\\\"Failed to set bean properties on servlet '\\\" + this.getServletName() + \\\"'\\\", var4); } throw var4; } } //此初始化阶段由子类实现， this.initServletBean(); } \",\"我们接着来看initServletBean()方法是如何实现的，它是在子类FrameworkServlet中定义的：\",\"protected final void initServletBean() throws ServletException { this.getServletContext().log(\\\"Initializing Spring \\\" + this.getClass().getSimpleName() + \\\" '\\\" + this.getServletName() + \\\"'\\\"); if (this.logger.isInfoEnabled()) { this.logger.info(\\\"Initializing Servlet '\\\" + this.getServletName() + \\\"'\\\"); } long startTime = System.currentTimeMillis(); try { // 注意：我们在一开始说了SpringMVC有两个容器，一个是Web容器一个是根容器 // Web容器只负责Controller等表现层内容 // 根容器就是Spring容器，它负责Service、Dao等，并且它是Web容器的父容器。 // 初始化WebApplicationContext，这个阶段会为根容器和Web容器进行父子关系建立 this.webApplicationContext = this.initWebApplicationContext(); this.initFrameworkServlet(); } catch (RuntimeException | ServletException var4) { //...以下内容全是打印日志 } } \",\"alt text\",\"我们来看看initWebApplicationContext是如何进行初始化的：\",\"protected WebApplicationContext initWebApplicationContext() { // 这里获取的是根容器，一般用于配置Service、数据源等 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // 如果webApplicationContext在之前已经存在，则直接给到wac wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext)wac; if (!cwac.isActive()) { if (cwac.getParent() == null) { // 设定根容器为Web容器的父容器 cwac.setParent(rootContext); } this.configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // 如果webApplicationContext是空，那么就从ServletContext找一下有没有初始化上下文 wac = this.findWebApplicationContext(); } if (wac == null) { // 如果还是找不到，直接创个新的，并直接将根容器作为父容器 wac = this.createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { synchronized(this.onRefreshMonitor) { //此方法由DispatcherServlet实现 this.onRefresh(wac); } } if (this.publishContext) { String attrName = this.getServletContextAttributeName(); //把Web容器丢进ServletContext this.getServletContext().setAttribute(attrName, wac); } return wac; } \",\"我们接着来看DispatcherServlet中实现的onRefresh()方法：\",\"@Override protected void onRefresh(ApplicationContext context) { initStrategies(context); } protected void initStrategies(ApplicationContext context) { //初始化各种解析器 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); //在容器中查找所有的HandlerMapping，放入集合中 //HandlerMapping保存了所有的请求映射信息（Controller中定义的），它可以根据请求找到处理器Handler，但并不是简单的返回处理器，而是将处理器和拦截器封装，形成一个处理器执行链（类似于之前的Filter） initHandlerMappings(context); //在容器中查找所有的HandlerAdapter，它用于处理请求并返回ModelAndView对象 //默认有三种实现HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter //当HandlerMapping找到处理请求的Controller之后，会选择一个合适的HandlerAdapter处理请求 //比如我们之前使用的是注解方式配置Controller，现在有一个请求携带了一个参数，那么HandlerAdapter会对请求的数据进行解析，并传入方法作为实参，最后根据方法的返回值将其封装为ModelAndView对象 initHandlerAdapters(context); //其他的内容 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); } \",\"DispatcherServlet初始化过程我们已经了解了\"]},\"626\":{\"h\":\"调度\",\"t\":[\"接着来看DispatcherServlet是如何进行调度的\",\"首先我们的请求肯定会经过HttpServlet，然后其交给对应的doGet、doPost等方法进行处理\",\"而在FrameworkServlet中，这些方法都被重写，并且使用processRequest来进行处理：\",\"protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.processRequest(request, response); } protected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.processRequest(request, response); } \",\"我们来看看processRequest做了什么：\",\"protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 前期准备工作 long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = this.buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor()); this.initContextHolders(request, localeContext, requestAttributes); try { // 重点在这里，这里进行了Service的执行，不过是在DispatcherServlet中定义的 this.doService(request, response); } catch (IOException | ServletException var16) { //... } \",\"请各位一定要耐心，这些大型框架的底层一般都是层层套娃，因为这样写起来层次会更加清晰\",\"来看看DispatcherServlet中是如何实现的：\",\"protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { //... try { //重点在这里，这才是整个处理过程中最核心的部分 this.doDispatch(request, response); } finally { //... } \",\"最核心的部分了：\",\"protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { try { ModelAndView mv = null; Object dispatchException = null; try { processedRequest = this.checkMultipart(request); multipartRequestParsed = processedRequest != request; // 在HandlerMapping集合中寻找可以处理当前请求的HandlerMapping mappedHandler = this.getHandler(processedRequest); if (mappedHandler == null) { this.noHandlerFound(processedRequest, response); //找不到HandlerMapping则无法进行处理 return; } // 根据HandlerMapping提供的信息，找到可以处理的HandlerAdapter HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); String method = request.getMethod(); boolean isGet = HttpMethod.GET.matches(method); if (isGet || HttpMethod.HEAD.matches(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) { return; } } // 执行所有拦截器的preHandle()方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // 使用HandlerAdapter进行处理（我们编写的请求映射方法在这个位置才真正地执行了） // HandlerAdapter会帮助我们将请求的数据进行处理，再来调用我们编写的请求映射方法 // 最后HandlerAdapter会将结果封装为ModelAndView返回给mv mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } this.applyDefaultViewName(processedRequest, mv); //执行所有拦截器的postHandle()方法 mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception var20) { dispatchException = var20; } catch (Throwable var21) { dispatchException = new NestedServletException(\\\"Handler dispatch failed\\\", var21); } // 最后处理结果，对视图进行渲染等，如果抛出异常会出现错误页面 this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); } catch (Exception var22) { this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22); } catch (Throwable var23) { this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\\\"Handler processing failed\\\", var23)); } } finally { if (asyncManager.isConcurrentHandlingStarted()) { if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else if (multipartRequestParsed) { this.cleanupMultipart(processedRequest); } } } \",\"所以，根据以上源码分析得出最终的流程图：\",\"alt text\",\"虽然完成本章学习后，我们已经基本能够基于Spring去重新编写一个更加高级的图书管理系统了，但是登陆验证复杂的问题依然没有解决，如果我们依然按照之前的方式编写登陆验证，显然太过简单，它仅仅只是一个登陆，但是没有任何的权限划分或是加密处理，我们需要更加高级的权限校验框架来帮助我们实现登陆操作，下一章，我们会详细讲解如何使用更加高级的SpringSecurity框架来进行权限验证。\"]},\"627\":{\"c\":[\"code\"]},\"628\":{\"c\":[\"javassm\",\"Spring\"]},\"629\":{\"h\":\"Javassm - SpringMVC7 (杂)\"},\"630\":{\"h\":\"MVC\",\"t\":[\"alt text\"]},\"631\":{\"h\":\"HandleMapping\",\"t\":[\"可以看到有：\",\"alt text\",\"应该这是 Spring MVC 自带的三个 HandleMapping\",\"alt text\",\"private void initHandlerMappings(ApplicationContext context) { this.handlerMappings = null; if (this.detectAllHandlerMappings) { Map<String, HandlerMapping> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) { this.handlerMappings = new ArrayList(matchingBeans.values()); AnnotationAwareOrderComparator.sort(this.handlerMappings); } } ... } \",\"这里主要会遍历，利用 BeanFactoryUtils.beansOfTypeIncludingAncestors() 去找对应的 Bean\",\"alt text\"]},\"632\":{\"c\":[\"code\"]},\"633\":{\"c\":[\"javassm\",\"Spring\"]},\"634\":{\"h\":\"Javassm - SpringSecurity1\"},\"635\":{\"h\":\"SpringSecurity\",\"t\":[\"SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：\",\"认证 （用户登录）\",\"授权 （此用户能够做哪些事情）\",\"攻击防护 （防止伪造身份攻击）\"]},\"636\":{\"h\":\"测试环境搭建\",\"t\":[\"为了测试我们之前的网站安全性，这里我们基于Mvc框架重新搭建一个采用之前的验证方式的简易网站\",\"alt text\",\"首先是登录界面部分：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>登录白马银行</title> </head> <body> <form action=\\\"login\\\" method=\\\"post\\\"> <label> 用户名： <input name=\\\"username\\\" type=\\\"text\\\"> </label> <label> 密码： <input name=\\\"password\\\" type=\\\"password\\\"> </label> <button type=\\\"submit\\\">登录</button> </form> <div th:if=\\\"${status}\\\">登录失败，用户名或密码错误！</div> </body> </html> \",\"接着是登录之后的首页：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>白马银行 - 首页</title> </head> <body> </body> </html> \",\"接着是Controller部分：\",\"@Controller public class HelloController { //处理登录操作并跳转 @PostMapping(\\\"/login\\\") public String login(@RequestParam String username, @RequestParam String password, HttpSession session, Model model){ if(\\\"test\\\".equals(username) && \\\"123456\\\".equals(password)) { session.setAttribute(\\\"login\\\", true); return \\\"redirect:/\\\"; } else { model.addAttribute(\\\"status\\\", true); return \\\"login\\\"; } } //处理首页或是登录界面跳转 @GetMapping(\\\"/\\\") public String index(HttpSession session){ if(session.getAttribute(\\\"login\\\") != null) { return \\\"index\\\"; }else { return \\\"login\\\"; } } } \",\"这样我们就可以进行简单登录了\",\"接着我们在首页加一个转账操作，要求填写转账人账号名称：\",\"@ResponseBody @PostMapping(\\\"/pay\\\") public JSONObject pay(@RequestParam String account, HttpSession session){ JSONObject object = new JSONObject(); //登录之后才能转账 if(session.getAttribute(\\\"login\\\") != null) { System.out.println(\\\"转账给\\\"+account+\\\"成功，交易已完成！\\\"); object.put(\\\"success\\\", true); } else { System.out.println(\\\"转账给\\\"+account+\\\"失败，用户未登录！\\\"); object.put(\\\"success\\\", false); } return object; } \",\"接着我们在页面中添加一个简单的转账操作按键：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>白马银行 - 首页</title> <script src=\\\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\\\"></script> </head> <body> <div> <label> 转账账号： <input type=\\\"text\\\" id=\\\"account\\\"/> </label> <button onclick=\\\"pay()\\\">立即转账</button> </div> </body> </html> <script> function pay() { const account = document.getElementById(\\\"account\\\").value axios.post('/mvc/pay', { account: account }, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }).then(({data}) => { if(data.success) alert(\\\"转账成功\\\") else alert(\\\"转账失败\\\") }) } </script> \",\"这样我们就成功搭建好网络安全的测试项目了\"]},\"637\":{\"c\":[\"code\"]},\"638\":{\"c\":[\"javassm\",\"Spring\"]},\"639\":{\"h\":\"Javassm - SpringSecurity2\"},\"640\":{\"h\":\"SpringSecurity2\"},\"641\":{\"h\":\"CSRF跨站请求伪造攻击\",\"t\":[\"CSRF是我们要介绍的第一种攻击形式，这种攻击方式非常好理解。\",\"我们时常会在QQ上收到别人发送的钓鱼网站链接，只要你在上面登陆了你的QQ账号，那么不出意外，你的号已经在别人手中了。\",\"实际上这一类网站都属于恶意网站，专门用于盗取他人信息，执行非法操作，甚至获取他人账户中的财产，非法转账等。而这里，我们需要了解一种比较容易发生的恶意操作，从不法分子的角度去了解整个流程。\",\"我们在JavaWeb阶段已经了解了Session和Cookie的机制，在一开始的时候，服务端会给浏览器一个名为JSESSIONID的Cookie信息作为会话的唯一凭据，只要用户携带此Cookie访问我们的网站，那么我们就可以认定此会话属于哪个浏览器用户。\",\"因此，只要此会话的用户执行了登录操作，那么就可以随意访问个人信息等内容。\",\"我们来尝试模拟一下这种操作，来编写一个钓鱼网站：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>坤坤炒粉放鸡精视频在线观看</title> <script src=\\\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\\\"></script> </head> <body> <iframe name=\\\"hiddenIframe\\\" hidden></iframe> <form action=\\\"http://localhost:8080/mvc/pay\\\" method=\\\"post\\\" target=\\\"hiddenIframe\\\"> <input type=\\\"text\\\" name=\\\"account\\\" value=\\\"黑客\\\" hidden> <button type=\\\"submit\\\">点击下载全套视频</button> </form> </body> </html> \",\"这个页面并不是我们官方提供的页面，而是不法分子搭建的恶意网站。我们发现此页面中有一个表单，但是表单中的输入框被隐藏了，而我们看到的只有一个按钮，我们不知道这是一个表单，也不知道表单会提交给那个地址，这时整个页面就非常有迷惑性了。\",\"如果我们点击此按钮，那么整个表单的数据会以POST的形式发送给我们的服务端（会携带之前登陆我们网站的Cookie信息），但是这里很明显是另一个网站跳转，通过这样的方式，恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作，当你发现上当受骗时，钱已经被转走了。\",\"这种构建恶意页面，引导用户访问对应网站执行操作的方式称为：跨站请求伪造（CSRF，Cross Site Request Forgery）\",\"显然，我们之前编写的图书管理系统就存在这样的安全漏洞，而SpringSecurity就解决了这样的问题。\",\"当然，除了通过我们自己SpringSecurity使用去解决之外，随着现在的浏览器不断发展，安全性越来越受到重视，很多浏览器都有SameSite保护机制，当用户在两个不同域名的站点操作时，默认情况下Cookie就会被自动屏蔽：\",\"SameSite是一种安全机制，旨在防止跨站点请求伪造（CSRF）攻击，它通过限制第三方Cookie的使用来实现这一目的。\",\"在Chrome浏览器中，SameSite默认为Lax，这意味着第三方Cookie只能在用户导航到与原始站点相同的站点时发送。\"]},\"642\":{\"h\":\"SFA会话固定攻击\",\"t\":[\"这同样是利用Cookie中相同的JSESSIONID进行的攻击\",\"会话固定攻击（Session fixation attack）是一种针对Web应用程序的安全漏洞攻击，攻击者利用这种漏洞，将一个有效的会话ID分配给用户，并诱使用户在该会话中进行操作，然后攻击者可以利用该会话ID获取用户的权限，或者通过此会话继续进行其他攻击。\",\"简单来说，就是黑客把他的JSESSIONID直接给你，你一旦使用这个ID登录，那么在后端这个ID就被认定为已登录状态，那么也就等同于他直接进入了已登录状态，从而直接访问你账号的任意内容，执行任意操作。\",\"攻击者通常使用以下几种方式进行会话固定攻击：\",\"会话传递：攻击者通过URL参数、表单隐藏字段、cookie等方式将会话ID传递给用户。当用户使用该会话ID登录时，攻击者就能利用该会话ID获取用户的权限。\",\"会话劫持：攻击者利用劫持用户与服务器之间的通信流量，获取到用户的会话ID，然后利用该会话ID冒充用户进行操作。\",\"会话劫持：攻击者事先获取到会话ID，并将其分配给用户，之后通过其他方式欺骗用户登录该会话。这样，攻击者就可以利用会话ID获取用户的权限。\",\"这里我们来尝试一下第一种方案，这里我们首先用另一个浏览器访问目标网站，此时需要登录，开始之前记得先清理一下两个浏览器的缓存，否则可能无法生效：\",\"alt text\",\"这里我们直接记录下这个JSESSIONID，然后将其编写到我们的诈骗网站中，这里有一个恶意脚本，会自动将对应用户的Cookie进行替换，变成我们的JSESSIONID值：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>冠希哥全套视频</title> <script src=\\\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\\\"></script> </head> <body> <script> //第三方网站恶意脚本，自动修改Cookie信息 document.cookie = \\\"JSESSIONID=6AAF677EC2B630704A80D36311F08E01; path=/mvc; domain=localhost\\\" //然后给你弄到原来的网站 location.href = 'http://localhost:8080/mvc/' </script> </body> </html> \",\"接着我们访问这个恶意网站，然后再作为用户，去正常访问目标网站进行登录操作\",\"可以看到此时用户的浏览器JSESSIONID值为刚刚恶意网站伪造的值，现在我们来进行登录操作\",\"此时我们回到一开始的浏览器，刷新之后，我们发现这个浏览器同样已经登录成功了，原理其实很简单，相当于让用户直接帮我们登录了，是不是感觉特别危险？\",\"当然，现在的浏览器同样有着对应的保护机制，Tomcat发送的SESSIONID默认是勾选了HttpOnly选项的，一旦被设定是无法被随意修改的\",\"当然前提是先得正常访问一次网站才行，否则仍然存在安全隐患。\",\"HttpOnly是Cookie中一个属性，用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HttpOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。\",\"alt text\",\"为了彻底杜绝这个问题，登录成功之后应该重新给用户分配一个新的JSESSIONID才行，而这些都由SpringSecurity帮我们实现了。\"]},\"643\":{\"h\":\"XSS跨站脚本攻击\",\"t\":[\"前面我们介绍了两种攻击方式，不过都是从外部干涉，在外部无法干涉的情况下\",\"我们也可以从内部击溃网站，接下来我们隆重介绍XSS跨站脚本攻击方式。\",\"XSS（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在合法网站中注入恶意脚本代码来攻击用户。\",\"当用户访问受到注入攻击的页面时，恶意代码会在用户的浏览器中执行，从而导致攻击者能够窃取用户的敏感信息、诱导用户操作、甚至控制用户的账号。\",\"XSS攻击常见的方式有三种：\",\"存储型XSS攻击：攻击者将恶意代码存储到目标网站的数据库中，当其他用户访问包含恶意代码的页面时，恶意代码会被执行。\",\"反射型XSS攻击：攻击者将恶意代码嵌入到URL中，当用户点击包含恶意代码的URL时，恶意代码会被执行。\",\"DOM-based XSS攻击：攻击者利用前端JavaScript代码的漏洞，通过修改页面的DOM结构来执行恶意代码。\",\"在一些社交网站上，用户可以自由发帖，而帖子是以富文本形式进行编辑和上传的，发送给后台的帖子往往是直接以HTML代码的形式，这个时候就会给黑客可乘之机了。\",\"正常情况下，用户发帖会向后端上传以下内容，这些是经过转换得到的正常HTML代码，方便后续直接展示：\",\"<div class=\\\"content ql-editor\\\"> <p> <strong>萨达睡觉了大数据</strong> </p> <p>撒大大撒大声地</p> </div> \",\"而现在，黑客不走常规的方式发帖，而是发送以下内容给服务端：\",\"<div class=\\\"content ql-editor\\\"> <p οnlοad=\\\"alert('xss')\\\"> <strong>萨达睡觉了大数据</strong> </p> <p>撒大大撒大声地</p> </div> \",\"可以看到p标签上添加了一段JS恶意脚本，黑客可以利用这种特性，获取用户的各种信息，甚至直接发送到他的后台，这样，我们的个人信息就从网站内部被泄露了。\",\"XSS漏洞最早被发现是在1996年，由于JavaScript的出现，导致在Web应用程序中存在了一些安全问题。\",\"在1997年，高智文(Gareth Owen)也就是“XSS之父”，在他的博客中描述了一种称为“脚本注入”(script injection)的攻击技术，这就是XSS漏洞的前身。从那时起，XSS漏洞便成为了Web应用程序中的一种常见安全漏洞。\",\"alt text\",\"这种攻击一般需要前端配合后端进行防御，或者后端对前端发送的内容进行安全扫描并处理，有机会我们会分享如何防范此类攻击。\"]},\"644\":{\"c\":[\"code\"]},\"645\":{\"c\":[\"javassm\",\"Spring\"]},\"646\":{\"h\":\"Javassm - SpringSecurity3\"},\"647\":{\"h\":\"SpringSecurity3\"},\"648\":{\"h\":\"SpringSecurity 环境配置\"},\"649\":{\"h\":\"模块导入\",\"t\":[\"我们继续使用之前的测试项目进行教学，首先我们需要导入SpringSecurity的相关依赖\",\"它不仅仅是一个模块，我们可以根据需求导入需要的模块，常用的是以下两个：\",\"<dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-web</artifactId> <version>6.1.1</version> </dependency> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-config</artifactId> <version>6.1.1</version> </dependency> \"]},\"650\":{\"h\":\"初始化器配置\",\"t\":[\"接着我们需要配置SpringSecurity，与Mvc一样，需要一个初始化器：\",\"public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { //不用重写任何内容 //这里实际上会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的，我们之后再探讨 } \"]},\"651\":{\"h\":\"配置类\",\"t\":[\"接着我们需要再创建一个配置类用于配置SpringSecurity：\",\"@Configuration @EnableWebSecurity //开启WebSecurity相关功能 public class SecurityConfiguration { } \"]},\"652\":{\"h\":\"添加配置类\",\"t\":[\"接着在根容器中添加此配置文件即可：\",\"@Override protected Class<?>[] getRootConfigClasses() { return new Class[]{MainConfiguration.class, SecurityConfiguration.class}; } \",\"这样，SpringSecurity的配置就完成了，我们再次运行项目，会发现无法进入的我们的页面中，无论我们访问哪个页面，都会进入到SpringSecurity为我们提供的一个默认登录页面，之后我们会讲解如何进行配置。\",\"alt text\",\"至此，项目环境搭建完成。\"]},\"653\":{\"c\":[\"code\"]},\"654\":{\"c\":[\"javassm\",\"Spring\"]},\"655\":{\"h\":\"Javassm - SpringSecurity4\"},\"656\":{\"h\":\"认证\",\"t\":[\"认证是我们网站的第一步，用户需要登录之后才能进入\",\"这一部分我们将详细介绍如何使用SpringSecurity实现用户登录。\"]},\"657\":{\"h\":\"基于内存验证\",\"t\":[\"首先我们来看看最简单的基于内存的配置，也就是说我们直接以代码的形式配置我们网站的用户和密码\"]},\"658\":{\"h\":\"\",\"t\":[\"配置方式非常简单，只需要在Security配置类中注册一个Bean即可：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { @Bean //UserDetailsService就是获取用户信息的服务 public UserDetailsService userDetailsService() { //每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色 UserDetails user = User.withDefaultPasswordEncoder() .username(\\\"user\\\") .password(\\\"password\\\") .roles(\\\"USER\\\") //角色目前我们不需要关心，随便写就行，后面会专门讲解 .build(); UserDetails admin = User.withDefaultPasswordEncoder() .username(\\\"admin\\\") .password(\\\"password\\\") .roles(\\\"ADMIN\\\", \\\"USER\\\") .build(); return new InMemoryUserDetailsManager(user, admin); //创建一个基于内存的用户信息管理器作为UserDetailsService } } \",\"配置完成后，我们就可以前往登录界面，进行登录操作了\",\"登录成功后，就可以访问到我们之前的界面了\",\"并且为了防止我们之前提到的会话固定问题，在登录之后，JSESSIONID会得到重新分配\",\"当我们想要退出时，也可以直接访问：http://localhost:8080/mvc/logout 地址，我们会进入到一个退出登录界面：\",\"alt text\",\"退出登录后就需要重新登录才能访问我们的网站了。\",\"可以发现，在有了SpringSecurity之后，我们网站的登录验证模块相当于直接被接管了，因此，从现在开始，我们的网站不需要再自己编写登录模块了，这里我们可以直接去掉，只留下主页面：\",\"@Controller public class HelloController { //现在所有接口不需要任何验证了，因为Security已经帮我们做了，没登录是根本进不来的 @GetMapping(\\\"/\\\") public String index(){ return \\\"index\\\"; } @ResponseBody @PostMapping(\\\"/pay\\\") public JSONObject pay(@RequestParam String account){ JSONObject object = new JSONObject(); System.out.println(\\\"转账给\\\"+account+\\\"成功，交易已完成！\\\"); object.put(\\\"success\\\", true); return object; } } \",\"这样，我们的网站就成功用上了更加安全的SpringSecurity框架了。\"]},\"659\":{\"h\":\"加密工具\",\"t\":[\"我们在配置用户信息的时候，报了黄标，实际上这种方式存储密码并不安全：\",\"这是因为SpringSecurity的密码校验不推荐直接使用原文进行比较，而是使用加密算法将密码进行加密（更准确地说应该进行Hash处理，此过程是不可逆的，无法解密），最后将用户提供的密码以同样的方式加密后与密文进行比较。\",\"对于我们来说，用户提供的密码属于隐私信息，直接明文存储并不好，而且如果数据库内容被窃取，那么所有用户的密码将全部泄露，这是我们不希望看到的结果，\",\"我们需要一种既能隐藏用户密码也能完成认证的机制，而Hash处理就是一种很好的解决方案，通过将用户的密码进行Hash值计算，计算出来的结果一般是单向的，无法还原为原文，如果需要验证是否与此密码一致，那么需要以同样的方式加密再比较两个Hash值是否一致，这样就很好的保证了用户密码的安全性。\",\"因此，我们在配置用户信息的时候，可以使用官方提供的BCrypt加密工具：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { //这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Bean public UserDetailsService userDetailsService(PasswordEncoder encoder) { UserDetails user = User .withUsername(\\\"user\\\") .password(encoder.encode(\\\"password\\\")) //这里将密码进行加密后存储 .roles(\\\"USER\\\") .build(); System.out.println(encoder.encode(\\\"password\\\")); //一会观察一下加密出来之后的密码长啥样 UserDetails admin = User .withUsername(\\\"admin\\\") .password(encoder.encode(\\\"password\\\")) //这里将密码进行加密后存储 .roles(\\\"ADMIN\\\", \\\"USER\\\") .build(); return new InMemoryUserDetailsManager(user, admin); } } \",\"这样，我们存储的密码就是更加安全的密码了：\",\"alt text\",\"alt text\"]},\"660\":{\"h\":\"403 权限问题\",\"t\":[\"不过，可能会有小伙伴发现，所有的POST请求都被403了：\",\"image-20230702183040922\",\"这是因为SpringSecurity自带了csrf防护，需求我们在POST请求中携带页面中的csrfToken才可以，否则一律进行拦截操作，这里我们可以将其嵌入到页面中，随便找一个地方添加以下内容：\",\"<input type=\\\"text\\\" th:id=\\\"${_csrf.getParameterName()}\\\" th:value=\\\"${_csrf.token}\\\" hidden> \",\"接着在axios发起请求时，携带这个input的value值：\",\"function pay() { const account = document.getElementById(\\\"account\\\").value const csrf = document.getElementById(\\\"_csrf\\\").value axios.post('/mvc/pay', { account: account, _csrf: csrf //携带此信息即可，否则会被拦截 }, { ... \",\"如果后续各位小伙伴遇到那种需要再form表单中提交的情况，也可以直接像下面这样给塞到表单里：\",\"<form action=\\\"/xxxx\\\" method=\\\"post\\\"> ... <input type=\\\"text\\\" th:name=\\\"${_csrf.getParameterName()}\\\" th:value=\\\"${_csrf.token}\\\" hidden> ... </form> \",\"实际上现在的浏览器已经很安全了，完全不需要使用自带的csrf防护，后面我们会讲解如何通过配置关闭csrf防护。这里温馨提醒一下，在后续各位小伙伴跟我们的实战项目时，如果遇到诸如401、403这种错误时，优先查看你的SpringSecurity配置是否错误。\",\"从Spring Security 4.0开始，默认情况下会启用CSRF保护，以防止CSRF攻击应用程序，Spring Security CSRF会针对PATCH，POST，PUT和DELETE方法的请求（不仅仅只是登陆请求，这里指的是任何请求路径）进行防护，而这里的登陆表单正好是一个POST类型的请求。在默认配置下，无论是否登陆，页面中只要发起了PATCH，POST，PUT和DELETE请求一定会被拒绝，并返回403错误**（注意，这里是个究极大坑，这个没有任何提示，直接403，因此如果你不知道的话根本不清楚是什么问题，就一直卡这里了）**，需要在请求的时候加入csrfToken才行，也就是\\\"83421936-b84b-44e3-be47-58bb2c14571a\\\"，正是csrfToken，如果提交的是表单类型的数据，那么表单中必须包含此Token字符串，键名称为\\\"_csrf\\\"；如果是JSON数据格式发送的，那么就需要在请求头中包含此Token字符串。\"]},\"661\":{\"h\":\"基于数据库验证\",\"t\":[\"前面我们已经实现了直接认证的方式，但是实际项目中往往都是将用户信息存储在数据库中，那么如何将其连接到数据库，通过查询数据库中的用户信息来进行用户登录呢？\"]},\"662\":{\"h\":\"建立数据库\",\"t\":[\"官方默认提供了可以直接使用的用户和权限表设计，根本不需要我们来建表，直接在Navicat中执行以下查询：\",\"create table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null); create table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username)); create unique index ix_auth_username on authorities (username,authority); \"]},\"663\":{\"h\":\"添加依赖\",\"t\":[\"接着我们添加Mybatis和MySQL相关的依赖：\",\"<dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.13</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>3.0.2</version> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>8.0.31</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>6.0.10</version> </dependency> \"]},\"664\":{\"h\":\"配置类\",\"t\":[\"接着我们编写配置类：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Bean public DataSource dataSource(){ //数据源配置 return new PooledDataSource(\\\"com.mysql.cj.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/test\\\", \\\"root\\\", \\\"123456\\\"); } @Bean public UserDetailsManager userDetailsService( DataSource dataSource, PasswordEncoder encoder ) { JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource); //仅首次启动时创建一个新的用户用于测试，后续无需创建 manager.createUser(User.withUsername(\\\"user\\\") .password(encoder.encode(\\\"password\\\")).roles(\\\"USER\\\").build()); return manager; } } \",\"启动后，可以看到两张表中已经自动添加好对应的数据了：\",\"alt text\",\"alt text\",\"我们可以直接尝试进行登录，使用方式和之前是完全一样的\",\"这样，当我们下次需要快速创建一个用户登录的应用程序时，直接使用这种方式就能快速完成了，是不是感觉特别方便。\"]},\"665\":{\"h\":\"接口\",\"t\":[\"无论是我们上节课认识的InMemoryUserDetailsManager还是现在认识的JdbcUserDetailsManager，他们都是实现自UserDetailsManager接口\",\"这个接口中有着一套完整的增删改查操作，方便我们直接对用户进行处理：\",\"public interface UserDetailsManager extends UserDetailsService { //创建一个新的用户 void createUser(UserDetails user); //更新用户信息 void updateUser(UserDetails user); //删除用户 void deleteUser(String username); //修改用户密码 void changePassword(String oldPassword, String newPassword); //判断是否存在指定用户 boolean userExists(String username); } \",\"通过使用UserDetailsManager对象，我们就能快速执行用户相关的管理操作\"]},\"666\":{\"h\":\"简单重置密码接口\",\"t\":[\"比如我们可以直接在网站上添加一个快速重置密码的接口，首先需要配置一下JdbcUserDetailsManager，为其添加一个AuthenticationManager用于原密码的校验：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { ... //手动创建一个AuthenticationManager用于处理密码校验 private AuthenticationManager getAuthenticationManager( UserDetailsManager manager, PasswordEncoder encoder ){ DaoAuthenticationProvider provider = new DaoAuthenticationProvider(); provider.setUserDetailsService(manager); provider.setPasswordEncoder(encoder); return new ProviderManager(provider); } @Bean public UserDetailsManager userDetailsService( DataSource dataSource, PasswordEncoder encoder ) { JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource); manager.setAuthenticationManager(getAuthenticationManager(manager, encoder)); return manager; } } \",\"接着我们编写一个快速重置密码的接口：\",\"@ResponseBody @PostMapping(\\\"/change-password\\\") public JSONObject changePassword(@RequestParam String oldPassword, @RequestParam String newPassword) { manager.changePassword(oldPassword, encoder.encode(newPassword)); JSONObject object = new JSONObject(); object.put(\\\"success\\\", true); return object; } \",\"接着我们在主界面中添加一个重置密码的操作：\",\"<div> <label> 修改密码： <input type=\\\"text\\\" id=\\\"oldPassword\\\" placeholder=\\\"旧密码\\\"/> <input type=\\\"text\\\" id=\\\"newPassword\\\" placeholder=\\\"新密码\\\"/> </label> <button onclick=\\\"change()\\\">修改密码</button> </div> \",\"function change() { const oldPassword = document.getElementById(\\\"oldPassword\\\").value const newPassword = document.getElementById(\\\"newPassword\\\").value const csrf = document.getElementById(\\\"_csrf\\\").value axios.post('/mvc/change-password', { oldPassword: oldPassword, newPassword: newPassword, _csrf: csrf }, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }).then(({data}) => { alert(data.success ? \\\"密码修改成功\\\" : \\\"密码修改失败，请检查原密码是否正确\\\") }) } \",\"这样我们就可以在首页进行修改密码操作了\",\"当然，这种方式的权限校验虽然能够直接使用数据库，但是存在一定的局限性，只适合快速搭建Demo使用，不适合实际生产环境下编写\"]},\"667\":{\"h\":\"自定义验证\",\"t\":[\"有些时候，我们的数据库可能并不会像SpringSecurity默认的那样进行设计，而是采用自定义的表结构，这种情况下，上面两种方式就很难进行验证了，此时我们得编写自定义验证，来应对各种任意变化的情况。\",\"既然需要自定义，那么我们就需要自行实现UserDetailsService或是功能更完善的UserDetailsManager接口\"]},\"668\":{\"h\":\"自行实现 接口\",\"t\":[\"public interface UserDetailsService { UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; } \",\"这里为了简单，我们直接选择前者进行实现：\",\"@Service public class AuthorizeService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { return null; } } \",\"只需要去实现这个loadUserByUsername方法，表示在验证的时候通过自定义的方式，根据给定的用户名查询用户，并封装为UserDetails对象返回\",\"然后由SpringSecurity将我们返回的对象与用户登录的信息进行核验，基本流程实际上跟之前是一样的，只是现在由我们自己来提供用户查询方式。\",\"只需要将其注册为 Bean 即可\",\"现在我们在数据库中创建一个自定义的用户表\"]},\"669\":{\"h\":\"构建实体类\",\"t\":[\"接着我们自行编写对应的查询操作，首先创建一个对应的实体类：\",\"@Data public class Account { int id; String username; String password; } \"]},\"670\":{\"h\":\"构建对应 接口\",\"t\":[\"然后是根据用户名查询用户的Mapper接口：\",\"public interface UserMapper { @Select(\\\"select * from user where username = #{username}\\\") Account findUserByName(String username); } \"]},\"671\":{\"h\":\"注册对应包扫描\",\"t\":[\"最后我们在配置类上添加相应的包扫描，同时也需要对应的 SqlSessionFactory\",\"@EnableWebMvc @Configuration @ComponentScans({ @ComponentScan(\\\"com.example.controller\\\"), @ComponentScan(\\\"com.example.service\\\") }) @MapperScan(\\\"com.example.mapper\\\") public class WebConfiguration implements WebMvcConfigurer { ... } \",\"@Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean; } \"]},\"672\":{\"h\":\"端进行查询\",\"t\":[\"然后我们来到Service这边进行一下完善，从数据库中进行查询：\",\"@Service public class AuthorizeService implements UserDetailsService { @Resource UserMapper mapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Account account = mapper.findUserByName(username); if(account == null) throw new UsernameNotFoundException(\\\"用户名或密码错误\\\"); return User .withUsername(username) .password(account.getPassword()) .build(); } } \",\"这样，我们就通过自定义的方式实现了数据库信息查询，并完成用户登录操作。\"]},\"673\":{\"c\":[\"code\"]},\"674\":{\"c\":[\"javassm\",\"Spring\"]},\"675\":{\"h\":\"Javassm - SpringSecurity5\"},\"676\":{\"h\":\"其他配置\",\"t\":[\"在实际开发场景中，我们还会面对各种各样的需求，这一部分我们接着来进行更加深层次的配置。\"]},\"677\":{\"h\":\"自定义登录界面\",\"t\":[\"虽然SpringSecurity为我们提供了一个还行的登录界面，但是很多情况下往往都是我们使用自定义的登录界面，这个时候就需要进行更多的配置了\",\"下载好模版后，我们将其中的两个页面和资源文件放到类路径下\"]},\"678\":{\"h\":\"注册静态资源\",\"t\":[\"@Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\\\"/static/**\\\").addResourceLocations(\\\"classpath:/static/\\\"); } \"]},\"679\":{\"h\":\"添加路径匹配\",\"t\":[\"接着我们配置对应页面的Controller控制器：\",\"@Controller public class HelloController { @GetMapping(\\\"/\\\") public String index(){ return \\\"index\\\"; } @GetMapping(\\\"/login\\\") public String login(){ return \\\"login\\\"; } } \",\"这样，我们在登录之后，就可以展示前端模版页面了\",\"不过现在依然是默认进入到SpringSecurity默认的登录界面\"]},\"680\":{\"h\":\"自定义登录设置 +\",\"t\":[\"现在我们来配置自定义的登录界面，将我们的前端模版中的登录页面作为SpringSecurity的默认登录界面。\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { ... //如果你学习过SpringSecurity 5.X版本，可能会发现新版本的配置方式完全不一样 //新版本全部采用lambda形式进行配置，无法再使用之前的and()方法进行连接了 @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http //以下是验证请求拦截和放行配置 .authorizeHttpRequests(auth -> { auth.anyRequest().authenticated(); //将所有请求全部拦截，一律需要验证 }) //以下是表单登录相关配置 .formLogin(conf -> { conf.loginPage(\\\"/login\\\"); //将登录页设置为我们自己的登录页面 conf.loginProcessingUrl(\\\"/doLogin\\\"); //登录表单提交的地址，可以自定义 conf.defaultSuccessUrl(\\\"/\\\"); //登录成功后跳转的页面 conf.permitAll(); //将登录相关的地址放行，否则未登录的用户连登录界面都进不去 //用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求 conf.usernameParameter(\\\"username\\\"); conf.passwordParameter(\\\"password\\\"); }) .build(); } } \",\"需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为/login，登陆请求地址为/doLogin，登陆页面我们刚刚已经自己编写Controller来实现了，登陆请求提交处理由SpringSecurity提供，只需要写路径就可以了。现在访问我们的网站，就可以进入到自定义的登录界面了\"]},\"681\":{\"h\":\"静态资源权限处理\",\"t\":[\"但是我们发现，我们的页面只有一个纯文本，这是因为在获取静态资源的时候，所有的静态资源默认情况下也会被拦截，因此全部被302重定向到登录页面，这显然是不对的\",\"因此，现在我们需要将所有的静态资源也给放行，否则登录界面都没法正常展示：\",\".authorizeHttpRequests(auth -> { auth.requestMatchers(\\\"/static/**\\\").permitAll(); //将所有的静态资源放行，一定要添加在全部请求拦截之前 auth.anyRequest().authenticated(); //将所有请求全部拦截，一律需要验证 }) \",\"再次访问我们的网站，就可以看到正常显示的登录界面了\",\"因此，如果各位小伙伴后续在编写项目过程中发现有302的情况，一定要先检查是否因为没有放行导致被SpringSecurity给拦截了，别再遇到302一脸懵逼了。\"]},\"682\":{\"h\":\"前端登录设置\",\"t\":[\"接着我们来配置登录操作，这里我们只需要配置一下登录的地址和登录按钮即可，当然，跟之前一样，要把CSRF的输入框也加上：\",\"<form action=\\\"doLogin\\\" method=\\\"post\\\"> ... <input type=\\\"text\\\" name=\\\"username\\\" placeholder=\\\"Email Address\\\" class=\\\"ad-input\\\"> ... <input type=\\\"password\\\" name=\\\"password\\\" placeholder=\\\"Password\\\" class=\\\"ad-input\\\"> ... <input type=\\\"text\\\" th:name=\\\"${_csrf.getParameterName()}\\\" th:value=\\\"${_csrf.token}\\\" hidden> <div class=\\\"ad-auth-btn\\\"> <button type=\\\"submit\\\" class=\\\"ad-btn ad-login-member\\\">Login</button> </div> ... </form> \",\"接着我们就可以尝试进行登录操作了。\"]},\"683\":{\"h\":\"退出登录操作配置\",\"t\":[\"退出登录也是同样的操作，我们只需要稍微进行一下配置就可以实现，我们首先继续完善配置类：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { ... @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http ... //以下是退出登录相关配置 .logout(conf -> { conf.logoutUrl(\\\"/doLogout\\\"); //退出登录地址，跟上面一样可自定义 conf.logoutSuccessUrl(\\\"/login\\\"); //退出登录成功后跳转的地址，这里设置为登录界面 conf.permitAll(); }) .build(); } } \",\"接着我们来稍微魔改一下页面中的退出登录按钮：\",\"<li> <form action=\\\"doLogout\\\" method=\\\"post\\\"> <input type=\\\"text\\\" th:name=\\\"${_csrf.getParameterName()}\\\" th:value=\\\"${_csrf.token}\\\" hidden> <button type=\\\"submit\\\"> <i class=\\\"fas fa-sign-out-alt\\\"></i> logout </button> </form> </li> \",\"现在我们点击右上角的退出按钮就可以退出了\"]},\"684\":{\"h\":\"取消 校验\",\"t\":[\"不过，可能会有小伙伴觉得，我们现在无论提交什么请求都需要Csrf校验，有些太麻烦了，实际上现在浏览器已经很安全了，没必要防御到这种程度，我们也可以直接在配置中关闭csrf校验：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { ... @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http ... //以下是csrf相关配置 .csrf(conf -> { conf.disable(); //此方法可以直接关闭全部的csrf校验，一步到位 conf.ignoringRequestMatchers(\\\"/xxx/**\\\"); //此方法可以根据情况忽略某些地址的csrf校验 }) .build(); } } \",\"这样，我们就不需要再往页面中嵌入CSRF相关的输入框了，发送请求时也不会进行校验，至此，我们就完成了简单的自定义登录界面配置。\"]},\"685\":{\"h\":\"记住我功能\",\"t\":[\"我们的网站还有一个重要的功能，就是记住我，也就是说我们可以在登陆之后的一段时间内，无需再次输入账号和密码进行登陆\",\"相当于服务端已经记住当前用户，再次访问时就可以免登陆进入，这是一个非常常用的功能。\",\"我们之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦，那么能否有一种更加高效的记住我功能实现呢？\"]},\"686\":{\"h\":\"\",\"t\":[\"SpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。\",\"我们需要进行简单配置，即可开启记住我功能：\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration { ... @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http ... .rememberMe(conf -> { conf.alwaysRemember(false); //这里不要开启始终记住，我们需要配置为用户自行勾选 conf.rememberMeParameter(\\\"remember-me\\\"); //记住我表单字段，默认就是这个，可以不配置 conf.rememberMeCookieName(\\\"xxxx\\\"); //记住我设置的Cookie名字，也可以自定义，不过没必要 }) .build(); } } \",\"配置完成后，我们需要修改一下前端页面中的表单，将记住我勾选框也作为表单的一部分进行提交：\",\"<div class=\\\"ad-checkbox\\\"> <label> <input type=\\\"checkbox\\\" name=\\\"remember-me\\\" class=\\\"ad-checkbox\\\"> <span>Remember Me</span> </label> </div> \",\"接着我们来尝试勾选记住我选项进行登录：\",\"alt text\",\"此时提交的表单中就已经包含记住我字段了，我们会发现，服务端返回给我们了一个记住我专属的Cookie信息：\",\"alt text\",\"这个Cookie信息的过期时间并不是仅会话，而是默认保存一段时间\",\"因此，我们关闭浏览器后下次再次访问网站时，就不需要我们再次进行登录操作了，而是直接继续上一次的登录状态。\",\"当然，由于记住我信息是存放在内存中的，我们需要保证服务器一直处于运行状态\",\"如果关闭服务器的话，记住我信息会全部丢失，因此，如果我们希望记住我能够一直持久化保存，我们就需要进一步进行配置。\"]},\"687\":{\"h\":\"+\",\"t\":[\"我们需要创建一个基于JDBC的TokenRepository实现：\",\"@Bean public PersistentTokenRepository tokenRepository(DataSource dataSource){ JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl(); //在启动时自动在数据库中创建存储记住我信息的表，仅第一次需要，后续不需要 repository.setCreateTableOnStartup(true); repository.setDataSource(dataSource); return repository; } \",\"然后添加此仓库：\",\".rememberMe(conf -> { conf.rememberMeParameter(\\\"remember-me\\\"); conf.tokenRepository(repository); //设置刚刚的记住我持久化存储库 conf.tokenValiditySeconds(3600 * 7); //设置记住我有效时间为7天 }) \",\"这样，我们就成功配置了数据库持久化存储记住我信息，即使我们重启服务器也不会导致数据丢失。\",\"当我们登录之后，数据库中会自动记录相关的信息：\",\"image-20230704220701000\",\"这样，我们网站的登录系统就更加完善了。\"]},\"688\":{\"c\":[\"code\"]},\"689\":{\"c\":[\"javassm\",\"Spring\"]},\"690\":{\"h\":\"Javassm - SpringSecurity6\"},\"691\":{\"h\":\"授权\",\"t\":[\"用户登录后，可能会根据用户当前是身份进行角色划分，比如我们最常用的QQ，一个QQ群里面，有群主、管理员和普通群成员三种角色\",\"其中群主具有最高权限，群主可以管理整个群的任何板块，并且具有解散和升级群的资格，而管理员只有群主的一部分权限，只能用于日常管理，普通群成员则只能进行最基本的聊天操作。\",\"对于我们来说，用户的一个操作实际上就是在访问我们提供的接口 (编写的对应访问路径的Servlet)\",\"比如登陆，就需要调用/login接口，退出登陆就要调用/logout接口，而我们之前的图书管理系统中，新增图书、删除图书，所有的操作都有着对应的Servlet来进行处理。\",\"因此，从我们开发者的角度来说，决定用户能否使用某个功能，只需要决定用户是否能够访问对应的Servlet即可。\",\"我们可以大致像下面这样进行划分：\",\"群主：/login、/logout、/chat、/edit、/delete、/upgrade\",\"管理员：/login、/logout、/chat、/edit\",\"普通群成员：/login、/logout、/chat\",\"也就是说，我们需要做的就是指定哪些请求可以由哪些用户发起。\",\"SpringSecurity为我们提供了两种授权方式：\",\"基于权限的授权：只要拥有某权限的用户，就可以访问某个路径。\",\"基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径。\",\"两者只是概念上的不同，实际上使用起来效果差不多。这里我们就先演示以角色方式来进行授权。\"]},\"692\":{\"h\":\"基于角色授权\",\"t\":[\"现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。\",\"首先我们需要对数据库中的角色表进行一些修改，添加一个用户角色字段，并创建一个新的用户，Test用户的角色为user，而Admin用户的角色为admin。\",\"接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：\",\".authorizeHttpRequests(auth -> { //静态资源依然全部可以访问 auth.requestMatchers(\\\"/static/**\\\").permitAll(); //只有具有以下角色的用户才能访问路径\\\"/\\\" auth.requestMatchers(\\\"/\\\").hasAnyRole(\\\"user\\\", \\\"admin\\\"); //其他所有路径必须角色为admin才能访问 auth.anyRequest().hasRole(\\\"admin\\\"); }) \",\"接着我们需要稍微修改一下验证逻辑，我们在数据库中的用户表上添加一个新的字段，用于表示角色：\",\"image-20230704222733082\",\"修改一下对应的实体类：\",\"@Data public class Account { int id; String username; String password; String role; } \",\"现在我们在查询用户时，需要添加其对应的角色：\",\" @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Account account = mapper.findUserByName(username); if(account == null) throw new UsernameNotFoundException(\\\"用户名或密码错误\\\"); return User .withUsername(username) .password(account.getPassword()) .roles(account.getRole()) //添加角色，一个用户可以有一个或多个角色 .build(); } \",\"这样就可以了，我们重启服务器登录看看：\",\"image-20230703182321093\",\"目前依然是可以正常登录的，但是我们随便访问一个其他的页面，就会被拦截并自动退回到登录界面：\",\"image-20230704223248124\",\"这是因为我们前面配置的是user角色，那么这个角色只能访问首页，其他的都不行，所以就会被自动拦截掉了。现在我们可以到数据库中对这个用户的角色进行修改，看看修改后是否能够访问到其他页面：\",\"image-20230704223503682\",\"这样就可以访问其他页面不会被拦截了，不过因为我们没配置这个路径，所以出来的是404页面。\",\"通过使用角色控制页面的访问，我们就可以让某些用户只能访问部分页面。\"]},\"693\":{\"h\":\"基于权限授权\",\"t\":[\"基于权限的授权与角色类似，需要以hasAnyAuthority或hasAuthority进行判断：\",\".authorizeHttpRequests(auth -> { //静态资源依然全部可以访问 auth.requestMatchers(\\\"/static/**\\\").permitAll(); //基于权限和基于角色其实差别并不大，使用方式是相同的 auth.anyRequest().hasAnyAuthority(\\\"page:index\\\"); }) \",\"实际上权限跟角色相比只是粒度更细，由于使用方式差不多，这里不多做阐述。\"]},\"694\":{\"h\":\"使用注解权限判断\"},\"695\":{\"h\":\"\",\"t\":[\"除了直接配置以外，我们还可以以注解形式直接配置\",\"首先需要在配置类(注意这里是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加)上开启：\",\"@Configuration @EnableWebSecurity @EnableMethodSecurity //开启方法安全校验 public class SecurityConfiguration { ... } \",\"现在我们就可以在我们想要进行权限校验的方法上添加注解了：\",\"@Controller public class HelloController { @PreAuthorize(\\\"hasRole('user')\\\") //直接使用hasRole方法判断是否包含某个角色 @GetMapping(\\\"/\\\") public String index(){ return \\\"index\\\"; } ... } \"]},\"696\":{\"h\":\"注解\",\"t\":[\"通过添加@PreAuthorize注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。\",\"这里其实是使用的就是我们之前讲解的SpEL表达式，我们可以直接在这里使用权限判断相关的方法。\",\"所有可以进行权限判断的方法在SecurityExpressionRoot类中有定义。\"]},\"697\":{\"h\":\"注解\",\"t\":[\"同样的还有@PostAuthorize注解，但是它是在方法执行之后再进行拦截：\",\"@PostAuthorize(\\\"hasRole('user')\\\") @RequestMapping(\\\"/\\\") public String index(){ System.out.println(\\\"执行了\\\"); return \\\"index\\\"; } \",\"除了Controller以外，只要是由Spring管理的Bean都可以使用注解形式来控制权限，我们可以在任意方法上添加这个注解\",\"只要不具备表达式中指定的访问权限，那么就无法执行方法并且会返回403页面。\",\"@Service public class UserService { @PreAuthorize(\\\"hasAnyRole('user')\\\") public void test(){ System.out.println(\\\"成功执行\\\"); } } \"]},\"698\":{\"h\":\"其它\",\"t\":[\"与具有相同功能的还有@Secured但是它不支持SpEL表达式的权限表示形式，并且需要添加\\\"ROLE_\\\"前缀，这里就不做演示了。\"]},\"699\":{\"h\":\"和 过滤\",\"t\":[\"我们还可以使用@PreFilter和@PostFilter对集合类型的参数或返回值进行过滤。\",\"比如：\",\"@PreFilter(\\\"filterObject.equals('lbwnb')\\\") //filterObject代表集合中每个元素，只要满足条件的元素才会留下 public void test(List<String> list){ System.out.println(\\\"成功执行\\\"+list); } \",\"@RequestMapping(\\\"/\\\") public String index(){ List<String> list = new LinkedList<>(); list.add(\\\"lbwnb\\\"); list.add(\\\"yyds\\\"); service.test(list); return \\\"index\\\"; } \",\"与@PreFilter类似的@PostFilter这里就不做演示了，它用于处理返回值，使用方法是一样的。\",\"当有多个集合时，需要使用filterTarget进行指定：\",\"@PreFilter(value = \\\"filterObject.equals('lbwnb')\\\", filterTarget = \\\"list2\\\") public void test(List<String> list, List<String> list2){ System.out.println(\\\"成功执行\\\"+list); } \",\"至此，有关Security的基本功能，我们就全部介绍完毕了，在后面的SpringBoot阶段，我们还会继续深入使用此框架，实现更多高级的功能。\"]},\"700\":{\"c\":[\"code\"]},\"701\":{\"c\":[\"javassm\",\"Spring\"]},\"702\":{\"h\":\"Javassm - SpringSecurity7\"},\"703\":{\"h\":\"内部机制探究\"},\"704\":{\"h\":\"授权校验流程\",\"t\":[\"SpringSecurity的实现原理本质上是依靠N个Filter实现的，也就是一个完整的过滤链（注意这里是过滤器，不是拦截器）\",\"主要关注各类对应的 init, doFilter\"]},\"705\":{\"h\":\"\",\"t\":[\"先从AbstractSecurityWebApplicationInitializer开始下手，也就是在 init 文件夹里的 SecurityInitializer 的父类\",\"我们来看看它配置了什么：\",\"//此方法会在启动时被调用 public final void onStartup(ServletContext servletContext) { this.beforeSpringSecurityFilterChain(servletContext); if (this.configurationClasses != null) { AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext(); rootAppContext.register(this.configurationClasses); servletContext.addListener(new ContextLoaderListener(rootAppContext)); } if (this.enableHttpSessionEventPublisher()) { servletContext.addListener(\\\"org.springframework.security.web.session.HttpSessionEventPublisher\\\"); } servletContext.setSessionTrackingModes(this.getSessionTrackingModes()); //重点在这里，这里插入了关键的FilterChain this.insertSpringSecurityFilterChain(servletContext); this.afterSpringSecurityFilterChain(servletContext); } \",\"然后转到 insertSpringSecurityFilterChain 实现\",\"private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = \\\"springSecurityFilterChain\\\"; //创建了一个DelegatingFilterProxy对象，它本质上也是一个Filter，但是是多个Filter的集合 DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(filterName); String contextAttribute = this.getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } //通过ServletContext注册DelegatingFilterProxy这个Filter this.registerFilter(servletContext, true, filterName, springSecurityFilterChain); } \",\"主要目的就是注册了一个 DelegatingFilterProxy, 它本质上也是一个Filter，但是是多个Filter的集合\"]},\"706\":{\"h\":\"\",\"t\":[\"我们接着来看看，DelegatingFilterProxy在做什么：\",\"// 这个是初始化方法，它由GenericFilterBean（父类）定义，在afterPropertiesSet方法中被调用 protected void initFilterBean() throws ServletException { synchronized(this.delegateMonitor) { if (this.delegate == null) { if (this.targetBeanName == null) { this.targetBeanName = this.getFilterName(); } WebApplicationContext wac = this.findWebApplicationContext(); if (wac != null) { //耐心点，套娃很正常 this.delegate = this.initDelegate(wac); } } } } \",\"protected Filter initDelegate(WebApplicationContext wac) throws ServletException { String targetBeanName = this.getTargetBeanName(); Assert.state(targetBeanName != null, \\\"No target bean name set\\\"); //这里通过WebApplicationContext获取了一个Bean Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class); if (this.isTargetFilterLifecycle()) { delegate.init(this.getFilterConfig()); } //返回Filter return delegate; } \",\"这里我们需要添加一个断点来查看到底获取到了什么Bean。\",\"通过断点调试，我们发现这里放回的对象是一个FilterChainProxy类型的，并且调用了它的初始化方法。\",\"我们倒回去看，当Filter返回之后，DelegatingFilterProxy的一个成员变量delegate被赋值为得到的Filter，也就是FilterChainProxy对象\",\"this.delegate = this.initDelegate(wac); \"]},\"707\":{\"h\":\"操作\",\"t\":[\"接着我们来看看，DelegatingFilterProxy是如何执行doFilter方法的。\",\"public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException { Filter delegateToUse = this.delegate; if (delegateToUse == null) { //非正常情况，这里省略... } //这里才是真正的调用，别忘了delegateToUse就是初始化的FilterChainProxy对象 this.invokeDelegate(delegateToUse, request, response, filterChain); } \",\"protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException { //最后实际上调用的是FilterChainProxy的doFilter方法 delegate.doFilter(request, response, filterChain); } \",\"实际上就相当于 DelegatingFilterProxy 的 doFilter 自己不实现功能，只是一个代理，真正是让 FilterChainProxy 类中的 doFilter 实现\"]},\"708\":{\"h\":\"\",\"t\":[\"alt text\",\"所以我们接着来看，FilterChainProxy的doFilter方法又在干什么：\",\"public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { boolean clearContext = request.getAttribute(FILTER_APPLIED) == null; if (!clearContext) { //真正的过滤在这里执行 this.doFilterInternal(request, response, chain); } else { //... } } \",\"private void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { FirewalledRequest firewallRequest = this.firewall.getFirewalledRequest((HttpServletRequest)request); HttpServletResponse firewallResponse = this.firewall.getFirewalledResponse((HttpServletResponse)response); // 这里获取了一个Filter列表，实际上SpringSecurity就是由N个过滤器实现的，这里获取的都是SpringSecurity提供的过滤器 // 但是请注意，经过我们之前的分析，实际上真正注册的Filter只有DelegatingFilterProxy // 而这里的Filter列表中的所有Filter并没有被注册，而是在这里进行内部调用 List<Filter> filters = this.getFilters((HttpServletRequest)firewallRequest); // 只要Filter列表不是空，就依次执行内置的Filter if (filters != null && filters.size() != 0) { if (logger.isDebugEnabled()) { logger.debug(LogMessage.of(() -> { return \\\"Securing \\\" + requestLine(firewallRequest); })); } // 这里创建一个虚拟的过滤链，过滤流程是由SpringSecurity自己实现的 (内部的类) // 以前的是直接用 FilterChainProxy.VirtualFilterChain 创建 // 现在绕了一下 FilterChain reset = (req, res) -> { if (logger.isDebugEnabled()) { logger.debug(LogMessage.of(() -> \\\"Secured \\\" + requestLine(firewallRequest))); } firewallRequest.reset(); chain.doFilter(req, res); }; this.filterChainDecorator.decorate(reset, filters).doFilter(firewallRequest, firewallResponse); } else { if (logger.isTraceEnabled()) { logger.trace(LogMessage.of(() -> { return \\\"No security for \\\" + requestLine(firewallRequest); })); } firewallRequest.reset(); chain.doFilter(firewallRequest, firewallResponse); } } \",\"这里的 List<Filter> filters 有很多, 实际上真正注册的Filter只有DelegatingFilterProxy，这里的Filter列表中的所有Filter并没有被注册，而是在这里进行内部调用： \",\"以前的源码是直接创建虚拟队列，然后就进行 doFilter 操作\",\"FilterChainProxy.VirtualFilterChain virtualFilterChain = new FilterChainProxy.VirtualFilterChain(firewallRequest, chain, filters); //调用虚拟过滤链的doFilter virtualFilterChain.doFilter(firewallRequest, firewallResponse); \",\"但现在改成这样：\",\"FilterChain reset = (req, res) -> { if (logger.isDebugEnabled()) { logger.debug(LogMessage.of(() -> \\\"Secured \\\" + requestLine(firewallRequest))); } firewallRequest.reset(); chain.doFilter(req, res); }; this.filterChainDecorator.decorate(reset, filters).doFilter(firewallRequest, firewallResponse); \",\"这个 FilterChain 是一个接口，只需要提供实现对应的 doFilter 方法\",\"public interface FilterChain { void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException; } \",\"先创建一个内联函数 reset，然后利用初始化时创建的 this.filterChainDecorator 来创建虚拟队列\"]},\"709\":{\"h\":\"\",\"t\":[\"在 FilterChainProxy 初始化时：\",\"... private FilterChainDecorator filterChainDecorator; public FilterChainProxy() { this.securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy(); this.filterChainValidator = new NullFilterChainValidator(); this.firewall = new StrictHttpFirewall(); this.requestRejectedHandler = new HttpStatusRequestRejectedHandler(); this.throwableAnalyzer = new ThrowableAnalyzer(); this.filterChainDecorator = new VirtualFilterChainDecorator(); } .... public static final class VirtualFilterChainDecorator implements FilterChainDecorator { public FilterChain decorate(FilterChain original) { return original; } public FilterChain decorate(FilterChain original, List<Filter> filters) { return new VirtualFilterChain(original, filters); } } \",\"这样创建了虚拟过滤器链 FilterChainProxy.VirtualFilterChain, 然后执行 doFilter\"]},\"710\":{\"h\":\"虚拟过滤器链\",\"t\":[\"我们来看一下虚拟过滤链的doFilter是怎么处理的：\",\"// 看似没有任何循环，实际上就是一个循环，是一个递归调用 public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { // 判断是否已经通过全部的内置过滤器，定位是否等于当前大小 if (this.currentPosition == this.size) { if (FilterChainProxy.logger.isDebugEnabled()) { FilterChainProxy.logger.debug(LogMessage.of(() -> { return \\\"Secured \\\" + FilterChainProxy.requestLine(this.firewalledRequest); })); } this.firewalledRequest.reset(); // 所有的内置过滤器已经完成，按照正常流程走DelegatingFilterProxy的下一个Filter // 也就是说这里之后就与DelegatingFilterProxy没有任何关系了，该走其他过滤器就走其他地方配置的过滤器，SpringSecurity的过滤操作已经结束 this.originalChain.doFilter(request, response); } else { // 定位自增 ++this.currentPosition; // 获取当前定位的Filter Filter nextFilter = (Filter)this.additionalFilters.get(this.currentPosition - 1); if (FilterChainProxy.logger.isTraceEnabled()) { FilterChainProxy.logger.trace(LogMessage.format(\\\"Invoking %s (%d/%d)\\\", nextFilter.getClass().getSimpleName(), this.currentPosition, this.size)); } // 执行内部过滤器的doFilter方法，传入当前对象本身作为Filter，执行如果成功，那么一定会再次调用当前对象的doFilter方法 // 可能最不理解的就是这里，执行的难道不是内部其他Filter的doFilter方法吗，怎么会让当前对象的doFilter方法递归调用呢？ // 没关系，下面我们接着了解了其中一个内部过滤器就明白了 nextFilter.doFilter(request, response, this); } } \",\"因此，我们差不多已经了解了整个SpringSecurity的实现机制了，那么我们来随便看一个内部的过滤器在做什么。\"]},\"711\":{\"h\":\"具体内部过滤器举例\",\"t\":[\"比如用于处理登陆的过滤器UsernamePasswordAuthenticationFilter，它继承自AbstractAuthenticationProcessingFilter\",\"我们来看看它是怎么进行过滤的：\",\"public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { this.doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain); } private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { // 如果不是登陆请求，那么根本不会理这个请求 if (!this.requiresAuthentication(request, response)) { // 直接调用传入的FilterChain的doFilter方法 // 而这里传入的正好是VirtualFilterChain对象 // 这下知道为什么上面说是递归了吧 chain.doFilter(request, response); } else { // 如果是登陆请求，那么会执行登陆请求的相关逻辑，注意执行过程中出现任何问题都会抛出异常 // 比如用户名和密码错误，我们之前也已经测试过了，会得到一个BadCredentialsException try { //进行认证 Authentication authenticationResult = this.attemptAuthentication(request, response); if (authenticationResult == null) { return; } this.sessionStrategy.onAuthentication(authenticationResult, request, response); if (this.continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } // 如果一路绿灯，没有报错，那么验证成功，执行successfulAuthentication this.successfulAuthentication(request, response, chain, authenticationResult); } catch (InternalAuthenticationServiceException var5) { this.logger.error(\\\"An internal error occurred while trying to authenticate the user.\\\", var5); // 验证失败，会执行unsuccessfulAuthentication this.unsuccessfulAuthentication(request, response, var5); } catch (AuthenticationException var6) { this.unsuccessfulAuthentication(request, response, var6); } } } \"]},\"712\":{\"h\":\"\",\"t\":[\"那么我们来看看successfulAuthentication和unsuccessfulAuthentication分别做了什么：\",\"protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException { //向SecurityContextHolder添加认证信息，我们可以通过SecurityContextHolder对象获取当前登陆的用户 SecurityContextHolder.getContext().setAuthentication(authResult); if (this.logger.isDebugEnabled()) { this.logger.debug(LogMessage.format(\\\"Set SecurityContextHolder to %s\\\", authResult)); } //记住我实现 this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); } //调用默认的或是我们自己定义的AuthenticationSuccessHandler的onAuthenticationSuccess方法 //这个根据我们配置文件决定 //到这里其实页面就已经直接跳转了 this.successHandler.onAuthenticationSuccess(request, response, authResult); } \"]},\"713\":{\"h\":\"\",\"t\":[\"protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException { //登陆失败会直接清理掉SecurityContextHolder中的认证信息 SecurityContextHolder.clearContext(); this.logger.trace(\\\"Failed to process authentication request\\\", failed); this.logger.trace(\\\"Cleared SecurityContextHolder\\\"); this.logger.trace(\\\"Handling authentication failure\\\"); //登陆失败的记住我处理 this.rememberMeServices.loginFail(request, response); //同上，调用默认或是我们自己定义的AuthenticationFailureHandler this.failureHandler.onAuthenticationFailure(request, response, failed); } \"]},\"714\":{\"h\":\"其他过滤器\",\"t\":[\"了解了整个用户验证实现流程，其实其它的过滤器是如何实现的也就很容易联想到了，SpringSecurity的过滤器从某种意义上来说，更像是一个处理业务的Servlet，它做的事情不像是拦截，更像是完成自己对应的职责，只不过是使用了过滤器机制进行实现罢了，从而将所有的验证提前到进入Controller之前。\",\"最后附上完整的过滤器清单，这里列出14个常见的内部过滤器：\",\"过滤器名称\",\"职责\",\"DisableEncodeUrlFilter\",\"禁止 HttpServletResponse 对 URL 进行编码，以防止在 URL 中包含 Session ID，此类 URL 不被视为 URL，因为会话 ID 可能会在 HTTP 访问日志等内容中泄露。\",\"WebAsyncManagerIntegrationFilter\",\"实现了对SecurityContext与WebAsyncManager的集成，使 Controller 中能够线程安全地获取到用户上下文认证信息。\",\"SecurityContextHolderFilter\",\"通过HttpSessionSecurityContextRepository接口从Session中读取SecurityContext或是直接创建新的，然后存入到SecurityContextHolder中，最后请求结束时会进行清理。\",\"HeaderWriterFilter\",\"给HTTP响应添加一些Header属性，如：X-Frame-Options、X-XSS-Protection、X-Content-Type-Options等。\",\"CsrfFilter\",\"针对Csrf相关校验。\",\"LogoutFilter\",\"对退出登录的请求进行处理，执行登出操作。\",\"UsernamePasswordAuthenticationFilter\",\"对登录的请求进行处理，执行登录操作。\",\"ConcurrentSessionFilter\",\"检查SessionRegistry保存的Session信息是否过期。\",\"RequestCacheAwareFilter\",\"缓存Request请求，可以用于恢复因登录而打断的请求。\",\"SecurityContextHolderAwareRequestFilter\",\"对ServletRequest进行进一步包装，让Request具有更加丰富的内容。\",\"RememberMeAuthenticationFilter\",\"针对于记住我Cookie进行校验。\",\"AnonymousAuthenticationFilter\",\"未验证成功的情况下进行匿名登录操作。\",\"SessionManagementFilter\",\"Session管理相关。\",\"ExceptionTranslationFilter\",\"异常转换处理，比如最常见的AccessDenied之类的。\"]},\"715\":{\"c\":[\"code\"]},\"716\":{\"c\":[\"javassm\",\"Spring\"]},\"717\":{\"h\":\"javaweb - Socket1\"},\"718\":{\"h\":\"Socket\",\"t\":[\"通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。\"]},\"719\":{\"h\":\"socket 连接示例\",\"t\":[\"//服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); //由于继承了Autocloseble 省略 socket.close() }catch (IOException e){ e.printStackTrace(); } } \",\"//客户端 public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ System.out.println(\\\"已连接到服务端！\\\"); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } \",\"实际上它就是一个TCP连接的建立过程：\",\"20250319235934\",\"一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } \"]},\"720\":{\"h\":\"使用Socket进行数据传输\",\"t\":[\"通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：\",\"注意：\",\"如果服务端是 Socket socket = server.accept(); 最后需要 socket.close 不然会报错\",\"如果接收端读取的是 reader.readLine(), 注意需要添加 \\\\n，writer.write(text+ \\\"\\\\n\\\");, writer不会主动加 \\\\n\",\"OutputStream 是把东西先到对应的流里 InputStream 是获取对应流的内容\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080) ){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.print(\\\"接收到客户端数据：\\\"); System.out.println(reader.readLine()); //向客户端发请求 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"receiver!\\\"); writer.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080); Scanner scanner = new Scanner(System.in); ){ System.out.println(\\\"已连接到服务端！\\\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); System.out.println(\\\"请输入要发送给服务端的内容：\\\"); String text = scanner.nextLine(); writer.write(text+ \\\"\\\\n\\\"); writer.flush(); System.out.println(\\\"数据已发送：\\\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\\\"收到服务器返回：\\\"+reader.readLine()); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"721\":{\"h\":\"杂项\",\"t\":[\"我们可以手动关闭单向的流：\",\"socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 \",\"如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间：\",\" socket.setSoTimeout(3000); \",\"当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：\",\" java.net.SocketTimeoutException: Read timed out \",\"我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接 connect 方法，调用无参构造方法不会自动连接。\",\"try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\\\"localhost\\\", 8080), 1000); //手动调用connect方法进行连接 } \",\"如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生：\",\"socket.setKeepAlive(true); \",\"当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。\",\"TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：\",\" socket.setReceiveBufferSize(25565); //TCP接收缓冲区 socket.setSendBufferSize(25565); //TCP发送缓冲区 \"]},\"722\":{\"c\":[\"code\"]},\"723\":{\"c\":[\"javaweb\"]},\"724\":{\"h\":\"javaweb - Socket2\"},\"725\":{\"h\":\"Socket2\"},\"726\":{\"h\":\"Socket 传输文件\",\"t\":[\"其实本质上都差不多，主要掌握几种流之间的操作，和 socket 的用法\",\"一般 xxxOutputStream 的操作是往对应的xxx流内写入一些东西；xxxInputStream 的操作是从对应的xxx流内获取一些东西。\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080); FileOutputStream fileOutputStream = new FileOutputStream(\\\"net/data.txt\\\"); ){ Socket socket = server.accept(); InputStream inputstream = socket.getInputStream(); byte[] bytes = new byte[1024]; int i; while((i = inputstream.read(bytes)) != -1){ fileOutputStream.write(bytes); } fileOutputStream.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ FileInputStream fileInputStream = new FileInputStream(\\\"1.txt\\\"); OutputStream stream = socket.getOutputStream(); byte[] bytes = new byte[1024]; int i; while((i = fileInputStream.read(bytes)) != -1){ stream.write(bytes, 0, i); } stream.flush(); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"727\":{\"h\":\"使用浏览器访问Socket服务器\",\"t\":[\"Http请求是基于TCP协议，不会保持长久连接，在收到响应的数据后会立即关闭TCP连接。\",\"尝试自己写的http相应时，要保持服务器一直在线，不能一个socket之后就done了，因为浏览器访问时会不止发一个请求，所以如果没有始终在线，浏览器会显示无法访问。\",\"查看浏览器发起的请求\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\\\"接收到客户端数据：\\\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } \",\"通过访问 http://localhost:8080 或是 http://127.0.0.1:8080, 来连接我们本地端口的服务器。\",\"我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：\",\"GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: keep-alive Cache-Control: max-age=0 sec-ch-ua: \\\"Chromium\\\";v=\\\"94\\\", \\\"Google Chrome\\\";v=\\\"94\\\", \\\";Not A Brand\\\";v=\\\"99\\\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \\\"macOS\\\" Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 \",\"实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。\",\"既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：\",\"HTTP/1.1 200 Accpeted \",\"然后就是响应内容（注意一定要换行再写），对应支持HTTP协议的响应内容：\",\"public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ // 必须加 while(true) 因为浏览器不止发一个请求 while(true){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"HTTP/1.1 200 Accepted\\\\r\\\\n\\\"); writer.write(\\\"\\\\r\\\\n\\\"); writer.write(\\\"Penguin!\\\"); writer.flush(); socket.close(); } }catch (Exception e){ e.printStackTrace(); } } } \"]},\"728\":{\"c\":[\"code\"]},\"729\":{\"c\":[\"javaweb\"]},\"730\":{\"h\":\"javaweb - 数据库1\"},\"731\":{\"h\":\"数据库 1\"},\"732\":{\"h\":\"简介\",\"t\":[\"数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。\",\"常见的数据库有很多种，包括但不限于：\",\"MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统\"]},\"733\":{\"h\":\"数据模型\",\"t\":[\"数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：\",\"属性不可再分\",\"一个实体的属性可以有很多个\",\"用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的\",\"属性取值可以有一定的约束，比如性别只能是男或是女\",\"实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。\",\"通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。\",\"1\"]},\"734\":{\"h\":\"数据库创建\",\"t\":[\"既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：\",\"学生表：用于存放所有学生的数据，学生（学号，姓名，性别）\",\"教师表：用于存放所有教师的数据，教师（教师号，姓名）\",\"授课表：用于存放教师与学生的授课信息，授课（学号，教师号）\",\"其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。\"]},\"735\":{\"h\":\"数据库的规范化\",\"t\":[\"要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。\",\"1NF对表中每一列进行约束，2NF对主属性和其他属性的依赖关系产生约束，3NF对依赖关系进一步加强，BCNF则是对主键的选取进行唯一确定\"]},\"736\":{\"h\":\"第一范式（1NF）\",\"t\":[\"第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：\",\"学生（姓名，电话号码）\",\"电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为：\",\"学生（姓名，座机号码，手机号码）\",\"满足第一范式是关系型数据库最基本的要求！\"]},\"737\":{\"h\":\"第二范式（2NF）\",\"t\":[\"第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：\",\"学生（学号，姓名，性别）\",\"学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。\"]},\"738\":{\"h\":\"第三范式（3NF）\",\"t\":[\"在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。\",\"学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）\",\"实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：\",\"学生借书情况（借阅编号，学生学号，书籍编号）\",\"书籍（书籍编号，书籍名称，书籍作者）\",\"这样就消除了传递依赖，从而满足第三范式。\"]},\"739\":{\"h\":\"BCNF\",\"t\":[\"BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：\",\"(仓库ID, 存储物品ID) →(管理员ID, 数量)\",\"(管理员ID, 存储物品ID) → (仓库ID, 数量)\",\"所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：\",\"(仓库ID) → (管理员ID)\",\"(管理员ID) → (仓库ID)\",\"即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。\"]},\"740\":{\"c\":[\"code\"]},\"741\":{\"c\":[\"javaweb\",\"mysql\"]},\"742\":{\"h\":\"javaweb - 数据库2\"},\"743\":{\"h\":\"数据库 2\"},\"744\":{\"h\":\"SQL 语句\",\"t\":[\"结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。\",\"SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！\",\"SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。\",\"我们要学习的就是以下四种类型的SQL语言：\",\"数据查询语言（Data Query Language, DQL） 基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。\",\"数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集， 以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。\",\"数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。\",\"DCL（Data Control Language）是数据库控制语言。 是用来设置或更改数据库用户或角色权限的语句 包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。\",\"我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）\"]},\"745\":{\"h\":\"数据库定义语言（DDL）\"},\"746\":{\"h\":\"SQL数据类型\",\"t\":[\"以下的数据类型用于字符串存储：\",\"char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。\",\"varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。\",\"以下数据类型用于存储数字：\",\"smallint用于存储小的整数，范围在 (-32768，32767)\",\"int用于存储一般的整数，范围在 (-2147483648，2147483647)\",\"bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)\",\"float用于存储单精度小数\",\"double用于存储双精度的小数\",\"以下数据类型用于存储时间：\",\"date存储日期\",\"time存储时间\",\"year存储年份\",\"datetime用于混合存储日期+时间\"]},\"747\":{\"h\":\"列级约束条件\",\"t\":[\"列级约束有六种：\",\"主键 Primary key 确保列中的每个值都是唯一的，并且不能为空。一个表只能有一个主键，主键列的值用来唯一标识每一行数据。在主键列中，不允许有重复的值和空值。\",\"id INT PRIMARY KEY 表示 id 列是主键，且不能为空且唯一。\",\"外键 foreign key 用于建立和维护两表之间的关系，确保列中的值必须存在于另一表的主键或唯一约束列中。它保证数据的参照完整性。即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值。\",\"FOREIGN KEY (department_id) REFERENCES departments(id)，表示 department_id 列是外键，参照 departments 表的 id 列。\",\"唯一 unique 确保列中的每个值都是唯一的，但允许空值。与主键类似，唯一约束保证列中所有的非空数据都是唯一的。一个表可以有多个唯一约束，不同于主键，唯一约束允许有空值。\",\"email VARCHAR(255) UNIQUE 表示 email 列的值是唯一的。\",\"检查 check （MySQL不支持） 用于定义列的值必须满足某些条件。检查约束通常用于限制某些特定的数值范围或模式。\",\"age INT CHECK (age >= 18)，表示 age 列的值必须大于或等于 18。\",\"默认 default 用于为列指定默认值。如果在插入数据时没有为该列提供值，则会使用默认值。默认值仅在插入数据时使用，如果插入时该列有明确值，则默认值不会生效。\",\"status VARCHAR(10) DEFAULT 'active'，表示 status 列在未指定值时默认值为 'active'。\",\"非空/空值 not null/ null 用于定义列是否可以为空。NOT NULL 约束要求该列的每一行必须有一个非空值，而 NULL 允许列中的某些行没有值。\",\"name VARCHAR(100) NOT NULL 表示 name 列不能为 NULL，每一行必须有值。\"]},\"748\":{\"h\":\"表级约束条件\",\"t\":[\"表级约束有四种：主键、外键、唯一、检查\",\"主键 主键约束保证表中的每一行数据都有唯一的标识符，且该列的值不能为空。一个表只能有一个主键。\",\"CONSTRAINT pk_primary_key PRIMARY KEY (id)\",\"外键 外键约束用于在两个表之间建立参照完整性关系，确保某列的值必须存在于另一表的主键或唯一约束列中。\",\"CREATE TABLE Departments ( DepartmentID INT, DepartmentName VARCHAR(50) NOT NULL, Location VARCHAR(50), ManagerID INT, Budget DECIMAL(10, 2), CONSTRAINT PK_Departments PRIMARY KEY (DepartmentID), CONSTRAINT UC_DepartmentName UNIQUE (DepartmentName), CONSTRAINT CK_BudgetPositive CHECK (Budget >= 0), CONSTRAINT FK_Manager FOREIGN KEY (ManagerID) REFERENCES Employees(EmployeeID), CONSTRAINT DF_Location DEFAULT 'Headquarters' FOR Location ); \"]},\"749\":{\"h\":\"数据库操作\",\"t\":[\"我们可以通过create database来创建一个数据库：\",\"CREATE DATABASE 数据库名 \",\"为了能够支持中文，我们在创建时可以设定编码格式：\",\"CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; \",\"如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库：\",\"DROP DATABASE 数据库名 \"]},\"750\":{\"h\":\"创建表\",\"t\":[\"在创建表之前，一定要先切换到我们要创建表的数据库内 use xxxx;，默认并不是你创建的数据库。\",\"数据库创建完成后，我们一般通过create table语句来创建一张表：\",\"create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) \"]},\"751\":{\"h\":\"修改表\",\"t\":[\"如果我们想修改表结构，我们可以通过alter table来进行修改：\",\"ALTER TABLE 表名 [ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] \",\"我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。\"]},\"752\":{\"h\":\"删除表\",\"t\":[\"我们可以通过drop table来删除一个表：\",\"DROP TABLE 表名[restrict|cascade] \",\"其中restrict和cascade上面的效果一致。\"]},\"753\":{\"h\":\"数据库操纵语言 (DML)\"},\"754\":{\"h\":\"插入数据\",\"t\":[\"通过使用insert into语句来向数据库中插入一条数据（一条记录）：\",\"INSERT INTO 表名 VALUES(值1, 值2, 值3) \",\"如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) \",\"我们也可以一次性向数据库中插入多条数据：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) \",\"我们来试试看向我们刚刚创建的表中添加三条数据。\"]},\"755\":{\"h\":\"修改数据\",\"t\":[\"我们可以通过update语句来更新表中的数据：\",\"UPDATE 表名 SET 列名=值,... WHERE 条件 \",\"注意，SQL语句中的等于判断是=\",\"警告： 如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！\"]},\"756\":{\"h\":\"删除数据\",\"t\":[\"我们可以通过使用delete来删除表中的数据：\",\"DELETE FROM 表名 \",\"通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据：\",\"DELETE FROM 表名 WHERE 条件 \"]},\"757\":{\"c\":[\"code\"]},\"758\":{\"c\":[\"javaweb\",\"mysql\"]},\"759\":{\"h\":\"javaweb - 数据库3\"},\"760\":{\"h\":\"数据库 3\"},\"761\":{\"h\":\"数据库查询语言 (DQL)\"},\"762\":{\"h\":\"单表查询\",\"t\":[\"单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询：\",\"-- 指定查询某一列数据 SELECT 列名[,列名] FROM 表名 -- 会以别名显示此列 SELECT 列名 别名 FROM 表名 -- 查询所有的列数据 SELECT * FROM 表名 -- 只查询不重复的值 SELECT DISTINCT 列名 FROM 表名 \",\"我们也可以添加where字句来限定查询目标：\",\"SELECT * FROM 表名 WHERE 条件 \"]},\"763\":{\"h\":\"常用 查询条件\",\"t\":[\"一般的比较运算符，包括=、>、<、>=、<=、!=等。\",\"是否在集合中：in、not in\",\"字符模糊匹配：like，not like % 表示任意内容 比如 03% 表示03开头\",\"多重条件连接查询：and、or、not\"]},\"764\":{\"h\":\"排序查询\",\"t\":[\"我们可以通过order by来将查询结果进行排序：\",\"SELECT * FROM 表名 ORDER BY 列名 ASC|DESC \",\"使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。\",\"我们也可以可以同时添加多个排序：\",\"SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC \",\"这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。\"]},\"765\":{\"h\":\"聚集函数\",\"t\":[\"聚集函数一般用作统计，包括：\",\"count([distinct]*)统计所有的行数（distinct表示去重再统计，下同）\",\"count([distinct]列名)统计某列的值总和\",\"sum([distinct]列名)求一列的和（注意必须是数字类型的）\",\"avg([distinct]列名)求一列的平均值（注意必须是数字类型）\",\"max([distinct]列名)求一列的最大值\",\"min([distinct]列名)求一列的最小值\",\"一般聚集函数是这样使用的：\",\"SELECT count(distinct 列名) FROM 表名 WHERE 条件 \"]},\"766\":{\"h\":\"分组和分页查询\",\"t\":[\"通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 \",\"我们还可以添加having来限制分组条件：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 \",\"我们可以通过limit来限制查询的数量，只取前n个结果：\",\"SELECT * FROM 表名 LIMIT 数量 \",\"我们也可以进行分页：\",\"SELECT * FROM 表名 LIMIT 起始位置,数量 \"]},\"767\":{\"h\":\"多表查询\",\"t\":[\"多表查询是同时查询的两个或两个以上的表，多表查询会通过连接转换为单表查询。\",\"SELECT * FROM 表1, 表2 \",\"直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。\",\"SELECT * FROM 表1, 表2 WHERE 条件 \",\"这样，只会从笛卡尔积的结果中得到满足条件的数据。\",\"注意： 如果两个表中都带有此属性，需要添加表名前缀来指明是哪一个表的数据。比如 select * from a1, a2 where a1.xxx;\"]},\"768\":{\"h\":\"自身连接查询\",\"t\":[\"自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：\",\"SELECT * FROM 表名 别名1, 表名 别名2 \",\"其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。\"]},\"769\":{\"h\":\"外连接查询\",\"t\":[\"可以叠着使用\",\"外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：\",\"通过使用inner join xxx on进行内连接 只会返回两个表满足条件的交集部分： select * from student inner join teach on student.sid = teach.sid;\",\"通过使用left join xxx on进行左连接 不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： select * from student left join teach on student.sid = teach.sid;\",\"右连接类似 right join xxx on\"]},\"770\":{\"h\":\"嵌套查询\",\"t\":[\"我们可以将查询的结果作为另一个查询的条件，比如：\",\"SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) \",\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。\"]},\"771\":{\"h\":\"数据库控制语言（DCL）\",\"t\":[\"庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。\"]},\"772\":{\"h\":\"创建用户\",\"t\":[\"我们可以通过create user来创建用户：\",\"CREATE USER 用户名 identified by 密码; \",\"也可以不带密码：\",\"CREATE USER 用户名; \",\"我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。\"]},\"773\":{\"h\":\"登陆用户\",\"t\":[\"首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：\",\"login -u 用户名 -p \",\"输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：\",\"show databases; \",\"我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！\"]},\"774\":{\"h\":\"用户授权\",\"t\":[\"我们可以通过使用grant来为一个数据库用户进行授权：\",\"grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] \",\"其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。\",\"我们可以使用revoke来收回一个权限：\",\"revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 \"]},\"775\":{\"c\":[\"code\"]},\"776\":{\"c\":[\"javaweb\",\"mysql\"]},\"777\":{\"h\":\"javaweb - 数据库4\"},\"778\":{\"h\":\"数据库 4\"},\"779\":{\"h\":\"视图\",\"t\":[\"视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。\",\"既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 对视图的修改就是对基本表的修改，相当于一个指针。\",\"我们可以通过create view来创建视图;\",\"CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; \",\"WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。\",\"若视图是由两个以上基本表导出的，则此视图不允许更新。\",\"若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。\",\"若视图的字段来自集函数，则此视图不允许更新。\",\"若视图定义中含有GROUP BY子句，则此视图不允许更新。\",\"若视图定义中含有DISTINCT短语，则此视图不允许更新。\",\"若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade > (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。\",\"一个不允许更新的视图上定义的视图也不允许更新\",\"通过drop来删除一个视图：\",\"drop view apptest \"]},\"780\":{\"h\":\"索引\",\"t\":[\"在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：\",\"-- 创建索引 CREATE INDEX 索引名称 ON 表名 (列名) -- 查看表中的索引 show INDEX FROM student \",\"索引类型包括：NORMAL, UNIQUE, FULLTEST, SPATIAL\",\"索引方法：BTREE, HASH\",\"我们也可以通过下面的命令删除一个索引：\",\"drop index 索引名称 on 表名 \",\"虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。\"]},\"781\":{\"h\":\"触发器\",\"t\":[\"触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。\",\"触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）\",\"比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。\",\"CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno \",\"FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！\",\"通过下面的命令来查看触发器：\",\"SHOW TRIGGERS \",\"如果不需要，我们就可以删除此触发器：\",\"DROP TRIGGER 触发器名称 \"]},\"782\":{\"h\":\"事务\",\"t\":[\"当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：\",\"SHOW ENGINES; \",\"MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。\",\"事务具有以下特性：\",\"原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\",\"一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\",\"隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\",\"持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\",\"类似 git 的操作？开启事务只有当commit后才能在真正的数据库里看到\",\"我们通过以下例子来探究以下事务：\",\"begin; #开始事务 ... rollback; #回滚事务 savepoint 回滚点; #添加回滚点 rollback to 回滚点; #回滚到指定回滚点 ... commit; #提交事务 -- 一旦提交，就无法再进行回滚了！ \",\"函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。\"]},\"783\":{\"c\":[\"code\"]},\"784\":{\"c\":[\"javaweb\",\"mysql\"]},\"785\":{\"h\":\"javaweb - JAVA与数据库1\"},\"786\":{\"h\":\"主要内容\",\"t\":[\"通过Java如何去使用数据库来帮助我们存储数据\"]},\"787\":{\"h\":\"JDBC\",\"t\":[\"JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。\",\"我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。\"]},\"788\":{\"h\":\"使用JDBC连接数据库\",\"t\":[\"//注意前两步都放在try()中，因为在最后需要释放资源！ //1. 通过DriverManager来获得数据库连接 try (Connection connection = DriverManager.getConnection( \\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement() ){ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\\\"select * from student\\\"); //4. 查看结果 while (set.next()){ System.out.println(set.getString(1)); } }catch (SQLException e){ e.printStackTrace(); } //5. 释放资源，try-with-resource语法会自动帮助我们close \",\"其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序）\",\"注意： 6.0版本以上，不用手动加载驱动，我们直接使用即可！ 即不需要使用 反射 来加载驱动类\",\"Class.forName(\\\"com.mysql.jdbc.Driver\\\") \",\"如果加载会提示\",\"Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. \"]},\"789\":{\"h\":\"DriverManager\",\"t\":[\"DriverManager是管理我们的数据库驱动的, 来分析我们设定的驱动是否可以连接，如果成功就返回对应的 connection\",\"public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\\\"registerDriver: \\\" + driver); } \",\"private static Connection getConnection( String url, java.util.Properties info, Class<?> caller) throws SQLException { /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) { // synchronize loading of the correct classloader. if (callerCL == null) { callerCL = Thread.currentThread().getContextClassLoader(); } } if(url == null) { throw new SQLException(\\\"The url cannot be null\\\", \\\"08001\\\"); } println(\\\"DriverManager.getConnection(\\\\\\\"\\\" + url + \\\"\\\\\\\")\\\"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) { // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) { try { println(\\\" trying \\\" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! println(\\\"getConnection returning \\\" + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { println(\\\" skipping: \\\" + aDriver.getClass().getName()); } } // if we got here nobody could connect. if (reason != null) { println(\\\"getConnection failed: \\\" + reason); throw reason; } println(\\\"getConnection: no suitable driver found for \\\"+ url); throw new SQLException(\\\"No suitable driver found for \\\"+ url, \\\"08001\\\"); } \",\"我们可以通过调用getConnection()来进行数据库的链接：\",\"@CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\\\"user\\\", user); } if (password != null) { info.put(\\\"password\\\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } \",\"我们可以手动为驱动管理器添加一个日志打印：\",\"static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } \",\"现在我们执行的数据库操作日志会在控制台实时打印。\"]},\"790\":{\"h\":\"了解Connection\",\"t\":[\"Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句：\",\"Statement createStatement() throws SQLException; \",\"我们发现除了普通的Statement，还存在PreparedStatement：\",\"PreparedStatement prepareStatement(String sql) throws SQLException; \",\"在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。\",\"它还支持事务的处理，也放到后面来详细进行讲解。\"]},\"791\":{\"h\":\"了解Statement\",\"t\":[\"我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！\",\"Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。\",\"也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。\",\"6\"]},\"792\":{\"c\":[\"code\"]},\"793\":{\"c\":[\"javaweb\",\"mysql\"]},\"794\":{\"h\":\"javaweb - JAVA与数据库2\"},\"795\":{\"h\":\"JDBC\"},\"796\":{\"h\":\"执行DML操作\",\"t\":[\"删除、更新、添加\",\"import java.io.PrintWriter; import java.sql.*; public class Main { public static void main(String[] args) { try ( Connection connection = DriverManager.getConnection(\\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); Statement statement = connection.createStatement(); ){ int i = statement.executeUpdate(\\\"insert into student values(4,'monkey','男')\\\"); // statement.executeUpdate(\\\"delete from student where sid = 4\\\"); // int i = statement.executeUpdate(\\\"update student set name = 'dog' where sid=3\\\"); System.out.println(\\\"生效了：\\\"+i+\\\"行\\\"); } catch (SQLException e) { throw new RuntimeException(e); } } } \"]},\"797\":{\"h\":\"执行DQL操作\",\"t\":[\"执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 一开始是在第一行上面，可以理解在标题栏\",\"//首先要明确，select返回的数据类似于一个excel表格 while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行 } \",\"我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。\",\"7\"]},\"798\":{\"h\":\"执行批处理操作\",\"t\":[\"当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\\\"insert into user values ('f', 1234)\\\"); statement.addBatch(\\\"insert into user values ('e', 1234)\\\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); } } \"]},\"799\":{\"h\":\"将查询结果映射为对象\",\"t\":[\"既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类：\",\"public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\\\"我叫：\\\"+name+\\\"，学号为：\\\"+sid+\\\"，我的性别是：\\\"+sex); } } \",\"现在我们来进行一个转换：\",\"while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say(); } \",\"注意： 列的下标是从1开始的。\",\"我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射：\",\"private static <T> T convert(ResultSet set, Class<T> clazz){ try { Constructor<T> constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class<?>[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i < param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\\\"错误的类型转换：\\\"+object[i].getClass()+\\\" -> \\\"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; } } \",\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了：\",\"while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say(); } \",\"实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。\"]},\"800\":{\"c\":[\"code\"]},\"801\":{\"c\":[\"javaweb\",\"mysql\"]},\"802\":{\"h\":\"javaweb - JAVA与数据库3\"},\"803\":{\"h\":\"JDBC\"},\"804\":{\"h\":\"实现登陆与SQL注入攻击\",\"t\":[\"在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写：\",\"try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\\\"select * from user where username='\\\"+scanner.nextLine()+\\\"'and pwd='\\\"+scanner.nextLine()+\\\"';\\\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } \",\"用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢：\",\"Test 1111' or 1=1; -- # Test 登陆成功！ \",\"1=1一定是true，那么我们原本的SQL语句会变为：\",\"select * from user where username='Test' and pwd='1111' or 1=1; -- ' \",\"我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。\"]},\"805\":{\"h\":\"使用\",\"t\":[\"我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); PreparedStatement statement = connection.prepareStatement(\\\"select * from user where username= ? and pwd=?;\\\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } } \",\"我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么：\",\"com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- '; \",\"我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！\"]},\"806\":{\"h\":\"管理事务\",\"t\":[\"JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false)方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。\",\"con.setAutoCommit(); //关闭自动提交后相当于开启事务。 // SQL语句 // SQL语句 // SQL语句 con.commit();或 con.rollback(); \",\"一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); } } \",\"我们来接着尝试一下使用回滚操作：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"同样的，我们也可以去创建一个回滚点来实现定点回滚：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\\\"insert into user values ('d', 1234)\\\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } } \"]},\"807\":{\"c\":[\"code\"]},\"808\":{\"c\":[\"javaweb\",\"mysql\"]},\"809\":{\"h\":\"javaweb - Lombok1\"},\"810\":{\"h\":\"Lombok1\",\"t\":[\"我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！\",\"通过使用 Lombok（小辣椒）就可以解决这样的问题！\",\"img\",\"使用原生方式和小辣椒方式编写类的区别，首先是传统方式：\",\"public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } \",\"而使用Lombok之后：\",\"@Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } \",\"我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！\"]},\"811\":{\"h\":\"配置Lombok\",\"t\":[\"首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download\",\"然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。\",\"重启IDEA\",\"Lombok 是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理(编译阶段处理)。\",\"Java的编译过程可以分成三个阶段： \",\"所有源文件会被解析成语法树。\",\"调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。\",\"最后，语法树会被分析并转化成类文件。\",\"实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。\"]},\"812\":{\"h\":\"使用Lombok\",\"t\":[\"我们通过实战来演示一下Lombok的实用注解：\",\"我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。\",\"我们还可以使用@Accessors来控制生成Getter和Setter的样式。\",\"我们通过添加@ToString来为当前类生成预设的toString方法。\",\"我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。\",\"我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。\",\"我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。\",\"使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。\",\"一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。\",\"使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。\",\"使用@SneakyThrows来自动生成try-catch代码块。\",\"使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换）\",\"使用@Builder来快速生成建造者模式。\",\"通过使用@Builder.Default来指定默认值。\",\"通过使用@Builder.ObtainVia来指定默认值的获取方式。\"]},\"813\":{\"c\":[\"code\"]},\"814\":{\"c\":[\"javaweb\",\"Lombok\"]},\"815\":{\"h\":\"javaweb - Mybatis1\"},\"816\":{\"h\":\"Mybatis1\",\"t\":[\"在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。\",\"再次强调： 学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。\",\"image-20230306163528771\",\"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。\"]},\"817\":{\"h\":\"XML语言\",\"t\":[\"在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <outer> <name>阿伟</name> <desc>怎么又在玩电动啊</desc> <inner type=\\\"1\\\"> <age>10</age> <sex>男</sex> </inner> </outer> \",\"HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。\",\"一个XML文件存在以下的格式规范：\",\"必须存在一个根节点，将所有的子标签全部包含。\",\"可以但不必须包含一个头部声明（主要是可以设定编码格式）\",\"所有的标签必须成对出现，可以嵌套但不能交叉嵌套\",\"区分大小写。\",\"标签中可以存在属性，比如上面的type=\\\"1\\\"就是inner标签的一个属性，属性的值由单引号或双引号包括。\",\"XML文件也可以使用注释：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!-- 注释内容 --> \",\"通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件）\"]},\"818\":{\"h\":\"转义字符\",\"t\":[\"image-20230306163528771\",\"如果嫌一个一个改太麻烦，也可以使用CDATA <![CDATA[ xxxxx ] 来快速创建不解析区域：\",\"<test> <name><![CDATA[我看你<><><>是一点都不懂哦>>>]]></name> </test> \"]},\"819\":{\"h\":\"解析XML文件\",\"t\":[\"如何将定义好的XML文件读取到Java程序中\",\"JDK为我们内置了一个叫做org.w3c的XML解析库：\",\"// 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\\\"file:mappers/test.xml\\\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\\\"test\\\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 // 节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i < childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \\\"：\\\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本 // （内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } \",\"当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的）\",\"不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！\"]},\"820\":{\"c\":[\"code\"]},\"821\":{\"c\":[\"javaweb\",\"mybatis\"]},\"822\":{\"h\":\"javaweb - Mybatis2\"},\"823\":{\"h\":\"Mybatis2\"},\"824\":{\"h\":\"初次使用 Mybatis\",\"t\":[\"文档网站：https://mybatis.org/mybatis-3/zh_CN/configuration.html\",\"我们需要导入Mybatis的依赖，依赖导入完成后，编写Mybatis的配置文件(通过一个XML文件去配置)\",\"按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <!-- 对应哪个数据库的JDBC驱动 com.mysql.cj.jdbc.Driver --> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容）\",\"通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了 （也可以不使用配置文件，自行阅读官方文档）\",\"配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象：\",\"public static void main(String[] args) throws FileNotFoundException { String resource = \\\"mybatis-config.xml\\\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try(SqlSession s = sqlSessionFactory.openSession(true)){ } } \",\"直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！\"]},\"825\":{\"h\":\"\",\"t\":[\"那么现在我们来看看，SqlSessionFactory对象是什么东西：\",\"每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话 —— SqlSession对象，\",\"每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。\",\"而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。\"]},\"826\":{\"h\":\"直接读取实体类\",\"t\":[\"我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段\",\"在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。\",\"首先编写实体类，直接使用Lombok：\",\"import lombok.Data; @Data public class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex; } \",\"在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"com.test.entity.Student\\\"> select * from student </select> </mapper> \",\"其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。\",\"我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。\",\"编写好后，我们在配置文件中添加这个Mapper映射器：\",\"<mappers> <mapper url=\\\"file:mappers/TestMapper.xml\\\"/> <!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --> </mappers> \",\"最后在程序中使用我们定义好的Mapper即可：\",\"public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \",\"我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！\"]},\"827\":{\"c\":[\"code\"]},\"828\":{\"c\":[\"javaweb\",\"mybatis\"]},\"829\":{\"h\":\"javaweb - Mybatis3\"},\"830\":{\"h\":\"Mybatis详解1\",\"t\":[\"由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些：\",\"public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } \",\"现在我们只需要在main方法中这样写即可查询结果了：\",\"public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \"]},\"831\":{\"h\":\"查询操作\",\"t\":[\"XML配置sql操作\",\"对应java进行调用\",\"查询操作在XML配置中使用一个select标签进行囊括\",\"假设我们现在需要编写一个根据ID查询用户的操作，首先我们需要指定select操作的id：\",\"<select id=\\\"selectUserById\\\"> </select> \",\"接着是我们需要进行查询的参数，这里我们需要根据用户ID查询，那么传入的参数就是一个int类型的参数，参数也可以是字符串类型的，类型名称：\",\"如果是基本类型，需要使用_int这样前面添加下划线。\",\"如果是JDK内置的包装类型或是其他类型，可以直接使用其名称，比如String、int（Integer的缩写）、Long\",\"如果是自己编写的类型，需要完整的包名+类名才可以。\",\"当然也可以直接不填这个属性，Mybatis会自动判断：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> </select> \",\"接下来就是编写我们的SQL语句了，由于这里我们需要通过一个参数来查询，所以需要填入一个占位符，通过使用#{xxx}或是${xxx}来填入我们给定的属性，名称随便：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> select * from user where id = #{id} </select> \",\"实际上Mybatis也是通过PreparedStatement首先进行一次预编译，来有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此对于常见的一些查询参数，我们一般都使用#{xxx}来进行操作保证安全性。\",\"最后我们查询到结果后，一般都是将其转换为对应的实体类对象，所以说这里我们之间填写之前建好的实体类名称，使用resultType属性来指定：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"832\":{\"h\":\"别名\",\"t\":[\"当然，如果你觉得像这样每次都要写一个完整的类名太累了，也可以为它起个别名，我们只需要在Mybatis的配置文件中进行编写即可：\",\"<typeAliases> <typeAlias type=\\\"com.test.User\\\" alias=\\\"User\\\"/> </typeAliases> \",\"也可以直接扫描整个包下的所有实体类，自动起别名，默认情况下别名就是类的名称：\",\"<typeAliases> <package name=\\\"com.test.entity\\\"/> </typeAliases> \",\"这样，SQL语句映射配置我们就编写好了，接着就是Java这边进行调用了：\",\"//这里我们填写刚刚的id，然后将我们的参数填写到后面 User user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"833\":{\"h\":\"hashmap 转换\",\"t\":[\"当然，如果你不需要转换为实体类，Mybatis也为我们提供了多种转换方案，比如转换为一个Map对象：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} </select> \",\"//使用Map类型变量进行接受，Key为String类型，Value为Object类型 Map<String, Object> user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"834\":{\"h\":\"多参数查询\",\"t\":[\"我们可以尝试接着来写一个同时查询ID和年龄的查询操作：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"因为这里需要多个参数，我们可以使用一个Map (Map.of是JAVA9的特性)或是具有同样参数的实体类来传递，显然Map用起来更便捷一些，注意key的名称需要与我们编写的SQL语句中占位符一致：\",\"User user = session.selectOne(\\\"selectUserByIdAndAge\\\", Map.of(\\\"id\\\", 1, \\\"age\\\", 18)); System.out.println(user); \"]},\"835\":{\"h\":\"\",\"t\":[\"下面这种情况，实体类中定义的属性名称和我们数据库中的名称不一样\",\"这会导致Mybatis自动处理出现问题：\",\"@Data public class User { int uid; String username; int age; } \",\"运行后发现，Mybatis虽然可以查询到对应的记录，但是转换的实体类数据并没有被添加上去，这是因为数据库字段名称与类中字段名称不匹配导致的，我们可以手动配一个resultMap来解决这种问题，直接在Mapper中添加：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultMap=\\\"user\\\"> select * from user where id = #{id} and age = #{age} </select> <resultMap id=\\\"user\\\" type=\\\"com.test.User\\\"> <!-- 因为id为主键，这里也可以使用<id>标签，有助于提高性能 --> <result column=\\\"id\\\" property=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"column 对应数据库字段名\",\"property 对应实体类属性名\",\"这里我们在resultMap标签中配置了一些result标签，每一个result标签都可以配置数据库字段和类属性的对应关系，这样Mybatis就可以按照我们的配置来正确找到对应的位置并赋值了，没有手动配置的字段会按照之前默认的方式进行赋值。\",\"配置完成后，最终只需要将resultType改为resultMap并指定对应id即可，然后就能够正确查询了。\",\"这里有一个RowBounds参数，用于实现分页效果，但是其分页功能是对查询到的数据进行划分，非常鸡肋，这里不进行介绍，了解即可。\"]},\"836\":{\"h\":\"查询列表操作\",\"t\":[\"我们再来尝试编写一下查询一个列表，查询列表时，resultType无需设置为list这种类型，而是使用List内部所包含的类型\",\"所以这里还是填写com.test.User类型或是Map类型：\",\"<select id=\\\"selectUsers\\\" resultType=\\\"com.test.User\\\"> select * from user; </select> \",\"由于返回的结果是一个列表，这里我们需要使用selectList方法来执行，如果使用之前的selectOne会导致异常：\",\"List<User> user = session.selectList(\\\"selectUsers\\\"); System.out.println(user); \",\"我们同样可以进行简单的条件查询，比如我们想要查询所有年龄大于等于18岁的用户：\",\"<select id=\\\"selectUsersByAge\\\" resultType=\\\"com.test.User\\\"> select * from user where age &gt; #{age}; </select> \",\"注意由于这里是XML配置，其中一些字符被用作标签表示，无法代表其原本的意思，比如小于、大于符号，分别需要使用&lt;和&gt;来进行转义。\",\"List<User> user = session.selectList(\\\"selectUsersByAge\\\", 18); \",\"一个比较特殊的选择方法selectMap\",\"可以将查询结果以一个Map的形式表示，只不过这和我们之前说的Map不太一样，它返回的Map是使用我们想要的属性作为Key，然后得到的结果作为Value的Map，它适用于单个数据查询或是多行数据查询：\",\"//最后一个参数为我们希望作为key的属性 Map<String, User> user = session.selectMap(\\\"selectUserById\\\", 1, \\\"id\\\"); \",\"可以看到这个Map中确实使用的是id作为Key，然后查询得到的实体对象作为Value。\",\"还有一个比较特殊的选择操作是selectCursor\",\"可以得到一个Cursor对象，同样是用于列表查询的，只不过使用起来和我们之前JDBC中的ResultSet比较类似，也是通过迭代器的形式去进行数据的读取，官方解释它主要用于惰性获取数据，提高性能：\",\"public interface Cursor<T> extends Closeable, Iterable<T> { ... } \",\"可以看到它本身是实现了Iterable接口的，表明它可以获取迭代器或是直接使用foreach来遍历：\",\"Cursor<User> cursor = session.selectCursor(\\\"selectUsers\\\"); for (User user : cursor) { System.out.println(user); } \",\"只不过这种方式在大部分请情况下还是用的比较少，我们主要还是以selectOne和selectList为主。\",\"最后还有一个普通的select方法，它支持我们使用Lambda的形式进行查询结果的处理：\",\"session.select(\\\"selectUsers\\\", context -> { //使用ResultHandler来处理结果 System.out.println(context.getResultObject()); }); \",\"结果会自动进行遍历并依次执行我们传入的Lambda表达式。\"]},\"837\":{\"c\":[\"code\"]},\"838\":{\"c\":[\"javaweb\",\"mybatis\"]},\"839\":{\"h\":\"javaweb - Mybatis4\"},\"840\":{\"h\":\"Mybatis详解2\"},\"841\":{\"h\":\"指定构造方法\",\"t\":[\"(一般不咋用) 通过前面的学习，我们已经知道如何使用Mybatis进行各种查询操作。我们知道，Mybatis在执行完查询语句后，会自动将查询的结果转换为我们所需要的实体类\",\"实际上Mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象，然后通过反射进行赋值，我们可以手动编写一个带调试信息的无参构造：\",\"public User() { System.out.println(\\\"????\\\"); } \",\"alt text\",\"可以看到Mybatis确实调用了我们的无参构造方法来构建对象，属性则是通过反射进行赋值，这里截取部分Mybatis源代码进行演示：\",\"//这里的object就是刚刚构造好的实体类对象，prop是要设置的值的字段信息，value就是要设置的值 private void setBeanProperty(PropertyTokenizer prop, Object object, Object value) { try { //Invoker是Mybatis内部编写一个用于反射设置对象属性值的工具 Invoker method = metaClass.getSetInvoker(prop.getName()); Object[] params = { value }; try { method.invoke(object, params); //通过Invoker为传入的实体类对象赋值 } catch (Throwable t) { throw ExceptionUtil.unwrapThrowable(t); } } catch (Throwable t) { ... } } \",\"由于Mybatis默认情况下直接通过无参构造来创建实体类对象，如果我们的类中存在其他的构造方法覆盖掉默认的无参构造，那么Mybatis会选择可用的构造方法来进行构造。\",\"但是如果存在多个构造方法，Mybatis会出现问题：\",\"@ToString public class User { ... public User(int id) { this.id = id; } public User(String name, int age) { this.name = name; this.age = age; } } \",\"运行时出现错误：\",\"Exception in thread \\\"main\\\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.User matching [java.lang.Integer, java.lang.String, java.lang.Integer] ### The error may exist in file:mappers/TestMapper.xml \",\"此时由于类中存在多个构造方法，而Mybatis不知道该如何选择，那么就会告诉我们找不到合适的构造方法，要解决这种问题也很简单，我们不需要删除这些多余的构造方法，只需添加一个无参构造或是全参构造即可，注意全参构造必须与查询结果字段参数一一对应。\",\"但是注意，Mybatis仅仅是使用这种方式进行对象的构建，而字段的赋值无论是什么构造方法，都会使用反射进行一次赋值：\",\"public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; //这里我们让age在赋值时增加一次 } \",\"我们会发现，就算像这样进行了修改，最终的结果依然是被赋值为数据库中的结果，也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了。\",\"如果需要让Mybatis完全使用构造方法进行对象构建与赋值工作，那么我们需要在XML中手动编写配置，同样需要使用resultMap来完成：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.User\\\"> <constructor> </constructor> </resultMap> \",\"这一次我们在resultMap中添加constructor标签，表示我们的查询结果直接使用指定的构造方法来处理。接着我们需要配置一下constructor里面的内容，使其符合我们指定构造方法的定义，比如现在我们有一个这样的构造方法：\",\"public User(int id, String name) { this.id = id; this.name = name + \\\"同学\\\"; } \",\"那么对应的XML配置编写为，使用arg标签来代表每一个参数，主键可以使用idArg来表示，有助于优化性能：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> </constructor> \",\"注意参数的顺序，必须和构造方法的顺序一致，否则会导致Mybatis无法确认。\",\"指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值。\"]},\"842\":{\"h\":\"接口绑定\",\"t\":[\"之前通过创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，可以用接口来简化\",\"通过namespace来将各种操作绑定到一个接口上，然后使用方法的形式来表示，注意接口的参数和返回值必须正确对应，否则可能会出现问题：\",\"public interface TestMapper { List<Student> selectStudent(); Student selectStuById(int id); List<Student> selectStusBySex(String sex); } \",\"接着将Mapper文件的命名空间修改为我们的接口完整名称：\",\"<mapper namespace=\\\"com.test.mapper.TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"Student\\\"> select * from student </select> <select id=\\\"selectStuById\\\" resultType=\\\"Student\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectStusBySex\\\" resultType=\\\"Student\\\"> select * from student where sex = #{sex} </select> </mapper> \",\"这里建议将对应的xml配置也放到放到同包中，作为内部资源：\",\"alt text\",\"作为内部资源后，我们需要修改一下配置文件中的mapper文件目录，不使用url而是resource表示是Jar内部的文件：\",\"<mappers> <mapper resource=\\\"com/test/mapper/TestMapper.xml\\\"/> </mappers> \",\"现在我们可以直接通过SqlSession获取我们编写接口的实现类，这个实现类是由Mybatis根据我们的配置自动生成的，不需要我们做任何事情：\",\"try(SqlSession sqlSession = MybatisUtil.openSession(true)) { TestMapper mapper = sqlSession.getMapper(TestMapper.class); //直接获取实现类 //这里调用我们编写的接口方法 mapper.selectStudent().forEach(System.out::println); } \",\"那肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？\",\"我们可以通过调用getClass()方法来看看实现类是个什么：\",\"TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getClass()); \",\"我们发现，得到的类名称很奇怪class jdk.proxy2.$Proxy4，它其实是通过动态代理生成的，相当于在程序运行过程中动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。\"]},\"843\":{\"h\":\"多参数表示\",\"t\":[\"xml中参数名改为 param1, param2, ...\",\"用注解 @param(xx)\",\"我们接着来看更方便的用法，有些时候，我们的查询操作可能需要不止一个参数：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"com.test.entity.User\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"一种最简单的方式就是和之前一样，我们使用一个Map作为参数，然后将这些参数添加到Map中进行传递：\",\"User selectUserByIdAndAge(Map<String, Object> map); \",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserByIdAndAge(Map.of(\\\"id\\\", 1, \\\"age\\\", 18))); \",\"只不过，这样编写实在是太复杂了，要是由一种更简单的方式就好了，我们也可以直接将这两个参数定义到形参列表中：\",\"User selectUserByIdAndAge(int id, int age); \",\"只不过这种方式查询的话，Mybatis会并不能正确获取对应的参数：\",\"### Cause: org.apache.ibatis.binding.BindingException: Parameter 'id' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) \",\"这是因为Java代码编译后形参名称无法保留，导致Mybatis无法确定具体哪个参数交什么名字，\",\"所以默认情况下它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等，这里id实际上就是param1：\",\"select * from user where id = #{param1} and age = #{param2} \",\"当然，如果你实在需要使用对应的属性名称，我们也可以手动添加一个@Param注解来指定某个参数的名称：\",\"User selectUserByIdAndAge(@Param(\\\"id\\\") int id, @Param(\\\"age\\\") int age); \",\"这样Mybatis就可以正确识别了。\"]},\"844\":{\"c\":[\"code\"]},\"845\":{\"c\":[\"javaweb\",\"mybatis\"]},\"846\":{\"h\":\"javaweb - Mybatis5\"},\"847\":{\"h\":\"Mybatis详解3\"},\"848\":{\"h\":\"复杂查询\"},\"849\":{\"h\":\"一对一查询\",\"t\":[\"首先来看最简单的一对一查询，假设我们每个用户都有一个自己的详细信息表：\",\"alt text\",\"这里的id与用户id一致，作为用户id的逻辑外键，表示对应用户的详细信息。对应的实体类为：\",\"@Data public class UserDetail { int id; String description; Date register; String avatar; } @Data public class User { int id; String name; int age; UserDetail detail; } \",\"现在我们希望查询User时，同时将用户的详细信息包含在内，像这种一对一查询该怎么实现呢？\",\"我们现在同样需要使用resultMap来自定义映射规则\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> </resultMap> \",\"MyBatis 有两种不同的方式加载关联：\",\"嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。\",\"嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。\"]},\"850\":{\"h\":\"嵌套结果映射\",\"t\":[\"我们先来看第一种方式，需要使用关联查询将用户的详细信息一并获取，然后配置关联查询相关信息，最后由Mybatis来对查询的结果进行处理即可.\",\"首先是关联查询的SQL语句，这里我们直接使用左连接：\",\"select * from user left join user_detail on user.id = user_detail.id where user.id = #{id} \",\"alt text\",\"接着我们需要在resultMap编写好对应关系，一对一查询我们可以使用association标签来进行指定，其中property就是需要进行一对一处理的对象\",\"在此标签内部填写需要进行一对一映射的对象属性：\",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" javaType=\\\"UserDetail\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"description\\\" column=\\\"description\\\"/> <result property=\\\"register\\\" column=\\\"register\\\"/> <result property=\\\"avatar\\\" column=\\\"avatar\\\"/> </association> </resultMap> \",\"这里的column和javaType可以不填，Mybatis一般情况下可以自动完成推断，配置完成后，我们在查询时Mybatis就可以自动把额外信息也封装好了：\",\"alt text\"]},\"851\":{\"h\":\"嵌套 Select 查询\",\"t\":[\"们可以在查询user表的时候，同时查询user_detail表的对应信息，分别执行两个选择语句，最后再由Mybatis将其结果合并，效果和第一种方法是一样的：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <select id=\\\"selectUserDetailById\\\" resultType=\\\"com.test.entity.UserDetail\\\"> select * from user_detail where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" select=\\\"selectUserDetailById\\\" javaType=\\\"com.test.entity.UserDetail\\\"/> </resultMap> \",\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息，并使用association标签的select属性来指定关联查询操作，得到结果是一样的\"]},\"852\":{\"h\":\"Mybatis日志\",\"t\":[\"我们可以开启Mybatis的日志来观察具体执行的操作，这里我们需要在Mybatis配置文件中添加：\",\"<settings> <setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\"/> </settings> \",\"这样Mybatis运行时就会打印日志到控制台了：\",\"... Opening JDBC Connection Created connection 1962329560. ==> Preparing: select * from user where id = ? ==> Parameters: 1(Integer) <== Columns: id, name, age <== Row: 1, 小明, 18 ====> Preparing: select * from user_detail where id = ? ====> Parameters: 1(Integer) <==== Columns: id, description, register, avatar <==== Row: 1, 我是一个阳光开朗大男孩, 2024-08-16 15:15:03, https://www.baidu.com <==== Total: 1 <== Total: 1 User(id=1, name=小明, age=18, detail=UserDetail(id=1, description=我是一个阳光开朗大男孩, register=Fri Aug 16 15:15:03 CST 2024, avatar=https://www.baidu.com)) Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@74f6c5d8] Returned connection 1962329560 to pool. \",\"Mybatis日志中，==>向右的箭头就是发送给MySQL服务器的SQL语句以及其参数列表，<==向左的箭头就是得到的结果，可以看到这里一共执行了两次SQL语句，分别是user表和user_detail表的查询操作\"]},\"853\":{\"h\":\"一对多查询 (查询一个 - 返回多个)\",\"t\":[\"collection - 实体属性为列表\",\"association - 实体属性为实体类\",\"我们接着来看一对多查询，现在来一个新的表，用于存放用户借阅的图书，对应实体类如下：\",\"@Data public class Book { int bid; String title; } @Data public class User { int id; String name; int age; List<Book> books; //直接得到用户所属的所有书籍信息 } \",\"其中book表设计如下，其中uid作为用户id的逻辑外键，表示这本书是谁借的：\",\"alt text\",\"对于一对多查询，我们也可以进行关联查询来让Mybatis自动解析结果并封装为对象\",\"首先还是关联查询的SQL语句，这里我们让user左连接到book表中：\",\"select * from user left join book on user.id = book.uid where user.id = #{id} \",\"此时由于出现了多行数据，我们需要配置一个collection标签来让其可以正确处理关联的集合结果，Mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中：\",\"<resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <collection property=\\\"books\\\" ofType=\\\"com.test.entity.Book\\\"> <id column=\\\"bid\\\" property=\\\"bid\\\"/> <result column=\\\"title\\\" property=\\\"title\\\"/> </collection> </resultMap> \",\"我们需要在resultMap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系，当然这个关系哪怕只写一个Mybatis也可以自动推断其他的，不过建议还是写完整一点\"]},\"854\":{\"h\":\"嵌套查询\",\"t\":[\"此外也可以用 select 嵌套查询来解决，操作是同样的\",\"<select id=\\\"selectStuById\\\" resultMap=\\\"test\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectBookBySid\\\" resultType=\\\"com.test.entity.Book\\\"> select * from book where uid = #{sid} </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <collection property=\\\"books\\\" select=\\\"selectBookBySid\\\" column=\\\"sid\\\" ofType=\\\"com.test.entity.Book\\\"/> </resultMap> \"]},\"855\":{\"h\":\"多对一查询 (多 - 多)\",\"t\":[\"了解了一对多，那么多对一又该如何查询\",\"比如每个用户现在都有一个小组，但是他们目前都是在同一个小组中，此时我们查询所有用户信息的时候，需要自动携带他们的小组：\",\"alt text\",\"这里我们需要修改一下user表来记录每一个用户所属的小组id，这里使用gid作为分组id的逻辑外键\",\"接着是实体类设计：\",\"@Data public class Group { int id; String name; } @Data public class User { int id; String name; int age; Group group; } \",\"接着就是编写SQL映射，实际上这里跟我们之前的一对一非常类似，我们只需要让查询出来的每一个用户都左连接分组信息即可，这样Mybatis就可以通过association来自动处理了：\",\"select *, groups.name as gname from user left join `groups` on user.gid = groups.id \",\"注意SQL语句中一些字段存在歧义，我们需要手动为其起个别名，接着就是XML编写了：\",\"<select id=\\\"selectAllUser\\\" resultMap=\\\"test2\\\"> select *, groups.name as gname from user left join `groups` on user.gid = groups.id </select> <resultMap id=\\\"test2\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <association property=\\\"group\\\"> <id column=\\\"gid\\\" property=\\\"id\\\"/> <result column=\\\"gname\\\" property=\\\"name\\\"/> </association> </resultMap> \",\"这样我们就可以成功实现多对一查询了，这与之前的一对一比较类似。\",\"当然，也可以嵌套select\",\"<select id=\\\"selectStudent\\\" resultMap=\\\"test\\\"> select * from student </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <association property=\\\"group\\\" select=\\\"selectGroup\\\" column=\\\"gid\\\" javaType=\\\"com.test.entity.Group\\\"/> </resultMap> <select id=\\\"selectGroup\\\" resultType=\\\"com.test.entity.Group\\\"> select * from `group` where gid = #{gid} </select> \"]},\"856\":{\"c\":[\"code\"]},\"857\":{\"c\":[\"javaweb\",\"mybatis\"]},\"858\":{\"h\":\"javaweb - Mybatis6\"},\"859\":{\"h\":\"Mybatis详解4\"},\"860\":{\"h\":\"DML 操作\",\"t\":[\"前面我们介绍了查询操作，我们接着来看修改相关操作(增、删、改)。\",\"Mybatis为我们的DML操作提供了几个预设方法：\",\"int insert(String statement); int insert(String statement, Object parameter); int update(String statement); int update(String statement, Object parameter); int delete(String statement); int delete(String statement, Object parameter); \",\"可以看到，这些方法默认情况下返回的结果都是int类型的，这与我们之前JDBC中是一样的，它代表执行SQL后受影响的行数。\"]},\"861\":{\"h\":\"插入 标签\",\"t\":[\"我们来尝试编写一个插入操作\",\"Mybatis为我们提供的插入操作非常快捷，我们可以直接让一个User对象作为参数传入\",\"即可在配置中直接解析其属性到insert语句中，这里需要用到insert标签：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里我们将parameterType类型设置为我们的实体类型，这样下面在使用#{name}时Mybatis就会自动调用类中对应的Get方法来获取结果\",\"不过，即使这里不指定具体类型，Mybatis也能完成自动推断，非常智能(参数名称要与实体类参数对应)。\",\"和之前一样，我们也可以直接将其绑定到一个接口上：\",\"public interface TestMapper { int addUser(User user); } \",\"注意返回类型必须是int或是long这类数字类型，表示生效的行数，然后这里我们传入的参数直接写成对应的类型即可。\"]},\"862\":{\"h\":\"自增主键ID\",\"t\":[\"有些时候，我们的数据插入后使用的是一个自增主键ID，那么这个自增的主键值我们该如何获取到呢？\",\"Mybatis为我们提供了一些参数用于处理这种问题：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里useGeneratedKeys设置为true表示我们希望获取数据库生成的键\",\"keyProperty设置为User类中的需要获取自增结果的属性名，keyColumn为数据库中自增的字段名称\",\"但是一般情况下不需要手动设置，但是某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，必须设置。\",\"这样我们就可以获取到自增后的值了，接着我们什么都不需要做，Mybatis会在查询完后自动为我们的User对象赋值：\"]},\"863\":{\"h\":\"修改 标签\",\"t\":[\"我们接着来看修改操作，比如要根据ID修改用户的年龄：\",\"<update id=\\\"setUserAgeById\\\"> update user set age = #{age} where id = #{id} </update> \",\"int setUserAgeById(User user); \",\"这里的参数我们依然选择使用User，和之前insert一样，Mybatis会从传入的对象中自动获取需要的参数，当然我们也可以将此方法设计为两个参数的形式：\",\"int setUserAgeById(@Param(\\\"age\\\") int age, @Param(\\\"id\\\") int id); \"]},\"864\":{\"h\":\"删除\",\"t\":[\"删除操作则更为简单，假设我们要根据用户的id进行数据的删除：\",\"<delete id=\\\"deleteUserById\\\"> delete from user where id = #{id} </delete> \",\"这些操作相比查询操作来说非常简单就可以实现，这里就不多做介绍了。\"]},\"865\":{\"h\":\"事务操作\",\"t\":[\"我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多\",\"在创建SqlSession的时候不填写参数默认使用的就是事务模式：\",\"try (SqlSession session = sqlSessionFactory.openSession(false)) { ... } \",\"我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的：\",\"try(SqlSession session = MybatisUtils.openSession(false)) { TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); //虽然日志中已经提示生效1行，但是并没有提交 } \",\"SqlSession接口中为我们提供了事务操作相关的方法，这里我们可以直接尝试进行事务的提交：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(7); session.commit(); //通过SqlSession进行事务提交 \",\"注意，如果我们在提交事务之前，没有进行任何的DML操作，也就是删除、更新、插入的其中任意一种操作，那么调用commit方法则不会进行提交，当然如果仍然需要提交的话也可以使用commit(true)来强制提交。\",\"我们接着来测试一下回滚操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); System.out.println(mapper.selectUserById(1)); //此时由于数据被删除，无法查到 session.rollback(); //进行回滚操作 System.out.println(mapper.selectUserById(1)); //之前被删除的数据回来了 \",\"事务相关操作非常简单，这里就暂时先介绍这么多。\"]},\"866\":{\"c\":[\"code\"]},\"867\":{\"c\":[\"javaweb\",\"mybatis\"]},\"868\":{\"h\":\"javaweb - Mybatis7\"},\"869\":{\"h\":\"Mybatis详解5\"},\"870\":{\"h\":\"动态SQL\"},\"871\":{\"h\":\"批处理\",\"t\":[\"在之前JDBC讲解的时候，我们就提到过批量执行语句的问题，当我们要执行很多条语句时，可能会一个一个地提交：\",\"//现在要求把下面所有用户都插入到数据库中 List<String> users = List.of(\\\"小刚\\\", \\\"小强\\\", \\\"小王\\\", \\\"小美\\\", \\\"小黑子\\\"); //使用for循环来一个一个执行insert语句 for (String user : users) { statement.executeUpdate(\\\"insert into user (name, age) values ('\\\" + user + \\\"', 18)\\\"); } \",\"虽然这样看似非常完美，也符合逻辑，但是实际上我们每次执行SQL语句，都像是去厨房端菜到客人桌上一样，我们每次上菜的时候只从厨房端一个菜，效率非常低\",\"但是如果我们每次上菜推一个小推车装满N个菜一起上，效率就会提升很多，而数据库也是这样，我们每一次执行SQL语句，都需要一定的时间开销\",\"但是如果我把这些任务合在一起告诉数据库，效率会截然不同：\",\"alt text\",\"可见，使用循环操作执行数据库相关操作实际上非常耗费资源，不仅带来网络上的额外开销，还有数据库的额外开销\",\"更推荐使用批处理来优化这种情况，一次性提交一个批量操作给数据库。\",\"需要在Mybatis中开启批处理，我们只需要在创建SqlSession时进行一些配置即可：\",\"factory.openSession(ExecutorType.BATCH, autoCommit); \",\"在使用openSession时直接配置ExecutorType为BATCH即可，这样SqlSession会开启批处理模式，在多次处理相同SQL时会尽可能转换为一次执行，开启批处理后，无论是否处于事务模式下，我们都需要flushStatements()来一次性提交之前是所有批处理操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } session.flushStatements(); \",\"此时日志中可以看到Mybatis在尽可能优化我们的SQL操作：\",\"alt text\"]},\"872\":{\"h\":\"动态SQL介绍\",\"t\":[\"除了使用批处理之外，Mybatis还为我们提供了一种更好的方式来处理这种问题，我们可以使用动态SQL来一次性生成一个批量操作的SQL语句\",\"动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\",\"简单来说，动态SQL在执行时可以进行各种条件判断以及循环拼接等操作，极大地提升了SQL语句编写的的灵活性。\"]},\"873\":{\"h\":\"条件判断 标签\",\"t\":[\"在编写SQL时，我们可以添加一些用于条件判断的标签到XML的SQL语句中\",\"比如我们希望在根据ID查询用户时，如果查询的ID大于3，那么必须同时要满足大于18岁这个条件，这看似是一个很奇怪的查询条件，此时动态SQL就能很轻松实现这个操作：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",\"如果不满足，那么就不拼接里面的内容到原本的SQL中，其中test属性就是我们需要填写的判断条件，它采用OGNL表达式进行编写，语法与Java比较相似\",\"详细了解: https://commons.apache.org/dormant/commons-ognl/\",\"当我们查询条件不同时，Mybatis会选择性拼接我们的SQL语句\"]},\"874\":{\"h\":\"选择判断\",\"t\":[\"除了if操作之外，Mybatis还针对多分支情况提供了choose操作，它类似于Java中的switch语句\",\"比如现在我们希望在查询用户时，ID等于1的必须同时要满足小于18岁，ID等于2的必须满足等于18岁，其他情况的必须满足大于18岁(这需求有点抽象)\",\"我们可以像这样进行编写：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <choose> <when test=\\\"id == 1\\\"> and age &lt;= 18 </when> <when test=\\\"id == 2\\\"> and age = 18 </when> <otherwise> and age > 18 </otherwise> </choose> </select> \",\"注意在when中不允许使用<或是>这种模糊匹配的条件(实际运行好像是可以的)。\"]},\"875\":{\"h\":\"实现批量处理\",\"t\":[\"foreach操作，它与Java中的for类似，可以实现批量操作，这非常适合处理我们前面说的批量执行SQL的问题：\"]},\"876\":{\"h\":\"批量删除\",\"t\":[\"for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } \",\"但是实际上这种情况完全可以简写为一个SQL语句：\",\"DELETE FROM users WHERE id IN (1, 2, 3, 4, 5); \",\"使用foreach来完成它就很简单了：\",\"<delete id=\\\"deleteUsers\\\"> delete from user where id in <foreach collection=\\\"list\\\" item=\\\"item\\\" index=\\\"index\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\"> #{item} </foreach> </delete> \",\"其中:\",\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称，即我们在JAVA中所传给他的值\",\"open和close用于控制起始和结束位置添加的符号\",\"separator用于控制分隔符\",\"现在执行以下操作：\",\"session.delete(\\\"deleteUsers\\\", List.of(1, 2, 3, 4, 5)); \",\"最后实际执行的SQL为：\",\"alt text\"]},\"877\":{\"h\":\"批量插入\",\"t\":[\"我们再来看一个例子，比如现在我们想要批量插入一些用户到数据库里面，原本Java应该这样写，但是这是一种极其不推荐的做法：\",\"TestMapper mapper = session.getMapper(TestMapper.class); List<User> users = List.of(new User(\\\"小美\\\", 17), new User(\\\"小张\\\", 18), new User(\\\"小刘\\\", 19)); for (User user : users) { mapper.insertUser(user); } \",\"实际上这种操作完全可以浓缩为一个SQL语句：\",\"INSERT INTO user (name, age) VALUES ('小美', 17), ('小张', 18), ('小刘', 19); \",\"那这时又可以直接使用咱们的动态SQL来完成操作了：\",\"<insert id=\\\"insertAllUser\\\"> insert into user (name, age) values <foreach collection=\\\"list\\\" item=\\\"item\\\" separator=\\\",\\\"> (#{item.name}, #{item.age}) </foreach> </insert> \",\"alt text\",\"通过使用动态SQL语句，我们基本上可以解决大部分的SQL查询和批量处理场景了。\"]},\"878\":{\"c\":[\"code\"]},\"879\":{\"c\":[\"javaweb\",\"mybatis\"]},\"880\":{\"h\":\"javaweb - Mybatis8\"},\"881\":{\"h\":\"Mybatis详解6\"},\"882\":{\"h\":\"缓存机制\",\"t\":[\"其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。\",\"Mybatis为了查询效率，同样内置了一个缓存机制，我们在查询时，如果Mybatis缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求，节省性能开销。\",\"alt text\",\"Mybatis的缓存机制有些复杂，存在一级缓存(本地缓存)和二级缓存\"]},\"883\":{\"h\":\"一级缓存 (作用在 )\",\"t\":[\"我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，也就是一级缓存，它仅仅对一个会话中的数据进行缓存（一级缓存强制启用，无法关闭，只能做调整）\",\"也就是每一个SqlSession都有有一个对应的缓存\",\"我们来看看下面这段代码：\",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserById(1)); System.out.println(mapper.selectUserById(1)); //再次获取 \",\"这里我们连续获取了两次ID为1的用户，我们会在日志中惊奇地发现，这里的查询操作实际上只进行了一次：\",\"alt text\",\"我们去掉类上的@Data注解，会发现得到的两个对象实际上就是同一个：\",\"alt text\",\"也就是说我们第二次查询不仅压根就没执行SQL语句，甚至直接没有重新构造对象，而是直接获取之前创建好的。\",\"可见，Mybatis确实存在着缓存机制来进行性能优化。\",\"那么如果我修改了数据库中的内容，缓存还会生效吗：\",\"System.out.println(mapper.selectUserById(1)); mapper.updateAgeById(1, 19); System.out.println(mapper.selectUserById(1)); \",\"此时由于我们更新了数据库中的数据，那么之前缓存的内容也会跟着失效，第二次获取的时候会进行重新查询。\",\"也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。\",\"但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。\",\"因此， 一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，我们可以来试验一下：\",\"try(SqlSession s1 = MybatisUtils.openSession(true); SqlSession s2 = MybatisUtils.openSession(true)) { TestMapper m1 = s1.getMapper(TestMapper.class); TestMapper m2 = s2.getMapper(TestMapper.class); System.out.println(m1.selectUserById(1)); m2.updateAgeById(1, 19); System.out.println(m1.selectUserById(1)); } \",\"可以看到，会话1在重复查询数据时，即使会话2已经修改了数据，但是依然没有影响会话1之中的缓存。\",\"这导致尽管会话2更新了数据，但是会话1中的数据是从缓存得到的，没有更新。\",\"一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，无论哪个会话对于数据的查询缓存都可以直接被所有会话使用。\"]},\"884\":{\"h\":\"二级缓存 (作用在 )\",\"t\":[\"我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加：\",\"<cache/> \",\"二级缓存是Mapper级别的，只要是使用这个Mapper的会话，都会关联到这个二级缓存\",\"无论哪个会话失效，它之前查询的缓存依然会存在于二级缓存中，依然可以被其他会话直接使用。\",\"我们可以对cache标签进行一些配置：\",\"<cache eviction=\\\"FIFO\\\" flushInterval=\\\"60000\\\" size=\\\"512\\\" readOnly=\\\"true\\\"/> \",\"其中，size表示最大的缓存对象数量，当缓存达到上限时，会根据eviction配置的策略进行清理：\",\"LRU – 最近最少使用：移除最长时间不被使用的对象。\",\"FIFO – 先进先出：按对象进入缓存的顺序来移除它们。\",\"SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。\",\"WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\",\"flushInterval用于控制缓存刷新时间，当到达指定时间时会自动清理所有缓存，默认情况下如果不配置此项则不会进行定时清理。\",\"readOnly（只读）属性可以被设置为 true 或 false，只读的缓存会给所有调用者返回相同的缓存对象，且对象不能被修改。这就提供了可观的性能提升。\",\"而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。\",\"注意： 二级缓存是事务性的，这意味着，当 SqlSession 结束并提交时，或是结束并回滚，而且没有执行 flushCache=true 的 insert/delete/update 语句时，二级缓存才会被更新。\",\"即：\",\"try(SqlSession session = MybatisUtil.getSession(true); SqlSession session2 = MybatisUtil.getSession(true) ){ TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectStuById(1)); session2.commit(); TestMapper mapper2 = session2.getMapper(TestMapper.class); System.out.println(mapper2.selectStuById(1)); } \",\"只有commit了，才会保存在二级缓存，这样用mapper2时，才不会重新读取，如果没有commit，就会重新读取，因为并没有保存在缓存中\",\"开启二级缓存后，再次执行我们之前的操作，就可以直接在二级缓存中命中了：\",\"alt text\"]},\"885\":{\"h\":\"查找顺序\",\"t\":[\"实际上，添加了二级缓存之后，Mybatis会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库。\"]},\"886\":{\"h\":\"单独配置取消二级缓存\",\"t\":[\"当我们开启二级缓存后，默认情况下一个Mapper中所有的操作都会使用二级缓存\",\"我们也可以单独配置其不使用二级缓存，只需要修改useCache属性即可：\",\"<select id=\\\"selectUserById\\\" useCache=\\\"false\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"887\":{\"h\":\"操作结束，清除所有缓存\",\"t\":[\"有些操作可能比较特殊，比如我们希望某个操作执行完成后，直接清除所有缓存，无论是一级缓存还是二级缓存，那么此时就可以开启flushCache属性：\",\"<select id=\\\"selectUserById\\\" flushCache=\\\"true\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \",\"开启此选项后，调用此操作将直接导致一级和二级缓存被清除。\"]},\"888\":{\"h\":\"缓存一致性问题\",\"t\":[\"虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题\",\"当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题。\",\"alt text\",\"而Mybatis也会这样，我们来看看这个例子：\",\"TestMapper mapper = session.getMapper(TestMapper.class); while (true){ Thread.sleep(3000); System.out.println(mapper.selectUserById(1)); } \",\"我们现在循环地每三秒读取一次，而在这个过程中，我们使用其他软件手动修改数据库中的数据，将1号用户的ID改成100，那么理想情况下，下一次读取将直接无法获取到这行数据，因为ID已经发生变化了。\",\"但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的\",\"因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题\",\"我们只能关闭所有二级缓存，并且在Mybatis每个操作都配置flushCache为true来保证刷新。\",\"只不过这种操作实际上是治标不治本的，实现多服务器缓存共用才是最终解决方案，也就是让所有的Mybatis都使用同一个缓存进行数据存取\",\"在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。\"]},\"889\":{\"c\":[\"code\"]},\"890\":{\"c\":[\"javaweb\",\"mybatis\"]},\"891\":{\"h\":\"javaweb - Mybatis9\"},\"892\":{\"h\":\"Mybatis详解7\"},\"893\":{\"h\":\"使用注解开发\",\"t\":[\"在之前的学习中，我们已经体验到Mybatis为我们带来的便捷了\",\"我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。\",\"那么，能否实现无需XML映射器配置，而是直接使用注解在接口上进行配置呢？\",\"我们可以直接删除掉所有的Mapper.xml文件了，只保留Mapper相关的接口。\",\"现在，我们来尝试以全注解的形式重现编写咱们的SQL语句映射\"]},\"894\":{\"h\":\"调整\",\"t\":[\"还是以查询所有的用户为例，既然现在不需要配置Mapper.xml文件了，那么我们现在需要重写在Mybatis的配置文件中进行mapper的配置\",\"因为现在只需要使用接口来进行配置\",\"所以使用package标签来指定一个包，包下所有的接口都将直接作为Mapper配置接口：\",\"<mappers> <package name=\\\"com.test.mapper\\\"/> </mappers> \",\"或者还是mapper标签通过class属性来指定具体的接口：\",\"<mappers> <mapper class=\\\"com.test.mapper.TestMapper\\\"/> </mappers> \"]},\"895\":{\"h\":\"修改对应接口+注解\",\"t\":[\"现在我们还是在Mapper中添加一个对应的方法用于执行：\",\"public interface TestMapper { List<User> selectAllUser(); } \",\"之前我们需要像这样编写：\",\"<select id=\\\"selectAllUser\\\" resultType=\\\"com.test.User\\\"> select * from user </select> \"]},\"896\":{\"h\":\"举例\",\"t\":[\"现在只需要一个注解即可，Mybatis为我们提供了丰富的注解用于表示不同SQL语句类型\",\"这里的@Select代表的就是select标签，我们只需要直接在其中编写SQL语句即可，而返回类型Mybatis会自动根据方法的返回值进行判断：\",\"public interface TestMapper { @Select(\\\"select * from user\\\") List<User> selectAllUser(); } \",\"QQ_1724143033753\",\"包括一些SQL语句参数的使用也是和之前完全一样，比如插入一个用户：\",\"@Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \"]},\"897\":{\"h\":\"配置这些额外的参数\",\"t\":[\"虽然Mybatis为我们提供了之前XML配置中各种操作的对应注解，但是我们发现，这些注解并不能像之前XML那样直接修改一些属性\",\"比如我们希望配置useGeneratedKeys来得到自动生成的主键，从而修改我们对应的实体类\",\"需要配置这些额外的参数，我们可以使用@Options注解：\",\"@Options(useGeneratedKeys = true, keyColumn = \\\"id\\\", keyProperty = \\\"id\\\") @Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \",\"<insert id=\\\"insertUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这两种写法效果是完全一样的，Mybatis在插入后，会将我们当前的实体类对象的id修改为得到的id\",\"Student student = new Student().setName(\\\"abc\\\").setSex(\\\"女\\\"); mapper.insertStudent(student); System.out.println(student); \",\"alt text\",\"所以我们通过Mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置。\"]},\"898\":{\"h\":\"实体类字段名称与数据库不同\",\"t\":[\"假如现在我们的实体类字段名称与数据库不同，此时该如何像之前一样配置resultMap呢？\",\"public class User { int uid; String username; int age; } \",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"我们可以使用@Results注解来实现这种操作，它的使用方式与resultMap几乎没什么区别：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"uid\\\"), @Result(column = \\\"name\\\", property = \\\"username\\\") }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"899\":{\"h\":\"结合 配置\",\"t\":[\"当然，如果你还是觉得这种方式配置起来不如之前方便，那么你也可以单独在XML中配置一个resultMap\",\"然后直接通过注解的形式引用：\",\"@ResultMap(\\\"test\\\") @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"900\":{\"h\":\"指定构造方法\",\"t\":[\"那么现在如果我们需要指定使用的构造方法怎么办呢？就像我们之前在使用constrator标签一样\",\"Mybatis为我们提供了@ConstructorArgs注解，配置方式和之前几乎一致：\",\"public class User { int id; String name; int age; public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; } } \",\"@ConstructorArgs({ @Arg(id = true, column = \\\"id\\\", javaType = int.class), @Arg(column = \\\"name\\\", javaType = String.class), @Arg(column = \\\"age\\\", javaType = int.class) }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \",\"这与我们之前的XML配置完全一致：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> <arg column=\\\"age\\\" javaType=\\\"_int\\\"/> </constructor> \"]},\"901\":{\"h\":\"关联查询 (注解只支持嵌套查询)\",\"t\":[\"我们再来看看之前在resultMap中配置的关联查询该如何编写，Mybatis也为我们提供了丰富的注解用于处理这类问题，我们首先来看看一对一查询：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"id\\\"), @Result(column = \\\"id\\\", property = \\\"detail\\\", one = @One(select = \\\"selectDetailById\\\")) }) @Select(\\\"select * from user where id = #{id};\\\") User selectUserById(int id); @Select(\\\"select * from user_detail where id = #{id}\\\") UserDetail selectDetailById(int id); \",\"我们在配置@Result注解时，只需要将one或是many参数进行填写即可，它们分别代表一对一关联和一对多关联\",\"使用@One和@Many注解来指定其他查询语句进行嵌套查询，就像是我们之前使用association和collection那样。\",\"不过很遗憾的是，我们无法完全通过注解来实现之前的联合查询解析（这是因为 Java 注解不允许循环引用）\",\"只能使用这种嵌套查询来完成复杂查询操作，因此，如果对这种复杂查询有着一定需求的话，建议使用之前的XML方式进行配置。\"]},\"902\":{\"h\":\"动态 配置 ( 注解)\",\"t\":[\"我们还可以使用注解进行动态SQL的配置\",\"比如现在我们想要实现之前的这个奇葩需求：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"Mybatis针对于所有的SQL操作都提供了对应的Provider注解，用于配置动态SQL\",\"我们需要先创建一个类编写我们的动态SQL操作：\",\"public class TestSqlBuilder { public static String buildGetUserById(int id) { return new SQL(){{ //SQL类中提供了常见的SELECT、FORM、WHERE等操作 SELECT(\\\"*\\\"); FROM(\\\"user\\\"); WHERE(\\\"id = #{id}\\\"); if (id > 3) { WHERE(\\\"age > 18\\\"); } }}.toString(); } } \",\"详细的SQL语句构建器语法文档：https://mybatis.org/mybatis-3/zh_CN/statement-builders.html\",\"构建完成后，接着我们就可以使用@SelectProvider来引用这边编写好的动态SQL操作：\",\"@SelectProvider(type = TestSqlBuilder.class, method = \\\"buildGetUserById\\\") User selectUserById(int id); \",\"效果和之前我们编写XML形式的动态SQL一致\",\"当然，如果遇到了多个参数的情况，我们同样需要使用@Param来指定参数名称，包括TestSqlBuilder中编写的方法也需要添加，否则必须保证形参列表与这边接口一致。\",\"虽然这样可以实现和之前差不多的效果，但是这实在是太过复杂了，我们还需要单独编写一个类来做这种事情\",\"实际上我们也可以直接在@Select中编写一个XML配置动态SQL，Mybatis同样可以正常解析：\",\"@Select(\\\"\\\"\\\" <script> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </script> \\\"\\\"\\\") User selectUserById(int id); \",\"这里只需要包括一个script标签我们就能像之前XML那样编写动态SQL了，只不过由于IDEA不支持这种语法的识别，可能会出现一些莫名其妙的红标，但是是可以正常运行的。\"]},\"903\":{\"h\":\"二级缓存配置\",\"t\":[\"最后我们来看一下二级缓存相关的配置，使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用：\",\"@CacheNamespace(size = 512, readWrite = false) public interface TestMapper {} \",\"我们如果需要控制单个方法的缓存，同样可以使用@Option来进行配置：\",\"@Options(flushCache = Options.FlushCachePolicy.TRUE, useCache = false) @Select(\\\"select * from user where id = #{id}\\\") User selectUserById(int id); \"]},\"904\":{\"h\":\"\",\"t\":[\"这里我们不如再做的更加极致一点，咱们把配置文件也给变成代码配置，彻底抛弃XML配置\",\"实际上我们的XML配置中所有配置项都可以以Configuration对象的形式进行配置，最后在构造SqlSessionFactory时也可以通过此对象进行创建：\",\"sqlSessionFactory = new SqlSessionFactoryBuilder().build(initConfiguration()); private static Configuration initConfiguration() { Configuration configuration = new Configuration(); PooledDataSource dataSource = new PooledDataSource( \\\"com.mysql.cj.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/web_study\\\", \\\"test\\\", \\\"123456\\\"); Environment environment = new Environment(\\\"development\\\", new JdbcTransactionFactory(), dataSource); configuration.setEnvironment(environment); configuration.getTypeAliasRegistry().registerAliases(\\\"com.test.entity\\\"); configuration.setLogImpl(StdOutImpl.class); configuration.addMappers(\\\"com.test.mapper\\\"); return configuration; } \",\"有关Mybatis的基本使用，我们就暂时介绍到这里。\"]},\"905\":{\"c\":[\"code\"]},\"906\":{\"c\":[\"javaweb\",\"mybatis\"]},\"907\":{\"h\":\"javaweb - JUL日志1\"},\"908\":{\"h\":\"JUL日志系统\",\"t\":[\"JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单：\",\"public class Main { public static void main(String[] args) { // 首先获取日志打印器，名称随意 Logger logger = Logger.getLogger(\\\"test\\\"); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\\\"我是普通的日志\\\"); } } \",\"我们可以在主类中使用日志打印，得到日志的打印结果：\",\"十一月 15, 2021 12:55:37 下午 com.test.Main main 信息: 我是普通的日志 \",\"我们发现，通过日志输出的结果会更加规范，在后续的学习中，日志将时刻伴随我们左右。\"]},\"909\":{\"h\":\"JUL基本使用\",\"t\":[\"日志的打印并不是简单的输出，有些时候我们可以会打印一些比较重要的日志信息，或是一些非常紧急的日志信息，根据不同类型的信息进行划分\"]},\"910\":{\"h\":\"级别划分\",\"t\":[\"日志一般分为7个级别，详细信息我们可以在Level类中查看：\",\"public class Level implements java.io.Serializable { ... //出现严重故障的消息级别，值为1000，也是可用的日志级别中最大的 public static final Level SEVERE = new Level(\\\"SEVERE\\\",1000, defaultBundle); //存在潜在问题的消息级别，比如边充电边打电话就是个危险操作，虽然手机爆炸的概率很小，但是还是会有人警告你最好别这样做，这是日志级别中倒数第二大的 public static final Level WARNING = new Level(\\\"WARNING\\\", 900, defaultBundle); //所有常规提示日志信息都以INFO级别进行打印 public static final Level INFO = new Level(\\\"INFO\\\", 800, defaultBundle); //以下日志级别依次降低，不太常用 public static final Level CONFIG = new Level(\\\"CONFIG\\\", 700, defaultBundle); public static final Level FINE = new Level(\\\"FINE\\\", 500, defaultBundle); public static final Level FINER = new Level(\\\"FINER\\\", 400, defaultBundle); public static final Level FINEST = new Level(\\\"FINEST\\\", 300, defaultBundle); ... } \",\"之前通过info方法直接输出的结果就是使用的默认级别的日志，实际上每个级别都有一个对应的方法用于打印：\",\"public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.severe(\\\"severe\\\"); //最高日志级别 logger.warning(\\\"warning\\\"); logger.info(\\\"info\\\"); //默认日志级别 logger.config(\\\"config\\\"); logger.fine(\\\"fine\\\"); logger.finer(\\\"finer\\\"); logger.finest(\\\"finest\\\"); //最低日志级别 } \"]},\"911\":{\"h\":\"自定义级别设置\",\"t\":[\"当然，如果需要更加灵活地控制日志级别\",\"我们也可以通过log方法来主动设定该条日志的输出级别：\",\"Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \\\"严重的错误\\\", new NullPointerException(\\\"祝你明天就遇到我\\\")); logger.log(Level.WARNING, \\\"警告的内容\\\"); logger.log(Level.INFO, \\\"普通的信息\\\"); logger.log(Level.CONFIG, \\\"级别低于普通信息\\\"); \",\"Logger默认情况下只会打印INFO级别以上的日志，而INFO级别以下的日志则会直接省略，我们可以通过配置来进行调整。\"]},\"912\":{\"h\":\"修改日志的默认打印级别\",\"t\":[\"我们知道日志的默认打印级别为INFO，此时低于INFO的所有日志都是被屏蔽的，而要修改日志的默认打印级别，我们需要同时调整Handler和Logger的level属性：\",\"handler.setLevel(Level.FINEST); //注意，填写的日志打印级别是什么，高于等于此级别的所有日志都会被打印 logger.setLevel(Level.FINEST); logger.fine(\\\"Hello World\\\"); \",\"现在我们再次打印低于INFO级别的日志就可以正确得到结果了。\",\"Logger类还为我们提供了两个比较特殊的日志级别，它们专门用于配置特殊情况：\",\"//表示直接关闭所有日志信息，值为int的最大值 public static final Level OFF = new Level(\\\"OFF\\\",Integer.MAX_VALUE, defaultBundle); //表示开启所有日志信息，无论是什么级别都进行打印 public static final Level ALL = new Level(\\\"ALL\\\", Integer.MIN_VALUE, defaultBundle); \",\"因为这这里OFF的值为int的最大值，也就是说没有任何日志级别的值大于它，因此，如果将打印等级配置为OFF，那么所有类型的日志信息都不会被打印了，而ALL则相反。\"]},\"913\":{\"c\":[\"code\"]},\"914\":{\"c\":[\"javaweb\",\"JUL\"]},\"915\":{\"h\":\"javaweb - JUL日志2\"},\"916\":{\"h\":\"JUL日志系统2\"},\"917\":{\"h\":\"日志核心内容\"},\"918\":{\"h\":\"核心部分\",\"t\":[\"日志打印的核心部分：Handler，它用于处理我们的日志内容打印\",\"ConsoleHandler | FileHandler | SocketHandler\",\"JDK为我们提供了很多种类的Handler用于多种不同类型的日志打印，比较常见的就是打印到控制台，当然我们也可以打印到一个日志文件中，名字一般为xxx.log这种格式。\",\"常用的Handler实现有：\",\"ConsoleHandler: 将日志通过System. err打印到控制台，现在默认就是使用的这个。\",\"FileHandler: 将日志直接写入到指定的文件中。\",\"SocketHandler: 将日志利用Socket通过网络发送到另一个主机。\",\"当然，一个Logger中可以包含多个Handler用于同时向不同的地方打印日志，我们可以通过getHandlers方法来获取Logger对象中已经配置的Handler对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(Arrays.toString(logger.getHandlers())); \",\"此时打印的列表中不存在任何Handler对象，可见，我们创建的Logger默认是不带任何Handler对象的\",\"那么我们之前的日志是怎么打印出来的呢？这实际上是Logger的父级提供的，这里我们先暂时不介绍继承关系。\",\"我们使用setUseParentHandlers方法来屏蔽所有父级提供的日志处理器：\",\"logger.setUseParentHandlers(false); \",\"现在由于Logger没有配置任何Handler处理器，因此我们打印日志就不会有任何效果。\"]},\"919\":{\"h\":\"\",\"t\":[\"我们可以来尝试自己配置一个用于控制台打印的Handler处理器，这里直接创建一个新的ConsoleHandler对象：\",\"ConsoleHandler handler = new ConsoleHandler(); logger.addHandler(handler); logger.info(\\\"Hello World\\\"); \",\"现在我们打印日志就可以出现想要的结果了：\",\"8月 28, 2024 12:12:37 上午 com.test.Main main 信息: Hello World \"]},\"920\":{\"h\":\"\",\"t\":[\"我们接着来尝试将日志记录到我们本地的文件中，这里使用FileHandler类型：\",\"FileHandler handler = new FileHandler(\\\"test.log\\\", true); //第二个参数开启后会续写已有的日志，如果不开启会直接覆盖重写 logger.addHandler(handler); \",\"最后我们就可以得到一个日志文件了，默认是以XML格式进行写入的：\",\"alt text\",\"这种格式有助于程序的日志读取，但是对于我们人来说，非常难以阅读，那有没有什么办法将文件的日志打印变成控制台那种格式呢？\"]},\"921\":{\"h\":\"修改输出格式\",\"t\":[\"实际上每一个Handler都有一个Formatter对象，它用于控制日志的格式，默认情况下，ConsoleHandler会配置一个SimpleFormatter对象，格式为：\",\"时间 类名 方法 日志级别: 日志内容 \",\"我们刚刚在FileHandler中见到的是默认生成的XMLFormatter，它会将日志以XML的形式进行打印，现在我们也可以手动修改它为SimpleFormatter类型：\",\"Handler handler = new FileHandler(\\\"test.log\\\"); handler.setFormatter(new SimpleFormatter()); \",\"此时日志文件中写入的内容就是简单的日志格式了\\n\"]},\"922\":{\"c\":[\"code\"]},\"923\":{\"c\":[\"javaweb\",\"JUL\"]},\"924\":{\"h\":\"javaweb - JUL日志3\"},\"925\":{\"h\":\"JUL日志系统3\"},\"926\":{\"h\":\"日志继承关系\"},\"927\":{\"h\":\"\",\"t\":[\"JUL中Logger之间存在父子关系，这种父子关系类似于继承，我们可以通过Logger的getParent方法来获取其父Logger对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent()); \",\"这里我们会得到一个：\",\"java.util.logging.LogManager$RootLogger@24d46ca6 \",\"这个RootLogger对象为所有日志记录器的最顶层父级对象，它包含一个默认的ConsoleHandler处理器用于进行控制台打印，而日志在打印时，子Logger会继承父Logger提供的所有Handler进行日志处理，因此我们在默认情况下才能正常使用日志打印：\",\"Logger logger = Logger.getLogger(\\\"test\\\"); Logger parent = logger.getParent(); System.out.println(Arrays.toString(parent.getHandlers())); \"]},\"928\":{\"h\":\"修改默认情况下的打印等级\",\"t\":[\"Handler是属于对应的Logger的，即继承的子Logger不能直接修改父Logger的Handler\",\"根据我们上节课学习的知识，在默认情况下如果我们需要修改日志打印等级，那么同时也需要将父级的Handler也进行日志等级配置：\",\"parent.getHandlers()[0].setLevel(Level.ALL); logger.setLevel(Level.ALL); logger.finest(\\\"test\\\"); \"]},\"929\":{\"h\":\"重复 问题\",\"t\":[\"当然，如果我们在不屏蔽父级Handler的情况下为子级配置一个Handler，那么此时两个Handler都会生效\",\"顺序：先子Logger, 再父Logger\",\"logger.addHandler(new ConsoleHandler()); logger.info(\\\"你干嘛\\\"); \",\"日志中出现了两次：\",\"8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 \",\"不过需要注意一下顺序，当父级和子级都配置时，那么子级的Handler优先进行处理，接着才是父级。\"]},\"930\":{\"h\":\"名称分级，自动构建继承关系\",\"t\":[\"除了默认的RootLogger作为父类，实际上Logger还会通过名称进行分级，自动构建一个继承关系，比如下面：\",\"Logger logger1 = Logger.getLogger(\\\"com\\\"); Logger logger2 = Logger.getLogger(\\\"com.test\\\"); Logger logger3 = Logger.getLogger(\\\"com.test.inner1\\\"); Logger logger4 = Logger.getLogger(\\\"com.test.inner2\\\"); System.out.println(logger4.getParent() == logger2); //全true System.out.println(logger3.getParent() == logger2); System.out.println(logger2.getParent() == logger1); \",\"就像包名一样，日志的名称会按照包的分级，进行自动继承，就像下面这个图一样：\",\"alt text\"]},\"931\":{\"c\":[\"code\"]},\"932\":{\"c\":[\"javaweb\",\"JUL\"]},\"933\":{\"h\":\"javaweb - JUL日志4\"},\"934\":{\"h\":\"JUL日志系统4\"},\"935\":{\"h\":\"日志默认配置\"},\"936\":{\"h\":\"格式\",\"t\":[\"Properties格式的文件是Java的一种配置文件，我们之前在学习Mybatis的时候学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？\",\"此时就可以使用Properties文件，它的格式如下：\",\"name=Test desc=Description \",\"该文件配置很简单，格式类似于我们Java中的Map键值对，中间使用等号进行连接。\",\"当然，键的名称我们也可以分为多级进行配置，每一级使用.进行划分，比如我们现在要配置数据库的连接信息，就可以编写为这种形式：\",\"jdbc.datasource.driver=com.cj.mysql.Driver jdbc.datasource.url=jdbc:mysql://localhost:3306/test jdbc.datasource.username=test jdbc.datasource.password=123456 \"]},\"937\":{\"h\":\"JAVA读取\",\"t\":[\"JDK为我们提供了一个叫做Properties的类型，它继承自Hashtable类（是HashMap的同步加锁版）\",\"使用起来和HashMap是差不多的：\",\"public class Properties extends Hashtable<Object,Object> {} \",\"相关操作：\",\"Properties properties = new Properties(); properties.load(new FileReader(\\\"test.properties\\\")); //使用load方法读取本地文件中的所有配置到Map中 System.out.println(properties); properties.get(xxx); \"]},\"938\":{\"h\":\"获取系统数据\",\"t\":[\"实际上，我们也可以通过这种方式来获取我们的一些系统属性\",\"System类中有一个getProperties方法用于存储所有系统相关的属性值，这里我们打印一下系统名称和版本：\",\"Properties properties = System.getProperties(); System.out.println(properties.get(\\\"os.name\\\")); System.out.println(properties.get(\\\"os.version\\\")); \",\"当然，程序中的Properties对象也可以快速保存为一个对应的.properties文件：\",\"Properties properties = System.getProperties(); properties.store(new FileWriter(\\\"system.properties\\\"), \\\"系统属性\\\"); \"]},\"939\":{\"h\":\"JUL设置默认配置\",\"t\":[\"实际上JUL也可以通过进行配置文件来规定日志打印器的一些默认值\",\"比如我们现在想配置默认的日志打印级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"接着我们需要在程序开始之前加载这里的配置：\",\"LogManager manager = LogManager.getLogManager(); //获取LogManager读取配置文件 manager.readConfiguration(new FileInputStream(\\\"test.properties\\\")); Logger logger = Logger.getLogger(\\\"test\\\"); logger.config(\\\"Hello World\\\"); \",\"这样就可以通过配置文件的形式修改一些功能的默认属性了，而不需要我们再使用代码进行配置。\",\"实际上在JUL的这类内部也有着对应的配置处理操作，如果发现有默认配置优先使用配置里面的，比如Handler的构造方法：\",\"Handler(Level defaultLevel, Formatter defaultFormatter, Formatter specifiedFormatter) { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); final Level level = manager.getLevelProperty(cname + \\\".level\\\", defaultLevel); final Filter filter = manager.getFilterProperty(cname + \\\".filter\\\", null); final Formatter formatter = specifiedFormatter == null ? manager.getFormatterProperty(cname + \\\".formatter\\\", defaultFormatter) : specifiedFormatter; final String encoding = manager.getStringProperty(cname + \\\".encoding\\\", null); ... } \",\"关于使用配置文件的形式修改JUL部分内容的默认值就先讲解到这里。\"]},\"940\":{\"c\":[\"code\"]},\"941\":{\"c\":[\"javaweb\",\"JUL\"]},\"942\":{\"h\":\"javaweb - JUL日志5\"},\"943\":{\"h\":\"JUL日志系统5\"},\"944\":{\"h\":\"自定义日志格式\",\"t\":[\"新建一个类，来继承Formatter，通过修改对应的format函数来实现自定义\",\"每一个Handler都可以配置一个对应的Formatter来决定日志打印的格式，除了官方为我们提供的两种默认格式外，我们也可以自定义我们想要的日志打印格式。\",\"我们只需要继承Formatter类，就可以创建一个自定义的日志格式处理逻辑了：\",\"public class MyFormatter extends Formatter { @Override public String format(LogRecord record) { return \\\"我是自定义日志格式\\\"; } } \",\"其中参数为LogRecord，它提供了当前日志记录的相关信息，比如：\",\"@Override public String format(LogRecord record) { System.out.println(\\\"所在类: \\\" + record.getSourceClassName()); System.out.println(\\\"方法名称: \\\" + record.getSourceMethodName()); System.out.println(\\\"日志级别: \\\" + record.getLevel().getLocalizedName()); return \\\"我是自定义日志格式\\\"; } \"]},\"945\":{\"h\":\"修改对应\"},\"946\":{\"h\":\"手动修改\",\"t\":[\"Logger logger = Logger.getLogger(\\\"com.test\\\"); logger.getParent().getHandlers()[0].setFormatter(new MyFormatter()); \"]},\"947\":{\"h\":\"配置文件修改\",\"t\":[\"直接把ConsoleHandler的默认Formatter配置为我们自己的类：\",\"java.util.logging.ConsoleHandler.formatter=com.test.MyFormatter \"]},\"948\":{\"h\":\"自定义例子\",\"t\":[\"因此，我们也可以利用这些属性来编写一个类似于的SimpleFormatter的日志格式，比如这里包含类名、时间等，类似于下面图中的日志格式：\",\"alt text\",\"我们来尝试编写一下：\",\"public String format(LogRecord record) { StringBuilder builder = new StringBuilder(); //日期 Date date = new Date(record.getMillis()); SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss.SSS\\\"); builder.append(dateFormat.format(date)); //级别 builder.append(\\\" \\\").append(record.getLevel()); builder.append(\\\" --- \\\"); //线程名称 builder.append('[').append(Thread.currentThread().getName()).append(']'); //类名称 builder.append(\\\" \\\").append(String.format(\\\"%-15s\\\", record.getSourceClassName())); //消息内容 builder.append(\\\" : \\\").append(record.getMessage()); return builder.toString(); } \"]},\"949\":{\"h\":\"第三方框架兼容性\",\"t\":[\"我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？\",\"前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter\"]},\"950\":{\"h\":\"日志注解\",\"t\":[\"同样的，Logger也是可以使用Lombok快速生成的。\",\"@Log public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \",\"只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。\",\"我们也可以手动指定名称：\",\"@Log(topic = \\\"打工是不可能打工的\\\") public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \"]},\"951\":{\"h\":\"日志\",\"t\":[\"我们接着来看Mybatis，经过前面的学习，我们知道，Mybatis也有日志系统，它详细记录了所有的数据库操作等，要开启日志系统，我们需要进行配置：\",\"<setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\" /> \",\"logImpl包括很多种配置项 包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\",\"而默认情况下是未配置，也就是说不打印。\",\"将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台\",\"现在我们也可以将其设置为JDK提供的日志框架：\",\"<setting name=\\\"logImpl\\\" value=\\\"JDK_LOGGING\\\" /> \",\"将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低\",\"因此我们需要设置一下logging.properties默认的日志级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"这样，Mybatis就可以正确使用JDK的日志框架进行日志打印了，只不过格式稍微有点炸裂，可能还是得我们自己编写一个自定义的Formatter才行。\"]},\"952\":{\"c\":[\"code\"]},\"953\":{\"c\":[\"javaweb\",\"JUL\"]},\"954\":{\"h\":\"javaweb - JUnit1\"},\"955\":{\"h\":\"JUnit单元测试1\"},\"956\":{\"h\":\"单元测试\",\"t\":[\"在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目，比如：\",\"public class Main { public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); func1(); func2(); func3(); } private static void func1() { System.out.println(\\\"我是第一个功能\\\"); } private static void func2() { System.out.println(\\\"我是第二个功能\\\"); } private static void func3() { System.out.println(\\\"我是第三个功能\\\"); } } \",\"如果现在我们想单独测试某一个功能的对应方法，而不是让整个项目完全跑起来，这就非常麻烦了。\",\"而单元测试则可以针对某一个方法直接进行测试执行，无需完整启动项目。\",\"alt text\",\"同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。\",\"我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。\"]},\"957\":{\"h\":\"JUnit使用\"},\"958\":{\"h\":\"导入依赖\",\"t\":[\"现在用的是JUnit5, 感觉没学到maven，找jar包花了点时间\",\"alt text\",\"同时IDEA需要安装JUnit插件（终极版默认是已经捆绑安装的，因此无需多余配置），安装好之后，我们就可以直接上手使用了\"]},\"959\":{\"h\":\"使用- 注解\",\"t\":[\"使用方式很简单，只需添加一个@Test注解即可快速创建新的测试用例，这里我们尝试新建一个类用于单元测试：\",\"public class MainTest { } \",\"接着就可以编写我们的测试用例了，现在我们需要创建一个public的无参无返回值方法（不能是静态方法）并在方法内编写我们的需要进行测试的代码：\",\"public void test1(){ Main.func1(); } \",\"最后在方法上添加@Test注解，此时IDEA会提示我们可以运行，旁边出现运行按钮：\",\"alt text\",\"接着点击运行，就可以直接执行我们的测试方法了，然后可以在控制台看到当前的测试用例耗时以及状态：\",\"alt text\",\"一个测试类中可以同时有多个测试案例：\",\"public class MainTest { @Test public void test1(){ Main.func1(); } @Test public void test2(){ Main.func2(); } @Test public void test3(){ Main.func3(); } } \",\"我们只需要点击类旁边的运行按钮，就可以直接执行当前类中所有的测试案例\"]},\"960\":{\"h\":\"跳过某个测试 -\",\"t\":[\"有些时候，可能我们并不想开启其中某个测试用例，我们也可以使用@Disable来关闭某一个测试用例：\",\"@Test @Disabled public void test2(){ } \",\"此时再次全部运行，将忽略二号测试案例进行测试\",\"alt text\"]},\"961\":{\"h\":\"测试自定义名称 -\",\"t\":[\"我们还可以为测试案例添加一个自定义的名称，不然测试案例一多我们就分不清楚到底哪个案例是干嘛的\",\"我们需要使用@DisplayName注解来为其命名：\",\"@Test @DisplayName(\\\"一只企鹅\\\") public void test1(){} \",\"这样我们的控制台也可以看到对应的名称：\",\"alt text\"]},\"962\":{\"h\":\"预设的名称生成器 -\",\"t\":[\"Junit还提供了一些预设的名称生成器，按照一定规则进行名称处理，可以通过@DisplayNameGeneration注解来配置使用，列表如下：\",\"显示名称生成器\",\"行为\",\"Standard\",\"方法名称作为测试名称。\",\"Simple\",\"同上，但是会删除无参数方法的尾随括号。\",\"ReplaceUnderscores\",\"同上，但是会用空格替换方法名称中的下划线。\",\"IndicativeSentences\",\"包含类名和方法名称连接之后的名称。\"]},\"963\":{\"h\":\"判断测试是否成功 — 断言\",\"t\":[\"当然，对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过，我们可以通过断言工具类Assertions来对结果进行判定：\",\"@Test public void test1(){ Random random = new Random(); int value = random.nextInt() % 2; //生成一个随机数，进行对2取余操作 Assertions.assertEquals(1, value); //如果是单数则匹配成功，如果不是则匹配失败 } \",\"当测试案例失败时，控制台会出现应该AssertionFailedError错误，同时IDEA也会提示我们测试失败\",\"alt text\"]},\"964\":{\"c\":[\"code\"]},\"965\":{\"c\":[\"javaweb\",\"JUL\"]},\"966\":{\"h\":\"javaweb - JUnit2\"},\"967\":{\"h\":\"JUnit单元测试2\"},\"968\":{\"h\":\"断言工具\",\"t\":[\"JUnit提供了非常多的断言操作，相比JUnit 4，它们都被封装在一个新的Assertions类中\",\"这些断言操作基本上都是用于判断某个测试结果是否符合我们的预期情况\"]},\"969\":{\"h\":\"值判断\",\"t\":[\"其中最简单的就是判断结果是否等于某个值\",\"Assertions.assertEquals(expected, actual, message)\",\"@Test public void test1(){ int a = 10, b = 5; int c = a + b; //判断结果是否相等，前面的是预期结果，后面的就是实际结果 Assertions.assertEquals(15, c); } \",\"当断言操作发现实际结果与预期不符时，会直接抛出异常告诉我们这个测试案例没有通过，并最终以失败状态结束。我们也可以为本次断言添加一个message来助于我们快速了解是什么类型的测试结果出现问题：\",\"Assertions.assertEquals(14, c, \\\"计算结果验证\\\"); \",\"此时控制台就会得到：\",\"alt text\"]},\"970\":{\"h\":\"真假判断\",\"t\":[\"Assertions.assertTure(condition, message)\",\"除了使用值进行比较外，我们也可以直接对某个boolean类型的结果快速进行判断，使用assertTrue方法：\",\"Assertions.assertTrue(14 == c, \\\"计算结果验证\\\"); \"]},\"971\":{\"h\":\"对象判断\",\"t\":[\"与其相似的还有两个相同对象的判断：\",\"Assertions.assertSame(999, 999); //判断两个值是否为同一个对象 \"]},\"972\":{\"h\":\"复杂判断\",\"t\":[\"如果判断流程比较复杂，我们也可以使用Java8的Lambda来编写结果判断逻辑，提供一个BooleanSupplier对象：\",\"Assertions.assertTrue(() -> { if(c < 10) return true; if(c > 20) return false; return c == 15; }, \\\"计算结果验证\\\"); \",\"对于更加复杂的组合结果判断，我们还可以使用assertAll来包含多个判断操作：\",\"Assertions.assertAll(\\\"整体测试\\\", () -> Assertions.assertTrue(c == 14), () -> Assertions.assertTrue(c > 10), () -> Assertions.assertTrue(c < 20) ); \",\"进行整体测试时，所有的测试结果将合并到一起输出。\"]},\"973\":{\"h\":\"异常判断\",\"t\":[\"除了我们上面提到的真假判断外，还有很多不同类型的结果判断，比如异常判断，我们希望这个案例抛出指定的异常：\",\"Assertions.assertThrows(IOException.class, () -> { System.out.println(1/0); }, \\\"此测试案例并未抛出指定异常\\\"); \",\"由于此时抛出的是一个ArithmeticException并不是我们需要的IOException或是其子类，所以说断言失败：\",\"alt text\",\"除了上述例子中出现的断言方法之外，JUnit还提供了上百种断言方法供大家使用，这里就不挨个介绍了。\"]},\"974\":{\"h\":\"假设工具\",\"t\":[\"除了断言工具外，对于一些不影响结果的测试\",\"我们可以使用“假设”工具来实现对结果的判断但不作为测试结果的判断依据，它通常在执行给定测试没有意义时使用。\",\"public void test1(){ Assumptions.assumeTrue(1 == 3); } \",\"测试结果中会将其显示为已忽略，而不是失败：\",\"alt text\"]},\"975\":{\"h\":\"条件测试和执行\",\"t\":[\"有些时候我们可能需要配置各种条件来执行某些测试案例\",\"比如某些测试案例必须在指定JDK版本执行，或是某些案例只需要在某个特定操作系统执行\",\"Junit支持我们就为测试案例设置条件来实现这些功能。\"]},\"976\":{\"h\":\"指定操作系统 -\",\"t\":[\"比如，我们要限制某个测试案例只在指定操作系统下进行，那么就可以使用@EnabledOnOs来指定：\",\"@Test @EnabledOnOs(OS.MAC) public void test1(){ System.out.println(\\\"我是只在Mac下执行的测试案例\\\"); } @Test @EnabledOnOs(OS.WINDOWS) //@DisabledOnOs(OS.MAC) 或是使用相反注解来为指定操作系统关闭此用例 public void test2(){ System.out.println(\\\"我是只在Windows下执行的测试案例\\\"); } \",\"这样，当我们在指定操作系统下执行时，此测试案例才会启动，否则会直接忽略：\",\"alt text\"]},\"977\":{\"h\":\"指定JDK版本\",\"t\":[\"同样的，如果我们要指定在某个JDK版本执行测试案例，也可以使用@EnabledOnJre来进行指定：\",\"@Test @EnabledOnJre(JRE.JAVA_8) //@DisabledOnJre(JRE.JAVA_8) 或是使用相反的注解来为指定JDK关闭 public void test1(){ System.out.println(\\\"我是只在Java8下执行的测试案例\\\"); } @Test @EnabledOnJre(JRE.JAVA_17) public void test2(){ System.out.println(\\\"我是只在Java17下执行的测试案例\\\"); } \"]},\"978\":{\"h\":\"指定JDK版本范围\",\"t\":[\"或是一个指定的JDK版本范围：\",\"@Test @EnabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_17) public void test1(){ System.out.println(\\\"我是只在Java8-17下执行的测试案例\\\"); } \",\"除了这种简单判断外，我们还可以直接从系统属性中获取我们需要的参数来进行判断。\",\"使用System.getProperties()来获取所有的系统属性，包括系统的架构、版本、名称等信息。下面注解主要就是利用这个函数来进行判断\"]},\"979\":{\"h\":\"系统属性判断\",\"t\":[\"使用@EnabledIfSystemProperty来对系统属性进行判断：\",\"@Test @EnabledIfSystemProperty(named = \\\"os.arch\\\", matches = \\\"aarch64\\\") //其中matches参数支持正则表达式 public void test1(){ System.out.println(\\\"我是只在arm64架构下做的测试\\\"); } \",\"当然，有时候为了方便，我们也可以直接读取环境变量：\",\"@Test @EnabledIfEnvironmentVariable(named = \\\"TEST_STR\\\", matches = \\\"666\\\") public void test1(){ System.out.println(\\\"我是只在环境变量: TEST_STR = 666\\\"); } \"]},\"980\":{\"h\":\"自定义方法\",\"t\":[\"如果你认为这还不够灵活，你还可以直接声明一个自定义方法来进行判断：\",\"@Test @EnabledIf(\\\"testCondition\\\") public void test1(){ System.out.println(\\\"我是自定义的测试条件\\\"); } public boolean testCondition() { return 1 > 0; } \",\"条件方法可以位于测试类之外。在这种情况下，它必须用其完全限定的名称来引用\",\"@EnabledIf(\\\"example.ExternalCondition#customCondition\\\") \",\"class ExternalCondition { /** * 在几种情况下，条件方法需要static： * 当@EnabledIf或@DisabledIf在类上使用时 * 当@EnabledIf或@DisabledIf用于@ParameterizedTest或@TestTemplate方法时 * 当条件方法位于外部类中时 */ static boolean customCondition() { return true; } } \"]},\"981\":{\"c\":[\"code\"]},\"982\":{\"c\":[\"javaweb\",\"JUL\"]},\"983\":{\"h\":\"javaweb - JUnit2\"},\"984\":{\"h\":\"JUnit单元测试3\"},\"985\":{\"h\":\"生命周期\",\"t\":[\"@BeforeAll@AferAll@BeforeEach@AfterEach\",\"其中 @BeforeAll 必须是static方法\",\"我们可以自由设定某些操作在测试开始之前或之后执行，比如测试前的准备工作或是测试后的收尾工作：\",\"@Test public void test1() { System.out.println(\\\"我是测试方法1\\\"); } @BeforeAll //使用BeforeAll必须为static方法 public static void start() { System.out.println(\\\"我是测试前必须要执行的准备工作\\\"); } \",\"其中，@BeforeAll表示此准备工作在所有测试用例执行之前执行，这样，当测试开始前，会优先进行指定的准备工作，防止准备不足导致的测试失败。\",\"相反的，@AfterAll则会在所有测试用例完成之后执行。\",\"除了在所有方法执行前后插入准备工作，我们也可以为所有的方法单个插入准备工作：\",\"@BeforeEach //使用BeforeEach不能为static方法 public void start() { System.out.println(\\\"我是测试前必须要执行的准备工作\\\"); } \",\"这样，在每个测试用例执行之前，都会执行一次这里的准备工作\"]},\"986\":{\"h\":\"测试类的生命周期\",\"t\":[\"我们接着来了解一下测试类的生命周期。\",\"默认情况下，执行测试实际上也会对类进行实例化，并通过实例化对象来调用其中的测试方法，并且，每一个测试用例执行之前，都会创建一个新的对象，而不是直接执行：\",\"public class TestMain { public TestMain() { System.out.println(\\\"构造函数\\\"); } @Test public void test() { System.out.println(\\\"Test1\\\"); } @Test public void test1() { System.out.println(\\\"Test2\\\"); } } \",\"像这样，我们可以得到这样的输出结果：\",\"alt text\",\"每次执行测试用例都会创建一个新的对象来执行，这在某些场景下可能会显得不太方便，比如初始化类需要花费大量时间或是执行非常费时的IO操作时，这会导致我们要花费大量时间来等待每次测试用例的初始化操作。\",\"我们也可以手动修改测试类的初始化行为，默认情况下为PER_METHOD模式：\",\"@TestInstance(TestInstance.Lifecycle.PER_CLASS) public class MainTest {} \",\"将其修改为PER_CLASS模式后，初始化操作只会执行一次，因为现在是以类为单位：\",\"alt text\",\"当然，如果依然对测试用例执行前后有其他准备工作需求，也可以使用之前的@BeforeEach和@AfterEach来实现灵活控制。\"]},\"987\":{\"h\":\"测试顺序控制\",\"t\":[\"有些时候我们可能需要控制某些测试案例的顺序\",\"默认情况下，所有的测试案例都是按照方法的名称顺序来进行的，比如：\",\"@Test public void test3() { //按照名称顺序，虽然这里是第一个定义的，但是它是第三个 System.out.println(\\\"我是测试用例3\\\"); } @Test public void test1() { System.out.println(\\\"我是测试用例1\\\"); } @Test public void test2() { System.out.println(\\\"我是测试用例2\\\"); } \",\"除了默认的名称顺序之外，JUnit提供了以下顺序：\",\"MethodOrderer.DisplayName：根据显示名称对测试方法进行字母数字排序（请参阅显示名称生成优先级规则）\",\"MethodOrderer.MethodName：根据测试方法的名称和形式参数列表，以字母数字排序\",\"MethodOrderer.OrderAnnotation：根据通过@Order注释指定的值对测试方法进行数值排序\",\"MethodOrderer.Random：伪随机排序测试方法，并支持自定义种子的配置\",\"其中，注解顺序可以由我们自己通过注解来手动定义执行顺序：\",\"@Test @Order(1) void nullValues() { // perform assertions against null values } \"]},\"988\":{\"h\":\"嵌套测试 -\",\"t\":[\"有些时候我们可能需要对测试用例进行进一步的分层，比如用户相关的测试全部归为一个组，而管理相关的测试全部归为一个组\",\"此时我们可以使用嵌套测试，通过在类中定义多个内部类来完成：\",\"public class MainTest { @Test public void test() { System.out.println(\\\"我是外部测试类型\\\"); } @Nested class Test1 { @Test public void test1_1() { System.out.println(\\\"我是内部测试类型1-1\\\"); } @Test public void test1_2() { System.out.println(\\\"我是内部测试类型1-2\\\"); } } @Nested class Test2 { @Test public void test2_1() { System.out.println(\\\"我是内部测试类型2-1\\\"); } @Test public void test2_2() { System.out.println(\\\"我是内部测试类型2-2\\\"); } } } \",\"此时测试的结果展示也是嵌套的样式：\",\"alt text\",\"注意，当我们在嵌套测试中使用诸如@BeforeEach、@BeforeAll这种注解时(就是写到里面)，它仅会作用于所属内部类中的所有测试用例，而不是包含外部类中和其他内部类中的全部测试用例，写到外面还是全部\",\"嵌套类的执行同样可以通过@TestClassOrder来控制嵌套类的执行顺序。\"]},\"989\":{\"h\":\"重复和参数化测试\",\"t\":[\"对于某些存在随机性的测试案例，我们可能需要多次执行才能确定其是否存在某些问题\"]},\"990\":{\"h\":\"重复测试\",\"t\":[\"比如某个案例存在一个BUG，导致其10次里面会有1次出现错误，现在我们想要保证其10次都不会出现问题才算通过，此时我们就可以使用重复测试案例来使其多次执行：\",\"@RepeatedTest(10) public void test1() { Random random = new Random(); if (random.nextInt(10) == 0) { throw new IllegalStateException(); } } \",\"此时会重复执行10次此案例，并且当每一次执行都没有出现问题时，才会正常通过.\"]},\"991\":{\"h\":\"参数化测试 +\",\"t\":[\"某些测试可能并不是固定单个输入参数，有时我们可能也需要对多个输入参数进行测试，来做到全方面的问题排查。\",\"它与重复测试比较类似，但是参数可以由我们自己决定，并且每个参数都会进行一次测试：\",\"@ParameterizedTest //使用此注解来表示此测试是一个参数化测试 @ValueSource(strings = { \\\"aa\\\", \\\"bb\\\", \\\"ccc\\\" }) //指定参数列表 public void test1(String str) { //需要添加一个参数 if (str.length() == 3) { throw new IllegalStateException(); } } \",\"这里我们使用@ValueSource来进行参数来源设定，也就是需要进行测试的参数列表\",\"接着下面会根据参数挨个执行此测试用例，保证每一种情况都正常执行\",\"这里的@ValueSource是最简单的一种参数设定，我们可以直接设置一系列值，支持以下类型：\",\"short、byte、int、long、float、double、char、boolean、java.lang.String、java.lang.Class\"]},\"992\":{\"h\":\"空值\",\"t\":[\"除了直接设置指定类型常量值，我们也可以传入空值或是一些为空的字符串、数组等：\",\"@ParameterizedTest @NullSource //将值设置为null进行测试 public void test1(String str) {} \",\"@ParameterizedTest @EmptySource //将值设置为空进行测试，如空字符串、空数组、空集合等 public void test1(int[] arr) {} \",\"@NullAndEmptySource：结合了@NullSource和@EmptySource两个注解的功能。\"]},\"993\":{\"h\":\"枚举值\",\"t\":[\"我们也可以使用枚举值来进行测试，比如我们希望测试某个枚举类型下所有的枚举作为参数进行测试：\",\"enum Type { SMALL, MEDIUM, LARGE } @ParameterizedTest @EnumSource(Type.class) //这将依次测试枚举类中的所有枚举 public void test1(Type type) { System.out.println(type); } \",\"或是指定某些枚举常量：\",\"@ParameterizedTest //模式默认为INCLUDE，即使用指定的枚举常量进行测试 @EnumSource(mode = EnumSource.Mode.INCLUDE, names = { \\\"SMALL\\\", \\\"LARGE\\\" }) public void test1(Type type) { System.out.println(type); } \"]},\"994\":{\"h\":\"特定的方法来生成参数\",\"t\":[\"除了以上方式获取参数，我们也可以使用特定的方法来生成我们需要的测试参数，只需要添加@MethodSource注解即可指定方法：\",\"@ParameterizedTest @MethodSource(\\\"stringProvider\\\") public void test1(String str) { System.out.println(str); } static List<String> stringProvider() { return List.of(\\\"apple\\\", \\\"banana\\\"); } \",\"方法的返回值可以是任何可迭代（Iterable）内容，如数组、集合类、Stream等。同样的，对于其他类中的方法，需要和之前一样使用完全限定的方法名称来引用。\"]},\"995\":{\"h\":\"字段\",\"t\":[\"和方法一样，字段同样可以作为参数的来源，但它必须是静态的：\",\"static List<String> list = List.of(\\\"AAA\\\", \\\"BBB\\\"); @ParameterizedTest @FieldSource(\\\"list\\\") public void test1(String str) { System.out.println(str); } \",\"不仅仅是一个普通的集合或是数组可以作为字段参数来源，如Supplier这种懒加载的数据，也可以作为参数来源：\",\"static Supplier<List<String>> list = () -> List.of(\\\"AAA\\\", \\\"BBB\\\"); @ParameterizedTest @FieldSource(\\\"list\\\") public void test1(String str) { System.out.println(str); } \",\"当然，JUnit还支持从CSV表格中导入或自定义参数提供器等，这里就不做详细介绍了\",\"官方文档：https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-ArgumentsSource\"]},\"996\":{\"c\":[\"code\"]},\"997\":{\"c\":[\"javaweb\",\"JUL\"]},\"998\":{\"h\":\"Maven1 - 简介与项目结构\"},\"999\":{\"h\":\"Maven1 - 简介与项目结构\"},\"1000\":{\"h\":\"简介\",\"t\":[\"Maven 翻译为\\\"专家\\\"、\\\"内行\\\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\",\"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。\",\"Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\",\"通过Maven，可以帮助我们做：\",\"项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。\",\"依赖管理，项目使用到哪些依赖，可以快速完成导入，不需要手动导入jar包。\",\"Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装。\"]},\"1001\":{\"h\":\"Maven项目结构\",\"t\":[\"Maven就很好地解决了这个问题，我们可以先来看一下，一个Maven项目和我们普通的项目有什么区别：\",\"alt text\",\"其中src目录下存放我们的源代码和测试代码，分别位于main和test目录下\",\"而test和main目录下又具有java、resources目录，它们分别用于存放Java源代码、静态资源（如配置文件、图片等），测试代码不会打包到项目里面，只仅用于测试。\",\"很多JavaWeb项目可能还会用到webapp目录。\"]},\"1002\":{\"h\":\"核心配置\",\"t\":[\"而下面的pom.xml则是Maven的核心配置，也是整个项目的所有依赖、插件、以及各种配置的集合，它也是使用XML格式编写的，一个标准的pom配置长这样：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.test</groupId> <artifactId>HelloWorld</artifactId> <version>1.0-SNAPSHOT</version> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> </project> \",\"我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。\"]},\"1003\":{\"h\":\"项目标识\",\"t\":[\"groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目\",\"别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标\",\"所有的项目一般都有自己的Maven坐标\",\"因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入：\",\"groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。\",\"artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。\",\"version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）\",\"properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为17，同时下面的源代码编码格式为UTF-8，无需进行修改。\"]},\"1004\":{\"c\":[\"code\"]},\"1005\":{\"c\":[\"javaweb\",\"Maven\"]},\"1006\":{\"h\":\"Maven2 - 依赖导入\"},\"1007\":{\"h\":\"Maven2\"},\"1008\":{\"h\":\"Maven依赖导入\",\"t\":[\"我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？\",\"我们可以创建一个dependencies节点：\",\"<dependencies> //里面填写的就是所有的依赖 </dependencies> \",\"那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？\",\"我们可以在：https://central.sonatype.com 进行查询\",\"直接搜索Lombok即可，打开后可以看到已经给我们写出了依赖的坐标：\",\"<dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.36</version> </dependency> \",\"我们直接将其添加到dependencies节点中即可\",\"现在我们来编写一个测试用例看看依赖导入成功了没有：\",\"public class Main { public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18); System.out.println(student); } } \",\"@Data @AllArgsConstructor public class Student { String name; int age; } \",\"项目运行成功，表示成功导入了依赖。\"]},\"1009\":{\"h\":\"Maven依赖管理原理\",\"t\":[\"那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程：\",\"alt text\",\"通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（可以自行搭建私服）\",\"几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（因此Maven第一次导入依赖是需要联网的，否则无法下载）\",\"远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题。\",\"在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。\"]},\"1010\":{\"h\":\"修改国内镜像源\",\"t\":[\"注意： 因为中心仓库服务器位于国外，下载速度缓慢，可能在导入依赖时会出现卡顿等问题，我们需要使用国内的镜像仓库服务器来加速访问（镜像仓库与中心仓库自动同步所有依赖，访问速度更快）有两种方式配置：\",\"可以配置IDEA自带的Maven插件远程仓库镜像地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑，找到mirros标签，添加以下内容：\",\"<mirror> <id>aliyunmaven</id> <mirrorOf>central</mirrorOf> <name>阿里云公共仓库</name> <url>https://maven.aliyun.com/repository/public</url> </mirror> \",\"自行前往Maven官网并下载最新版的Maven安装，然后将IDEA的Maven配置为我们自行安装的位置（好处是IDEA更新后不需要重新配置）可以一直使用，镜像配置方式同第1步。\",\"这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了）\"]},\"1011\":{\"c\":[\"code\"]},\"1012\":{\"c\":[\"javaweb\",\"Maven\"]},\"1013\":{\"h\":\"Maven3 - 依赖作用域\"},\"1014\":{\"h\":\"Maven3 - 依赖作用域\"},\"1015\":{\"h\":\"Maven依赖作用域\",\"t\":[\"除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：\",\"type：依赖的类型，对于项目坐标定义的packaging。 大部分情况下，该元素不必声明，其默认值为jar\",\"scope：依赖的范围（作用域，着重讲解）\",\"optional：标记依赖是否可选\",\"exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）\"]},\"1016\":{\"h\":\"属性\",\"t\":[\"我们着重来讲解一下scope属性，它决定了依赖的作用域范围：\",\"compile ：默认的依赖有效范围，如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围，此范围表示在编译、运行、测试时均有效。\",\"provided ：仅在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖 比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。\",\"runtime ：在运行、测试时有效，但是在编译代码时无效。 比如JDBC驱动就是典型的只需要运行时使用，因为JDBC驱动由数据库厂商开发，我们使用的始终是JDK中提供的接口，不需要直接使用特定驱动中的类或是方法，因此只需在运行时包含即可。\",\"test ：只在测试时有效 例如：JUnit框架，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，所以这个选项非常适合测试相关的框架。\"]},\"1017\":{\"h\":\"测试导入\",\"t\":[\"这里我们来测试一下JUnit，我们可以在网站上搜索JUnit的依赖，我们这里导入最新的JUnit5作为依赖：\",\"<dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> \",\"我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用：\",\"public class MainTest { @Test public void test(){ System.out.println(\\\"测试\\\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); } } \",\"因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖：\",\"<dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> \",\"我们发现，Maven还给我们提供了一个resource目标，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <settings> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/> <setting name=\\\"cacheEnabled\\\" value=\\\"true\\\"/> <setting name=\\\"logImpl\\\" value=\\\"JDK_LOGGING\\\" /> </settings> <!-- 需要在environments的上方 --> <typeAliases> <package name=\\\"com.test.entity\\\"/> </typeAliases> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.cj.jdbc.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/web_study\\\"/> <property name=\\\"username\\\" value=\\\"test\\\"/> <property name=\\\"password\\\" value=\\\"123456\\\"/> </dataSource> </environment> </environments> <mappers> <mapper class=\\\"com.test.mapper.TestMapper\\\"/> </mappers> </configuration> \",\"现在我们创建一下测试用例，顺便带大家回顾一下JUnit5的使用：\",\"public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\\\"mybatis.xml\\\")); } @DisplayName(\\\"Mybatis数据库测试\\\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } } } \"]},\"1018\":{\"h\":\"第四个作用域 - 导入本地jar包\",\"t\":[\"那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？\",\"我们可以使用第四种作用域：\",\"system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包。\",\"<dependency> <groupId>javax.jntm</groupId> <artifactId>lbwnb</artifactId> <version>2.0</version> <scope>system</scope> <systemPath>C://学习资料/4K高清无码/test.jar</systemPath> </dependency> \",\"比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。\"]},\"1019\":{\"c\":[\"code\"]},\"1020\":{\"c\":[\"javaweb\",\"Maven\"]},\"1021\":{\"h\":\"Maven4 - 导入本地依赖\"},\"1022\":{\"h\":\"Maven4 - 导入本地依赖\"},\"1023\":{\"h\":\"Maven项目导入自己项目\",\"t\":[\"如何在其他项目中引入我们自己编写的Maven项目作为依赖使用。\",\"这里我们创建一个用于测试的简单项目：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.0-SNAPSHOT</version> ... </project> \",\"public class TestUtils { public static void test() { System.out.println(\\\"抛开事实不谈，你们就没有一点错吗？\\\"); } } \",\"接着我们点击右上角的Maven选项\",\"然后执行install或直接在命令行中输入mvn install来安装我们自己的项目到本地Maven仓库中。\",\"接着我们就可以在需要使用此项目作为依赖的其他项目中使用它了，只需要填写和这边一样的坐标：\",\"<dependency> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"接着我们就可以在项目中直接使用了：\",\"public static void main(String[] args) { TestUtils.test(); } \"]},\"1024\":{\"h\":\"依赖传递\",\"t\":[\"注意，如果我们的旧项目中引入了一些其他的依赖，那么此依赖是会一起被传递的\",\"比如这里我们添加了MyBatis的依赖到原项目中：\",\"<dependencies> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.16</version> </dependency> </dependencies> \",\"此时在引入此项目的其他项目中，此依赖也被一起传递\",\"也就是说，当我们的项目依赖于其他内容时，为了保证完整性，默认情况下会一并引入所有此项目包含的依赖项。\"]},\"1025\":{\"h\":\"可选依赖\",\"t\":[\"作用在被导入的项目中\",\"在某些情况下，可能我们并不希望某些依赖直接被项目连带引入，因此，当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的\",\"默认在导入依赖时，不会导入可选的依赖：\",\"<optional>true</optional> \",\"比如Mybatis的POM文件中，就存在大量的可选依赖：\",\"<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.30</version> <optional>true</optional> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.7.30</version> <optional>true</optional> </dependency> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.17</version> <optional>true</optional> </dependency> ... \",\"由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。\"]},\"1026\":{\"h\":\"排除依赖中的不必要依赖\",\"t\":[\"作用在我们自己的项目中\",\"现在我们可以让使用此项目作为依赖的项目不使用可选依赖，但是如果别人的项目中没有将我们不希望的依赖作为可选依赖，这就导致我们还是会连带引入这些依赖\",\"这个时候我们就可以通过排除依赖来防止添加不必要的依赖，只需添加exclusion标签即可：\",\"<dependency> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.1-SNAPSHOT</version> <exclusions> <exclusion> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <!-- 可以不指定版本号，只需要组名和项目名称 --> </exclusion> </exclusions> </dependency> \",\"此时我们通过这种方式手动排除了Test项目中包含的MyBatis依赖，这样项目中就不会包含此依赖了。\"]},\"1027\":{\"c\":[\"code\"]},\"1028\":{\"c\":[\"javaweb\",\"Maven\"]},\"1029\":{\"h\":\"Maven5 - 继承和多模块 + 测试和打包\"},\"1030\":{\"h\":\"Maven5 - 继承、多模块 + 测试和打包\"},\"1031\":{\"h\":\"Maven继承和多模块\"},\"1032\":{\"h\":\"继承\",\"t\":[\"一个Maven项目可以继承自另一个Maven项目\",\"比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。\",\"在我们学习到SpringBoot或是SpringCloud开发时，很多项目往往都会采用这种多模块子项目的形式的去编写，来更加合理地对项目中代码进行职责划分。\",\"(在一个项目内部在创建一个项目就行) 要创建一个子项目非常简单，我们只需右键左侧栏，新建模块，来创建一个子项目：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <parent> <artifactId>MavenTest</artifactId> <groupId>org.example</groupId> <version>1.0-SNAPSHOT</version> </parent> <modelVersion>4.0.0</modelVersion> <artifactId>ChildModel</artifactId> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> </properties> </project> \",\"我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目\",\"子项目直接继承父项目的groupId，子项目会继承父项目的所有依赖，我们来编写一个测试用例尝试一下:\",\"import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\\\"我是日志信息\\\"); } } \",\"可以看到，子项目也成功继承了Lombok依赖。\"]},\"1033\":{\"h\":\"多模块\",\"t\":[\"我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理\",\"我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。\",\"<dependencyManagement> <dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.22</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> </dependencies> </dependencyManagement> \",\"我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可：\",\"<dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <scope>provided</scope> </dependency> </dependencies> \",\"当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承：\",\"<dependencies> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> </dependencies> <dependencyManagement> <dependencies> ... \"]},\"1034\":{\"h\":\"Maven测试和打包\",\"t\":[\"我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期\",\"实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：\",\"clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。\",\"validate命令可以验证项目的可用性。\",\"compile命令可以将项目编译为.class文件。\",\"install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用\",\"verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等）\",\"所有的命令在执行完成之后都会显示BUILD SUCCESS，否则就是在执行过程中出现了什么错误。\"]},\"1035\":{\"h\":\"命令\",\"t\":[\"除了上述介绍的几种命令外，我们还可以通过使用test命令，一键测试所有位于test目录下的测试案例，但是请注意默认的test命令有以下要求：\",\"测试类的名称必须是以Test结尾，比如MainTest\",\"测试方法上必须标注@Test注解或是其他标记JUnit测试案例的注解\",\"public class MainTest { @Test public void test() { System.out.println(\\\"我是测试\\\"); } } \"]},\"1036\":{\"h\":\"命令\",\"t\":[\"我们接着来看package命令，它用于将我们的项目打包为jar文件，以供其他项目作为依赖引入，或是作为一个可执行的Java应用程序运行。\",\"我们可以直接点击package来进行打包操作。\",\"注意，在使用package命令打包之前也会自动执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过\",\"选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true来以跳过测试的方式进行打包。\",\"接着在target目录下会出现我们打包完成的jar包，在JavaSE中我们就给大家介绍过\",\"一个jar包实际上就是对我们生成的字节码文件进行的压缩打包，因此，我们也可以使用常见的压缩工具打开jar包查看其内部文件。\",\"alt text\",\"此时jar包中已经包含了我们项目中编写的类了，可以直接被其他项目导入使用。\"]},\"1037\":{\"h\":\"打包成可执行文件\",\"t\":[\"当然，以上方式存在一定的问题，比如这里并没有包含项目中用到的一些其他依赖，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们提供的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包：\",\"<build> <plugins> <plugin> <artifactId>maven-assembly-plugin</artifactId> <version>3.1.0</version> <configuration> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> <archive> <manifest> <addClasspath>true</addClasspath> <mainClass>com.test.Main</mainClass> </manifest> </archive> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin> </plugins> </build> \",\"导入插件后，我们可以重新进行一次打包任务，等待打包完成即可得到我们的Jar文件，此时会出现两个文件\",\"其中一个是之前的正常打包得到的jar文件，还有一个就是包含了所有依赖以及配置了主类的jar文件。\",\"我们只需要执行java -jar命令即可运行打包好的Java程序\"]},\"1038\":{\"h\":\"多模块测试打包\",\"t\":[\"对父项目执行的任何操作除了作用于本身，还会作用于他的所有子项目。\",\"多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom (此时父项目不会打包成 jar)\",\"<packaging>pom</packaging> \",\"packing默认是jar类型，如果不作配置，maven会将该项目打成jar包：\",\"作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build直到所有任务都完成。\"]},\"1039\":{\"c\":[\"code\"]},\"1040\":{\"c\":[\"javaweb\",\"Maven\"]},\"1041\":{\"h\":\"Content - 网络基础1\"},\"1042\":{\"h\":\"网络基础1\",\"t\":[\"在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：\",\"万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用链接的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档，在一个客户程序主窗口上显示出的万维网文档称为页面。\",\"URL的格式为：\",\"<协议>://<主机>:<端口>/<路径>\",\"协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。\",\"主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问）\",\"端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。\",\"路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。\",\"接着了解一下什么是HTTP协议：\",\"HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。\",\"HTTP的传输原理：\",\"HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。\",\"HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理：\",\"点击查看源网页\",\"TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。\",\"而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。\",\"点击查看源网页\",\"HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？\",\"我们来看一下HTTP的传输过程：\",\"点击查看源网页\",\"用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。 当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。 服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。\",\"因此，我们的浏览器请求一个页面，需要两倍的往返时间。\",\"最后，我们再来了解一下HTTP的报文结构：\",\"image-20230306164008613\",\"由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。\"]},\"1043\":{\"c\":[\"code\"]},\"1044\":{\"c\":[\"javaweb\"]},\"1045\":{\"h\":\"Content - Tomact\"},\"1046\":{\"h\":\"网络基础2\"},\"1047\":{\"h\":\"Tomact 安装\",\"t\":[\"Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。\",\"那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：https://tomcat.apache.org/download-10.cgi\",\"下载：64-bit Windows zip\",\"下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开高级系统设置，打开环境变量，添加一个新的系统变量，变量名称为JRE_HOME，填写JDK的安装目录+/jre，比如Zulujdk默认就是：C:\\\\Program Files\\\\Zulu\\\\zulu-8\\\\jre\",\"设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。\",\"如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开conf文件夹，找到logging.properties文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式：\",\"java.util.logging.ConsoleHandler.encoding = GBK \",\"现在重新启动服务器，就可以正常显示中文了。\",\"服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：http://localhost:8080/\",\"Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。\",\"整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹：\",\"lib目录：Tomcat服务端运行的一些依赖，不用关心。\",\"logs目录：所有的日志信息都在这里。\",\"temp目录：存放运行时产生的一些临时文件，不用关心。\",\"work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及）\",\"webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：\",\"我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。\",\"我们也可以访问example项目，只需要在后面填写路径即可：http://localhost:8080/examples/\",\"或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/\",\"Tomcat还自带管理页面，我们打开：http://localhost:8080/manager\",\"提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容：\",\"You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp.\",\"For example, to add the manager-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above.\",\"<role rolename=\\\"manager-gui\\\"/> <user username=\\\"tomcat\\\" password=\\\"s3cret\\\" roles=\\\"manager-gui\\\"/> \",\"Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single manager role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.\",\"manager-gui - allows access to the HTML GUI and the status pages\",\"manager-script - allows access to the text interface and the status pages\",\"manager-jmx - allows access to the JMX proxy and the status pages\",\"manager-status - allows access to the status pages only\",\"The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:\",\"Users with the manager-gui role should not be granted either the manager-script or manager-jmx roles.\",\"If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.\",\"For more information - please see the Manager App How-To.\",\"现在我们按照上面的提示，去配置文件中进行修改：\",\" <role rolename=\\\"manager-gui\\\"/> <user username=\\\"admin\\\" password=\\\"admin\\\" roles=\\\"manager-gui\\\"/> \",\"现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。\",\"同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。\",\"我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。\",\"我们可以直接通过 http://localhost:8080/test/ 来进行访问。\"]},\"1048\":{\"h\":\"IDEA MAVEN 构建 web 项目\",\"t\":[\"新建项目，选择 Java Enterprise 项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。\"]},\"1049\":{\"c\":[\"code\"]},\"1050\":{\"c\":[\"javaweb\"]},\"1051\":{\"h\":\"Content - Servlet1\"},\"1052\":{\"h\":\"网络基础3\"},\"1053\":{\"h\":\"Servlet\",\"t\":[\"Servlet 是 Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的 Servlet。\",\"我们可以通过实现 Servlet 来进行动态网页响应，使用Servlet，不再是直接由Tomcat 服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java 代码进行动态拼接的结果，它能够很好地实现动态网页的返回。\",\"当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于 HTTP。\"]},\"1054\":{\"h\":\"创建Servlet\",\"t\":[\"那么如何创建一个Servlet呢，非常简单，我们只需要实现Servlet类即可，并添加注解@WebServlet来进行注册。\",\"@WebServlet(\\\"/test\\\") public class TestServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return \\\"\\\"; } @Override public void destroy() { } } \",\"除了直接编写一个类，我们也可以在web.xml中进行注册，现将类上@WebServlet的注解去掉：\",\"<servlet> <servlet-name>test</servlet-name> <servlet-class>com.example.webtest.TestServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>test</servlet-name> <url-pattern>/test</url-pattern> </servlet-mapping> \",\"这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。\",\"实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中：\",\"<!-- The mapping for the default servlet --> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> <!-- The mappings for the JSP servlet --> <servlet-mapping> <servlet-name>jsp</servlet-name> <url-pattern>*.jsp</url-pattern> <url-pattern>*.jspx</url-pattern> </servlet-mapping> \",\"我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。\",\"我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。\"]},\"1055\":{\"h\":\"Servlet 的生命周期\",\"t\":[\"我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是service方法，因此，一个Servlet的生命周期为：\",\"首先执行构造方法完成 Servlet 初始化\",\"Servlet 初始化后调用 init () 方法。\",\"Servlet 调用 service() 方法来处理客户端的请求。\",\"Servlet 销毁前调用 destroy() 方法。\",\"最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\",\"现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次service方法，来让我们处理用户的请求，并将结果响应给用户。\"]},\"1056\":{\"h\":\"方法\",\"t\":[\"每次访问对应的 url 时，都会单独创建一个线程来处理执行 sevice 函数。\",\"在 service 方法 中，还有两个参数，ServletRequest和ServletResponse\",\"实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个ServletRequest对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，我们可以从 ServletRequest 获取所有的请求内容。\",\"HTTP请求报文中的所有内容，都可以从ServletRequest对象中获取，同理，ServletResponse就是我们需要返回给浏览器的HTTP响应报文实体类封装。\"]},\"1057\":{\"h\":\"内容\",\"t\":[\"对应用户发起的请求信息，我们可以获取请求的一些信息：\",\"@Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现） HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getProtocol()); //获取协议版本 System.out.println(request.getRemoteAddr()); //获取访问者的IP地址 System.out.println(request.getMethod()); //获取请求方法 //获取头部信息 Enumeration<String> enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()){ String name = enumeration.nextElement(); System.out.println(name + \\\": \\\" + request.getHeader(name)); } } \",\"我们发现，整个HTTP请求报文中的所有内容，都可以通过HttpServletRequest对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。\"]},\"1058\":{\"h\":\"内容\",\"t\":[\"用来传回信息给用户\",\"再来看看ServletResponse，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：\",\"//转换为HttpServletResponse（同上） HttpServletResponse response = (HttpServletResponse) servletResponse; //设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输） response.setHeader(\\\"Content-type\\\", \\\"text/html;charset=UTF-8\\\"); //获取Writer直接写入内容 response.getWriter().write(\\\"我是响应内容！\\\"); //所有内容写入完成之后，再发送给浏览器 \",\"现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。\",\"点击查看源网页\",\"首先 tomcat 里面有许多 servlet 容器，客户端会请求对应的容器中的某些资源或者实例，如果该容器找到了对应的需要的实例就会采用该服务然后返回\"]},\"1059\":{\"h\":\"\",\"t\":[\"首先Servlet有一个直接实现抽象类GenericServlet\",\"这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作\",\"接着来看HttpServlet，它是遵循HTTP协议的一种Servlet，继承自GenericServlet，它根据HTTP协议的规则，完善了service方法。\",\"对应的 service 方法，先看对应请求是否支持Http协议的实现，是的话进行转化 HttpServletRequest 以及 HttpServletResponse，然后去 this.service 来实现具体对应方法的请求，我们只需要重写这些具体方法就行\",\"public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { if (req instanceof HttpServletRequest && res instanceof HttpServletResponse) { HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)res; this.service(request, response); } else { throw new ServletException(\\\"non-HTTP request or response\\\"); } } protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(\\\"GET\\\")) { long lastModified = this.getLastModified(req); if (lastModified == -1L) { this.doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(\\\"If-Modified-Since\\\"); if (ifModifiedSince < lastModified) { this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); } else { resp.setStatus(304); } } } else if (method.equals(\\\"HEAD\\\")) { long lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); } else if (method.equals(\\\"POST\\\")) { this.doPost(req, resp); } else if (method.equals(\\\"PUT\\\")) { this.doPut(req, resp); } else if (method.equals(\\\"DELETE\\\")) { this.doDelete(req, resp); } else if (method.equals(\\\"OPTIONS\\\")) { this.doOptions(req, resp); } else if (method.equals(\\\"TRACE\\\")) { this.doTrace(req, resp); } else if (method.equals(\\\"PATCH\\\")) { this.doPatch(req, resp); } else { String errMsg = lStrings.getString(\\\"http.method_not_implemented\\\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); } } \",\"在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。\",\"在 HttpServlet 源码中已经配置好了对应的 Get, Post, Put 等操作函数和代码，只不过并没有写具体操作，如果直接调用是默认提示没有支持该方法的\",\"以 doGet 为例\",\"在 HttpServlet 源码中\",\"protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String protocol = req.getProtocol(); String msg = lStrings.getString(\\\"http.method_get_not_supported\\\"); resp.sendError(this.getMethodNotSupportedCode(protocol), msg); } \",\"显然表示此时不支持，现在，我们只需要在对应的 Servlet 中重写对应的请求方式，就可以快速完成Servlet的编写。\",\"@Log @WebServlet(\\\"/test\\\") public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"<h1>恭喜你解锁了全新玩法</h1>\\\"); } } \"]},\"1060\":{\"h\":\"@WebServlet注解详解\",\"t\":[\"我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。\"]},\"1061\":{\"h\":\"不同路径配置\",\"t\":[\"首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配：\",\"@WebServlet(\\\"/test/*\\\") \",\"上面的路径表示，所有匹配/test/随便什么的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。\",\"也可以进行某个扩展名称的匹配：\",\"@WebServlet(\\\"*.js\\\") \",\"这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。\"]},\"1062\":{\"h\":\"替换默认路径\",\"t\":[\"那么如果我们的路径为/呢？\",\"@WebServlet(\\\"/\\\") \",\"此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的\",\"此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么就会使用此Servlet进行处理。\"]},\"1063\":{\"h\":\"配置多个访问路径\",\"t\":[\"我们还可以为一个Servlet配置多个访问路径：\",\"@WebServlet({\\\"/test1\\\", \\\"/test2\\\"}) \"]},\"1064\":{\"h\":\"属性\",\"t\":[\"我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet\",\"默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。\",\"@Log @WebServlet(value = \\\"/test\\\", loadOnStartup = 1) public class TestServlet extends HttpServlet { @Override public void init() throws ServletException { super.init(); log.info(\\\"我被初始化了！\\\"); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"<h1>恭喜你解锁了全新玩法</h1>\\\"); } } \"]},\"1065\":{\"c\":[\"code\"]},\"1066\":{\"c\":[\"javaweb\"]},\"1067\":{\"h\":\"Content - Servlet2\"},\"1068\":{\"h\":\"Servlet2\"},\"1069\":{\"h\":\"使用POST请求完成登陆\",\"t\":[\"一般通过 Post 操作来向服务器传输数据\",\"我们需要修改一下我们的Servlet，让其能够接收一个POST请求：\",\"@WebServlet(\\\"/login\\\") public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getParameterMap().forEach((k, v) -> { System.out.println(k + \\\": \\\" + Arrays.toString(v)); }); } } \",\"ParameterMap存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。\",\"对应的前端用 form 来进行提交：\",\"<body> <h1>登录到系统</h1> <form method=\\\"post\\\" action=\\\"login\\\"> <hr> <div> <label> <input type=\\\"text\\\" placeholder=\\\"用户名\\\" name=\\\"username\\\"> </label> </div> <div> <label> <input type=\\\"password\\\" placeholder=\\\"密码\\\" name=\\\"password\\\"> </label> </div> <div> <button>登录</button> </div> </form> </body> \",\"通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login（注意不同路径的写法），也就是我们上面编写的Servlet路径。\",\"运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。\"]},\"1070\":{\"h\":\"实现简单登录功能\",\"t\":[\"根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作\"]},\"1071\":{\"h\":\"Mybatis 配置\",\"t\":[\"去数据库里创建一个表作为测试\",\"在 pom.xml 中装好 mybatis 以及 数据库驱动 mysql\",\" <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> \",\"在 Resources 文件夹写 mybatis-config.xml 配置文件 其中，驱动名就是对应的 com.mysql.jc.jdbc.Driver，其他就很好找的\",\" <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"再去编写对应逻辑，创建一个实体类以及Mapper来进行用户信息查询： Mapper创在对应的Mapper文件夹下，然后去mybatis-config.xml填写对应mapper的配置\",\"@Data public class User { String username; String password; } \",\"public interface UserMapper { @Select(\\\"select * from users where username = #{username} and password = #{password}\\\") User getUser(@Param(\\\"username\\\") String username, @Param(\\\"password\\\") String password); } \",\"<mappers> <mapper class=\\\"com.example.dao.UserMapper\\\"/> </mappers> \"]},\"1072\":{\"h\":\"实现登录功能\",\"t\":[\"初始化得到 mybatis 配置连接数据库\",\"在 doPost 中写对应的登录逻辑\",\"@WebServlet(value = \\\"/login\\\", loadOnStartup = 1) public class LoginServlet extends HttpServlet { SqlSessionFactory factory; @Override public void init() throws ServletException { try { factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\\\"mybatis-config.xml\\\")); } catch (IOException e) { throw new RuntimeException(e); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //首先设置一下响应类型 resp.setContentType(\\\"text/html;charset=UTF-8\\\"); //获取POST请求携带的表单数据 Map<String, String[]> map = req.getParameterMap(); //判断表单是否完整 if(map.containsKey(\\\"username\\\") && map.containsKey(\\\"password\\\")) { String username = req.getParameter(\\\"username\\\"); String password = req.getParameter(\\\"password\\\"); try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); //判断用户是否登陆成功，若查询到信息则表示存在此用户 if(user != null){ System.out.println(user.toString()); resp.getWriter().write(\\\"登陆成功！\\\"); }else { resp.getWriter().write(\\\"登陆失败，请验证您的用户名或密码！\\\"); } } }else { resp.getWriter().write(\\\"错误，您的表单数据不完整！\\\"); } } } \"]},\"1073\":{\"h\":\"上传和下载文件\"},\"1074\":{\"h\":\"下载\",\"t\":[\"首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载：\",\"@WebServlet(\\\"/file\\\") public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"image/png\\\"); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(\\\"icon.png\\\"); } } \",\"为了更加快速地编写IO代码，我们可以引入一个工具库 commons-io：\",\"<dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>2.6</version> </dependency> \",\"使用此类库可以快速完成IO操作：\",\"resp.setContentType(\\\"image/png\\\"); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(\\\"icon.png\\\"); //直接使用copy方法完成转换 IOUtils.copy(inputStream, outputStream); \",\"现在我们在前端页面添加一个链接，用于下载此文件：\",\"<hr> <a href=\\\"file\\\" download=\\\"icon.png\\\">点我下载高清资源</a> \"]},\"1075\":{\"h\":\"上传\",\"t\":[\"首先我们编写前端部分：\",\"<form method=\\\"post\\\" action=\\\"file\\\" enctype=\\\"multipart/form-data\\\"> <div> <input type=\\\"file\\\" name=\\\"test-file\\\"> </div> <div> <button>上传文件</button> </div> </form> \",\"注意必须添加enctype=\\\"multipart/form-data\\\"，来表示此表单用于文件传输。\",\"现在我们来修改一下Servlet代码：\",\"@MultipartConfig @WebServlet(\\\"/file\\\") public class FileServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try(FileOutputStream stream = new FileOutputStream(\\\"xxxx\\\")){ Part part = req.getPart(\\\"test-file\\\"); IOUtils.copy(part.getInputStream(), stream); resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"文件上传成功！\\\"); } } } \",\"part 为网站中上传的内容，将其copy到stream中\",\"注意，必须添加@MultipartConfig注解来表示此Servlet用于处理文件上传请求。\",\"现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。\"]},\"1076\":{\"h\":\"使用XHR请求数据\",\"t\":[\"现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。\",\"这个时候就需要我们在网页展示时向后端发起请求，并根据后端响应的结果，动态地更新页面中的内容\",\"要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新：\",\"function updateTime() { let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { document.getElementById(\\\"time\\\").innerText = xhr.responseText } }; xhr.open('GET', 'time', true); xhr.send(); } \",\"接着修改一下前端页面，添加一个时间显示区域：\",\"<hr> <div id=\\\"time\\\"></div> <br> <button onclick=\\\"updateTime()\\\">更新数据</button> <script> updateTime() </script> \",\"最后创建一个Servlet用于处理时间更新请求：\",\"@WebServlet(\\\"/time\\\") public class TimeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy年MM月dd日 HH:mm:ss\\\"); String date = dateFormat.format(new Date()); resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(date); } } \",\"GET请求也能传递参数, 后面跟 ? 就行\"]},\"1077\":{\"c\":[\"code\"]},\"1078\":{\"c\":[\"javaweb\"]},\"1079\":{\"h\":\"Content - Servlet3\"},\"1080\":{\"h\":\"Servlet3\"},\"1081\":{\"h\":\"重定向与请求转发\"},\"1082\":{\"h\":\"重定向 302\",\"t\":[\"当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。\",\"当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。\",\"实现重定向很简单，只需要调用一个方法即可\",\"resp.sendRedirect(\\\"time\\\"); \",\"调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。\",\"现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。\",\"除了用写好的 resp.sendRedircet() 来进行重定向操作外，我们可以直接发送 302 + 定义 Location 的位置即可\",\"resp.setStatus(302); resp.setHeader(\\\"Location\\\", \\\"xxxx\\\"); \"]},\"1083\":{\"h\":\"请求转发\",\"t\":[\"请求转发可以携带数据，重定向无法携带数据\",\"那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面\",\"而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。\",\"req.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。\",\"现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。\",\"那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。\",\"现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理：\",\"@Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } \",\"再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。\",\"请求转发可以携带数据！\",\"req.setAttribute(\\\"test\\\", \\\"我是请求转发前的数据\\\"); req.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"System.out.println(req.getAttribute(\\\"test\\\")); \",\"通过setAttribute方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。\",\"重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？\",\"我们可以使用即将要介绍的ServletContext对象。\",\"最后总结，两者的区别为：\",\"请求转发是一次请求，重定向是两次请求\",\"请求转发地址栏不会发生改变， 重定向地址栏会发生改变\",\"请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了\",\"请求转发只能转发给内部的Servlet\"]},\"1084\":{\"h\":\"ServletContext对象 - 全局存储通信\",\"t\":[\"ServletContext全局唯一，它是属于整个Web应用程序的\",\"可以通过getServletContext()来获取到此对象。\",\"此对象也能设置附加值：\",\"ServletContext context = getServletContext(); context.setAttribute(\\\"test\\\", \\\"我是重定向之前的数据\\\"); resp.sendRedirect(\\\"time\\\"); \",\"System.out.println(getServletContext().getAttribute(\\\"test\\\")); \",\"因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。\",\"它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：\",\"context.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）\",\"contest.getResourceAsStream() \"]},\"1085\":{\"h\":\"初始化参数\",\"t\":[\"初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。\",\"我们可以给一个Servlet添加一些初始化参数：\",\"@WebServlet(value = \\\"/login\\\", initParams = { @WebInitParam(name = \\\"test\\\", value = \\\"我是一个默认的初始化参数\\\") }) \",\"它也是以键值对形式保存的，我们可以直接通过Servlet的getInitParameter方法获取：\",\"System.out.println(getInitParameter(\\\"test\\\")); \"]},\"1086\":{\"h\":\"全局定义初始化参数\",\"t\":[\"但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可：\",\"<context-param> <param-name>lbwnb</param-name> <param-value>我是全局初始化参数</param-value> </context-param> \",\"我们需要使用ServletContext来读取全局初始化参数：\",\"ServletContext context = getServletContext(); System.out.println(context.getInitParameter(\\\"lbwnb\\\")); \",\"有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。\"]},\"1087\":{\"c\":[\"code\"]},\"1088\":{\"c\":[\"javaweb\"]},\"1089\":{\"h\":\"Content - Cookie + Session\"},\"1090\":{\"h\":\"Cookie\",\"t\":[\"Cookie, 可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。\"]},\"1091\":{\"h\":\"简单使用\",\"t\":[\"在服务器端发送 Cookie 的请求头\",\"Cookie cookie = new Cookie(\\\"test\\\", \\\"yyds\\\"); resp.addCookie(cookie); resp.sendRedirect(\\\"time\\\"); \",\"对应的服务器响应头就会包含 Set-Cookie：\",\"HTTP/1.1 302 Set-Cookie: test=123 Location: time Content-Type: text/html;charset=UTF-8 Content-Length: 0 Date: Thu, 24 Jul 2025 07:09:50 GMT Keep-Alive: timeout=20 Connection: keep-alive \",\"之后网页收到服务器的响应请求后就会存储对应 Cookie 在本地, 当满足条件时，网页发送的请求就会携带所有的 Cookie, 服务器端可以进行获取\",\"for (Cookie cookie : req.getCookies()) { System.out.println(cookie.getName() + \\\": \\\" + cookie.getValue()); } \",\"对应的用户请求头就会包含 Cookie\",\"GET /WebTest_war_exploded/time HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Cache-Control: max-age=0 Connection: keep-alive Cookie: test=123 Host: localhost:8081 Referer: http://localhost:8081/WebTest_war_exploded/ Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0 \",\"alt text\"]},\"1092\":{\"h\":\"属性\",\"t\":[\"一个Cookie包含信息：\",\"name - Cookie的名称，Cookie一旦创建，名称便不可更改\",\"value - Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码\",\"maxAge - Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。\",\"secure - 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。\",\"path - Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。\",\"domain - 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。\",\"comment - 该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。\",\"version - Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范\",\"我们发现，最关键的其实是name、value、maxAge、domain属性。\",\"尝试修改一下maxAge来看看失效时间：\",\"cookie.setMaxAge(20); \",\"设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。\"]},\"1093\":{\"h\":\"应用\",\"t\":[\"可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中\",\"如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。\",\"那么首先，我们先在前端页面的表单中添加一个勾选框：\",\"<div> <label> <input type=\\\"checkbox\\\" placeholder=\\\"记住我\\\" name=\\\"remember-me\\\"> 记住我 </label> </div> \",\"接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地：\",\"if(map.containsKey(\\\"remember-me\\\")){ //若勾选了勾选框，那么会此表单信息 Cookie cookie_username = new Cookie(\\\"username\\\", username); cookie_username.setMaxAge(30); Cookie cookie_password = new Cookie(\\\"password\\\", password); cookie_password.setMaxAge(30); resp.addCookie(cookie_username); resp.addCookie(cookie_password); } \",\"然后，我们修改一下默认的请求地址，现在一律通过http://localhost:8080/yyds/login进行登陆，那么我们需要添加GET请求的相关处理：\",\"@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie[] cookies = req.getCookies(); if(cookies != null){ String username = null; String password = null; for (Cookie cookie : cookies) { if(cookie.getName().equals(\\\"username\\\")) username = cookie.getValue(); if(cookie.getName().equals(\\\"password\\\")) password = cookie.getValue(); } if(username != null && password != null){ //登陆校验 try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); if(user != null){ resp.sendRedirect(\\\"time\\\"); return; //直接返回 } } } } req.getRequestDispatcher(\\\"/\\\").forward(req, resp); //正常情况还是转发给默认的Servlet帮我们返回静态页面 } \",\"现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。\",\"现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。\"]},\"1094\":{\"h\":\"Session\",\"t\":[\"Session 是基于 Cookie 设计的\",\"由于HTTP是无连接的，所以无法辨别当前的请求是来自哪个用户发起，而 Session 就是用来处理这种问题的\",\"每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。\"]},\"1095\":{\"h\":\"原理\",\"t\":[\"Session实际上是基于Cookie实现的，它会给浏览器设定一个叫做JSESSIONID的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。\",\"具体内容是保存在服务器端的 Session 对象里，网页端只是保存了JSESSIONID来识别\",\"alt text\"]},\"1096\":{\"h\":\"应用\",\"t\":[\"那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从HttpSession中读取到存储在会话中的数据：\",\"在登录界面，服务端发出响应请求时，加入 Session:\",\"HttpSession session = req.getSession(); session.setAttribute(\\\"user\\\", user); \",\"对应用户会收到相应请求，Set-Cookie:\",\"HTTP/1.1 302 Set-Cookie: JSESSIONID=84ABDD94FB965F266818B9DBB6172807; Path=/WebTest_war_exploded; HttpOnly Location: time Content-Type: text/html;charset=UTF-8 Content-Length: 0 Date: Thu, 24 Jul 2025 09:54:07 GMT Keep-Alive: timeout=20 Connection: keep-alive \",\"在主页界面(\\\\time)，服务端处理请求时，根据 Session 来判断是否登录：\",\"如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：\",\"HttpSession session = req.getSession(); User user = (User) session.getAttribute(\\\"user\\\"); if(user == null) { resp.sendRedirect(\\\"login\\\"); return; } \",\"对应，用户的发送请求会携带对应的Cookie，包含 JSESSIONID\",\"GET /WebTest_war_exploded/time HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Cache-Control: max-age=0 Connection: keep-alive Cookie: test=123; JSESSIONID=84ABDD94FB965F266818B9DBB6172807 Host: localhost:8081 Referer: http://localhost:8081/WebTest_war_exploded/login Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0 sec-ch-ua: \\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Microsoft Edge\\\";v=\\\"138\\\" \"]},\"1097\":{\"h\":\"配置\",\"t\":[\"Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件 web.xml 中修改过期时间：\",\"<session-config> <session-timeout>1</session-timeout> </session-config> \",\"我们也可以在代码中使用invalidate方法来使Session立即失效：\",\"session.invalidate(); \",\"现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。\"]},\"1098\":{\"c\":[\"code\"]},\"1099\":{\"c\":[\"javaweb\"]},\"1100\":{\"h\":\"Content - Filter + Listener\"},\"1101\":{\"h\":\"Filter\",\"t\":[\"有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？\",\"过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet\",\"而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。\",\"alt text\"]},\"1102\":{\"h\":\"添加过滤器\",\"t\":[\"添加一个过滤器非常简单，只需要实现Filter接口，并添加@WebFilter注解即可：\",\"@WebFilter(\\\"/*\\\") //路径的匹配规则和Servlet一致，这里表示匹配所有请求 public class TestFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { } } \",\"这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器：\",\"HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getRequestURL()); \",\"我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。\"]},\"1103\":{\"h\":\"允许请求通过\",\"t\":[\"那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句：\",\"filterChain.doFilter(servletRequest, servletResponse); \",\"由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果：\",\"@WebFilter(\\\"/*\\\") public class TestFilter2 implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是2号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); } } \",\"由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。\",\"我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。\",\"alt text\",\"实际上，当doFilter方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下：\",\"@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是2号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\\\"我是2号过滤器，处理后\\\"); } \",\"@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是1号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\\\"我是1号过滤器，处理后\\\"); } \",\"即，在 filterChain.doFilter 之后的语句需要等处理完，再倒回来处理\",\"alt text\"]},\"1104\":{\"h\":\"接口\",\"t\":[\"同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写：\",\"public abstract class HttpFilter extends GenericFilter { private static final long serialVersionUID = 7478463438252262094L; public HttpFilter() { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { if (req instanceof HttpServletRequest && res instanceof HttpServletResponse) { this.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain); } else { throw new ServletException(\\\"non-HTTP request or response\\\"); } } protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { chain.doFilter(req, res); } } \",\"那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻：\",\"@WebFilter(\\\"/*\\\") public class MainFilter extends HttpFilter { @Override protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { String url = req.getRequestURL().toString(); //判断是否为静态资源 if(!url.endsWith(\\\".js\\\") && !url.endsWith(\\\".css\\\") && !url.endsWith(\\\".png\\\")){ HttpSession session = req.getSession(); User user = (User) session.getAttribute(\\\"user\\\"); //判断是否未登陆 if(user == null && !url.endsWith(\\\"login\\\")){ res.sendRedirect(\\\"login\\\"); return; } } //交给过滤链处理 chain.doFilter(req, res); } } \",\"现在，我们的页面已经基本完善为我们想要的样子了。\"]},\"1105\":{\"h\":\"Listener\",\"t\":[\"监听器并不是我们学习的重点内容，那么什么是监听器呢？\",\"如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。\",\"alt text\",\"默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可：\",\"@WebListener public class TestListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(\\\"有一个Session被创建了\\\"); } } \"]},\"1106\":{\"c\":[\"code\"]},\"1107\":{\"c\":[\"javaweb\"]},\"1108\":{\"h\":\"Content - Tomact类加载机制\"},\"1109\":{\"h\":\"Tomcat类加载机制\",\"t\":[\"Tomcat到底是如何加载和运行我们的Web应用程序的。\",\"Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离\",\"也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问\",\"而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。\",\"img\",\"首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：\",\"Common ClassLoader：Tomcat最基本的类加载器，该加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。\",\"Catalina ClassLoader：Tomcat容器私有的类加载器，该加载路径中的class对于Web应用程序不可见。\",\"Shared ClassLoader：各个Web应用程序共享的类加载器，该加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。\",\"Webapp ClassLoader：各个Web应用程序私有的类加载器，该加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。\",\"JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。\",\"通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的双亲委派机制（即每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。）\",\"比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？\",\"难道Tomcat的开发团队没有考虑到这个问题吗？\",\"alt text\",\"实际上，WebAppClassLoader的加载机制是这样的：\",\"WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。\",\"这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。\"]},\"1110\":{\"c\":[\"code\"]},\"1111\":{\"c\":[\"javaweb\"]},\"1112\":{\"h\":\"Javassm - Spring1\",\"t\":[\"SSM（Spring+SpringMVC+Mybatis）\"]},\"1113\":{\"h\":\"Spring 简介\",\"t\":[\"Spring是一个框架(文档：https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core)\",\"它是为了简化开发而生，它是轻量级的IoC和AOP的容器框架，主要是针对Bean的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。\"]},\"1114\":{\"h\":\"IoC理论基础 1\",\"t\":[\"Spring框架最核心的其实它的IoC容器\"]},\"1115\":{\"h\":\"IoC理论介绍\",\"t\":[\"IOC是Inversion of Control的缩写，翻译为：“控制反转”\",\"把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\"]},\"1116\":{\"h\":\"以前耦合情况\",\"t\":[\"在我们之前的图书管理系统Web应用程序中，我们发现，整个程序其实是依靠各个部分相互协作，共同完成一个操作\",\"比如要展示借阅信息列表，那么首先需要使用Servlet进行请求和响应的数据处理，然后请求的数据全部交给对应的Service（业务层）来处理，当Service发现要从数据库中获取数据时，再向对应的Mapper发起请求。\",\"它们之间就像连接在一起的齿轮：\",\"alt text\",\"就像一个团队，每个人的分工都很明确，流水线上的一套操作必须环环相扣，这是一种高度耦合的体系。\",\"但是这样存在一个很严重的问题，很容易出现，之前写好的代码，实现的功能，需要全部推翻，改成新的功能，那么我们就不得不去修改某些流水线上的模块，但是这样一修改，会直接导致整个流水线的引用关系大面积更新。\",\"比如下面的情况：\",\"class A{ private List<B> list; public B test(B b){ return null; } } class C{ public C(B b){} } class B{ } \",\"可以看到，A和C在大量地直接使用B，但是某一天，这个B的实现已经过时了，此时来了个把功能实现的更好的D，我们需要用这个新的类来完成业务了：\",\"alt text\",\"可以看到，因为类之间的关联性太强了，会开始大面积报错，所有之前用了B的类，得挨个进行修改，全都改成D.\",\"因此，高耦合度带来的缺点是很明显的，也是现代软件开发中很致命的问题。\",\"如果要改善这种情况，我们只能将各个模块进行解耦，让各个模块之间的依赖性不再那么地强。\",\"也就是说，Service的实现类，不再由我们决定，而是让程序自己决定，所有的实现类对象，全部交给程序来管理，所有对象之间的关系，也由程序来动态决定，这样就引入了IoC理论。\"]},\"1117\":{\"h\":\"IoC理论\",\"t\":[\"alt text\",\"我们可以将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码。\",\"还是之前的代码，但是有了IoC容器加持之后：\",\"public static void main(String[] args) { A a = new A(); a.test(IoC.getBean(Service.class)); //瞎编的一个容器类，但是是那个意思，即根据所给的接口确定类 //比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B } class A{ private List<Service> list; //一律使用Service，具体实现由IoC容器提供 public Service test(Service b){ return null; } } interface Service{ } //使用Service做一个顶层抽象 class B implements Service{} //B依然是具体实现类，并交给IoC容器管理 \",\"当具体实现类发生修改时，我们同样只需要将新的实现类交给IoC容器管理，这样我们无需修改之前的任何代码：\",\"interface Service{ } class D implements Service{} //现在实现类变成了D，但是之前的代码并不会报错 \",\"这样，即使我们的底层实现类发生了修改，也不会导致与其相关联的类出现错误，而进行大面积修改，通过定义抽象+容器管理的形式，我们就可以将原有的强关联解除。\",\"高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，一个由Spring IoC容器实例化、组装和管理的对象，我们称其为Bean。\"]},\"1118\":{\"h\":\"第一个Spring项目\",\"t\":[\"首先一定要明确，使用Spring首要目的是为了使得软件项目进行解耦，而不是为了去简化代码。\",\"Spring并不是一个独立的框架，它实际上包含了很多的模块：\",\"alt text\",\"而我们首先要去学习的就是Core Container，也就是核心容器模块，只有了解了Spring的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。\",\"Spring是一个非入侵式的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring核心框架的Maven依赖坐标：\",\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>6.0.10</version> </dependency> \",\"注意： 与旧版教程不同的是，Spring 6要求你使用的Java版本为17及以上，包括后面我们在学习SpringMvc时，要求Tomcat版本必须为10以上。\",\"这个依赖中包含了如下依赖：\",\"alt text\",\"这里出现的都是Spring核心相关的内容，如Beans、Core、Context、SpEL以及非常关键的AOP框架\"]},\"1119\":{\"h\":\"使用\",\"t\":[\"Spring会给我们提供IoC容器用于管理Bean，但是我们得先为这个容器编写一个配置文件，我们可以通过配置文件告诉容器需要管理哪些Bean以及Bean的属性、依赖关系等等。\",\"首先我们需要在resource中创建一个Spring配置文件（在resource中创建的文件，会在编译时被一起放到类路径下），命名为test.xml，直接右键点击即可创建：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\\\"> </beans> \",\"Spring为我们提供了一个IoC容器，用于去存放我们需要使用的对象，我们可以将对象交给IoC容器进行管理，当我们需要使用对象时，就可以向IoC容器去索要，并由它来决定给我们哪一个对象。\",\"而我们如果需要使用Spring为我们提供的IoC容器，那么就需要创建一个应用程序上下文，它代表的就是IoC容器，它会负责实例化、配置和组装Bean：\",\"public static void main(String[] args) { //ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种 //因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类 ApplicationContext context = new ClassPathXmlApplicationContext(\\\"test.xml\\\"); //这里写上刚刚的名字 } \",\"比如现在我们要让IoC容器帮助我们管理一个Student对象（Bean），当我们需要这个对象时再申请，那么就需要这样，首先先将Student类定义出来：\",\"package com.test.bean; public class Student { public void hello(){ System.out.println(\\\"Hello World!\\\"); } } \",\"既然现在要让别人帮忙管理对象，那么就不能再由我们自己去new这个对象了，而是编写对应的配置，我们打开刚刚创建的test.xml文件进行编辑，添加：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"/> \",\"这里我们就在配置文件中编写好了对应Bean的信息，之后容器就会根据这里的配置进行处理了。\",\"现在，这个对象不需要我们再去创建了，而是由IoC容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象：\",\"public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"test.xml\\\"); Student student = (Student) context.getBean(\\\"student\\\"); //使用getBean方法来获取对应的对象（Bean） student.hello(); } \",\"同理，我们也可以实现前面IoC提到的例子：\",\"此时有 接口Serivce 和 对应实现类 Aservice\",\"alt text\",\"此时我们去配置文件注册好对应的Aservice的bean\",\"<bean class=\\\"com.test.service.Aservice\\\"/> \",\"然后，我们在项目里使用Service来创建对象，向容器找到对应实现的类：\",\"public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); Service service = (Service) context.getBean(Service.class); System.out.println(service); } } \",\"这样最终实现的类就是对应的 Aservice\",\"alt text\",\"所以，当Aservice被更新了，变成Bservice，将对应的配置文件修改就行，它会自动找到对应接口是否存在bean的实现类。\",\"如果有多个的话，这样是会报错的，后续应该有解决方案。\",\"Exception in thread \\\"main\\\" org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.test.service.Service' available: expected single matching bean but found 2: com.test.service.Aservice#0,com.test.service.Bservice#0 \",\"实际上，这里得到的Student对象是由Spring通过反射机制帮助我们创建的\",\"alt text\"]},\"1120\":{\"c\":[\"code\"]},\"1121\":{\"c\":[\"javassm\",\"Spring\"]},\"1122\":{\"h\":\"Javassm - Spring2 (Bean注册与配置 + 依赖注入)\"},\"1123\":{\"h\":\"IoC理论基础 2\"},\"1124\":{\"h\":\"Bean注册与配置\",\"t\":[\"详细了解一下如何向Spring注册Bean以及Bean的相关配置。\",\"实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans ...> <import resource=\\\"test.xml\\\"/> </beans> \",\"但是为了简单起见，我们还是从单配置文件开始讲起\"]},\"1125\":{\"h\":\"配置并注册\",\"t\":[\"首先我们需要知道如何配置Bean并注册。\",\"要配置一个Bean，只需要添加：\",\"<bean/> \",\"但是这样写的话，Spring无法得知我们要配置的Bean到底是哪一个类，所以说我们还得指定对应的类才可以：\",\"<bean class=\\\"com.test.bean.Student\\\"/> \",\"alt text\",\"可以看到类的旁边出现了Bean的图标，表示我们的Bean已经注册成功了，这样，我们就可以根据类型向容器索要Bean实例对象了：\",\"public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"test.xml\\\"); //getBean有多种形式，其中第一种就是根据类型获取对应的Bean //容器中只要注册了对应类的Bean或是对应类型子类的Bean，都可以获取到 Student student = context.getBean(Student.class); student.hello(); } \",\"表示，当我们尝试获取该类的bean来创建对象时，容器会去找注册的bean是否有对应的类或者其类的子类。\"]},\"1126\":{\"h\":\"创建对象的类存在多个对应\",\"t\":[\"不过在有些时候，Bean的获取可能会出现歧义，我们可以来分别注册两个子类的Bean：\",\"public class ArtStudent extends Student{ public void art(){ System.out.println(\\\"我爱画画\\\"); } } \",\"public class SportStudent extends Student{ public void sport(){ System.out.println(\\\"我爱运动\\\"); } } \",\"<bean class=\\\"com.test.bean.ArtStudent\\\"/> <bean class=\\\"com.test.bean.SportStudent\\\"/> \",\"但是此时我们在创建Student类时，获取Bean时会找到有两个子类都满足：\",\"Student student = context.getBean(Student.class); student.hello(); \",\"运行时得到如下报错：\",\"alt text\",\"这里出现了一个Bean定义不唯一异常，很明显，因为我们需要的类型是Student，但是此时有两个Bean定义都满足这个类型，它们都是Student的子类，此时IoC容器不知道给我们返回哪一个Bean，所以就只能抛出异常了。\",\"因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义：\",\"ArtStudent student = context.getBean(ArtStudent.class); student.art(); \"]},\"1127\":{\"h\":\"属性\",\"t\":[\"那要是两个Bean的类型都是一样的呢？\",\"<bean class=\\\"com.test.bean.Student\\\"/> <bean class=\\\"com.test.bean.Student\\\"/> \",\"这种情况下，就无法使用Class来进行区分了，除了为Bean指定对应类型之外，我们也可以为Bean指定一个名称用于区分：\",\"<bean name=\\\"art\\\" class=\\\"com.test.bean.ArtStudent\\\"/> <bean name=\\\"sport\\\" class=\\\"com.test.bean.SportStudent\\\"/> \",\"name属性就是为这个Bean设定一个独一无二的名称（id属性也可以，跟name功能相同，但是会检查命名是否规范，否则会显示黄标）\",\"不同的Bean名字不能相同，否则报错：\",\"<bean name=\\\"a\\\" class=\\\"com.test.bean.Student\\\"/> <bean name=\\\"b\\\" class=\\\"com.test.bean.Student\\\"/> \",\"这样，这两个Bean我们就可以区分出来了：\",\"Student student = (Student) context.getBean(\\\"a\\\"); student.hello(); \",\"虽然目前这两Bean定义都是一模一样的，也没什么区别，但是这确实是两个不同的Bean，只是类型一样而已，之后我们还可以为这两个Bean分别设置不同的其他属性。\"]},\"1128\":{\"h\":\"别名\",\"t\":[\"我们可以给Bean起名字，也可以起别名\",\"<bean name=\\\"a\\\" class=\\\"com.test.bean.Student\\\"/> <alias name=\\\"a\\\" alias=\\\"test\\\"/> \",\"这样，我们使用别名也是可以拿到对应的Bean的：\",\"Student student = (Student) context.getBean(\\\"test\\\"); student.hello(); \"]},\"1129\":{\"h\":\"IoC容器对象生成原理\",\"t\":[\"那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？\",\"我们现在在主方法中连续获取两次Bean对象：\",\"Student student1 = context.getBean(Student.class); Student student2 = context.getBean(Student.class); System.out.println(student1 == student2); //默认为单例模式，对象始终为同一个 \",\"我们发现，最后得到的结果为true\",\"那么说明每次从IoC容器获取到的对象，始终都是同一个，默认情况下，通过IoC容器进行管理的Bean都是单例模式的，这个对象只会被创建一次。\",\"如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域进行修改\",\"这里一共有两种作用域，第一种是singleton，默认情况下就是这一种，当然还有prototype，表示为原型模式，这种模式每次得到的对象都是一个新的：\",\"Student student1 = context.getBean(Student.class); //原型模式下，对象不再始终是同一个了 Student student2 = context.getBean(Student.class); System.out.println(student1 == student2); \",\"实际上，当Bean的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建，我们之后拿到的都是这个对象。\",\"而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。\"]},\"1130\":{\"h\":\"懒加载\",\"t\":[\"当然，如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以开启懒加载：\",\"<bean class=\\\"com.test.bean.Student\\\" lazy-init=\\\"true\\\"/> \",\"开启懒加载后，只有在真正第一次使用时才会创建对象。\"]},\"1131\":{\"h\":\"规定加载顺序\",\"t\":[\"因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建）那么我们可以使用depends-on来设定前置加载Bean，这样被依赖的Bean一定会在之前加载，比如Teacher应该在Student之前加载：\",\"<bean name=\\\"teacher\\\" class=\\\"com.test.bean.Teacher\\\"/> <bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" depends-on=\\\"teacher\\\"/> \",\"这样就可以保证Bean的加载顺序了。\"]},\"1132\":{\"h\":\"依赖注入\",\"t\":[\"依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。\",\"现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，我们使用容器的目标之一是消除类之间的强关联.\",\"其实现的主要功能是，IoC容器在创建对象时，会根据我们提供的信息作为对象的属性来提前注入到对象中\",\"比如现在有一个教师接口：\",\"public interface Teacher { void teach(); } \",\"具体的实现有两个：\",\"public class ArtTeacher implements Teacher{ @Override public void teach() { System.out.println(\\\"我是美术老师，我教你画画！\\\"); } } \",\"public class ProgramTeacher implements Teacher{ @Override public void teach() { System.out.println(\\\"我是编程老师，我教你学Golang！\\\"); } } \",\"我们的学生一开始有一个老师教他，比如美术老师：\",\"public class Student { private Teacher teacher = new ArtTeacher(); //在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了 public void study(){ teacher.teach(); } } \",\"但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改Student类的定义：\",\"public class Student { private Teacher teacher = new ProgramTeacher(); ... } \",\"可以想象一下，如果现在冒出来各种各样的类都需要这样去用Teacher，那么一旦Teacher的实现发生变化，会导致我们挨个对之前用到Teacher的类进行修改，这就很难受了。\",\"而有了依赖注入之后，Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值\",\"也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中\"]},\"1133\":{\"h\":\"标签\",\"t\":[\"我们可以使用property标签来实现，将bean标签展开：\",\"<bean name=\\\"mathTeacher\\\" class=\\\"com.test.entity.MathTeacher\\\"/> <bean name=\\\"artTeacher\\\" class=\\\"com.test.entity.ArtTeacher\\\"/> <bean class=\\\"com.test.entity.Student\\\"> <property name=\\\"teacher\\\" ref=\\\"artTeacher\\\"/> </bean> \",\"name属性表示该注册的bean对应的对象的指定属性(name值)\",\"ref属性表示赋给这个属性的值来自另一个对应的bean注册对象中\",\"value属性表示赋给这个属性的值为value对应的值\",\"同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法：\",\"public class Student { private Teacher teacher; //要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法 public void setTeacher(Teacher teacher) { this.teacher = teacher; } ... } \",\"alt text\",\"使用property来指定需要注入的值是一个Bean，这里我们选择ProgramTeacher，那么在使用时，Student类中的得到的就是这个Bean的对象了：\",\"Student student = context.getBean(Student.class); student.study(); \",\"alt text\",\"可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置\",\"这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以：\",\"<!-- 只需要修改这里的class即可，现在改为ArtTeacher --> <bean name=\\\"mathTeacher\\\" class=\\\"com.test.entity.MathTeacher\\\"/> <bean name=\\\"artTeacher\\\" class=\\\"com.test.entity.ArtTeacher\\\"/> <bean class=\\\"com.test.entity.Student\\\"> <property name=\\\"teacher\\\" ref=\\\"mathTeacher\\\"/> </bean> \",\"这样，这个Bean的class就变成了新的类型，并且我们不需要再去调整其他位置的代码\",\"通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？\",\"当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"> <property name=\\\"name\\\" value=\\\"卢本伟\\\"/> </bean> \",\"直接使用value可以直接传入一个具体值。\"]},\"1134\":{\"h\":\"构造注入 标签\",\"t\":[\"实际上，在很多情况下，类中的某些参数是在构造方法中就已经完成初始化，而不是创建之后，比如：\",\"public class Student { private final Teacher teacher; //构造方法中完成，所以说是一个final变量 public Student(Teacher teacher){ //Teacher属性是在构造方法中完成的初始化 this.teacher = teacher; } ... } \",\"很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法\",\"我们展开bean标签，添加一个constructor-arg标签：\",\"<bean name=\\\"mathTeacher\\\" class=\\\"com.test.entity.MathTeacher\\\"/> <bean name=\\\"artTeacher\\\" class=\\\"com.test.entity.ArtTeacher\\\"/> <bean class=\\\"com.test.entity.Student\\\"> <constructor-arg name=\\\"teacher\\\" ref=\\\"artTeacher\\\"/> </bean> \",\"这里的constructor-arg就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。\",\"通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机提前到了对象构造时。\"]},\"1135\":{\"h\":\"多种构造函数情况\",\"t\":[\"现在我们的Student类中是这样定义的：\",\"public class Student { private final String name; public Student(String name){ System.out.println(\\\"我是一号构造方法\\\"); this.name = name; } public Student(int age){ System.out.println(\\\"我是二号构造方法\\\"); this.name = String.valueOf(age); } } \",\"此时我们希望使用的是二号构造方法，那么怎么才能指定呢？\",\"有2种方式，我们可以给标签添加类型：\",\"<constructor-arg value=\\\"1\\\" type=\\\"int\\\"/> \",\"也可以指定为对应的参数名称：\",\"<constructor-arg value=\\\"1\\\" name=\\\"age\\\"/> \",\"如果是参数数量不同，就根据参数数量来区分就行\",\"反正只要能够保证我们指定的参数匹配到目标构造方法即可。\"]},\"1136\":{\"h\":\"集合类型情况\",\"t\":[\"现在我们的类中出现了一个比较特殊的类型，它是一个集合类型：\",\"public class Student { private List<String> list; public void setList(List<String> list) { this.list = list; } } \",\"对于这种集合类型，有着特殊的支持：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"> <!-- 对于集合类型，我们可以直接使用标签编辑集合的默认值 --> <property name=\\\"list\\\"> <list> <value>AAA</value> <value>BBB</value> <value>CCC</value> </list> </property> </bean> \",\"不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用entry来注入：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"> <property name=\\\"map\\\"> <map> <entry key=\\\"语文\\\" value=\\\"100.0\\\"/> <entry key=\\\"数学\\\" value=\\\"80.0\\\"/> <entry key=\\\"英语\\\" value=\\\"92.5\\\"/> </map> </property> </bean> \",\"至此，我们就已经完成了两种依赖注入的学习：\",\"Setter依赖注入：通过成员属性对应的set方法完成注入。\",\"构造方法依赖注入：通过构造方法完成注入。\"]},\"1137\":{\"h\":\"自动装配 属性\",\"t\":[\"在之前，如果我们需要使用依赖注入的话，我们需要对property参数进行配置：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"> <property name=\\\"teacher\\\" ref=\\\"teacher\\\"/> </bean> \",\"但是有些时候为了方便，我们也可以开启自动装配。\",\"自动装配就是让IoC容器自己去寻找需要填入的值，我们只需要将set方法提供好就可以了，这里需要添加autowire属性：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" autowire=\\\"byType\\\"/> \"]},\"1138\":{\"h\":\"+\",\"t\":[\"autowire属性最普通的有两个值\",\"一个是byName，还有一个是byType\",\"顾名思义，一个是根据类型(即对应的类或者其子类)去寻找合适的Bean自动装配\",\"还有一个是根据名字(根据setxxx中的xxx)去找，这样我们就不需要显式指定property了。\",\"此时set方法旁边会出现一个自动装配图标，效果和上面是一样的。\"]},\"1139\":{\"h\":\"\",\"t\":[\"对于使用构造方法完成的依赖注入，也支持自动装配，我们只需要将autowire修改为：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" autowire=\\\"constructor\\\"/> \",\"这样，我们只需要提供一个对应参数的构造方法就可以了（这种情况默认也是byType寻找的）\",\"这样同样可以完成自动注入\"]},\"1140\":{\"h\":\"候选名单\",\"t\":[\"自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：\",\"alt text\",\"此时，由于autowire的规则为byType，存在两个候选Bean，但是我们其实希望ProgramTeacher这个Bean在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：\",\"<bean name=\\\"teacher\\\" class=\\\"com.test.bean.ArtTeacher\\\"/> <bean name=\\\"teacher2\\\" class=\\\"com.test.bean.ProgramTeacher\\\" autowire-candidate=\\\"false\\\"/> <bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" autowire=\\\"byType\\\"/> \",\"当autowire-candidate设定false时，这个Bean将不再作为自动装配的候选Bean，此时自动装配候选就只剩下一个唯一的Bean了，报错消失，程序可以正常运行。\"]},\"1141\":{\"h\":\"优先选择\",\"t\":[\"除了这种方式，我们也可以设定primary属性，表示这个Bean作为主要的Bean，当出现歧义时，也会优先选择：\",\"<bean name=\\\"teacher\\\" class=\\\"com.test.bean.ArtTeacher\\\" primary=\\\"true\\\"/> <bean name=\\\"teacher2\\\" class=\\\"com.test.bean.ProgramTeacher\\\"/> <bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" autowire=\\\"byType\\\"/> \"]},\"1142\":{\"c\":[\"code\"]},\"1143\":{\"c\":[\"javassm\",\"Spring\"]},\"1144\":{\"h\":\"Javassm - Spring3 (Bean生命周期与继承)\"},\"1145\":{\"h\":\"IoC理论基础 3\"},\"1146\":{\"h\":\"Bean生命周期与继承\"},\"1147\":{\"h\":\"初始化 和 销毁\",\"t\":[\"我们可以为Bean指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务\",\"通过init-method和destroy-method属性来指定：\",\"<bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\" init-method=\\\"init\\\" destroy-method=\\\"destroy\\\"/> \",\"其中的值为对应对象的某个函数\"]},\"1148\":{\"h\":\"初始化和销毁的时机\",\"t\":[\"那么什么时候是初始化，什么时候又是销毁呢？\",\"当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行init-method\",\"我们可以调用close方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行destroy-method\",\"// 容器创建时，默认情况下Bean都是单例的 // 那么都会在一开始就加载好，对象构造完成后，会执行init-method ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\\\"test.xml\\\"); // 我们可以调用close方法关闭容器 // 此时容器内存放的Bean也会被一起销毁，会执行destroy-method context.close(); \",\"注意，如果Bean不是单例模式，而是采用的原型模式，那么就只会在获取时才创建，并调用init-method，而对应的销毁方法不会被调用，即使你contest.close()\",\"因此，对于原型模式下的Bean，Spring无法顾及其完整生命周期，而在单例模式下，Spring能够从Bean对象的创建一直管理到对象的销毁\",\"官方文档原文如下：\",\"In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom bean post-processor, which holds a reference to beans that need to be cleaned up.\"]},\"1149\":{\"h\":\"继承 (属性继承)\",\"t\":[\"Bean之间也是具备继承关系的，只不过这里的继承并不是类的继承，而是属性的继承，比如：\",\"public class SportStudent { private String name; public void setName(String name) { this.name = name; } } \",\"public class ArtStudent { private String name; public void setName(String name) { this.name = name; } } \",\"此时，我们先将ArtStudent注册一个Bean：\",\"<bean name=\\\"artStudent\\\" class=\\\"com.test.bean.ArtStudent\\\"> <property name=\\\"name\\\" value=\\\"小明\\\"/> </bean> \",\"这里我们会注入一个name的初始值，此时我们创建了一个SportStudent的Bean，我们希望这个Bean的属性跟刚刚创建的Bean属性是一样的，那么我们可以写一个一模一样的：\",\"<bean class=\\\"com.test.bean.SportStudent\\\"> <property name=\\\"name\\\" value=\\\"小明\\\"/> </bean> \",\"但是如果属性太多的话，写起来有点麻烦\",\"这种情况，我们就可以配置Bean之间的继承关系了，我们可以让SportStudent这个Bean直接继承ArtStudent这个Bean配置的属性：\",\"<bean class=\\\"com.test.bean.SportStudent\\\" parent=\\\"artStudent\\\"/> \",\"这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误）\"]},\"1150\":{\"h\":\"单独配置其他属性\",\"t\":[\"当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置：\",\"<bean name=\\\"artStudent\\\" class=\\\"com.test.bean.ArtStudent\\\" abstract=\\\"true\\\"> <property name=\\\"name\\\" value=\\\"小明\\\"/> <property name=\\\"id\\\" value=\\\"1\\\"/> </bean> <bean class=\\\"com.test.bean.SportStudent\\\" parent=\\\"artStudent\\\"> <property name=\\\"id\\\" value=\\\"2\\\"/> </bean> \"]},\"1151\":{\"h\":\"抽象\",\"t\":[\"如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，容器就不会创建这个Bean的对象了：\",\"<bean name=\\\"artStudent\\\" class=\\\"com.test.bean.ArtStudent\\\" abstract=\\\"true\\\"> <property name=\\\"name\\\" value=\\\"小明\\\"/> </bean> <bean class=\\\"com.test.bean.SportStudent\\\" parent=\\\"artStudent\\\"/> \",\"注意，一旦声明为抽象Bean，那么就无法通过容器获取到其实例化对象了。\",\"alt text\",\"不过Bean的继承使用频率不是很高，了解就行。\"]},\"1152\":{\"h\":\"默认全局配置\",\"t\":[\"这里最后再提一下，我们前面已经学习了各种各样的Bean配置属性，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置：\",\"alt text\",\"这样，即使Bean没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非Bean自己进行配置覆盖掉默认配置。\"]},\"1153\":{\"c\":[\"code\"]},\"1154\":{\"c\":[\"javassm\",\"Spring\"]},\"1155\":{\"h\":\"Javassm - Spring4 (工厂模式和工厂Bean)\"},\"1156\":{\"h\":\"IoC理论基础 4\"},\"1157\":{\"h\":\"工厂模式和工厂Bean\",\"t\":[\"默认情况下，容器会调用Bean对应类型的构造方法进行对象创建\",\"但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中\",\"我们更希望 Spring 不要直接利用反射机制通过构造方法创建Bean对象, 而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的Bean对象：\",\"public class Student { Student() { System.out.println(\\\"我被构造了\\\"); } } \",\"public class StudentFactory { public static Student getStudent(){ System.out.println(\\\"欢迎光临电子厂\\\"); return new Student(); } } \"]},\"1158\":{\"h\":\"\",\"t\":[\"得到的Bean依然是对应对象的Bean, 而不是对应工厂的。\",\"此时Student有一个工厂，我们正常情况下需要使用工厂才可以得到Student对象，现在我们希望Spring也这样做，不要直接去反射搞构造方法创建，我们可以通过factory-method进行指定：\",\"<bean class=\\\"com.test.bean.StudentFactory\\\" factory-method=\\\"getStudent\\\"/> \",\"注意，这里的Bean类型需要填写为Student类的工厂类，并且添加factory-method指定对应的工厂方法\",\"但是最后注册的是工厂方法的返回类型，所以说依然是Student的Bean\",\"此时我们再去进行获取，拿到的也是通过工厂方法得到的对象\",\"alt text\",\"这里有一个误区，千万不要认为是我们注册了StudentFactory这个Bean，class填写为这个类这个只是为了告诉Spring我们的工厂方法在哪个位置，真正注册的是工厂方法提供的东西。 也可以用init-method测试，当你把对应的init方法写在StudentFactory中，idea会自动报错，只有写在Student中才是正确的。 \",\"可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对Bean进行依赖注入等操作了，而是只能在工厂方法中完成.\"]},\"1159\":{\"h\":\"工厂 -\",\"t\":[\"当然，可能某些工厂类需要构造出对象之后才能使用(比如对应构建实体类对象的方法不是Static)\",\"就需要先将这个工厂类注册为一个bean，然后再基于这个bean作为新的bean的factory-bean的值\",\"我们也可以将某个工厂类直接注册为工厂Bean：\",\"public class StudentFactory { public Student getStudent(){ System.out.println(\\\"欢迎光临电子厂\\\"); return new Student(); } } \",\"现在需要StudentFactory对象才可以获取到Student，此时我们就只能先将其注册为Bean了，像这样将工厂类注册为Bean，我们称其为工厂Bean，然后再使用factory-bean来指定Bean的工厂Bean：\",\"<bean name=\\\"studentFactory\\\" class=\\\"com.test.bean.StudentFactory\\\"/> <bean factory-bean=\\\"studentFactory\\\" factory-method=\\\"getStudent\\\"/> \",\"注意，使用factory-bean之后，不再要求指定class，我们可以直接使用了：\",\"alt text\",\"此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为Bean，此时我们就可以在配置文件中为工厂Bean配置依赖注入等内容了。\",\"这里还有一个很细节的操作，如果我们想获取工厂Bean为我们提供的Bean，可以直接输入工厂Bean的名称，这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例：\",\"Student bean = (Student) context.getBean(\\\"studentFactory\\\"); \",\"当然，如果我们需要获取工厂类的实例，可以在名称前面添加&符号：\",\"StudentFactory bean = (StudentFactory) context.getBean(\\\"&studentFactory\\\"); \"]},\"1160\":{\"h\":\"直接继承\",\"t\":[\"不需要注册工厂bean，xml只需要：\",\"<bean class=\\\"com.test.entity.StudentFactory\\\"/> \",\"然后让对应的工厂类继承FactoryBean:\",\"public class StudentFactory implements FactoryBean<Student> { public Student getStudent() { System.out.println(\\\"getStudent\\\"); return new Student(); } @Override public Student getObject() throws Exception { return getStudent(); } @Override public Class<?> getObjectType() { return Student.class; } } \"]},\"1161\":{\"c\":[\"code\"]},\"1162\":{\"c\":[\"javassm\",\"Spring\"]},\"1163\":{\"h\":\"Javassm - Spring5\"},\"1164\":{\"h\":\"IoC理论基础 5\"},\"1165\":{\"h\":\"使用注解开发\",\"t\":[\"前面我们已经完成了大部分的配置文件学习，但是我们发现，使用配置文件进行配置，似乎有点复杂\",\"可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满Bean配置，并且会继续庞大下去。\",\"所以可以用注解来进行配置\"]},\"1166\":{\"h\":\"\",\"t\":[\"既然现在要使用注解来进行开发，那么我们就删掉之前的xml配置文件吧，我们来看看使用注解能有多方便。\",\"ApplicationContext context = new AnnotationConfigApplicationContext(); \",\"现在我们使用AnnotationConfigApplicationContext作为上下文实现，它是注解配置的。\",\"既然现在采用注解，我们就需要使用类来编写配置文件\",\"只需要创建一个配置类就可以了：\",\"@Configuration public class MainConfiguration { } \",\"我们可以为AnnotationConfigApplicationContext指定一个默认的配置类：\",\"这个构造方法可以接收多个配置类（更准确的说是多个组件）\",\"//这个构造方法可以接收多个配置类（更准确的说是多个组件） ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); \"]},\"1167\":{\"h\":\"注册 ( )\",\"t\":[\"那么现在我们该如何配置Bean呢？\",\"@Bean 中包含的属性：\",\"@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Bean { @AliasFor(\\\"name\\\") String[] value() default {}; @AliasFor(\\\"value\\\") String[] name() default {}; boolean autowireCandidate() default true; String initMethod() default \\\"\\\"; String destroyMethod() default \\\"(inferred)\\\"; } \",\"具体例子：\",\"@Configuration public class MainConfiguration { @Bean(\\\"student\\\") public Student student(){ return new Student(); } } \",\"这样写相对于配置文件中的：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean name = \\\"student\\\" class=\\\"com.test.bean.Student\\\"/> </beans> \"]},\"1168\":{\"h\":\"引入其他配置类\",\"t\":[\"多个配置合并成一个再集体导入\",\"通过@Import还可以引入其他配置类：\",\"@Import(LBWConfiguration.class) //在讲解到Spring原理时，我们还会遇到它，目前只做了解即可。 @Configuration public class MainConfiguration {} \"]},\"1169\":{\"h\":\"具体使用\",\"t\":[\"只不过现在变成了由Java代码为我们提供Bean配置，这样会更加的灵活，也更加便于控制Bean对象的创建。\",\"ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student student = context.getBean(Student.class); System.out.println(student); \",\"使用方法是相同的，这跟使用XML配置是一样的。\"]},\"1170\":{\"h\":\"设置的配置\",\"t\":[\"初始化方法和摧毁方法、自动装配可以直接在@Bean注解中进行配置：\",\"@Bean(name = \\\"\\\", initMethod = \\\"\\\", destroyMethod = \\\"\\\", autowireCandidate = false) public Student student(){ return new Student(); } \"]},\"1171\":{\"h\":\"其他注解设置的配置 (lazy, 单例/原型@Scope 等)\",\"t\":[\"其次，我们可以使用一些其他的注解来配置其他属性，比如：\",\"@Bean @Lazy(true) //对应lazy-init属性 @Scope(\\\"prototype\\\") //对应scope属性 是单例还是原型 @DependsOn(\\\"teacher\\\") //对应depends-on属性 public Student student(){ return new Student(); } \"]},\"1172\":{\"h\":\"依赖注入的配置\",\"t\":[\"对于那些我们需要通过构造方法或是Setter完成依赖注入的Bean，比如：\",\"<bean name=\\\"teacher\\\" class=\\\"com.test.bean.ProgramTeacher\\\"/> <bean name=\\\"student\\\" class=\\\"com.test.bean.Student\\\"> <property name=\\\"teacher\\\" ref=\\\"teacher\\\"/> </bean> \",\"像这种需要引入其他Bean进行的注入，我们可以直接将其作为形式参数放到方法中：\",\"@Configuration public class MainConfiguration { @Bean public Teacher teacher(){ return new Teacher(); } @Bean public Student student(Teacher teacher){ return new Student(teacher); // 要有对应的构造函数或者对应setteacher } } \",\"此时我们可以看到，旁边已经出现图标了：\",\"alt text\",\"运行程序之后，我们发现，这样确实可以直接得到对应的Bean并使用。\"]},\"1173\":{\"h\":\"自动装配\",\"t\":[\"只不过，除了这种基于构造器或是Setter的依赖注入之外，我们也可以直接到Bean对应的类中使用自动装配：\",\"public class Student { @Autowired //使用此注解来进行自动装配，由IoC容器自动为其赋值 private Teacher teacher; } \",\"现在，我们甚至连构造方法和Setter都不需要去编写了，就能直接完成自动装配\",\"很快，应该是根据对应的属性的类去找有没有对应的Bean，不需要给Bean取别名对应\",\"当然，@Autowired并不是只能用于字段，对于构造方法或是Setter，它同样可以：\",\"public class Student { private Teacher teacher; @Autowired public void setTeacher(Teacher teacher) { this.teacher = teacher; } } \"]},\"1174\":{\"h\":\"指定装配\",\"t\":[\"@Autowired默认采用byType的方式进行自动装配，也就是说会使用类型进行配\",\"那么要是出现了多个相同类型的Bean，如果我们想要指定使用其中的某一个该怎么办呢？\",\"@Bean(\\\"a\\\") public Teacher teacherA(){ return new Teacher(); } @Bean(\\\"b\\\") public Teacher teacherB(){ return new Teacher(); } \",\"此时，我们可以配合@Qualifier进行名称匹配：\",\"public class Student { @Autowired @Qualifier(\\\"a\\\") //匹配名称为a的Teacher类型的Bean private Teacher teacher; } \"]},\"1175\":{\"h\":\"(移除)\",\"t\":[\"这里需要提一下，在我们旧版本的SSM教程中讲解了@Resource这个注解，但是现在它没有了。\",\"随着Java版本的更新迭代，某些javax包下的包，会被逐渐弃用并移除。在JDK11版本以后，javax.annotation这个包被移除并且更名为jakarta.annotation\",\"其中有一个非常重要的注解，叫做@Resource，它的作用与@Autowired时相同的，也可以实现自动装配，但是在IDEA中并不推荐使用@Autowired注解对成员字段进行自动装配，而是推荐使用@Resource，如果需要使用这个注解，还需要额外导入包：\",\"<dependency> <groupId>jakarta.annotation</groupId> <artifactId>jakarta.annotation-api</artifactId> <version>2.1.1</version> </dependency> \",\"使用方法一样，直接替换掉就可以了：\",\"public class Student { @Resource private Teacher teacher; } \",\"只不过，他们两有些机制上的不同：\",\"@Resource默认ByName如果找不到则ByType，可以添加到set方法、字段上。\",\"@Autowired默认是byType，只会根据类型寻找，可以添加在构造方法、set方法、字段、方法参数上。\",\"因为@Resource的匹配机制更加合理高效，因此官方并不推荐使用@Autowired字段注入\",\"当然，实际上Spring官方更推荐我们使用基于构造方法或是Setter的@Autowired注入，比如S etter 注入的一个好处是，Setter 方法使该类的对象能够在以后重新配置或重新注入。\",\"其实，最后使用哪个注解，还是看你自己，要是有强迫症不能忍受黄标但是又实在想用字段注入，那就用@Resource注解。\"]},\"1176\":{\"h\":\"初始化和销毁注解\",\"t\":[\"除了这个注解之外，还有@PostConstruct和@PreDestroy，它们效果和init-method和destroy-method是一样的：\",\"@PostConstruct public void init(){ System.out.println(\\\"我是初始化方法\\\"); } @PreDestroy public void destroy(){ System.out.println(\\\"我是销毁方法\\\"); } \",\"我们只需要将其添加到对应的方法上即可：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student student = context.getBean(Student.class); context.close(); \",\"可以看到效果是完全一样的，这些注解都是jakarta.annotation提供的，有关Spring和JakartaEE的渊源，还请各位小伙伴自行了解。\"]},\"1177\":{\"h\":\"(常用注册Bean方式)\",\"t\":[\"前面我们介绍了使用@Bean来注册Bean，但是实际上我们发现，如果只是简单将一个类作为Bean的话，这样写还是不太方便，因为都是固定模式，就是单纯的new一个对象出来，能不能像之前一样，让容器自己反射获取构造方法去生成这个对象呢？\",\"肯定是可以的，我们可以在需要注册为Bean的类上添加@Component注解来将一个类进行注册(现在最常用的方式)\",\"不过要实现这样的方式，我们需要添加一个自动扫描 @ComponentScan 来告诉Spring，它需要在哪些包中查找我们提供的@Component声明的Bean。\",\"@Component(\\\"penguin\\\") //同样可以自己起名字 public class Student { } \",\"要注册这个类的Bean，只需要添加@Component即可，然后配置一下包扫描：\",\"@Configuration @ComponentScan(\\\"com.test.bean\\\") //包扫描，这样Spring就会去扫描对应包下所有的类 public class MainConfiguration { } \",\"或者\",\"@Configuration @ComponentScans({ @ComponentScan(\\\"com.test.bean\\\") ... }) public class MainConfiguration { } \",\"Spring在扫描对应包下所有的类时，会自动将那些添加了@Component的类注册为Bean\",\"只不过这种方式只适用于我们自己编写类的情况，如果是第三方包提供的类，只能使用前者完成注册，并且这种方式并不是那么的灵活。\"]},\"1178\":{\"h\":\"默认 命名\",\"t\":[\"不过，无论是通过@Bean还是@Component形式注册的Bean，Spring都会为其添加一个默认的name属性，比如：\",\"@Component public class Student { } \",\"它的默认名称生产规则依然是类名并按照首字母小写的驼峰命名法来的，所以说对应的就是student：\",\"Student student = (Student) context.getBean(\\\"student\\\"); //这样同样可以获取到 System.out.println(student); \",\"同样的，如果是通过@Bean注册的，默认名称是对应的方法名称：\",\"@Bean public Student artStudent(){ return new Student(); } \",\"Student student = (Student) context.getBean(\\\"artStudent\\\"); System.out.println(student); \"]},\"1179\":{\"h\":\"其他\",\"t\":[\"相比传统的XML配置方式，注解形式的配置确实能够减少我们很多工作量。\",\"并且，对于这种使用@Component注册的Bean，如果其构造方法不是默认无参构造，那么默认会对其每一个参数都进行自动注入：\",\"@Component public class Student { Teacher teacher; public Student(Teacher teacher){ //如果有Teacher类型的Bean，那么这里的参数会被自动注入 this.teacher = teacher; } } \"]},\"1180\":{\"h\":\"工厂模式处理\",\"t\":[\"最后，对于我们之前使用的工厂模式，Spring也提供了接口，我们可以直接实现接口表示这个Bean是一个工厂Bean：\",\"@Component public class StudentFactory implements FactoryBean<Student> { @Override public Student getObject() { //生产的Bean对象 return new Student(); } @Override public Class<?> getObjectType() { //生产的Bean类型 return Student.class; } @Override public boolean isSingleton() { //生产的Bean是否采用单例模式 return false; } } \"]},\"1181\":{\"h\":\"讨论\",\"t\":[\"实际上跟我们之前在配置文件中编写是一样的，这里就不多说了。\",\"请注意，使用注解虽然可以省事很多，代码也能变得更简洁，但是这并不代表XML配置文件就是没有意义的，它们有着各自的优点，在不同的场景下合理使用，能够起到事半功倍的效果，官方原文：\",\"Are annotations better than XML for configuring Spring?\",\"The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.\",\"No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its JavaConfig option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the Spring Tools for Eclipse.\",\"在最后，留一个问题，现在有两个类：\",\"@Component public class Student { @Resource private Teacher teacher; } \",\"@Component public class Teacher { @Resource private Student student; } \",\"这两个类互相需要注入对方的实例对象，这个时候Spring会怎么进行处理呢？\",\"测试了，加了这种注解是可以正常运行的不会报错，但如果我改成这样：\",\"@Component public class Student { @Autowired private Teacher teacher; } \",\"@Component public class Teacher { @Autowired private Student student; } \",\"就会报错：\",\"月 06, 2025 11:57:12 下午 org.springframework.context.support.AbstractApplicationContext refresh 警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'student' defined in file: Unsatisfied dependency expressed through constructor parameter 0: Error creating bean with name 'teacher' defined in file : Unsatisfied dependency expressed through constructor parameter 0: Error creating bean with name 'student': Requested bean is currently in creation: Is there an unresolvable circular reference? \",\"问了GPT回答：\",\"在 构造器注入 的情况下，Spring 必须一次性把依赖注入进去，无法像 setter注入 或 字段注入 那样延迟注入，因此两个类互相通过构造器注入会导致无法完成初始化。\",\"而采用 @Autowired，可以让 Spring 能先创建一个 Bean 再回头注入依赖。\",\"或者如果一定用构造器注入，可以用 @Lazy 让其中一个依赖延迟到使用时再初始化。\",\"@Component public class Student { private final Teacher teacher; public Student(@Lazy Teacher teacher) { this.teacher = teacher; } } \",\"这样 Spring 创建 Student 时不会立刻去创建 Teacher，避免循环依赖。\",\"如果Bean变成原型模式，Spring又会怎么处理呢？\",\"对于单例情况：\",\"单例 Bean 的循环依赖（构造器以外）时，Spring 可以用 三级缓存（三级缓存机制） 暂存早期引用，允许先暴露一个“半成品”Bean，让另一个 Bean 注入，最后再完成填充。\",\"但是 构造器注入 场景下没法这么干，因为构造函数必须一次性拿到所有参数，Spring 没法先造个半成品放进去。\",\"但对于原型模式：\",\"原型 Bean 是 每次请求都会新建一个实例，Spring 不会缓存它。 这意味着：\",\"对于 原型 Bean 的循环依赖，Spring 完全没有缓存机制可用 所以即使是 setter/字段注入，Spring 也无法像单例那样从缓存取“早期引用”来解循环\",\"结果就是：无论是构造器注入还是 setter 注入，只要原型 Bean有循环依赖，都会直接报错\",\"alt text\",\"alt text\"]},\"1182\":{\"c\":[\"code\"]},\"1183\":{\"c\":[\"javassm\",\"Spring\"]},\"1184\":{\"h\":\"Javassm - Spring高级特性 (Aware接口+任务调度+监听器)\"},\"1185\":{\"h\":\"Spring高级特性1\"},\"1186\":{\"h\":\"Bean Aware\",\"t\":[\"在Spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化之后，可以获取相应资源。\",\"Aware的中文意思为感知。\",\"简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。\",\"比如BeanNameAware之类的以Aware结尾的接口，这个接口获取的资源就是BeanName：\",\"@Component public class Student implements BeanNameAware { //我们只需要实现这个接口就可以了 @Override public void setBeanName(String name) { //Bean在加载的时候，容器就会自动调用此方法，将Bean的名称给到我们 System.out.println(\\\"我在加载阶段获得了Bean名字：\\\"+name); } } \",\"又比如BeanClassLoaderAware，那么它能够使得我们可以在Bean加载阶段就获取到当前Bean的类加载器：\",\"@Component public class Student implements BeanClassLoaderAware { @Override public void setBeanClassLoader(ClassLoader classLoader) { System.out.println(classLoader); } } \"]},\"1187\":{\"h\":\"任务调度\",\"t\":[\"为了执行某些任务，我们可能需要一些非常规的操作\",\"比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。\",\"这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务\",\"但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。\"]},\"1188\":{\"h\":\"异步任务执行\",\"t\":[\"我们需要在配置类上添加@EnableAsync注解。\",\"@EnableAsync @Configuration @ComponentScan(\\\"com.test.bean\\\") public class MainConfiguration { ... } \",\"接着我们只需要在需要异步执行的方法上，添加@Async注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，而不是在当前线程执行。\",\"@Component public class Student { public void syncTest() throws InterruptedException { System.out.println(Thread.currentThread().getName()+\\\"我是同步执行的方法，开始...\\\"); Thread.sleep(3000); System.out.println(\\\"我是同步执行的方法，结束！\\\"); } @Async public void asyncTest() throws InterruptedException { System.out.println(Thread.currentThread().getName()+\\\"我是异步执行的方法，开始...\\\"); Thread.sleep(3000); System.out.println(\\\"我是异步执行的方法，结束！\\\"); } } \",\"现在我们在主方法中分别调用一下试试看：\",\"public static void main(String[] args) throws InterruptedException { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student student = context.getBean(Student.class); student.asyncTest(); //异步执行 student.syncTest(); //同步执行 } \",\"执行结果为：\",\"alt text\",\"很明显，异步执行的任务并不是在当前线程启动的，而是在其他线程启动的，所以说并不会在当前线程阻塞，可以看到马上就开始执行下一行代码，调用同步执行的任务了。\",\"因此，当我们要将Bean的某个方法设计为异步执行时，就可以直接添加这个注解。\",\"但是需要注意，添加此注解要求方法的返回值只能是void或是Future类型才可以\",\"还有，在使用时，可能还会出现这样的信息：\",\"alt text\",\"虽然出现了这样的信息，但是我们的程序依然可以正常运行，这是因为Spring默认会从容器中选择一个Executor类型（JUC有关）的实例，并使用它来创建线程执行任务\",\"这是Spring推荐的方式，当然，如果没有找到，那么会使用自带的 SimpleAsyncTaskExecutor 处理异步方法调用。\"]},\"1189\":{\"h\":\"原理\",\"t\":[\"这个方法很明显我们并没有去编写异步执行的逻辑，那么为什么会异步执行呢？\",\"这里很明显是同步调用的方法。的确，如果这个Bean只是一个简简单单的Student类型的对象，确实做不到。但是它真的只是一个简简单单的Student类型对象吗？\",\"Student student = context.getBean(Student.class); System.out.println(student.getClass()); //这里我们通过getClass来获取一下类型，你会发现惊喜 \",\"我们来看看结果：\",\"alt text\",\"实际上Spring帮助我们动态生成的一个代理类，我们原本的类代码已经被修改了，当然，这只是冰山一角，能做到这样的操作，这其实都是AOP的功劳。\"]},\"1190\":{\"h\":\"定时任务\",\"t\":[\"定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段使用过TimerTask来执行定时任务。\",\"Spring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加@EnableScheduling注解：\",\"不需要调用，默认启动就会运行\",\"@EnableScheduling @Configuration @ComponentScan(\\\"com.test.bean\\\") public class MainConfiguration { ... } \",\"接着我们可以直接在配置类里面编写定时任务，把我们要做的任务写成方法，并添加@Scheduled注解：\",\"@Scheduled(fixedRate = 2000) //单位依然是毫秒，这里是每两秒钟打印一次 public void task(){ System.out.println(\\\"我是定时任务！\\\"+new Date()); } \",\"我们注意到@Scheduled中有很多参数\",\"我们需要指定'cron', 'fixedDelay(String)', or 'fixedRate(String)'的其中一个，否则无法创建定时任务，他们的区别如下：\",\"fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。\",\"fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。\",\"cron：如果嫌上面两个不够灵活，你还可以使用cron表达式来指定任务计划。\",\"这里简单讲解一下cron表达式：https://blog.csdn.net/sunnyzyq/article/details/98597252\"]},\"1191\":{\"h\":\"监听器\",\"t\":[\"监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知\",\"监听器可是很关键的，只不过在Spring中用的不是很频繁罢了。\",\"但是这里还是要简单介绍一下：\",\"@Component public class TestListener implements ApplicationListener<ContextRefreshedEvent> { @Override public void onApplicationEvent(ContextRefreshedEvent event) { System.out.println(event.getApplicationContext()); //可以直接通过事件获取到事件相关的东西 } } \",\"要编写监听器，我们只需要让Bean继承ApplicationListener就可以了，并且将类型指定为对应的Event事件\",\"这样，当发生某个事件时就会通知我们，比如ContextRefreshedEvent，这个事件会在Spring容器初始化完成会触发一次：\",\"alt text\"]},\"1192\":{\"h\":\"自定义事件\",\"t\":[\"Spring内部有各种各样的事件\",\"我们也可以自己编写事件，然后在某个时刻发布这个事件到所有的监听器：\",\"public class TestEvent extends ApplicationEvent { // 自定义事件需要继承ApplicationEvent public TestEvent(Object source) { super(source); } } \",\"对应设置监听器\",\"@Component public class TestListener implements ApplicationListener<TestEvent> { @Override public void onApplicationEvent(TestEvent event) { System.out.println(\\\"发生了一次自定义事件，成功监听到！\\\"); } } \",\"比如现在我们希望在定时任务中每秒钟发生一次这个事件：\",\"@Component public class TaskComponent implements ApplicationEventPublisherAware { // 要发布事件，需要拿到ApplicationEventPublisher // 这里我们通过Aware在初始化的时候拿到 // 实际上我们的ApplicationContext // 就是ApplicationEventPublisher的实现类 // 这里拿到的就是 我们创建的ApplicationContext对象 ApplicationEventPublisher publisher; @Scheduled(fixedRate = 1000) //一秒一次 public void task(){ // 直接通过ApplicationEventPublisher的publishEvent方法发布事件 // 这样，所有这个事件的监听器，都会监听到这个事件发生了 publisher.publishEvent(new TestEvent(this)); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } } \",\"根据提示，其实我们可以在main里面直接发布事件：\",\"public class Main { public static void main(String[] args) throws InterruptedException { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); context.publishEvent(new TestEvent(context.getBean(Student.class))); } } \",\"对应的事件的source参数随便给一个对象就行，表示这个事件的源头\",\"alt text\"]},\"1193\":{\"c\":[\"code\"]},\"1194\":{\"c\":[\"javassm\",\"Spring\"]},\"1195\":{\"h\":\"Javassm - SpringEL表达式1\"},\"1196\":{\"h\":\"SpringEL表达式\",\"t\":[\"SpEL 是一种强大，简洁的装配 Bean 的方式，它可以通过运行期间执行的表达式将值装配到我们的属性或构造函数当中，更可以调用 JDK 中提供的静态常量，获取外部 Properties 文件中的的配置。\"]},\"1197\":{\"h\":\"外部属性注入\",\"t\":[\"我们可以将一些外部配置文件中的配置进行读取，并完成注入。\",\"创建以.properties结尾的配置文件，这种配置文件格式很简单，类似于Map，需要一个Key和一个Value，中间使用等号进行连接\",\"这里我们在resource目录下创建一个test.properties文件：\",\"test.name=企鹅 \"]},\"1198\":{\"h\":\"\",\"t\":[\"我们可以通过一个注解直接读取到外部配置文件中对应的属性值，首先我们需要引入这个配置文件，我们可以在配置类上添加@PropertySource注解：\",\"@Configuration @ComponentScan(\\\"com.test.bean\\\") @PropertySource(\\\"classpath:test.properties\\\") //注意，类路径下的文件名称需要在前面加上classpath: public class MainConfiguration{ ... } \"]},\"1199\":{\"h\":\"\",\"t\":[\"通过 @Value 注解将外部配置文件中的值注入到任何我们想要的位置：\",\"@Component public class Student { @Value(\\\"${test.name}\\\") //这里需要在外层套上 ${ } private String name; //String会被自动赋值为配置文件中对应属性的值 public void hello(){ System.out.println(\\\"我的名字是：\\\"+name); } } \",\"@Value中的${...}表示占位符，它会读取外部配置文件的属性值装配到属性中，如果配置正确没问题的话，这里甚至还会直接显示对应配置项的值：\",\"image-20221125164854022\",\"如果遇到乱码的情况，请将配置文件的编码格式切换成UTF-8：\",\"Settings->Editor->File Encodings->Default encoding for properties files\",\"然后在@PropertySource注解中添加属性\",\"@PropertySource(value=\\\"classpath:test.properties\\\", encoding = \\\"utf-8\\\")\"]},\"1200\":{\"h\":\"方法参数注入\",\"t\":[\"除了在字段上进行注入之外，我们也可以在需要注入的方法中使用：\",\"@Component public class Student { private final String name; //构造方法中的参数除了被自动注入外，我们也可以选择使用@Value进行注入 public Student(@Value(\\\"${test.name}\\\") String name){ this.name = name; } public void hello(){ System.out.println(\\\"我的名字是：\\\"+name); } } \",\"当然，如果我们只是想简单的注入一个常量值，也可以直接填入固定值：\",\"private final String name; public Student(@Value(\\\"10\\\") String name){ //只不过，这里都是常量值了，我干嘛不直接写到代码里呢 this.name = name; } \",\"当然，@Value 的功能还远不止这些，配合SpringEL表达式，能够实现更加强大的功能。\"]},\"1201\":{\"h\":\"SpEL表达式\",\"t\":[\"Spring官方为我们提供了一套非常高级SpEL表达式，通过使用表达式，我们可以更加灵活地使用Spring框架。\"]},\"1202\":{\"h\":\"创建SpEL表达式\",\"t\":[\"ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\\\"'Hello World'\\\"); //使用parseExpression方法来创建一个表达式 System.out.println(exp.getValue()); //表达式最终的运算结果可以通过getValue()获取 \",\"这里得到的就是一个很简单的 Hello World 字符串，字符串使用单引号囊括，SpEL是具有运算能力的。\",\"我们可以像写Java一样，对这个字符串进行各种操作，比如调用方法之类的：\",\"Expression exp = parser.parseExpression(\\\"'Hello World'.toUpperCase()\\\"); //调用String的toUpperCase方法 System.out.println(exp.getValue()); \",\"不仅能调用方法、还可以访问属性、使用构造方法等\"]},\"1203\":{\"h\":\"\",\"t\":[\"对于Getter方法，我们可以像访问属性一样去使用：\",\"//比如 String.getBytes() 方法，就是一个Getter，那么可以写成 bytes Expression exp = parser.parseExpression(\\\"'Hello World'.bytes\\\"); System.out.println(exp.getValue()); \",\"表达式可以不止一级，我们可以多级调用：\",\"Expression exp = parser.parseExpression(\\\"'Hello World'.bytes.length\\\"); //继续访问数组的length属性 System.out.println(exp.getValue()); \",\"对于构造方法，也可以写成这种表达式而已：\",\"Expression exp = parser.parseExpression(\\\"new String('hello world').toUpperCase()\\\"); System.out.println(exp.getValue()); \",\"它甚至还支持根据特定表达式，从给定对象中获取属性出来：\",\"@Component public class Student { private final String name; public Student(@Value(\\\"${test.name}\\\") String name){ this.name = name; } public String getName() { //比如下面要访问name属性，那么这个属性得可以访问才行，访问权限不够是不行的 return name; } } \",\"Student student = context.getBean(Student.class); ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\\\"name\\\"); System.out.println(exp.getValue(student)); //直接读取对象的name属性 \",\"这里表示exp为某个对应的name属性，然后通过getValue()去获取，对应属性就需要有对应的Getter方法\",\"拿到对象属性之后，甚至还可以继续去处理：\",\"Expression exp = parser.parseExpression(\\\"name.bytes.length\\\"); //拿到name之后继续getBytes然后length \"]},\"1204\":{\"h\":\"\",\"t\":[\"除了获取，我们也可以调用表达式的setValue方法来设定属性的值：\",\"Expression exp = parser.parseExpression(\\\"name\\\"); exp.setValue(student, \\\"刻师傅\\\"); //同样的，这个属性得有访问权限且能set才可以，否则会报错 \",\"除了属性调用，我们也可以使用运算符进行各种高级运算：\",\"Expression exp = parser.parseExpression(\\\"66 > 77\\\"); //比较运算 System.out.println(exp.getValue()); \",\"Expression exp = parser.parseExpression(\\\"99 + 99 * 3\\\"); //算数运算 System.out.println(exp.getValue()); \"]},\"1205\":{\"h\":\"导入\",\"t\":[\"对于那些需要导入才能使用的类以及静态方法使用，我们需要使用一个特殊的语法：\",\"Expression exp = parser.parseExpression(\\\"T(java.lang.Math).random()\\\"); //由T()囊括，包含完整包名+类名 //Expression exp = parser.parseExpression(\\\"T(System).nanoTime()\\\"); //默认导入的类可以不加包名 System.out.println(exp.getValue()); \",\"即这种表达式如果只是简单字符串，表示的是对应字段属性\",\"如果要表示字符串，需要加入单引号, \\\"`xxx`\\\"\",\"如果表示导入的类啥就需要 T(xxx)\"]},\"1206\":{\"h\":\"集合操作相关语法\"},\"1207\":{\"h\":\"选取元素\",\"t\":[\"现在我们的类中存在一些集合类：\",\"@Component public class Student { public Map<String, String> map = Map.of(\\\"test\\\", \\\"你干嘛\\\"); public List<String> list = List.of(\\\"AAA\\\", \\\"BBB\\\", \\\"CCC\\\"); } \",\"我们可以使用SpEL快速取出集合中的元素：\",\"Expression exp = parser.parseExpression(\\\"map['test']\\\"); //对于Map这里映射型，可以直接使用map[key]来取出value System.out.println(exp.getValue(student)); \",\"Expression exp = parser.parseExpression(\\\"list[2]\\\"); //对于List、数组这类，可以直接使用[index] System.out.println(exp.getValue(student)); \"]},\"1208\":{\"h\":\"创建\",\"t\":[\"我们也可以快速创建集合：\",\"Expression exp = parser.parseExpression(\\\"{5, 2, 1, 4, 6, 7, 0, 3, 9, 8}\\\"); //使用{}来快速创建List集合 List value = (List) exp.getValue(); value.forEach(System.out::println); \",\"Expression exp = parser.parseExpression(\\\"{{1, 2}, {3, 4}}\\\"); //支持嵌套使用的 \",\"//创建Map也很简单，只需要key:value就可以了 Expression exp = parser.parseExpression(\\\"{name: '小明', info: {address: '北京市朝阳区', tel: 10086}}\\\"); System.out.println(exp.getValue()); \"]},\"1209\":{\"h\":\"条件获取\",\"t\":[\"根据条件获取集合中的元素：\",\"@Component public class Student { public List<Clazz> list = List.of(new Clazz(\\\"高等数学\\\", 4)); public record Clazz(String name, int score){ } } \",\"获取那些满足我们条件的元素，并组成一个新的集合\",\"//现在我们希望从list中获取那些满足我们条件的元素，并组成一个新的集合，我们可以使用.?运算符 Expression exp = parser.parseExpression(\\\"list.?[name == '高等数学']\\\"); System.out.println(exp.getValue(student)); \",\"Expression exp = parser.parseExpression(\\\"list.?[score > 3]\\\"); //选择学分大于3分的科目 System.out.println(exp.getValue(student)); \"]},\"1210\":{\"h\":\"投影集合\",\"t\":[\"我们还可以针对某个属性创建对应的投影集合：\",\"Expression exp = parser.parseExpression(\\\"list.![name]\\\"); //使用.!创建投影集合，这里创建的时课程名称组成的新集合 System.out.println(exp.getValue(student)); \"]},\"1211\":{\"h\":\"安全导航运算符\",\"t\":[\"我们接着来介绍安全导航运算符，安全导航运算符用于避免NullPointerException，它来自Groovy语言。\",\"通常，当有对对象的引用时，可能需要在访问对象的方法或属性之前验证它是否为空。\",\"为了避免这种情况，安全导航运算符返回null而不是抛出异常。\",\"以下示例显示了如何使用安全导航运算符：\",\"Expression exp = parser.parseExpression(\\\"name.toUpperCase()\\\"); //如果Student对象中的name属性为null System.out.println(exp.getValue(student)); \",\"会直接报错显示空指针\",\"当遇到null时很不方便，我们还得写判断：\",\"if(student.name != null) System.out.println(student.name.toUpperCase()); \",\"Java 8之后能这样写：\",\"Optional.ofNullable(student.name).ifPresent(System.out::println); \",\"但是你如果写过Kotlin：\",\"println(student.name?.toUpperCase()); \",\"类似于这种判空问题，我们就可以直接使用安全导航运算符，SpEL也支持这种写法：\",\"Expression exp = parser.parseExpression(\\\"name?.toUpperCase()\\\"); System.out.println(exp.getValue(student)); \",\"当遇到空时，只会得到一个null，而不是直接抛出一个异常\",\"我们可以将SpEL配合 @Value 注解或是xml配置文件中的value属性使用，比如XML中可以这样写：\",\"<bean id=\\\"numberGuess\\\" class=\\\"org.spring.samples.NumberGuess\\\"> <property name=\\\"randomNumber\\\" value=\\\"#{ T(java.lang.Math).random() * 100.0 }\\\"/> </bean> \",\"或是使用注解开发：\",\"public class FieldValueTestBean { @Value(\\\"#{ systemProperties['user.region'] }\\\") private String defaultLocale; } \",\"这样，我们有时候在使用配置文件中的值时，就能进行一些简单的处理了。\",\"有关更多详细语法教程，请前往：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-language-ref\"]},\"1212\":{\"c\":[\"code\"]},\"1213\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1214\":{\"h\":\"Javassm - AOP1\"},\"1215\":{\"h\":\"AOP面向切片\",\"t\":[\"AOP（Aspect Oriented Programming）思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上。\",\"也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，它就是代理！\",\"通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作\",\"比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。\",\"alt text\",\"相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。\",\"它的原理实际上就是通过动态代理机制实现的。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不仅仅是接口。\"]},\"1216\":{\"h\":\"使用配置实现AOP\"},\"1217\":{\"h\":\"准备\",\"t\":[\"在开始之前，先换回之前的XML配置模式\",\"注意这里还入了一些新的AOP相关的约束进来：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:aop=\\\"http://www.springframework.org/schema/aop\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\\\"> </beans> \",\"Spring是支持AOP编程的框架之一（实际上它整合了AspectJ框架的一部分），要使用AOP我们需要先导入一个依赖：\",\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-aspects</artifactId> <version>6.0.10</version> </dependency> \",\"那么，如何使用AOP呢？首先我们要明确，要实现AOP操作，我们需要知道这些内容：\",\"需要切入的类，类的哪个方法需要被切入\",\"切入之后需要执行什么动作\",\"是在方法执行前切入还是在方法执行后切入\",\"如何告诉Spring需要进行切入\"]},\"1218\":{\"h\":\"例子\",\"t\":[\"比如现在我们希望对这个学生对象的study方法进行增强，在不修改源代码的情况下，增加一些额外的操作：\",\"public class Student { public void study(){ System.out.println(\\\"PPPP\\\"); //现在我们希望在这个方法执行完之后，打印一些其他的内容，在不修改原有代码的情况下，该怎么做呢？ } } \",\"<bean class=\\\"org.example.entity.Student\\\"/> \",\"那么我们按照上面的流程，依次来看\",\"首先需要解决的问题是，找到需要切入的类，很明显，就是这个Student类，我们要切入的是这个study方法。\",\"第二步，我们切入之后要做什么呢？这里我们直接创建一个新的类，并将要执行的操作写成一个方法：\",\"public class StudentAOP { //这个方法就是我们打算对其进行的增强操作 public void afterStudy() { System.out.println(\\\"Penguin\\\"); } } \",\"注意这个类也得注册为Bean才可以：\",\"<bean id=\\\"studentAOP\\\" class=\\\"org.example.entity.StudentAOP\\\"/> \",\"第三步，我们要明确这是在方法执行之前切入还是执行之后切入，很明显，按照上面的要求，我们需要执行之后进行切入。\",\"第四步，最关键的来了，我们怎么才能告诉Spring我们要进行切入操作呢？这里我们需要在配置文件中进行AOP配置：\",\"<aop:config> </aop:config> \"]},\"1219\":{\"h\":\"建立切点\",\"t\":[\"这个的目的就是来找那些满足条件的匹配的函数\",\"接着我们需要添加一个新的切点，首先填写ID，这个随便起都可以：\",\"<aop:pointcut id=\\\"test\\\" expression=\\\"\\\"/> \",\"然后就是通过后面的expression表达式来选择到我们需要切入的方法，这个表达式支持很多种方式进行选择\",\"Spring AOP支持以下AspectJ切点指示器（PCD）用于表达式，重点是 execution：\",\"execution：用于匹配方法执行连接点。这是使用Spring AOP时使用的主要点切割指示器。\",\"within：限制匹配到某些类型的连接点（使用Spring AOP时在匹配类型中声明的方法的执行）。\",\"this：限制与连接点匹配（使用Spring AOP时方法的执行），其中bean引用（Spring AOP代理）是给定类型的实例。\",\"target：限制匹配连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。\",\"args：限制与连接点匹配（使用Spring AOP时方法的执行），其中参数是给定类型的实例。\",\"@target：限制匹配连接点（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注释。\",\"@args：限制匹配到连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。\",\"@within：限制与具有给定注释的类型中的连接点匹配（使用Spring AOP时在带有给定注释的类型中声明的方法的执行）。\",\"@annotation：与连接点主体（在Spring AOP中运行的方法）具有给定注释的连接点匹配的限制。\",\"更多详细内容请查阅：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators\",\"其中，execution填写格式如下：\",\"修饰符 包名.类名.方法名称(方法参数) \",\"修饰符：public、protected、private、包括返回值类型、static等等（使用*代表任意修饰符）\",\"包名：如com.test（*代表全部，比如com.*代表com包下的全部包）\",\"类名：使用*也可以代表包下的所有类\",\"方法名称：可以使用*代表全部方法\",\"方法参数：填写对应的参数即可，比如(String, String)，也可以使用*来代表任意一个参数，使用..代表所有参数。\",\"也可以使用其他属性来进行匹配，比如@annotation可以用于表示标记了哪些注解的方法被切入，这里我们就只是简单的执行，所以说只需要这样写就可以了：\",\"<aop:pointcut id=\\\"test\\\" expression=\\\"execution(* org.example.entity.Student.study())\\\"/> \",\"这样，我们就指明了需要切入的方法\"]},\"1220\":{\"h\":\"选择增强方法\",\"t\":[\"这则是来匹配满足条件的切点调用的是什么方法\",\"然后就是将我们的增强方法，我们在里面继续添加aop:aspect标签，并使用ref属性将其指向我们刚刚注册的AOP类Bean：\",\"<aop:config> <aop:pointcut id=\\\"test\\\" expression=\\\"execution(* org.example.entity.Student.study())\\\"/> <aop:aspect ref=\\\"studentAOP\\\"> </aop:aspect> </aop:config> \",\"接着就是添加后续动作了，当然，官方支持的有多种多样的，比如执行前、执行后、抛出异常后、方法返回后等等：\",\"alt text\",\"其中around方法为环绕方法，自定义度会更高。\",\"这里我们按照上面的要求，直接添加后续动作，注意需要指明生效的切点：\",\"<aop:aspect ref=\\\"studentAOP\\\"> <!-- method就是我们的增强方法，pointcut-ref指向我们刚刚创建的切点 --> <aop:after method=\\\"afterStudy\\\" pointcut-ref=\\\"test\\\"/> </aop:aspect> \",\"这样，我们就成功配置好了\"]},\"1221\":{\"h\":\"测试\",\"t\":[\"public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); Student bean = context.getBean(Student.class); bean.study(); } \",\"结果如下：\",\"alt text\",\"可以看到在我们原本的方法执行完成之后，它还继续执行了我们的增强方法，这实际上就是动态代理做到的，实现在不修改原有代码的基础上，对方法的调用进行各种增强，在之后的SpringMVC学习中，我们甚至可以使用它来快速配置访问日志打印。\"]},\"1222\":{\"h\":\"分析\",\"t\":[\"前面我们说了，AOP是基于动态代理实现的，所以说我们如果直接获取Bean的类型，会发现不是原本的类型了：\",\"Student bean = context.getBean(Student.class); System.out.println(bean.getClass()); \",\"alt text\",\"这里其实是Spring通过CGLib为我们生成的动态代理类，也就不难理解为什么调用方法会直接得到增强之后的结果了。\",\"包括我们前面讲解Spring的异步任务调度时，为什么能够直接实现异步，其实就是利用了AOP机制实现的方法增强。\"]},\"1223\":{\"h\":\"获取切点信息\",\"t\":[\"虽然这些功能已经非常强大了，但是仅仅只能简单的切入还是不能满足一些需求，在某些情况下，我们可以需求方法执行的一些参数，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等\",\"现在我们修改一下Student中study方法的参数：\",\"public class Student { public void study(String str){ //现在方法有一个String类型的参数 System.out.println(\\\"都别学Java了，根本找不到工作，快去卷\\\"+str); } } \",\"我们希望在增强的方法中也能拿到这个参数，然后进行处理\",\"这个时候，我们可以为我们切入的方法添加一个JoinPoint参数，通过此参数就可以快速获取切点位置的一些信息：\",\"public void afterStudy(JoinPoint point) { //JoinPoint实例会被自动传入 //这里我们直接通过getArgs()返回的参数数组获取第1个参数 System.out.println(\\\"学什么\\\"+point.getArgs()[0]+\\\"，Rust天下第一！\\\"); } \",\"接着我们修改一下刚刚的AOP配置（因为方法参数有变动）看看结果吧：\",\"<aop:pointcut id=\\\"test\\\" expression=\\\"execution(* org.example.entity.Student.study(String))\\\"/> \"]},\"1224\":{\"h\":\"环绕方法\",\"t\":[\"我们接着来看自定义度更高的环绕方法，现在我们希望在方法执行前和执行后都加入各种各样的动作,此时我们就可以使用环绕方法。\",\"此时，我们就相当于需要自己来调用代理方法，然后就可以在其前后写我们的动作来执行\",\"环绕方法相当于完全代理了此方法，它完全将此方法包含在中间，需要我们手动调用才可以执行此方法，并且我们可以直接获取更多的参数\",\"注意，如果代理方法存在返回值，那么环绕方法也需要有一个返回值，通过proceed方法来执行代理的方法\",\"也可以修改参数之后调用proceed(Object[])，使用我们给定的参数再去执行：\",\"public Object test1(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\\\"方法开始之前\\\"); String arg = joinPoint.getArgs()[0] + \\\"伞兵一号\\\"; Object value = joinPoint.proceed(new Object[]{arg}); System.out.println(\\\"方法执行完成，结果为：\\\"+value); return value; } \",\"这里我们还是以study方法为例，现在我们希望在调用前修改这个方法传入的参数值，改成我们自己的，然后在调用之后对返回值结果也进行处理：\",\"public String study(String str){ if(str.equals(\\\"Java\\\")) System.out.println(\\\"我的梦想是学Java\\\"); else { System.out.println(\\\"我就要学Java，不要修改我的梦想！\\\"); str = \\\"Java\\\"; } return str; } \",\"现在我们编写一个环绕方法，对其进行全方面处理：\",\"public Object test1(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\\\"我是她的家长，他不能学Java，必须学Rust，这是为他好\\\"); Object value = joinPoint.proceed(new Object[]{\\\"Rust\\\"}); if(value.equals(\\\"Java\\\")) { System.out.println(\\\"听话，学Rust以后进大厂！\\\"); value = \\\"Rust\\\"; } return value; } \",\"同样的，因为方法变动了，现在我们去修改一下我们的AOP配置：\",\"<aop:pointcut id=\\\"test\\\" expression=\\\"execution(* org.example.entity.Student.study(String))\\\"/> <aop:aspect ref=\\\"studentAOP\\\"> <aop:around method=\\\"test1\\\" pointcut-ref=\\\"test\\\"/> </aop:aspect> \",\"环绕方法的图标是全包的，跟我们之前的图标不太一样。\",\"public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); Student bean = context.getBean(Student.class); System.out.println(\\\"已报名：\\\"+bean.study(\\\"Java\\\")); } \",\"alt text\",\"这样，我们就实现了环绕方法，通过合理利用AOP带来的便捷，可以使得我们的代码更加清爽和优美。\"]},\"1225\":{\"h\":\"实现异步效果\",\"t\":[\"实现异步效果，可以用AOP来实现\",\"首先在Student类中创立一个task\",\"public class Student { public void task(Runnable runnable){ runnable.run(); } } \",\"这样在main里\",\"public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); Student student = (Student) context.getBean(Student.class); student.task(()->{ try { Thread.sleep(3000); System.out.println(\\\"Penguin\\\"); } catch (InterruptedException e) { throw new RuntimeException(e); } }); System.out.println(\\\"PPPP!\\\"); } \",\"此时显然是同步的，要等task结束才会输出PPPP!\",\"这时候借助AOP, 我们在StudentAOP类用一个async\",\"public void async(ProceedingJoinPoint joinPoint) throws Throwable { new Thread(()->{ try { joinPoint.proceed(joinPoint.getArgs()); } catch (Throwable e) { throw new RuntimeException(e); } }).start(); } \",\"然后去配置文件修改\",\" <aop:config> <aop:pointcut id=\\\"task\\\" expression=\\\"execution(* com.ekko.entity.Student.task(Runnable))\\\"/> <aop:aspect ref=\\\"penguin\\\"> <aop:around method=\\\"async\\\" pointcut-ref=\\\"task\\\"/> </aop:aspect> </aop:config> \",\"此时就可以实现异步，相当于调用task方法会独立开一个线程\",\"alt text\"]},\"1226\":{\"h\":\"术语\",\"t\":[\"这里介绍一下 AOP 领域中的特性术语，防止自己下来看不懂文章：\",\"通知（Advice）: AOP 框架中的增强处理，通知描述了切面何时执行以及如何执行增强处理，也就是我们上面编写的方法实现。\",\"连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。\",\"切点（PointCut）: 可以插入增强处理的连接点，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。\",\"切面（Aspect）: 切面是通知和切点的结合，我们之前在xml中定义的就是切面，包括很多信息。\",\"引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。\",\"织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，我们之前都是在将我们的增强处理添加到目标对象，也就是织入（这名字挺有文艺范的）\"]},\"1227\":{\"c\":[\"code\"]},\"1228\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1229\":{\"h\":\"Javassm - AOP2\"},\"1230\":{\"h\":\"AOP面向切片2\"},\"1231\":{\"h\":\"使用接口实现AOP\",\"t\":[\"我们来看看如何使用Advice接口实现AOP。\",\"它与我们之前学习的动态代理更接近一些，比如在方法开始执行之前或是执行之后会去调用我们实现的接口，首先我们需要将一个类实现Advice接口，只有实现此接口，才可以被通知\",\"比如我们这里使用MethodBeforeAdvice表示是一个在方法执行之前的动作：\",\"public class StudentAOP implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\\\"通过Advice实现AOP\\\"); } } \",\"我们发现，方法中包括了很多的参数，其中args代表的是方法执行前得到的实参列表，还有target表示执行此方法的实例对象。\",\"运行之后，效果和之前是一样的，但是在这里我们就可以快速获取到更多信息。\",\"还是以简单的study方法为例：\",\"public class Student { public void study(){ System.out.println(\\\"我是学习方法！\\\"); } } \",\"xml不需要配置 <aop:aspect> 只需要 <aop:advisor> 来指明对应的bean和切入点\",\"<bean id=\\\"student\\\" class=\\\"org.example.entity.Student\\\"/> <bean id=\\\"studentAOP\\\" class=\\\"org.example.entity.StudentAOP\\\"/> <aop:config> <aop:pointcut id=\\\"test\\\" expression=\\\"execution(* org.example.entity.Student.study())\\\"/> <!-- 这里只需要添加我们刚刚写好的advisor就可以了，注意是Bean的名字 --> <aop:advisor advice-ref=\\\"studentAOP\\\" pointcut-ref=\\\"test\\\"/> </aop:config> \",\"alt text\",\"除了此接口以外，还有其他的接口，比如AfterReturningAdvice就需要实现一个方法执行之后的操作：\",\"public class StudentAOP implements MethodBeforeAdvice, AfterReturningAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\\\"通过Advice实现AOP\\\"); } @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\\\"我是方法执行之后的结果，方法返回值为：\\\"+returnValue); } } \",\"因为使用的是接口，就非常方便，直接写一起，配置文件都不需要改了\",\"我们也可以使用MethodInterceptor（同样也是Advice的子接口）进行更加环绕那样的自定义的增强，它用起来就真的像代理一样，例子如下：\",\"public class Student { public String study(){ System.out.println(\\\"我是学习方法！\\\"); return \\\"lbwnb\\\"; } } \",\"public class StudentAOP implements MethodInterceptor { //实现MethodInterceptor接口 @Override public Object invoke(MethodInvocation invocation) throws Throwable { //invoke方法就是代理方法 Object value = invocation.proceed(); //跟之前一样，需要手动proceed()才能调用原方法 return value+\\\"增强\\\"; } } \",\"使用起来还是挺简单的。\"]},\"1232\":{\"h\":\"使用注解实现AOP\",\"t\":[\"首先我们需要在主类添加@EnableAspectJAutoProxy注解，开启AOP注解支持：\",\"@EnableAspectJAutoProxy @ComponentScan(\\\"org.example.entity\\\") @Configuration public class MainConfiguration { } \",\"还是熟悉的玩法，类上直接添加@Component快速注册Bean：\",\"@Component public class Student { public void study(){ System.out.println(\\\"我是学习方法！\\\"); } } \"]},\"1233\":{\"h\":\"定义增强方法 ( )\",\"t\":[\"接着我们需要在定义AOP增强操作的类上添加@Aspect注解和@Component将其注册为Bean即可，就像我们之前在配置文件中也要将其注册为Bean那样：\",\"@Aspect @Component public class StudentAOP { } \",\"接着，我们可以在里面编写增强方法，并将此方法添加到一个切点中\",\"比如我们希望在Student的study方法执行之前执行我们的before方法：\",\"那么只需要添加@Before注解即可：\",\"@Before(\\\"execution(* org.example.entity.Student.study())\\\") //execution写法跟之前一样 public void before(){ System.out.println(\\\"我是之前执行的内容！\\\"); } \",\"这样，这个方法就会在指定方法执行之前执行了：\",\"public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student bean = context.getBean(Student.class); bean.study(); } \"]},\"1234\":{\"h\":\"添加 参数\",\"t\":[\"同样的，我们可以为其添加JoinPoint参数来获取切入点信息，使用方法跟之前一样：\",\"@Before(\\\"execution(* org.example.entity.Student.study())\\\") public void before(JoinPoint point){ System.out.println(\\\"参数列表：\\\"+ Arrays.toString(point.getArgs())); System.out.println(\\\"我是之前执行的内容！\\\"); } \"]},\"1235\":{\"h\":\"命名绑定模式\",\"t\":[\"为了更方便，我们还可以直接将参数放入，比如：\",\"public void study(String str){ System.out.println(\\\"我是学习方法！\\\"); } \",\"使用命名绑定模式，可以快速得到原方法的参数：\",\"@Before(value = \\\"execution(* org.example.entity.Student.study(..)) && args(str)\\\", argNames = \\\"str\\\") // 命名绑定模式就是根据下面的方法参数列表进行匹配 // 这里args指明参数，注意需要跟原方法保持一致，然后在argNames中指明 public void before(String str){ System.out.println(str); //可以快速得到传入的参数 System.out.println(\\\"我是之前执行的内容！\\\"); } \"]},\"1236\":{\"h\":\"其他注解\",\"t\":[\"除了@Before，还有很多可以直接使用的注解，比如@AfterReturning、@AfterThrowing等，比如@AfterReturning：\",\"public String study(){ System.out.println(\\\"我是学习方法！\\\"); return \\\"lbwnb\\\"; } \",\"@AfterReturning(value = \\\"execution(* org.example.entity.Student.study())\\\", argNames = \\\"returnVal\\\", returning = \\\"returnVal\\\") //使用returning指定接收方法返回值的参数returnVal public void afterReturn(Object returnVal){ System.out.println(\\\"返回值是：\\\"+returnVal); } \"]},\"1237\":{\"h\":\"环绕\",\"t\":[\"同样的，环绕也可以直接通过注解声明：\",\"@Around(\\\"execution(* com.test.bean.Student.test(..))\\\") public Object around(ProceedingJoinPoint point) throws Throwable { System.out.println(\\\"方法执行之前！\\\"); Object val = point.proceed(); System.out.println(\\\"方法执行之后！\\\"); return val; } \",\"实际上，无论是使用注解或是XML配置，我们要做的流程都是一样的，在之后的学习中，我们还会遇到更多需要使用AOP的地方。\"]},\"1238\":{\"c\":[\"code\"]},\"1239\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1240\":{\"h\":\"Javassm - 数据库框架整合1\"},\"1241\":{\"h\":\"数据库框架整合1\",\"t\":[\"学习了Spring之后，我们已经了解如何将一个类作为Bean交由IoC容器管理，这样，我们就可以通过更方便的方式来使用Mybatis框架，我们可以直接把SqlSessionFactory、Mapper交给Spring进行管理，并且可以通过注入的方式快速地使用它们。\"]},\"1242\":{\"h\":\"数据源 接口\",\"t\":[\"在之前，我们如果需要创建一个JDBC的连接，那么必须使用DriverManager.getConnection()来创建连接，连接建立后，通过创建Statement对象，就可以进行数据库操作。\",\"而学习了Mybatis之后，我们就不用再去使用DriverManager为我们提供连接对象，而是直接使用Mybatis为我们提供的SqlSessionFactory工具类来获取对应的SqlSession通过会话对象去操作数据库。\",\"那么，它到底是如何封装JDBC的呢？\",\"我们可以试着来猜想一下，会不会是Mybatis每次都是帮助我们调用DriverManager来实现的数据库连接创建？\",\"对应Mybatis的源码：\",\"public SqlSession openSession(boolean autoCommit) { return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, autoCommit); } \",\"在通过SqlSessionFactory调用openSession方法之后，它调用了内部的一个私有的方法openSessionFromDataSource，\",\"这个方法里面定义了的内容：\",\"private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) { Transaction tx = null; DefaultSqlSession var8; try { //获取当前环境（由配置文件映射的对象实体） Environment environment = this.configuration.getEnvironment(); //事务工厂（暂时不提，下一板块讲解） TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment); //配置文件中：<transactionManager type=\\\"JDBC\\\"/> //生成事务（根据我们的配置，会默认生成JdbcTransaction），这里是关键，我们看到这里用到了environment.getDataSource()方法 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); //执行器，包括全部的数据库操作方法定义，本质上是在使用执行器操作数据库，需要传入事务对象 Executor executor = this.configuration.newExecutor(tx, execType); //封装为SqlSession对象 var8 = new DefaultSqlSession(this.configuration, executor, autoCommit); } catch (Exception var12) { this.closeTransaction(tx); throw ExceptionFactory.wrapException(\\\"Error opening session. Cause: \\\" + var12, var12); } finally { ErrorContext.instance().reset(); } return var8; } \",\"也就是说，我们的数据源配置信息，存放在了Transaction对象中，那么现在我们只需要知道执行器到底是如何执行SQL语句的，我们就知道到底如何创建Connection对象了，这时就需要获取数据库的链接信息了，那么我们来看看，这个DataSource到底是个什么：\",\"public interface DataSource extends CommonDataSource, Wrapper { Connection getConnection() throws SQLException; Connection getConnection(String username, String password) throws SQLException; } \",\"我们发现，它是在javax.sql定义的一个接口，它包括了两个方法，都是用于获取连接的。\",\"因此，现在我们可以断定，并不是通过之前DriverManager的方法去获取连接了，而是使用DataSource的实现类来获取的，因此，也就正式引入到我们这一节的话题了：\",\"数据库链接的建立和关闭是极其耗费系统资源的操作，通过DriverManager获取的数据库连接，一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完后立即关闭连接，频繁的打开、关闭连接会持续消耗网络资源，造成整个系统性能的低下。\",\"因此，JDBC为我们定义了一个数据源的标准，也就是DataSource接口，告诉数据源数据库的连接信息，并将所有的连接全部交给数据源进行集中管理，当需要一个Connection对象时，可以向数据源申请，数据源会根据内部机制，合理地分配连接对象给我们。\",\"一般比较常用的DataSource实现，都是采用池化技术，就是在一开始就创建好N个连接，这样之后使用就无需再次进行连接，而是直接使用现成的Connection对象进行数据库操作。\",\"alt text\",\"当然，也可以使用传统的即用即连的方式获取Connection对象，Mybatis为我们提供了几个默认的数据源实现，之前一直使用的是官方的默认配置，也就是池化数据源：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"这里的type属性一共三个选项：\",\"UNPOOLED 不使用连接池的数据源\",\"POOLED 使用连接池的数据源\",\"JNDI 使用JNDI实现的数据源\"]},\"1243\":{\"h\":\"Mybatis数据源实现\",\"t\":[\"前面我们介绍了DataSource数据源，那么我们就来看看，Mybatis到底是怎么实现的。\",\"Mybatis总共就三种数据源\"]},\"1244\":{\"h\":\"不使用池化的数据源\",\"t\":[\"我们先来看看，不使用池化的数据源实现，它叫做UnpooledDataSource，我们来看看源码：\",\"public class UnpooledDataSource implements DataSource { private ClassLoader driverClassLoader; private Properties driverProperties; private static Map<String, Driver> registeredDrivers = new ConcurrentHashMap(); private String driver; private String url; private String username; private String password; private Boolean autoCommit; private Integer defaultTransactionIsolationLevel; private Integer defaultNetworkTimeout; ... } \",\"首先这个类中定义了很多的成员，包括数据库的连接信息、数据库驱动信息、事务相关信息等。\",\"我们接着来看，它是如何实现DataSource中提供的接口方法的：\",\"public Connection getConnection() throws SQLException { return this.doGetConnection(this.username, this.password); } public Connection getConnection(String username, String password) throws SQLException { return this.doGetConnection(username, password); } \",\"实际上，这两个方法都指向了内部的一个doGetConnection方法，那么我们接着来看：\",\"private Connection doGetConnection(String username, String password) throws SQLException { Properties props = new Properties(); if (this.driverProperties != null) { props.putAll(this.driverProperties); } if (username != null) { props.setProperty(\\\"user\\\", username); } if (password != null) { props.setProperty(\\\"password\\\", password); } return this.doGetConnection(props); } \",\"这里将用户名和密码配置封装为一个Properties对象，然后执行另一个重载同名的方法：\",\"private Connection doGetConnection(Properties properties) throws SQLException { //若未初始化驱动，需要先初始化，内部维护了一个Map来记录初始化信息，这里不多介绍了 this.initializeDriver(); //传统的获取连接的方式，是不是终于找到熟悉的味道了 Connection connection = DriverManager.getConnection(this.url, properties); //对连接进行额外的一些配置 this.configureConnection(connection); return connection; //返回得到的Connection对象 } \",\"到这里，就返回Connection对象了，而此对象正是通过DriverManager来创建的\",\"因此，非池化的数据源实现依然使用的是传统的连接创建方式.\"]},\"1245\":{\"h\":\"池化的数据源\",\"t\":[\"接着来看池化的数据源实现，它是PooledDataSource类：\",\"public class PooledDataSource implements DataSource { private static final Log log = LogFactory.getLog(PooledDataSource.class); private final PoolState state = new PoolState(this); //内部维护了一个非池化的数据源，这是要干嘛？ private final UnpooledDataSource dataSource; protected int poolMaximumActiveConnections = 10; protected int poolMaximumIdleConnections = 5; protected int poolMaximumCheckoutTime = 20000; protected int poolTimeToWait = 20000; protected int poolMaximumLocalBadConnectionTolerance = 3; protected String poolPingQuery = \\\"NO PING QUERY SET\\\"; protected boolean poolPingEnabled; protected int poolPingConnectionsNotUsedFor; private int expectedConnectionTypeCode; //并发相关类，我们在JUC篇视频教程中介绍过，感兴趣可以前往观看 private final Lock lock = new ReentrantLock(); private final Condition condition; } \",\"我们发现，在这里的定义就比非池化的实现复杂得多了，因为它还要考虑并发的问题，并且还要考虑如何合理地存放大量的链接对象，该如何进行合理分配\",\"因此它的玩法非常之高级。\",\"首先注意，它存放了一个UnpooledDataSource，此对象是在构造时就被创建，其实创建Connection还是依靠数据库驱动创建\",\"首先我们来看看它是如何实现接口方法的：\",\"public Connection getConnection() throws SQLException { return this.popConnection(this.dataSource.getUsername(), this.dataSource.getPassword()).getProxyConnection(); } public Connection getConnection(String username, String password) throws SQLException { return this.popConnection(username, password).getProxyConnection(); } \",\"可以看到，它调用了popConnection()方法来获取连接对象，然后进行了一个代理\",\"通过这方法名字我们可以猜测，有可能整个连接池就是一个类似于栈的集合类型结构实现的。\"]},\"1246\":{\"h\":\"方法\",\"t\":[\"那么我们接着来看看popConnection方法：\",\"主要是用PoolState类中维护了两个列表进行管理\",\"private PooledConnection popConnection(String username, String password) throws SQLException { boolean countedWait = false; //返回的是PooledConnection对象， PooledConnection conn = null; long t = System.currentTimeMillis(); int localBadConnectionCount = 0; while(conn == null) { // 现在加锁的源码，用 ReentrantLock // 直接 this.lock.lock(); synchronized(this.state) { // 加锁，因为有可能很多个线程都需要获取连接对象 PoolState var10000; // PoolState存了两个List，一个是空闲列表，一个是活跃列表 if (!this.state.idleConnections.isEmpty()) { // 有空闲的连接时，可以直接分配Connection conn = (PooledConnection)this.state.idleConnections.remove(0); //ArrayList中取第一个元素 if (log.isDebugEnabled()) { log.debug(\\\"Checked out connection \\\" + conn.getRealHashCode() + \\\" from pool.\\\"); } // 如果已经没有多余的连接可以分配，那么就检查一下活跃连接数是否达到最大的分配上限，如果没有，就new一个新的 } else if (this.state.activeConnections.size() < this.poolMaximumActiveConnections) { // 注意new了之后并没有立即往List里面塞，只是存了一些基本信息 // 我们发现，这里依靠UnpooledDataSource创建了一个Connection对象，并将其封装到PooledConnection中 // 所以说内部维护的UnpooledDataSource对象其实是为了节省代码，因为创建数据库连接其实都是一样的方式 conn = new PooledConnection(this.dataSource.getConnection(), this); if (log.isDebugEnabled()) { log.debug(\\\"Created connection \\\" + conn.getRealHashCode() + \\\".\\\"); } //以上条件都不满足，那么只能从之前的连接中寻找了，看看有没有那种卡住的链接（比如，由于网络问题有可能之前的连接一直被卡住，然而正常情况下早就结束并且可以使用了，所以这里相当于是优化也算是一种捡漏的方式） } else { // 获取最早创建的连接 PooledConnection oldestActiveConnection = (PooledConnection)this.state.activeConnections.get(0); long longestCheckoutTime = oldestActiveConnection.getCheckoutTime(); // 判断是否超过最大的使用时间 if (longestCheckoutTime > (long)this.poolMaximumCheckoutTime) { // 超时统计信息（不重要） ++this.state.claimedOverdueConnectionCount; var10000 = this.state; var10000.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime; var10000 = this.state; var10000.accumulatedCheckoutTime += longestCheckoutTime; // 从活跃列表中移除此链接信息 this.state.activeConnections.remove(oldestActiveConnection); // 如果开启事务，还需要回滚一下 if (!oldestActiveConnection.getRealConnection().getAutoCommit()) { try { oldestActiveConnection.getRealConnection().rollback(); } catch (SQLException var15) { log.debug(\\\"Bad connection. Could not roll back\\\"); } } // 这里就根据之前的连接对象直接new一个新的连接（注意使用的还是之前的Connection对象，并没有创建新的对象，只是被重新封装了） conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this); conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp()); conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp()); // 过期 oldestActiveConnection.invalidate(); if (log.isDebugEnabled()) { log.debug(\\\"Claimed overdue connection \\\" + conn.getRealHashCode() + \\\".\\\"); } } else { // 没有超时，那就确实是没连接可以用了，只能卡住了（阻塞） // 然后顺手记录一下目前有几个线程在等待其他的任务搞完 try { if (!countedWait) { ++this.state.hadToWaitCount; countedWait = true; } if (log.isDebugEnabled()) { log.debug(\\\"Waiting as long as \\\" + this.poolTimeToWait + \\\" milliseconds for connection.\\\"); } // 最后再等等 long wt = System.currentTimeMillis(); this.state.wait((long)this.poolTimeToWait); // 要是超过等待时间还是没等到，只能放弃了 // 注意这样的话con就为null了 var10000 = this.state; var10000.accumulatedWaitTime += System.currentTimeMillis() - wt; } catch (InterruptedException var16) { break; } } } // 经过之前的操作，并且已经成功分配到连接对象的情况下 if (conn != null) { if (conn.isValid()) { // 首先验证是否有效 if (!conn.getRealConnection().getAutoCommit()) { // 清理之前可能存在的遗留事务操作 conn.getRealConnection().rollback(); } conn.setConnectionTypeCode(this.assembleConnectionTypeCode(this.dataSource.getUrl(), username, password)); conn.setCheckoutTimestamp(System.currentTimeMillis()); conn.setLastUsedTimestamp(System.currentTimeMillis()); // 添加到活跃表中 this.state.activeConnections.add(conn); // 统计信息（不重要） ++this.state.requestCount; var10000 = this.state; var10000.accumulatedRequestTime += System.currentTimeMillis() - t; } else { // 无效的连接，直接抛异常 if (log.isDebugEnabled()) { log.debug(\\\"A bad connection (\\\" + conn.getRealHashCode() + \\\") was returned from the pool, getting another connection.\\\"); } ++this.state.badConnectionCount; ++localBadConnectionCount; conn = null; if (localBadConnectionCount > this.poolMaximumIdleConnections + this.poolMaximumLocalBadConnectionTolerance) { if (log.isDebugEnabled()) { log.debug(\\\"PooledDataSource: Could not get a good connection to the database.\\\"); } throw new SQLException(\\\"PooledDataSource: Could not get a good connection to the database.\\\"); } } } } } // 最后该干嘛干嘛，要是之前拿到的con是null的话，直接抛异常 if (conn == null) { if (log.isDebugEnabled()) { log.debug(\\\"PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.\\\"); } throw new SQLException(\\\"PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.\\\"); } else { return conn; // 否则正常返回 } } \",\"经过上面操作之后，我们可以得到以下信息：\",\"如果最后得到了连接对象（有可能是从空闲列表中得到，有可能是直接创建的新的，还有可能是经过回收策略回收得到的），那么连接(Connection)对象一定会被放在活跃列表中(state.activeConnections)\"]},\"1247\":{\"h\":\"代理对象\",\"t\":[\"那么肯定有一个疑问，现在我们已经知道获取一个链接会直接进入到活跃列表中，那么，如果一个连接被关闭，又会发生什么事情呢\",\"在此方法返回之后，会调用getProxyConnection来获取一个代理对象，实际上就是PooledConnection类：\",\"class PooledConnection implements InvocationHandler { private static final String CLOSE = \\\"close\\\"; private static final Class<?>[] IFACES = new Class[]{Connection.class}; private final int hashCode; // 会记录是来自哪一个数据源创建的的 private final PooledDataSource dataSource; // 连接对象本体 private final Connection realConnection; // 代理的链接对象 private final Connection proxyConnection; ... } \",\"它直接代理了构造方法中传入的Connection对象，也是使用JDK的动态代理实现的\",\"那么我们来看一下，它是如何进行代理的：\",\"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); // 如果调用的是Connection对象的close方法， if (\\\"close\\\".equals(methodName)) { // 这里并不会真的关闭连接（这也是为什么用代理），而是调用之前数据源的pushConnection方法，将此连接改为为空闲状态 this.dataSource.pushConnection(this); return null; } else { try { if (!Object.class.equals(method.getDeclaringClass())) { this.checkConnection(); // 任何操作执行之前都会检查连接是否可用 } // 原方法该干嘛干嘛 return method.invoke(this.realConnection, args); } catch (Throwable var6) { throw ExceptionUtil.unwrapThrowable(var6); } } } \",\"这下，池化数据源的大致流程其实就已经很清晰了，那么我们最后再来看看pushConnection方法：\",\"protected void pushConnection(PooledConnection conn) throws SQLException { synchronized(this.state) { // 老规矩，先来把锁 // 先从活跃列表移除此连接 this.state.activeConnections.remove(conn); // 判断此链接是否可用 if (conn.isValid()) { PoolState var10000; // 看看闲置列表容量是否已满（容量满了就回不去了） if (this.state.idleConnections.size() < this.poolMaximumIdleConnections && conn.getConnectionTypeCode() == this.expectedConnectionTypeCode) { var10000 = this.state; var10000.accumulatedCheckoutTime += conn.getCheckoutTime(); if (!conn.getRealConnection().getAutoCommit()) { conn.getRealConnection().rollback(); } // 把唯一有用的Connection对象拿出来，然后重新创建一个PooledConnection包装 PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this); // 放入闲置列表，成功回收 this.state.idleConnections.add(newConn); newConn.setCreatedTimestamp(conn.getCreatedTimestamp()); newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp()); conn.invalidate(); if (log.isDebugEnabled()) { log.debug(\\\"Returned connection \\\" + newConn.getRealHashCode() + \\\" to pool.\\\"); } this.state.notifyAll(); } else { var10000 = this.state; var10000.accumulatedCheckoutTime += conn.getCheckoutTime(); if (!conn.getRealConnection().getAutoCommit()) { conn.getRealConnection().rollback(); } conn.getRealConnection().close(); if (log.isDebugEnabled()) { log.debug(\\\"Closed connection \\\" + conn.getRealHashCode() + \\\".\\\"); } conn.invalidate(); } } else { if (log.isDebugEnabled()) { log.debug(\\\"A bad connection (\\\" + conn.getRealHashCode() + \\\") attempted to return to the pool, discarding connection.\\\"); } ++this.state.badConnectionCount; } } } \",\"这样，我们就已经完全了解了Mybatis的池化数据源的执行流程了。\",\"只不过，无论Connection管理方式如何变换，无论数据源再高级，我们要知道，它都最终都会使用DriverManager来创建连接对象，而最终使用的也是DriverManager提供的Connection对象。\"]},\"1248\":{\"c\":[\"code\"]},\"1249\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1250\":{\"h\":\"Javassm - 数据库框架整合2\"},\"1251\":{\"h\":\"数据库框架整合2\"},\"1252\":{\"h\":\"整合Mybatis框架\",\"t\":[\"通过了解数据源，我们已经清楚，Mybatis实际上是在使用自己编写的数据源（数据源实现其实有很多）默认使用的是池化数据源，它预先存储了很多的连接对象。\",\"如何将Mybatis与Spring更好的结合\"]},\"1253\":{\"h\":\"使用例子\",\"t\":[\"比如我们现在希望将SqlSessionFactory交给IoC容器进行管理，而不是我们自己创建工具类来管理（我们之前一直都在使用工具类管理和创建会话）\",\"<!-- 这两个依赖不用我说了吧 --> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <!-- 注意，对于Spring 6.0来说，版本需要在3.5以上 --> <version>3.5.13</version> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>8.0.31</version> </dependency> <!-- Mybatis针对于Spring专门编写的支持框架 --> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>3.0.2</version> </dependency> <!-- Spring的JDBC支持框架 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>6.0.10</version> </dependency> \"]},\"1254\":{\"h\":\"类\",\"t\":[\"在mybatis-spring依赖中，为我们提供了SqlSessionTemplate类，它其实就是官方封装的一个工具类，我们可以将其注册为Bean\",\"这样我们随时都可以向IoC容器索要对象，而不用自己再去编写一个工具类了，我们可以直接在配置类中创建。\",\"对于这种别人编写的类型，如果要注册为Bean，那么只能在配置类中完成：\",\"@Configuration @ComponentScan(\\\"org.example.entity\\\") public class MainConfiguration { // 注册SqlSessionTemplate的Bean @Bean public SqlSessionTemplate sqlSessionTemplate() throws IOException { SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(\\\"mybatis-config.xml\\\")); return new SqlSessionTemplate(factory); } } \"]},\"1255\":{\"h\":\"其他配置\",\"t\":[\"这里写一个测试的Mapper类：\",\"@Data public class Student { private int sid; private String name; private String sex; } \",\"public interface TestMapper { @Select(\\\"select * from student where sid = 1\\\") Student getStudent(); } \",\"最后是配置文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.cj.jdbc.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/study\\\"/> <property name=\\\"username\\\" value=\\\"root\\\"/> <property name=\\\"password\\\" value=\\\"123456\\\"/> </dataSource> </environment> </environments> <mappers> <mapper class=\\\"org.example.mapper.TestMapper\\\"/> </mappers> </configuration> \"]},\"1256\":{\"h\":\"测试\",\"t\":[\"public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); SqlSessionTemplate template = context.getBean(SqlSessionTemplate.class); TestMapper testMapper = template.getMapper(TestMapper.class); System.out.println(testMapper.getStudent()); } \",\"alt text\",\"这样，我们就成功将Mybatis与Spring完成了初步整合，直接从容器中就能获取到SqlSessionTemplate，结合自动注入，我们的代码量能够进一步的减少。\",\"虽然这样已经很方便了，但是还不够方便，我们依然需要手动去获取Mapper对象，那么能否直接得到对应的Mapper对象呢\"]},\"1257\":{\"h\":\"自动管理\",\"t\":[\"我们希望让Spring直接帮助我们管理所有的Mapper，当需要时，可以直接从容器中获取，我们可以直接在配置类上方添加注解：\",\"@Configuration @ComponentScan(\\\"org.example.entity\\\") @MapperScan(\\\"org.example.mapper\\\") public class MainConfiguration { } \",\"这样，Mybatis就会自动扫描对应包下所有的接口，并直接被注册为对应的Mapper作为Bean管理，那么我们现在就可以直接通过容器获取了：\",\"public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); TestMapper mapper = context.getBean(TestMapper.class); System.out.println(mapper.getStudent()); } \",\"在我们后续的SpringBoot学习阶段，会有更加方便的方式来注册Mapper，我们只需要一个@Mapper注解即可完成，非常简单。\",\"请一定注意，必须存在SqlSessionTemplate或是SqlSessionFactoryBean的Bean，否则会无法初始化（毕竟要数据库的链接信息）\"]},\"1258\":{\"h\":\"全注解配置\",\"t\":[\"我们接着来看，如果我们希望直接去除Mybatis的配置文件，完全实现全注解配置，那么改怎么去实现呢？\"]},\"1259\":{\"h\":\"继承 类\",\"t\":[\"我们可以使用SqlSessionFactoryBean类：\",\"@Configuration @ComponentScan(\\\"org.example.entity\\\") @MapperScan(\\\"org.example.mapper\\\") public class MainConfiguration { @Bean //单独创建一个Bean，方便之后更换 public DataSource dataSource(){ return new PooledDataSource(\\\"com.mysql.cj.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/study\\\", \\\"root\\\", \\\"123456\\\"); } @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //直接参数得到Bean对象 SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean; } } \",\"首先我们需要创建一个数据源的实现类，因为这是数据库最基本的信息，然后再给到SqlSessionFactoryBean实例\",\"这样，我们相当于直接在一开始通过IoC容器配置了SqlSessionFactory，这里只需要传入一个DataSource的实现即可，我们采用池化数据源。\",\"删除配置文件，重新再来运行，同样可以正常使用Mapper。\",\"从这里开始，通过IoC容器，Mybatis已经不再需要使用配置文件了，在我们之后的学习中，基于Spring的开发将不会再出现Mybatis的配置文件。\"]},\"1260\":{\"h\":\"HikariCP连接池\",\"t\":[\"数据源还有其他实现，比如C3P0、Druid等，都是非常优秀的数据源实现\",\"这里要介绍的，是在SpringBoot中还会遇到的HikariCP连接池。\",\"HikariCP是由日本程序员开源的一个数据库连接池组件，代码非常轻量，并且速度非常的快。根据官方提供的数据，在酷睿i7开启32个线程32个连接的情况下，进行随机数据库读写操作，HikariCP的速度是现在常用的C3P0数据库连接池的数百倍。在SpringBoot 3.0中，官方也是推荐使用HikariCP。\",\"alt text\",\"首先，我们需要导入依赖：\",\"<dependency> <groupId>com.zaxxer</groupId> <artifactId>HikariCP</artifactId> <version>5.0.1</version> </dependency> \",\"要更换数据源实现，非常简单\",\"可以直接声明一个Bean：\",\"@Bean public DataSource dataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\\\"jdbc:mysql://localhost:3306/study\\\"); dataSource.setDriverClassName(\\\"com.mysql.cj.jdbc.Driver\\\"); dataSource.setUsername(\\\"root\\\"); dataSource.setPassword(\\\"123456\\\"); return dataSource; } \",\"最后我们发现，同样可以得到输出结果，但是出现了一个报错：\",\"SLF4J: No SLF4J providers were found. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#noProviders for further details. \",\"此数据源实际上是采用了SLF4J日志框架打印日志信息，但是现在没有任何的日志实现\",\"(slf4j只是一个API标准，它规范了多种日志框架的操作，统一使用SLF4J定义的方法来操作不同的日志框架)\",\"我们这里就使用JUL作为日志实现，我们需要导入另一个依赖：\",\"<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-jdk14</artifactId> <version>1.7.25</version> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.25</version> </dependency> \",\"注意版本一定要和slf4j-api保持一致\",\"这样，HikariCP数据源的启动日志就可以正常打印出来了：\",\"8月 21, 2025 12:10:11 下午 com.zaxxer.hikari.HikariDataSource getConnection 信息: HikariPool-1 - Starting... 8月 21, 2025 12:10:12 下午 com.zaxxer.hikari.pool.HikariPool checkFailFast 信息: HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@18245eb0 8月 21, 2025 12:10:12 下午 com.zaxxer.hikari.HikariDataSource getConnection 信息: HikariPool-1 - Start completed. Student(sid=1, name=penguin, sex=男) \",\"在SpringBoot阶段，我们还会遇到HikariPool-1 - Starting...和HikariPool-1 - Start completed.同款日志信息。\",\"当然，Lombok肯定也是支持这个日志框架快速注解的：\",\"@Slf4j public class Main { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); TestMapper mapper = context.getBean(TestMapper.class); log.info(mapper.getStudent().toString()); } } \",\"自动在 Main 类中生成一个名为 log 的 Logger 对象（类型是 org.slf4j.Logger）\",\"使用时可以直接调用 log.info(...)、log.debug(...)、log.error(...) 等方法来打印日志。\"]},\"1261\":{\"c\":[\"code\"]},\"1262\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1263\":{\"h\":\"Javassm - 数据库框架整合2\"},\"1264\":{\"h\":\"数据库框架整合3\"},\"1265\":{\"h\":\"Mybatis事务管理\",\"t\":[\"通过将对应的Bean类型注册到容器中，就能更加方便的去使用Mapper\",\"接着来看Spring的事务控制。\"]},\"1266\":{\"h\":\"事务机制回顾\",\"t\":[\"回顾一下事务机制。首先事务遵循一个ACID原则：\",\"原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。\",\"一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。类比银行转账，从一个账号扣款，另一个账号增款，必须保证总金额不变。\",\"隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。类比多个人同时编辑同一文档，每个人看到的结果都是独立的，不会受其他人的影响，不过难免会存在冲突。\",\"持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。类比写入硬盘的文件，即使关机重启，文件仍然存在。\",\"简单来说，事务就是要么完成，要么就啥都别做！并且不同的事务之间相互隔离，互不干扰。\"]},\"1267\":{\"h\":\"隔离机制\",\"t\":[\"那么我们接着来深入了解一下事务的隔离机制\",\"个人理解：隔离机制就是规定不同事务来接触数据库时，所获得的数据信息的规则 当多个事务（Transaction）同时执行时，数据库需要通过一定的规则和策略， 保证这些事务之间不会互相干扰，从而确保数据的一致性和正确性。\",\"事务之间是相互隔离互不干扰的，那么如果出现了下面的情况，会怎么样呢：\",\"当两个事务同时在执行，并且同时在操作同一个数据，这样很容易出现并发相关的问题，比如一个事务先读取了某条数据，而另一个事务此时修改了此数据，当前一个事务紧接着再次读取时，会导致和前一次读取的数据不一致，这就是一种典型的数据虚读现象。\",\"因此，为了解决这些问题，事务之间实际上是存在一些隔离级别的：\",\"ISOLATION_READ_UNCOMMITTED（读未提交）：其他事务会读取当前事务尚未更改的提交（相当于读取的是这个事务暂时缓存的内容，并不是数据库中的内容）\",\"ISOLATION_READ_COMMITTED（读已提交）：其他事务会读取当前事务已经提交的数据（也就是直接读取数据库中已经发生更改的内容）\",\"ISOLATION_REPEATABLE_READ（可重复读）：其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改（注意这里仅仅是不允许修改数据）\",\"ISOLATION_SERIALIZABLE（串行化）：它完全服从ACID原则，一个事务必须等待其他事务结束之后才能开始执行，相当于挨个执行，效率很低\",\"我们依次来看看，不同的隔离级别会导致什么问题。\"]},\"1268\":{\"h\":\"\",\"t\":[\"首先是读未提交级别，此级别属于最低级别，相当于各个事务共享一个缓存区域，任何事务的操作都在这里进行。\",\"那么它会导致以下问题 (脏读)：\",\"alt text\",\"也就是说，事务A最后得到的实际上是一个毫无意义的数据（事务B已经回滚了）\",\"我们称此数据为\\\"脏数据\\\"，这种现象称为脏读\"]},\"1269\":{\"h\":\"\",\"t\":[\"我们接着来看读已提交级别，事务只能读取其他事务已经提交的内容，相当于直接从数据中读取数据，这样就可以避免脏读问题了，但是它还是存在以下问题：\",\"alt text\",\"这正是我们前面例子中提到的问题，虽然它避免了脏读问题，但是如果事件B修改并提交了数据，那么实际上事务A之前读取到的数据依然不是最新的数据，直接导致两次读取的数据不一致\",\"这种现象称为虚读也可以称为不可重复读\"]},\"1270\":{\"h\":\"\",\"t\":[\"因此，下一个隔离级别可重复读就能够解决这样的问题（MySQL的默认隔离级别）\",\"它规定在其他事务执行时，不允许修改数据，这样，就可以有效地避免不可重复读的问题\",\"但是这里仅仅是禁止了事务执行过程中的UPDATE操作，但是它并没有禁止INSERT这类操作，因此，如果事务A执行过程中事务B插入了新的数据，那么A这时是毫不知情的，比如：\",\"alt text\",\"两个人同时报名一个活动，两个报名的事务同时在进行，但是他们一开始读取到的人数都是5，而这时，它们都会认为报名成功后人数应该变成6，而正常情况下应该是7\",\"因此这个时候就发生了数据的幻读现象。\"]},\"1271\":{\"h\":\"\",\"t\":[\"因此，要解决这种问题，只能使用最后一种隔离级别串行化来实现了，每个事务不能同时进行，直接避免所有并发问题，简单粗暴，但是效率爆减，并不推荐。\",\"最后总结三种情况：\",\"脏读：读取到了被回滚的数据，它毫无意义。\",\"虚读（不可重复读）：由于其他事务更新数据，两次读取的数据不一致。\",\"幻读：由于其他事务执行插入删除操作，而又无法感知到表中记录条数发生变化，当下次再读取时会莫名其妙多出或缺失数据，就像产生幻觉一样。\",\"（对于虚读和幻读的区分：虚读是某个数据前后读取不一致，幻读是整个表的记录数量前后读取不一致\",\"最后这张图，请务必记在你的脑海，记在你的心中：\",\"alt text\"]},\"1272\":{\"h\":\"Mybatis事务封装介绍\",\"t\":[\"Mybatis对于数据库的事务管理，也有着相应的封装。\",\"一个事务无非就是创建、提交、回滚、关闭，因此这些操作被Mybatis抽象为一个接口：\",\"public interface Transaction { Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException; Integer getTimeout() throws SQLException; } \",\"对于此接口的实现，MyBatis的事务管理分为两种形式：\",\"使用JDBC的事务管理机制：即利用对应数据库的驱动生成的Connection对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等，对应的实现类为JdbcTransaction\",\"使用MANAGED的事务管理机制：这种机制MyBatis自身不会去实现事务管理，而是让程序的容器（比如Spring）来实现对事务的管理，对应的实现类为ManagedTransaction\",\"如果需要自定义，那么得实现org.apache.ibatis.transaction.Transaction接口，然后在type属性中指定其类名。使用自定义的事务管理器可以根据具体需求来实现一些特定的事务管理行为。\"]},\"1273\":{\"h\":\"接口实现1 ——\",\"t\":[\"而我们之前一直使用的其实就是JDBC的事务，相当于直接使用Connection对象（之前JavaWeb阶段已经讲解过了）在进行事务操作，并没有额外的管理机制，对应的配置为：\",\"<transactionManager type=\\\"JDBC\\\"/> \",\"那么我们来看看JdbcTransaction：\",\"public class JdbcTransaction implements Transaction { private static final Log log = LogFactory.getLog(JdbcTransaction.class); protected Connection connection; protected DataSource dataSource; protected TransactionIsolationLevel level; protected boolean autoCommit; public JdbcTransaction(DataSource ds, TransactionIsolationLevel desiredLevel, boolean desiredAutoCommit) { // 数据源 this.dataSource = ds; // 事务隔离级别，上面已经提到过了 this.level = desiredLevel; // 是否自动提交 this.autoCommit = desiredAutoCommit; } // 也可以直接给个Connection对象 public JdbcTransaction(Connection connection) { this.connection = connection; } public Connection getConnection() throws SQLException { // 没有就通过数据源新开一个Connection if (this.connection == null) { this.openConnection(); } return this.connection; } public void commit() throws SQLException { // 连接已经创建并且没开启自动提交才可以使用 if (this.connection != null && !this.connection.getAutoCommit()) { if (log.isDebugEnabled()) { log.debug(\\\"Committing JDBC Connection [\\\" + this.connection + \\\"]\\\"); } // 实际上使用的是数据库驱动提供的Connection对象进行事务操作 this.connection.commit(); } } ... } \",\"相当于JdbcTransaction只是为数据库驱动提供的Connection对象套了层壳，所有的事务操作实际上是直接调用Connection对象。\",\"那么我们接着来看ManagedTransaction的源码：\",\"public class ManagedTransaction implements Transaction { ... public void commit() throws SQLException { } public void rollback() throws SQLException { } ... } \",\"我们发现，大体内容和JdbcTransaction差不多，但是它并没有实现任何的事务操作。也就是说，它希望将实现交给其他的管理框架来完成，而Spring就为Mybatis提供了一个非常好的事务管理实现。\"]},\"1274\":{\"h\":\"Spring事务管理\",\"t\":[\"现在我们来学习一下Spring提供的事务管理（Spring事务管理分为编程式事务和声明式事务，但是编程式事务过于复杂并且具有高度耦合性，违背了Spring框架的设计初衷，因此这里只讲解声明式事务）\",\"声明式事务是基于AOP实现的。\",\"使用声明式事务非常简单\",\"只需要在配置类添加@EnableTransactionManagement注解即可\",\"这样就可以开启Spring的事务支持了。\",\"接着，我们只需要把一个事务要做的所有事情封装到Service层的一个方法中即可\"]},\"1275\":{\"h\":\"例子\"},\"1276\":{\"h\":\"1. 事务管理器\",\"t\":[\"首先需要在配置文件中注册一个新的Bean，事务需要执行必须有一个事务管理器：\",\"@Configuration @ComponentScan(\\\"org.example\\\") @MapperScan(\\\"org.example.mapper\\\") @EnableTransactionManagement public class MainConfiguration { @Bean public TransactionManager transactionManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } @Bean public DataSource dataSource() throws IOException { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\\\"jdbc:mysql://localhost:3306/study\\\"); dataSource.setDriverClassName(\\\"com.mysql.cj.jdbc.Driver\\\"); dataSource.setUsername(\\\"root\\\"); dataSource.setPassword(\\\"123456\\\"); return dataSource; } @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //直接参数得到Bean对象 SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean; } } \"]},\"1277\":{\"h\":\"2. 对应示例操作\",\"t\":[\"接着我们来编写一个简单的Mapper操作：\",\"@Mapper public interface TestMapper { ... @Insert(\\\"insert into student(name, sex) values('测试', '男')\\\") void insertStudent(); } \",\"这样会向数据库中插入一条新的学生信息\",\"接着，假设我们这里有一个业务需要连续插入两条学生信息\",\"首先编写业务层的接口：\",\"public interface TestService { void test(); } \",\"接着，我们再来编写业务层的实现，我们可以直接将其注册为Bean，交给Spring来进行管理\",\"这样就可以自动将Mapper注入到类中了，并且可以支持事务：\",\"@Component public class TestServiceImpl implements TestService{ @Resource TestMapper mapper; @Transactional // 此注解表示事务，之后执行的所有方法都会在同一个事务中执行 public void test() { mapper.insertStudent(); if(true) throw new RuntimeException(\\\"我是测试异常！\\\"); mapper.insertStudent(); } } \",\"我们只需在方法上添加@Transactional注解，即可表示此方法执行的是一个事务操作\",\"在调用此方法时，Spring会通过AOP机制为其进行增强，一旦发现异常，事务会自动回滚。\"]},\"1278\":{\"h\":\"3. 测试\",\"t\":[\"最后我们来调用一下此方法：\",\"@Slf4j public class Main { public static void main(String[] args) { log.info(\\\"项目正在启动...\\\"); ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class); TestService service = context.getBean(TestService.class); service.test(); } } \",\"得到的结果是出现错误：\",\"12月 17, 2022 4:09:00 下午 com.zaxxer.hikari.HikariDataSource getConnection 信息: HikariPool-1 - Start completed. Exception in thread \\\"main\\\" java.lang.RuntimeException: 我是测试异常！ at org.example.service.TestServiceImpl.test(TestServiceImpl.java:17) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:568) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) \",\"我们发现，整个栈追踪信息中包含了大量aop包下的内容，也就印证了它确实是通过AOP实现的\",\"结果显而易见，第一次的插入操作确实被回滚了，数据库中没有任何新增的内容。\"]},\"1279\":{\"h\":\"\",\"t\":[\"我们接着来研究一下@Transactional注解的一些参数：\",\"@Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { @AliasFor(\\\"transactionManager\\\") String value() default \\\"\\\"; @AliasFor(\\\"value\\\") String transactionManager() default \\\"\\\"; String[] label() default {}; Propagation propagation() default Propagation.REQUIRED; Isolation isolation() default Isolation.DEFAULT; int timeout() default -1; String timeoutString() default \\\"\\\"; boolean readOnly() default false; Class<? extends Throwable>[] rollbackFor() default {}; String[] rollbackForClassName() default {}; Class<? extends Throwable>[] noRollbackFor() default {}; String[] noRollbackForClassName() default {}; } \",\"几个比较关键的属性：\",\"transactionManager：指定事务管理器\",\"propagation：事务传播规则，一个事务可以包括N个子事务\",\"isolation：事务隔离级别，不多说了\",\"timeout：事务超时时间\",\"readOnly：是否为只读事务，不同的数据库会根据只读属性进行优化，比如MySQL一旦声明事务为只读，那么久不允许增删改操作了。\",\"rollbackFor和noRollbackFor：发生指定异常时回滚或是不回滚，默认发生任何异常都回滚。\"]},\"1280\":{\"h\":\"事务传播规则\",\"t\":[\"除了事务的传播规则，其他的内容其实已经给大家讲解过了，那么我们就来看看事务的传播。\",\"事务传播一共有七种级别：\",\"alt text\"]},\"1281\":{\"h\":\"级别\",\"t\":[\"Spring默认的传播级别是PROPAGATION_REQUIRED\",\"现在我们的Service类中一共存在两个事务，而一个事务方法包含了另一个事务方法：\",\"@Component public class TestServiceImpl implements TestService{ @Resource TestMapper mapper; @Transactional public void test() { test2(); // 包含另一个事务 if(true) throw new RuntimeException(\\\"我是测试异常！\\\"); // 发生异常时，会回滚另一个事务吗？ } @Transactional public void test2() { mapper.insertStudent(); } } \",\"最后我们得到结果，另一个事务也被回滚了\",\"也就是说，相当于另一个事务直接加入到此事务中，也就是表中所描述的那样。\",\"如果单独执行test2()则会开启一个新的事务，而执行test()则会直接让内部的test2()加入到当前事务中。\"]},\"1282\":{\"h\":\"级别\",\"t\":[\"现在我们将test2()的传播级别设定为SUPPORTS\",\"那么这时如果单独调用test2()方法，并不会以事务的方式执行，当发生异常时，虽然依然存在AOP增强，但是不会进行回滚操作\",\"而现在再调用test()方法，才会以事务的方式执行，即只有别的事务调用该方法，才会作为事务的一部分：\",\"@Transactional public void test() { test2(); } @Transactional(propagation = Propagation.SUPPORTS) public void test2() { mapper.insertStudent(); if(true) throw new RuntimeException(\\\"我是测试异常！\\\"); } \"]},\"1283\":{\"h\":\"级别\",\"t\":[\"我们接着来看MANDATORY，它非常严格，如果当前方法并没有在任何事务中进行，会直接出现异常：\",\"@Transactional public void test() { test2(); } @Transactional(propagation = Propagation.MANDATORY) public void test2() { mapper.insertStudent(); if(true) throw new RuntimeException(\\\"我是测试异常！\\\"); } \",\"直接运行test2()方法，报错如下：\",\"Exception in thread \\\"main\\\" org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory' at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:362) at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) at com.sun.proxy.$Proxy29.test2(Unknown Source) at com.test.Main.main(Main.java:17) \"]},\"1284\":{\"h\":\"其他级别\",\"t\":[\"NESTED级别表示如果存在外层事务，则此方法单独创建一个子事务，回滚只会影响到此子事务，实际上就是利用创建Savepoint，然后回滚到此保存点实现的。\",\"NEVER级别表示此方法不应该加入到任何事务中，其余类型适用于同时操作多数据源情况下的分布式事务管理，这里暂时不做介绍。\"]},\"1285\":{\"c\":[\"code\"]},\"1286\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1287\":{\"h\":\"Javassm - JUnit整合\"},\"1288\":{\"h\":\"JUnit整合\",\"t\":[\"集成JUnit测试\",\"既然使用了Spring，那么怎么集成到JUnit中进行测试呢，首先大家能够想到的肯定是：\",\"public class TestMain { @Test public void test(){ ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class); TestService service = context.getBean(TestService.class); service.test(); } } \",\"直接编写一个测试用例即可，但是这样的话，如果我们有很多个测试用例，那么我们不可能每次测试都去创建ApplicationContext吧？\"]},\"1289\":{\"h\":\"SpringTest模块\"},\"1290\":{\"h\":\"导入依赖\",\"t\":[\"Spring为我们提供了一个Test模块，它会自动集成Junit进行测试，我们可以导入一下依赖：\",\"<dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.9.0</version> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>6.0.10</version> </dependency> \",\"这里导入的是JUnit5和SpringTest模块依赖\"]},\"1291\":{\"h\":\"加入注解 +\",\"t\":[\"然后直接在我们的测试类上添加两个注解就可以搞定：\",\"@ExtendWith(SpringExtension.class) @ContextConfiguration(classes = TestConfiguration.class) public class TestMain { @Autowired TestService service; @Test public void test(){ service.test(); } } \",\"@ExtendWith是由JUnit提供的注解，等同于旧版本的@RunWith注解\",\"然后使用SpringTest模块提供的@ContextConfiguration注解来表示要加载哪一个配置文件，可以是XML文件也可以是类，我们这里就直接使用类进行加载。\",\"配置完成后，我们可以直接使用@Autowired来进行依赖注入，并且直接在测试方法中使用注入的Bean，现在就非常方便了。\",\"至此，SSM中的其中一个S（Spring）和一个M（Mybatis）就已经学完了，还剩下一个SpringMvc需要去学习。\"]},\"1292\":{\"c\":[\"code\"]},\"1293\":{\"c\":[\"javassm\",\"Spring\",\"SpringEL\"]},\"1294\":{\"h\":\"Javassm - Bean相关分析\"},\"1295\":{\"h\":\"Bean工厂与Bean定义\",\"t\":[\"实际上我们之前的所有操作都离不开一个东西，那就是IoC容器，那么它到底是如何实现呢？这一部分我们将详细介绍，首先我们大致了解一下ApplicationContext的加载流程：\",\"alt text\",\"alt text\"]},\"1296\":{\"h\":\"\",\"t\":[\"首先，容器既然要管理Bean，那么肯定需要一个完善的管理机制\",\"实际上，对Bean的管理都是依靠BeanFactory在进行，顾名思义BeanFactory就是对Bean进行生产和管理的工厂，我们可以尝试自己创建和使用BeanFactory对象：\",\"public static void main(String[] args) { BeanFactory factory = new DefaultListableBeanFactory(); //这是BeanFactory的一个默认实现类 System.out.println(\\\"获取Bean对象：\\\"+factory.getBean(\\\"lbwnb\\\")); //我们可以直接找工厂获取Bean对象 } \",\"我们可以直接找Bean工厂索要对象，只不过在一开始，工厂并不知道自己需要生产什么，可以生产什么\",\"我们只有告诉工厂我们要生产什么，怎么生产，工厂才能开工：\",\"public static void main(String[] args) { DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // 这是BeanFactory的一个默认实现类 BeanDefinition definition = BeanDefinitionBuilder // 使用BeanDefinitionBuilder快速创建Bean定义 .rootBeanDefinition(Student.class) // Bean的类型 .setScope(\\\"prototype\\\") // 设置作用域为原型模式 .getBeanDefinition(); // 生成此Bean定义 factory.registerBeanDefinition(\\\"lbwnb\\\", definition); // 向工厂注册Bean此定义，并设定Bean的名称 System.out.println(factory.getBean(\\\"lbwnb\\\")); // 现在就可以拿到了 } \",\"实际上，我们的ApplicationContext中就维护了一个AutowireCapableBeanFactory对象：\",\"public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext { @Nullable private volatile DefaultListableBeanFactory beanFactory; //默认构造后存放在这里的是一个DefaultListableBeanFactory对象 ... @Override public final ConfigurableListableBeanFactory getBeanFactory() { //getBeanFactory就可以直接得到上面的对象了 DefaultListableBeanFactory beanFactory = this.beanFactory; if (beanFactory == null) { throw new IllegalStateException(\\\"BeanFactory not initialized or already closed - \\\" + \\\"call 'refresh' before accessing beans via the ApplicationContext\\\"); } return beanFactory; } } \",\"可以尝试获取一下：\",\"ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); //我们可以直接获取此对象 System.out.println(context.getAutowireCapableBeanFactory()); \",\"正是因为这样，ApplicationContext才具有了管理和生产Bean对象的能力。\",\"不过，我们的配置可能是XML、可能是配置类，那么Spring要如何进行解析，将这些变成对应的BeanDefinition对象呢？\",\"使用BeanDefinitionReader就可以：\",\"public static void main(String[] args) { DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // 比如我们要读取XML配置，我们直接使用XmlBeanDefinitionReader就可以快速进行扫描 XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); // 加载此XML文件中所有的Bean定义到Bean工厂中 reader.loadBeanDefinitions(new ClassPathResource(\\\"application.xml\\\")); // 可以看到能正常生产此Bean的实例对象 System.out.println(factory.getBean(Student.class)); } \"]},\"1297\":{\"h\":\"实现方式\",\"t\":[\"因此，针对于不同类型的配置方式，ApplicationContext有着多种实现，其中常用的有：\",\"ClassPathXmlApplicationContext：适用于类路径下的XML配置文件。\",\"FileSystemXmlApplicationContext：适用于非类路径下的XML配置文件。\",\"AnnotationConfigApplicationContext：适用于注解配置形式。\",\"比如ClassPathXmlApplicationContext在初始化的时候就会创建一个对应的XmlBeanDefinitionReader进行扫描：\",\"@Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 为给定的BeanFactory创建XmlBeanDefinitionReader便于读取XML中的Bean配置 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 各种配置，忽略掉 beanDefinitionReader.setEnvironment(this.getEnvironment()); ... // 配置完成后，直接开始加载XML文件中的Bean定义 loadBeanDefinitions(beanDefinitionReader); } \",\"protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); //具体加载过程我就不详细介绍了 if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); } } \",\"现在，我们就已经知道，Bean实际上是一开始通过BeanDefinitionReader进行扫描，然后将所有Bean以BeanDefinition对象的形式注册到对应的BeanFactory中进行集中管理\",\"我们使用的ApplicationContext实际上内部就有一个BeanFactory在进行Bean管理，这样容器才拥有了最基本的Bean管理功能。\"]},\"1298\":{\"h\":\"继承\",\"t\":[\"当然，BeanFactory还可以具有父子关系，其中最关键的作用就是继承父容器中所有的Bean定义\",\"这样的话，如果我们想要创建一个新的BeanFactory并且默认具有其他BeanFactory中所有的Bean定义外加一些其他的，那么就可以采用这种形式，这是很方便的。\",\"我们可以来尝试一下，创建两个工厂：\",\"public class Main { public static void main(String[] args) { DefaultListableBeanFactory factoryParent = new DefaultListableBeanFactory(); DefaultListableBeanFactory factoryChild = new DefaultListableBeanFactory(); // 在父工厂中注册A factoryParent.registerBeanDefinition(\\\"a\\\", new RootBeanDefinition(A.class)); // 在子工厂中注册B、C factoryChild.registerBeanDefinition(\\\"b\\\", new RootBeanDefinition(B.class)); factoryChild.registerBeanDefinition(\\\"c\\\", new RootBeanDefinition(C.class)); // 最后设定子工厂的父工厂 factoryChild.setParentBeanFactory(factoryParent); } static class A{ } static class B{ } static class C{ } } \",\"现在我们来看看是不是我们想的那样：\",\"System.out.println(factoryChild.getBean(A.class)); //子工厂不仅能获取到自己的，也可以拿到父工厂的 System.out.println(factoryChild.getBean(B.class)); System.out.println(factoryChild.getBean(C.class)); System.out.println(factoryParent.getBean(B.class)); //注意父工厂不能拿到子工厂的，就像类的继承一样 \",\"同样的，我们在使用ApplicationContext时，也可以设定这样的父子关系，效果相同：\",\"public static void main(String[] args) { ApplicationContext contextParent = new ClassPathXmlApplicationContext(\\\"parent.xml\\\"); ApplicationContext contextChild = new ClassPathXmlApplicationContext(new String[]{\\\"child.xml\\\"}, contextParent); //第一个参数只能用数组，奇怪 } \",\"当然，除了这些功能之外，BeanFactory还提供了很多其他的管理Bean定义的方法，比如移除Bean定义、拷贝Bean定义、销毁单例Bean实例对象等功能，这里就不一一列出了，各位小伙伴自己调用一下测试就可以了，很简单。\"]},\"1299\":{\"h\":\"单例Bean的创建与循环依赖\",\"t\":[\"前面我们讲解了配置的Bean是如何被读取并加载到容器中的，接着我们来了解一下Bean实例对象是如何被创建并得到的\",\"我们知道，如果要得到一个Bean的实例很简单，通过getBean方法就可以直接拿到了：\",\"ApplicationContext context = new ClassPathXmlApplicationContext(\\\"application.xml\\\"); System.out.println(context.getBean(Student.class)); //通过此方法就能快速得到 \",\"那么，一个Bean的实例对象到底是如何创建出来的呢？\"]},\"1300\":{\"h\":\"分析\",\"t\":[\"我们还要继续对我们之前讲解的BeanFactory进行深入介绍。\",\"我们可以直接找到BeanFactory接口的一个抽象实现AbstractBeanFactory类，它实现了getBean()方法：\",\"public Object getBean(String name) throws BeansException { // 套娃开始了，做好准备 return this.doGetBean(name, (Class)null, (Object[])null, false); } \",\"那么我们doGetBean()接着来看方法里面干了什么，这个方法比较长，我们分段进行讲解：\",\"protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { String beanName = this.transformedBeanName(name); // 虽然这里直接传的就是name，但是万一是别名呢，所以还得要解析一下变成原本的Bean名字 Object sharedInstance = this.getSingleton(beanName); // 首先直接获取单例Bean对象 Object beanInstance; if (sharedInstance != null && args == null) { // 判断是否成功获取到共享的单例对象 ... }else{ ... } } \",\"因为所有的Bean默认都是单例模式，对象只会存在一个\",\"因此它会先调用父类的getSingleton()方法来直接获取单例对象，如果有的话，就可以直接拿到Bean的实例。\",\"如果Bean不是单例模式，那么会进入else代码块。\",\"这一部分我们先来看单例模式下的处理，其实逻辑非常简单：\",\"protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { ... if (sharedInstance != null && args == null) { if (this.logger.isTraceEnabled()) { // 这里会判断Bean是否为正在创建状态，为什么会有这种状态呢？我们会在后面进行介绍 if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.trace(\\\"Returning eagerly cached instance of singleton bean '\\\" + beanName + \\\"' that is not fully initialized yet - a consequence of a circular reference\\\"); } else { this.logger.trace(\\\"Returning cached instance of singleton bean '\\\" + beanName + \\\"'\\\"); } } //这里getObjectForBeanInstance会进行最终处理 //因为Bean有两个特殊的类型，工厂Bean和空Bean，所以说需要单独处理 //如果是普通Bean直接原样返回beanInstance接收到最终结果 beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null); } else { ... } //最后还会进行一次类型判断，如果都没问题，直接返回beanInstance作为结果，我们就得到Bean的实例对象了 return this.adaptBeanInstance(name, beanInstance, requiredType); } \",\"实际上整个单例Bean的创建路线还是很清晰的，并没有什么很难理解的地方，在正常情况下，其实就是简单的创建对象实例并返回即可。\"]},\"1301\":{\"h\":\"循环依赖的解决\",\"t\":[\"其中最关键的是它对于循环依赖的处理。\",\"我们发现，在上面的代码中，得到单例对象后，会有一个很特殊的判断isSingletonCurrentlyInCreation，这个是干嘛的？\",\"对象不应该直接创建出来吗？为什么会有这种正在创建的状态呢？我们来探究一下。\",\"开始之前先给大家提个问题：\",\"现在有两个Bean，A和B都是以原型模式进行创建，而A中需要注入B，B中需要注入A，这时就会出现A还未创建完成，就需要B，而B这时也没创建完成，因为B需要A，而A等着B，B又等着A，这样就只能无限循环下去了（就像死锁那种感觉）所以就出现了循环依赖的问题（同理，一个对象注入自己，还有三个对象之间，甚至多个对象之间也会出现这种情况）\",\"但是，在单例模式下，由于每个Bean只会创建一个实例，只要能够处理好对象之间的引用关系，Spring完全有机会解决单例对象循环依赖的问题。\",\"alt text\",\"我们回到一开始的getSingleton()方法中，研究一下它到底是如何处理循环依赖的，它是可以自动解决循环依赖问题的：\",\"@Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); // 先从第一层列表中拿Bean实例，拿到直接返回 if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) { // 如果第一层拿不到，并且已经认定为处于循环状态，看看第二层有没有 singletonObject = this.earlySingletonObjects.get(beanName); // 要是还是没有，继续往下 if (singletonObject == null && allowEarlyReference) { synchronized(this.singletonObjects) { // 加锁再执行一次上述流程 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) { // 仍然没有获取到实例，只能从singletonFactory中获取了 ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); // 丢进earlySingletonObjects中，下次就可以直接在第二层拿到了 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } } } return singletonObject; } \",\"看起来很复杂，实际上它使用了三级缓存的方式来处理循环依赖的问题，包括：\",\"singletonObjects，用于保存实例化、注入、初始化完成的 bean 实例\",\"earlySingletonObjects，用于保存实例化完成的 bean 实例\",\"singletonFactories，在初始创建Bean对象时都会生成一个对应的单例工厂用于获取早期对象\",\"我们先来画一个流程图理清整个过程：\",\"alt text\",\"我们在了解这个流程之前，一定要先明确，单例Bean对象的获取，会有哪些结果，首先就是如果我们获取的Bean压根就没在工厂中注册，那得到的结果肯定是null；\",\"其次，如果我们获取的Bean已经注册了，那么肯定就可以得到这个单例对象，只是不清楚创建到哪一个阶段了。\",\"现在我们根据上面的流程图，来模拟一下A和B循环依赖的情况：\",\"alt text\",\"看起来似乎两级缓存也可以解决问题啊，干嘛搞三层而且还搞个对象工厂？这不是多此一举吗？\",\"实际上这是为了满足Bean的生命周期而做的，通过工厂获取早期对象代码如下：\",\"protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) { Object exposedObject = bean; // 这里很关键，会对一些特别的BeanPostProcessor进行处理，比如AOP代理相关的，如果这个Bean是被AOP代理的，我们需要得到的是一个经过AOP代理的对象，而不是直接创建出来的对象，这个过程需要BeanPostProcessor来完成（AOP产生代理对象的逻辑是在属性填充之后，因此只能再加一级进行缓冲） if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) { exposedObject = bp.getEarlyBeanReference(exposedObject, beanName); } } return exposedObject; } \",\"我们会在后面的部分中详细介绍BeanPostProcessor以及AOP的实现原理，届时各位再回来看就会明白了。\"]},\"1302\":{\"c\":[\"code\"]},\"1303\":{\"c\":[\"javassm\",\"Spring\"]},\"1304\":{\"h\":\"Javassm - 后置处理器与AOP\"},\"1305\":{\"h\":\"后置处理器与AOP\"},\"1306\":{\"h\":\"\",\"t\":[\"介绍一下PostProcessor，它其实是Spring提供的一种后置处理机制\",\"可以让我们能够插手Bean、BeanFactory、BeanDefinition的创建过程，相当于进行一个最终的处理，而最后得到的结果（比如Bean实例、Bean定义等）就是经过后置处理器返回的结果\",\"它是整个加载过程的最后一步。\",\"而AOP机制正是通过它来实现\"]},\"1307\":{\"h\":\"\",\"t\":[\"相当于Bean初始化的一个后置动作，我们可以直接实现此接口：\",\"// 注意它后置处理器也要进行注册 @Component public class TestBeanProcessor implements BeanPostProcessor { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(beanName); //打印bean的名称 return bean; } @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); } } \",\"我们发现，此接口中包括两个方法\",\"一个是postProcessAfterInitialization用于在Bean初始化之后进行处理\",\"还有一个postProcessBeforeInitialization用于在Bean初始化之前进行处理\",\"注意这里的初始化不是创建对象，而是调用类的初始化方法，比如：\",\"@Component public class TestBeanProcessor implements BeanPostProcessor { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\\\"我是之后：\\\"+beanName); return bean; // 这里返回的Bean相当于最终的结果了，我们依然能够插手修改，这里返回之后是什么就是什么了 } @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\\\"我是之前：\\\"+beanName); return bean; // 这里返回的Bean会交给下一个阶段，也就是初始化方法 } } \"]},\"1308\":{\"h\":\"执行顺序分析\",\"t\":[\"@Component public class TestServiceImpl implements TestService{ public TestServiceImpl(){ System.out.println(\\\"我是构造方法\\\"); } @PostConstruct public void init(){ System.out.println(\\\"我是初始化方法\\\"); } TestMapper mapper; @Autowired public void setMapper(TestMapper mapper) { System.out.println(\\\"我是依赖注入\\\"); this.mapper = mapper; } ... } \",\"而TestServiceImpl的加载顺序为：\",\"我是构造方法 我是依赖注入 我是之前：testServiceImpl 我是初始化方法 我是之后：testServiceImpl \"]},\"1309\":{\"h\":\"加载流程\",\"t\":[\"现在我们再来总结一下一个Bean的加载流程：\",\"[Bean定义] 首先扫描Bean，加载Bean定义 -> [依赖注入] 根据Bean定义通过反射创建Bean实例 -> [依赖注入] 进行依赖注入（顺便解决循环依赖问题）\",\"-> [初始化Bean] BeanPostProcessor的初始化之前方法 -> [初始化Bean] @PostConstruct Bean初始化方法 -> [初始化Bean] BeanPostProcessor的初始化之后方法\",\"-> [完成]最终得到的Bean加载完成的实例\"]},\"1310\":{\"h\":\"实现过程\",\"t\":[\"利用这种机制，理解Aop的实现过程就非常简单了，AOP实际上也是通过这种机制实现的\",\"它的实现类是AnnotationAwareAspectJAutoProxyCreator，而它就是在最后对Bean进行了代理\",\"因此最后我们得到的结果实际上就是一个动态代理的对象（有关详细实现过程，这里就不进行列举了，感兴趣的可以继续深入）\",\"因此，实际上之前设计的三层缓存，都是由于需要处理AOP设计的，因为在Bean创建得到最终对象之前，很有可能会被PostProcessor给偷梁换柱！\",\"那么肯定有人有疑问了，这个类没有被注册啊，那按理说它不应该参与到Bean的初始化流程中的，为什么它直接就被加载了呢？\",\"还记得@EnableAspectJAutoProxy吗？我们来看看它是如何定义就知道了：\",\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Import({AspectJAutoProxyRegistrar.class}) public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false; } \",\"我们发现它使用了@Import来注册AspectJAutoProxyRegistrar，那么这个类又是什么呢，我们接着来看：\",\"class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar { AspectJAutoProxyRegistrar() { } public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 注册AnnotationAwareAspectJAutoProxyCreator到容器中 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); if (enableAspectJAutoProxy != null) { if (enableAspectJAutoProxy.getBoolean(\\\"proxyTargetClass\\\")) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } if (enableAspectJAutoProxy.getBoolean(\\\"exposeProxy\\\")) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } } \",\"它实现了接口，这个接口也是Spring提供的一种Bean加载机制，它支持直接向容器中添加Bean定义，容器也会加载这个Bean：\",\"ImportBeanDefinitionRegistrar类只能通过其他类@Import的方式来加载，通常是启动类或配置类。\",\"使用@Import，如果括号中的类是ImportBeanDefinitionRegistrar的实现类，则会调用接口中方法（一般用于注册Bean）\",\"实现该接口的类拥有注册bean的能力。\",\"我们可以看到此接口提供了一个BeanDefinitionRegistry正是用于注册Bean的定义的。\",\"因此，当我们打上了@EnableAspectJAutoProxy注解之后，首先会通过@Import加载AspectJAutoProxyRegistrar，然后调用其registerBeanDefinitions方法，然后使用工具类注册AnnotationAwareAspectJAutoProxyCreator到容器中\",\"这样在每个Bean创建之后，如果需要使用AOP，那么就会通过AOP的后置处理器进行处理，最后返回一个代理对象。\"]},\"1311\":{\"h\":\"\",\"t\":[\"我们也可以尝试编写一个自己的ImportBeanDefinitionRegistrar实现，首先编写一个测试Bean：\",\"public class TestBean { @PostConstruct void init(){ System.out.println(\\\"我被初始化了！\\\"); } } \",\"public class TestBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { BeanDefinition definition = BeanDefinitionBuilder.rootBeanDefinition(Student.class).getBeanDefinition(); registry.registerBeanDefinition(\\\"lbwnb\\\", definition); } } \",\"观察控制台输出，成功加载Bean实例。\",\"与BeanPostProcessor差不多的还有BeanFactoryPostProcessor，它和前者一样，也是用于我们自己处理后置动作的，不过这里是用于处理BeanFactory加载的后置动作\",\"BeanDefinitionRegistryPostProcessor直接继承自BeanFactoryPostProcessor，并且还添加了新的动作postProcessBeanDefinitionRegistry，你可以在这里动态添加Bean定义或是修改已经存在的Bean定义\",\"这里我们就直接演示BeanDefinitionRegistryPostProcessor的实现：\",\"@Component public class TestDefinitionProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { System.out.println(\\\"我是Bean定义后置处理！\\\"); BeanDefinition definition = BeanDefinitionBuilder.rootBeanDefinition(TestBean.class).getBeanDefinition(); registry.registerBeanDefinition(\\\"lbwnb\\\", definition); } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException { System.out.println(\\\"我是Bean工厂后置处理！\\\"); } } \",\"在这里注册Bean定义其实和之前那种方法效果一样。\",\"最后，我们再完善一下Bean加载流程（加粗部分是新增的）：\",\"[Bean定义]首先扫描Bean，加载Bean定义 -> [Bean定义]Bean定义和Bean工厂后置处理 -> [依赖注入]根据Bean定义通过反射创建Bean实例 -> [依赖注入]进行依赖注入（顺便解决循环依赖问题）-> [初始化Bean]BeanPostProcessor的初始化之前方法 -> [初始化Bean]Bean初始化方法 -> [初始化Bean]BeanPostProcessor的初始化之前后方法 -> [完成]最终得到的Bean加载完成的实例\"]},\"1312\":{\"c\":[\"code\"]},\"1313\":{\"c\":[\"javassm\",\"Spring\"]},\"1314\":{\"h\":\"Javassm - 应用程序上下文\"},\"1315\":{\"h\":\"应用程序上下文详解\",\"t\":[\"前面我们详细介绍了BeanFactory是如何工作的，接着我们来研究一下ApplicationContext的内部\",\"实际上我们真正在项目中使用的就是ApplicationContext的实现。\"]},\"1316\":{\"h\":\"接口\",\"t\":[\"public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { @Nullable String getId(); String getApplicationName(); String getDisplayName(); long getStartupDate(); @Nullable ApplicationContext getParent(); AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException; } \",\"它本身是一个接口，同时集成了多种类型的BeanFactory接口，说明它应该具有这些BeanFactory的能力，实际上我们在前面已经提到过\",\"ApplicationContext是依靠内部维护的BeanFactory对象来完成这些功能的，并不是它本身就实现了这些功能。\"]},\"1317\":{\"h\":\"分析\",\"t\":[\"这里我们就先从构造方法开始走起，以我们常用的AnnotationConfigApplicationContext为例：\",\"public AnnotationConfigApplicationContext(Class<?>... componentClasses) { this(); //1. 首先会调用自己的无参构造 register(componentClasses); //2. 然后注册我们传入的配置类 refresh(); //3. 最后进行刷新操作（关键） } \"]},\"1318\":{\"h\":\"调用无参构造\",\"t\":[\"先来看第一步：\",\"父类的无参构造调用，创建 beanFactory\",\"public GenericApplicationContext() { // 父类首先初始化内部维护的BeanFactory对象 this.beanFactory = new DefaultListableBeanFactory(); } \",\"自身无参构造调用\",\"public AnnotationConfigApplicationContext() { StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\\\"spring.context.annotated-bean-reader.create\\\"); // 创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解 this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); // 创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean this.scanner = new ClassPathBeanDefinitionScanner(this); } \",\"这样，AnnotationConfigApplicationContext的基本内容就初始化好了\",\"不过在Reader中会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中\",\"它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理：\",\"public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) { Assert.notNull(registry, \\\"BeanDefinitionRegistry must not be null\\\"); Assert.notNull(environment, \\\"Environment must not be null\\\"); this.registry = registry; this.conditionEvaluator = new ConditionEvaluator(registry, environment, null); // 这里注册了注解处理配置相关的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } \",\"实际上这个后置处理器的主要目的就是为了读取配置类中的各种Bean定义以及其他注解，比如@Import、@ComponentScan等。\",\"同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入，这里就不深入讲解具体实现了。\",\"所以，第一步结束之后，就会有这两个关键的后置处理器放在容器中：\",\"alt text\"]},\"1319\":{\"h\":\"注册配置类\",\"t\":[\"接着是第二步，注册配置类：\",\"@Override public void register(Class<?>... componentClasses) { Assert.notEmpty(componentClasses, \\\"At least one component class must be specified\\\"); StartupStep registerComponentClass = this.getApplicationStartup().start(\\\"spring.context.component-classes.register\\\") .tag(\\\"classes\\\", () -> Arrays.toString(componentClasses)); //使用我们上面创建的Reader注册配置类 this.reader.register(componentClasses); registerComponentClass.end(); } \",\"现在配置类已经成功注册到IoC容器中了\"]},\"1320\":{\"h\":\"机制\",\"t\":[\"我们接着来看第三步，到目前为止，我们已知的仅仅是注册了配置类的Bean，而刷新操作就是配置所有Bean的关键部分了\",\"刷新操作是在 AbstractApplicationContext 中实现的：\",\"@Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // 准备当前应用程序上下文，进行刷新、设置启动事件和活动标志以及执行其他初始化 prepareRefresh(); // 这个方法由子类实现，对内部维护的BeanFactory进行刷新操作，然后返回这个BeanFactory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 初始化配置Bean工厂，比如一些会用到的类加载器和后置处理器。 prepareBeanFactory(beanFactory); try { // 由子类实现对BeanFactory的其他后置处理，目前没有看到有实现 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // 实例化并调用所有注册的 BeanFactoryPostProcessor 类型的Bean // 这一步中，上面提到的BeanFactoryPostProcessor就开始工作了，比如包扫描、解析Bean配置等 // 这一步结束之后，包扫描到的其他Bean就注册到BeanFactory中了 invokeBeanFactoryPostProcessors(beanFactory); // 实例化并注册所有 BeanPostProcessor 类型的 Bean，不急着执行 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); initMessageSource(); initApplicationEventMulticaster(); // 依然是提供给子类实现的，目的是用于处理一些其他比较特殊的Bean，目前似乎也没看到有实现 onRefresh(); // 注册所有的监听器 registerListeners(); // 将剩余所有非懒加载单例Bean全部实例化 finishBeanFactoryInitialization(beanFactory); finishRefresh(); } catch (BeansException ex) { ... // 发现异常直接销毁所有Bean destroyBeans(); // 取消本次刷新操作，重置标记 cancelRefresh(ex); // 继续往上抛异常 throw ex; } finally { resetCommonCaches(); contextRefresh.end(); } } } \",\"所以，现在流程就很清晰了，实际上最主要的就是refresh方法，它从初始化到实例化所有的Bean整个流程都已经完成，在这个方法结束之后，整个IoC容器基本就可以正常使用了。\"]},\"1321\":{\"h\":\"方法\",\"t\":[\"我们继续来研究一下finishBeanFactoryInitialization方法，看看它是怎么加载所有Bean的\",\"将剩余所有非懒加载单例Bean全部实例化：\",\"protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { ... beanFactory.preInstantiateSingletons(); //套娃 } \",\" @Override public void preInstantiateSingletons() throws BeansException { ... // 列出全部bean名称 List<String> beanNames = new ArrayList<>(this.beanDefinitionNames); // 开始初始化所有Bean for (String beanName : beanNames) { // 得到Bean定义 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // Bean不能是抽象类、不能是非单例模式、不能是懒加载的 if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { // 针对于Bean和FactoryBean分开进行处理 if (isFactoryBean(beanName)) { Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) { getBean(beanName); } } else { getBean(beanName); // 最后都是通过调用getBean方法来初始化实例，这里就跟我们之前讲的连起来了 } } } ... } \"]},\"1322\":{\"c\":[\"code\"]},\"1323\":{\"c\":[\"javassm\",\"Spring\"]},\"1324\":{\"h\":\"Javassm - Mybatis整合原理\"},\"1325\":{\"h\":\"Mybatis整合原理\"},\"1326\":{\"h\":\"实现\",\"t\":[\"通过之前的了解，我们再来看Mybatis的@MapperScan是如何实现的，现在理解起来就非常简单了。\",\"我们可以直接打开查看：\",\"@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) @Documented @Import({MapperScannerRegistrar.class}) @Repeatable(MapperScans.class) public @interface MapperScan { String[] value() default {}; String[] basePackages() default {}; ... } \",\"我们发现，和Aop一样，它也是通过Registrar机制，通过@Import来进行Bean的注册\",\"我们来看看MapperScannerRegistrar是个什么东西，关键代码如下：\",\"void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) { BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class); builder.addPropertyValue(\\\"processPropertyPlaceHolders\\\", true); ... } \",\"虽然很长很多，但是这些代码都是在添加一些Bean定义的属性，而最关键的则是最上方的MapperScannerConfigurer，Mybatis将其Bean信息注册到了容器中\"]},\"1327\":{\"h\":\"类\",\"t\":[\"那么这个类又是干嘛的呢？\",\"public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware { private String basePackage; ... } \",\"它实现了BeanDefinitionRegistryPostProcessor，也就是说它为Bean信息加载提供了后置处理\",\"我们接着来看看它在Bean信息后置处理中做了什么：\",\"public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { if (this.processPropertyPlaceHolders) { this.processPropertyPlaceHolders(); } // 初始化类路径Mapper扫描器，它相当于是一个工具类，可以快速扫描出整个包下的类定义信息 // ClassPathMapperScanner是Mybatis自己实现的一个扫描器，修改了一些扫描规则 ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass); if (StringUtils.hasText(this.lazyInitialization)) { scanner.setLazyInitialization(Boolean.valueOf(this.lazyInitialization)); } if (StringUtils.hasText(this.defaultScope)) { scanner.setDefaultScope(this.defaultScope); } // 添加过滤器，这里会配置为所有的接口都能被扫描（因此即使你不添加@Mapper注解都能够被扫描并加载） scanner.registerFilters(); // 开始扫描 scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, \\\",; \\\\t\\\\n\\\")); } \",\"开始扫描后，会调用doScan()方法，我们接着来看（这是ClassPathMapperScanner中的扫描方法）：\",\"public Set<BeanDefinitionHolder> doScan(String... basePackages) { Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages); // 首先从包中扫描所有的Bean定义 if (beanDefinitions.isEmpty()) { LOGGER.warn(() -> { return \\\"No MyBatis mapper was found in '\\\" + Arrays.toString(basePackages) + \\\"' package. Please check your configuration.\\\"; }); } else { // 处理所有的Bean定义，实际上就是生成对应Mapper的代理对象，并注册到容器中 this.processBeanDefinitions(beanDefinitions); } // 最后返回所有的Bean定义集合 return beanDefinitions; } \",\"通过断点我们发现，最后处理得到的Bean定义发现此Bean是一个MapperFactoryBean，它不同于普通的Bean\",\"FactoryBean相当于为普通的Bean添加了一层外壳，它并不是依靠Spring直接通过反射创建，而是使用接口中的方法：\",\"public interface FactoryBean<T> { String OBJECT_TYPE_ATTRIBUTE = \\\"factoryBeanObjectType\\\"; @Nullable T getObject() throws Exception; @Nullable Class<?> getObjectType(); default boolean isSingleton() { return true; } } \",\"通过getObject()方法，就可以获取到Bean的实例了。\"]},\"1328\":{\"h\":\"和\",\"t\":[\"注意这里一定要区分FactoryBean和BeanFactory的概念：\",\"BeanFactory是个Factory，也就是 IOC 容器或对象工厂，所有的 Bean 都是由 BeanFactory( 也就是 IOC 容器 ) 来进行管理。\",\"FactoryBean是一个能生产或者修饰生成对象的工厂Bean(本质上也是一个Bean)，可以在BeanFactory（IOC容器）中被管理，所以它并不是一个简单的Bean。当使用容器中factory bean的时候，该容器不会返回factory bean本身，而是返回其生成的对象。要想获取FactoryBean的实现类本身，得在getBean(String BeanName)中的BeanName之前加上&,写成getBean(String &BeanName)。\",\"我们也可以自己编写一个实现：\",\"@Component(\\\"test\\\") public class TestFb implements FactoryBean<Student> { @Override public Student getObject() throws Exception { System.out.println(\\\"获取了学生\\\"); return new Student(); } @Override public Class<?> getObjectType() { return Student.class; } } \",\"public static void main(String[] args) { log.info(\\\"项目正在启动...\\\"); ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class); System.out.println(context.getBean(\\\"&test\\\")); // 得到FactoryBean本身（得加个&搞得像C语言指针一样） System.out.println(context.getBean(\\\"test\\\")); // 得到FactoryBean调用getObject()之后的结果 } \",\"因此，实际上我们的Mapper最终就以FactoryBean的形式，被注册到容器中进行加载了：\",\"public T getObject() throws Exception { return this.getSqlSession().getMapper(this.mapperInterface); } \",\"这样，整个Mybatis的@MapperScan的原理就全部解释完毕了。\",\"在了解完了Spring的底层原理之后，我们其实已经完全可以根据这些实现原理来手写一个Spring框架了。\"]},\"1329\":{\"c\":[\"code\"]},\"1330\":{\"c\":[\"javassm\",\"Spring\"]},\"1331\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"1332\":{\"h\":\"Daily\"},\"1333\":{\"h\":\"UAV\"},\"1334\":{\"h\":\"Academic\"},\"1335\":{\"h\":\"强化学习\"},\"1336\":{\"h\":\"Java\"},\"1337\":{\"h\":\"Code\"},\"1338\":{\"h\":\"Java 9 17\"},\"1339\":{\"h\":\"Java Hint\"},\"1340\":{\"h\":\"Spring Mvc\"},\"1341\":{\"h\":\"Java Ssm\"},\"1342\":{\"h\":\"Spring Security\"},\"1343\":{\"h\":\"1 Socket\"},\"1344\":{\"h\":\"Javaweb\"},\"1345\":{\"h\":\"2 数据库\"},\"1346\":{\"h\":\"3 Lombok\"},\"1347\":{\"h\":\"4 Mybatis\"},\"1348\":{\"h\":\"5 JUL\"},\"1349\":{\"h\":\"6 JUnit\"},\"1350\":{\"h\":\"7 Maven\"},\"1351\":{\"h\":\"8 网络内容\"},\"1352\":{\"h\":\"1 Io C容器\"},\"1353\":{\"h\":\"Spring\"},\"1354\":{\"h\":\"2 Spring高级特性\"},\"1355\":{\"h\":\"3 AOP\"},\"1356\":{\"h\":\"4 数据库框架整合\"},\"1357\":{\"h\":\"5 JUnit整合\"},\"1358\":{\"h\":\"6 原理\"}},\"dirtCount\":0,\"index\":[[\"搞得像c语言指针一样\",{\"1\":{\"1328\":1}}],[\"观察控制台输出\",{\"1\":{\"1311\":1}}],[\"观察结果\",{\"1\":{\"304\":1}}],[\"理解aop的实现过程就非常简单了\",{\"1\":{\"1310\":1}}],[\"届时各位再回来看就会明白了\",{\"1\":{\"1301\":1}}],[\"干嘛搞三层而且还搞个对象工厂\",{\"1\":{\"1301\":1}}],[\"干净\",{\"1\":{\"228\":1}}],[\"丢进earlysingletonobjects中\",{\"1\":{\"1301\":1}}],[\"仍然没有获取到实例\",{\"1\":{\"1301\":1}}],[\"仍然是获取不到具体的\",{\"1\":{\"343\":1}}],[\"研究一下它到底是如何处理循环依赖的\",{\"1\":{\"1301\":1}}],[\"拷贝bean定义\",{\"1\":{\"1298\":1}}],[\"拷贝个基莫\",{\"1\":{\"377\":1}}],[\"奇怪\",{\"1\":{\"1298\":1}}],[\"忽略掉\",{\"1\":{\"1297\":1}}],[\"忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告\",{\"1\":{\"361\":1}}],[\"集成junit测试\",{\"1\":{\"1288\":1}}],[\"集合操作相关语法\",{\"0\":{\"1206\":1}}],[\"集合操作能不能也安排点高级的玩法呢\",{\"1\":{\"232\":1}}],[\"集合还可以调用\",{\"1\":{\"516\":1}}],[\"集合运算和表达的高阶抽象\",{\"1\":{\"228\":1}}],[\"集合只是粗略的进行了讲解\",{\"1\":{\"207\":1}}],[\"集合中基本都是从\",{\"1\":{\"204\":1}}],[\"集合中的每一个元素就是一个集合\",{\"1\":{\"182\":1}}],[\"集合的具体类型\",{\"1\":{\"234\":1}}],[\"集合的各种功能我们都可以来测试一下\",{\"1\":{\"182\":1}}],[\"集合的\",{\"1\":{\"181\":1}}],[\"集合的大小是可变的\",{\"1\":{\"179\":1}}],[\"集合根接口\",{\"0\":{\"180\":1}}],[\"集合跟数组一样\",{\"1\":{\"179\":1}}],[\"集合\",{\"0\":{\"204\":1},\"1\":{\"178\":1}}],[\"集合表示一组对象\",{\"1\":{\"178\":1}}],[\"集合其实与我们数学中的集合是差不多的概念\",{\"1\":{\"178\":1}}],[\"集合类型情况\",{\"0\":{\"1136\":1}}],[\"集合类新增工厂方法\",{\"0\":{\"475\":1}}],[\"集合类中有一个东西是java8新增的spliterator接口\",{\"1\":{\"330\":1}}],[\"集合类中并不是通过\",{\"1\":{\"241\":1}}],[\"集合类中继承的方法这里也不多种介绍了\",{\"1\":{\"201\":1}}],[\"集合类对象相等判定\",{\"0\":{\"240\":1,\"241\":1}}],[\"集合类同样支持这种语法\",{\"1\":{\"187\":1}}],[\"集合类是支持嵌套使用的\",{\"1\":{\"182\":1}}],[\"集合类是java中非常重要的存在\",{\"1\":{\"178\":1}}],[\"集合类基本都是在java\",{\"1\":{\"180\":1}}],[\"集合类与数组区别\",{\"0\":{\"179\":1}}],[\"集合类其实就是为了更好地组织\",{\"1\":{\"178\":1}}],[\"集合类\",{\"0\":{\"176\":1,\"177\":1,\"178\":1,\"185\":1,\"186\":1,\"192\":1,\"197\":1,\"198\":1,\"210\":1,\"211\":1,\"330\":1},\"1\":{\"192\":1,\"330\":1,\"994\":1}}],[\"几个比较关键的属性\",{\"1\":{\"1279\":1}}],[\"几乎所有的依赖都被放到了中央仓库中\",{\"1\":{\"1009\":1}}],[\"几乎能够无视一切阻拦\",{\"1\":{\"350\":1}}],[\"几乎都在操作内部维护的一个hashmap\",{\"1\":{\"224\":1}}],[\"违背了spring框架的设计初衷\",{\"1\":{\"1274\":1}}],[\"幻读是整个表的记录数量前后读取不一致\",{\"1\":{\"1271\":1}}],[\"幻读\",{\"1\":{\"1271\":1}}],[\"虚读是某个数据前后读取不一致\",{\"1\":{\"1271\":1}}],[\"虚读\",{\"1\":{\"1271\":1}}],[\"虚拟过滤器链\",{\"0\":{\"710\":1}}],[\"脏数据\",{\"1\":{\"1268\":1}}],[\"脏读\",{\"1\":{\"1268\":1,\"1271\":1}}],[\"串行化\",{\"1\":{\"1267\":1}}],[\"串联性以及后续数据库可以自发性地完成预定的工作\",{\"1\":{\"782\":1}}],[\"互不干扰\",{\"1\":{\"1266\":1}}],[\"统一使用slf4j定义的方法来操作不同的日志框架\",{\"1\":{\"1260\":1}}],[\"统计信息\",{\"1\":{\"1246\":1}}],[\"统计某列的值总和\",{\"1\":{\"765\":1}}],[\"统计所有的行数\",{\"1\":{\"765\":1}}],[\"毕竟要数据库的链接信息\",{\"1\":{\"1257\":1}}],[\"毕竟peek方法可以修改流中元素\",{\"1\":{\"514\":1}}],[\"容量满了就回不去了\",{\"1\":{\"1247\":1}}],[\"容器或对象工厂\",{\"1\":{\"1328\":1}}],[\"容器也会加载这个bean\",{\"1\":{\"1310\":1}}],[\"容器既然要管理bean\",{\"1\":{\"1296\":1}}],[\"容器就会自动调用此方法\",{\"1\":{\"1186\":1}}],[\"容器就不会创建这个bean的对象了\",{\"1\":{\"1151\":1}}],[\"容器会调用bean对应类型的构造方法进行对象创建\",{\"1\":{\"1157\":1}}],[\"容器会去找注册的bean是否有对应的类或者其类的子类\",{\"1\":{\"1125\":1}}],[\"容器创建时\",{\"1\":{\"1148\":1}}],[\"容器加载配置时\",{\"1\":{\"1129\":1}}],[\"容器中只要注册了对应类的bean或是对应类型子类的bean\",{\"1\":{\"1125\":1}}],[\"容器\",{\"1\":{\"1058\":1,\"1328\":1}}],[\"老规矩\",{\"1\":{\"1247\":1}}],[\"老的版本是不支持的哦\",{\"1\":{\"1054\":1}}],[\"池化数据源的大致流程其实就已经很清晰了\",{\"1\":{\"1247\":1}}],[\"池化的数据源\",{\"0\":{\"1245\":1}}],[\"然而正常情况下早就结束并且可以使用了\",{\"1\":{\"1246\":1}}],[\"然后返回这个beanfactory\",{\"1\":{\"1320\":1}}],[\"然后注册我们传入的配置类\",{\"1\":{\"1317\":1}}],[\"然后调用其registerbeandefinitions方法\",{\"1\":{\"1310\":1}}],[\"然后回滚到此保存点实现的\",{\"1\":{\"1284\":1}}],[\"然后重新创建一个pooledconnection包装\",{\"1\":{\"1247\":1}}],[\"然后顺手记录一下目前有几个线程在等待其他的任务搞完\",{\"1\":{\"1246\":1}}],[\"然后通过getvalue\",{\"1\":{\"1203\":1}}],[\"然后通过反射进行赋值\",{\"1\":{\"841\":1}}],[\"然后配置一下包扫描\",{\"1\":{\"1177\":1}}],[\"然后配置关联查询相关信息\",{\"1\":{\"850\":1}}],[\"然后让对应的工厂类继承factorybean\",{\"1\":{\"1160\":1}}],[\"然后请求的数据全部交给对应的service\",{\"1\":{\"1116\":1}}],[\"然后去配置文件修改\",{\"1\":{\"1225\":1}}],[\"然后去mybatis\",{\"1\":{\"1071\":1}}],[\"然后去\",{\"1\":{\"1059\":1}}],[\"然后点击完成\",{\"1\":{\"1048\":1}}],[\"然后设置tomcat主目录即可\",{\"1\":{\"1048\":1}}],[\"然后依次build直到所有任务都完成\",{\"1\":{\"1038\":1}}],[\"然后可以在控制台看到当前的测试用例耗时以及状态\",{\"1\":{\"959\":1}}],[\"然后直接在我们的测试类上添加两个注解就可以搞定\",{\"1\":{\"1291\":1}}],[\"然后直接通过注解的形式引用\",{\"1\":{\"899\":1}}],[\"然后直接配置base\",{\"1\":{\"549\":1}}],[\"然后这里我们传入的参数直接写成对应的类型即可\",{\"1\":{\"861\":1}}],[\"然后查询得到的实体对象作为value\",{\"1\":{\"836\":1}}],[\"然后得到的结果作为value的map\",{\"1\":{\"836\":1}}],[\"然后将所有bean以beandefinition对象的形式注册到对应的beanfactory中进行集中管理\",{\"1\":{\"1297\":1}}],[\"然后将idea的maven配置为我们自行安装的位置\",{\"1\":{\"1010\":1}}],[\"然后将这些参数添加到map中进行传递\",{\"1\":{\"843\":1}}],[\"然后将我们的参数填写到后面\",{\"1\":{\"832\":1}}],[\"然后将其编写到我们的诈骗网站中\",{\"1\":{\"642\":1}}],[\"然后就可以在其前后写我们的动作来执行\",{\"1\":{\"1224\":1}}],[\"然后就是将我们的增强方法\",{\"1\":{\"1220\":1}}],[\"然后就是通过后面的expression表达式来选择到我们需要切入的方法\",{\"1\":{\"1219\":1}}],[\"然后就是响应内容\",{\"1\":{\"727\":1}}],[\"然后就能够正确查询了\",{\"1\":{\"835\":1}}],[\"然后就在标签中写入我们的查询语句即可\",{\"1\":{\"826\":1}}],[\"然后就进行\",{\"1\":{\"708\":1}}],[\"然后存入到securitycontextholder中\",{\"1\":{\"714\":1}}],[\"然后执行另一个重载同名的方法\",{\"1\":{\"1244\":1}}],[\"然后执行install或直接在命令行中输入mvn\",{\"1\":{\"1023\":1}}],[\"然后执行\",{\"1\":{\"709\":1}}],[\"然后利用工厂类去生成需要的bean对象\",{\"1\":{\"1157\":1}}],[\"然后利用初始化时创建的\",{\"1\":{\"708\":1}}],[\"然后利用该会话id冒充用户进行操作\",{\"1\":{\"642\":1}}],[\"然后转到\",{\"1\":{\"705\":1}}],[\"然后添加此仓库\",{\"1\":{\"687\":1}}],[\"然后是根据用户名查询用户的mapper接口\",{\"1\":{\"670\":1}}],[\"然后由springsecurity将我们返回的对象与用户登录的信息进行核验\",{\"1\":{\"668\":1}}],[\"然后给你弄到原来的网站\",{\"1\":{\"642\":1}}],[\"然后攻击者可以利用该会话id获取用户的权限\",{\"1\":{\"642\":1}}],[\"然后其交给对应的doget\",{\"1\":{\"626\":1}}],[\"然后编写配置\",{\"1\":{\"616\":1}}],[\"然后编写一个我们自己的classloader\",{\"1\":{\"356\":1}}],[\"然后它会将其进行整合渲染得到最终有数据的页面\",{\"1\":{\"541\":1}}],[\"然后再给到sqlsessionfactorybean实例\",{\"1\":{\"1259\":1}}],[\"然后再使用factory\",{\"1\":{\"1159\":1}}],[\"然后再基于这个bean作为新的bean的factory\",{\"1\":{\"1159\":1}}],[\"然后再作为用户\",{\"1\":{\"642\":1}}],[\"然后再交给handleradapter\",{\"1\":{\"558\":1}}],[\"然后再告知业务层进行处理\",{\"1\":{\"540\":1}}],[\"然后再添加数据\",{\"1\":{\"475\":1}}],[\"然后基于此\",{\"1\":{\"534\":1}}],[\"然后根据属性调用对应的方法进行修改\",{\"1\":{\"524\":1}}],[\"然后使用工具类注册annotationawareaspectjautoproxycreator到容器中\",{\"1\":{\"1310\":1}}],[\"然后使用springtest模块提供的\",{\"1\":{\"1291\":1}}],[\"然后使用方法的形式来表示\",{\"1\":{\"842\":1}}],[\"然后使用注解\",{\"1\":{\"534\":1}}],[\"然后使用的时候\",{\"1\":{\"524\":1}}],[\"然后使用相应接口的抽象方参数列表的第一个作为目标对象\",{\"1\":{\"451\":1}}],[\"然后用\",{\"1\":{\"523\":1}}],[\"然后类型转换\",{\"1\":{\"499\":1}}],[\"然后前后截取\",{\"1\":{\"490\":1}}],[\"然后定义c并得到a+b的结果\",{\"1\":{\"473\":1}}],[\"然后我们需要配置web应用程序服务器\",{\"1\":{\"1048\":1}}],[\"然后我们可以通过使用\",{\"1\":{\"903\":1}}],[\"然后我们要安装一下lombok插件\",{\"1\":{\"811\":1}}],[\"然后我们来到service这边进行一下完善\",{\"1\":{\"672\":1}}],[\"然后我们在方法上添加一个\",{\"1\":{\"615\":1}}],[\"然后我们只需要在类中编写方法用于处理对应地址的请求即可\",{\"1\":{\"561\":1}}],[\"然后我们导入了lombok框架的依赖\",{\"1\":{\"468\":1}}],[\"然后我们通过cmd去登陆mysql\",{\"1\":{\"773\":1}}],[\"然后我们通过\",{\"1\":{\"142\":1}}],[\"然后声明我们提供了实现类\",{\"1\":{\"467\":1}}],[\"然后在type属性中指定其类名\",{\"1\":{\"1272\":1}}],[\"然后在argnames中指明\",{\"1\":{\"1235\":1}}],[\"然后在调用之后对返回值结果也进行处理\",{\"1\":{\"1224\":1}}],[\"然后在\",{\"1\":{\"1199\":1}}],[\"然后在某个时刻发布这个事件到所有的监听器\",{\"1\":{\"1192\":1}}],[\"然后在javac进行编译的时候\",{\"1\":{\"811\":1}}],[\"然后在此上面进行一些自己的处理\",{\"1\":{\"534\":1}}],[\"然后在项目b使用\",{\"1\":{\"464\":1}}],[\"然后在更新了一定次数之后\",{\"1\":{\"142\":1}}],[\"然后创建子类对象\",{\"1\":{\"412\":1}}],[\"然后\",{\"1\":{\"313\":1,\"1093\":1,\"1119\":1}}],[\"然后继续做我们的事情\",{\"1\":{\"301\":1}}],[\"然后生成了一个\",{\"1\":{\"154\":1}}],[\"然后进行了一个代理\",{\"1\":{\"1245\":1}}],[\"然后进行处理\",{\"1\":{\"1223\":1}}],[\"然后进行迭代\",{\"1\":{\"79\":1}}],[\"然后进行不断迭代\",{\"1\":{\"47\":1}}],[\"感兴趣的可以继续深入\",{\"1\":{\"1310\":1}}],[\"感兴趣可以前往观看\",{\"1\":{\"1245\":1}}],[\"感觉没学到maven\",{\"1\":{\"958\":1}}],[\"告诉数据源数据库的连接信息\",{\"1\":{\"1242\":1}}],[\"告诉用户\",{\"1\":{\"1096\":1}}],[\"造成整个系统性能的低下\",{\"1\":{\"1242\":1}}],[\"频繁的打开\",{\"1\":{\"1242\":1}}],[\"织入\",{\"1\":{\"1226\":1}}],[\"切面是通知和切点的结合\",{\"1\":{\"1226\":1}}],[\"切面\",{\"1\":{\"1226\":1}}],[\"切点\",{\"1\":{\"1226\":1}}],[\"切入之后需要执行什么动作\",{\"1\":{\"1217\":1}}],[\"框架中的增强处理\",{\"1\":{\"1226\":1}}],[\"领域中的特性术语\",{\"1\":{\"1226\":1}}],[\"术语\",{\"0\":{\"1226\":1}}],[\"听话\",{\"1\":{\"1224\":1}}],[\"环绕也可以直接通过注解声明\",{\"1\":{\"1237\":1}}],[\"环绕\",{\"0\":{\"1237\":1}}],[\"环绕方法的图标是全包的\",{\"1\":{\"1224\":1}}],[\"环绕方法相当于完全代理了此方法\",{\"1\":{\"1224\":1}}],[\"环绕方法\",{\"0\":{\"1224\":1}}],[\"环境配置\",{\"0\":{\"648\":1}}],[\"环境配置完成后\",{\"1\":{\"473\":1}}],[\"快去卷\",{\"1\":{\"1223\":1}}],[\"快速排查导致程序运行缓慢的问题\",{\"1\":{\"956\":1}}],[\"快速配置springmvc注解\",{\"1\":{\"553\":1}}],[\"快速地进行空格去除操作\",{\"1\":{\"488\":1}}],[\"快速生成一组0~19的int数据\",{\"1\":{\"478\":1}}],[\"快速取最小值\",{\"1\":{\"431\":1}}],[\"快速取最大值\",{\"1\":{\"431\":1}}],[\"快速获取文件夹下的文件名称列表\",{\"1\":{\"255\":1}}],[\"快速获取最大值\",{\"1\":{\"228\":1}}],[\"快速填充\",{\"0\":{\"235\":1}}],[\"修饰符\",{\"1\":{\"1219\":2}}],[\"修改了一些扫描规则\",{\"1\":{\"1327\":1}}],[\"修改国内镜像源\",{\"0\":{\"1010\":1}}],[\"修改默认情况下的打印等级\",{\"0\":{\"928\":1}}],[\"修改输出格式\",{\"0\":{\"921\":1}}],[\"修改日志的默认打印级别\",{\"0\":{\"912\":1}}],[\"修改对应\",{\"0\":{\"945\":1}}],[\"修改对应接口+注解\",{\"0\":{\"895\":1}}],[\"修改对象的属性\",{\"1\":{\"161\":1}}],[\"修改\",{\"0\":{\"863\":1}}],[\"修改语法树\",{\"1\":{\"811\":1}}],[\"修改数据\",{\"0\":{\"755\":1}}],[\"修改表\",{\"0\":{\"751\":1}}],[\"修改一下对应的实体类\",{\"1\":{\"692\":1}}],[\"修改一个对象的属性并不会影响到其他对象\",{\"1\":{\"161\":1}}],[\"修改密码\",{\"1\":{\"666\":1}}],[\"修改用户密码\",{\"1\":{\"665\":1}}],[\"修改用户\",{\"1\":{\"589\":1}}],[\"修改用户信息\",{\"1\":{\"589\":1}}],[\"修改操作被阻止了\",{\"1\":{\"462\":1}}],[\"修改类的属性\",{\"0\":{\"350\":1}}],[\"修改访问权限\",{\"1\":{\"348\":1}}],[\"修改变量\",{\"1\":{\"348\":1}}],[\"修改键值对的值\",{\"1\":{\"213\":1}}],[\"修改相关操作\",{\"1\":{\"213\":1}}],[\"修改为\",{\"1\":{\"142\":1}}],[\"限制与具有给定注释的类型中的连接点匹配\",{\"1\":{\"1219\":1}}],[\"限制与连接点匹配\",{\"1\":{\"1219\":2}}],[\"限制匹配到连接点\",{\"1\":{\"1219\":1}}],[\"限制匹配到某些类型的连接点\",{\"1\":{\"1219\":1}}],[\"限制匹配连接点\",{\"1\":{\"1219\":2}}],[\"限定符表如下\",{\"1\":{\"403\":1}}],[\"准备当前应用程序上下文\",{\"1\":{\"1320\":1}}],[\"准备\",{\"0\":{\"1217\":1}}],[\"思想实际上就是\",{\"1\":{\"1215\":1}}],[\"思考\",{\"1\":{\"355\":1}}],[\"投影集合\",{\"0\":{\"1210\":1}}],[\"北京市朝阳区\",{\"1\":{\"1208\":1}}],[\"囊括\",{\"1\":{\"1205\":1}}],[\"刻师傅\",{\"1\":{\"1204\":1}}],[\"监听实际上就是等待某个事件的触发\",{\"1\":{\"1191\":1}}],[\"监听器可是很关键的\",{\"1\":{\"1191\":1}}],[\"监听器\",{\"0\":{\"1191\":1}}],[\"监听器并不是我们学习的重点内容\",{\"1\":{\"1105\":1}}],[\"异步执行的任务并不是在当前线程启动的\",{\"1\":{\"1188\":1}}],[\"异步执行\",{\"1\":{\"1188\":1}}],[\"异步任务执行\",{\"0\":{\"1188\":1}}],[\"异常判断\",{\"0\":{\"973\":1}}],[\"异常转换处理\",{\"1\":{\"714\":1}}],[\"异常错误信息\",{\"1\":{\"424\":1}}],[\"异常处理\",{\"0\":{\"602\":1},\"1\":{\"424\":1}}],[\"异常的抛出\",{\"1\":{\"1226\":1}}],[\"异常的抛出同样需要创建一个异常对象出来\",{\"1\":{\"423\":1}}],[\"异常的处理\",{\"0\":{\"424\":1}}],[\"异常对象携带了我们抛出异常时的一些信息\",{\"1\":{\"423\":1}}],[\"异常其实就两大类\",{\"1\":{\"422\":1}}],[\"异常就是不同寻常\",{\"1\":{\"421\":1}}],[\"异常类型\",{\"0\":{\"421\":1}}],[\"异常机制\",{\"0\":{\"420\":1}}],[\"异常\",{\"0\":{\"418\":1},\"1\":{\"182\":1}}],[\"任务调度\",{\"0\":{\"1187\":1}}],[\"任何事务的操作都在这里进行\",{\"1\":{\"1268\":1}}],[\"任何操作执行之前都会检查连接是否可用\",{\"1\":{\"1247\":1}}],[\"任何路径只能有一个方法进行处理\",{\"1\":{\"569\":1}}],[\"任何页面的返回和数据填充也全靠表示层来完成\",{\"1\":{\"540\":1}}],[\"任何类都可以继承\",{\"1\":{\"504\":1}}],[\"任何类不能再继承当前类\",{\"1\":{\"504\":1}}],[\"任何方法都可以通过方法引用作为实现\",{\"1\":{\"415\":1}}],[\"任何一种\",{\"1\":{\"155\":1}}],[\"早期引用\",{\"1\":{\"1181\":1}}],[\"场景下没法这么干\",{\"1\":{\"1181\":1}}],[\"半成品\",{\"1\":{\"1181\":1}}],[\"暂存早期引用\",{\"1\":{\"1181\":1}}],[\"暂时不提\",{\"1\":{\"1242\":1}}],[\"暂时不需要了解\",{\"1\":{\"264\":1}}],[\"暂时不做讲解\",{\"1\":{\"193\":1}}],[\"三级缓存机制\",{\"1\":{\"1181\":1}}],[\"三级缓存\",{\"1\":{\"1181\":1}}],[\"三引号\",{\"0\":{\"498\":1}}],[\"避免循环依赖\",{\"1\":{\"1181\":1}}],[\"避免了几乎所有的\",{\"1\":{\"816\":1}}],[\"问了gpt回答\",{\"1\":{\"1181\":1}}],[\"问题\",{\"0\":{\"929\":1},\"1\":{\"103\":1,\"104\":1,\"110\":1}}],[\"问题转化\",{\"0\":{\"103\":1}}],[\"问题引入\",{\"0\":{\"96\":1,\"101\":1}}],[\"问题进行研究\",{\"1\":{\"92\":1}}],[\"月\",{\"1\":{\"1181\":1}}],[\"留一个问题\",{\"1\":{\"1181\":1}}],[\"讨论\",{\"0\":{\"1181\":1}}],[\"似乎有点复杂\",{\"1\":{\"1165\":1}}],[\"符号\",{\"1\":{\"1159\":1}}],[\"符合函数式接口定义\",{\"1\":{\"447\":1}}],[\"千万不要认为是我们注册了studentfactory这个bean\",{\"1\":{\"1158\":1}}],[\"欢迎光临电子厂\",{\"1\":{\"1157\":1,\"1159\":1}}],[\"销毁单例bean实例对象等功能\",{\"1\":{\"1298\":1}}],[\"销毁\",{\"0\":{\"1147\":1}}],[\"销毁前调用\",{\"1\":{\"1055\":1}}],[\"候选名单\",{\"0\":{\"1140\":1}}],[\"英语\",{\"1\":{\"1136\":1}}],[\"英文简称web\",{\"1\":{\"1042\":1}}],[\"卢本伟\",{\"1\":{\"1133\":1}}],[\"懒加载\",{\"0\":{\"1130\":1}}],[\"始终都是同一个\",{\"1\":{\"1129\":1}}],[\"始终都是依次进行的\",{\"1\":{\"295\":1}}],[\"组装和管理的对象\",{\"1\":{\"1117\":1}}],[\"组合\",{\"0\":{\"521\":1},\"1\":{\"349\":1}}],[\"低耦合\",{\"1\":{\"1117\":1}}],[\"瞎编的一个容器类\",{\"1\":{\"1117\":1}}],[\"瞎移除都不带报错的\",{\"1\":{\"350\":1}}],[\"业务层\",{\"1\":{\"1116\":1}}],[\"绕开了\",{\"1\":{\"1109\":1}}],[\"岂不是就出问题了\",{\"1\":{\"1109\":1}}],[\"破坏了jdk的双亲委派机制\",{\"1\":{\"1109\":1}}],[\"亦或是在request对象创建的时候进行一些操作\",{\"1\":{\"1105\":1}}],[\"旁边已经出现图标了\",{\"1\":{\"1172\":1}}],[\"旁边有一个按钮\",{\"1\":{\"1076\":1}}],[\"旁边出现运行按钮\",{\"1\":{\"959\":1}}],[\"您的表单数据不完整\",{\"1\":{\"1072\":1}}],[\"您的氪金力度不足\",{\"1\":{\"605\":1}}],[\"驱动名就是对应的\",{\"1\":{\"1071\":1}}],[\"驱动类\",{\"1\":{\"824\":1,\"1071\":1,\"1242\":1}}],[\"呢\",{\"1\":{\"1062\":1}}],[\"替换默认路径\",{\"0\":{\"1062\":1}}],[\"替代tomcat为我们提供的默认的静态资源servlet\",{\"1\":{\"558\":1}}],[\"响应头为我们设定了20秒的过期时间\",{\"1\":{\"1092\":1}}],[\"响应头部分\",{\"1\":{\"1058\":1}}],[\"响应的状态码会被设置为302\",{\"1\":{\"1082\":1}}],[\"响应中断\",{\"1\":{\"301\":1}}],[\"展示给我们的是一个图形化界面\",{\"1\":{\"1047\":1}}],[\"汤姆猫\",{\"1\":{\"1047\":1}}],[\"双方随时可以互相发送数据\",{\"1\":{\"1042\":1}}],[\"双端队列既可以当做普通队列使用\",{\"1\":{\"201\":1}}],[\"双端队列\",{\"0\":{\"201\":1}}],[\"点击按钮就可以刷新当前时间\",{\"1\":{\"1076\":1}}],[\"点击下一步即可\",{\"1\":{\"1048\":1}}],[\"点击查看源网页\",{\"1\":{\"1042\":3,\"1058\":1}}],[\"点击提交之后\",{\"1\":{\"619\":1}}],[\"声音和图像\",{\"1\":{\"1042\":1}}],[\"声明式事务是基于aop实现的\",{\"1\":{\"1274\":1}}],[\"声明一个私有方法\",{\"1\":{\"474\":1}}],[\"声明此模块提供了test的实现类\",{\"1\":{\"467\":1}}],[\"超时统计信息\",{\"1\":{\"1246\":1}}],[\"超文本\",{\"1\":{\"1042\":1}}],[\"超过一个时间\",{\"1\":{\"721\":1}}],[\"端口是当前服务器上web应用程序开启的端口\",{\"1\":{\"1042\":1}}],[\"端进行查询\",{\"0\":{\"672\":1}}],[\"协议是指采用什么协议来访问服务器\",{\"1\":{\"1042\":1}}],[\"客户程序向服务器程序发出请求\",{\"1\":{\"1042\":1}}],[\"客户端会请求对应的容器中的某些资源或者实例\",{\"1\":{\"1058\":1}}],[\"客户端\",{\"1\":{\"719\":1}}],[\"客户端已连接\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"万维网客户就把http请求报文作为建立tcp连接的三报文握手中的第三个报文的数据\",{\"1\":{\"1042\":1}}],[\"万维网文档所驻留的主机则运行服务器程序\",{\"1\":{\"1042\":1}}],[\"万维网以客户服务器的方式工作\",{\"1\":{\"1042\":1}}],[\"万维网用链接的方法\",{\"1\":{\"1042\":1}}],[\"万维网是一个大规模的联机式信息储藏所\",{\"1\":{\"1042\":1}}],[\"万维网\",{\"1\":{\"1042\":1}}],[\"万一给进来的str是null呢\",{\"1\":{\"454\":1}}],[\"谢希仁\",{\"1\":{\"1042\":1}}],[\"命名绑定模式就是根据下面的方法参数列表进行匹配\",{\"1\":{\"1235\":1}}],[\"命名绑定模式\",{\"0\":{\"1235\":1}}],[\"命名\",{\"0\":{\"1178\":1}}],[\"命名规则依然是驼峰命名法\",{\"1\":{\"1133\":1}}],[\"命名规则一般和包名一致\",{\"1\":{\"1003\":1}}],[\"命名为test\",{\"1\":{\"1119\":1}}],[\"命令\",{\"0\":{\"1035\":1,\"1036\":1}}],[\"排除依赖中的不必要依赖\",{\"0\":{\"1026\":1}}],[\"排序查询\",{\"0\":{\"764\":1}}],[\"排序sorted\",{\"1\":{\"515\":1}}],[\"排序\",{\"1\":{\"228\":1}}],[\"顺便解决循环依赖问题\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"顺便带大家回顾一下junit5的使用\",{\"1\":{\"1017\":1}}],[\"顺序\",{\"1\":{\"929\":1}}],[\"顺序执行\",{\"1\":{\"511\":1}}],[\"顺序就同我们的插入顺序一致\",{\"1\":{\"218\":1}}],[\"着重讲解\",{\"1\":{\"1015\":1}}],[\"国外\",{\"1\":{\"1010\":1}}],[\"镜像配置方式同第1步\",{\"1\":{\"1010\":1}}],[\"镜像仓库与中心仓库自动同步所有依赖\",{\"1\":{\"1010\":1}}],[\"远程仓库中下载之后\",{\"1\":{\"1009\":1}}],[\"插件\",{\"1\":{\"1002\":1}}],[\"插入的其中任意一种操作\",{\"1\":{\"865\":1}}],[\"插入\",{\"0\":{\"861\":1}}],[\"插入数据\",{\"0\":{\"754\":1}}],[\"插入新的元素到当前待遍历元素之前\",{\"1\":{\"194\":1}}],[\"插入元素默认是插入到尾部\",{\"1\":{\"181\":1}}],[\"部署等操作\",{\"1\":{\"1000\":1}}],[\"软件基金会主持的独立\",{\"1\":{\"1000\":1}}],[\"软引用\",{\"1\":{\"884\":1}}],[\"曾是\",{\"1\":{\"1000\":1}}],[\"报错如下\",{\"1\":{\"1283\":1}}],[\"报错消失\",{\"1\":{\"1140\":1}}],[\"报告和文档等步骤\",{\"1\":{\"1000\":1}}],[\"报了黄标\",{\"1\":{\"659\":1}}],[\"缩写\",{\"1\":{\"1000\":1}}],[\"翻译为\",{\"1\":{\"1000\":1,\"1115\":1}}],[\"翻译过来就是\",{\"1\":{\"330\":1}}],[\"某些javax包下的包\",{\"1\":{\"1175\":1}}],[\"某些测试可能并不是固定单个输入参数\",{\"1\":{\"991\":1}}],[\"某些集合不支持这种操作\",{\"1\":{\"189\":1}}],[\"伪随机排序测试方法\",{\"1\":{\"987\":1}}],[\"伪代码\",{\"0\":{\"32\":1,\"64\":1,\"67\":1,\"124\":1,\"144\":1},\"1\":{\"116\":1}}],[\"防止数据损坏\",{\"1\":{\"1266\":1}}],[\"防止自己下来看不懂文章\",{\"1\":{\"1226\":1}}],[\"防止准备不足导致的测试失败\",{\"1\":{\"985\":1}}],[\"防止伪造身份攻击\",{\"1\":{\"635\":1}}],[\"真假判断\",{\"0\":{\"970\":1}}],[\"真正注册的是工厂方法提供的东西\",{\"1\":{\"1158\":1}}],[\"真正的过滤在这里执行\",{\"1\":{\"708\":1}}],[\"真正是让\",{\"1\":{\"707\":1}}],[\"真正有用的那一部分代码\",{\"1\":{\"446\":1}}],[\"断言工具\",{\"0\":{\"968\":1}}],[\"断言\",{\"0\":{\"963\":1}}],[\"断言表达式\",{\"0\":{\"425\":1}}],[\"预设的名称生成器\",{\"0\":{\"962\":1}}],[\"预设注解\",{\"0\":{\"361\":1}}],[\"跳过某个测试\",{\"0\":{\"960\":1}}],[\"跳过了一个字节\",{\"1\":{\"248\":1}}],[\"安全导航运算符返回null而不是抛出异常\",{\"1\":{\"1211\":1}}],[\"安全导航运算符用于避免nullpointerexception\",{\"1\":{\"1211\":1}}],[\"安全导航运算符\",{\"0\":{\"1211\":1}}],[\"安全协议有https\",{\"1\":{\"1092\":1}}],[\"安全协议\",{\"1\":{\"1092\":1}}],[\"安全性越来越受到重视\",{\"1\":{\"641\":1}}],[\"安装\",{\"0\":{\"1047\":1},\"1\":{\"1000\":1}}],[\"安装好之后\",{\"1\":{\"958\":1}}],[\"牵一发而动全身\",{\"1\":{\"956\":1}}],[\"难道tomcat的开发团队没有考虑到这个问题吗\",{\"1\":{\"1109\":1}}],[\"难道取1000还可能吐2000出来吗\",{\"1\":{\"311\":1}}],[\"难免会涉及到一些原有代码的修改\",{\"1\":{\"956\":1}}],[\"消息内容\",{\"1\":{\"948\":1}}],[\"消费者可以从货架上拿走商品\",{\"1\":{\"331\":1}}],[\"消费者也在不断的消费\",{\"1\":{\"331\":1}}],[\"日期\",{\"1\":{\"948\":1}}],[\"日志\",{\"0\":{\"951\":1}}],[\"日志注解\",{\"0\":{\"950\":1}}],[\"日志默认配置\",{\"0\":{\"935\":1}}],[\"日志的名称会按照包的分级\",{\"1\":{\"930\":1}}],[\"日志的打印并不是简单的输出\",{\"1\":{\"909\":1}}],[\"日志中出现了两次\",{\"1\":{\"929\":1}}],[\"日志继承关系\",{\"0\":{\"926\":1}}],[\"日志内容\",{\"1\":{\"921\":1}}],[\"日志级别\",{\"1\":{\"921\":1,\"944\":1}}],[\"日志打印的核心部分\",{\"1\":{\"918\":1}}],[\"日志核心内容\",{\"0\":{\"917\":1}}],[\"日志一般分为7个级别\",{\"1\":{\"910\":1}}],[\"日志将时刻伴随我们左右\",{\"1\":{\"908\":1}}],[\"格式类似于我们java中的map键值对\",{\"1\":{\"936\":1}}],[\"格式\",{\"0\":{\"936\":1}}],[\"格式为\",{\"1\":{\"921\":1}}],[\"格式数据\",{\"0\":{\"611\":1}}],[\"填写对应的参数即可\",{\"1\":{\"1219\":1}}],[\"填写jdk的安装目录+\",{\"1\":{\"1047\":1}}],[\"填写的日志打印级别是什么\",{\"1\":{\"912\":1}}],[\"填充\",{\"1\":{\"609\":1}}],[\"级别\",{\"0\":{\"1281\":1,\"1282\":1,\"1283\":1},\"1\":{\"948\":1}}],[\"级别低于普通信息\",{\"1\":{\"911\":1}}],[\"级别划分\",{\"0\":{\"910\":1}}],[\"祝你明天就遇到我\",{\"1\":{\"911\":1}}],[\"严重的错误\",{\"1\":{\"911\":1}}],[\"严格等于\",{\"1\":{\"155\":1}}],[\"十一月\",{\"1\":{\"908\":1}}],[\"十六进制哈希值\",{\"1\":{\"372\":1}}],[\"彻底抛弃xml配置\",{\"1\":{\"904\":1}}],[\"彻底封死\",{\"1\":{\"504\":1}}],[\"咱们把配置文件也给变成代码配置\",{\"1\":{\"904\":1}}],[\"假如现在我们的实体类字段名称与数据库不同\",{\"1\":{\"898\":1}}],[\"假设工具\",{\"0\":{\"974\":1}}],[\"假设仓库管理关系表为storehousemanage\",{\"1\":{\"739\":1}}],[\"假设厨师炒出一个菜的时间为3秒\",{\"1\":{\"331\":1}}],[\"假设有\",{\"1\":{\"142\":1}}],[\"假设我们这里有一个业务需要连续插入两条学生信息\",{\"1\":{\"1277\":1}}],[\"假设我们要根据用户的id进行数据的删除\",{\"1\":{\"864\":1}}],[\"假设我们每个用户都有一个自己的详细信息表\",{\"1\":{\"849\":1}}],[\"假设我们现在需要编写一个根据id查询用户的操作\",{\"1\":{\"831\":1}}],[\"假设我们后端有一个需要实时刷新的数据\",{\"1\":{\"617\":1}}],[\"假设我们具有\",{\"1\":{\"116\":1}}],[\"假设我们可以得到有关随机变量\",{\"1\":{\"110\":1}}],[\"假设我们需要求解如下方程\",{\"1\":{\"96\":1}}],[\"假设我们有了一系列\",{\"1\":{\"78\":1}}],[\"假设\",{\"1\":{\"94\":1,\"154\":1,\"974\":1}}],[\"假设功率q=qn​\",{\"1\":{\"11\":1}}],[\"女\",{\"1\":{\"897\":1}}],[\"速度上会慢一些\",{\"1\":{\"884\":1}}],[\"弱引用\",{\"1\":{\"884\":1}}],[\"极大的简化了我们之前jdbc那样的代码编写模式\",{\"1\":{\"893\":1}}],[\"极大地提升了sql语句编写的的灵活性\",{\"1\":{\"872\":1}}],[\"极大简化了之前的流程\",{\"1\":{\"825\":1}}],[\"批处理\",{\"0\":{\"871\":1}}],[\"批量插入\",{\"0\":{\"877\":1}}],[\"批量删除\",{\"0\":{\"876\":1}}],[\"批量获取\",{\"1\":{\"490\":1}}],[\"批量操作\",{\"1\":{\"213\":1}}],[\"像极了爱情\",{\"1\":{\"1101\":1}}],[\"像这样将工厂类注册为bean\",{\"1\":{\"1159\":1}}],[\"像这样\",{\"1\":{\"986\":1}}],[\"像这种需要引入其他bean进行的注入\",{\"1\":{\"1172\":1}}],[\"像这种一对一查询该怎么实现呢\",{\"1\":{\"849\":1}}],[\"像这种只有一个方法需要实现的接口\",{\"1\":{\"171\":1}}],[\"像\",{\"1\":{\"862\":1}}],[\"删\",{\"1\":{\"860\":1}}],[\"删除配置文件\",{\"1\":{\"1259\":1}}],[\"删除操作则更为简单\",{\"1\":{\"864\":1}}],[\"删除\",{\"0\":{\"864\":1},\"1\":{\"796\":1}}],[\"删除数据\",{\"0\":{\"756\":1}}],[\"删除表\",{\"0\":{\"752\":1}}],[\"删除图书\",{\"1\":{\"691\":1}}],[\"删除用户\",{\"1\":{\"589\":1,\"665\":1}}],[\"删除用户信息\",{\"1\":{\"589\":1}}],[\"删除2到4这个范围内的字符\",{\"1\":{\"402\":1}}],[\"删除就完事\",{\"1\":{\"182\":1}}],[\"删除的是另一个对象\",{\"1\":{\"182\":1}}],[\"删除的是下标为10的元素\",{\"1\":{\"182\":1}}],[\"删除所有元素\",{\"1\":{\"180\":1}}],[\"们可以在查询user表的时候\",{\"1\":{\"851\":1}}],[\"名称便不可更改\",{\"1\":{\"1092\":1}}],[\"名称等信息\",{\"1\":{\"978\":1}}],[\"名称分级\",{\"0\":{\"930\":1}}],[\"名称随意\",{\"1\":{\"908\":1}}],[\"名称随便\",{\"1\":{\"831\":1}}],[\"名称最好和数据库字段名称保持一致\",{\"1\":{\"826\":1}}],[\"名字一般为xxx\",{\"1\":{\"918\":1}}],[\"名字挺高大上的\",{\"1\":{\"589\":1}}],[\"名字\",{\"1\":{\"161\":1}}],[\"含包名\",{\"1\":{\"824\":1,\"1071\":1,\"1242\":1}}],[\"含噪声\",{\"1\":{\"104\":1}}],[\"含噪音\",{\"1\":{\"97\":1}}],[\"初次使用\",{\"0\":{\"824\":1}}],[\"初始化类路径mapper扫描器\",{\"1\":{\"1327\":1}}],[\"初始化配置bean工厂\",{\"1\":{\"1320\":1}}],[\"初始化bean\",{\"1\":{\"1309\":3,\"1311\":3}}],[\"初始化完成的\",{\"1\":{\"1301\":1}}],[\"初始化和销毁注解\",{\"0\":{\"1176\":1}}],[\"初始化和销毁的时机\",{\"0\":{\"1148\":1}}],[\"初始化方法和摧毁方法\",{\"1\":{\"1170\":1}}],[\"初始化参数类似于初始化配置需要的一些值\",{\"1\":{\"1085\":1}}],[\"初始化参数\",{\"0\":{\"1085\":1}}],[\"初始化得到\",{\"1\":{\"1072\":1}}],[\"初始化后调用\",{\"1\":{\"1055\":1}}],[\"初始化\",{\"0\":{\"1147\":1},\"1\":{\"1055\":1}}],[\"初始化操作只会执行一次\",{\"1\":{\"986\":1}}],[\"初始化时\",{\"1\":{\"709\":1}}],[\"初始化器配置\",{\"0\":{\"650\":1}}],[\"初始化各种解析器\",{\"1\":{\"625\":1}}],[\"初始化webapplicationcontext\",{\"1\":{\"625\":1}}],[\"初始容量为16\",{\"1\":{\"216\":1}}],[\"节省性能开销\",{\"1\":{\"882\":1}}],[\"节点可以是一个带有内容的标签\",{\"1\":{\"819\":1}}],[\"节所述\",{\"1\":{\"79\":1}}],[\"区分大小写\",{\"1\":{\"817\":1}}],[\"区别于贝尔曼公式\",{\"1\":{\"56\":1}}],[\"合理地分配连接对象给我们\",{\"1\":{\"1242\":1}}],[\"合理地使用这些技术\",{\"1\":{\"816\":1}}],[\"合格\",{\"1\":{\"437\":1}}],[\"放在项目目录下直接导入就行了\",{\"1\":{\"811\":1}}],[\"放入闲置列表\",{\"1\":{\"1247\":1}}],[\"放入到这个文件夹中\",{\"1\":{\"1017\":1}}],[\"放入集合中\",{\"1\":{\"625\":1}}],[\"放入缓冲区再经过转换流输出到给定的输出流上\",{\"1\":{\"284\":1}}],[\"炸\",{\"1\":{\"810\":1}}],[\"爆\",{\"1\":{\"810\":1}}],[\"长\",{\"1\":{\"810\":1}}],[\"长度不固定\",{\"1\":{\"746\":1}}],[\"长度不超过\",{\"1\":{\"228\":1}}],[\"长度是在一开始创建数组的时候就确定好的\",{\"1\":{\"393\":1}}],[\"撤销前面全部操作\",{\"1\":{\"806\":2}}],[\"乍一看好像没啥问题\",{\"1\":{\"804\":1}}],[\"行为\",{\"1\":{\"962\":1}}],[\"行\",{\"1\":{\"796\":1}}],[\"行不行\",{\"1\":{\"402\":2}}],[\"`xxx`\",{\"1\":{\"1205\":1}}],[\"`group`\",{\"1\":{\"855\":1}}],[\"`groups`\",{\"1\":{\"855\":2}}],[\"`com\",{\"1\":{\"788\":2}}],[\"``\",{\"1\":{\"349\":1}}],[\"连接已经创建并且没开启自动提交才可以使用\",{\"1\":{\"1273\":1}}],[\"连接对象本体\",{\"1\":{\"1247\":1}}],[\"连接建立后\",{\"1\":{\"1242\":1}}],[\"连接点表示应用执行过程中能够插入切面的一个点\",{\"1\":{\"1226\":1}}],[\"连接点\",{\"1\":{\"1226\":1}}],[\"连接的url如果记不住格式\",{\"1\":{\"788\":1}}],[\"连接示例\",{\"0\":{\"719\":1}}],[\"释放资源\",{\"1\":{\"788\":1}}],[\"又会发生什么事情呢\",{\"1\":{\"1247\":1}}],[\"又比如beanclassloaderaware\",{\"1\":{\"1186\":1}}],[\"又比如每个同学都有一个学号与其唯一对应\",{\"1\":{\"733\":1}}],[\"又依次返回到最前面的filter\",{\"1\":{\"1103\":1}}],[\"又要挨个进行修改\",{\"1\":{\"810\":1}}],[\"又兼备存储的优势\",{\"1\":{\"787\":1}}],[\"回顾一下事务机制\",{\"1\":{\"1266\":1}}],[\"回滚只会影响到此子事务\",{\"1\":{\"1284\":1}}],[\"回滚到回滚点\",{\"1\":{\"806\":1}}],[\"回滚到指定回滚点\",{\"1\":{\"782\":1}}],[\"回滚之前的内容都没了\",{\"1\":{\"806\":2}}],[\"回滚\",{\"1\":{\"806\":1,\"1272\":2}}],[\"回滚点\",{\"1\":{\"782\":2}}],[\"回滚事务\",{\"1\":{\"782\":1}}],[\"回到mark时的位置\",{\"1\":{\"265\":1}}],[\"持久性\",{\"1\":{\"782\":1,\"1266\":1}}],[\"读已提交\",{\"1\":{\"1267\":1}}],[\"读未提交\",{\"1\":{\"1267\":1}}],[\"读提交\",{\"1\":{\"782\":1}}],[\"读取到了被回滚的数据\",{\"1\":{\"1271\":1}}],[\"读取实体类肯定需要一个映射规则\",{\"1\":{\"826\":1}}],[\"读取配置参数\",{\"1\":{\"625\":1}}],[\"读取后直接得到一个字符串\",{\"1\":{\"269\":1}}],[\"读取一个少一个\",{\"1\":{\"248\":1}}],[\"隔离机制就是规定不同事务来接触数据库时\",{\"1\":{\"1267\":1}}],[\"隔离机制\",{\"0\":{\"1267\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"782\":1}}],[\"隔离性\",{\"1\":{\"782\":1,\"1266\":1}}],[\"隔开即可\",{\"1\":{\"376\":1}}],[\"事务传播一共有七种级别\",{\"1\":{\"1280\":1}}],[\"事务传播规则\",{\"0\":{\"1280\":1},\"1\":{\"1279\":1}}],[\"事务超时时间\",{\"1\":{\"1279\":1}}],[\"事务会自动回滚\",{\"1\":{\"1277\":1}}],[\"事务需要执行必须有一个事务管理器\",{\"1\":{\"1276\":1}}],[\"事务管理器\",{\"0\":{\"1276\":1}}],[\"事务隔离级别\",{\"1\":{\"1273\":1,\"1279\":1}}],[\"事务隔离分为不同级别\",{\"1\":{\"782\":1}}],[\"事务只能读取其他事务已经提交的内容\",{\"1\":{\"1269\":1}}],[\"事务b已经回滚了\",{\"1\":{\"1268\":1}}],[\"事务a最后得到的实际上是一个毫无意义的数据\",{\"1\":{\"1268\":1}}],[\"事务之间实际上是存在一些隔离级别的\",{\"1\":{\"1267\":1}}],[\"事务之间是相互隔离互不干扰的\",{\"1\":{\"1267\":1}}],[\"事务就是要么完成\",{\"1\":{\"1266\":1}}],[\"事务的结果被写到持久化存储器中\",{\"1\":{\"1266\":1}}],[\"事务的原子性确保动作要么全部完成\",{\"1\":{\"1266\":1}}],[\"事务是一个原子操作\",{\"1\":{\"1266\":1}}],[\"事务机制回顾\",{\"0\":{\"1266\":1}}],[\"事务相关信息等\",{\"1\":{\"1244\":1}}],[\"事务相关操作非常简单\",{\"1\":{\"865\":1}}],[\"事务工厂\",{\"1\":{\"1242\":1}}],[\"事务操作\",{\"0\":{\"865\":1}}],[\"事务等\",{\"1\":{\"787\":1}}],[\"事务处理结束后\",{\"1\":{\"782\":1}}],[\"事务在执行过程中发生错误\",{\"1\":{\"782\":1}}],[\"事务具有以下特性\",{\"1\":{\"782\":1}}],[\"事务\",{\"0\":{\"782\":1}}],[\"触发器名称\",{\"1\":{\"781\":2}}],[\"触发器所依附的表称为基本表\",{\"1\":{\"781\":1}}],[\"触发器显得更加灵活\",{\"1\":{\"781\":1}}],[\"触发器通常用于检查内容的安全性\",{\"1\":{\"781\":1}}],[\"触发器就像其名字一样\",{\"1\":{\"781\":1}}],[\"触发器\",{\"0\":{\"781\":1}}],[\"能做到这样的操作\",{\"1\":{\"1189\":1}}],[\"能先创建一个\",{\"1\":{\"1181\":1}}],[\"能不能像之前一样\",{\"1\":{\"1177\":1}}],[\"能用就完事了\",{\"1\":{\"1117\":1}}],[\"能够实现更加强大的功能\",{\"1\":{\"1200\":1}}],[\"能够起到事半功倍的效果\",{\"1\":{\"1181\":1}}],[\"能够直接访问webapp目录下的静态页面\",{\"1\":{\"1054\":1}}],[\"能够非常方便地从互联网上的一个站点访问另一个站点\",{\"1\":{\"1042\":1}}],[\"能够大大提高我们的查询效率\",{\"1\":{\"780\":1}}],[\"能否一次性地过滤掉没有登录验证的用户呢\",{\"1\":{\"1101\":1}}],[\"能否简化一下这个流程呢\",{\"1\":{\"949\":1}}],[\"能否实现无需xml映射器配置\",{\"1\":{\"893\":1}}],[\"能匹配\",{\"1\":{\"403\":2}}],[\"索引为我们带来高速查询效率的同时\",{\"1\":{\"780\":1}}],[\"索引方法\",{\"1\":{\"780\":1}}],[\"索引类型包括\",{\"1\":{\"780\":1}}],[\"索引名称\",{\"1\":{\"780\":2}}],[\"索引\",{\"0\":{\"780\":1}}],[\"子工厂不仅能获取到自己的\",{\"1\":{\"1298\":1}}],[\"子项目只需要使用即可\",{\"1\":{\"1033\":1}}],[\"子项目需要什么再拿什么即可\",{\"1\":{\"1033\":1}}],[\"子项目的依赖失效了\",{\"1\":{\"1033\":1}}],[\"子项目可以选取需要的作为依赖\",{\"1\":{\"1033\":1}}],[\"子项目也成功继承了lombok依赖\",{\"1\":{\"1032\":1}}],[\"子项目会继承父项目的所有依赖\",{\"1\":{\"1032\":1}}],[\"子项目直接继承父项目的groupid\",{\"1\":{\"1032\":1}}],[\"子logger会继承父logger提供的所有handler进行日志处理\",{\"1\":{\"927\":1}}],[\"子查询语句\",{\"1\":{\"779\":1}}],[\"子类也可以定义\",{\"1\":{\"375\":1}}],[\"子类对应必须是\",{\"1\":{\"375\":1}}],[\"子类必须要实现抽象类所有的抽象方法\",{\"1\":{\"375\":1}}],[\"子类\",{\"1\":{\"375\":1,\"504\":2}}],[\"子类是\",{\"1\":{\"371\":1}}],[\"子类实现了父类所有非私有化的属性和方法\",{\"1\":{\"369\":1}}],[\"子类我们会在下一章介绍\",{\"1\":{\"278\":1}}],[\"子类初始化时\",{\"1\":{\"275\":1}}],[\"代理的链接对象\",{\"1\":{\"1247\":1}}],[\"代理对象\",{\"0\":{\"1247\":1}}],[\"代表所有参数\",{\"1\":{\"1219\":1}}],[\"代表com包下的全部包\",{\"1\":{\"1219\":1}}],[\"代表全部方法\",{\"1\":{\"1219\":1}}],[\"代表全部\",{\"1\":{\"1219\":1}}],[\"代表任意修饰符\",{\"1\":{\"1219\":1}}],[\"代表项目版本\",{\"1\":{\"1003\":1}}],[\"代表为所有的数据库和表都授权\",{\"1\":{\"774\":1}}],[\"代码非常轻量\",{\"1\":{\"1260\":1}}],[\"代码也能变得更简洁\",{\"1\":{\"1181\":1}}],[\"代码进行动态拼接的结果\",{\"1\":{\"1053\":1}}],[\"代码和手动设置参数以及获取结果集\",{\"1\":{\"816\":1}}],[\"代码的健壮性有所欠缺\",{\"1\":{\"437\":1}}],[\"代码语句\",{\"1\":{\"414\":1,\"446\":1,\"447\":1}}],[\"代码块\",{\"1\":{\"312\":1}}],[\"代码块中的内容会在对象创建时仅执行一次\",{\"1\":{\"166\":1}}],[\"代码块同样会在对象构造之前进行\",{\"1\":{\"166\":1}}],[\"权限2\",{\"1\":{\"774\":2}}],[\"权限问题\",{\"0\":{\"660\":1}}],[\"庞大的数据库不可能由一个人来管理\",{\"1\":{\"771\":1}}],[\"嵌套类的执行同样可以通过\",{\"1\":{\"988\":1}}],[\"嵌套测试\",{\"0\":{\"988\":1}}],[\"嵌套\",{\"0\":{\"851\":1},\"1\":{\"849\":1}}],[\"嵌套结果映射\",{\"0\":{\"850\":1},\"1\":{\"849\":1}}],[\"嵌套查询来解决\",{\"1\":{\"854\":1}}],[\"嵌套查询\",{\"0\":{\"770\":1,\"854\":1}}],[\"嵌套关系可以表示为\",{\"1\":{\"610\":1}}],[\"起始位置\",{\"1\":{\"766\":1}}],[\"约束条件\",{\"1\":{\"766\":1}}],[\"约束要求该列的每一行必须有一个非空值\",{\"1\":{\"747\":1}}],[\"聚集函数一般用作统计\",{\"1\":{\"765\":1}}],[\"聚集函数\",{\"0\":{\"765\":1}}],[\"聚合max\",{\"1\":{\"515\":1}}],[\"聚合等\",{\"1\":{\"228\":1}}],[\"警告的内容\",{\"1\":{\"911\":1}}],[\"警告\",{\"1\":{\"755\":1,\"1181\":1}}],[\"条件获取\",{\"0\":{\"1209\":1}}],[\"条件方法需要static\",{\"1\":{\"980\":1}}],[\"条件方法可以位于测试类之外\",{\"1\":{\"980\":1}}],[\"条件测试和执行\",{\"0\":{\"975\":1}}],[\"条件判断\",{\"0\":{\"873\":1}}],[\"条件\",{\"1\":{\"755\":1,\"756\":1,\"762\":1,\"764\":1,\"765\":1,\"766\":2,\"767\":1,\"770\":1}}],[\"条件转换掉\",{\"1\":{\"85\":1}}],[\"列出全部bean名称\",{\"1\":{\"1321\":1}}],[\"列的下标是从1开始的\",{\"1\":{\"799\":1}}],[\"列的值必须大于或等于\",{\"1\":{\"747\":1}}],[\"列的值是唯一的\",{\"1\":{\"747\":1}}],[\"列1\",{\"1\":{\"774\":2}}],[\"列名=值\",{\"1\":{\"755\":1}}],[\"列名2\",{\"1\":{\"754\":2,\"764\":1}}],[\"列名1\",{\"1\":{\"754\":2,\"764\":1}}],[\"列名\",{\"1\":{\"750\":2,\"751\":2,\"762\":4,\"764\":1,\"765\":6,\"766\":2,\"770\":2,\"779\":1,\"780\":1}}],[\"列不能为\",{\"1\":{\"747\":1}}],[\"列在未指定值时默认值为\",{\"1\":{\"747\":1}}],[\"列\",{\"1\":{\"747\":1}}],[\"列是外键\",{\"1\":{\"747\":1}}],[\"列是主键\",{\"1\":{\"747\":1}}],[\"列级约束有六种\",{\"1\":{\"747\":1}}],[\"列级约束条件\",{\"0\":{\"747\":1},\"1\":{\"750\":2,\"751\":1}}],[\"列表如下\",{\"1\":{\"962\":1}}],[\"列表中允许存在相同元素\",{\"1\":{\"182\":1}}],[\"列表中允许存在重复元素\",{\"1\":{\"181\":1}}],[\"列表\",{\"0\":{\"181\":1},\"1\":{\"181\":1,\"241\":1}}],[\"负责对数据库对象运行数据访问工作的指令集\",{\"1\":{\"744\":1}}],[\"负载因子默认为0\",{\"1\":{\"217\":1}}],[\"负载因子\",{\"1\":{\"215\":1}}],[\"仓库id\",{\"1\":{\"739\":6}}],[\"书籍\",{\"1\":{\"738\":1}}],[\"书籍作者\",{\"1\":{\"738\":2}}],[\"书籍名称\",{\"1\":{\"738\":2}}],[\"书籍编号\",{\"1\":{\"738\":3}}],[\"借阅编号\",{\"1\":{\"738\":2}}],[\"借用\",{\"1\":{\"101\":1}}],[\"满足第三范式\",{\"1\":{\"738\":1}}],[\"满足第一范式是关系型数据库最基本的要求\",{\"1\":{\"736\":1}}],[\"满足f\",{\"1\":{\"58\":1}}],[\"手机号码\",{\"1\":{\"736\":1}}],[\"手动修改\",{\"0\":{\"946\":1}}],[\"手动调用connect方法进行连接\",{\"1\":{\"721\":1}}],[\"手动调用wait\",{\"1\":{\"300\":1}}],[\"手动创建一个authenticationmanager用于处理密码校验\",{\"1\":{\"666\":1}}],[\"手动编译一个\",{\"1\":{\"356\":1}}],[\"座机号码\",{\"1\":{\"736\":1}}],[\"电话号码实际上包括了家用座机电话和移动电话\",{\"1\":{\"736\":1}}],[\"电话号码\",{\"1\":{\"736\":1}}],[\"授课\",{\"1\":{\"734\":1}}],[\"授课表\",{\"1\":{\"734\":1}}],[\"授权校验流程\",{\"0\":{\"704\":1}}],[\"授权\",{\"0\":{\"691\":1},\"1\":{\"635\":1}}],[\"教师号\",{\"1\":{\"734\":2}}],[\"教师\",{\"1\":{\"734\":1}}],[\"教师表\",{\"1\":{\"734\":1}}],[\"姓名和性别都会因此发生改变\",{\"1\":{\"737\":1}}],[\"姓名\",{\"1\":{\"734\":2,\"736\":2,\"737\":1}}],[\"专家\",{\"1\":{\"1000\":1}}],[\"专业等\",{\"1\":{\"733\":1}}],[\"专门创建一个独属于某个线程的变量\",{\"1\":{\"319\":1}}],[\"专门用于盗取他人信息\",{\"1\":{\"641\":1}}],[\"专门用于表示一个文件或文件夹\",{\"1\":{\"255\":1}}],[\"专门用于处理文本数据\",{\"1\":{\"245\":1}}],[\"年级\",{\"1\":{\"733\":1}}],[\"年龄\",{\"1\":{\"161\":1,\"166\":1,\"733\":1}}],[\"免费\",{\"1\":{\"732\":1}}],[\"探测双方的tcp\",{\"1\":{\"721\":1}}],[\"省略\",{\"1\":{\"719\":1}}],[\"禁止\",{\"1\":{\"714\":1}}],[\"职责\",{\"1\":{\"714\":1}}],[\"验证失败\",{\"1\":{\"711\":1}}],[\"怎么生产\",{\"1\":{\"1296\":1}}],[\"怎么会让当前对象的dofilter方法递归调用呢\",{\"1\":{\"710\":1}}],[\"怎么使用\",{\"1\":{\"549\":1}}],[\"看起来似乎两级缓存也可以解决问题啊\",{\"1\":{\"1301\":1}}],[\"看起来很复杂\",{\"1\":{\"1301\":1}}],[\"看系统内核参数配置\",{\"1\":{\"721\":1}}],[\"看似没有任何循环\",{\"1\":{\"710\":1}}],[\"看看它是怎么加载所有bean的\",{\"1\":{\"1321\":1}}],[\"看看第二层有没有\",{\"1\":{\"1301\":1}}],[\"看看闲置列表容量是否已满\",{\"1\":{\"1247\":1}}],[\"看看有没有那种卡住的链接\",{\"1\":{\"1246\":1}}],[\"看看结果吧\",{\"1\":{\"1223\":1}}],[\"看看修改后是否能够访问到其他页面\",{\"1\":{\"692\":1}}],[\"看看如何使用模块机制\",{\"1\":{\"464\":1}}],[\"看看是否还有下一个元素\",{\"1\":{\"189\":1}}],[\"耐心点\",{\"1\":{\"706\":1}}],[\"决定哪些角色可以访问哪些页面\",{\"1\":{\"692\":1}}],[\"决定用户能否使用某个功能\",{\"1\":{\"691\":1}}],[\"两次读取的数据不一致\",{\"1\":{\"1271\":1}}],[\"两次任务之间的时间间隔\",{\"1\":{\"1190\":1}}],[\"两者的区别为\",{\"1\":{\"1083\":1}}],[\"两者只是概念上的不同\",{\"1\":{\"691\":1}}],[\"两个报名的事务同时在进行\",{\"1\":{\"1270\":1}}],[\"两个人同时报名一个活动\",{\"1\":{\"1270\":1}}],[\"两个参数\",{\"1\":{\"521\":1}}],[\"两个参数对应\",{\"1\":{\"452\":1}}],[\"两个属性都是一模一样的\",{\"1\":{\"501\":1}}],[\"两个方法同时在运行或者是两个计算同时在进行\",{\"1\":{\"295\":1}}],[\"两个对象只有\",{\"1\":{\"241\":1}}],[\"两个需要比较的数会在这里给出\",{\"1\":{\"171\":1}}],[\"两个算法迭代过程十分类似\",{\"1\":{\"70\":1}}],[\"群主\",{\"1\":{\"691\":1}}],[\"群主可以管理整个群的任何板块\",{\"1\":{\"691\":1}}],[\"退出登陆就要调用\",{\"1\":{\"691\":1}}],[\"退出登录成功后跳转的地址\",{\"1\":{\"683\":1}}],[\"退出登录地址\",{\"1\":{\"683\":1}}],[\"退出登录也是同样的操作\",{\"1\":{\"683\":1}}],[\"退出登录操作配置\",{\"0\":{\"683\":1}}],[\"退出登录后就需要重新登录才能访问我们的网站了\",{\"1\":{\"658\":1}}],[\"管理事务\",{\"0\":{\"806\":1}}],[\"管理员id\",{\"1\":{\"739\":6}}],[\"管理员\",{\"1\":{\"691\":1}}],[\"管理员和普通群成员三种角色\",{\"1\":{\"691\":1}}],[\"管理和操作我们的数据而存在的\",{\"1\":{\"178\":1}}],[\"记在你的心中\",{\"1\":{\"1271\":1}}],[\"记住我\",{\"1\":{\"1093\":2}}],[\"记住我实现\",{\"1\":{\"712\":1}}],[\"记住我信息会全部丢失\",{\"1\":{\"686\":1}}],[\"记住我设置的cookie名字\",{\"1\":{\"686\":1}}],[\"记住我表单字段\",{\"1\":{\"686\":1}}],[\"记住我功能\",{\"0\":{\"685\":1}}],[\"记录\",{\"1\":{\"501\":1}}],[\"记录类型在java\",{\"1\":{\"501\":1}}],[\"记录类型\",{\"0\":{\"501\":1}}],[\"记录当前数组元素数的\",{\"1\":{\"182\":1}}],[\"记录在\",{\"1\":{\"81\":1}}],[\"校验\",{\"0\":{\"684\":1}}],[\"别名2\",{\"1\":{\"768\":1}}],[\"别名1\",{\"1\":{\"768\":1}}],[\"别名\",{\"0\":{\"832\":1,\"1128\":1},\"1\":{\"762\":1}}],[\"别忘了delegatetouse就是初始化的filterchainproxy对象\",{\"1\":{\"707\":1}}],[\"别再遇到302一脸懵逼了\",{\"1\":{\"681\":1}}],[\"别人如果需要将我们编写的代码作为依赖\",{\"1\":{\"1003\":1}}],[\"别人将某个方法设置为private一定有他的理由\",{\"1\":{\"349\":1}}],[\"别人来调用我们的实现\",{\"1\":{\"171\":1}}],[\"登陆之后畅行无阻\",{\"1\":{\"1104\":1}}],[\"登陆校验\",{\"1\":{\"1093\":1}}],[\"登陆成功\",{\"1\":{\"804\":2,\"805\":1,\"1072\":1}}],[\"登陆用户\",{\"0\":{\"773\":1}}],[\"登陆失败\",{\"1\":{\"1072\":1}}],[\"登陆失败的记住我处理\",{\"1\":{\"713\":1}}],[\"登陆失败会直接清理掉securitycontextholder中的认证信息\",{\"1\":{\"713\":1}}],[\"登陆请求提交处理由springsecurity提供\",{\"1\":{\"680\":1}}],[\"登陆请求地址为\",{\"1\":{\"680\":1}}],[\"登陆页面我们刚刚已经自己编写controller来实现了\",{\"1\":{\"680\":1}}],[\"登录后\",{\"1\":{\"1047\":1}}],[\"登录表单提交的地址\",{\"1\":{\"680\":1}}],[\"登录之后才能转账\",{\"1\":{\"636\":1}}],[\"登录失败\",{\"1\":{\"617\":2}}],[\"登录成功后跳转的页面\",{\"1\":{\"680\":1}}],[\"登录成功后\",{\"1\":{\"658\":1}}],[\"登录成功之后应该重新给用户分配一个新的jsessionid才行\",{\"1\":{\"642\":1}}],[\"登录成功\",{\"1\":{\"617\":2}}],[\"构建\",{\"0\":{\"1048\":1}}],[\"构建完成后\",{\"1\":{\"902\":1}}],[\"构建对应\",{\"0\":{\"670\":1}}],[\"构建实体类\",{\"0\":{\"669\":1}}],[\"构造注入\",{\"0\":{\"1134\":1}}],[\"构造函数\",{\"1\":{\"986\":1}}],[\"构造函数或方法上\",{\"1\":{\"525\":1}}],[\"构造函数也不能赋值\",{\"1\":{\"374\":1}}],[\"构造器以外\",{\"1\":{\"1181\":1}}],[\"构造器注入\",{\"1\":{\"1181\":2}}],[\"构造器\",{\"1\":{\"166\":1,\"348\":1}}],[\"构造方法中的参数除了被自动注入外\",{\"1\":{\"1200\":1}}],[\"构造方法中完成\",{\"1\":{\"1134\":1}}],[\"构造方法依赖注入\",{\"1\":{\"1136\":1}}],[\"构造方法的编写会非常麻烦\",{\"1\":{\"810\":1}}],[\"构造方法直接使用new关键字就行\",{\"1\":{\"453\":1}}],[\"构造方法作为方法引用\",{\"0\":{\"453\":1}}],[\"构造方法也可以被引用\",{\"1\":{\"415\":1}}],[\"构造方法得到字符串\",{\"1\":{\"248\":1}}],[\"构造方法会在new的时候自动执行\",{\"1\":{\"166\":1}}],[\"构造方法会在对象创建时执行\",{\"1\":{\"166\":1}}],[\"构造方法不需要指定返回值\",{\"1\":{\"166\":1}}],[\"构造方法不需要填写返回值\",{\"1\":{\"166\":1}}],[\"构造方法\",{\"0\":{\"166\":1},\"1\":{\"166\":1,\"182\":1,\"501\":1}}],[\"旧的内容会被移到old表中\",{\"1\":{\"781\":2}}],[\"旧密码\",{\"1\":{\"666\":1}}],[\"旧容量不大于0只可能是还没初始化\",{\"1\":{\"217\":1}}],[\"启动后\",{\"1\":{\"664\":1}}],[\"启动时\",{\"1\":{\"560\":1}}],[\"官方也是推荐使用hikaricp\",{\"1\":{\"1260\":1}}],[\"官方支持的有多种多样的\",{\"1\":{\"1220\":1}}],[\"官方原文\",{\"1\":{\"1181\":1}}],[\"官方已经给我们预设了一些项目了\",{\"1\":{\"1047\":1}}],[\"官方文档原文如下\",{\"1\":{\"1148\":1}}],[\"官方文档\",{\"1\":{\"995\":1}}],[\"官方解释它主要用于惰性获取数据\",{\"1\":{\"836\":1}}],[\"官方解释它是java编程语言和广泛的数据库之间独立于数据库的连接标准的java\",{\"1\":{\"787\":1}}],[\"官方默认提供了可以直接使用的用户和权限表设计\",{\"1\":{\"662\":1}}],[\"官方提供的模块\",{\"1\":{\"463\":1}}],[\"页面中出现如下内容\",{\"1\":{\"1047\":1}}],[\"页面中只要发起了patch\",{\"1\":{\"660\":1}}],[\"页面在加载时就会显示一个弹窗\",{\"1\":{\"564\":1}}],[\"携带此信息即可\",{\"1\":{\"660\":1}}],[\"携带这个input的value值\",{\"1\":{\"660\":1}}],[\"携带表单数据\",{\"1\":{\"589\":2}}],[\"地址\",{\"1\":{\"658\":1}}],[\"角色目前我们不需要关心\",{\"1\":{\"658\":1}}],[\"脚本注入\",{\"1\":{\"643\":1}}],[\"οnlοad=\",{\"1\":{\"643\":1}}],[\"诱导用户操作\",{\"1\":{\"643\":1}}],[\"恶意代码会被执行\",{\"1\":{\"643\":2}}],[\"恶意代码会在用户的浏览器中执行\",{\"1\":{\"643\":1}}],[\"恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作\",{\"1\":{\"641\":1}}],[\"跨站脚本攻击\",{\"1\":{\"643\":1}}],[\"跨站请求伪造\",{\"1\":{\"641\":1}}],[\"攻击者将恶意代码嵌入到url中\",{\"1\":{\"643\":1}}],[\"攻击者将恶意代码存储到目标网站的数据库中\",{\"1\":{\"643\":1}}],[\"攻击者就可以利用会话id获取用户的权限\",{\"1\":{\"642\":1}}],[\"攻击者就能利用该会话id获取用户的权限\",{\"1\":{\"642\":1}}],[\"攻击者事先获取到会话id\",{\"1\":{\"642\":1}}],[\"攻击者利用前端javascript代码的漏洞\",{\"1\":{\"643\":1}}],[\"攻击者利用劫持用户与服务器之间的通信流量\",{\"1\":{\"642\":1}}],[\"攻击者利用这种漏洞\",{\"1\":{\"642\":1}}],[\"攻击者通过在合法网站中注入恶意脚本代码来攻击用户\",{\"1\":{\"643\":1}}],[\"攻击者通过url参数\",{\"1\":{\"642\":1}}],[\"攻击者通常使用以下几种方式进行会话固定攻击\",{\"1\":{\"642\":1}}],[\"攻击\",{\"1\":{\"641\":1}}],[\"攻击防护\",{\"1\":{\"635\":1}}],[\"旨在防止跨站点请求伪造\",{\"1\":{\"641\":1}}],[\"旨在方便我们编写复杂字符串\",{\"1\":{\"498\":1}}],[\"钱已经被转走了\",{\"1\":{\"641\":1}}],[\"黑客可以利用这种特性\",{\"1\":{\"643\":1}}],[\"黑客不走常规的方式发帖\",{\"1\":{\"643\":1}}],[\"黑客\",{\"1\":{\"641\":1}}],[\"服务端处理请求时\",{\"1\":{\"1096\":1}}],[\"服务端发出响应请求时\",{\"1\":{\"1096\":1}}],[\"服务端不仅仅只可以让一个客户端进行连接\",{\"1\":{\"719\":1}}],[\"服务端和客户端之间就可以相互发送数据\",{\"1\":{\"719\":1}}],[\"服务端连接失败\",{\"1\":{\"719\":1,\"720\":1,\"726\":1}}],[\"服务端\",{\"1\":{\"719\":1}}],[\"服务端返回给我们了一个记住我专属的cookie信息\",{\"1\":{\"686\":1}}],[\"服务端会给浏览器一个名为jsessionid的cookie信息作为会话的唯一凭据\",{\"1\":{\"641\":1}}],[\"服务器就会通过cookie的值进行辨别\",{\"1\":{\"1095\":1}}],[\"服务器端可以进行获取\",{\"1\":{\"1091\":1}}],[\"服务器端只需要在请求参数位置添加一个对象接收即可\",{\"1\":{\"617\":1}}],[\"服务器发送我们编写好的静态网页内容\",{\"1\":{\"1053\":1}}],[\"服务器配置文件目录\",{\"1\":{\"1047\":1}}],[\"服务器启动成功之后\",{\"1\":{\"1047\":1}}],[\"服务器则正常启动\",{\"1\":{\"1047\":1}}],[\"服务器收到http请求报文后\",{\"1\":{\"1042\":1}}],[\"服务器程序向客户程序送回客户所要的万维网文档\",{\"1\":{\"1042\":1}}],[\"服务器出现了一个内部错误qaq\",{\"1\":{\"605\":1}}],[\"失败\",{\"1\":{\"636\":1}}],[\"交给spring来进行管理\",{\"1\":{\"1277\":1}}],[\"交给过滤链处理\",{\"1\":{\"1104\":1}}],[\"交给上一级函数\",{\"1\":{\"424\":1}}],[\"交易已完成\",{\"1\":{\"636\":1,\"658\":1}}],[\"密码等\",{\"1\":{\"824\":1}}],[\"密码修改失败\",{\"1\":{\"666\":1}}],[\"密码修改成功\",{\"1\":{\"666\":1}}],[\"密码\",{\"1\":{\"636\":1,\"772\":1,\"804\":1,\"805\":1,\"806\":4,\"824\":1,\"1069\":1,\"1071\":1,\"1242\":1}}],[\"密封类型有以下要求\",{\"1\":{\"504\":1}}],[\"密封类型可以说是java\",{\"1\":{\"503\":1}}],[\"密封类型\",{\"0\":{\"503\":1}}],[\"认证是我们网站的第一步\",{\"1\":{\"656\":1}}],[\"认证\",{\"0\":{\"656\":1},\"1\":{\"635\":1}}],[\"认为所有状态都是同等重要的\",{\"1\":{\"134\":1}}],[\"根本找不到工作\",{\"1\":{\"1223\":1}}],[\"根本上说jdbc是一种规范\",{\"1\":{\"787\":1}}],[\"根本不需要我们来建表\",{\"1\":{\"662\":1}}],[\"根容器就是spring容器\",{\"1\":{\"625\":1}}],[\"根据bean定义通过反射创建bean实例\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"根据官方提供的数据\",{\"1\":{\"1260\":1}}],[\"根据我们的配置\",{\"1\":{\"1242\":1}}],[\"根据我们上节课学习的知识\",{\"1\":{\"928\":1}}],[\"根据条件获取集合中的元素\",{\"1\":{\"1209\":1}}],[\"根据提示\",{\"1\":{\"1192\":1}}],[\"根据类实现的感知接口\",{\"1\":{\"1186\":1}}],[\"根据setxxx中的xxx\",{\"1\":{\"1138\":1}}],[\"根据已有的基础\",{\"1\":{\"1070\":1}}],[\"根据通过\",{\"1\":{\"987\":1}}],[\"根据测试方法的名称和形式参数列表\",{\"1\":{\"987\":1}}],[\"根据显示名称对测试方法进行字母数字排序\",{\"1\":{\"987\":1}}],[\"根据不同类型的信息进行划分\",{\"1\":{\"909\":1}}],[\"根据不同的分支\",{\"1\":{\"497\":1}}],[\"根据用户属于哪个角色来决定是否可以访问某个路径\",{\"1\":{\"691\":1}}],[\"根据以上源码分析得出最终的流程图\",{\"1\":{\"626\":1}}],[\"根据handlermapping提供的信息\",{\"1\":{\"626\":1}}],[\"根据请求的路径选择合适的控制器进行处理\",{\"1\":{\"558\":1}}],[\"根据字符串中的\",{\"1\":{\"488\":2}}],[\"根据上面的推导\",{\"1\":{\"217\":1}}],[\"根据初始化大小\",{\"1\":{\"182\":1}}],[\"根据给定的用户名查询用户\",{\"1\":{\"668\":1}}],[\"根据给定的键\",{\"1\":{\"213\":1}}],[\"根据给定的predicate条件进行元素移除操作\",{\"1\":{\"180\":1}}],[\"根据给定的策略\",{\"1\":{\"112\":1}}],[\"根据这个式子我们就可以通过\",{\"1\":{\"155\":1}}],[\"根据梯度下降的公式\",{\"1\":{\"142\":1}}],[\"根据策略\",{\"1\":{\"78\":1}}],[\"根据策略π\",{\"1\":{\"48\":1}}],[\"根据对应的\",{\"1\":{\"66\":1}}],[\"根据\",{\"1\":{\"53\":2,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"113\":1,\"1096\":1}}],[\"根据一个\",{\"1\":{\"42\":1}}],[\"根据所给定的用户划分情况\",{\"1\":{\"13\":1}}],[\"根据遗传算法找到cn​个最优个体作为簇的中心\",{\"1\":{\"13\":1}}],[\"根据n个用户\",{\"1\":{\"13\":1}}],[\"根据mos数值\",{\"1\":{\"10\":1}}],[\"根据香农定理\",{\"1\":{\"9\":1}}],[\"机制\",{\"0\":{\"1320\":1},\"1\":{\"619\":1}}],[\"带着诸多问题\",{\"1\":{\"1109\":1}}],[\"带各位小伙伴体验如何发起异步请求并更新我们页面中的数据\",{\"1\":{\"617\":1}}],[\"带初始值的初始化\",{\"1\":{\"528\":1}}],[\"期间用户无法进行其他操作\",{\"1\":{\"617\":1}}],[\"期望的情况\",{\"1\":{\"105\":1}}],[\"打开conf文件夹\",{\"1\":{\"1047\":1}}],[\"打开环境变量\",{\"1\":{\"1047\":1}}],[\"打开高级系统设置\",{\"1\":{\"1047\":1}}],[\"打开编辑\",{\"1\":{\"1010\":1}}],[\"打开后可以看到已经给我们写出了依赖的坐标\",{\"1\":{\"1008\":1}}],[\"打开浏览器\",{\"1\":{\"615\":1}}],[\"打包成可执行文件\",{\"0\":{\"1037\":1}}],[\"打包将无法完成\",{\"1\":{\"1036\":1}}],[\"打包\",{\"1\":{\"1000\":1}}],[\"打工是不可能打工的\",{\"1\":{\"950\":1}}],[\"打印bean的名称\",{\"1\":{\"1307\":1}}],[\"打印一些其他的内容\",{\"1\":{\"1218\":1}}],[\"打印查看一下最终执行的\",{\"1\":{\"805\":1}}],[\"打印栈追踪信息\",{\"1\":{\"424\":1}}],[\"打印当前线程名称\",{\"1\":{\"323\":1}}],[\"打印\",{\"1\":{\"299\":1,\"432\":1}}],[\"打印流其实我们从一开始就在使用了\",{\"1\":{\"284\":1}}],[\"打印流\",{\"0\":{\"284\":1}}],[\"打印集合类\",{\"1\":{\"182\":1}}],[\"比较运算\",{\"1\":{\"1204\":1}}],[\"比较常见的就是打印到控制台\",{\"1\":{\"918\":1}}],[\"比较常用的是jackson和fastjson\",{\"1\":{\"611\":1}}],[\"比如包扫描\",{\"1\":{\"1320\":1}}],[\"比如bean实例\",{\"1\":{\"1306\":1}}],[\"比如beannameaware之类的以aware结尾的接口\",{\"1\":{\"1186\":1}}],[\"比如aop代理相关的\",{\"1\":{\"1301\":1}}],[\"比如afterreturningadvice就需要实现一个方法执行之后的操作\",{\"1\":{\"1231\":1}}],[\"比如移除bean定义\",{\"1\":{\"1298\":1}}],[\"比如classpathxmlapplicationcontext在初始化的时候就会创建一个对应的xmlbeandefinitionreader进行扫描\",{\"1\":{\"1297\":1}}],[\"比如c3p0\",{\"1\":{\"1260\":1}}],[\"比如contextrefreshedevent\",{\"1\":{\"1191\":1}}],[\"比如com\",{\"1\":{\"277\":1,\"1219\":1}}],[\"比如方法执行之后返回了什么\",{\"1\":{\"1223\":1}}],[\"比如执行前\",{\"1\":{\"1220\":1}}],[\"比如xml中可以这样写\",{\"1\":{\"1211\":1}}],[\"比如调用方法之类的\",{\"1\":{\"1202\":1}}],[\"比如对应构建实体类对象的方法不是static\",{\"1\":{\"1159\":1}}],[\"比如在方法开始执行之前或是执行之后会去调用我们实现的接口\",{\"1\":{\"1231\":1}}],[\"比如在工厂方法设计模式中\",{\"1\":{\"1157\":1}}],[\"比如在insert操作时\",{\"1\":{\"781\":1}}],[\"比如出现了下面的情况\",{\"1\":{\"1140\":1}}],[\"比如美术老师\",{\"1\":{\"1132\":1}}],[\"比如teacher应该在student之前加载\",{\"1\":{\"1131\":1}}],[\"比如当我们需要一个接口的实现时\",{\"1\":{\"1117\":1}}],[\"比如webapp\",{\"1\":{\"1109\":1}}],[\"比如请求转发\",{\"1\":{\"1084\":1}}],[\"比如网页上有一个时间\",{\"1\":{\"1076\":1}}],[\"比如zulujdk默认就是\",{\"1\":{\"1047\":1}}],[\"比如mysql一旦声明事务为只读\",{\"1\":{\"1279\":1}}],[\"比如mybatis的pom文件中\",{\"1\":{\"1025\":1}}],[\"比如map类型\",{\"1\":{\"1136\":1}}],[\"比如maintest\",{\"1\":{\"1035\":1}}],[\"比如多个子项目都需要父项目的依赖\",{\"1\":{\"1032\":1}}],[\"比如配置文件\",{\"1\":{\"1017\":1}}],[\"比如jdbc驱动就是典型的只需要运行时使用\",{\"1\":{\"1016\":1}}],[\"比如js\",{\"1\":{\"564\":1}}],[\"比如某个bean必须要在另一个bean之前创建\",{\"1\":{\"1131\":1}}],[\"比如某个案例存在一个bug\",{\"1\":{\"990\":1}}],[\"比如某些测试案例必须在指定jdk版本执行\",{\"1\":{\"975\":1}}],[\"比如初始化类需要花费大量时间或是执行非常费时的io操作时\",{\"1\":{\"986\":1}}],[\"比如测试前的准备工作或是测试后的收尾工作\",{\"1\":{\"985\":1}}],[\"比如异常判断\",{\"1\":{\"973\":1}}],[\"比如handler的构造方法\",{\"1\":{\"939\":1}}],[\"比如下面要访问name属性\",{\"1\":{\"1203\":1}}],[\"比如下面的情况\",{\"1\":{\"1116\":1}}],[\"比如下面的这个例子\",{\"1\":{\"500\":1}}],[\"比如下面\",{\"1\":{\"930\":1}}],[\"比如边充电边打电话就是个危险操作\",{\"1\":{\"910\":1}}],[\"比如插入一个用户\",{\"1\":{\"896\":1}}],[\"比如每个用户现在都有一个小组\",{\"1\":{\"855\":1}}],[\"比如每个同学的学号都是不一样的\",{\"1\":{\"733\":1}}],[\"比如小于\",{\"1\":{\"836\":1}}],[\"比如转换为一个map对象\",{\"1\":{\"833\":1}}],[\"比如类中的哪个字段对应数据库中的哪个字段\",{\"1\":{\"826\":1}}],[\"比如类的成员变量\",{\"1\":{\"485\":1}}],[\"比如根节点下就囊括了所有的节点\",{\"1\":{\"819\":1}}],[\"比如要展示借阅信息列表\",{\"1\":{\"1116\":1}}],[\"比如要根据id修改用户的年龄\",{\"1\":{\"863\":1}}],[\"比如要依次删除很多个表的数据\",{\"1\":{\"782\":1}}],[\"比如要共享某些数据\",{\"1\":{\"295\":1}}],[\"比如现在有一个教师接口\",{\"1\":{\"1132\":1}}],[\"比如现在有一个存储所有用户的表\",{\"1\":{\"769\":1}}],[\"比如现在在ioc容器中管理的service的实现是b\",{\"1\":{\"1117\":1}}],[\"比如现在我们希望对这个学生对象的study方法进行增强\",{\"1\":{\"1218\":1}}],[\"比如现在我们希望在定时任务中每秒钟发生一次这个事件\",{\"1\":{\"1192\":1}}],[\"比如现在我们希望在查询用户时\",{\"1\":{\"874\":1}}],[\"比如现在我们要让ioc容器帮助我们管理一个student对象\",{\"1\":{\"1119\":1}}],[\"比如现在我们有一个这样的构造方法\",{\"1\":{\"841\":1}}],[\"比如现在我们有一个abcd\",{\"1\":{\"488\":1}}],[\"比如现在我们写了这些类\",{\"1\":{\"504\":1}}],[\"比如现在我们想要实现之前的这个奇葩需求\",{\"1\":{\"902\":1}}],[\"比如现在我们想要批量插入一些用户到数据库里面\",{\"1\":{\"877\":1}}],[\"比如现在我们想要让数据从大到小排列\",{\"1\":{\"171\":1}}],[\"比如现在我们想去批量下载某个网站的壁纸\",{\"1\":{\"490\":1}}],[\"比如现在我们想执行\",{\"1\":{\"480\":1}}],[\"比如现在我们创建了一个新的maven项目\",{\"1\":{\"468\":1}}],[\"比如性别只能是男或是女\",{\"1\":{\"733\":1}}],[\"比如最常见的accessdenied之类的\",{\"1\":{\"714\":1}}],[\"比如用户相关的测试全部归为一个组\",{\"1\":{\"988\":1}}],[\"比如用户名和密码错误\",{\"1\":{\"711\":1}}],[\"比如用于处理登陆的过滤器usernamepasswordauthenticationfilter\",{\"1\":{\"711\":1}}],[\"比如登陆\",{\"1\":{\"691\":1}}],[\"比如重定向\",{\"1\":{\"587\":1}}],[\"比如这里并没有包含项目中用到的一些其他依赖\",{\"1\":{\"1037\":1}}],[\"比如这里包含类名\",{\"1\":{\"948\":1}}],[\"比如这里我们添加了mybatis的依赖到原项目中\",{\"1\":{\"1024\":1}}],[\"比如这里我们要求请求中必须携带username和password属性\",{\"1\":{\"574\":1}}],[\"比如这里我们返回的是helloworld字符串\",{\"1\":{\"549\":1}}],[\"比如这里就是通过空格分隔\",{\"1\":{\"401\":1}}],[\"比如淘宝\",{\"1\":{\"540\":1}}],[\"比如失败的情况只需要code和message\",{\"1\":{\"523\":1}}],[\"比如一些会用到的类加载器和后置处理器\",{\"1\":{\"1320\":1}}],[\"比如一些集合允许重复的元素\",{\"1\":{\"178\":1}}],[\"比如一个事务先读取了某条数据\",{\"1\":{\"1267\":1}}],[\"比如一个老师可以教很多个学生\",{\"1\":{\"733\":1}}],[\"比如一个学生的特征包括姓名\",{\"1\":{\"733\":1}}],[\"比如一个api结果返回值的类result\",{\"1\":{\"523\":1}}],[\"比如双引号等\",{\"1\":{\"498\":1}}],[\"比如需要的服务等\",{\"1\":{\"467\":1}}],[\"比如runnable接口需要一个方法体对它的run\",{\"1\":{\"446\":1}}],[\"比如是因为什么原因导致的异常\",{\"1\":{\"423\":1}}],[\"比如object类中定义的clone方法\",{\"1\":{\"421\":1}}],[\"比如数组越界异常\",{\"1\":{\"421\":1}}],[\"比如字符串的裁剪\",{\"1\":{\"401\":1}}],[\"比如之前悬念中的value变量\",{\"1\":{\"311\":1}}],[\"比如spring\",{\"1\":{\"1272\":1}}],[\"比如s\",{\"1\":{\"1175\":1}}],[\"比如string\",{\"1\":{\"831\":1}}],[\"比如scanner获取输入的文本\",{\"1\":{\"299\":1}}],[\"比如system\",{\"1\":{\"284\":1}}],[\"比如键盘发送的信号\",{\"1\":{\"265\":1}}],[\"比如筛选\",{\"1\":{\"228\":1}}],[\"比如上面的例子\",{\"1\":{\"1018\":1}}],[\"比如上面的type=\",{\"1\":{\"817\":1}}],[\"比如上面的学生信息\",{\"1\":{\"213\":1}}],[\"比如上我们定义的是类型\",{\"1\":{\"171\":1}}],[\"比如\",{\"1\":{\"180\":1,\"360\":1,\"421\":1,\"445\":1,\"448\":1,\"569\":1,\"571\":3,\"572\":1,\"574\":1,\"576\":1,\"582\":1,\"589\":1,\"699\":1,\"737\":1,\"763\":1,\"767\":1,\"770\":1,\"843\":1,\"944\":1,\"956\":1,\"976\":1,\"987\":1,\"1034\":1,\"1134\":1,\"1149\":1,\"1171\":1,\"1172\":1,\"1178\":1,\"1203\":1,\"1219\":2,\"1235\":1,\"1236\":2,\"1246\":1,\"1270\":1,\"1307\":1,\"1318\":1}}],[\"比如我们要读取xml配置\",{\"1\":{\"1296\":1}}],[\"比如我们要估计某个随机变量x的\",{\"1\":{\"99\":1}}],[\"比如我们这里使用methodbeforeadvice表示是一个在方法执行之前的动作\",{\"1\":{\"1231\":1}}],[\"比如我们这里使用的是org\",{\"1\":{\"1003\":1}}],[\"比如我们的某些方法执行完成之后\",{\"1\":{\"1215\":1}}],[\"比如我们的数据库连接相关信息\",{\"1\":{\"1085\":1}}],[\"比如我们在这里编写一个mybatis的配置文件\",{\"1\":{\"1017\":1}}],[\"比如我们上面的lombok\",{\"1\":{\"1016\":1}}],[\"比如我们上面用的\",{\"1\":{\"463\":1}}],[\"比如我们希望使用多线程来处理我们的结果或是执行一些定时任务\",{\"1\":{\"1187\":1}}],[\"比如我们希望测试某个枚举类型下所有的枚举作为参数进行测试\",{\"1\":{\"993\":1}}],[\"比如我们希望配置usegeneratedkeys来得到自动生成的主键\",{\"1\":{\"897\":1}}],[\"比如我们希望某个操作执行完成后\",{\"1\":{\"887\":1}}],[\"比如我们希望在student的study方法执行之前执行我们的before方法\",{\"1\":{\"1233\":1}}],[\"比如我们希望在根据id查询用户时\",{\"1\":{\"873\":1}}],[\"比如我们希望在读取到某个元素时截断\",{\"1\":{\"479\":1}}],[\"比如我们最常用的qq\",{\"1\":{\"691\":1}}],[\"比如我们点击一个按钮会弹出新的内容\",{\"1\":{\"617\":1}}],[\"比如我们向其中存放几个数据\",{\"1\":{\"612\":1}}],[\"比如我们从数据库中查询的账户信息\",{\"1\":{\"501\":1}}],[\"比如我们来做一个简单的计算\",{\"1\":{\"473\":1}}],[\"比如我们现在希望将sqlsessionfactory交给ioc容器进行管理\",{\"1\":{\"1253\":1}}],[\"比如我们现在想配置默认的日志打印级别\",{\"1\":{\"939\":1}}],[\"比如我们现在要配置数据库的连接信息\",{\"1\":{\"936\":1}}],[\"比如我们现在需要对一个数组进行排序\",{\"1\":{\"449\":1}}],[\"比如我们现在不希望使用object类中提供的equals方法\",{\"1\":{\"373\":1}}],[\"比如我们之前使用的是注解方式配置controller\",{\"1\":{\"625\":1}}],[\"比如我们之前使用的runable类\",{\"1\":{\"447\":1}}],[\"比如我们之前要重写一个类的equals方法\",{\"1\":{\"499\":1}}],[\"比如我们之前学习的顺序表\",{\"1\":{\"180\":1}}],[\"比如我们想要查询所有年龄大于等于18岁的用户\",{\"1\":{\"836\":1}}],[\"比如我们想要编写一个根据成绩得到等级的方法\",{\"1\":{\"495\":1}}],[\"比如我们想要打印数组\",{\"1\":{\"432\":1}}],[\"比如我们想计算某个学生的所有科目分数之后\",{\"1\":{\"222\":1}}],[\"比如我们可以直接在网站上添加一个快速重置密码的接口\",{\"1\":{\"666\":1}}],[\"比如我们可以直接当做栈来进行使用\",{\"1\":{\"201\":1}}],[\"比如我们可以这样编写\",{\"1\":{\"574\":1}}],[\"比如我们可以使用\",{\"1\":{\"473\":1}}],[\"比如我们可以判断变量的值\",{\"1\":{\"425\":1}}],[\"比如我们可以来看看下面这个问题\",{\"1\":{\"311\":1}}],[\"比如我们运行qq\",{\"1\":{\"295\":1}}],[\"比如我们经常访问的\",{\"1\":{\"277\":1}}],[\"比如说\",{\"1\":{\"171\":1,\"376\":1,\"522\":3}}],[\"阿伟\",{\"1\":{\"610\":3}}],[\"杰哥\",{\"1\":{\"610\":4,\"612\":2,\"613\":2,\"615\":1,\"616\":1}}],[\"配合springel表达式\",{\"1\":{\"1200\":1}}],[\"配合使用\",{\"1\":{\"604\":1}}],[\"配合\",{\"1\":{\"602\":3}}],[\"配置并注册\",{\"0\":{\"1125\":1}}],[\"配置和组装bean\",{\"1\":{\"1119\":1}}],[\"配置连接数据库\",{\"1\":{\"1072\":1}}],[\"配置多个访问路径\",{\"0\":{\"1063\":1}}],[\"配置很简单\",{\"1\":{\"1048\":1}}],[\"配置为国内的阿里云仓库地址了\",{\"1\":{\"1010\":1}}],[\"配置文件中\",{\"1\":{\"1242\":1}}],[\"配置文件都不需要改了\",{\"1\":{\"1231\":1}}],[\"配置文件\",{\"1\":{\"1071\":1}}],[\"配置文件修改\",{\"0\":{\"947\":1}}],[\"配置文件完成后\",{\"1\":{\"824\":1}}],[\"配置consolehandler的默认level\",{\"1\":{\"939\":1,\"951\":1}}],[\"配置方式和之前几乎一致\",{\"1\":{\"900\":1}}],[\"配置方式非常简单\",{\"1\":{\"658\":1}}],[\"配置这些额外的参数\",{\"0\":{\"897\":1}}],[\"配置lombok\",{\"0\":{\"811\":1}}],[\"配置完成后\",{\"1\":{\"658\":1,\"686\":1,\"835\":1,\"850\":1,\"1048\":1,\"1291\":1,\"1297\":1}}],[\"配置类\",{\"0\":{\"651\":1,\"664\":1}}],[\"配置类注册\",{\"0\":{\"596\":1}}],[\"配置静态资源的访问路径\",{\"1\":{\"564\":1}}],[\"配置静态资源\",{\"0\":{\"564\":1}}],[\"配置模板引擎bean\",{\"1\":{\"560\":1}}],[\"配置模板解析器\",{\"1\":{\"560\":1}}],[\"配置视图解析器非常简单\",{\"1\":{\"560\":1}}],[\"配置视图解析器和控制器\",{\"0\":{\"559\":1}}],[\"配置相应配置类\",{\"0\":{\"553\":1}}],[\"配置dispatcherservlet的配置类\",{\"1\":{\"552\":1}}],[\"配置初始化接口\",{\"0\":{\"552\":1}}],[\"配置spring上下文环境\",{\"0\":{\"546\":1}}],[\"配置\",{\"0\":{\"545\":1,\"899\":1,\"902\":1,\"1071\":1,\"1097\":1}}],[\"配置环境并搭建项目\",{\"0\":{\"542\":1}}],[\"二级缓存配置\",{\"0\":{\"903\":1}}],[\"二级缓存才会被更新\",{\"1\":{\"884\":1}}],[\"二级缓存是事务性的\",{\"1\":{\"884\":1}}],[\"二级缓存是mapper级别的\",{\"1\":{\"884\":1}}],[\"二级缓存默认是关闭状态\",{\"1\":{\"884\":1}}],[\"二级缓存\",{\"0\":{\"884\":1}}],[\"二号拦截器\",{\"1\":{\"600\":7,\"601\":4}}],[\"二分搜索\",{\"0\":{\"234\":1}}],[\"情况\",{\"0\":{\"598\":1}}],[\"拦截器已经生效\",{\"1\":{\"596\":1}}],[\"拦截器不进行拦截的路径\",{\"1\":{\"596\":1}}],[\"拦截器与过滤器类似\",{\"1\":{\"593\":1}}],[\"拦截器是整个springmvc的一个重要内容\",{\"1\":{\"593\":1}}],[\"了解就行\",{\"1\":{\"1151\":1}}],[\"了解statement\",{\"0\":{\"791\":1}}],[\"了解connection\",{\"0\":{\"790\":1}}],[\"了解了一对多\",{\"1\":{\"855\":1}}],[\"了解了整个用户验证实现流程\",{\"1\":{\"714\":1}}],[\"了解了以上的相关知识后\",{\"1\":{\"468\":1}}],[\"了解一下dispatcherservlet底层是如何进行调度的\",{\"1\":{\"624\":1}}],[\"了解即可\",{\"1\":{\"589\":1,\"835\":1}}],[\"规定加载顺序\",{\"0\":{\"1131\":1}}],[\"规范资源获取的uri路径\",{\"1\":{\"589\":1}}],[\"规约reduce\",{\"1\":{\"515\":1}}],[\"鸡你太美\",{\"1\":{\"582\":1}}],[\"伞兵一号\",{\"1\":{\"581\":1,\"1224\":1}}],[\"拿到直接返回\",{\"1\":{\"1301\":1}}],[\"拿到name之后继续getbytes然后length\",{\"1\":{\"1203\":1}}],[\"拿到对象属性之后\",{\"1\":{\"1203\":1}}],[\"拿到的也是通过工厂方法得到的对象\",{\"1\":{\"1158\":1}}],[\"拿到输入流和文件输出流\",{\"1\":{\"490\":1}}],[\"拿\",{\"1\":{\"575\":1}}],[\"顾名思义beanfactory就是对bean进行生产和管理的工厂\",{\"1\":{\"1296\":1}}],[\"顾名思义\",{\"1\":{\"572\":1,\"1138\":1}}],[\"顾客3\",{\"1\":{\"331\":1}}],[\"顾客2\",{\"1\":{\"331\":1}}],[\"顾客1\",{\"1\":{\"331\":1}}],[\"顾客吃掉菜品的时间为4秒\",{\"1\":{\"331\":1}}],[\"辅助功能\",{\"0\":{\"570\":1}}],[\"$proxy29\",{\"1\":{\"1283\":1}}],[\"$proxy4\",{\"1\":{\"842\":1}}],[\"$\",{\"1\":{\"563\":1,\"605\":1,\"636\":1,\"660\":4,\"682\":2,\"683\":2,\"824\":4,\"1071\":4,\"1199\":2,\"1200\":1,\"1203\":1,\"1242\":4}}],[\"啊这\",{\"1\":{\"563\":1}}],[\"→\",{\"1\":{\"560\":1,\"739\":4}}],[\"模式默认为include\",{\"1\":{\"993\":1}}],[\"模板解析器\",{\"1\":{\"560\":1}}],[\"模板\",{\"1\":{\"560\":1}}],[\"模块导入\",{\"0\":{\"649\":1}}],[\"模块需要使用到\",{\"1\":{\"467\":1}}],[\"模块化机制提供了另一个级别的java代码可见性\",{\"1\":{\"461\":1}}],[\"模块名称随便起一个就可以\",{\"1\":{\"461\":2}}],[\"模块可以由一个或者多个在一起的\",{\"1\":{\"460\":1}}],[\"模块机制\",{\"0\":{\"457\":1,\"459\":1}}],[\"解压\",{\"1\":{\"1047\":1}}],[\"解读dispatcherservlet源码\",{\"0\":{\"624\":1}}],[\"解析bean配置等\",{\"1\":{\"1320\":1}}],[\"解析xml文件\",{\"0\":{\"819\":1}}],[\"解析成一个真正的\",{\"1\":{\"560\":1}}],[\"解析完成后\",{\"1\":{\"558\":1}}],[\"解析为一个真正的view\",{\"1\":{\"558\":1}}],[\"解决方案\",{\"0\":{\"12\":1}}],[\"项目正在启动\",{\"1\":{\"1278\":1,\"1328\":1}}],[\"项目模板选择web应用程序\",{\"1\":{\"1048\":1}}],[\"项目名称随便\",{\"1\":{\"1048\":1}}],[\"项目在打包时会将资源文件夹中文件一起打包的jar中\",{\"1\":{\"1017\":1}}],[\"项目在运行时\",{\"1\":{\"1016\":1}}],[\"项目运行成功\",{\"1\":{\"1008\":1}}],[\"项目标识\",{\"0\":{\"1003\":1}}],[\"项目使用到哪些依赖\",{\"1\":{\"1000\":1}}],[\"项目的自动构建\",{\"1\":{\"1000\":1}}],[\"项目的子项目\",{\"1\":{\"1000\":1}}],[\"项目\",{\"0\":{\"1048\":1},\"1\":{\"1000\":1}}],[\"项目进行构建\",{\"1\":{\"1000\":1}}],[\"项目环境搭建完成\",{\"1\":{\"652\":1}}],[\"项目里必须加\",{\"1\":{\"553\":1}}],[\"项目中代码量非常之大\",{\"1\":{\"437\":1}}],[\"光是一个页面中可能就包含了几十甚至上百个功能\",{\"1\":{\"540\":1}}],[\"帮你注入\",{\"1\":{\"534\":1}}],[\"帮你生成方法\",{\"1\":{\"534\":1}}],[\"改成我们自己的\",{\"1\":{\"1224\":1}}],[\"改成新的功能\",{\"1\":{\"1116\":1}}],[\"改\",{\"1\":{\"860\":1}}],[\"改写字节码\",{\"1\":{\"534\":1}}],[\"改进的\",{\"0\":{\"476\":1}}],[\"清理之前可能存在的遗留事务操作\",{\"1\":{\"1246\":1}}],[\"清除所有缓存\",{\"0\":{\"887\":1}}],[\"清除输入缓冲区的换行符\",{\"1\":{\"531\":1}}],[\"清空缓冲区\",{\"1\":{\"270\":1}}],[\"清空整个map\",{\"1\":{\"213\":1}}],[\"清空整个集合\",{\"1\":{\"180\":1}}],[\"块里的内容都会被执行\",{\"1\":{\"531\":1}}],[\"遇到异常\",{\"1\":{\"531\":1}}],[\"遇到\",{\"1\":{\"531\":1}}],[\"遇到过这种问题的扣个1吧\",{\"1\":{\"500\":1}}],[\"里要启用文件上传\",{\"1\":{\"619\":1}}],[\"里一般不用加\",{\"1\":{\"553\":1}}],[\"里是正常结束\",{\"1\":{\"531\":1}}],[\"里面有许多\",{\"1\":{\"1058\":1}}],[\"里面的内依赖依然是直接继承\",{\"1\":{\"1033\":1}}],[\"里面的该咋写咋写\",{\"1\":{\"504\":1}}],[\"里面填写的就是所有的依赖\",{\"1\":{\"1008\":1}}],[\"里面条件为\",{\"1\":{\"228\":1}}],[\"换行符仍然留在输入缓冲区中\",{\"1\":{\"531\":1}}],[\"换句话说\",{\"1\":{\"508\":1}}],[\"较繁琐\",{\"1\":{\"528\":1}}],[\"便于链式调用\",{\"1\":{\"525\":1}}],[\"便于我们去使用的类\",{\"1\":{\"429\":1}}],[\"叫做\",{\"1\":{\"1175\":1}}],[\"叫做建造者模式\",{\"1\":{\"524\":1}}],[\"叫子类\",{\"1\":{\"369\":1}}],[\"建立切点\",{\"0\":{\"1219\":1}}],[\"建立数据库\",{\"0\":{\"662\":1}}],[\"建议使用之前的xml方式进行配置\",{\"1\":{\"901\":1}}],[\"建议选择方便打开的\",{\"1\":{\"619\":1}}],[\"建议在最后执行一次刷新操作\",{\"1\":{\"249\":1}}],[\"建议在finally中进行\",{\"1\":{\"247\":1}}],[\"建造者模式\",{\"0\":{\"524\":1}}],[\"王\",{\"1\":{\"518\":1}}],[\"王力宏\",{\"1\":{\"518\":1,\"519\":1,\"522\":1}}],[\"林俊杰\",{\"1\":{\"518\":1,\"519\":1,\"522\":1}}],[\"陶喆\",{\"1\":{\"518\":1,\"519\":1,\"522\":1}}],[\"周杰伦\",{\"1\":{\"518\":1,\"519\":1,\"522\":1}}],[\"另外\",{\"1\":{\"516\":1}}],[\"另一个事务也被回滚了\",{\"1\":{\"1281\":1}}],[\"另一个账号增款\",{\"1\":{\"1266\":1}}],[\"另一种表达\",{\"0\":{\"151\":1,\"154\":1}}],[\"另一种问题描述方法\",{\"0\":{\"105\":1}}],[\"另一些则频繁被访问\",{\"1\":{\"134\":1}}],[\"另一分布下\",{\"1\":{\"29\":1}}],[\"源码中\",{\"1\":{\"1059\":1}}],[\"源码中已经配置好了对应的\",{\"1\":{\"1059\":1}}],[\"源码分析\",{\"0\":{\"625\":1}}],[\"源码的话\",{\"1\":{\"516\":1}}],[\"源码定义\",{\"0\":{\"189\":1}}],[\"世界加油\",{\"1\":{\"515\":2}}],[\"武汉加油\",{\"1\":{\"515\":1}}],[\"终极版默认是已经捆绑安装的\",{\"1\":{\"958\":1}}],[\"终端操作会产生一个新的集合或值\",{\"1\":{\"515\":1}}],[\"终端操作结束后流无法再次使用\",{\"1\":{\"515\":1}}],[\"终端操作\",{\"1\":{\"515\":1}}],[\"终于是支持了\",{\"1\":{\"487\":1}}],[\"筛选filter\",{\"1\":{\"515\":1}}],[\"惰性求值\",{\"1\":{\"514\":1}}],[\"执行顺序分析\",{\"0\":{\"1308\":1}}],[\"执行器\",{\"1\":{\"1242\":1}}],[\"执行后\",{\"1\":{\"1220\":1}}],[\"执行后会清理整个target文件夹\",{\"1\":{\"1034\":1}}],[\"执行测试实际上也会对类进行实例化\",{\"1\":{\"986\":1}}],[\"执行批处理操作\",{\"0\":{\"798\":1}}],[\"执行dql操作会返回一个resultset对象\",{\"1\":{\"797\":1}}],[\"执行dql操作\",{\"0\":{\"797\":1}}],[\"执行dml操作\",{\"0\":{\"796\":1}}],[\"执行sql语句\",{\"1\":{\"788\":1}}],[\"执行successfulauthentication\",{\"1\":{\"711\":1}}],[\"执行登录操作\",{\"1\":{\"714\":1}}],[\"执行登出操作\",{\"1\":{\"714\":1}}],[\"执行的难道不是内部其他filter的dofilter方法吗\",{\"1\":{\"710\":1}}],[\"执行的数据库查询\",{\"1\":{\"513\":1}}],[\"执行如果成功\",{\"1\":{\"710\":1}}],[\"执行内部过滤器的dofilter方法\",{\"1\":{\"710\":1}}],[\"执行了\",{\"1\":{\"697\":1}}],[\"执行任意操作\",{\"1\":{\"642\":1}}],[\"执行非法操作\",{\"1\":{\"641\":1}}],[\"执行所有拦截器的posthandle\",{\"1\":{\"626\":1}}],[\"执行所有拦截器的prehandle\",{\"1\":{\"626\":1}}],[\"执行结果为\",{\"1\":{\"1188\":1}}],[\"执行结果\",{\"0\":{\"597\":1}}],[\"执行一个延时任务\",{\"1\":{\"323\":1}}],[\"形成一个处理器执行链\",{\"1\":{\"625\":1}}],[\"形成一个新的consumer\",{\"1\":{\"511\":1}}],[\"形式来声明\",{\"1\":{\"364\":1}}],[\"形式下的贝尔曼最优公式\",{\"1\":{\"119\":1}}],[\"链式操作\",{\"1\":{\"511\":1}}],[\"杂项\",{\"0\":{\"721\":1}}],[\"杂\",{\"0\":{\"507\":1,\"629\":1}}],[\"保留意见\",{\"1\":{\"514\":1}}],[\"保存的是一些不可变数据\",{\"1\":{\"501\":1}}],[\"保证这些事务之间不会互相干扰\",{\"1\":{\"1267\":1}}],[\"保证了数据的可靠传输\",{\"1\":{\"1042\":1}}],[\"保证每一种情况都正常执行\",{\"1\":{\"991\":1}}],[\"保证在传输过程中的安全性\",{\"1\":{\"356\":1}}],[\"保证两个线程执行完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"保证数据的安全性\",{\"1\":{\"311\":1}}],[\"保证当两个对象通过\",{\"1\":{\"241\":1}}],[\"保证\",{\"1\":{\"98\":2}}],[\"保证选取最大的\",{\"1\":{\"57\":1}}],[\"经过上面操作之后\",{\"1\":{\"1246\":1}}],[\"经过之前的操作\",{\"1\":{\"1246\":1}}],[\"经过前面的学习\",{\"1\":{\"951\":1}}],[\"经过我们之前的分析\",{\"1\":{\"708\":1}}],[\"经常遇到空指针异常\",{\"1\":{\"500\":1}}],[\"经验回放\",{\"0\":{\"143\":1}}],[\"文档\",{\"1\":{\"1113\":1}}],[\"文档类型定义\",{\"1\":{\"824\":1}}],[\"文档网站\",{\"1\":{\"824\":1}}],[\"文本块表达式在java\",{\"1\":{\"498\":1}}],[\"文本块\",{\"0\":{\"498\":1}}],[\"文件仍然存在\",{\"1\":{\"1266\":1}}],[\"文件中的的配置\",{\"1\":{\"1196\":1}}],[\"文件夹写\",{\"1\":{\"1071\":1}}],[\"文件夹里的\",{\"1\":{\"705\":1}}],[\"文件下载\",{\"0\":{\"620\":1}}],[\"文件就会上传到服务器了\",{\"1\":{\"619\":1}}],[\"文件上传成功\",{\"1\":{\"619\":1,\"1075\":1}}],[\"文件上传\",{\"0\":{\"619\":1}}],[\"文件其实就是我们编写的一个类\",{\"1\":{\"275\":1}}],[\"文件丢给\",{\"1\":{\"275\":1}}],[\"文件字符流\",{\"0\":{\"252\":1}}],[\"文件字节流\",{\"0\":{\"246\":1}}],[\"文件拷贝操作实现\",{\"0\":{\"251\":1}}],[\"文件读取\",{\"0\":{\"248\":1}}],[\"传输文件\",{\"0\":{\"726\":1}}],[\"传统\",{\"1\":{\"553\":1}}],[\"传统xml配置形式\",{\"0\":{\"543\":1}}],[\"传统的获取连接的方式\",{\"1\":{\"1244\":1}}],[\"传统的\",{\"1\":{\"497\":1}}],[\"传递的参数都是一样的不会被上一个影响\",{\"1\":{\"511\":1}}],[\"传入当前对象本身作为filter\",{\"1\":{\"710\":1}}],[\"传入分数\",{\"1\":{\"495\":1}}],[\"传入的string对象可能为null\",{\"1\":{\"480\":1}}],[\"传入的如果是对象\",{\"1\":{\"312\":1}}],[\"传入fileinputstream\",{\"1\":{\"262\":1}}],[\"详细信息我们可以在level类中查看\",{\"1\":{\"910\":1}}],[\"详细的sql语句构建器语法文档\",{\"1\":{\"902\":1}}],[\"详细了解一下如何向spring注册bean以及bean的相关配置\",{\"1\":{\"1124\":1}}],[\"详细了解\",{\"1\":{\"873\":1}}],[\"详细规则\",{\"0\":{\"497\":1}}],[\"详细过程就不介绍了\",{\"1\":{\"217\":1}}],[\"貌似还是和之前是一样的\",{\"1\":{\"496\":1}}],[\"貌似和之前没啥区别\",{\"1\":{\"461\":1}}],[\"寄\",{\"1\":{\"495\":1}}],[\"及以上\",{\"1\":{\"528\":2}}],[\"及格\",{\"1\":{\"495\":2,\"496\":1}}],[\"及其子类异常\",{\"1\":{\"604\":1}}],[\"及其子类\",{\"1\":{\"245\":2}}],[\"范围在\",{\"1\":{\"746\":3}}],[\"范围\",{\"1\":{\"495\":1}}],[\"知道图片在哪里直接字符串截取\",{\"1\":{\"490\":1}}],[\"局部变量类型推断\",{\"0\":{\"485\":1}}],[\"局部内部类直接使用类名就行\",{\"1\":{\"410\":1}}],[\"局部内部类名\",{\"1\":{\"410\":1}}],[\"局部内部类就像局部变量一样\",{\"1\":{\"410\":1}}],[\"局部内部类\",{\"0\":{\"410\":1}}],[\"却还是要我们自己填类型\",{\"1\":{\"480\":1}}],[\"单位依然是毫秒\",{\"1\":{\"1190\":1}}],[\"单位秒\",{\"1\":{\"1092\":1}}],[\"单例bean对象的获取\",{\"1\":{\"1301\":1}}],[\"单例bean的创建与循环依赖\",{\"0\":{\"1299\":1}}],[\"单例\",{\"0\":{\"1171\":1},\"1\":{\"1181\":1}}],[\"单例模式下\",{\"1\":{\"1129\":1}}],[\"单元测试\",{\"0\":{\"956\":1}}],[\"单独创建一个bean\",{\"1\":{\"1259\":1}}],[\"单独配置其他属性\",{\"0\":{\"1150\":1}}],[\"单独配置取消二级缓存\",{\"0\":{\"886\":1}}],[\"单独丢进try中\",{\"1\":{\"480\":1}}],[\"单表查询是最简单的一种查询\",{\"1\":{\"762\":1}}],[\"单表查询\",{\"0\":{\"762\":1}}],[\"单走\",{\"1\":{\"223\":4}}],[\"参照\",{\"1\":{\"747\":1}}],[\"参考一下\",{\"1\":{\"478\":1}}],[\"参数列表\",{\"1\":{\"1234\":1}}],[\"参数化测试\",{\"0\":{\"991\":1}}],[\"参数化类型中可以获取到泛型在定义过程中的参数类型\",{\"1\":{\"343\":1}}],[\"参数也可以是字符串类型的\",{\"1\":{\"831\":1}}],[\"参数的值会自动传递给形式参数\",{\"1\":{\"579\":1}}],[\"参数\",{\"0\":{\"1234\":1},\"1\":{\"512\":1}}],[\"参数一样\",{\"1\":{\"415\":1}}],[\"参数直接写成lambda表达式\",{\"1\":{\"414\":1}}],[\"参数名称要与实体类参数对应\",{\"1\":{\"861\":1}}],[\"参数名称\",{\"1\":{\"398\":1,\"414\":1,\"447\":1}}],[\"参数类型\",{\"1\":{\"398\":1,\"414\":1,\"447\":1}}],[\"参数类型可能会多种多样\",{\"1\":{\"165\":1}}],[\"参数上\",{\"1\":{\"360\":1}}],[\"好处是idea更新后不需要重新配置\",{\"1\":{\"1010\":1}}],[\"好了\",{\"1\":{\"490\":2}}],[\"好耶\",{\"1\":{\"475\":1}}],[\"好比说一个银行\",{\"1\":{\"311\":1}}],[\"开发的开源项目\",{\"1\":{\"1000\":1}}],[\"开源数据库\",{\"1\":{\"732\":1}}],[\"开启aop注解支持\",{\"1\":{\"1232\":1}}],[\"开启懒加载后\",{\"1\":{\"1130\":1}}],[\"开启此选项后\",{\"1\":{\"887\":1}}],[\"开启二级缓存后\",{\"1\":{\"884\":1}}],[\"开启批处理后\",{\"1\":{\"871\":1}}],[\"开启时把之前的事务模式下的内容给提交了\",{\"1\":{\"806\":1}}],[\"开启事务只有当commit后才能在真正的数据库里看到\",{\"1\":{\"782\":1}}],[\"开启方法安全校验\",{\"1\":{\"695\":1}}],[\"开启websecurity相关功能\",{\"1\":{\"651\":1}}],[\"开启默认的servlet\",{\"1\":{\"564\":1}}],[\"开启反射\",{\"0\":{\"466\":1}}],[\"开始扫描后\",{\"1\":{\"1327\":1}}],[\"开始扫描\",{\"1\":{\"1327\":1}}],[\"开始初始化所有bean\",{\"1\":{\"1321\":1}}],[\"开始之前先给大家提个问题\",{\"1\":{\"1301\":1}}],[\"开始之前记得先清理一下两个浏览器的缓存\",{\"1\":{\"642\":1}}],[\"开始\",{\"1\":{\"1188\":2}}],[\"开始事务\",{\"1\":{\"782\":1}}],[\"开始支持\",{\"1\":{\"361\":2,\"362\":1}}],[\"开始唤醒\",{\"1\":{\"318\":1}}],[\"开始等待\",{\"1\":{\"318\":1}}],[\"岁\",{\"1\":{\"464\":1}}],[\"岁了\",{\"1\":{\"162\":1}}],[\"例子如下\",{\"1\":{\"1231\":1}}],[\"例子\",{\"0\":{\"464\":1,\"1218\":1,\"1275\":1}}],[\"例如拼接时要确保不能忘记添加必要的空格\",{\"1\":{\"872\":1}}],[\"例如将成绩在平均成绩之上的元组定义成一个视图good\",{\"1\":{\"779\":1}}],[\"例如application\",{\"1\":{\"577\":1}}],[\"例如\",{\"1\":{\"403\":8,\"1000\":1,\"1016\":1}}],[\"例如当向printstream流中写入一个字节数组后自动调用flush\",{\"1\":{\"284\":1}}],[\"全注解配置\",{\"0\":{\"1258\":1}}],[\"全注解配置形式\",{\"0\":{\"550\":1}}],[\"全都改成d\",{\"1\":{\"1116\":1}}],[\"全true\",{\"1\":{\"930\":1}}],[\"全称为超文本传输协议\",{\"1\":{\"727\":1}}],[\"全局定义初始化参数\",{\"0\":{\"1086\":1}}],[\"全局存储通信\",{\"0\":{\"1084\":1}}],[\"全局数据绑定\",{\"1\":{\"603\":1}}],[\"全局数据预处理\",{\"1\":{\"602\":1,\"603\":1}}],[\"全局控制器增强\",{\"1\":{\"603\":1}}],[\"全新的httpclient使用\",{\"0\":{\"489\":1}}],[\"全新的模块机制\",{\"1\":{\"458\":1}}],[\"全部交给程序来管理\",{\"1\":{\"1116\":1}}],[\"全部不再需要\",{\"1\":{\"446\":1}}],[\"全部拷贝为一个新的对象\",{\"1\":{\"377\":1}}],[\"于是\",{\"1\":{\"453\":1,\"460\":1}}],[\"举例\",{\"0\":{\"449\":1,\"896\":1}}],[\"间接说明编译之后lambda并不是以匿名内部类的形式存在的\",{\"1\":{\"446\":1}}],[\"间隔多久继续执行\",{\"1\":{\"1190\":1}}],[\"间隔1秒\",{\"1\":{\"319\":1}}],[\"间隔2秒\",{\"1\":{\"319\":1}}],[\"率\",{\"1\":{\"437\":1}}],[\"良好\",{\"1\":{\"437\":1,\"495\":2,\"496\":1}}],[\"课程成绩\",{\"1\":{\"437\":1}}],[\"课程号\",{\"1\":{\"437\":1}}],[\"永远都不会被捕获\",{\"1\":{\"424\":2}}],[\"捕获所有\",{\"1\":{\"604\":1}}],[\"捕获到异常\",{\"1\":{\"424\":1}}],[\"捕获异常\",{\"1\":{\"421\":1}}],[\"抛开事实不谈\",{\"1\":{\"1023\":1}}],[\"抛出\",{\"1\":{\"528\":1}}],[\"抛出异常后\",{\"1\":{\"1220\":1}}],[\"抛出异常\",{\"0\":{\"423\":1},\"1\":{\"512\":1}}],[\"抛给上一级\",{\"1\":{\"424\":1}}],[\"明确会抛出ioexception\",{\"1\":{\"424\":1}}],[\"处理所有的bean定义\",{\"1\":{\"1327\":1}}],[\"处理异步方法调用\",{\"1\":{\"1188\":1}}],[\"处理后\",{\"1\":{\"1103\":2}}],[\"处理首页或是登录界面跳转\",{\"1\":{\"636\":1}}],[\"处理登录操作并跳转\",{\"1\":{\"636\":1}}],[\"处理前和处理后\",{\"1\":{\"597\":1}}],[\"处理请求\",{\"1\":{\"541\":1}}],[\"处理\",{\"1\":{\"424\":1}}],[\"处理单位\",{\"1\":{\"245\":3}}],[\"给到我的一定是一个可以正常使用的实现类\",{\"1\":{\"1117\":1}}],[\"给http响应添加一些header属性\",{\"1\":{\"714\":1}}],[\"给\",{\"1\":{\"424\":1}}],[\"给定的策略\",{\"1\":{\"154\":1}}],[\"给定策略\",{\"1\":{\"113\":1}}],[\"函数\",{\"1\":{\"1056\":1}}],[\"函数和存储过程并没有包含在我们的教程当中\",{\"1\":{\"782\":1}}],[\"函数调用方必须要对抛出的这个异常进行对应的处理才可以\",{\"1\":{\"423\":1}}],[\"函数的\",{\"0\":{\"399\":1}}],[\"算数运算\",{\"1\":{\"1204\":1}}],[\"算术异常等\",{\"1\":{\"421\":1}}],[\"算法是用来解决\",{\"1\":{\"119\":1}}],[\"算法是用来求解一个\",{\"1\":{\"113\":1}}],[\"算法如下来进行估计\",{\"1\":{\"116\":1}}],[\"算法同样是来求解\",{\"1\":{\"115\":1}}],[\"算法其目的是用于直接估计\",{\"1\":{\"115\":1}}],[\"算法分析\",{\"0\":{\"113\":1}}],[\"算法所需的数据\",{\"1\":{\"112\":1}}],[\"算法为\",{\"1\":{\"110\":1}}],[\"算法进行求解\",{\"1\":{\"110\":1}}],[\"算法进行求解g\",{\"1\":{\"104\":1}}],[\"算法\",{\"0\":{\"114\":1,\"157\":1},\"1\":{\"104\":2,\"105\":1,\"136\":1}}],[\"算法来进行求解\",{\"1\":{\"99\":1}}],[\"算法就可以用来求解当\",{\"1\":{\"97\":1}}],[\"算法介绍\",{\"0\":{\"97\":1}}],[\"算法流程\",{\"0\":{\"89\":1}}],[\"算法中\",{\"0\":{\"88\":1},\"1\":{\"138\":1}}],[\"算法的统一形式和总结\",{\"0\":{\"127\":1}}],[\"算法的比较\",{\"0\":{\"114\":1}}],[\"算法的问题描述中\",{\"1\":{\"105\":1}}],[\"算法的核心是\",{\"1\":{\"77\":1}}],[\"算法的基础上\",{\"1\":{\"23\":1}}],[\"算法思路\",{\"0\":{\"77\":1}}],[\"算法比较\",{\"0\":{\"70\":1}}],[\"算法描述\",{\"0\":{\"66\":1,\"112\":1}}],[\"算法迭代示意图\",{\"1\":{\"65\":1}}],[\"算法1\",{\"1\":{\"13\":1}}],[\"空数组\",{\"1\":{\"992\":1}}],[\"空值\",{\"0\":{\"992\":1},\"1\":{\"747\":1}}],[\"空指针异常的改进\",{\"0\":{\"500\":1}}],[\"空指针异常\",{\"1\":{\"421\":1}}],[\"空集合等\",{\"1\":{\"992\":1}}],[\"空集合\",{\"0\":{\"236\":1}}],[\"卡布奇诺今犹在\",{\"1\":{\"415\":1}}],[\"待实现的求和方法\",{\"1\":{\"415\":1}}],[\"今天学会了\",{\"1\":{\"414\":5}}],[\"今年\",{\"1\":{\"162\":1}}],[\"匿名类只能访问其父类的属性或方法\",{\"1\":{\"412\":1}}],[\"匿名对象通常不能直接给属性赋值\",{\"1\":{\"412\":1}}],[\"匿名对象的类是在创建时匿名生成的\",{\"1\":{\"412\":1}}],[\"匿名对象本身不能定义新的属性\",{\"1\":{\"412\":1}}],[\"匿名内部类是没办法使用钻石运算符进行自动类型推断的\",{\"1\":{\"480\":1}}],[\"匿名内部类是我们使用频率非常高的一种内部类\",{\"1\":{\"412\":1}}],[\"匿名内部类会在编译时创建一个单独的class文件\",{\"1\":{\"446\":1}}],[\"匿名内部类特性\",{\"0\":{\"413\":1}}],[\"匿名内部类中同样可以使用类中的属性\",{\"1\":{\"412\":1}}],[\"匿名内部类\",{\"0\":{\"412\":1,\"445\":1},\"1\":{\"413\":1}}],[\"匿名内部类在java8无法使用钻石运算符\",{\"1\":{\"182\":1}}],[\"把唯一有用的connection对象拿出来\",{\"1\":{\"1247\":1}}],[\"把我们要做的任务写成方法\",{\"1\":{\"1190\":1}}],[\"把复杂系统分解成相互合作的对象\",{\"1\":{\"1115\":1}}],[\"把web容器丢进servletcontext\",{\"1\":{\"625\":1}}],[\"把实体数据对象和前端页面都给到thymeleaf\",{\"1\":{\"541\":1}}],[\"把一个流中的元素转化成新的流中的元素\",{\"1\":{\"519\":1}}],[\"把图片取到\",{\"1\":{\"490\":1}}],[\"把图片的地址提取出来\",{\"1\":{\"490\":1}}],[\"把未实现的方法实现了\",{\"1\":{\"412\":1}}],[\"把对象的属性和方法结合成一个独立的整体\",{\"1\":{\"369\":1}}],[\"套娃\",{\"1\":{\"1321\":1}}],[\"套娃开始了\",{\"1\":{\"1300\":1}}],[\"套娃很正常\",{\"1\":{\"706\":1}}],[\"套娃了属于是\",{\"1\":{\"408\":1}}],[\"套壳实现的\",{\"1\":{\"224\":1}}],[\"属性继承\",{\"0\":{\"1149\":1}}],[\"属性可以被设置为\",{\"1\":{\"884\":1}}],[\"属性则是通过反射进行赋值\",{\"1\":{\"841\":1}}],[\"属性的值由单引号或双引号包括\",{\"1\":{\"817\":1}}],[\"属性取值可以有一定的约束\",{\"1\":{\"733\":1}}],[\"属性不可再分\",{\"1\":{\"733\":1}}],[\"属性具有以下特点\",{\"1\":{\"733\":1}}],[\"属性\",{\"0\":{\"572\":1,\"574\":1,\"576\":1,\"580\":1,\"1016\":1,\"1064\":1,\"1092\":1,\"1127\":1,\"1137\":1}}],[\"属性默认就是这个值\",{\"1\":{\"166\":1}}],[\"属于\",{\"0\":{\"408\":1,\"409\":1},\"1\":{\"406\":2}}],[\"非池化的数据源实现依然使用的是传统的连接创建方式\",{\"1\":{\"1244\":1}}],[\"非空\",{\"1\":{\"747\":1}}],[\"非空白符\",{\"1\":{\"403\":1}}],[\"非正常情况\",{\"1\":{\"707\":1}}],[\"非法转账等\",{\"1\":{\"641\":1}}],[\"非指定的模块即使导入也无法使用\",{\"1\":{\"464\":1}}],[\"非静态方法作为方法引用\",{\"0\":{\"450\":1}}],[\"非常简单\",{\"1\":{\"1054\":1,\"1257\":1,\"1260\":1}}],[\"非常难以阅读\",{\"1\":{\"920\":1}}],[\"非常智能\",{\"1\":{\"861\":1}}],[\"非常鸡肋\",{\"1\":{\"835\":1}}],[\"非常耗时\",{\"1\":{\"295\":1}}],[\"非常方便\",{\"1\":{\"182\":1,\"587\":1,\"610\":1}}],[\"^\",{\"1\":{\"403\":1}}],[\"^aeiou\",{\"1\":{\"403\":1}}],[\"^abc\",{\"1\":{\"403\":1}}],[\"请务必记在你的脑海\",{\"1\":{\"1271\":1}}],[\"请一定注意\",{\"1\":{\"1257\":1}}],[\"请前往\",{\"1\":{\"1211\":1}}],[\"请注意\",{\"1\":{\"1181\":1}}],[\"请注意在逗号和两个数之间不能有空格\",{\"1\":{\"403\":1}}],[\"请验证您的用户名或密码\",{\"1\":{\"1072\":1}}],[\"请参阅显示名称生成优先级规则\",{\"1\":{\"987\":1}}],[\"请输入要发送给服务端的内容\",{\"1\":{\"720\":1}}],[\"请检查原密码是否正确\",{\"1\":{\"666\":1}}],[\"请各位一定要耐心\",{\"1\":{\"626\":1}}],[\"请求头中会携带这些信息\",{\"1\":{\"1090\":1}}],[\"请求地址为当前地址+\",{\"1\":{\"1069\":1}}],[\"请求结束后bean也消失\",{\"1\":{\"588\":1}}],[\"请求转发只能转发给内部的servlet\",{\"1\":{\"1083\":1}}],[\"请求转发可以共享请求参数\",{\"1\":{\"1083\":1}}],[\"请求转发可以携带数据\",{\"1\":{\"1083\":2}}],[\"请求转发地址栏不会发生改变\",{\"1\":{\"1083\":1}}],[\"请求转发是一次请求\",{\"1\":{\"1083\":1}}],[\"请求转发其实是一种服务器内部的跳转机制\",{\"1\":{\"1083\":1}}],[\"请求转发\",{\"0\":{\"1083\":1},\"1\":{\"587\":1}}],[\"请求参数会自动根据类中的字段名称进行匹配\",{\"1\":{\"583\":1}}],[\"请求参数username不允许为test\",{\"1\":{\"574\":1}}],[\"请求返回时\",{\"1\":{\"560\":1}}],[\"请调用方处理好\",{\"1\":{\"423\":1}}],[\"请将配置文件的编码格式切换成utf\",{\"1\":{\"1199\":1}}],[\"请将\",{\"1\":{\"355\":1}}],[\"至此\",{\"1\":{\"652\":1,\"684\":1,\"699\":1,\"1136\":1,\"1291\":1}}],[\"至于这是怎么做到的的\",{\"1\":{\"549\":1}}],[\"至于为什么默认是0\",{\"1\":{\"217\":1}}],[\"至于为什么要这样设计\",{\"1\":{\"188\":1}}],[\"至少匹配n\",{\"1\":{\"403\":1}}],[\"匹配名称为a的teacher类型的bean\",{\"1\":{\"1174\":1}}],[\"匹配路径\",{\"1\":{\"552\":1}}],[\"匹配find\",{\"1\":{\"515\":1}}],[\"匹配值可以存在多个\",{\"1\":{\"497\":1}}],[\"匹配值\",{\"1\":{\"497\":3}}],[\"匹配字母\",{\"1\":{\"403\":1}}],[\"匹配字符串\",{\"1\":{\"403\":2}}],[\"匹配所有\",{\"1\":{\"403\":1}}],[\"匹配所有大写字母\",{\"1\":{\"403\":1}}],[\"匹配除换行符\",{\"1\":{\"403\":1}}],[\"匹配除了\",{\"1\":{\"403\":1}}],[\"匹配\",{\"0\":{\"520\":1},\"1\":{\"403\":1}}],[\"匹配确定的\",{\"1\":{\"403\":1}}],[\"匹配前面的子表达式零次或一次\",{\"1\":{\"403\":1}}],[\"匹配前面的子表达式零次或多次\",{\"1\":{\"403\":1}}],[\"匹配前面的子表达式一次或多次\",{\"1\":{\"403\":1}}],[\"匹配成功返回true\",{\"1\":{\"403\":1}}],[\"描述\",{\"1\":{\"403\":2}}],[\"描述了一种字符串匹配的模式\",{\"1\":{\"403\":1}}],[\"描述如下\",{\"1\":{\"13\":1}}],[\"汉堡\",{\"1\":{\"402\":2}}],[\"汉堡做滴彳亍不彳亍\",{\"1\":{\"270\":1}}],[\"弥补了字符串不能修改的不足\",{\"1\":{\"402\":1}}],[\"裁剪等操作\",{\"1\":{\"402\":1}}],[\"哥们在这跟你说唱\",{\"1\":{\"398\":1}}],[\"哥们这瓜多少钱一斤\",{\"1\":{\"356\":2}}],[\"答案是可以的\",{\"1\":{\"397\":1}}],[\"允许先暴露一个\",{\"1\":{\"1181\":1}}],[\"允许请求通过\",{\"0\":{\"1103\":1}}],[\"允许便捷式访问底层数据库\",{\"1\":{\"787\":1}}],[\"允许列中的某些行没有值\",{\"1\":{\"747\":1}}],[\"允许用户继续进行其他操作\",{\"1\":{\"617\":1}}],[\"允许包含\",{\"1\":{\"528\":1}}],[\"允许传递为\",{\"1\":{\"512\":1}}],[\"允许\",{\"1\":{\"396\":1}}],[\"允许在任何地方被访问\",{\"1\":{\"278\":1}}],[\"肯定是可以的\",{\"1\":{\"1177\":1}}],[\"肯定是继承自object的\",{\"1\":{\"392\":1}}],[\"肯定的啊\",{\"1\":{\"172\":1}}],[\"面向对象高级篇\",{\"0\":{\"390\":1,\"419\":1,\"429\":1}}],[\"面向对象高级篇1\",{\"0\":{\"382\":1}}],[\"精确到小数点后100位\",{\"1\":{\"386\":1}}],[\"浮点类型精度有限\",{\"1\":{\"386\":1}}],[\"乘法\",{\"1\":{\"386\":1}}],[\"轻轻松松\",{\"1\":{\"386\":1}}],[\"轻松地就实现了\",{\"1\":{\"224\":1}}],[\"特定的方法来生成参数\",{\"0\":{\"994\":1}}],[\"特点\",{\"0\":{\"514\":1},\"1\":{\"603\":1,\"604\":1}}],[\"特性\",{\"0\":{\"395\":1},\"1\":{\"528\":1}}],[\"特殊包装类\",{\"0\":{\"386\":1}}],[\"特别注意一下\",{\"1\":{\"182\":1}}],[\"覆盖原有构造方法\",{\"1\":{\"378\":1}}],[\"覆盖之后\",{\"1\":{\"216\":1}}],[\"枚举值\",{\"0\":{\"993\":1}}],[\"枚举\",{\"1\":{\"501\":1}}],[\"枚举的成员变量\",{\"1\":{\"378\":1}}],[\"枚举类型是普通的类\",{\"1\":{\"378\":1}}],[\"枚举类型使用起来就非常方便了\",{\"1\":{\"378\":1}}],[\"枚举类的语法稍微有一些不一样\",{\"1\":{\"378\":1}}],[\"枚举类\",{\"0\":{\"378\":1}}],[\"睡觉\",{\"1\":{\"378\":2}}],[\"睡觉这三个之中的其中一种\",{\"1\":{\"378\":1}}],[\"学rust以后进大厂\",{\"1\":{\"1224\":1}}],[\"学什么\",{\"1\":{\"1223\":1}}],[\"学号为\",{\"1\":{\"799\":1}}],[\"学号发生改变就代表学生发生改变\",{\"1\":{\"737\":1}}],[\"学号是每个学生的唯一标识\",{\"1\":{\"737\":1}}],[\"学号\",{\"1\":{\"733\":1,\"734\":2,\"737\":1}}],[\"学习了spring之后\",{\"1\":{\"1241\":1}}],[\"学习资料\",{\"1\":{\"1018\":1}}],[\"学习和使用xml只是为了更好地去认识mybatis的工作原理\",{\"1\":{\"819\":1}}],[\"学习厉害的框架或是厉害的技术\",{\"1\":{\"816\":1}}],[\"学习\",{\"1\":{\"378\":2}}],[\"学生学号\",{\"1\":{\"738\":2}}],[\"学生借书情况\",{\"1\":{\"738\":2}}],[\"学生表\",{\"1\":{\"734\":1}}],[\"学生\",{\"1\":{\"376\":1,\"377\":1,\"734\":1,\"736\":2,\"737\":1}}],[\"学生和老师来说\",{\"1\":{\"376\":1}}],[\"深拷贝会将引用类型的所有内容\",{\"1\":{\"377\":1}}],[\"深拷贝\",{\"1\":{\"377\":1}}],[\"浅拷贝\",{\"1\":{\"377\":1}}],[\"克隆实现\",{\"1\":{\"377\":1}}],[\"克隆操作可以完全复制一个对象的所有属性\",{\"1\":{\"377\":1}}],[\"克隆出来的与原来的对象不是一个对象\",{\"1\":{\"377\":1}}],[\"克隆方法\",{\"0\":{\"377\":1}}],[\"克隆当前对象\",{\"1\":{\"372\":1}}],[\"顶多说是多继承的一种替代方案\",{\"1\":{\"376\":1}}],[\"逗号\",{\"1\":{\"376\":1}}],[\"甚至多个对象之间也会出现这种情况\",{\"1\":{\"1301\":1}}],[\"甚至直接没有重新构造对象\",{\"1\":{\"883\":1}}],[\"甚至直接发送到他的后台\",{\"1\":{\"643\":1}}],[\"甚至当字段变得很多时\",{\"1\":{\"810\":1}}],[\"甚至控制用户的账号\",{\"1\":{\"643\":1}}],[\"甚至获取他人账户中的财产\",{\"1\":{\"641\":1}}],[\"甚至可以直接将httpsession也作为参数传递\",{\"1\":{\"582\":1}}],[\"甚至连名字都没有\",{\"1\":{\"412\":1}}],[\"甚至还可以继续去处理\",{\"1\":{\"1203\":1}}],[\"甚至还可以继续套娃一个成员内部类\",{\"1\":{\"408\":1}}],[\"甚至还可以查看当前的web应用程序有没有出现内存泄露\",{\"1\":{\"1047\":1}}],[\"甚至还能获取到泛型\",{\"1\":{\"336\":1}}],[\"甚至都不是一个类了\",{\"1\":{\"376\":1}}],[\"甚至都不是一个类\",{\"1\":{\"376\":1}}],[\"他不能学java\",{\"1\":{\"1224\":1}}],[\"他就是一个标识\",{\"1\":{\"1186\":1}}],[\"他能在编译时自动生成getter和setter\",{\"1\":{\"501\":1}}],[\"他只代表某个确切的功能\",{\"1\":{\"376\":1}}],[\"他们的区别如下\",{\"1\":{\"1190\":1}}],[\"他们两有些机制上的不同\",{\"1\":{\"1175\":1}}],[\"他们编写在conf目录下的web\",{\"1\":{\"1054\":1}}],[\"他们可以添加到类或是字段上\",{\"1\":{\"812\":1}}],[\"他们可能会做不同的事情\",{\"1\":{\"277\":1}}],[\"他们都是实现自userdetailsmanager接口\",{\"1\":{\"665\":1}}],[\"他们都继承自\",{\"1\":{\"421\":1}}],[\"他们都具有学习这个能力\",{\"1\":{\"376\":1}}],[\"他们其实都是异常类型\",{\"1\":{\"421\":1}}],[\"他们其实是需要配合synchronized来使用的\",{\"1\":{\"318\":1}}],[\"他们存储了方法的信息\",{\"1\":{\"349\":1}}],[\"抽象\",{\"0\":{\"1151\":1}}],[\"抽象成接口来进行使用\",{\"1\":{\"376\":1}}],[\"抽象方法的访问权限不能为\",{\"1\":{\"375\":1}}],[\"抽象方法是指\",{\"1\":{\"375\":1}}],[\"抽象方法\",{\"1\":{\"375\":2}}],[\"抽象类中可以具有抽象方法\",{\"1\":{\"375\":1}}],[\"抽象类的子类也可以是一个抽象类\",{\"1\":{\"375\":1}}],[\"抽象类的实现\",{\"1\":{\"343\":1}}],[\"抽象类一般只用作继承使用\",{\"1\":{\"375\":1}}],[\"抽象类具有\",{\"1\":{\"375\":1}}],[\"抽象类\",{\"0\":{\"375\":1},\"1\":{\"375\":1,\"439\":1,\"504\":1}}],[\"控制反转\",{\"1\":{\"1115\":1}}],[\"控制台会出现应该assertionfailederror错误\",{\"1\":{\"963\":1}}],[\"控制器处理完成之后\",{\"1\":{\"558\":1}}],[\"控制器就相当于servlet的基本功能\",{\"1\":{\"541\":1}}],[\"控制符\",{\"0\":{\"374\":1}}],[\"控制其一直待在target\",{\"1\":{\"19\":1}}],[\"做好准备\",{\"1\":{\"1300\":1}}],[\"做一些额外的操作\",{\"1\":{\"1215\":1}}],[\"做统一处理\",{\"1\":{\"603\":1}}],[\"做滴\",{\"1\":{\"402\":2}}],[\"做题我并不擅长\",{\"1\":{\"373\":1,\"375\":1}}],[\"做传输媒介\",{\"1\":{\"251\":1}}],[\"垃圾\",{\"1\":{\"372\":1}}],[\"完全实现全注解配置\",{\"1\":{\"1258\":1}}],[\"完全没有缓存机制可用\",{\"1\":{\"1181\":1}}],[\"完全不需要使用自带的csrf防护\",{\"1\":{\"660\":1}}],[\"完善了service方法\",{\"1\":{\"1059\":1}}],[\"完成\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"完成整个tcp通信\",{\"1\":{\"1042\":1}}],[\"完成整个过程\",{\"1\":{\"558\":1}}],[\"完成自我介绍需要执行的所有代码就在这个花括号中编写\",{\"1\":{\"162\":1}}],[\"完整类名\",{\"1\":{\"372\":1}}],[\"父项目如果还存在dependencies节点的话\",{\"1\":{\"1033\":1}}],[\"父类首先初始化内部维护的beanfactory对象\",{\"1\":{\"1318\":1}}],[\"父类的无参构造调用\",{\"1\":{\"1318\":1}}],[\"父类\",{\"1\":{\"504\":2,\"706\":1}}],[\"父类型在前\",{\"1\":{\"424\":1}}],[\"父类是\",{\"1\":{\"371\":1}}],[\"父加载器\",{\"1\":{\"355\":1}}],[\"隐藏实现细节\",{\"1\":{\"369\":1}}],[\"隐式加载\",{\"1\":{\"275\":1}}],[\"封装为sqlsession对象\",{\"1\":{\"1242\":1}}],[\"封装和安全性得到了改进\",{\"1\":{\"462\":1}}],[\"封装成一个类\",{\"1\":{\"384\":1}}],[\"封装\",{\"0\":{\"369\":1,\"370\":1},\"1\":{\"369\":2}}],[\"现将类上\",{\"1\":{\"1054\":1}}],[\"现为由\",{\"1\":{\"1000\":1}}],[\"现阶段作为初学者\",{\"1\":{\"365\":1}}],[\"现在理解起来就非常简单了\",{\"1\":{\"1326\":1}}],[\"现在流程就很清晰了\",{\"1\":{\"1320\":1}}],[\"现在配置类已经成功注册到ioc容器中了\",{\"1\":{\"1319\":1}}],[\"现在就可以拿到了\",{\"1\":{\"1296\":1}}],[\"现在就可以使用了\",{\"1\":{\"465\":1}}],[\"现在就非常方便了\",{\"1\":{\"1291\":1}}],[\"现在加锁的源码\",{\"1\":{\"1246\":1}}],[\"现在方法有一个string类型的参数\",{\"1\":{\"1223\":1}}],[\"现在有两个bean\",{\"1\":{\"1301\":1}}],[\"现在有两个类\",{\"1\":{\"1181\":1}}],[\"现在有一个请求携带了一个参数\",{\"1\":{\"625\":1}}],[\"现在有一个新的需求\",{\"1\":{\"172\":1}}],[\"现在最常用的方式\",{\"1\":{\"1177\":1}}],[\"现在需要studentfactory对象才可以获取到student\",{\"1\":{\"1159\":1}}],[\"现在需要再前端实时更新展示\",{\"1\":{\"617\":1}}],[\"现在改为artteacher\",{\"1\":{\"1133\":1}}],[\"现在来了一个其他的老师教学生\",{\"1\":{\"1132\":1}}],[\"现在来一个新的表\",{\"1\":{\"853\":1}}],[\"现在实现类变成了d\",{\"1\":{\"1117\":1}}],[\"现在已经离我们理想的页面越来越接近了\",{\"1\":{\"1093\":1}}],[\"现在一律通过http\",{\"1\":{\"1093\":1}}],[\"现在再次进行登陆操作\",{\"1\":{\"1083\":1}}],[\"现在再次打开管理页面\",{\"1\":{\"1047\":1}}],[\"现在重新启动服务器\",{\"1\":{\"1047\":1}}],[\"现在用的是junit5\",{\"1\":{\"958\":1}}],[\"现在由于logger没有配置任何handler处理器\",{\"1\":{\"918\":1}}],[\"现在默认就是使用的这个\",{\"1\":{\"918\":1}}],[\"现在执行以下操作\",{\"1\":{\"876\":1}}],[\"现在要求把下面所有用户都插入到数据库中\",{\"1\":{\"871\":1}}],[\"现在将变为我们手动提交\",{\"1\":{\"806\":4}}],[\"现在绕了一下\",{\"1\":{\"708\":1}}],[\"现在访问我们的网站\",{\"1\":{\"680\":1}}],[\"现在所有接口不需要任何验证了\",{\"1\":{\"658\":1}}],[\"现在所有的请求\",{\"1\":{\"558\":1}}],[\"现在的浏览器同样有着对应的保护机制\",{\"1\":{\"642\":1}}],[\"现在的问题就是\",{\"1\":{\"437\":1}}],[\"现在图片地址也可以批量拿到了\",{\"1\":{\"490\":1}}],[\"现在接口中可以存在私有方法了\",{\"1\":{\"474\":1}}],[\"现在main类中有一个刚好匹配的方法\",{\"1\":{\"452\":1}}],[\"现在只需要一个注解即可\",{\"1\":{\"896\":1}}],[\"现在只需要一个简短的lambda表达式即可\",{\"1\":{\"446\":1}}],[\"现在只会进行追加写入\",{\"1\":{\"250\":1}}],[\"现在我们根据上面的流程图\",{\"1\":{\"1301\":1}}],[\"现在我们将test2\",{\"1\":{\"1282\":1}}],[\"现在我们已经知道获取一个链接会直接进入到活跃列表中\",{\"1\":{\"1247\":1}}],[\"现在我们已经了解了如何注册和使用一个bean\",{\"1\":{\"1132\":1}}],[\"现在我们去修改一下我们的aop配置\",{\"1\":{\"1224\":1}}],[\"现在我们编写一个环绕方法\",{\"1\":{\"1224\":1}}],[\"现在我们修改一下student中study方法的参数\",{\"1\":{\"1223\":1}}],[\"现在我们使用annotationconfigapplicationcontext作为上下文实现\",{\"1\":{\"1166\":1}}],[\"现在我们使用var关键字来自动进行类型推断\",{\"1\":{\"485\":1}}],[\"现在我们的service类中一共存在两个事务\",{\"1\":{\"1281\":1}}],[\"现在我们的student类中是这样定义的\",{\"1\":{\"1135\":1}}],[\"现在我们的类中存在一些集合类\",{\"1\":{\"1207\":1}}],[\"现在我们的类中出现了一个比较特殊的类型\",{\"1\":{\"1136\":1}}],[\"现在我们的java代码中\",{\"1\":{\"1133\":1}}],[\"现在我们发起的所有请求\",{\"1\":{\"1102\":1}}],[\"现在我们发现\",{\"1\":{\"1055\":1}}],[\"现在我们给此servlet添加post请求处理\",{\"1\":{\"1083\":1}}],[\"现在我们再来总结一下一个bean的加载流程\",{\"1\":{\"1309\":1}}],[\"现在我们再运行服务器\",{\"1\":{\"1075\":1}}],[\"现在我们再次打印低于info级别的日志就可以正确得到结果了\",{\"1\":{\"912\":1}}],[\"现在我们点击登录按钮\",{\"1\":{\"1069\":1}}],[\"现在我们点击右上角的退出按钮就可以退出了\",{\"1\":{\"683\":1}}],[\"现在我们按照上面的提示\",{\"1\":{\"1047\":1}}],[\"现在我们创建一下测试用例\",{\"1\":{\"1017\":1}}],[\"现在我们也可以将其设置为jdk提供的日志框架\",{\"1\":{\"951\":1}}],[\"现在我们也可以手动修改它为simpleformatter类型\",{\"1\":{\"921\":1}}],[\"现在我们打印日志就可以出现想要的结果了\",{\"1\":{\"919\":1}}],[\"现在我们还是在mapper中添加一个对应的方法用于执行\",{\"1\":{\"895\":1}}],[\"现在我们只需要在main方法中这样写即可查询结果了\",{\"1\":{\"830\":1}}],[\"现在我们只需要通过一个对象就能完成数据库交互了\",{\"1\":{\"825\":1}}],[\"现在我们只需要构造一个http请求实体\",{\"1\":{\"490\":1}}],[\"现在我们执行的数据库操作日志会在控制台实时打印\",{\"1\":{\"789\":1}}],[\"现在我们可以断定\",{\"1\":{\"1242\":1}}],[\"现在我们可以让使用此项目作为依赖的项目不使用可选依赖\",{\"1\":{\"1026\":1}}],[\"现在我们可以直接通过sqlsession获取我们编写接口的实现类\",{\"1\":{\"842\":1}}],[\"现在我们可以到数据库中对这个用户的角色进行修改\",{\"1\":{\"692\":1}}],[\"现在我们可以来测试一下是否配置正确\",{\"1\":{\"549\":1}}],[\"现在我们需要创建一个public的无参无返回值方法\",{\"1\":{\"959\":1}}],[\"现在我们需要将所有的静态资源也给放行\",{\"1\":{\"681\":1}}],[\"现在我们需要一个参数为string返回值为string的实现\",{\"1\":{\"453\":1}}],[\"现在我们来看看是不是我们想的那样\",{\"1\":{\"1298\":1}}],[\"现在我们来学习一下spring提供的事务管理\",{\"1\":{\"1274\":1}}],[\"现在我们来修改一下servlet代码\",{\"1\":{\"1075\":1}}],[\"现在我们来编写一个测试用例看看依赖导入成功了没有\",{\"1\":{\"1008\":1}}],[\"现在我们来进行一个转换\",{\"1\":{\"799\":1}}],[\"现在我们来进行登录操作\",{\"1\":{\"642\":1}}],[\"现在我们来配置自定义的登录界面\",{\"1\":{\"680\":1}}],[\"现在我们在主方法中分别调用一下试试看\",{\"1\":{\"1188\":1}}],[\"现在我们在前端页面添加一个链接\",{\"1\":{\"1074\":1}}],[\"现在我们在浏览器中打开此页面\",{\"1\":{\"1058\":1}}],[\"现在我们在浏览器中访问index页面\",{\"1\":{\"596\":1}}],[\"现在我们在查询用户时\",{\"1\":{\"692\":1}}],[\"现在我们在数据库中创建一个自定义的用户表\",{\"1\":{\"668\":1}}],[\"现在我们如果直接使用浏览器访问此页面\",{\"1\":{\"572\":1}}],[\"现在我们访问\",{\"1\":{\"569\":1}}],[\"现在我们就完成了视图解析器的配置\",{\"1\":{\"560\":1}}],[\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了\",{\"1\":{\"799\":1}}],[\"现在我们就可以在我们想要进行权限校验的方法上添加注解了\",{\"1\":{\"695\":1}}],[\"现在我们就可以在main类中使用模块module\",{\"1\":{\"464\":1}}],[\"现在我们就可以把请求发送出去了\",{\"1\":{\"490\":1}}],[\"现在我们就可以对此类进行操作了\",{\"1\":{\"356\":1}}],[\"现在我们想要保证其10次都不会出现问题才算通过\",{\"1\":{\"990\":1}}],[\"现在我们想要使用switch来实现这个功能\",{\"1\":{\"495\":1}}],[\"现在我们想新建一个线程来做事情\",{\"1\":{\"446\":2}}],[\"现在我们想新建一个线程来搞事情\",{\"1\":{\"445\":1}}],[\"现在我们希望在调用前修改这个方法传入的参数值\",{\"1\":{\"1224\":1}}],[\"现在我们希望在方法执行前和执行后都加入各种各样的动作\",{\"1\":{\"1224\":1}}],[\"现在我们希望在这个方法执行完之后\",{\"1\":{\"1218\":1}}],[\"现在我们希望从list中获取那些满足我们条件的元素\",{\"1\":{\"1209\":1}}],[\"现在我们希望spring也这样做\",{\"1\":{\"1158\":1}}],[\"现在我们希望\",{\"1\":{\"1076\":1}}],[\"现在我们希望查询user时\",{\"1\":{\"849\":1}}],[\"现在我们希望创建两个角色\",{\"1\":{\"692\":1}}],[\"现在我们希望按照全新的模块化开发模式来进行开发\",{\"1\":{\"468\":1}}],[\"现在我们希望能够自己处理出现的问题\",{\"1\":{\"424\":1}}],[\"现在我们要实现一个方法\",{\"1\":{\"454\":1}}],[\"现在\",{\"1\":{\"356\":1,\"893\":1,\"1059\":1,\"1082\":1,\"1083\":1,\"1093\":1,\"1097\":1,\"1104\":1,\"1119\":1,\"1173\":1,\"1297\":1}}],[\"现在线程才是程序执行流的最小单元\",{\"1\":{\"295\":1}}],[\"现在是按字符进行读取\",{\"1\":{\"253\":1}}],[\"现在跳过的是一个字符\",{\"1\":{\"253\":1}}],[\"现在没有\",{\"1\":{\"172\":1}}],[\"丝毫get不到这玩意的用处\",{\"1\":{\"365\":1}}],[\"多种构造函数情况\",{\"0\":{\"1135\":1}}],[\"多模块下父项目存在一个packing打包类型标签\",{\"1\":{\"1038\":1}}],[\"多模块测试打包\",{\"0\":{\"1038\":1}}],[\"多模块\",{\"0\":{\"1030\":1,\"1033\":1}}],[\"多\",{\"0\":{\"855\":2}}],[\"多对一查询\",{\"0\":{\"855\":1}}],[\"多参数表示\",{\"0\":{\"843\":1}}],[\"多参数查询\",{\"0\":{\"834\":1}}],[\"多表查询会通过连接转换为单表查询\",{\"1\":{\"767\":1}}],[\"多表查询是同时查询的两个或两个以上的表\",{\"1\":{\"767\":1}}],[\"多表查询\",{\"0\":{\"767\":1}}],[\"多重条件连接查询\",{\"1\":{\"763\":1}}],[\"多用于表单提交数据或者url传参\",{\"1\":{\"602\":1}}],[\"多级拦截器\",{\"0\":{\"600\":1}}],[\"多维数组\",{\"0\":{\"397\":1},\"1\":{\"432\":1}}],[\"多个配置合并成一个再集体导入\",{\"1\":{\"1168\":1}}],[\"多个会话之间不相通\",{\"1\":{\"883\":1}}],[\"多个学生可以以数组的形式表示\",{\"1\":{\"610\":1}}],[\"多个子类使用逗号隔开\",{\"1\":{\"503\":1}}],[\"多个参数时需要\",{\"1\":{\"447\":1}}],[\"多个类型变量使用逗号隔开\",{\"1\":{\"438\":1}}],[\"多个异常使用逗号隔开\",{\"1\":{\"423\":1}}],[\"多个不同的对象对同一消息作出响应\",{\"1\":{\"369\":1}}],[\"多个值时就使用花括号括起来\",{\"1\":{\"364\":1}}],[\"多态\",{\"1\":{\"369\":1}}],[\"多线程4\",{\"0\":{\"328\":1}}],[\"多线程3\",{\"0\":{\"317\":1}}],[\"多线程下java内存管理\",{\"0\":{\"311\":1}}],[\"多线程2\",{\"0\":{\"309\":1}}],[\"多线程与反射4\",{\"0\":{\"327\":1}}],[\"多线程与反射3\",{\"0\":{\"316\":1}}],[\"多线程与反射2\",{\"0\":{\"308\":1}}],[\"多线程与反射1\",{\"0\":{\"293\":1}}],[\"多线程\",{\"0\":{\"294\":1}}],[\"元注解是作用于注解上的注解\",{\"1\":{\"362\":1}}],[\"元注解\",{\"0\":{\"362\":1}}],[\"元素中的\",{\"1\":{\"241\":1}}],[\"元素流在管道中经过\",{\"1\":{\"228\":1}}],[\"标签\",{\"0\":{\"861\":1,\"863\":1,\"873\":1,\"1133\":1,\"1134\":1}}],[\"标签中可以存在属性\",{\"1\":{\"817\":1}}],[\"标注下划线的属性\",{\"1\":{\"734\":1}}],[\"标注在方法上\",{\"1\":{\"604\":1}}],[\"标准的声明格式如下\",{\"1\":{\"504\":1}}],[\"标准格式为\",{\"1\":{\"414\":1,\"447\":1}}],[\"标识某注解可以在同一个声明上使用多次\",{\"1\":{\"362\":1}}],[\"标识这个注解怎么保存\",{\"1\":{\"362\":1}}],[\"标识一个匿名函数或函数式接口\",{\"1\":{\"361\":1}}],[\"标记依赖是否可选\",{\"1\":{\"1015\":1}}],[\"标记这个注解是继承于哪个注解类\",{\"1\":{\"362\":1}}],[\"标记这个注解应该是哪种\",{\"1\":{\"362\":1}}],[\"标记这些注解是否包含在用户文档中\",{\"1\":{\"362\":1}}],[\"标记过时方法\",{\"1\":{\"361\":1}}],[\"标记为native的方法是本地方法\",{\"1\":{\"372\":1}}],[\"标记为公共的内容\",{\"1\":{\"278\":1}}],[\"标记为受保护的内容可以能被类本身和同包中的其他类访问\",{\"1\":{\"278\":1}}],[\"标记为私有的内容无法被除当前类以外的任何位置访问\",{\"1\":{\"278\":1}}],[\"标记位置\",{\"1\":{\"265\":1}}],[\"指定事务管理器\",{\"1\":{\"1279\":1}}],[\"指定位置上\",{\"1\":{\"1215\":1}}],[\"指定装配\",{\"0\":{\"1174\":1}}],[\"指定参数列表\",{\"1\":{\"991\":1}}],[\"指定jdk版本范围\",{\"0\":{\"978\":1}}],[\"指定jdk版本\",{\"0\":{\"977\":1}}],[\"指定操作系统\",{\"0\":{\"976\":1}}],[\"指定构造方法后\",{\"1\":{\"841\":1}}],[\"指定构造方法\",{\"0\":{\"841\":1,\"900\":1}}],[\"指定查询某一列数据\",{\"1\":{\"762\":1}}],[\"指定返回的内容类型\",{\"1\":{\"577\":1}}],[\"指定处理请求的提交内容类型\",{\"1\":{\"577\":1}}],[\"指定我们刚刚创建在类路径下的xml配置文件\",{\"1\":{\"548\":1}}],[\"指定b继承a\",{\"1\":{\"504\":1}}],[\"指定实现\",{\"0\":{\"467\":1}}],[\"指示编译器去忽略注解中声明的警告\",{\"1\":{\"361\":1}}],[\"指导agent在当前状态下选择哪个动作\",{\"1\":{\"19\":1}}],[\"检查约束通常用于限制某些特定的数值范围或模式\",{\"1\":{\"747\":1}}],[\"检查sessionregistry保存的session信息是否过期\",{\"1\":{\"714\":1}}],[\"检查\",{\"1\":{\"361\":1,\"747\":1,\"748\":1}}],[\"想要获取对应的参数\",{\"1\":{\"575\":1}}],[\"想要了解优先级队列的具体是原理\",{\"1\":{\"203\":1}}],[\"想想那样的话写起来得多恐怖\",{\"1\":{\"540\":1}}],[\"想之前一样的话\",{\"1\":{\"461\":1}}],[\"想破解你代码有的是方法\",{\"1\":{\"356\":1}}],[\"华强\",{\"1\":{\"356\":1}}],[\"爷爷加载器\",{\"1\":{\"355\":1}}],[\"错误的类型转换\",{\"1\":{\"799\":1}}],[\"错误\",{\"1\":{\"355\":1,\"421\":1,\"425\":1,\"1072\":1}}],[\"既然使用了spring\",{\"1\":{\"1288\":1}}],[\"既然使用的是http连接\",{\"1\":{\"727\":1}}],[\"既然现在采用注解\",{\"1\":{\"1166\":1}}],[\"既然现在要使用注解来进行开发\",{\"1\":{\"1166\":1}}],[\"既然现在要让别人帮忙管理对象\",{\"1\":{\"1119\":1}}],[\"既然现在不需要配置mapper\",{\"1\":{\"894\":1}}],[\"既然它是依靠tcp协议进行数据传输\",{\"1\":{\"1042\":1}}],[\"既然我们现在可以从数据库中获取数据了\",{\"1\":{\"799\":1}}],[\"既然我们的注解可以保留到运行时\",{\"1\":{\"365\":1}}],[\"既然视图本质就是一个查询的结果\",{\"1\":{\"779\":1}}],[\"既然了解了属性和联系\",{\"1\":{\"734\":1}}],[\"既然了解了元注解的使用和注解的定义方式\",{\"1\":{\"363\":1}}],[\"既然需要自定义\",{\"1\":{\"667\":1}}],[\"既然要实现前后端分离\",{\"1\":{\"610\":1}}],[\"既然分数段都是整数\",{\"1\":{\"495\":1,\"496\":1}}],[\"既然是在方法中声明的类\",{\"1\":{\"410\":1}}],[\"既然数组可以是任何类型的\",{\"1\":{\"397\":1}}],[\"既然数组操作都这么方便了\",{\"1\":{\"232\":1}}],[\"既然能装箱\",{\"1\":{\"384\":1}}],[\"既然都有\",{\"1\":{\"376\":1}}],[\"既然通过classloader就可以加载类\",{\"1\":{\"356\":1}}],[\"既然说class对象和加载的类唯一对应\",{\"1\":{\"355\":1}}],[\"淦\",{\"1\":{\"350\":1,\"438\":1}}],[\"~modifier\",{\"1\":{\"350\":1}}],[\"尤其是仅比较子类属性\",{\"1\":{\"812\":1}}],[\"尤其是在类进行类内部成员字段封装时\",{\"1\":{\"810\":1}}],[\"尤其是在网络i\",{\"1\":{\"248\":1}}],[\"尤其是我们提到的越权访问\",{\"1\":{\"349\":1}}],[\"整体测试\",{\"1\":{\"972\":1}}],[\"整个mybatis的\",{\"1\":{\"1328\":1}}],[\"整个ioc容器基本就可以正常使用了\",{\"1\":{\"1320\":1}}],[\"整个idea程序都是由java编写的\",{\"1\":{\"788\":1}}],[\"整个栈追踪信息中包含了大量aop包下的内容\",{\"1\":{\"1278\":1}}],[\"整个配置文件将会充满bean配置\",{\"1\":{\"1165\":1}}],[\"整个程序其实是依靠各个部分相互协作\",{\"1\":{\"1116\":1}}],[\"整个http请求报文中的所有内容\",{\"1\":{\"1057\":1}}],[\"整个tomcat目录下\",{\"1\":{\"1047\":1}}],[\"整个报文全部是以文本形式发送的\",{\"1\":{\"1042\":1}}],[\"整个web页面的内容在一开始就编写完成了\",{\"1\":{\"609\":1}}],[\"整个web应用程序的开发变得非常简单\",{\"1\":{\"586\":1}}],[\"整个内部类中都处于静态上下文\",{\"1\":{\"409\":1}}],[\"整个arraylist体系由于我们的反射操作\",{\"1\":{\"350\":1}}],[\"整个过程都是反射在代替进行操作\",{\"1\":{\"349\":1}}],[\"整合mybatis框架\",{\"0\":{\"1252\":1}}],[\"整合\",{\"1\":{\"46\":1}}],[\"萨日朗\",{\"1\":{\"348\":1}}],[\"哪些变量等等\",{\"1\":{\"337\":1}}],[\"堆内存\",{\"1\":{\"337\":1}}],[\"慎重使用\",{\"1\":{\"336\":1}}],[\"继类\",{\"1\":{\"501\":1}}],[\"继续往上抛异常\",{\"1\":{\"1320\":1}}],[\"继续往下\",{\"1\":{\"1301\":1}}],[\"继续访问数组的length属性\",{\"1\":{\"1203\":1}}],[\"继续编写throws往上一级抛\",{\"1\":{\"424\":1}}],[\"继续读取会导致mark失效\",{\"1\":{\"265\":1}}],[\"继承和多模块\",{\"0\":{\"1029\":1}}],[\"继承和多态是面向对象编程的三大特性\",{\"1\":{\"369\":1}}],[\"继承和多态\",{\"0\":{\"369\":1}}],[\"继承的子类必须显式标记为final\",{\"1\":{\"504\":1}}],[\"继承也是同样的\",{\"1\":{\"439\":1}}],[\"继承自genericservlet\",{\"1\":{\"1059\":1}}],[\"继承自servletrequest\",{\"1\":{\"1057\":1}}],[\"继承自\",{\"1\":{\"421\":1}}],[\"继承自number类\",{\"1\":{\"384\":1}}],[\"继承自哪个类\",{\"1\":{\"336\":1}}],[\"继承\",{\"0\":{\"371\":1,\"1030\":1,\"1032\":1,\"1149\":1,\"1259\":1,\"1298\":1},\"1\":{\"369\":1,\"421\":1}}],[\"反映客观事物间的本质联系\",{\"1\":{\"732\":1}}],[\"反正只要能够保证我们指定的参数匹配到目标构造方法即可\",{\"1\":{\"1135\":1}}],[\"反正只要是符合接口中方法的定义的\",{\"1\":{\"415\":1}}],[\"反正接口定义了啥\",{\"1\":{\"1117\":1}}],[\"反正作为新手\",{\"1\":{\"217\":1}}],[\"反射型xss攻击\",{\"1\":{\"643\":1}}],[\"反射获取注解\",{\"0\":{\"365\":1}}],[\"反射3\",{\"0\":{\"353\":1,\"354\":1}}],[\"反射非常暴力\",{\"1\":{\"350\":1}}],[\"反射非常强大\",{\"1\":{\"349\":1}}],[\"反射可以无视权限修饰符访问类的内容\",{\"1\":{\"348\":1}}],[\"反射2\",{\"0\":{\"346\":1,\"347\":1}}],[\"反射操作可能需要用到\",{\"1\":{\"340\":1}}],[\"反射就是把java类中的各个成分映射成一个个的java对象\",{\"1\":{\"336\":1}}],[\"反射\",{\"0\":{\"336\":1},\"1\":{\"462\":1,\"534\":1,\"788\":1}}],[\"反射1\",{\"0\":{\"334\":1,\"335\":1}}],[\"厨师2\",{\"1\":{\"331\":1}}],[\"厨师1\",{\"1\":{\"331\":1}}],[\"生产的bean是否采用单例模式\",{\"1\":{\"1180\":1}}],[\"生产的bean类型\",{\"1\":{\"1180\":1}}],[\"生产的bean对象\",{\"1\":{\"1180\":1}}],[\"生产者此时等待货架出现空位\",{\"1\":{\"331\":1}}],[\"生产者要生产产品\",{\"1\":{\"331\":1}}],[\"生产者与消费者\",{\"0\":{\"331\":1}}],[\"生命周期\",{\"0\":{\"985\":1}}],[\"生效了\",{\"1\":{\"796\":1}}],[\"生成此bean定义\",{\"1\":{\"1296\":1}}],[\"生成事务\",{\"1\":{\"1242\":1}}],[\"生成一个随机数\",{\"1\":{\"963\":1}}],[\"生成一个匿名的iterator对象\",{\"1\":{\"193\":1}}],[\"生成流\",{\"1\":{\"228\":1}}],[\"生成\",{\"1\":{\"228\":1}}],[\"生成反向迭代器\",{\"1\":{\"201\":1}}],[\"生成当前集合的迭代器\",{\"1\":{\"193\":1}}],[\"生成当前集合的并行流\",{\"1\":{\"180\":1}}],[\"生成当前集合的流\",{\"1\":{\"180\":1}}],[\"程序中的properties对象也可以快速保存为一个对应的\",{\"1\":{\"938\":1}}],[\"程序可以正常运行\",{\"1\":{\"461\":1,\"1140\":1}}],[\"程序继续正常运行\",{\"1\":{\"424\":1}}],[\"程序正常运行中\",{\"1\":{\"329\":2}}],[\"程序编译之后的样子是什么样的\",{\"1\":{\"173\":1}}],[\"守护进程在后台运行运行\",{\"1\":{\"329\":1}}],[\"守护线程自动结束\",{\"1\":{\"329\":2}}],[\"守护线程\",{\"0\":{\"329\":1}}],[\"循环依赖的解决\",{\"0\":{\"1301\":1}}],[\"循环引用情况\",{\"0\":{\"614\":1}}],[\"循环间隔\",{\"1\":{\"323\":1}}],[\"循环定时任务等\",{\"1\":{\"323\":1}}],[\"延迟\",{\"1\":{\"323\":1}}],[\"定时任务其实就是指定在哪个时候再去执行\",{\"1\":{\"1190\":1}}],[\"定时任务\",{\"0\":{\"1190\":1}}],[\"定时器\",{\"0\":{\"321\":1}}],[\"定位自增\",{\"1\":{\"710\":1}}],[\"定位是否等于当前大小\",{\"1\":{\"710\":1}}],[\"定义增强方法\",{\"0\":{\"1233\":1}}],[\"定义了一个名为accept的抽象方法\",{\"1\":{\"508\":1}}],[\"定义了agent与环境的交互行为\",{\"1\":{\"19\":1}}],[\"定义接口\",{\"1\":{\"376\":1}}],[\"定义一个自己的classloader\",{\"1\":{\"356\":1}}],[\"定义可以先放在try外部\",{\"1\":{\"247\":1}}],[\"定义中提到\",{\"1\":{\"241\":1}}],[\"定义的全部功能\",{\"1\":{\"224\":1}}],[\"定义目标函数\",{\"1\":{\"132\":1}}],[\"定义\",{\"0\":{\"363\":1,\"392\":1},\"1\":{\"48\":1,\"376\":1,\"706\":1,\"1082\":1}}],[\"定义为ξ=\",{\"1\":{\"13\":1}}],[\"尝试修改一下maxage来看看失效时间\",{\"1\":{\"1092\":1}}],[\"尝试自己写的http相应时\",{\"1\":{\"727\":1}}],[\"尝试通过反射获取jdk提供的类中的字段\",{\"1\":{\"462\":1}}],[\"尝试获取threadlocal中存放的变量\",{\"1\":{\"319\":1}}],[\"尝试将\",{\"1\":{\"142\":1}}],[\"唤醒所有等待当前对象锁的线程\",{\"1\":{\"372\":1}}],[\"唤醒一个等待当前对象锁的线程\",{\"1\":{\"372\":1}}],[\"唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\",{\"1\":{\"318\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"318\":1}}],[\"态\",{\"1\":{\"318\":1}}],[\"平常环境下是无法使用的\",{\"1\":{\"318\":1}}],[\"导出视图good\",{\"1\":{\"779\":1}}],[\"导出其他的视图\",{\"1\":{\"779\":1}}],[\"导入\",{\"0\":{\"1205\":1}}],[\"导入插件后\",{\"1\":{\"1037\":1}}],[\"导入本地依赖\",{\"0\":{\"1021\":1,\"1022\":1}}],[\"导入本地jar包\",{\"0\":{\"1018\":1}}],[\"导入依赖\",{\"0\":{\"958\":1,\"1290\":1}}],[\"导入需要的依赖\",{\"1\":{\"559\":1}}],[\"导入项目a的模块\",{\"1\":{\"467\":1}}],[\"导入我们需要使用的类\",{\"1\":{\"277\":1}}],[\"导致其10次里面会有1次出现错误\",{\"1\":{\"990\":1}}],[\"导致mybatis无法确定具体哪个参数交什么名字\",{\"1\":{\"843\":1}}],[\"导致一方还持有连接\",{\"1\":{\"721\":1}}],[\"导致在web应用程序中存在了一些安全问题\",{\"1\":{\"643\":1}}],[\"导致被破坏\",{\"1\":{\"350\":1}}],[\"导致程序卡住\",{\"1\":{\"313\":1}}],[\"死锁是指两个线程相互持有对方需要的锁\",{\"1\":{\"313\":1}}],[\"死锁\",{\"0\":{\"313\":1}}],[\"缓存还会生效吗\",{\"1\":{\"883\":1}}],[\"缓存的概念在我们后续的学习中还会经常遇见\",{\"1\":{\"882\":1}}],[\"缓存机制\",{\"0\":{\"882\":1}}],[\"缓存request请求\",{\"1\":{\"714\":1}}],[\"缓存一致性问题\",{\"0\":{\"888\":1}}],[\"缓存一致性\",{\"1\":{\"311\":1}}],[\"缓冲字符输出流\",{\"0\":{\"270\":1}}],[\"缓冲字符读取流\",{\"0\":{\"269\":1}}],[\"缓冲字符流\",{\"0\":{\"268\":1}}],[\"缓冲字节输出流\",{\"0\":{\"267\":1}}],[\"缓冲字节读取流\",{\"0\":{\"262\":1}}],[\"缓冲字节流\",{\"0\":{\"261\":1}}],[\"缓冲机制\",{\"0\":{\"265\":1}}],[\"缓冲区\",{\"1\":{\"260\":1}}],[\"缓冲流可以叠加\",{\"0\":{\"266\":1}}],[\"缓冲流特性\",{\"0\":{\"263\":1}}],[\"缓冲流\",{\"0\":{\"260\":1}}],[\"称之为\",{\"1\":{\"311\":1}}],[\"称为key\",{\"1\":{\"733\":1}}],[\"称为构建器\",{\"1\":{\"525\":1}}],[\"称为\",{\"1\":{\"113\":1}}],[\"称为策略评估\",{\"1\":{\"45\":1}}],[\"写成getbean\",{\"1\":{\"1328\":1}}],[\"写起来有点麻烦\",{\"1\":{\"1149\":1}}],[\"写到外面还是全部\",{\"1\":{\"988\":1}}],[\"写一个运行期的注解使用\",{\"0\":{\"535\":1}}],[\"写法\",{\"1\":{\"497\":1}}],[\"写共享变量的副本\",{\"1\":{\"311\":1}}],[\"写入的是二进制数据\",{\"1\":{\"286\":1}}],[\"写入对应长度的数据到输出流\",{\"1\":{\"251\":1}}],[\"尽可能减少\",{\"1\":{\"735\":1}}],[\"尽可能多的在执行线程2的内容\",{\"1\":{\"304\":1}}],[\"尽可能的扬长避短\",{\"1\":{\"182\":1}}],[\"常用注册bean方式\",{\"0\":{\"1177\":1}}],[\"常用的handler实现有\",{\"1\":{\"918\":1}}],[\"常用的是以下两个\",{\"1\":{\"649\":1}}],[\"常用\",{\"0\":{\"763\":1}}],[\"常用工具类\",{\"0\":{\"430\":1}}],[\"常见的数据库有很多种\",{\"1\":{\"732\":1}}],[\"常见的前端异步请求方式包括使用xmlhttprequest对象\",{\"1\":{\"617\":1}}],[\"常见用法就是集中定义全局异常处理逻辑\",{\"1\":{\"603\":1}}],[\"常与\",{\"1\":{\"604\":1}}],[\"常规优先级\",{\"1\":{\"302\":1}}],[\"常数\",{\"1\":{\"9\":1}}],[\"复杂判断\",{\"0\":{\"972\":1}}],[\"复杂查询\",{\"0\":{\"848\":1}}],[\"复制一份即可\",{\"1\":{\"788\":1}}],[\"复制到\",{\"1\":{\"142\":1}}],[\"复位中断标记\",{\"1\":{\"301\":2}}],[\"休眠后再运行\",{\"1\":{\"322\":2}}],[\"休眠3秒\",{\"1\":{\"301\":1}}],[\"休眠时间\",{\"1\":{\"299\":1}}],[\"显示名称生成器\",{\"1\":{\"962\":1}}],[\"显示声明了会抛出一个interruptedexception异常\",{\"1\":{\"300\":1}}],[\"显然表示此时不支持\",{\"1\":{\"1059\":1}}],[\"显然map用起来更便捷一些\",{\"1\":{\"834\":1}}],[\"显然太过简单\",{\"1\":{\"626\":1}}],[\"显然无法在编译期确定类型是否安全\",{\"1\":{\"437\":1}}],[\"显然是\",{\"1\":{\"150\":1}}],[\"显然是可以通过一个\",{\"1\":{\"66\":1}}],[\"显然我们仍然可以通过\",{\"1\":{\"110\":1}}],[\"显然我们可以将\",{\"1\":{\"104\":1}}],[\"显然ϵ=0\",{\"1\":{\"87\":1}}],[\"显然其核心关键就是在\",{\"1\":{\"77\":1}}],[\"显然在现实运行算法中是无法做到的\",{\"1\":{\"71\":1}}],[\"显然\",{\"1\":{\"19\":1,\"23\":1,\"63\":1,\"71\":1,\"78\":1,\"86\":1,\"96\":1,\"104\":1,\"641\":1}}],[\"被注册到容器中进行加载了\",{\"1\":{\"1328\":1}}],[\"被直接斩断\",{\"1\":{\"1215\":1}}],[\"被包装的元素为null\",{\"1\":{\"480\":1}}],[\"被包装的元素为\",{\"1\":{\"480\":1}}],[\"被除数不能为0\",{\"1\":{\"423\":2}}],[\"被挂起的线程才能继续\",{\"1\":{\"313\":1}}],[\"被\",{\"1\":{\"300\":1}}],[\"阻塞态\",{\"1\":{\"318\":1}}],[\"阻塞\",{\"1\":{\"300\":1,\"1246\":1}}],[\"或其它类似的框架\",{\"1\":{\"872\":1}}],[\"或注解来配置和映射原生信息\",{\"1\":{\"816\":1}}],[\"或\",{\"1\":{\"603\":1,\"604\":1,\"806\":1,\"884\":1,\"1181\":1}}],[\"或是方法开始之前传入了什么参数等等\",{\"1\":{\"1223\":1}}],[\"或是使用注解开发\",{\"1\":{\"1211\":1}}],[\"或是使用timertask来完成定时任务\",{\"1\":{\"1187\":1}}],[\"或是使用相反的注解来为指定jdk关闭\",{\"1\":{\"977\":1}}],[\"或是使用相反注解来为指定操作系统关闭此用例\",{\"1\":{\"976\":1}}],[\"或是session创建的时候\",{\"1\":{\"1105\":1}}],[\"或是docs项目\",{\"1\":{\"1047\":1}}],[\"或是作为一个可执行的java应用程序运行\",{\"1\":{\"1036\":1}}],[\"或是指定某些枚举常量\",{\"1\":{\"993\":1}}],[\"或是一些其他的配置项\",{\"1\":{\"1085\":1}}],[\"或是一些非常紧急的日志信息\",{\"1\":{\"909\":1}}],[\"或是一个指定的jdk版本范围\",{\"1\":{\"978\":1}}],[\"或是某些案例只需要在某个特定操作系统执行\",{\"1\":{\"975\":1}}],[\"或是结束并回滚\",{\"1\":{\"884\":1}}],[\"或是具有同样参数的实体类来传递\",{\"1\":{\"834\":1}}],[\"或是$\",{\"1\":{\"831\":1}}],[\"或是getupdatecount\",{\"1\":{\"791\":1}}],[\"或是\",{\"1\":{\"727\":1,\"744\":1}}],[\"或是跳转到新的页面\",{\"1\":{\"617\":1}}],[\"或是由\",{\"1\":{\"589\":1}}],[\"或是继续使用此泛型让具体创建的对象来确定类型\",{\"1\":{\"439\":1}}],[\"或是调用sleep\",{\"1\":{\"299\":1}}],[\"或者如果一定用构造器注入\",{\"1\":{\"1181\":1}}],[\"或者还是mapper标签通过class属性来指定具体的接口\",{\"1\":{\"894\":1}}],[\"或者后端对前端发送的内容进行安全扫描并处理\",{\"1\":{\"643\":1}}],[\"或者通过此会话继续进行其他攻击\",{\"1\":{\"642\":1}}],[\"或者从\",{\"1\":{\"575\":1}}],[\"或者仅仅保存null\",{\"1\":{\"512\":1}}],[\"或者是继续摆烂\",{\"1\":{\"439\":1}}],[\"或者是false\",{\"1\":{\"392\":1}}],[\"或者是在运行时可以通过反射访问\",{\"1\":{\"362\":1}}],[\"或者是引用的接口中并没有该方法时\",{\"1\":{\"361\":1}}],[\"或者为静态变量赋值\",{\"1\":{\"275\":1}}],[\"或者\",{\"1\":{\"23\":1,\"66\":1,\"131\":1,\"156\":1,\"394\":1,\"413\":1,\"516\":1,\"1177\":1}}],[\"线程名称\",{\"1\":{\"948\":1}}],[\"线程会阻塞\",{\"1\":{\"719\":1,\"720\":1}}],[\"线程池\",{\"1\":{\"516\":1}}],[\"线程a和线程b都需要对方的锁\",{\"1\":{\"313\":1}}],[\"线程锁\",{\"0\":{\"312\":1},\"1\":{\"312\":1}}],[\"线程锁和线程同步\",{\"0\":{\"310\":1}}],[\"线程之间的共享变量\",{\"1\":{\"311\":1}}],[\"线程之间是同时运行的\",{\"1\":{\"296\":1}}],[\"线程2变量值已设定\",{\"1\":{\"319\":1}}],[\"线程2\",{\"1\":{\"313\":1}}],[\"线程2完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"线程2等待线程1待执行的内容全部执行完成之后\",{\"1\":{\"305\":1}}],[\"线程2开始运行\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程1读取变量值\",{\"1\":{\"319\":1}}],[\"线程1变量值已设定\",{\"1\":{\"319\":1}}],[\"线程1\",{\"1\":{\"313\":1}}],[\"线程1完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"线程1加入后\",{\"1\":{\"305\":1}}],[\"线程1加入到此线程\",{\"1\":{\"305\":1}}],[\"线程1结束\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程1开始运行\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程优先级\",{\"0\":{\"302\":1}}],[\"线程被中断了\",{\"1\":{\"301\":1}}],[\"线程开始运行\",{\"1\":{\"301\":1,\"302\":1}}],[\"线程的加入只是等待另一个线程的完成\",{\"1\":{\"305\":1}}],[\"线程的礼让和加入\",{\"0\":{\"303\":1}}],[\"线程的优先级一般分为以下三种\",{\"1\":{\"302\":1}}],[\"线程的下一个状态会出现以下情况\",{\"1\":{\"300\":1}}],[\"线程的休眠和中断\",{\"0\":{\"300\":1}}],[\"线程的创建和启动\",{\"0\":{\"296\":1}}],[\"线程和进程差不多\",{\"1\":{\"299\":1}}],[\"线程是程序执行中一个单一的顺序控制流程\",{\"1\":{\"295\":1}}],[\"线程横空出世\",{\"1\":{\"295\":1}}],[\"线性表支持随机访问\",{\"1\":{\"181\":1}}],[\"线性表\",{\"1\":{\"181\":1}}],[\"网页端只是保存了jsessionid来识别\",{\"1\":{\"1095\":1}}],[\"网页发送的请求就会携带所有的\",{\"1\":{\"1091\":1}}],[\"网页中的部分内容\",{\"1\":{\"1076\":1}}],[\"网络内容\",{\"0\":{\"1351\":1}}],[\"网络基础3\",{\"0\":{\"1052\":1}}],[\"网络基础2\",{\"0\":{\"1046\":1}}],[\"网络基础1\",{\"0\":{\"1041\":1,\"1042\":1}}],[\"网络的输入包括\",{\"1\":{\"142\":1}}],[\"网站地址\",{\"1\":{\"490\":1}}],[\"网易云音乐等软件\",{\"1\":{\"295\":1}}],[\"浏览器显示cookie信息的时候显示该说明\",{\"1\":{\"1092\":1}}],[\"浏览器也不会以任何形式保存该cookie\",{\"1\":{\"1092\":1}}],[\"浏览器也是可以直接打开xml文件的\",{\"1\":{\"817\":1}}],[\"浏览器只发起了一次请求\",{\"1\":{\"1083\":1}}],[\"浏览器发送了什么数据\",{\"1\":{\"1069\":1}}],[\"浏览器就是安装在用户主机上的万维网客户程序\",{\"1\":{\"1042\":1}}],[\"浏览器会显示无法访问\",{\"1\":{\"727\":1}}],[\"浏览器会等待服务器响应\",{\"1\":{\"617\":1}}],[\"浏览器\",{\"1\":{\"295\":1}}],[\"进而补货\",{\"1\":{\"331\":1}}],[\"进入等待状态并释放锁\",{\"1\":{\"318\":1}}],[\"进程之间的通信就变得非常麻烦\",{\"1\":{\"295\":1}}],[\"进程是拥有资源和独立运行的最小单位\",{\"1\":{\"295\":1}}],[\"进程是程序执行的实体\",{\"1\":{\"295\":1}}],[\"进程与线程概念\",{\"0\":{\"295\":1}}],[\"进行刷新\",{\"1\":{\"1320\":1}}],[\"进行依赖注入\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"进行随机数据库读写操作\",{\"1\":{\"1260\":1}}],[\"进行更加环绕那样的自定义的增强\",{\"1\":{\"1231\":1}}],[\"进行更新即可\",{\"1\":{\"115\":1}}],[\"进行查询\",{\"1\":{\"1008\":1}}],[\"进行整体测试时\",{\"1\":{\"972\":1}}],[\"进行对2取余操作\",{\"1\":{\"963\":1}}],[\"进行划分\",{\"1\":{\"936\":1}}],[\"进行自动继承\",{\"1\":{\"930\":1}}],[\"进行回滚操作\",{\"1\":{\"865\":1}}],[\"进行结尾\",{\"1\":{\"744\":1}}],[\"进行编码\",{\"1\":{\"714\":1}}],[\"进行认证\",{\"1\":{\"711\":1}}],[\"进行防护\",{\"1\":{\"660\":1}}],[\"进行登录操作了\",{\"1\":{\"658\":1}}],[\"进行全局数据绑定\",{\"1\":{\"602\":1}}],[\"进行全局异常处理\",{\"1\":{\"602\":1}}],[\"进行处理\",{\"1\":{\"558\":1,\"811\":1}}],[\"进行限制的话\",{\"1\":{\"478\":1}}],[\"进行缩减\",{\"1\":{\"446\":1}}],[\"进行类型比较又会导致额外的开销和增加代码量\",{\"1\":{\"437\":1}}],[\"进行异常捕获\",{\"1\":{\"424\":1}}],[\"进行捕获\",{\"1\":{\"424\":1}}],[\"进行拼接操作\",{\"1\":{\"402\":1}}],[\"进行加密\",{\"1\":{\"356\":1}}],[\"进行数据转换就会很麻烦\",{\"1\":{\"283\":1}}],[\"进行判断\",{\"1\":{\"241\":1}}],[\"进行判断来删除元素\",{\"1\":{\"241\":1}}],[\"进行判断的\",{\"1\":{\"241\":1}}],[\"进行分割\",{\"1\":{\"228\":1}}],[\"进行倒序排列\",{\"1\":{\"228\":1}}],[\"进行优化\",{\"1\":{\"148\":1}}],[\"进行训练\",{\"1\":{\"142\":1}}],[\"进行赋值\",{\"1\":{\"142\":1}}],[\"进行固定求解\",{\"1\":{\"142\":1}}],[\"进行生成数据\",{\"1\":{\"125\":1}}],[\"进行的采样\",{\"1\":{\"84\":1}}],[\"进行估计\",{\"1\":{\"78\":1,\"94\":1}}],[\"进行了无穷多步来进行了真实的求解\",{\"1\":{\"71\":1}}],[\"进行迭代\",{\"1\":{\"70\":1,\"101\":1}}],[\"进行求解\",{\"1\":{\"47\":1,\"66\":1,\"103\":1}}],[\"取而代之的是那一堆xml配置\",{\"1\":{\"1133\":1}}],[\"取消本次刷新操作\",{\"1\":{\"1320\":1}}],[\"取消\",{\"0\":{\"684\":1}}],[\"取消这些不必要保存的属性\",{\"1\":{\"290\":1}}],[\"取值只能进行强制类型转换\",{\"1\":{\"437\":1}}],[\"取值范围从1−4\",{\"1\":{\"10\":1}}],[\"秘制小汉堡\",{\"1\":{\"285\":1}}],[\"系统必须确保它所建模的业务处于一致的状态\",{\"1\":{\"1266\":1}}],[\"系统属性判断\",{\"0\":{\"979\":1}}],[\"系统属性\",{\"1\":{\"938\":1}}],[\"系统模块\",{\"1\":{\"463\":1}}],[\"系统输入流\",{\"1\":{\"285\":1}}],[\"系统结构\",{\"0\":{\"7\":1}}],[\"❌\",{\"1\":{\"278\":6,\"528\":3}}],[\"✅\",{\"1\":{\"278\":10,\"528\":4}}],[\"公共\",{\"1\":{\"278\":1}}],[\"受保护\",{\"1\":{\"278\":1}}],[\"受限制的始终是底层哈希表的长度\",{\"1\":{\"217\":1}}],[\"什么时候又是销毁呢\",{\"1\":{\"1148\":1}}],[\"什么时候更新策略也是一个影响效率的因素\",{\"1\":{\"82\":1}}],[\"什么都不写\",{\"1\":{\"278\":1}}],[\"私有\",{\"1\":{\"278\":1}}],[\"包名\",{\"1\":{\"1219\":2}}],[\"包扫描到的其他bean就注册到beanfactory中了\",{\"1\":{\"1320\":1}}],[\"包扫描\",{\"1\":{\"1177\":1}}],[\"包下所有的接口都将直接作为mapper配置接口\",{\"1\":{\"894\":1}}],[\"包含另一个事务\",{\"1\":{\"1281\":1}}],[\"包含完整包名+类名\",{\"1\":{\"1205\":1}}],[\"包含\",{\"1\":{\"1096\":1}}],[\"包含类名和方法名称连接之后的名称\",{\"1\":{\"962\":1}}],[\"包含了真正的请求映射的处理\",{\"1\":{\"597\":1}}],[\"包含会抛出\",{\"1\":{\"528\":1}}],[\"包组成\",{\"1\":{\"460\":1}}],[\"包装类支持字符串直接转换\",{\"1\":{\"385\":1}}],[\"包装类的方法\",{\"0\":{\"385\":1}}],[\"包装类实际上就是将我们的基本数据类型\",{\"1\":{\"384\":1}}],[\"包装类型支持自动装箱\",{\"1\":{\"384\":1}}],[\"包装类型的自动装箱和拆箱机制\",{\"1\":{\"384\":1}}],[\"包装类型都有一个type\",{\"1\":{\"340\":1}}],[\"包延时任务\",{\"1\":{\"323\":1}}],[\"包其实就是用来区分类位置的东西\",{\"1\":{\"277\":1}}],[\"包的命名规则同样是英文和数字的组合\",{\"1\":{\"277\":1}}],[\"包的声明和导入\",{\"0\":{\"277\":1}}],[\"包的访问与控制\",{\"0\":{\"276\":1}}],[\"包括全部的数据库操作方法定义\",{\"1\":{\"1242\":1}}],[\"包括很多信息\",{\"1\":{\"1226\":1}}],[\"包括我们前面讲解spring的异步任务调度时\",{\"1\":{\"1222\":1}}],[\"包括我们自己也是没办法实现继承的\",{\"1\":{\"503\":1}}],[\"包括后面我们在学习springmvc时\",{\"1\":{\"1118\":1}}],[\"包括后面的spring等众多框架都会用到xml来作为框架的配置文件\",{\"1\":{\"819\":1}}],[\"包括tomcat\",{\"1\":{\"1053\":1}}],[\"包括testsqlbuilder中编写的方法也需要添加\",{\"1\":{\"902\":1}}],[\"包括html文件\",{\"1\":{\"1047\":1}}],[\"包括已经在运行的web应用程序\",{\"1\":{\"1047\":1}}],[\"包括启动和关闭服务器的脚本\",{\"1\":{\"1047\":1}}],[\"包括版本号等\",{\"1\":{\"1033\":1}}],[\"包括代码的编译\",{\"1\":{\"1000\":1}}],[\"包括系统的架构\",{\"1\":{\"978\":1}}],[\"包括一些sql语句参数的使用也是和之前完全一样\",{\"1\":{\"896\":1}}],[\"包括url\",{\"1\":{\"824\":1}}],[\"包括读未提交\",{\"1\":{\"782\":1}}],[\"包括=\",{\"1\":{\"763\":1}}],[\"包括但不限于\",{\"1\":{\"732\":1}}],[\"包括singleton和prototype\",{\"1\":{\"588\":1}}],[\"包括数据库的连接信息\",{\"1\":{\"1244\":1}}],[\"包括数据模型和视图\",{\"1\":{\"558\":1}}],[\"包括数组复制方法\",{\"1\":{\"171\":1}}],[\"包括双引号等\",{\"1\":{\"498\":1}}],[\"包括jdk官方库\",{\"1\":{\"460\":1}}],[\"包括接口\",{\"1\":{\"439\":1}}],[\"包括课程名称\",{\"1\":{\"437\":1}}],[\"包括返回值类型\",{\"1\":{\"1219\":1}}],[\"包括返回值\",{\"1\":{\"414\":1,\"447\":1}}],[\"包括对方法的调用和super关键字的使用\",{\"1\":{\"408\":1}}],[\"包括对象内部的所有成员变量\",{\"1\":{\"377\":1}}],[\"包括对象的各个属性\",{\"1\":{\"372\":1}}],[\"包括换行\",{\"1\":{\"403\":1}}],[\"包括引用类型和基本类型\",{\"1\":{\"391\":1}}],[\"包括三种策略\",{\"1\":{\"363\":1}}],[\"包括方法上\",{\"1\":{\"360\":1}}],[\"包括方法的形式参数列表\",{\"1\":{\"349\":1}}],[\"包括void\",{\"1\":{\"340\":1}}],[\"包括类里面有哪些方法\",{\"1\":{\"337\":1}}],[\"包括类里面有哪些字段\",{\"1\":{\"336\":1}}],[\"包括文本\",{\"1\":{\"245\":1}}],[\"包括\",{\"1\":{\"223\":1,\"744\":1,\"765\":1,\"951\":1,\"1301\":1}}],[\"包括列表\",{\"1\":{\"178\":1}}],[\"静态资源\",{\"1\":{\"1001\":1}}],[\"静态资源依然全部可以访问\",{\"1\":{\"692\":1,\"693\":1}}],[\"静态资源权限处理\",{\"0\":{\"681\":1}}],[\"静态内部类编译特性\",{\"0\":{\"411\":1}}],[\"静态内部类由于是静态的\",{\"1\":{\"409\":1}}],[\"静态内部类的类名同样是之前的格式\",{\"1\":{\"409\":1}}],[\"静态内部类就像静态方法和静态变量一样\",{\"1\":{\"409\":1}}],[\"静态内部类\",{\"0\":{\"409\":1}}],[\"静态\",{\"1\":{\"406\":1}}],[\"静态初始化\",{\"1\":{\"392\":1}}],[\"静态导入test方法\",{\"1\":{\"278\":1}}],[\"静态导入\",{\"1\":{\"278\":1}}],[\"静态方法作为方法引用时\",{\"1\":{\"452\":1}}],[\"静态方法使用\",{\"1\":{\"415\":1}}],[\"静态方法甚至是类指定访问权限\",{\"1\":{\"278\":1}}],[\"静态方法同样是属于类的\",{\"1\":{\"274\":1}}],[\"静态变量\",{\"1\":{\"278\":1}}],[\"静态变量初始化\",{\"0\":{\"275\":1}}],[\"静态变量和静态方法\",{\"0\":{\"274\":1}}],[\"静态的内容\",{\"1\":{\"274\":1}}],[\"静止\",{\"1\":{\"13\":1}}],[\"已报名\",{\"1\":{\"1224\":1}}],[\"已连接到服务端\",{\"1\":{\"719\":1,\"720\":1}}],[\"已经可以成功使用此用户进行登陆了\",{\"1\":{\"1047\":1}}],[\"已经封死了\",{\"1\":{\"504\":1}}],[\"已经超过了readlimit\",{\"1\":{\"265\":1}}],[\"已知的情况\",{\"1\":{\"96\":1}}],[\"已知\",{\"1\":{\"77\":1}}],[\"主机可以是一个域名\",{\"1\":{\"1042\":1}}],[\"主机接收了就没了\",{\"1\":{\"265\":1}}],[\"主键可以使用idarg来表示\",{\"1\":{\"841\":1}}],[\"主键约束保证表中的每一行数据都有唯一的标识符\",{\"1\":{\"748\":1}}],[\"主键列的值用来唯一标识每一行数据\",{\"1\":{\"747\":1}}],[\"主键\",{\"1\":{\"747\":1,\"748\":2}}],[\"主线程停止1秒\",{\"1\":{\"311\":1,\"312\":2}}],[\"主动让出cpu资源\",{\"0\":{\"304\":1}}],[\"主方法的string参数是java\",{\"1\":{\"277\":1}}],[\"主要是用poolstate类中维护了两个列表进行管理\",{\"1\":{\"1246\":1}}],[\"主要是针对bean的生命周期进行管理的轻量级容器\",{\"1\":{\"1113\":1}}],[\"主要是可以设定编码格式\",{\"1\":{\"817\":1}}],[\"主要掌握几种流之间的操作\",{\"1\":{\"726\":1}}],[\"主要目的就是注册了一个\",{\"1\":{\"705\":1}}],[\"主要关注各类对应的\",{\"1\":{\"704\":1}}],[\"主要用于controller等配置\",{\"1\":{\"552\":1}}],[\"主要就是定义注解\",{\"1\":{\"534\":1}}],[\"主要就两个方法\",{\"1\":{\"509\":1}}],[\"主要区别\",{\"1\":{\"245\":1}}],[\"主要类\",{\"1\":{\"245\":2}}],[\"主要方法\",{\"1\":{\"189\":1}}],[\"主要框架\",{\"1\":{\"18\":1}}],[\"主要内容\",{\"0\":{\"6\":1,\"786\":1}}],[\"主要贡献\",{\"0\":{\"5\":1}}],[\"主要动机\",{\"0\":{\"4\":1}}],[\"装饰着模式\",{\"0\":{\"264\":1}}],[\"很快\",{\"1\":{\"1173\":1}}],[\"很明显\",{\"1\":{\"1126\":1,\"1134\":1,\"1188\":1,\"1218\":2}}],[\"很明显是自动生成的\",{\"1\":{\"446\":1}}],[\"很容易出现\",{\"1\":{\"1116\":1}}],[\"很容易出现以下的情况\",{\"1\":{\"437\":1}}],[\"很有可能会被postprocessor给偷梁换柱\",{\"1\":{\"1310\":1}}],[\"很有可能出现改了代码导致之前的功能出现问题\",{\"1\":{\"956\":1}}],[\"很有可能造成程序反应迟钝\",{\"1\":{\"260\":1}}],[\"很多项目往往都会采用这种多模块子项目的形式的去编写\",{\"1\":{\"1032\":1}}],[\"很多javaweb项目可能还会用到webapp目录\",{\"1\":{\"1001\":1}}],[\"很多浏览器都有samesite保护机制\",{\"1\":{\"641\":1}}],[\"很多的类仅仅只是充当一个实体类罢了\",{\"1\":{\"501\":1}}],[\"很遗憾\",{\"1\":{\"393\":1}}],[\"很简单\",{\"1\":{\"182\":1,\"1298\":1}}],[\"虽然很长很多\",{\"1\":{\"1326\":1}}],[\"虽然依然存在aop增强\",{\"1\":{\"1282\":1}}],[\"虽然它避免了脏读问题\",{\"1\":{\"1269\":1}}],[\"虽然出现了这样的信息\",{\"1\":{\"1188\":1}}],[\"虽然目前这两bean定义都是一模一样的\",{\"1\":{\"1127\":1}}],[\"虽然手机爆炸的概率很小\",{\"1\":{\"910\":1}}],[\"虽然mybatis为我们提供了之前xml配置中各种操作的对应注解\",{\"1\":{\"897\":1}}],[\"虽然缓存机制给我们提供了很大的性能提升\",{\"1\":{\"888\":1}}],[\"虽然这里直接传的就是name\",{\"1\":{\"1300\":1}}],[\"虽然这里是第一个定义的\",{\"1\":{\"987\":1}}],[\"虽然这些功能已经非常强大了\",{\"1\":{\"1223\":1}}],[\"虽然这样已经很方便了\",{\"1\":{\"1256\":1}}],[\"虽然这样可以实现和之前差不多的效果\",{\"1\":{\"902\":1}}],[\"虽然这样看似非常完美\",{\"1\":{\"871\":1}}],[\"虽然这两种列表的实现不同\",{\"1\":{\"190\":1}}],[\"虽然日志中已经提示生效1行\",{\"1\":{\"865\":1}}],[\"虽然没有干什么事情\",{\"1\":{\"824\":1}}],[\"虽然我们能够通过jdbc来连接和操作数据库\",{\"1\":{\"816\":1}}],[\"虽然我们目前还没有学习数组\",{\"1\":{\"384\":1}}],[\"虽然添加索引后会使得查询效率更高\",{\"1\":{\"780\":1}}],[\"虽然此用户能够成功登录\",{\"1\":{\"773\":1}}],[\"虽然springsecurity为我们提供了一个还行的登录界面\",{\"1\":{\"677\":1}}],[\"虽然stop\",{\"1\":{\"299\":1}}],[\"虽然完成本章学习后\",{\"1\":{\"626\":1}}],[\"虽然放在类上和放在构造函数上这两种模式是最常见的用例\",{\"1\":{\"525\":1}}],[\"虽然空指针异常告诉我们问题出现在这一行\",{\"1\":{\"500\":1}}],[\"虽然并不是一开始的类型\",{\"1\":{\"437\":1}}],[\"虽然是继承于\",{\"1\":{\"393\":1}}],[\"虽然a和b的值相同\",{\"1\":{\"384\":1}}],[\"虽然java语言是一个面向对象的语言\",{\"1\":{\"383\":1}}],[\"虽然拥有了创世主的能力\",{\"1\":{\"350\":1}}],[\"虽然任务执行完成了\",{\"1\":{\"324\":1}}],[\"虽然能得到对象\",{\"1\":{\"290\":1}}],[\"虽然给定的是fileinputstream\",{\"1\":{\"283\":1}}],[\"虽然给定的是fileoutputstream\",{\"1\":{\"283\":1}}],[\"虽然普通的文件流读取文件数据非常便捷\",{\"1\":{\"260\":1}}],[\"刷新操作是在\",{\"1\":{\"1320\":1}}],[\"刷新之后\",{\"1\":{\"642\":1}}],[\"刷新\",{\"1\":{\"254\":1}}],[\"牛\",{\"1\":{\"254\":2}}],[\"支持嵌套使用的\",{\"1\":{\"1208\":1}}],[\"支持以下类型\",{\"1\":{\"991\":1}}],[\"支持实现接口\",{\"1\":{\"501\":1}}],[\"支持c语言样式\",{\"1\":{\"392\":1}}],[\"支持载入外部class文件\",{\"1\":{\"356\":1}}],[\"支持参数\",{\"1\":{\"318\":1}}],[\"支持\",{\"1\":{\"265\":1,\"528\":1}}],[\"支持获取编码\",{\"1\":{\"254\":1}}],[\"支持泛型的数组转换\",{\"1\":{\"180\":1}}],[\"追加操作\",{\"0\":{\"250\":1}}],[\"强行设置值\",{\"1\":{\"350\":1}}],[\"强制类型转换\",{\"1\":{\"341\":1,\"376\":1}}],[\"强制写入\",{\"1\":{\"249\":1}}],[\"强化学习\",{\"0\":{\"1335\":1},\"2\":{\"22\":1,\"35\":1,\"51\":1,\"60\":1,\"74\":1,\"91\":1,\"108\":1,\"129\":1,\"146\":1,\"159\":1}}],[\"强化学习框架图\",{\"0\":{\"18\":1}}],[\"操作来向服务器传输数据\",{\"1\":{\"1069\":1}}],[\"操作结束\",{\"0\":{\"887\":1}}],[\"操作是同样的\",{\"1\":{\"854\":1}}],[\"操作流\",{\"0\":{\"517\":1}}],[\"操作出现在suspend\",{\"1\":{\"313\":1}}],[\"操作的都是同一个目标\",{\"1\":{\"274\":1}}],[\"操作和原来的流是一样的\",{\"1\":{\"262\":1}}],[\"操作\",{\"0\":{\"515\":1,\"707\":1,\"860\":1},\"1\":{\"249\":1,\"265\":1,\"269\":1,\"708\":1}}],[\"操作而是write\",{\"1\":{\"249\":1}}],[\"操作就是相同的\",{\"1\":{\"241\":1}}],[\"路径的匹配规则和servlet一致\",{\"1\":{\"1102\":1}}],[\"路径就是我们希望去访问此服务器上的某个文件\",{\"1\":{\"1042\":1}}],[\"路径还支持使用通配符进行匹配\",{\"1\":{\"571\":1}}],[\"路径\",{\"1\":{\"247\":2}}],[\"减少了字节到字符的转换时间\",{\"1\":{\"245\":1}}],[\"性质\",{\"0\":{\"396\":1}}],[\"性能就大大提高了\",{\"1\":{\"515\":1}}],[\"性能\",{\"1\":{\"245\":1}}],[\"性别呢\",{\"1\":{\"166\":1}}],[\"性别\",{\"1\":{\"161\":1,\"734\":1,\"737\":1}}],[\"字段注入\",{\"1\":{\"1181\":2}}],[\"字段上\",{\"1\":{\"1175\":1}}],[\"字段同样可以作为参数的来源\",{\"1\":{\"995\":1}}],[\"字段\",{\"0\":{\"995\":1},\"1\":{\"1175\":1}}],[\"字母的所有字母\",{\"1\":{\"403\":1}}],[\"字母\",{\"1\":{\"403\":1}}],[\"字符模糊匹配\",{\"1\":{\"763\":1}}],[\"字符\",{\"1\":{\"403\":2}}],[\"字符数组转字符串\",{\"1\":{\"401\":1}}],[\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组\",{\"1\":{\"401\":1}}],[\"字符串使用单引号囊括\",{\"1\":{\"1202\":1}}],[\"字符串支持使用\",{\"1\":{\"402\":1}}],[\"字符串类中提供了很多方便我们操作的方法\",{\"1\":{\"401\":1}}],[\"字符串类是一个比较特殊的类\",{\"1\":{\"400\":1}}],[\"字符串的内容比较\",{\"1\":{\"401\":1}}],[\"字符串中的字符一旦确定\",{\"1\":{\"400\":1}}],[\"字符串\",{\"0\":{\"389\":1,\"400\":1},\"1\":{\"1202\":1}}],[\"字符串转integer有多个方法\",{\"1\":{\"385\":1}}],[\"字符串内容的比较\",{\"1\":{\"373\":1}}],[\"字符流只支持char\",{\"1\":{\"253\":1}}],[\"字符流是以一个具体的字符进行读取\",{\"1\":{\"253\":1}}],[\"字符流不同于字节\",{\"1\":{\"253\":1}}],[\"字符流在处理文本数据时通常更高效\",{\"1\":{\"245\":1}}],[\"字符流自动处理字符编码转换\",{\"1\":{\"245\":1}}],[\"字符流仅适用于文本数据\",{\"1\":{\"245\":1}}],[\"字符流以字符为单位\",{\"1\":{\"245\":1}}],[\"字符流\",{\"1\":{\"245\":1}}],[\"字节流不处理字符编码\",{\"1\":{\"245\":1}}],[\"字节流适用于所有类型的数据\",{\"1\":{\"245\":1}}],[\"字节流以字节为单位\",{\"1\":{\"245\":1}}],[\"字节流\",{\"1\":{\"245\":1}}],[\"编码格式是重中之重\",{\"1\":{\"560\":1}}],[\"编码处理\",{\"1\":{\"245\":3}}],[\"编写好后\",{\"1\":{\"826\":1}}],[\"编写mybatis的配置文件\",{\"1\":{\"824\":1}}],[\"编写适用于自己数据库的实现类\",{\"1\":{\"787\":1}}],[\"编写的对应访问路径的servlet\",{\"1\":{\"691\":1}}],[\"编写配置项\",{\"0\":{\"560\":1}}],[\"编写对应\",{\"0\":{\"554\":1}}],[\"编写\",{\"0\":{\"549\":1}}],[\"编译完成后\",{\"1\":{\"1016\":1}}],[\"编译阶段处理\",{\"1\":{\"811\":1}}],[\"编译期的注解使用\",{\"0\":{\"536\":1}}],[\"编译期生效\",{\"1\":{\"534\":1}}],[\"编译时异常的子类有很多很多\",{\"1\":{\"422\":1}}],[\"编译时异常只需要继承\",{\"1\":{\"422\":1}}],[\"编译时异常明确指出可能会出现的异常\",{\"1\":{\"421\":1}}],[\"编译时异常\",{\"1\":{\"421\":1}}],[\"编译器是很聪明的\",{\"1\":{\"402\":1}}],[\"编译器不知道到底我们想用的是哪一个string类\",{\"1\":{\"277\":1}}],[\"编译后\",{\"1\":{\"356\":1,\"525\":1}}],[\"编译出来就自带\",{\"1\":{\"166\":1}}],[\"视图名\",{\"1\":{\"781\":1}}],[\"视图名称\",{\"1\":{\"779\":1}}],[\"视图本质就是一个查询的结果\",{\"1\":{\"779\":1}}],[\"视图\",{\"0\":{\"779\":1}}],[\"视图一起删除\",{\"1\":{\"751\":1}}],[\"视图解析器会对整个视图页面进行解析\",{\"1\":{\"558\":1}}],[\"视图解析器\",{\"1\":{\"558\":1}}],[\"视频等二进制数据\",{\"1\":{\"245\":1}}],[\"视为一个特殊情况下的\",{\"1\":{\"104\":1}}],[\"视为\",{\"1\":{\"104\":1,\"142\":1}}],[\"音频\",{\"1\":{\"245\":1}}],[\"图片等\",{\"1\":{\"1001\":1}}],[\"图片\",{\"1\":{\"245\":1}}],[\"适用于注解配置形式\",{\"1\":{\"1297\":1}}],[\"适用于非类路径下的xml配置文件\",{\"1\":{\"1297\":1}}],[\"适用于类路径下的xml配置文件\",{\"1\":{\"1297\":1}}],[\"适用于windows\",{\"1\":{\"732\":1}}],[\"适用于中小型\",{\"1\":{\"732\":1}}],[\"适用于处理文本文件\",{\"1\":{\"245\":1}}],[\"适用于处理所有类型的数据\",{\"1\":{\"245\":1}}],[\"适用范围\",{\"1\":{\"245\":1}}],[\"适用场景\",{\"1\":{\"245\":2}}],[\"位于此目录下的内容不会在最后被打包到项目中\",{\"1\":{\"1017\":1}}],[\"位于java\",{\"1\":{\"908\":1}}],[\"位\",{\"1\":{\"245\":2}}],[\"判断此链接是否可用\",{\"1\":{\"1247\":1}}],[\"判断用户是否登陆成功\",{\"1\":{\"1072\":1}}],[\"判断表单是否完整\",{\"1\":{\"1072\":1}}],[\"判断结果是否相等\",{\"1\":{\"969\":1}}],[\"判断测试是否成功\",{\"0\":{\"963\":1}}],[\"判断值是否存在\",{\"1\":{\"512\":1}}],[\"判断字符串是否为空或者仅包含空格\",{\"1\":{\"488\":1}}],[\"判断当前对象和给定对象是否相等\",{\"1\":{\"372\":1}}],[\"判断是否成功获取到共享的单例对象\",{\"1\":{\"1300\":1}}],[\"判断是否超过最大的使用时间\",{\"1\":{\"1246\":1}}],[\"判断是否未登陆\",{\"1\":{\"1104\":1}}],[\"判断是否为静态资源\",{\"1\":{\"1104\":1}}],[\"判断是否为子类或是接口\",{\"1\":{\"343\":1}}],[\"判断是否已经通过全部的内置过滤器\",{\"1\":{\"710\":1}}],[\"判断是否存在指定用户\",{\"1\":{\"665\":1}}],[\"判断是否存在中断标志\",{\"1\":{\"301\":1}}],[\"判断相同\",{\"1\":{\"241\":1}}],[\"判断修改成根据\",{\"1\":{\"241\":1}}],[\"判断两个值是否为同一个对象\",{\"1\":{\"971\":1}}],[\"判断两个元素是否相同\",{\"1\":{\"241\":1}}],[\"判断两个键值对是否相等\",{\"1\":{\"213\":1}}],[\"判断两个集合是否相等\",{\"1\":{\"180\":1}}],[\"汇成新的list\",{\"1\":{\"228\":1}}],[\"变成bservice\",{\"1\":{\"1119\":1}}],[\"变成我们的jsessionid值\",{\"1\":{\"642\":1}}],[\"变成独立的6个元素\",{\"1\":{\"228\":1}}],[\"变参数实际上就是一个数组\",{\"1\":{\"349\":1}}],[\"变量默认是\",{\"1\":{\"447\":1}}],[\"变量名称为jre\",{\"1\":{\"1047\":1}}],[\"变量名称\",{\"1\":{\"392\":4}}],[\"变量的值就是当前对象的存放值\",{\"1\":{\"162\":1}}],[\"变量的类型就是对应的类名\",{\"1\":{\"161\":1}}],[\"变量使用之前需要先赋值\",{\"1\":{\"161\":1}}],[\"依次来看\",{\"1\":{\"1218\":1}}],[\"依次经过handlerinterceptor有点类似于之前我们所学的过滤器\",{\"1\":{\"558\":1}}],[\"依次打印\",{\"1\":{\"228\":1}}],[\"依赖注入的配置\",{\"0\":{\"1172\":1}}],[\"依赖注入并不一定要注入其他的bean\",{\"1\":{\"1133\":1}}],[\"依赖注入要求对应的属性必须有一个set方法\",{\"1\":{\"1133\":1}}],[\"依赖注入\",{\"0\":{\"1122\":1,\"1132\":1},\"1\":{\"1132\":1,\"1309\":2,\"1311\":2}}],[\"依赖关系等等\",{\"1\":{\"1119\":1}}],[\"依赖项使用默认即可\",{\"1\":{\"1048\":1}}],[\"依赖的范围\",{\"1\":{\"1015\":1}}],[\"依赖的类型\",{\"1\":{\"1015\":1}}],[\"依赖的下载速度就会快起来了\",{\"1\":{\"1010\":1}}],[\"依赖还可以添加以下属性\",{\"1\":{\"1015\":1}}],[\"依赖作用域\",{\"0\":{\"1013\":1,\"1014\":1}}],[\"依赖导入\",{\"0\":{\"1006\":1}}],[\"依赖导入完成后\",{\"1\":{\"824\":1}}],[\"依赖管理\",{\"1\":{\"1000\":2}}],[\"依赖此模块的模块也会自动进行依赖\",{\"1\":{\"465\":1}}],[\"依赖传递\",{\"0\":{\"465\":1,\"1024\":1}}],[\"依赖于当前状态和所采取的动作\",{\"1\":{\"19\":1}}],[\"依然是提供给子类实现的\",{\"1\":{\"1320\":1}}],[\"依然是就近原则\",{\"1\":{\"408\":1}}],[\"依然可以被其他会话直接使用\",{\"1\":{\"884\":1}}],[\"依然会被反射赋值\",{\"1\":{\"841\":1}}],[\"依然返回自己\",{\"1\":{\"480\":1}}],[\"依然采用\",{\"1\":{\"451\":1}}],[\"依然使用泛型\",{\"1\":{\"439\":1}}],[\"依附任何对象我们可以直接创建使用\",{\"1\":{\"409\":1}}],[\"依附于b创建的对象\",{\"1\":{\"408\":1}}],[\"依附于a创建的对象\",{\"1\":{\"408\":1}}],[\"本地缓存\",{\"1\":{\"882\":1}}],[\"本地方法不是我们se中需要学习的内容\",{\"1\":{\"372\":1}}],[\"本地内存\",{\"1\":{\"311\":1}}],[\"本来应该进行2次自增操作\",{\"1\":{\"311\":1}}],[\"本质是\",{\"1\":{\"448\":1}}],[\"本质就是调用的构造方法\",{\"1\":{\"378\":1}}],[\"本质上也是一个bean\",{\"1\":{\"1328\":1}}],[\"本质上是在使用执行器操作数据库\",{\"1\":{\"1242\":1}}],[\"本质上是一个intstream\",{\"1\":{\"228\":1}}],[\"本质上还是类的实例进行调用\",{\"1\":{\"349\":1}}],[\"本质和普通进程类似\",{\"1\":{\"329\":1}}],[\"本质也是reader和writer\",{\"1\":{\"283\":1}}],[\"本文目的是优化无人机在每个时隙的位置\",{\"1\":{\"11\":1}}],[\"没法先造个半成品放进去\",{\"1\":{\"1181\":1}}],[\"没关系\",{\"1\":{\"710\":1}}],[\"没必要防御到这种程度\",{\"1\":{\"684\":1}}],[\"没登录是根本进不来的\",{\"1\":{\"658\":1}}],[\"没啥意义\",{\"1\":{\"386\":1}}],[\"没错\",{\"1\":{\"237\":1,\"415\":1,\"453\":1,\"498\":1}}],[\"没想到吧\",{\"1\":{\"228\":1}}],[\"没有就通过数据源新开一个connection\",{\"1\":{\"1273\":1}}],[\"没有超时\",{\"1\":{\"1246\":1}}],[\"没有出现任何的具体实现类信息\",{\"1\":{\"1133\":1}}],[\"没有明确指定依赖有效范围的话\",{\"1\":{\"1016\":1}}],[\"没有更新\",{\"1\":{\"883\":1}}],[\"没有进行任何的dml操作\",{\"1\":{\"865\":1}}],[\"没有手动配置的字段会按照之前默认的方式进行赋值\",{\"1\":{\"835\":1}}],[\"没有任何关联\",{\"1\":{\"825\":1}}],[\"没有任何一处需要引用到对象的实际类型\",{\"1\":{\"349\":1}}],[\"没有commit也成功了\",{\"1\":{\"806\":1}}],[\"没有报错\",{\"1\":{\"711\":1}}],[\"没有起始值\",{\"1\":{\"521\":1}}],[\"没有方法体\",{\"1\":{\"375\":1}}],[\"没有方法\",{\"1\":{\"364\":1}}],[\"没有的话就暂时处于休眠状态\",{\"1\":{\"324\":1}}],[\"没有使用哈希表\",{\"1\":{\"219\":1}}],[\"没有返回值\",{\"1\":{\"162\":1}}],[\"工厂bean和空bean\",{\"1\":{\"1300\":1}}],[\"工厂才能开工\",{\"1\":{\"1296\":1}}],[\"工厂并不知道自己需要生产什么\",{\"1\":{\"1296\":1}}],[\"工厂模式处理\",{\"0\":{\"1180\":1}}],[\"工厂模式和工厂bean\",{\"0\":{\"1155\":1,\"1157\":1}}],[\"工厂方法上同样有了图标\",{\"1\":{\"1159\":1}}],[\"工厂\",{\"0\":{\"1159\":1}}],[\"工厂的机器才会按照预定的流程启动\",{\"1\":{\"228\":1}}],[\"工作目录\",{\"1\":{\"1047\":1}}],[\"工作内存中存储了该线程以读\",{\"1\":{\"311\":1}}],[\"工具来实现对结果的判断但不作为测试结果的判断依据\",{\"1\":{\"974\":1}}],[\"工具类一般都会内置大量的静态方法\",{\"1\":{\"429\":1}}],[\"工具类就是专门为一些特定场景编写的\",{\"1\":{\"429\":1}}],[\"工具类\",{\"0\":{\"231\":1,\"232\":1,\"428\":1}}],[\"工具类中\",{\"1\":{\"182\":1}}],[\"工人\",{\"1\":{\"375\":1}}],[\"zstd\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"zulu\",{\"1\":{\"1047\":2}}],[\"zip\",{\"1\":{\"1047\":1}}],[\"zh\",{\"1\":{\"727\":2,\"824\":1,\"902\":1,\"1091\":2,\"1096\":2}}],[\"z0\",{\"1\":{\"403\":1}}],[\"zaxxer\",{\"1\":{\"1260\":3,\"1278\":1}}],[\"zaxxer<\",{\"1\":{\"1260\":1}}],[\"za\",{\"1\":{\"403\":1}}],[\"zo+\",{\"1\":{\"403\":1}}],[\"zoo\",{\"1\":{\"403\":2}}],[\"zo\",{\"1\":{\"403\":2}}],[\"z\",{\"1\":{\"228\":1,\"403\":5}}],[\"去获取\",{\"1\":{\"1203\":1}}],[\"去找\",{\"1\":{\"1138\":1}}],[\"去找对应的\",{\"1\":{\"631\":1}}],[\"去寻找合适的bean自动装配\",{\"1\":{\"1138\":1}}],[\"去数据库里创建一个表作为测试\",{\"1\":{\"1071\":1}}],[\"去配置文件中进行修改\",{\"1\":{\"1047\":1}}],[\"去正常访问目标网站进行登录操作\",{\"1\":{\"642\":1}}],[\"去容器里找所有\",{\"1\":{\"560\":1}}],[\"去扩展默认配置\",{\"1\":{\"553\":1}}],[\"去挂起线程的原因\",{\"1\":{\"313\":1}}],[\"去执行的\",{\"1\":{\"275\":1}}],[\"去重组合skip\",{\"1\":{\"515\":1}}],[\"去重\",{\"1\":{\"228\":2,\"476\":1}}],[\"去除尾部空格\",{\"1\":{\"488\":1}}],[\"去除首部空格\",{\"1\":{\"488\":1}}],[\"去除首尾空格\",{\"1\":{\"488\":1}}],[\"去除final标记\",{\"1\":{\"350\":1}}],[\"去除\",{\"1\":{\"228\":1}}],[\"首次调用会移动到第一行\",{\"1\":{\"797\":1}}],[\"首页<\",{\"1\":{\"636\":2}}],[\"首字母不是大写字母\",{\"1\":{\"228\":1}}],[\"首先从包中扫描所有的bean定义\",{\"1\":{\"1327\":1}}],[\"首先会调用自己的无参构造\",{\"1\":{\"1317\":1}}],[\"首先会通过\",{\"1\":{\"1310\":1}}],[\"首先扫描bean\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"首先就是如果我们获取的bean压根就没在工厂中注册\",{\"1\":{\"1301\":1}}],[\"首先直接获取单例bean对象\",{\"1\":{\"1300\":1}}],[\"首先大家能够想到的肯定是\",{\"1\":{\"1288\":1}}],[\"首先编写一个测试bean\",{\"1\":{\"1311\":1}}],[\"首先编写业务层的接口\",{\"1\":{\"1277\":1}}],[\"首先编写实体类\",{\"1\":{\"826\":1}}],[\"首先事务遵循一个acid原则\",{\"1\":{\"1266\":1}}],[\"首先验证是否有效\",{\"1\":{\"1246\":1}}],[\"首先注意\",{\"1\":{\"1245\":1}}],[\"首先这个类中定义了很多的成员\",{\"1\":{\"1244\":1}}],[\"首先在student类中创立一个task\",{\"1\":{\"1225\":1}}],[\"首先在js中编写我们的xhr请求\",{\"1\":{\"1076\":1}}],[\"首先填写id\",{\"1\":{\"1219\":1}}],[\"首先先将student类定义出来\",{\"1\":{\"1119\":1}}],[\"首先一定要明确\",{\"1\":{\"1118\":1}}],[\"首先将我们的icon\",{\"1\":{\"1074\":1}}],[\"首先将其转换为httpservletrequest\",{\"1\":{\"1057\":1}}],[\"首先设置一下响应类型\",{\"1\":{\"1072\":1}}],[\"首先name属性就是servlet名称\",{\"1\":{\"1061\":1}}],[\"首先servlet有一个直接实现抽象类genericservlet\",{\"1\":{\"1059\":1}}],[\"首先执行构造方法完成\",{\"1\":{\"1055\":1}}],[\"首先点击新建\",{\"1\":{\"1048\":1}}],[\"首先获取日志打印器\",{\"1\":{\"908\":1}}],[\"首先还是关联查询的sql语句\",{\"1\":{\"853\":1}}],[\"首先来看最简单的一对一查询\",{\"1\":{\"849\":1}}],[\"首先定义我们的实体类\",{\"1\":{\"799\":1}}],[\"首先要通过connection对象调用setautocommit\",{\"1\":{\"806\":1}}],[\"首先要明确\",{\"1\":{\"797\":1}}],[\"首先要介绍的是jsonobject\",{\"1\":{\"612\":1}}],[\"首先需要在配置文件中注册一个新的bean\",{\"1\":{\"1276\":1}}],[\"首先需要在配置类\",{\"1\":{\"695\":1}}],[\"首先需要解决的问题是\",{\"1\":{\"1218\":1}}],[\"首先需要添加一个环境变量\",{\"1\":{\"773\":1}}],[\"首先需要配置一下jdbcuserdetailsmanager\",{\"1\":{\"666\":1}}],[\"首先创建一个对应的实体类\",{\"1\":{\"669\":1}}],[\"首先是读未提交级别\",{\"1\":{\"1268\":1}}],[\"首先是关联查询的sql语句\",{\"1\":{\"850\":1}}],[\"首先是传统方式\",{\"1\":{\"810\":1}}],[\"首先是响应头\",{\"1\":{\"727\":1}}],[\"首先是登录界面部分\",{\"1\":{\"636\":1}}],[\"首先是前端页面\",{\"1\":{\"617\":1}}],[\"首先我们大致了解一下applicationcontext的加载流程\",{\"1\":{\"1295\":1}}],[\"首先我们要知道\",{\"1\":{\"1109\":1}}],[\"首先我们要明确\",{\"1\":{\"734\":1,\"1217\":1}}],[\"首先我们编写前端部分\",{\"1\":{\"1075\":1}}],[\"首先我们来看看它是如何实现接口方法的\",{\"1\":{\"1245\":1}}],[\"首先我们来看看比较简单的下载文件\",{\"1\":{\"1074\":1}}],[\"首先我们来看看最简单的基于内存的配置\",{\"1\":{\"657\":1}}],[\"首先我们的请求肯定会经过httpservlet\",{\"1\":{\"626\":1}}],[\"首先我们需要创建一个数据源的实现类\",{\"1\":{\"1259\":1}}],[\"首先我们需要在主类添加\",{\"1\":{\"1232\":1}}],[\"首先我们需要在resource中创建一个spring配置文件\",{\"1\":{\"1119\":1}}],[\"首先我们需要将一个类实现advice接口\",{\"1\":{\"1231\":1}}],[\"首先我们需要引入这个配置文件\",{\"1\":{\"1198\":1}}],[\"首先我们需要知道如何配置bean并注册\",{\"1\":{\"1125\":1}}],[\"首先我们需要指定select操作的id\",{\"1\":{\"831\":1}}],[\"首先我们需要导入lombok的jar依赖\",{\"1\":{\"811\":1}}],[\"首先我们需要导入springsecurity的相关依赖\",{\"1\":{\"649\":1}}],[\"首先我们需要对数据库中的角色表进行一些修改\",{\"1\":{\"692\":1}}],[\"首先我们需要找到dispatcherservlet的最顶层httpservletbean\",{\"1\":{\"625\":1}}],[\"首先我们需要实现最基本的页面解析并返回\",{\"1\":{\"559\":1}}],[\"首先我们需要添加mvc相关依赖\",{\"1\":{\"544\":1}}],[\"首先我们在项目a中\",{\"1\":{\"464\":1}}],[\"首先\",{\"1\":{\"534\":1,\"1058\":1,\"1260\":1,\"1296\":1}}],[\"首先判断是否为student类型\",{\"1\":{\"499\":1}}],[\"首先模块具有四种类型\",{\"1\":{\"463\":1}}],[\"首先方法参数类型是可以省略的\",{\"1\":{\"447\":1}}],[\"首先实现cloneable接口\",{\"1\":{\"377\":1}}],[\"首先利用jps找到我们的java进程号\",{\"1\":{\"313\":1}}],[\"首先初始化一个随机的策略π0​\",{\"1\":{\"79\":1}}],[\"首先随机设计一个初始的策略π0​\",{\"1\":{\"66\":1}}],[\"过期\",{\"1\":{\"1246\":1}}],[\"过多的使用反射\",{\"1\":{\"349\":1}}],[\"过滤器相当于在所有访问前加了一堵墙\",{\"1\":{\"1101\":1}}],[\"过滤器名称\",{\"1\":{\"714\":1}}],[\"过滤换行符之类的内容\",{\"1\":{\"819\":1}}],[\"过滤流程是由springsecurity自己实现的\",{\"1\":{\"708\":1}}],[\"过滤等\",{\"1\":{\"515\":1}}],[\"过滤和映射数据等操作\",{\"1\":{\"513\":1}}],[\"过滤\",{\"0\":{\"518\":1,\"699\":1},\"1\":{\"228\":2}}],[\"过去研究主要考虑的是2d部署\",{\"1\":{\"4\":1}}],[\"过去研究大多没有基于用户的移动\",{\"1\":{\"4\":1}}],[\"流水线上的一套操作必须环环相扣\",{\"1\":{\"1116\":1}}],[\"流才开始真正地遍历\",{\"1\":{\"515\":1}}],[\"流在中间处理过程中\",{\"1\":{\"514\":1}}],[\"流在管道中传输\",{\"1\":{\"228\":1}}],[\"流的内容是有限的\",{\"1\":{\"248\":1}}],[\"流stream\",{\"1\":{\"228\":1}}],[\"简称sql\",{\"1\":{\"744\":1}}],[\"简化了我们手动转换的步骤\",{\"1\":{\"499\":1}}],[\"简洁的装配\",{\"1\":{\"1196\":1}}],[\"简洁的代码\",{\"1\":{\"228\":1}}],[\"简洁一些了\",{\"1\":{\"490\":1}}],[\"简单粗暴\",{\"1\":{\"1271\":1}}],[\"简单说它就是java与数据库的连接的桥梁或者插件\",{\"1\":{\"787\":1}}],[\"简单重置密码接口\",{\"0\":{\"666\":1}}],[\"简单来说\",{\"1\":{\"642\":1,\"872\":1,\"1186\":1,\"1266\":1}}],[\"简单使用\",{\"0\":{\"468\":1,\"1091\":1}}],[\"简单理解为\",{\"1\":{\"337\":1}}],[\"简而言之\",{\"1\":{\"336\":1,\"732\":1,\"735\":1}}],[\"简介与项目结构\",{\"0\":{\"998\":1,\"999\":1}}],[\"简介\",{\"0\":{\"188\":1,\"460\":1,\"732\":1,\"1000\":1,\"1113\":1}}],[\"语文\",{\"1\":{\"1136\":1}}],[\"语句时\",{\"1\":{\"884\":1}}],[\"语句有多痛苦\",{\"1\":{\"872\":1}}],[\"语句\",{\"0\":{\"744\":1},\"1\":{\"744\":1}}],[\"语句块进行异常的捕获\",{\"1\":{\"424\":1}}],[\"语句块来处理\",{\"1\":{\"424\":1}}],[\"语句从数据库查询数据的直观方式来提供一种对\",{\"1\":{\"228\":1}}],[\"语法与java比较相似\",{\"1\":{\"873\":1}}],[\"语法树会被分析并转化成类文件\",{\"1\":{\"811\":1}}],[\"语法那是相当的简洁\",{\"1\":{\"496\":1}}],[\"语法\",{\"1\":{\"187\":1,\"193\":1}}],[\"利用这种机制\",{\"1\":{\"1310\":1}}],[\"利用这种特性\",{\"1\":{\"201\":1}}],[\"利用动态\",{\"1\":{\"872\":1}}],[\"利用springmvc\",{\"1\":{\"618\":1}}],[\"利用全新的客户端\",{\"1\":{\"490\":1}}],[\"利用\",{\"0\":{\"478\":1},\"1\":{\"631\":1}}],[\"利用反射之后\",{\"1\":{\"349\":1}}],[\"利用了\",{\"1\":{\"224\":1}}],[\"你可以在这里动态添加bean定义或是修改已经存在的bean定义\",{\"1\":{\"1311\":1}}],[\"你还可以使用cron表达式来指定任务计划\",{\"1\":{\"1190\":1}}],[\"你还可以直接声明一个自定义方法来进行判断\",{\"1\":{\"980\":1}}],[\"你们就没有一点错吗\",{\"1\":{\"1023\":1}}],[\"你干嘛\",{\"1\":{\"929\":3,\"1207\":1}}],[\"你应该能理解根据不同条件拼接\",{\"1\":{\"872\":1}}],[\"你也可以认为这就是之前jdbc中的statement对象\",{\"1\":{\"825\":1}}],[\"你一旦使用这个id登录\",{\"1\":{\"642\":1}}],[\"你的号已经在别人手中了\",{\"1\":{\"641\":1}}],[\"你看\",{\"1\":{\"402\":2}}],[\"你会发现惊喜\",{\"1\":{\"1189\":1}}],[\"你会发现\",{\"1\":{\"516\":1}}],[\"你会发现它更像一个sql语句\",{\"1\":{\"228\":1}}],[\"你会发现所有的方法全是替身攻击\",{\"1\":{\"224\":1}}],[\"你只需要坐着等别人写好然后你自己拿去交差就行了\",{\"1\":{\"224\":1}}],[\"你没看错\",{\"1\":{\"224\":1}}],[\"玛卡\",{\"1\":{\"223\":1}}],[\"巴卡\",{\"1\":{\"223\":1}}],[\"若未初始化驱动\",{\"1\":{\"1244\":1}}],[\"若超过此时间\",{\"1\":{\"1097\":1}}],[\"若勾选了勾选框\",{\"1\":{\"1093\":1}}],[\"若查询到信息则表示存在此用户\",{\"1\":{\"1072\":1}}],[\"若没问题\",{\"1\":{\"1047\":1}}],[\"若此字段被填入了构造方法作为参数\",{\"1\":{\"841\":1}}],[\"若此文件不存在\",{\"1\":{\"249\":1}}],[\"若视图定义中有嵌套查询\",{\"1\":{\"779\":1}}],[\"若视图定义中含有distinct短语\",{\"1\":{\"779\":1}}],[\"若视图定义中含有group\",{\"1\":{\"779\":1}}],[\"若视图的字段来自集函数\",{\"1\":{\"779\":1}}],[\"若视图的字段来自字段表达式或常数\",{\"1\":{\"779\":1}}],[\"若视图是由两个以上基本表导出的\",{\"1\":{\"779\":1}}],[\"若不存在则计算并插入新的值\",{\"1\":{\"221\":1}}],[\"若key不存在\",{\"1\":{\"221\":1}}],[\"若\",{\"1\":{\"221\":1}}],[\"若有一系列\",{\"1\":{\"75\":1}}],[\"具有给定注释的连接点匹配的限制\",{\"1\":{\"1219\":1}}],[\"具有\",{\"1\":{\"218\":1}}],[\"具体加载过程我就不详细介绍了\",{\"1\":{\"1297\":1}}],[\"具体例子\",{\"1\":{\"1167\":1}}],[\"具体实现由ioc容器提供\",{\"1\":{\"1117\":1}}],[\"具体实现克隆\",{\"1\":{\"377\":1}}],[\"具体内容是保存在服务器端的\",{\"1\":{\"1095\":1}}],[\"具体内部过滤器举例\",{\"0\":{\"711\":1}}],[\"具体操作\",{\"1\":{\"525\":1}}],[\"具体示例\",{\"1\":{\"510\":1}}],[\"具体请回顾一下javase篇视频教程\",{\"1\":{\"453\":1}}],[\"具体规范\",{\"0\":{\"447\":1}}],[\"具体的实现有两个\",{\"1\":{\"1132\":1}}],[\"具体的实现逻辑\",{\"1\":{\"445\":1}}],[\"具体的实现由\",{\"1\":{\"375\":1}}],[\"具体类型不同的泛型类变量\",{\"1\":{\"438\":1}}],[\"具体类型只能是我们指定的上界类型或是上界类型的子类\",{\"1\":{\"172\":1}}],[\"具体使用\",{\"0\":{\"1169\":1},\"1\":{\"438\":1}}],[\"具体而言\",{\"1\":{\"162\":1}}],[\"具体推导过程\",{\"1\":{\"155\":1}}],[\"具体解决如下\",{\"1\":{\"97\":1}}],[\"具体求解方法\",{\"1\":{\"79\":1}}],[\"具体算法\",{\"0\":{\"79\":1}}],[\"具体步骤\",{\"0\":{\"63\":1}}],[\"具体分两步\",{\"1\":{\"56\":1}}],[\"具体代码\",{\"1\":{\"13\":1}}],[\"具体表述如下\",{\"1\":{\"11\":1}}],[\"具体如下\",{\"1\":{\"10\":1,\"142\":1}}],[\"原方法该干嘛干嘛\",{\"1\":{\"1247\":1}}],[\"原型\",{\"0\":{\"1171\":1},\"1\":{\"1181\":2}}],[\"原型模式下\",{\"1\":{\"1129\":1}}],[\"原理\",{\"0\":{\"1095\":1,\"1189\":1,\"1358\":1}}],[\"原理其实很简单\",{\"1\":{\"642\":1}}],[\"原子性\",{\"1\":{\"782\":1,\"1266\":1}}],[\"原本java应该这样写\",{\"1\":{\"877\":1}}],[\"原本需要完整编写包括类\",{\"1\":{\"446\":1}}],[\"原本就有的\",{\"1\":{\"194\":3}}],[\"原因很多\",{\"1\":{\"217\":1}}],[\"阈值为负载因子乘以默认容量\",{\"1\":{\"217\":1}}],[\"新建项目\",{\"1\":{\"1048\":1}}],[\"新建模块\",{\"1\":{\"1032\":1}}],[\"新建一个类\",{\"1\":{\"944\":1}}],[\"新建名为testmapper\",{\"1\":{\"826\":1}}],[\"新建module\",{\"1\":{\"461\":1}}],[\"新文件也要进行编译\",{\"1\":{\"811\":1}}],[\"新数据类型\",{\"1\":{\"751\":1}}],[\"新列名\",{\"1\":{\"751\":1}}],[\"新版本全部采用lambda形式进行配置\",{\"1\":{\"680\":1}}],[\"新密码\",{\"1\":{\"666\":1}}],[\"新增图书\",{\"1\":{\"691\":1}}],[\"新增的一个函数式接口\",{\"1\":{\"519\":1}}],[\"新增操作\",{\"1\":{\"214\":1}}],[\"新语法\",{\"0\":{\"496\":1}}],[\"新特性\",{\"0\":{\"494\":1,\"502\":1}}],[\"新的内容会出现在new表中\",{\"1\":{\"781\":1}}],[\"新的内容会被插入到new表中\",{\"1\":{\"781\":1}}],[\"新的流中的内容被修改为对应字符串的长度\",{\"1\":{\"519\":1}}],[\"新的instanceof语法在java\",{\"1\":{\"499\":1}}],[\"新的instanceof语法\",{\"0\":{\"499\":1}}],[\"新的switch语法\",{\"0\":{\"495\":1}}],[\"新的api支持最新的http2和websocket协议\",{\"1\":{\"489\":1}}],[\"新的容量直接等于默认容量16\",{\"1\":{\"217\":1}}],[\"新的容量等于旧容量的2倍\",{\"1\":{\"217\":1}}],[\"新的阈值也提升到原来的两倍\",{\"1\":{\"217\":1}}],[\"此接口中包括两个方法\",{\"1\":{\"1307\":1}}],[\"此级别属于最低级别\",{\"1\":{\"1268\":1}}],[\"此数据源实际上是采用了slf4j日志框架打印日志信息\",{\"1\":{\"1260\":1}}],[\"此对象是在构造时就被创建\",{\"1\":{\"1245\":1}}],[\"此对象也能设置附加值\",{\"1\":{\"1084\":1}}],[\"此加载器可能会存在多个实例\",{\"1\":{\"1109\":1}}],[\"此加载器可能存在多个实例\",{\"1\":{\"1109\":1}}],[\"此属性表示\",{\"1\":{\"1082\":1}}],[\"此属性决定了是否在tomcat启动时就加载此servlet\",{\"1\":{\"1064\":1}}],[\"此路径的意思为\",{\"1\":{\"1062\":1}}],[\"此路径和tomcat默认为我们提供的servlet冲突\",{\"1\":{\"1062\":1}}],[\"此依赖也被一起传递\",{\"1\":{\"1024\":1}}],[\"此范围表示在编译\",{\"1\":{\"1016\":1}}],[\"此测试案例才会启动\",{\"1\":{\"976\":1}}],[\"此测试案例并未抛出指定异常\",{\"1\":{\"973\":1}}],[\"此缓冲区大小为\",{\"1\":{\"721\":1}}],[\"此类\",{\"1\":{\"714\":1}}],[\"此过程是不可逆的\",{\"1\":{\"659\":1}}],[\"此用户能够做哪些事情\",{\"1\":{\"635\":1}}],[\"此初始化阶段由子类实现\",{\"1\":{\"625\":1}}],[\"此注解表示事务\",{\"1\":{\"1277\":1}}],[\"此注解就是将请求和处理请求的方法建立一个映射关系\",{\"1\":{\"569\":1}}],[\"此注解在编译时会被自动丢弃\",{\"1\":{\"360\":1}}],[\"此模块暴露了com\",{\"1\":{\"467\":1}}],[\"此方法返回给我们一个resultset对象\",{\"1\":{\"791\":1}}],[\"此方法返回值为void\",{\"1\":{\"447\":1}}],[\"此方法会在启动时被调用\",{\"1\":{\"705\":1}}],[\"此方法会直接终止此线程\",{\"1\":{\"299\":1}}],[\"此方法可以根据情况忽略某些地址的csrf校验\",{\"1\":{\"684\":1}}],[\"此方法可以直接关闭全部的csrf校验\",{\"1\":{\"684\":1}}],[\"此方法由dispatcherservlet实现\",{\"1\":{\"625\":1}}],[\"此外也可以用\",{\"1\":{\"854\":1}}],[\"此外大多数浏览器仍允许通过xmlhttp对象读取http响应中的set\",{\"1\":{\"642\":1}}],[\"此外\",{\"1\":{\"343\":1}}],[\"此外在每次扩容时会调用\",{\"1\":{\"217\":1}}],[\"此文件是否存在\",{\"1\":{\"255\":1}}],[\"此时显然是同步的\",{\"1\":{\"1225\":1}}],[\"此时可以看到\",{\"1\":{\"1159\":1}}],[\"此时可以分析每一个状态在这个策略下的概率\",{\"1\":{\"135\":1}}],[\"此时student有一个工厂\",{\"1\":{\"1158\":1}}],[\"此时set方法旁边会出现一个自动装配图标\",{\"1\":{\"1138\":1}}],[\"此时容器内存放的bean也会被一起销毁\",{\"1\":{\"1148\":2}}],[\"此时自动装配候选就只剩下一个唯一的bean了\",{\"1\":{\"1140\":1}}],[\"此时ioc容器不知道给我们返回哪一个bean\",{\"1\":{\"1126\":1}}],[\"此时idea会提示我们可以运行\",{\"1\":{\"959\":1}}],[\"此时有\",{\"1\":{\"1119\":1}}],[\"此时来了个把功能实现的更好的d\",{\"1\":{\"1116\":1}}],[\"此时父项目不会打包成\",{\"1\":{\"1038\":1}}],[\"此时会出现两个文件\",{\"1\":{\"1037\":1}}],[\"此时会重复执行10次此案例\",{\"1\":{\"990\":1}}],[\"此时jar包中已经包含了我们项目中编写的类了\",{\"1\":{\"1036\":1}}],[\"此时在引入此项目的其他项目中\",{\"1\":{\"1024\":1}}],[\"此时测试的结果展示也是嵌套的样式\",{\"1\":{\"988\":1}}],[\"此时控制台就会得到\",{\"1\":{\"969\":1}}],[\"此时再次全部运行\",{\"1\":{\"960\":1}}],[\"此时再调用next将不能再得到下一个元素\",{\"1\":{\"188\":1}}],[\"此时日志文件中写入的内容就是简单的日志格式了\",{\"1\":{\"921\":1}}],[\"此时日志中可以看到mybatis在尽可能优化我们的sql操作\",{\"1\":{\"871\":1}}],[\"此时打印的列表中不存在任何handler对象\",{\"1\":{\"918\":1}}],[\"此时低于info的所有日志都是被屏蔽的\",{\"1\":{\"912\":1}}],[\"此时该如何像之前一样配置resultmap呢\",{\"1\":{\"898\":1}}],[\"此时该trajectory的return=0+0+0+1+1+⋯=∞\",{\"1\":{\"19\":1}}],[\"此时动态sql就能很轻松实现这个操作\",{\"1\":{\"873\":1}}],[\"此时由于我们更新了数据库中的数据\",{\"1\":{\"883\":1}}],[\"此时由于数据被删除\",{\"1\":{\"865\":1}}],[\"此时由于出现了多行数据\",{\"1\":{\"853\":1}}],[\"此时由于类中存在多个构造方法\",{\"1\":{\"841\":1}}],[\"此时由于三个属性完全一致\",{\"1\":{\"373\":1}}],[\"此时提交的表单中就已经包含记住我字段了\",{\"1\":{\"686\":1}}],[\"此时我们可以看到\",{\"1\":{\"1172\":1}}],[\"此时我们可以使用嵌套测试\",{\"1\":{\"988\":1}}],[\"此时我们就只能先将其注册为bean了\",{\"1\":{\"1159\":1}}],[\"此时我们就可以使用环绕方法\",{\"1\":{\"1224\":1}}],[\"此时我们就可以使用重复测试案例来使其多次执行\",{\"1\":{\"990\":1}}],[\"此时我们就可以在配置文件中为工厂bean配置依赖注入等内容了\",{\"1\":{\"1159\":1}}],[\"此时我们就可以将它的自动装配候选关闭\",{\"1\":{\"1140\":1}}],[\"此时我们再去进行获取\",{\"1\":{\"1158\":1}}],[\"此时我们创建了一个sportstudent的bean\",{\"1\":{\"1149\":1}}],[\"此时我们希望使用的是二号构造方法\",{\"1\":{\"1135\":1}}],[\"此时我们去配置文件注册好对应的aservice的bean\",{\"1\":{\"1119\":1}}],[\"此时我们通过这种方式手动排除了test项目中包含的mybatis依赖\",{\"1\":{\"1026\":1}}],[\"此时我们查询所有用户信息的时候\",{\"1\":{\"855\":1}}],[\"此时我们得编写自定义验证\",{\"1\":{\"667\":1}}],[\"此时我们回到一开始的浏览器\",{\"1\":{\"642\":1}}],[\"此时我们怎么去明确要使用的是哪一个\",{\"1\":{\"408\":1}}],[\"此时需要登录\",{\"1\":{\"642\":1}}],[\"此时返回的类型和起始值类型一致\",{\"1\":{\"521\":1}}],[\"此时返回\",{\"1\":{\"521\":1}}],[\"此时参数\",{\"1\":{\"519\":1}}],[\"此时就可以实现异步\",{\"1\":{\"1225\":1}}],[\"此时就可以使用properties文件\",{\"1\":{\"936\":1}}],[\"此时就不会使用默认的情况\",{\"1\":{\"452\":1}}],[\"此时就是随机策略\",{\"1\":{\"87\":1}}],[\"此时发生异常再往上抛出的话\",{\"1\":{\"424\":1}}],[\"此时这里创建出来的student对象\",{\"1\":{\"412\":1}}],[\"此时消费者在等待生产者往货架上生产产品\",{\"1\":{\"331\":1}}],[\"此时获取键为3的值\",{\"1\":{\"214\":1}}],[\"此时元素成功被移除\",{\"1\":{\"182\":1}}],[\"此时虽然使用的是通配符\",{\"1\":{\"172\":1}}],[\"此时this\",{\"1\":{\"166\":1}}],[\"此时变量没有引用任何对象\",{\"1\":{\"161\":1}}],[\"此时也可以是\",{\"1\":{\"124\":1}}],[\"此时\",{\"1\":{\"46\":1,\"77\":1,\"125\":1,\"451\":1,\"1140\":1,\"1149\":1,\"1174\":1,\"1224\":1}}],[\"此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​\",{\"1\":{\"19\":1}}],[\"此时的mos模型定义如下\",{\"1\":{\"10\":1}}],[\"正在代理的应用程序对象\",{\"1\":{\"1219\":1}}],[\"正在等待客户端连接\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"正式发布项目一般只带版本号\",{\"1\":{\"1003\":1}}],[\"正是因为这样\",{\"1\":{\"1296\":1}}],[\"正是csrftoken\",{\"1\":{\"660\":1}}],[\"正是得益于spring框架\",{\"1\":{\"586\":1}}],[\"正是这三大特性\",{\"1\":{\"369\":1}}],[\"正好匹配了接口中的\",{\"1\":{\"453\":1}}],[\"正好匹配了compareto方法\",{\"1\":{\"451\":1}}],[\"正好可以匹配\",{\"1\":{\"403\":1}}],[\"正则表达式并不是只有java才支持\",{\"1\":{\"403\":1}}],[\"正则表达式\",{\"0\":{\"389\":1,\"403\":1},\"1\":{\"403\":2}}],[\"正常情况还是转发给默认的servlet帮我们返回静态页面\",{\"1\":{\"1093\":1}}],[\"正常情况下是不会出错的\",{\"1\":{\"421\":1}}],[\"正常情况下\",{\"1\":{\"343\":1,\"412\":1,\"643\":1}}],[\"正常实例化方法是无法创造抽象类的实例\",{\"1\":{\"375\":1}}],[\"正常插入键值对返回值为null\",{\"1\":{\"216\":1}}],[\"正确性和收敛性分析\",{\"0\":{\"104\":1}}],[\"键的名称我们也可以分为多级进行配置\",{\"1\":{\"936\":1}}],[\"键名称为\",{\"1\":{\"660\":1}}],[\"键值对size计数自增\",{\"1\":{\"216\":1}}],[\"键也相同\",{\"1\":{\"216\":1}}],[\"达到了阈值\",{\"1\":{\"216\":1}}],[\"找jar包花了点时间\",{\"1\":{\"958\":1}}],[\"找到需要切入的类\",{\"1\":{\"1218\":1}}],[\"找到logging\",{\"1\":{\"1047\":1}}],[\"找到mirros标签\",{\"1\":{\"1010\":1}}],[\"找到settings\",{\"1\":{\"1010\":1}}],[\"找到安装根目录\",{\"1\":{\"1010\":1}}],[\"找到可以处理的handleradapter\",{\"1\":{\"626\":1}}],[\"找到尾部\",{\"1\":{\"216\":1}}],[\"找不到handlermapping则无法进行处理\",{\"1\":{\"626\":1}}],[\"找的是在所有可能策略中的最优策略\",{\"1\":{\"88\":1}}],[\"普通html文本使用text\",{\"1\":{\"1058\":1}}],[\"普通用户只能访问index页面\",{\"1\":{\"692\":1}}],[\"普通用户和管理员\",{\"1\":{\"692\":1}}],[\"普通群成员\",{\"1\":{\"691\":1}}],[\"普通群成员则只能进行最基本的聊天操作\",{\"1\":{\"691\":1}}],[\"普通的信息\",{\"1\":{\"911\":1}}],[\"普通的\",{\"1\":{\"816\":1}}],[\"普通的类也可以\",{\"1\":{\"412\":1}}],[\"普通的list只需要一个方法就可以直接转换到方便好用的intstream了\",{\"1\":{\"228\":1}}],[\"普通链表就直接在链表尾部插入\",{\"1\":{\"216\":1}}],[\"普通队列中从队尾入队\",{\"1\":{\"201\":1}}],[\"说明它应该具有这些beanfactory的能力\",{\"1\":{\"1316\":1}}],[\"说明编码格式配置有问题\",{\"1\":{\"1047\":1}}],[\"说明哪个模块导入的依赖只能哪个模块用\",{\"1\":{\"465\":1}}],[\"说明这种情况下\",{\"1\":{\"411\":1}}],[\"说明这个链表已经升级为红黑树了\",{\"1\":{\"216\":1}}],[\"说明外部希望当前线程立即停止\",{\"1\":{\"301\":1}}],[\"说明已经存放了相同键的键值对了\",{\"1\":{\"216\":1}}],[\"先从第一层列表中拿bean实例\",{\"1\":{\"1301\":1}}],[\"先从活跃列表移除此连接\",{\"1\":{\"1247\":1}}],[\"先从abstractsecuritywebapplicationinitializer开始下手\",{\"1\":{\"705\":1}}],[\"先来看第一步\",{\"1\":{\"1318\":1}}],[\"先来把锁\",{\"1\":{\"1247\":1}}],[\"先来10个\",{\"1\":{\"490\":1}}],[\"先换回之前的xml配置模式\",{\"1\":{\"1217\":1}}],[\"先看对应请求是否支持http协议的实现\",{\"1\":{\"1059\":1}}],[\"先子logger\",{\"1\":{\"929\":1}}],[\"先进先出\",{\"1\":{\"884\":1}}],[\"先创建一个内联函数\",{\"1\":{\"708\":1}}],[\"先拦截\",{\"1\":{\"601\":1}}],[\"先找好我们要截取的前面一段\",{\"1\":{\"490\":1}}],[\"先不要一次性获取太多\",{\"1\":{\"490\":1}}],[\"先定义一个a=10和b=10\",{\"1\":{\"473\":1}}],[\"先实现未实现的方法\",{\"1\":{\"412\":1}}],[\"先转换为当前类型\",{\"1\":{\"373\":1}}],[\"先写好我们定义的类\",{\"1\":{\"356\":1}}],[\"先加载\",{\"1\":{\"337\":1}}],[\"先完成线程1的内容\",{\"1\":{\"305\":1}}],[\"先把下面这几个旧的东西保存一下\",{\"1\":{\"217\":1}}],[\"先初始化\",{\"1\":{\"216\":1}}],[\"先根据当前策略计算出各个状态的\",{\"1\":{\"77\":1}}],[\"哈希表的大小并不是一直不变的\",{\"1\":{\"215\":1}}],[\"哈希表可能会出现哈希冲突\",{\"1\":{\"215\":1}}],[\"哈希表\",{\"1\":{\"215\":1}}],[\"备胎\",{\"1\":{\"214\":1}}],[\"体系下的接口\",{\"1\":{\"212\":1}}],[\"映射语句来加载期望的复杂类型\",{\"1\":{\"849\":1}}],[\"映射成数据库中的记录\",{\"1\":{\"816\":1}}],[\"映射\",{\"0\":{\"519\":1}}],[\"映射map\",{\"1\":{\"515\":1}}],[\"映射指两个元素的之间相互\",{\"1\":{\"212\":1}}],[\"映射等数据结构\",{\"1\":{\"178\":1}}],[\"底层其实还是依赖\",{\"1\":{\"619\":1}}],[\"底层c++写的\",{\"1\":{\"392\":1}}],[\"底层是由c++实现的\",{\"1\":{\"372\":1}}],[\"底层是直接用\",{\"1\":{\"224\":1}}],[\"底层直接用\",{\"1\":{\"224\":1}}],[\"底层哈希表的长度永远是2的n次方\",{\"1\":{\"216\":1}}],[\"底层实现\",{\"0\":{\"215\":1,\"224\":1}}],[\"底层采用哈希表实现\",{\"1\":{\"214\":2}}],[\"底层维护的不再是一个\",{\"1\":{\"206\":1}}],[\"底层就是采用数组实现的\",{\"1\":{\"182\":1}}],[\"篇视频教程中学习大顶堆和小顶堆\",{\"1\":{\"203\":1}}],[\"栈相关操作已经帮助我们定义好了\",{\"1\":{\"201\":1}}],[\"队首出队\",{\"1\":{\"201\":1}}],[\"队列中继承下来的方法操作是一样的\",{\"1\":{\"201\":1}}],[\"队列的添加操作\",{\"1\":{\"200\":1}}],[\"队列\",{\"0\":{\"200\":1,\"202\":1},\"1\":{\"178\":1}}],[\"测试了\",{\"1\":{\"1181\":1}}],[\"测试后发现\",{\"1\":{\"1069\":1}}],[\"测试方法上必须标注\",{\"1\":{\"1035\":1}}],[\"测试类的名称必须是以test结尾\",{\"1\":{\"1035\":1}}],[\"测试类的生命周期\",{\"0\":{\"986\":1}}],[\"测试和打包\",{\"0\":{\"1029\":1,\"1030\":1}}],[\"测试导入\",{\"0\":{\"1017\":1}}],[\"测试时有效\",{\"1\":{\"1016\":2}}],[\"测试时均有效\",{\"1\":{\"1016\":1}}],[\"测试代码不会打包到项目里面\",{\"1\":{\"1001\":1}}],[\"测试顺序控制\",{\"0\":{\"987\":1}}],[\"测试结果中会将其显示为已忽略\",{\"1\":{\"974\":1}}],[\"测试自定义名称\",{\"0\":{\"961\":1}}],[\"测试环境搭建\",{\"0\":{\"636\":1}}],[\"测试\",{\"0\":{\"549\":1,\"1221\":1,\"1256\":1,\"1278\":1},\"1\":{\"193\":1,\"350\":1,\"1000\":1,\"1017\":1,\"1277\":1}}],[\"测试阶段\",{\"1\":{\"14\":1}}],[\"得加个\",{\"1\":{\"1328\":1}}],[\"得在getbean\",{\"1\":{\"1328\":1}}],[\"得挨个进行修改\",{\"1\":{\"1116\":1}}],[\"得益于泛型的类型擦除机制\",{\"1\":{\"237\":1}}],[\"得益于\",{\"1\":{\"193\":1}}],[\"得到factorybean调用getobject\",{\"1\":{\"1328\":1}}],[\"得到factorybean本身\",{\"1\":{\"1328\":1}}],[\"得到bean定义\",{\"1\":{\"1321\":1}}],[\"得到单例对象后\",{\"1\":{\"1301\":1}}],[\"得到对应的session对象\",{\"1\":{\"1095\":1}}],[\"得到日志的打印结果\",{\"1\":{\"908\":1}}],[\"得到json格式数据\",{\"1\":{\"615\":1}}],[\"得到整理拦截器的执行顺序\",{\"1\":{\"597\":1}}],[\"得到最终的页面并返回给前端\",{\"1\":{\"541\":1}}],[\"得到最终的图片地址\",{\"1\":{\"490\":1}}],[\"得到true\",{\"1\":{\"501\":1}}],[\"得到一个字符串数组\",{\"1\":{\"401\":1}}],[\"得到一个克隆的对象\",{\"1\":{\"377\":1}}],[\"得到一个class文件\",{\"1\":{\"356\":1}}],[\"得到一个method对象\",{\"1\":{\"349\":1}}],[\"得到一个样本序列x1​\",{\"1\":{\"75\":1}}],[\"得到结果是一样的\",{\"1\":{\"851\":1}}],[\"得到结果如下\",{\"1\":{\"600\":1}}],[\"得到结果\",{\"1\":{\"228\":1,\"768\":1}}],[\"得到前面处理的结果\",{\"1\":{\"228\":1}}],[\"得到含有噪音的观测值序列\",{\"1\":{\"97\":1}}],[\"得到的结果是出现错误\",{\"1\":{\"1278\":1}}],[\"得到的结果为\",{\"1\":{\"613\":1}}],[\"得到的bean依然是对应对象的bean\",{\"1\":{\"1158\":1}}],[\"得到的类名称很奇怪class\",{\"1\":{\"842\":1}}],[\"得到的class也是string类型\",{\"1\":{\"485\":1}}],[\"得到的会是同一个对象\",{\"1\":{\"384\":1}}],[\"得到的是包名+类名的完整名称\",{\"1\":{\"341\":1}}],[\"得到的\",{\"1\":{\"84\":1,\"241\":1}}],[\"得到\",{\"1\":{\"68\":1}}],[\"介绍一下postprocessor\",{\"1\":{\"1306\":1}}],[\"介绍\",{\"0\":{\"193\":1,\"194\":1,\"463\":1}}],[\"调整\",{\"0\":{\"894\":1}}],[\"调整为限制的大小\",{\"1\":{\"182\":1}}],[\"调度\",{\"0\":{\"626\":1}}],[\"调用string的touppercase方法\",{\"1\":{\"1202\":1}}],[\"调用同步执行的任务了\",{\"1\":{\"1188\":1}}],[\"调用后\",{\"1\":{\"1082\":1}}],[\"调用info来输出一个普通的信息\",{\"1\":{\"908\":1}}],[\"调用此操作将直接导致一级和二级缓存被清除\",{\"1\":{\"887\":1}}],[\"调用此方法\",{\"1\":{\"525\":1}}],[\"调用此方法时也会获取锁\",{\"1\":{\"312\":1}}],[\"调用此方法后\",{\"1\":{\"301\":1}}],[\"调用此方法来开始执行此线程\",{\"1\":{\"297\":1}}],[\"调用注解处理器\",{\"1\":{\"811\":1}}],[\"调用无参构造\",{\"0\":{\"1318\":1}}],[\"调用无参构造不会自动连接\",{\"1\":{\"721\":1}}],[\"调用无参构造方法不会自动连接\",{\"1\":{\"721\":1}}],[\"调用默认或是我们自己定义的authenticationfailurehandler\",{\"1\":{\"713\":1}}],[\"调用默认的或是我们自己定义的authenticationsuccesshandler的onauthenticationsuccess方法\",{\"1\":{\"712\":1}}],[\"调用虚拟过滤链的dofilter\",{\"1\":{\"708\":1}}],[\"调用get\",{\"1\":{\"512\":1}}],[\"调用\",{\"1\":{\"415\":1,\"1055\":1}}],[\"调用clone方法\",{\"1\":{\"377\":1}}],[\"调用consumer的accept来对每一个元素进行消费\",{\"1\":{\"192\":1}}],[\"调用父类的实现\",{\"1\":{\"373\":1}}],[\"调用protected方法\",{\"1\":{\"356\":1}}],[\"调用类方法\",{\"0\":{\"349\":1}}],[\"调用类的静态方法\",{\"1\":{\"275\":1}}],[\"调用方法\",{\"1\":{\"348\":1}}],[\"调用t的interrupt方法\",{\"1\":{\"301\":1}}],[\"调用时的位置\",{\"1\":{\"265\":1}}],[\"调用resize进行扩容\",{\"1\":{\"216\":1}}],[\"调用的另一个方法进行映射关系存放\",{\"1\":{\"216\":1}}],[\"自然也需要运行别人的代码\",{\"1\":{\"1037\":1}}],[\"自增主键id\",{\"0\":{\"862\":1}}],[\"自行前往maven官网并下载最新版的maven安装\",{\"1\":{\"1010\":1}}],[\"自行阅读官方文档\",{\"1\":{\"824\":1}}],[\"自行实现\",{\"0\":{\"668\":1}}],[\"自身无参构造调用\",{\"1\":{\"1318\":1}}],[\"自身连接\",{\"1\":{\"768\":1}}],[\"自身连接查询\",{\"0\":{\"768\":1}}],[\"自身存在一个\",{\"1\":{\"192\":1}}],[\"自带的三个\",{\"1\":{\"631\":1}}],[\"自从有了stream\",{\"1\":{\"476\":1}}],[\"自jdk9后\",{\"1\":{\"462\":1}}],[\"自动在\",{\"1\":{\"1260\":1}}],[\"自动管理\",{\"0\":{\"1257\":1}}],[\"自动化的东西虽然省事\",{\"1\":{\"1140\":1}}],[\"自动装配可以直接在\",{\"1\":{\"1170\":1}}],[\"自动装配可能会遇到一些问题\",{\"1\":{\"1140\":1}}],[\"自动装配就是让ioc容器自己去寻找需要填入的值\",{\"1\":{\"1137\":1}}],[\"自动装配\",{\"0\":{\"1137\":1,\"1173\":1}}],[\"自动装箱|拆箱机制\",{\"1\":{\"386\":1}}],[\"自动执行多次测试\",{\"1\":{\"1017\":1}}],[\"自动生成的logger名称\",{\"1\":{\"950\":2}}],[\"自动生成了构造方法和成员字段的公共get方法\",{\"1\":{\"501\":1}}],[\"自动构建一个继承关系\",{\"1\":{\"930\":1}}],[\"自动构建继承关系\",{\"0\":{\"930\":1}}],[\"自动起别名\",{\"1\":{\"832\":1}}],[\"自动修改cookie信息\",{\"1\":{\"642\":1}}],[\"自动转换\",{\"0\":{\"616\":1}}],[\"自动模块\",{\"1\":{\"463\":1}}],[\"自动处理字符编码转换\",{\"1\":{\"245\":1}}],[\"自其他接口的\",{\"1\":{\"376\":1}}],[\"自定义度会更高\",{\"1\":{\"1220\":1}}],[\"自定义事件需要继承applicationevent\",{\"1\":{\"1192\":1}}],[\"自定义事件\",{\"0\":{\"1192\":1}}],[\"自定义测试名称\",{\"1\":{\"1017\":1}}],[\"自定义方法\",{\"0\":{\"980\":1}}],[\"自定义例子\",{\"0\":{\"948\":1}}],[\"自定义日志格式\",{\"0\":{\"944\":1}}],[\"自定义级别设置\",{\"0\":{\"911\":1}}],[\"自定义登录设置\",{\"0\":{\"680\":1}}],[\"自定义登录界面\",{\"0\":{\"677\":1}}],[\"自定义验证\",{\"0\":{\"667\":1}}],[\"自定义运行时异常\",{\"1\":{\"422\":1}}],[\"自定义编译时异常\",{\"1\":{\"422\":1}}],[\"自定义异常\",{\"0\":{\"422\":1}}],[\"自定义的注解需要定义1个\",{\"1\":{\"363\":1}}],[\"自定义线程名称\",{\"1\":{\"297\":1}}],[\"自己不实现功能\",{\"1\":{\"707\":1}}],[\"自己编译的类加载到\",{\"0\":{\"356\":1}}],[\"自己定义的定时器\",{\"0\":{\"322\":1}}],[\"自己定义的类要序列化保存\",{\"1\":{\"288\":1}}],[\"自我介绍需要用到当前对象的名字和年龄\",{\"1\":{\"162\":1}}],[\"自我介绍只需要完成就行\",{\"1\":{\"162\":1}}],[\"表明它可以获取迭代器或是直接使用foreach来遍历\",{\"1\":{\"836\":1}}],[\"表\",{\"1\":{\"774\":2}}],[\"表2\",{\"1\":{\"767\":2}}],[\"表1\",{\"1\":{\"767\":2}}],[\"表名\",{\"1\":{\"750\":1,\"751\":1,\"752\":1,\"754\":3,\"755\":1,\"756\":2,\"762\":5,\"764\":2,\"765\":1,\"766\":4,\"768\":2,\"770\":2,\"780\":2,\"781\":1}}],[\"表级约束有四种\",{\"1\":{\"748\":1}}],[\"表级约束条件\",{\"0\":{\"748\":1},\"1\":{\"750\":1}}],[\"表的\",{\"1\":{\"747\":1}}],[\"表中的唯一非关键字段为数量\",{\"1\":{\"739\":1}}],[\"表单隐藏字段\",{\"1\":{\"642\":1}}],[\"表达式可以不止一级\",{\"1\":{\"1203\":1}}],[\"表达式最终的运算结果可以通过getvalue\",{\"1\":{\"1202\":1}}],[\"表达式要求必须涵盖所有的可能\",{\"1\":{\"497\":1}}],[\"表达式\",{\"0\":{\"444\":1}}],[\"表达式的\",{\"1\":{\"192\":1}}],[\"表示的是对应字段属性\",{\"1\":{\"1205\":1}}],[\"表示占位符\",{\"1\":{\"1199\":1}}],[\"表示删除该cookie\",{\"1\":{\"1092\":1}}],[\"表示不在启动时加载\",{\"1\":{\"1064\":1}}],[\"表示此maven项目是父maven项目的子项目\",{\"1\":{\"1032\":1}}],[\"表示此类为密封类型\",{\"1\":{\"503\":1}}],[\"表示成功导入了依赖\",{\"1\":{\"1008\":1}}],[\"表示开启所有日志信息\",{\"1\":{\"912\":1}}],[\"表示直接关闭所有日志信息\",{\"1\":{\"912\":1}}],[\"表示生效的行数\",{\"1\":{\"861\":1}}],[\"表示这个事件的源头\",{\"1\":{\"1192\":1}}],[\"表示这个bean作为主要的bean\",{\"1\":{\"1141\":1}}],[\"表示这个类具有克隆的功能\",{\"1\":{\"377\":1}}],[\"表示这个类是一个抽象类\",{\"1\":{\"375\":1}}],[\"表示这个类不能再被继承了\",{\"1\":{\"374\":1}}],[\"表示这本书是谁借的\",{\"1\":{\"853\":1}}],[\"表示对应用户的详细信息\",{\"1\":{\"849\":1}}],[\"表示对于对应\",{\"1\":{\"84\":1}}],[\"表示对于每一个\",{\"1\":{\"84\":1}}],[\"表示我们的bean已经注册成功了\",{\"1\":{\"1125\":1}}],[\"表示我们的查询结果直接使用指定的构造方法来处理\",{\"1\":{\"841\":1}}],[\"表示我们无权去调用默认构造方法\",{\"1\":{\"348\":1}}],[\"表示将数据库结果映射为student类\",{\"1\":{\"826\":1}}],[\"表示添加一个select操作\",{\"1\":{\"826\":1}}],[\"表示执行后受影响的行数\",{\"1\":{\"791\":1}}],[\"表示针对每一行都会生效\",{\"1\":{\"781\":1}}],[\"表示匹配所有的ip地址\",{\"1\":{\"772\":1}}],[\"表示03开头\",{\"1\":{\"763\":1}}],[\"表示如果此列作为其他表的约束或视图引用到此列时\",{\"1\":{\"751\":1}}],[\"表示服务器端返回了一个json格式的数据\",{\"1\":{\"615\":1}}],[\"表示该方法用来捕获并处理指定类型的异常\",{\"1\":{\"604\":1}}],[\"表示当前目录或基于当前目录的多级目录\",{\"1\":{\"571\":1}}],[\"表示当前数组长度\",{\"1\":{\"393\":1}}],[\"表示任意内容\",{\"1\":{\"763\":1}}],[\"表示任意0\",{\"1\":{\"571\":1}}],[\"表示任意一个字符\",{\"1\":{\"571\":1}}],[\"表示层框架\",{\"1\":{\"540\":1}}],[\"表示只有不为空才进行调用\",{\"1\":{\"480\":1}}],[\"表示什么时候结束生成\",{\"1\":{\"478\":1}}],[\"表示所有小写字母\",{\"1\":{\"403\":1}}],[\"表示abc这几个字符可以出现\",{\"1\":{\"403\":1}}],[\"表示long的最大值\",{\"1\":{\"386\":1}}],[\"表示类支持接口代表的功能\",{\"1\":{\"376\":1}}],[\"表示类具有的属性\",{\"1\":{\"161\":1}}],[\"表示导入这个包中全部的类\",{\"1\":{\"277\":1}}],[\"表示integer这个类型\",{\"1\":{\"237\":1}}],[\"表示是\",{\"1\":{\"135\":1}}],[\"表示是一种长时间的交互行为\",{\"1\":{\"135\":1}}],[\"表示是最佳部署位置\",{\"1\":{\"13\":1}}],[\"表示一个区间\",{\"1\":{\"403\":1}}],[\"表示一个键值对\",{\"1\":{\"213\":1}}],[\"表示一个函数\",{\"1\":{\"110\":1}}],[\"表示一个给定的策略\",{\"1\":{\"45\":1}}],[\"表示状态转移矩阵\",{\"1\":{\"46\":1}}],[\"表示为原型模式\",{\"1\":{\"1129\":1}}],[\"表示为此类中的所有请求映射添加一个路径前缀\",{\"1\":{\"569\":1}}],[\"表示为\",{\"1\":{\"40\":1,\"152\":3}}],[\"表示为rkn​​\",{\"1\":{\"9\":1}}],[\"表示在验证的时候通过自定义的方式\",{\"1\":{\"668\":1}}],[\"表示在单步情况下\",{\"1\":{\"153\":1}}],[\"表示在策略π下\",{\"1\":{\"153\":1}}],[\"表示在一个\",{\"1\":{\"137\":1}}],[\"表示在各状态执行各动作的概率\",{\"1\":{\"20\":1}}],[\"表示在状态s下采取动作a\",{\"1\":{\"20\":2}}],[\"表示\",{\"1\":{\"10\":1,\"135\":1,\"142\":1,\"155\":1,\"604\":1,\"747\":6,\"1125\":1}}],[\"表示round\",{\"1\":{\"10\":1}}],[\"表示无人机与用户之间的仰角\",{\"1\":{\"9\":1}}],[\"遍历foreach\",{\"1\":{\"515\":1}}],[\"遍历打印数组中每一个元素\",{\"1\":{\"398\":1}}],[\"遍历方式也不同\",{\"1\":{\"190\":1}}],[\"遍历当前元素\",{\"1\":{\"189\":1}}],[\"向工厂注册bean此定义\",{\"1\":{\"1296\":1}}],[\"向容器找到对应实现的类\",{\"1\":{\"1119\":1}}],[\"向客户端发请求\",{\"1\":{\"720\":1}}],[\"向securitycontextholder添加认证信息\",{\"1\":{\"712\":1}}],[\"向map中添加新的映射关系\",{\"1\":{\"213\":1}}],[\"向后继续寻找结点\",{\"1\":{\"190\":1}}],[\"向集合中添加元素\",{\"1\":{\"180\":1}}],[\"移动指针\",{\"1\":{\"190\":1}}],[\"移除最长时间不被使用的对象\",{\"1\":{\"884\":1}}],[\"移除\",{\"0\":{\"1175\":1},\"1\":{\"241\":1}}],[\"移除其映射关系\",{\"1\":{\"213\":1}}],[\"移除队首元素\",{\"1\":{\"200\":1}}],[\"移除上一个被遍历的元素\",{\"1\":{\"189\":1}}],[\"移除指定位置上的元素\",{\"1\":{\"181\":1}}],[\"移除给定集合中出现的所有元素\",{\"1\":{\"180\":1}}],[\"移除成功返回true\",{\"1\":{\"180\":3}}],[\"实例化并注册所有\",{\"1\":{\"1320\":1}}],[\"实例化并调用所有注册的\",{\"1\":{\"1320\":1}}],[\"实例\",{\"1\":{\"1301\":2}}],[\"实体属性为实体类\",{\"1\":{\"853\":1}}],[\"实体属性为列表\",{\"1\":{\"853\":1}}],[\"实体类字段名称与数据库不同\",{\"0\":{\"898\":1}}],[\"实体类中定义的属性名称和我们数据库中的名称不一样\",{\"1\":{\"835\":1}}],[\"实体类转换json\",{\"0\":{\"615\":1}}],[\"实体或是属性之间可以具有一定的联系\",{\"1\":{\"733\":1}}],[\"实现该接口的类拥有注册bean的能力\",{\"1\":{\"1310\":1}}],[\"实现过程\",{\"0\":{\"1310\":1}}],[\"实现方式\",{\"0\":{\"1297\":1}}],[\"实现methodinterceptor接口\",{\"1\":{\"1231\":1}}],[\"实现异步效果\",{\"0\":{\"1225\":1},\"1\":{\"1225\":1}}],[\"实现在不修改原有代码的基础上\",{\"1\":{\"1221\":1}}],[\"实现此接口的类会获得某些感知能力\",{\"1\":{\"1186\":1}}],[\"实现重定向很简单\",{\"1\":{\"1082\":1}}],[\"实现登录功能\",{\"0\":{\"1072\":1}}],[\"实现登陆与sql注入攻击\",{\"0\":{\"804\":1}}],[\"实现简单登录功能\",{\"0\":{\"1070\":1}}],[\"实现多服务器缓存共用才是最终解决方案\",{\"1\":{\"888\":1}}],[\"实现批量处理\",{\"0\":{\"875\":1}}],[\"实现\",{\"0\":{\"1326\":1},\"1\":{\"705\":1,\"707\":1}}],[\"实现更多高级的功能\",{\"1\":{\"699\":1}}],[\"实现文件上传和下载\",{\"0\":{\"618\":1}}],[\"实现了aware接口的bean在被初始化之后\",{\"1\":{\"1186\":1}}],[\"实现了对securitycontext与webasyncmanager的集成\",{\"1\":{\"714\":1}}],[\"实现了linkedhashmap接口\",{\"1\":{\"612\":1}}],[\"实现了\",{\"1\":{\"560\":1}}],[\"实现各干各的\",{\"1\":{\"541\":1}}],[\"实现包的分离管理\",{\"0\":{\"461\":1}}],[\"实现一个consumer\",{\"1\":{\"454\":1}}],[\"实现接口时\",{\"1\":{\"376\":1}}],[\"实现接口\",{\"1\":{\"376\":1}}],[\"实现的功能\",{\"1\":{\"1116\":1}}],[\"实现的\",{\"1\":{\"215\":1}}],[\"实现用例\",{\"0\":{\"190\":1}}],[\"实际运行好像是可以的\",{\"1\":{\"874\":1}}],[\"实际返回的\",{\"1\":{\"528\":1}}],[\"实际上最主要的就是refresh方法\",{\"1\":{\"1320\":1}}],[\"实际上最后只要是object的实现类都可以保存到集合类中\",{\"1\":{\"237\":1}}],[\"实际上之前设计的三层缓存\",{\"1\":{\"1310\":1}}],[\"实际上整个单例bean的创建路线还是很清晰的\",{\"1\":{\"1300\":1}}],[\"实际上整个过程\",{\"1\":{\"558\":1}}],[\"实际上使用的是数据库驱动提供的connection对象进行事务操作\",{\"1\":{\"1273\":1}}],[\"实际上使用起来效果差不多\",{\"1\":{\"691\":1}}],[\"实际上它使用了三级缓存的方式来处理循环依赖的问题\",{\"1\":{\"1301\":1}}],[\"实际上它整合了aspectj框架的一部分\",{\"1\":{\"1217\":1}}],[\"实际上它就是一个tcp连接的建立过程\",{\"1\":{\"719\":1}}],[\"实际上它就是被作为一个模块单独存在\",{\"1\":{\"461\":1}}],[\"实际上跟我们之前在配置文件中编写是一样的\",{\"1\":{\"1181\":1}}],[\"实际上http的内容会作为tcp协议的报文被封装\",{\"1\":{\"1042\":1}}],[\"实际上域名最后会被解析为ip地址进行访问\",{\"1\":{\"1042\":1}}],[\"实际上已经转换为对应的代码了\",{\"1\":{\"1016\":1}}],[\"实际上logger还会通过名称进行分级\",{\"1\":{\"930\":1}}],[\"实际上每一个handler都有一个formatter对象\",{\"1\":{\"921\":1}}],[\"实际上每个级别都有一个对应的方法用于打印\",{\"1\":{\"910\":1}}],[\"实际上mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象\",{\"1\":{\"841\":1}}],[\"实际上mybatis也是通过preparedstatement首先进行一次预编译\",{\"1\":{\"831\":1}}],[\"实际上main就是一个函数\",{\"1\":{\"162\":1}}],[\"实际上idea就是一个java程序\",{\"1\":{\"788\":1}}],[\"实际上书籍编号依赖于借阅编号\",{\"1\":{\"738\":1}}],[\"实际上会有一个缓冲区用于数据的发送和接收\",{\"1\":{\"721\":1}}],[\"实际上会直接使用默认的类型\",{\"1\":{\"173\":1}}],[\"实际上真正注册的filter只有delegatingfilterproxy\",{\"1\":{\"708\":2}}],[\"实际上spring帮助我们动态生成的一个代理类\",{\"1\":{\"1189\":1}}],[\"实际上spring官方更推荐我们使用基于构造方法或是setter的\",{\"1\":{\"1175\":1}}],[\"实际上springsecurity就是由n个过滤器实现的\",{\"1\":{\"708\":1}}],[\"实际上synchronized是一种悲观锁\",{\"1\":{\"312\":1}}],[\"实际上权限跟角色相比只是粒度更细\",{\"1\":{\"693\":1}}],[\"实际上现在浏览器已经很安全了\",{\"1\":{\"684\":1}}],[\"实际上现在的浏览器已经很安全了\",{\"1\":{\"660\":1}}],[\"实际上jul也可以通过进行配置文件来规定日志打印器的一些默认值\",{\"1\":{\"939\":1}}],[\"实际上jsonobject就是对json数据的一种对象表示\",{\"1\":{\"612\":1}}],[\"实际上java\",{\"1\":{\"478\":1}}],[\"实际上我们在前面已经提到过\",{\"1\":{\"1316\":1}}],[\"实际上我们真正在项目中使用的就是applicationcontext的实现\",{\"1\":{\"1315\":1}}],[\"实际上我们之前的所有操作都离不开一个东西\",{\"1\":{\"1295\":1}}],[\"实际上我们的mapper最终就以factorybean的形式\",{\"1\":{\"1328\":1}}],[\"实际上我们的applicationcontext\",{\"1\":{\"1192\":1}}],[\"实际上我们的配置文件可以有很多个\",{\"1\":{\"1124\":1}}],[\"实际上我们的xml配置中所有配置项都可以以configuration对象的形式进行配置\",{\"1\":{\"904\":1}}],[\"实际上我们的集合类都是支持使用foreach语法\",{\"1\":{\"187\":1}}],[\"实际上我们也可以直接在\",{\"1\":{\"902\":1}}],[\"实际上我们上面编写的controller就是负责servlet基本功能的\",{\"1\":{\"549\":1}}],[\"实际上我们可以把用不到的类库排除掉\",{\"1\":{\"460\":1}}],[\"实际上很多功能我们并不会用到\",{\"1\":{\"460\":1}}],[\"实际上是main类中的lambda$main$0\",{\"1\":{\"446\":1}}],[\"实际上正则表达式内容非常多\",{\"1\":{\"403\":1}}],[\"实际上实现接口更像是一个类的功能列表\",{\"1\":{\"376\":1}}],[\"实际上接口的目标就是将类所具有某些的行为抽象出来\",{\"1\":{\"376\":1}}],[\"实际上类最开始是由bootstarpclassloader进行加载\",{\"1\":{\"355\":1}}],[\"实际上类锁也是对象锁\",{\"1\":{\"312\":1}}],[\"实际上锁就是依附于对象存在的\",{\"1\":{\"318\":1}}],[\"实际上只执行了一次\",{\"1\":{\"311\":1}}],[\"实际上只要是实现了迭代器接口的类\",{\"1\":{\"193\":1}}],[\"实际上一个java程序启动后\",{\"1\":{\"295\":1}}],[\"实际上这个后置处理器的主要目的就是为了读取配置类中的各种bean定义以及其他注解\",{\"1\":{\"1318\":1}}],[\"实际上这个表就是一个存放头结点的数组+若干结点\",{\"1\":{\"215\":1}}],[\"实际上这是为了满足bean的生命周期而做的\",{\"1\":{\"1301\":1}}],[\"实际上这是classloader的双亲委派机制在保护java程序的正常运行\",{\"1\":{\"355\":1}}],[\"实际上这些是maven的一些插件\",{\"1\":{\"1034\":1}}],[\"实际上这些内容都是http协议规定的请求头内容\",{\"1\":{\"727\":1}}],[\"实际上这里跟我们之前的一对一非常类似\",{\"1\":{\"855\":1}}],[\"实际上这里面就是方法体\",{\"1\":{\"414\":1}}],[\"实际上这种操作完全可以浓缩为一个sql语句\",{\"1\":{\"877\":1}}],[\"实际上这种方式存储密码并不安全\",{\"1\":{\"659\":1}}],[\"实际上这种模式是父类filterinputstream提供的规范\",{\"1\":{\"264\":1}}],[\"实际上这一类网站都属于恶意网站\",{\"1\":{\"641\":1}}],[\"实际上进行i\",{\"1\":{\"264\":1}}],[\"实际上在web应用程序运行时\",{\"1\":{\"1055\":1}}],[\"实际上在jul的这类内部也有着对应的配置处理操作\",{\"1\":{\"939\":1}}],[\"实际上在java中并不是真的有泛型类型\",{\"1\":{\"173\":1}}],[\"实际上在上述的第二阶段\",{\"1\":{\"811\":1}}],[\"实际上在之前我们如果不希望别人继承我们的类\",{\"1\":{\"503\":1}}],[\"实际上在我们的开发中\",{\"1\":{\"237\":1}}],[\"实际上对应类型的集合类有可能会存放其他类型的值\",{\"1\":{\"237\":1}}],[\"实际上\",{\"1\":{\"228\":1,\"299\":1,\"311\":2,\"350\":1,\"451\":1,\"588\":1,\"733\":1,\"799\":1,\"885\":1,\"938\":1,\"1042\":1,\"1054\":1,\"1056\":1,\"1103\":1,\"1109\":1,\"1119\":1,\"1129\":1,\"1134\":1,\"1215\":1,\"1237\":1,\"1244\":1,\"1296\":2}}],[\"实际上用的就是我们的\",{\"1\":{\"224\":1}}],[\"实际上底层大致结构跟我们之前学习的差不多\",{\"1\":{\"215\":1}}],[\"实际上就相当于\",{\"1\":{\"707\":1}}],[\"实际上就跟浏览器访问类似\",{\"1\":{\"490\":1}}],[\"实际上就是生成对应mapper的代理对象\",{\"1\":{\"1327\":1}}],[\"实际上就是利用创建savepoint\",{\"1\":{\"1284\":1}}],[\"实际上就是pooledconnection类\",{\"1\":{\"1247\":1}}],[\"实际上就是一个循环\",{\"1\":{\"710\":1}}],[\"实际上就是我们在方法执行前或是执行后需要做的内容\",{\"1\":{\"1226\":1}}],[\"实际上就是我们之前的开发模式\",{\"1\":{\"468\":1}}],[\"实际上就是我们对run\",{\"1\":{\"446\":1}}],[\"实际上就是传统java\",{\"1\":{\"463\":1}}],[\"实际上就是存放的映射关系\",{\"1\":{\"215\":1}}],[\"实际上就像这样\",{\"1\":{\"172\":1}}],[\"实际上编译之后会修改为\",{\"1\":{\"187\":1}}],[\"实际上泛型方法在很多工具类中也有\",{\"1\":{\"171\":1}}],[\"实际传入的参数是一个字符串类型的值\",{\"1\":{\"171\":1}}],[\"实际不常用\",{\"1\":{\"68\":1}}],[\"实际意义的解释\",{\"1\":{\"48\":1}}],[\"实际意义是\",{\"1\":{\"48\":1}}],[\"增加一些额外的操作\",{\"1\":{\"1218\":1}}],[\"增加了更多方便的操作\",{\"1\":{\"194\":1}}],[\"增\",{\"1\":{\"860\":1}}],[\"增强版switch语法\",{\"1\":{\"496\":1,\"497\":2}}],[\"增强\",{\"1\":{\"187\":1,\"1231\":1}}],[\"增量式的迭代算法\",{\"1\":{\"94\":1}}],[\"各位小伙伴自己调用一下测试就可以了\",{\"1\":{\"1298\":1}}],[\"各种配置\",{\"1\":{\"1297\":1}}],[\"各种属性都是默认值\",{\"1\":{\"166\":1}}],[\"各个web应用程序私有的类加载器\",{\"1\":{\"1109\":1}}],[\"各个web应用程序共享的类加载器\",{\"1\":{\"1109\":1}}],[\"各个线程之间共享程序的内存空间\",{\"1\":{\"295\":1}}],[\"各项操作的结果也是一样的\",{\"1\":{\"182\":1}}],[\"内行\",{\"1\":{\"1000\":1}}],[\"内层查询中涉及的表也是sc\",{\"1\":{\"779\":1}}],[\"内加入一个\",{\"1\":{\"524\":1}}],[\"内置了一系列收集器实现\",{\"1\":{\"522\":1}}],[\"内置了很多\",{\"1\":{\"490\":1}}],[\"内存占用已经超出限制\",{\"1\":{\"421\":1}}],[\"内存也会消耗更多\",{\"1\":{\"384\":1}}],[\"内容就会自动转换为json格式响应给客户端了\",{\"1\":{\"616\":1}}],[\"内容\",{\"0\":{\"1057\":1,\"1058\":1},\"1\":{\"410\":1,\"994\":1}}],[\"内部维护了一个非池化的数据源\",{\"1\":{\"1245\":1}}],[\"内部维护了一个map来记录初始化信息\",{\"1\":{\"1244\":1}}],[\"内部实现对外部是透明的\",{\"1\":{\"1115\":1}}],[\"内部有实现\",{\"1\":{\"789\":1}}],[\"内部的内容都是子节点\",{\"1\":{\"819\":1}}],[\"内部的类\",{\"1\":{\"708\":1}}],[\"内部的数据结构\",{\"1\":{\"224\":1}}],[\"内部机制探究\",{\"0\":{\"703\":1}}],[\"内部类静态方法\",{\"1\":{\"411\":2}}],[\"内部类初始化\",{\"1\":{\"411\":2}}],[\"内部类父类的tostring方法\",{\"1\":{\"408\":1}}],[\"内部类自己的tostring方法\",{\"1\":{\"408\":1}}],[\"内部类名称\",{\"1\":{\"408\":1}}],[\"内部类也是类\",{\"1\":{\"408\":1}}],[\"内部类顾名思义\",{\"1\":{\"407\":1}}],[\"内部类\",{\"0\":{\"406\":1,\"407\":1}}],[\"内部什么都没有\",{\"1\":{\"402\":1}}],[\"内部使用结点\",{\"1\":{\"215\":1}}],[\"内部使用的结点类\",{\"1\":{\"182\":1}}],[\"内嵌迭代算法求解\",{\"1\":{\"70\":1}}],[\"哟唉嘛干你\",{\"1\":{\"182\":2}}],[\"结尾的域名都可以访问该cookie\",{\"1\":{\"1092\":1}}],[\"结合自动注入\",{\"1\":{\"1256\":1}}],[\"结合了\",{\"1\":{\"992\":1}}],[\"结合\",{\"0\":{\"899\":1}}],[\"结合去寻找最优策略\",{\"1\":{\"111\":1}}],[\"结构化查询语言\",{\"1\":{\"744\":1}}],[\"结果显而易见\",{\"1\":{\"1278\":1}}],[\"结果如下\",{\"1\":{\"1221\":1}}],[\"结果就是\",{\"1\":{\"1181\":1}}],[\"结果会自动进行遍历并依次执行我们传入的lambda表达式\",{\"1\":{\"836\":1}}],[\"结果为\",{\"1\":{\"599\":1,\"601\":1,\"1224\":1}}],[\"结果肯定是空\",{\"1\":{\"523\":1}}],[\"结果是\",{\"1\":{\"411\":1}}],[\"结果依然是删除成功\",{\"1\":{\"182\":1}}],[\"结束并提交时\",{\"1\":{\"884\":1}}],[\"结束\",{\"1\":{\"324\":1,\"1188\":2}}],[\"那按理说它不应该参与到bean的初始化流程中的\",{\"1\":{\"1310\":1}}],[\"那得到的结果肯定是null\",{\"1\":{\"1301\":1}}],[\"那样延迟注入\",{\"1\":{\"1181\":1}}],[\"那有没有什么办法将文件的日志打印变成控制台那种格式呢\",{\"1\":{\"920\":1}}],[\"那这时又可以直接使用咱们的动态sql来完成操作了\",{\"1\":{\"877\":1}}],[\"那这接口怎么就出现了一个实现类呢\",{\"1\":{\"842\":1}}],[\"那如果我输入的是以下内容呢\",{\"1\":{\"804\":1}}],[\"那如果我们手动创建一个与jdk包名一样\",{\"1\":{\"355\":1}}],[\"那太简单了吧\",{\"1\":{\"454\":1}}],[\"那作用范围也就只能在方法中了\",{\"1\":{\"410\":1}}],[\"那肯定有人好奇\",{\"1\":{\"842\":1}}],[\"那肯定不相等\",{\"1\":{\"373\":1}}],[\"那肯定是没有的\",{\"1\":{\"214\":1}}],[\"那必须的\",{\"1\":{\"232\":1}}],[\"那就确实是没连接可以用了\",{\"1\":{\"1246\":1}}],[\"那就用\",{\"1\":{\"1175\":1}}],[\"那就是ioc容器\",{\"1\":{\"1295\":1}}],[\"那就是modules\",{\"1\":{\"1038\":1}}],[\"那就是参数了\",{\"1\":{\"408\":1}}],[\"那就直接整除10\",{\"1\":{\"495\":1,\"496\":1}}],[\"那就直接放一个新的结点\",{\"1\":{\"216\":1}}],[\"那就返回supplier提供的另一个optional包装\",{\"1\":{\"480\":1}}],[\"那就执行覆盖操作\",{\"1\":{\"216\":1}}],[\"那要是两个bean的类型都是一样的呢\",{\"1\":{\"1127\":1}}],[\"那要是我们就是想要使用维持顺序的set集合呢\",{\"1\":{\"206\":1}}],[\"那要是此时我们删除对象呢\",{\"1\":{\"182\":1}}],[\"那要是这样写呢\",{\"1\":{\"182\":1}}],[\"那么spring要如何进行解析\",{\"1\":{\"1296\":1}}],[\"那么久不允许增删改操作了\",{\"1\":{\"1279\":1}}],[\"那么得实现org\",{\"1\":{\"1272\":1}}],[\"那么a这时是毫不知情的\",{\"1\":{\"1270\":1}}],[\"那么改怎么去实现呢\",{\"1\":{\"1258\":1}}],[\"那么肯定有人有疑问了\",{\"1\":{\"1310\":1}}],[\"那么肯定有一个疑问\",{\"1\":{\"1247\":1}}],[\"那么肯定就可以得到这个单例对象\",{\"1\":{\"1301\":1}}],[\"那么肯定需要一个完善的管理机制\",{\"1\":{\"1296\":1}}],[\"那么肯定应该排在前面\",{\"1\":{\"171\":1}}],[\"那么连接\",{\"1\":{\"1246\":1}}],[\"那么只能在配置类中完成\",{\"1\":{\"1254\":1}}],[\"那么只能从之前的连接中寻找了\",{\"1\":{\"1246\":1}}],[\"那么只需要添加\",{\"1\":{\"1233\":1}}],[\"那么只要求解\",{\"1\":{\"99\":1}}],[\"那么环绕方法也需要有一个返回值\",{\"1\":{\"1224\":1}}],[\"那么定时任务也就跟着启动了\",{\"1\":{\"1190\":1}}],[\"那么要是出现了多个相同类型的bean\",{\"1\":{\"1174\":1}}],[\"那么都会在一开始就加载好\",{\"1\":{\"1148\":2}}],[\"那么都会被认为是同一个会话\",{\"1\":{\"588\":1}}],[\"那么什么时候是初始化\",{\"1\":{\"1148\":1}}],[\"那么什么是监听器呢\",{\"1\":{\"1105\":1}}],[\"那么怎么集成到junit中进行测试呢\",{\"1\":{\"1288\":1}}],[\"那么怎么才能指定呢\",{\"1\":{\"1135\":1}}],[\"那么怎么样才可以使用反射呢\",{\"1\":{\"466\":1}}],[\"那么一旦teacher的实现发生变化\",{\"1\":{\"1132\":1}}],[\"那么一定会再次调用当前对象的dofilter方法\",{\"1\":{\"710\":1}}],[\"那么说明每次从ioc容器获取到的对象\",{\"1\":{\"1129\":1}}],[\"那么添加一句打印语句看看\",{\"1\":{\"1102\":1}}],[\"那么也就是说\",{\"1\":{\"1083\":1}}],[\"那么也就等同于他直接进入了已登录状态\",{\"1\":{\"642\":1}}],[\"那么服务器会发送给我们一个重定向响应\",{\"1\":{\"1082\":1}}],[\"那么首先需要使用servlet进行请求和响应的数据处理\",{\"1\":{\"1116\":1}}],[\"那么首先\",{\"1\":{\"1047\":1,\"1093\":1}}],[\"那么为什么会异步执行呢\",{\"1\":{\"1189\":1}}],[\"那么为什么说它本身是无连接的呢\",{\"1\":{\"1042\":1}}],[\"那么为空时\",{\"1\":{\"500\":1}}],[\"那么我不仅需要将自己编写的类打包到jar中\",{\"1\":{\"1037\":1}}],[\"那么我们dogetbean\",{\"1\":{\"1300\":1}}],[\"那么我们不可能每次测试都去创建applicationcontext吧\",{\"1\":{\"1288\":1}}],[\"那么我们接着来深入了解一下事务的隔离机制\",{\"1\":{\"1267\":1}}],[\"那么我们接着来看managedtransaction的源码\",{\"1\":{\"1273\":1}}],[\"那么我们接着来看看popconnection方法\",{\"1\":{\"1246\":1}}],[\"那么我们接着来看请求转发\",{\"1\":{\"1083\":1}}],[\"那么我们接着来看其他的文件夹\",{\"1\":{\"1047\":1}}],[\"那么我们接着来看\",{\"1\":{\"617\":1,\"1244\":1}}],[\"那么我们最后再来看看pushconnection方法\",{\"1\":{\"1247\":1}}],[\"那么我们按照上面的流程\",{\"1\":{\"1218\":1}}],[\"那么我们从里面拿到的service实现就是b\",{\"1\":{\"1117\":1}}],[\"那么我们将发送一个重定向请求\",{\"1\":{\"1096\":1}}],[\"那么我们需要添加get请求的相关处理\",{\"1\":{\"1093\":1}}],[\"那么我们需要添加一个systempath来指定jar文件的位置\",{\"1\":{\"1018\":1}}],[\"那么我们需要在xml中手动编写配置\",{\"1\":{\"841\":1}}],[\"那么我们如何知道每个依赖的坐标呢\",{\"1\":{\"1008\":1}}],[\"那么我们如何去检测死锁呢\",{\"1\":{\"313\":1}}],[\"那么我们之前的日志是怎么打印出来的呢\",{\"1\":{\"918\":1}}],[\"那么我们现在就可以直接通过容器获取了\",{\"1\":{\"1257\":1}}],[\"那么我们现在需要重写在mybatis的配置文件中进行mapper的配置\",{\"1\":{\"894\":1}}],[\"那么我们现在来看看如何向服务器请求数据\",{\"1\":{\"617\":1}}],[\"那么我们原有的sql语句结构就遭到了破坏\",{\"1\":{\"804\":1}}],[\"那么我们原本的sql语句会变为\",{\"1\":{\"804\":1}}],[\"那么我们这边会发送一个ack探测包发到对方\",{\"1\":{\"721\":1}}],[\"那么我们来看一下\",{\"1\":{\"1247\":1}}],[\"那么我们来看看jdbctransaction\",{\"1\":{\"1273\":1}}],[\"那么我们来看看successfulauthentication和unsuccessfulauthentication分别做了什么\",{\"1\":{\"712\":1}}],[\"那么我们来看看\",{\"1\":{\"365\":2,\"1242\":1}}],[\"那么我们来想细看看此注解还有什么其他的玩法\",{\"1\":{\"1060\":1}}],[\"那么我们来随便看一个内部的过滤器在做什么\",{\"1\":{\"710\":1}}],[\"那么我们首先来看一下\",{\"1\":{\"625\":1}}],[\"那么我们就删掉之前的xml配置文件吧\",{\"1\":{\"1166\":1}}],[\"那么我们就不得不去修改某些流水线上的模块\",{\"1\":{\"1116\":1}}],[\"那么我们就来尝试创建一个数据库\",{\"1\":{\"734\":1}}],[\"那么我们就来看看事务的传播\",{\"1\":{\"1280\":1}}],[\"那么我们就来看看\",{\"1\":{\"598\":1,\"1243\":1}}],[\"那么我们就需要自行实现userdetailsservice或是功能更完善的userdetailsmanager接口\",{\"1\":{\"667\":1}}],[\"那么我们就可以直接为用户进行登陆\",{\"1\":{\"1093\":1}}],[\"那么我们就可以直接从缓存中获取\",{\"1\":{\"882\":1}}],[\"那么我们就可以认定此会话属于哪个浏览器用户\",{\"1\":{\"641\":1}}],[\"那么我们就可以将学习这个能力\",{\"1\":{\"376\":1}}],[\"那么我们就可以将其重写了\",{\"1\":{\"373\":1}}],[\"那么我们就必须约定一种更加高效的数据传输模式\",{\"1\":{\"610\":1}}],[\"那么我们在访问这个地址的时候\",{\"1\":{\"549\":1}}],[\"那么我们能否创建数组类型的数组呢\",{\"1\":{\"397\":1}}],[\"那么我们也可以给枚举类型添加独有的成员方法\",{\"1\":{\"378\":1}}],[\"那么我们可以将其配置为abstract\",{\"1\":{\"1151\":1}}],[\"那么我们可以将匿名内部类简写为lambda表达式\",{\"1\":{\"414\":1}}],[\"那么我们可以写一个一模一样的\",{\"1\":{\"1149\":1}}],[\"那么我们可以使用depends\",{\"1\":{\"1131\":1}}],[\"那么我们可以使用emptyxxx来快速生成一个只读的空集合\",{\"1\":{\"236\":1}}],[\"那么我们可以尝试获取以下post请求的参数\",{\"1\":{\"1083\":1}}],[\"那么我们可以继续踢皮球\",{\"1\":{\"424\":1}}],[\"那么我们可以自己手动将class文件加载到jvm中吗\",{\"1\":{\"356\":1}}],[\"那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用\",{\"1\":{\"278\":1}}],[\"那么我们可以对\",{\"1\":{\"78\":1}}],[\"那么子级的handler优先进行处理\",{\"1\":{\"929\":1}}],[\"那么同样会生效\",{\"1\":{\"1152\":1}}],[\"那么同样可以使用\",{\"1\":{\"373\":1}}],[\"那么同时也需要将父级的handler也进行日志等级配置\",{\"1\":{\"928\":1}}],[\"那么你也可以单独在xml中配置一个resultmap\",{\"1\":{\"899\":1}}],[\"那么理想情况下\",{\"1\":{\"888\":1}}],[\"那么之前的缓存就全部失效了\",{\"1\":{\"883\":1}}],[\"那么之前缓存的内容也会跟着失效\",{\"1\":{\"883\":1}}],[\"那么之后无论有无拦截器\",{\"1\":{\"600\":1}}],[\"那么必须使用drivermanager\",{\"1\":{\"1242\":1}}],[\"那么必须要指明类型并且不能出现歧义\",{\"1\":{\"1126\":1}}],[\"那么必须同时要满足大于18岁这个条件\",{\"1\":{\"873\":1}}],[\"那么必须告知函数的调用方我们会抛出某个异常\",{\"1\":{\"423\":1}}],[\"那么调用commit方法则不会进行提交\",{\"1\":{\"865\":1}}],[\"那么多对一又该如何查询\",{\"1\":{\"855\":1}}],[\"那么mybatis会选择可用的构造方法来进行构造\",{\"1\":{\"841\":1}}],[\"那么传入的参数就是一个int类型的参数\",{\"1\":{\"831\":1}}],[\"那么它到底是如何实现呢\",{\"1\":{\"1295\":1}}],[\"那么它会导致以下问题\",{\"1\":{\"1268\":1}}],[\"那么它会在一开始\",{\"1\":{\"1129\":1}}],[\"那么它能够使得我们可以在bean加载阶段就获取到当前bean的类加载器\",{\"1\":{\"1186\":1}}],[\"那么它本身就是一个虚表\",{\"1\":{\"779\":1}}],[\"那么它们的\",{\"1\":{\"241\":1}}],[\"那么被授权的用户还能将已获得的授权继续授权给其他用户\",{\"1\":{\"774\":1}}],[\"那么是否可以等到我们想要的时候再去连接\",{\"1\":{\"721\":1}}],[\"那么是不相等的\",{\"1\":{\"384\":1}}],[\"那么验证成功\",{\"1\":{\"711\":1}}],[\"那么根本不会理这个请求\",{\"1\":{\"711\":1}}],[\"那么下次携带此cookie访问服务器将无需登陆\",{\"1\":{\"686\":1}}],[\"那么能否直接得到对应的mapper对象呢\",{\"1\":{\"1256\":1}}],[\"那么能否有一种简单一点的配置文件呢\",{\"1\":{\"936\":1}}],[\"那么能否有一种更加高效的记住我功能实现呢\",{\"1\":{\"685\":1}}],[\"那么能否实现在对象创建时就为其指定名字\",{\"1\":{\"166\":1}}],[\"那么如何让请求可以顺利地到达对应的servlet\",{\"1\":{\"1103\":1}}],[\"那么如何创建一个servlet呢\",{\"1\":{\"1054\":1}}],[\"那么如何使用maven来管理依赖呢\",{\"1\":{\"1008\":1}}],[\"那么如何将其连接到数据库\",{\"1\":{\"661\":1}}],[\"那么如果出现了下面的情况\",{\"1\":{\"1267\":1}}],[\"那么如果我们的路径为\",{\"1\":{\"1062\":1}}],[\"那么如果我们并不是能够马上返回\",{\"1\":{\"497\":1}}],[\"那么如果我修改了数据库中的内容\",{\"1\":{\"883\":1}}],[\"那么如果这时一号拦截器在处理前就返回了false呢\",{\"1\":{\"600\":1}}],[\"那么如果是在处理中发生异常了呢\",{\"1\":{\"599\":1}}],[\"那么如果内部类中也定义了同名的变量\",{\"1\":{\"408\":1}}],[\"那么表单中必须包含此token字符串\",{\"1\":{\"660\":1}}],[\"那么所有类型的日志信息都不会被打印了\",{\"1\":{\"912\":1}}],[\"那么所有的操作都会丢失\",{\"1\":{\"806\":1}}],[\"那么所有用户的密码将全部泄露\",{\"1\":{\"659\":1}}],[\"那么所有在方法中可能会抛出的异常都需要注明\",{\"1\":{\"423\":1}}],[\"那么在后端这个id就被认定为已登录状态\",{\"1\":{\"642\":1}}],[\"那么在使用时\",{\"1\":{\"438\":1,\"1133\":1}}],[\"那么整个表单的数据会以post的形式发送给我们的服务端\",{\"1\":{\"641\":1}}],[\"那么不出意外\",{\"1\":{\"641\":1}}],[\"那么不会执行处理后posthandle方法\",{\"1\":{\"599\":1}}],[\"那么handleradapter会对请求的数据进行解析\",{\"1\":{\"625\":1}}],[\"那么后端如何快速创建一个json格式的数据呢\",{\"1\":{\"611\":1}}],[\"那么bean实例始终不变\",{\"1\":{\"588\":1}}],[\"那么此对象将一直存在\",{\"1\":{\"1129\":1}}],[\"那么此依赖是会一起被传递的\",{\"1\":{\"1024\":1}}],[\"那么此请求必须携带指定参数\",{\"1\":{\"580\":1}}],[\"那么此时两个handler都会生效\",{\"1\":{\"929\":1}}],[\"那么此时就可以开启flushcache属性\",{\"1\":{\"887\":1}}],[\"那么此时就出现了歧义\",{\"1\":{\"277\":1}}],[\"那么此时的\",{\"1\":{\"135\":1}}],[\"那么现在又有新的问题了\",{\"1\":{\"1129\":1}}],[\"那么现在\",{\"1\":{\"1096\":1,\"1104\":1}}],[\"那么现在就可以向节点中填写依赖了\",{\"1\":{\"1008\":1}}],[\"那么现在就可以将这些数据转换为一个类来进行操作\",{\"1\":{\"799\":1}}],[\"那么现在如果我们需要指定使用的构造方法怎么办呢\",{\"1\":{\"900\":1}}],[\"那么现在我们只需要知道执行器到底是如何执行sql语句的\",{\"1\":{\"1242\":1}}],[\"那么现在我们该如何配置bean呢\",{\"1\":{\"1167\":1}}],[\"那么现在我们再来添加jdbc和mybatis的依赖\",{\"1\":{\"1017\":1}}],[\"那么现在我们来看看\",{\"1\":{\"825\":1}}],[\"那么现在我们需要访问\",{\"1\":{\"569\":1}}],[\"那么现在执行所有的操作如果在最后不进行commit\",{\"1\":{\"806\":1}}],[\"那么现在该如何去设计这样的一个\",{\"1\":{\"437\":1}}],[\"那么dispatcherservlet会帮助我们做什么呢\",{\"1\":{\"558\":1}}],[\"那么第一步依然跟之前一样\",{\"1\":{\"547\":1}}],[\"那么无论是谁\",{\"1\":{\"503\":1}}],[\"那么无法重写\",{\"1\":{\"373\":1}}],[\"那么将无法导入\",{\"1\":{\"464\":1}}],[\"那么其他模块是不允许使用反射进行修改的\",{\"1\":{\"462\":1}}],[\"那么其他的对象读取的就是被改变的值\",{\"1\":{\"274\":1}}],[\"那么由于类型不确定\",{\"1\":{\"438\":1}}],[\"那么泛型就变成对应的类型了\",{\"1\":{\"438\":1}}],[\"那么泛型到底是如何实现的呢\",{\"1\":{\"173\":1}}],[\"那么当发生这个异常时\",{\"1\":{\"424\":1}}],[\"那么使用时候\",{\"1\":{\"415\":1}}],[\"那么需要以同样的方式加密再比较两个hash值是否一致\",{\"1\":{\"659\":1}}],[\"那么需要在前面添加外部类型名称\",{\"1\":{\"408\":1}}],[\"那么需要在前面添加外部类型名称test\",{\"1\":{\"408\":1}}],[\"那么需要重新生成一个迭代器对象\",{\"1\":{\"191\":1}}],[\"那么中间就需要产生4个字符串对象出来\",{\"1\":{\"402\":1}}],[\"那么始终都是同一个对象\",{\"1\":{\"401\":1}}],[\"那么始终都会得到同一个对象\",{\"1\":{\"384\":1}}],[\"那么可以写成\",{\"1\":{\"1203\":1}}],[\"那么可以省略列名\",{\"1\":{\"754\":1}}],[\"那么可以省去小括号\",{\"1\":{\"414\":1}}],[\"那么可以不用明确\",{\"1\":{\"439\":1}}],[\"那么可以直接明确对应类型\",{\"1\":{\"439\":1}}],[\"那么可以使用\",{\"1\":{\"438\":1}}],[\"那么可以使用this关键字\",{\"1\":{\"164\":1}}],[\"那么可变长参数只能放在最后\",{\"1\":{\"398\":1}}],[\"那么自动装箱的呢\",{\"1\":{\"384\":1}}],[\"那么实际上事务a之前读取到的数据依然不是最新的数据\",{\"1\":{\"1269\":1}}],[\"那么实际上只是传递了对象的引用\",{\"1\":{\"161\":1}}],[\"那么实现类中不强制要求进行实现\",{\"1\":{\"376\":1}}],[\"那么还有必要去重新加载吗\",{\"1\":{\"1109\":1}}],[\"那么还有什么意义呢\",{\"1\":{\"375\":1}}],[\"那么还需要将旧的数组中所有元素全部搬到新的里面去\",{\"1\":{\"217\":1}}],[\"那么有可能两个线程同一时间都执行同一个方法\",{\"1\":{\"330\":1}}],[\"那么有没有下界呢\",{\"1\":{\"172\":1}}],[\"那么线程将一直处于挂起状态\",{\"1\":{\"313\":1}}],[\"那么这时如果单独调用test2\",{\"1\":{\"1282\":1}}],[\"那么这里的参数会被自动注入\",{\"1\":{\"1179\":1}}],[\"那么这行代码的意思实际上是将此请求继续传递给下一个过滤器\",{\"1\":{\"1103\":1}}],[\"那么这个类又是干嘛的呢\",{\"1\":{\"1327\":1}}],[\"那么这个类又是什么呢\",{\"1\":{\"1310\":1}}],[\"那么这个属性得可以访问才行\",{\"1\":{\"1203\":1}}],[\"那么这个时候\",{\"1\":{\"1082\":1,\"1105\":1,\"1215\":1}}],[\"那么这个时候就需要添加\",{\"1\":{\"617\":1}}],[\"那么这个测试就应该没有成功通过\",{\"1\":{\"963\":1}}],[\"那么这个自增的主键值我们该如何获取到呢\",{\"1\":{\"862\":1}}],[\"那么这个角色只能访问首页\",{\"1\":{\"692\":1}}],[\"那么这些类如果都放在一起的话\",{\"1\":{\"277\":1}}],[\"那么这称为\",{\"1\":{\"84\":1}}],[\"那么通过这个类创建的所有对象\",{\"1\":{\"274\":1}}],[\"那么fill操作不会生效\",{\"1\":{\"235\":1}}],[\"那么直接给到\",{\"1\":{\"217\":1}}],[\"那么直接扩容到最小的大小\",{\"1\":{\"182\":1}}],[\"那么就检查一下活跃连接数是否达到最大的分配上限\",{\"1\":{\"1246\":1}}],[\"那么就无法通过容器获取到其实例化对象了\",{\"1\":{\"1151\":1}}],[\"那么就无法执行方法并且会返回403页面\",{\"1\":{\"697\":1}}],[\"那么就只会在获取时才创建\",{\"1\":{\"1148\":1}}],[\"那么就讲cookie存储到本地\",{\"1\":{\"1093\":1}}],[\"那么就有人提问了\",{\"1\":{\"1018\":1}}],[\"那么就必须要实现不同应用程序之间的隔离\",{\"1\":{\"1109\":1}}],[\"那么就必须通过这三个元素来定位我们的项目\",{\"1\":{\"1003\":1}}],[\"那么就必须逐一进行修改\",{\"1\":{\"739\":1}}],[\"那么就不能再由我们自己去new这个对象了\",{\"1\":{\"1119\":1}}],[\"那么就不能修改了\",{\"1\":{\"438\":1}}],[\"那么就不会再去远程仓库下载了\",{\"1\":{\"1009\":1}}],[\"那么就不拼接里面的内容到原本的sql中\",{\"1\":{\"873\":1}}],[\"那么就会通过aop的后置处理器进行处理\",{\"1\":{\"1310\":1}}],[\"那么就会使用此servlet进行处理\",{\"1\":{\"1062\":1}}],[\"那么就会告诉我们找不到合适的构造方法\",{\"1\":{\"841\":1}}],[\"那么就会出现这种情况\",{\"1\":{\"237\":1}}],[\"那么就需要去修改student类的定义\",{\"1\":{\"1132\":1}}],[\"那么就需要这样\",{\"1\":{\"1119\":1}}],[\"那么就需要创建一个应用程序上下文\",{\"1\":{\"1119\":1}}],[\"那么就需要创造一个对象\",{\"1\":{\"408\":1}}],[\"那么就需要一起下载我们项目的依赖\",{\"1\":{\"1015\":1}}],[\"那么就需要在每个类都去编写获取logger的代码\",{\"1\":{\"949\":1}}],[\"那么就需要在请求头中包含此token字符串\",{\"1\":{\"660\":1}}],[\"那么就需要按照http协议的规则\",{\"1\":{\"727\":1}}],[\"那么就从servletcontext找一下有没有初始化上下文\",{\"1\":{\"625\":1}}],[\"那么就类型转换\",{\"1\":{\"499\":1}}],[\"那么就相当于到顶层了\",{\"1\":{\"424\":1}}],[\"那么就是一个未命名模块\",{\"1\":{\"468\":1}}],[\"那么就是b的\",{\"1\":{\"408\":1}}],[\"那么就是a的\",{\"1\":{\"408\":1}}],[\"那么就是不同的对象了\",{\"1\":{\"401\":1}}],[\"那么就像我们把成员变量访问权限变成私有一样\",{\"1\":{\"408\":1}}],[\"那么就可以采用这种形式\",{\"1\":{\"1298\":1}}],[\"那么就可以使用\",{\"1\":{\"976\":1}}],[\"那么就可以随意访问个人信息等内容\",{\"1\":{\"641\":1}}],[\"那么就可以像这样\",{\"1\":{\"222\":1}}],[\"那么就可以直接使用迭代器来完成\",{\"1\":{\"190\":1}}],[\"那么就进行扩容\",{\"1\":{\"217\":1}}],[\"那么就开始扩容\",{\"1\":{\"217\":1}}],[\"那么就转换为红黑树来存放\",{\"1\":{\"216\":1}}],[\"那么键就是integer类型的\",{\"1\":{\"213\":1}}],[\"那么会进入else代码块\",{\"1\":{\"1300\":1}}],[\"那么会使用自带的\",{\"1\":{\"1188\":1}}],[\"那么会此表单信息\",{\"1\":{\"1093\":1}}],[\"那么会执行登陆请求的相关逻辑\",{\"1\":{\"711\":1}}],[\"那么会不会传递给依赖于模块module\",{\"1\":{\"465\":1}}],[\"那么会按照未命名模块进行处理\",{\"1\":{\"463\":1}}],[\"那么会直接返回已经提前创建好的对象\",{\"1\":{\"384\":1}}],[\"那么会直接抛出类型转换异常\",{\"1\":{\"237\":1}}],[\"那么会覆盖掉之前的\",{\"1\":{\"214\":1}}],[\"那么会失败\",{\"1\":{\"204\":1}}],[\"那么会抛出异常\",{\"1\":{\"200\":2}}],[\"那么会从默认类型变成上界定义的类型\",{\"1\":{\"173\":1}}],[\"那么集合中就是相同的两个对象\",{\"1\":{\"182\":1}}],[\"那么忽略这个元素\",{\"1\":{\"180\":1}}],[\"那么编译之后\",{\"1\":{\"173\":1}}],[\"那么限定了上界后\",{\"1\":{\"172\":1}}],[\"那么既然泛型有上界\",{\"1\":{\"172\":1}}],[\"那么t就会自动变成\",{\"1\":{\"171\":1}}],[\"那么默认会对其每一个参数都进行自动注入\",{\"1\":{\"1179\":1}}],[\"那么默认会认为这个变量是一个\",{\"1\":{\"438\":1}}],[\"那么默认情况下可以不使用this关键字来明确表示当前对象\",{\"1\":{\"164\":1}}],[\"那么默认是null\",{\"1\":{\"161\":1}}],[\"那么默认是统一为0\",{\"1\":{\"161\":1}}],[\"那么创建对象之后能否直接访问呢\",{\"1\":{\"161\":1}}],[\"那么对应的xml配置编写为\",{\"1\":{\"841\":1}}],[\"那么对应的损失函数求解为\",{\"1\":{\"142\":1}}],[\"那么对应返回的就是确定的类型\",{\"1\":{\"343\":1}}],[\"那么对象构造好之后\",{\"1\":{\"166\":1}}],[\"那么对象的属性都会存在初始值\",{\"1\":{\"161\":1}}],[\"那么对于随机变量x的估计可以为\",{\"1\":{\"75\":1}}],[\"那么\",{\"1\":{\"68\":1,\"94\":1,\"98\":1,\"576\":1,\"893\":1,\"1009\":1,\"1083\":1,\"1093\":1,\"1217\":1,\"1242\":1,\"1247\":1,\"1299\":1}}],[\"科技与狠活\",{\"1\":{\"182\":1}}],[\"扩展与增强\",{\"1\":{\"503\":1}}],[\"扩展了collection接口中一些额外的操作\",{\"1\":{\"181\":1}}],[\"扩展了大量列表支持的操作\",{\"1\":{\"181\":1}}],[\"扩容规则跟我们之前的是一样的\",{\"1\":{\"182\":1}}],[\"度\",{\"1\":{\"182\":1}}],[\"创建classpathbeandefinitionscanner对象\",{\"1\":{\"1318\":1}}],[\"创建controller也非常简单\",{\"1\":{\"561\":1}}],[\"创建annotatedbeandefinitionreader对象\",{\"1\":{\"1318\":1}}],[\"创建两个工厂\",{\"1\":{\"1298\":1}}],[\"创建投影集合\",{\"1\":{\"1210\":1}}],[\"创建map也很简单\",{\"1\":{\"1208\":1}}],[\"创建spel表达式\",{\"0\":{\"1202\":1}}],[\"创建servlet\",{\"0\":{\"1054\":1}}],[\"创建以\",{\"1\":{\"1197\":1}}],[\"创建documentbuilder对象\",{\"1\":{\"819\":1}}],[\"创建documentbuilderfactory对象\",{\"1\":{\"819\":1}}],[\"创建回滚点\",{\"1\":{\"806\":1}}],[\"创建索引\",{\"1\":{\"780\":1}}],[\"创建后\",{\"1\":{\"779\":1}}],[\"创建用户\",{\"0\":{\"772\":1}}],[\"创建表\",{\"0\":{\"750\":1}}],[\"创建\",{\"0\":{\"1208\":1},\"1\":{\"708\":1,\"1181\":1,\"1318\":1}}],[\"创建了一个delegatingfilterproxy对象\",{\"1\":{\"705\":1}}],[\"创建拦截器\",{\"0\":{\"594\":1}}],[\"创建test\",{\"1\":{\"564\":1}}],[\"创建对象的类存在多个对应\",{\"0\":{\"1126\":1}}],[\"创建对象越多\",{\"1\":{\"384\":1}}],[\"创建对应页面文件\",{\"0\":{\"562\":1}}],[\"创建对应\",{\"0\":{\"561\":1}}],[\"创建完成后会自动生成相关文件\",{\"1\":{\"542\":1}}],[\"创建流\",{\"0\":{\"516\":1},\"1\":{\"516\":1}}],[\"创建请求\",{\"1\":{\"490\":1}}],[\"创建一个实体类以及mapper来进行用户信息查询\",{\"1\":{\"1071\":1}}],[\"创建一个实现runnable的匿名内部类\",{\"1\":{\"445\":1}}],[\"创建一个用于执行sql的statement对象\",{\"1\":{\"788\":1}}],[\"创建一个新的用户\",{\"1\":{\"665\":1}}],[\"创建一个基于内存的用户信息管理器作为userdetailsservice\",{\"1\":{\"658\":1}}],[\"创建一个拦截器我们需要实现一个handlerinterceptor接口\",{\"1\":{\"595\":1}}],[\"创建一个mvc中使用的controller类\",{\"1\":{\"549\":1}}],[\"创建一个无参的default构造函数\",{\"1\":{\"525\":1}}],[\"创建一个变量指代我们刚刚创建好的对象\",{\"1\":{\"161\":1}}],[\"创建random对象\",{\"1\":{\"431\":1}}],[\"创建出来的数组每个位置上都有默认值\",{\"1\":{\"392\":1}}],[\"创建出学生对象\",{\"1\":{\"349\":2}}],[\"创建枚举需要添加参数\",{\"1\":{\"378\":1}}],[\"创建类对象\",{\"0\":{\"348\":1}}],[\"创建类的实例\",{\"1\":{\"275\":1}}],[\"创建定时器对象\",{\"1\":{\"323\":1}}],[\"创建并启动此定时任务\",{\"1\":{\"322\":2}}],[\"创建好后\",{\"1\":{\"297\":1}}],[\"创建当前列表\",{\"1\":{\"182\":1}}],[\"存放在了transaction对象中\",{\"1\":{\"1242\":1}}],[\"存放在元空间中\",{\"1\":{\"337\":1}}],[\"存放运行时产生的一些临时文件\",{\"1\":{\"1047\":1}}],[\"存放参数\",{\"1\":{\"799\":1}}],[\"存放数据的底层数组\",{\"1\":{\"182\":1}}],[\"存储过程以及高级映射\",{\"1\":{\"816\":1}}],[\"存储过程\",{\"1\":{\"787\":1}}],[\"存储物品id\",{\"1\":{\"739\":5}}],[\"存储型xss攻击\",{\"1\":{\"643\":1}}],[\"存储类型为我们要存放的变量类型\",{\"1\":{\"319\":1}}],[\"存储在主内存\",{\"1\":{\"311\":1}}],[\"存储本地读取字节数\",{\"1\":{\"251\":1}}],[\"存在两个候选bean\",{\"1\":{\"1140\":1}}],[\"存在潜在问题的消息级别\",{\"1\":{\"910\":1}}],[\"存在一级缓存\",{\"1\":{\"882\":1}}],[\"存在时存在则计算并赋予新的值\",{\"1\":{\"221\":1}}],[\"存在不动点x∗\",{\"1\":{\"58\":1}}],[\"存在\",{\"1\":{\"53\":1}}],[\"存在lemma1\",{\"1\":{\"9\":1}}],[\"接收到客户端数据\",{\"1\":{\"720\":1,\"727\":1}}],[\"接收端\",{\"1\":{\"10\":1}}],[\"接受到请求参数\",{\"1\":{\"579\":1,\"580\":1,\"581\":1,\"582\":1}}],[\"接受一个输入参数\",{\"1\":{\"519\":1}}],[\"接受一个参数\",{\"1\":{\"454\":1}}],[\"接着\",{\"1\":{\"1093\":1,\"1233\":1,\"1274\":1,\"1277\":2}}],[\"接着修改一下前端页面\",{\"1\":{\"1076\":1}}],[\"接着了解一下什么是http协议\",{\"1\":{\"1042\":1}}],[\"接着下面会根据参数挨个执行此测试用例\",{\"1\":{\"991\":1}}],[\"接着点击运行\",{\"1\":{\"959\":1}}],[\"接着就可以编写我们的测试用例了\",{\"1\":{\"959\":1}}],[\"接着就是添加后续动作了\",{\"1\":{\"1220\":1}}],[\"接着就是xml编写了\",{\"1\":{\"855\":1}}],[\"接着就是编写sql映射\",{\"1\":{\"855\":1}}],[\"接着就是java这边进行调用了\",{\"1\":{\"832\":1}}],[\"接着才是父级\",{\"1\":{\"929\":1}}],[\"接着将mapper文件的命名空间修改为我们的接口完整名称\",{\"1\":{\"842\":1}}],[\"接着将其注册为bean\",{\"1\":{\"588\":1}}],[\"接着在target目录下会出现我们打包完成的jar包\",{\"1\":{\"1036\":1}}],[\"接着在axios发起请求时\",{\"1\":{\"660\":1}}],[\"接着在根容器中添加此配置文件即可\",{\"1\":{\"652\":1}}],[\"接着是第二步\",{\"1\":{\"1319\":1}}],[\"接着是实体类设计\",{\"1\":{\"855\":1}}],[\"接着是我们需要进行查询的参数\",{\"1\":{\"831\":1}}],[\"接着是controller部分\",{\"1\":{\"636\":1}}],[\"接着是登录之后的首页\",{\"1\":{\"636\":1}}],[\"接着来看方法里面干了什么\",{\"1\":{\"1300\":1}}],[\"接着来看spring的事务控制\",{\"1\":{\"1265\":1}}],[\"接着来看池化的数据源实现\",{\"1\":{\"1245\":1}}],[\"接着来看httpservlet\",{\"1\":{\"1059\":1}}],[\"接着来看dispatcherservlet是如何进行调度的\",{\"1\":{\"626\":1}}],[\"接着来创建一个controller\",{\"1\":{\"561\":1}}],[\"接着给一个报错\",{\"1\":{\"605\":1}}],[\"接着需要为整个web应用程序配置一个spring上下文环境\",{\"1\":{\"546\":1}}],[\"接着我们修改一下刚刚的aop配置\",{\"1\":{\"1223\":1}}],[\"接着我们可以直接在配置类里面编写定时任务\",{\"1\":{\"1190\":1}}],[\"接着我们只需要在需要异步执行的方法上\",{\"1\":{\"1188\":1}}],[\"接着我们只需要在控制器添加一个方法用于处理对应的请求即可\",{\"1\":{\"569\":1}}],[\"接着我们点击右上角的maven选项\",{\"1\":{\"1023\":1}}],[\"接着我们就可以在项目中直接使用了\",{\"1\":{\"1023\":1}}],[\"接着我们就可以在需要使用此项目作为依赖的其他项目中使用它了\",{\"1\":{\"1023\":1}}],[\"接着我们就可以使用\",{\"1\":{\"902\":1}}],[\"接着我们就可以尝试进行登录操作了\",{\"1\":{\"682\":1}}],[\"接着我们什么都不需要做\",{\"1\":{\"862\":1}}],[\"接着我们来研究一下applicationcontext的内部\",{\"1\":{\"1315\":1}}],[\"接着我们来了解一下bean实例对象是如何被创建并得到的\",{\"1\":{\"1299\":1}}],[\"接着我们来编写一个简单的mapper操作\",{\"1\":{\"1277\":1}}],[\"接着我们来看看\",{\"1\":{\"707\":1}}],[\"接着我们来尝试勾选记住我选项进行登录\",{\"1\":{\"686\":1}}],[\"接着我们来稍微魔改一下页面中的退出登录按钮\",{\"1\":{\"683\":1}}],[\"接着我们来配置登录操作\",{\"1\":{\"682\":1}}],[\"接着我们来创建一个主类\",{\"1\":{\"461\":1}}],[\"接着我们配置对应页面的controller控制器\",{\"1\":{\"679\":1}}],[\"接着我们自行编写对应的查询操作\",{\"1\":{\"669\":1}}],[\"接着我们编写配置类\",{\"1\":{\"664\":1}}],[\"接着我们编写一个servlet用于处理文件下载\",{\"1\":{\"1074\":1}}],[\"接着我们编写一个快速重置密码的接口\",{\"1\":{\"666\":1}}],[\"接着我们编写一个专门显示异常的页面\",{\"1\":{\"605\":1}}],[\"接着我们编写一下项目a的模块设置\",{\"1\":{\"464\":1}}],[\"接着我们添加mybatis和mysql相关的依赖\",{\"1\":{\"663\":1}}],[\"接着我们访问这个恶意网站\",{\"1\":{\"642\":1}}],[\"接着我们在主界面中添加一个重置密码的操作\",{\"1\":{\"666\":1}}],[\"接着我们在页面中添加一个简单的转账操作按键\",{\"1\":{\"636\":1}}],[\"接着我们在首页加一个转账操作\",{\"1\":{\"636\":1}}],[\"接着我们在类路径根目录下创建一个简单html文件\",{\"1\":{\"562\":1}}],[\"接着我们直接编写controller即可\",{\"1\":{\"619\":1}}],[\"接着我们使用axios框架直接对后端请求json数据\",{\"1\":{\"617\":1}}],[\"接着我们使用json工具类将其转换为json格式的字符串\",{\"1\":{\"615\":1}}],[\"接着我们将其作用域修改为\",{\"1\":{\"588\":1}}],[\"接着我们将其自动注入到controller中\",{\"1\":{\"588\":1}}],[\"接着我们需要添加一个新的切点\",{\"1\":{\"1219\":1}}],[\"接着我们需要在定义aop增强操作的类上添加\",{\"1\":{\"1233\":1}}],[\"接着我们需要在程序开始之前加载这里的配置\",{\"1\":{\"939\":1}}],[\"接着我们需要在resultmap编写好对应关系\",{\"1\":{\"850\":1}}],[\"接着我们需要在配置类中进行注册\",{\"1\":{\"596\":1}}],[\"接着我们需要配置一下constructor里面的内容\",{\"1\":{\"841\":1}}],[\"接着我们需要配置springsecurity\",{\"1\":{\"650\":1,\"692\":1}}],[\"接着我们需要稍微修改一下验证逻辑\",{\"1\":{\"692\":1}}],[\"接着我们需要再创建一个配置类用于配置springsecurity\",{\"1\":{\"651\":1}}],[\"接着我们需要再配置类中添加一些必要的注解\",{\"1\":{\"553\":1}}],[\"接着我们需要将这个类注册为bean才能正常使用\",{\"1\":{\"549\":1}}],[\"接着我们需要为dispatcherservlet配置一些初始化参数来指定刚刚创建的配置文件\",{\"1\":{\"548\":1}}],[\"接着我们需要来观察一下网站的html具体怎么写的\",{\"1\":{\"490\":1}}],[\"接着我们现在想要在项目b中使用项目a的user类\",{\"1\":{\"464\":1}}],[\"接着我们对三个属性挨个进行比较\",{\"1\":{\"373\":1}}],[\"接下来需要配置一下环境变量\",{\"1\":{\"1047\":1}}],[\"接下来就是编写我们的sql语句了\",{\"1\":{\"831\":1}}],[\"接下来我们隆重介绍xss跨站脚本攻击方式\",{\"1\":{\"643\":1}}],[\"接下来\",{\"1\":{\"228\":1}}],[\"接口实现1\",{\"0\":{\"1273\":1}}],[\"接口serivce\",{\"1\":{\"1119\":1}}],[\"接口绑定\",{\"0\":{\"842\":1}}],[\"接口声明\",{\"0\":{\"509\":1}}],[\"接口再次得到强化\",{\"1\":{\"474\":1}}],[\"接口类型\",{\"1\":{\"447\":1}}],[\"接口内部必须有且仅有一个抽象方法\",{\"1\":{\"414\":1,\"447\":1}}],[\"接口也可以通过这种匿名内部类的形式\",{\"1\":{\"412\":1}}],[\"接口同样支持向下转型\",{\"1\":{\"376\":1}}],[\"接口跟抽象类一样\",{\"1\":{\"376\":1}}],[\"接口定义\",{\"1\":{\"376\":1}}],[\"接口支持多继承\",{\"1\":{\"376\":1}}],[\"接口是可以继承\",{\"1\":{\"376\":1}}],[\"接口不同于类\",{\"1\":{\"376\":1}}],[\"接口的private方法等\",{\"1\":{\"458\":1}}],[\"接口的默认方法是保底的\",{\"1\":{\"376\":1}}],[\"接口的继承相当于是对接口功能的融合罢了\",{\"1\":{\"376\":1}}],[\"接口的使用和继承的概念有一定的出入\",{\"1\":{\"376\":1}}],[\"接口的类\",{\"1\":{\"234\":1,\"550\":1}}],[\"接口可以实现很多个\",{\"1\":{\"376\":1}}],[\"接口里只能定义对应的抽象方法\",{\"1\":{\"376\":1}}],[\"接口包含了一些列方法的定义\",{\"1\":{\"376\":1}}],[\"接口一般只代表某些功能的抽象\",{\"1\":{\"376\":1}}],[\"接口甚至比抽象类还抽象\",{\"1\":{\"376\":1}}],[\"接口中方法的默认实现可以直接调用接口中的私有方法\",{\"1\":{\"474\":1}}],[\"接口中\",{\"1\":{\"474\":1,\"516\":1}}],[\"接口中的方法默认是\",{\"1\":{\"474\":1}}],[\"接口中的方法可以存在默认实现\",{\"1\":{\"376\":1}}],[\"接口中的private方法\",{\"0\":{\"474\":1}}],[\"接口中的定义\",{\"1\":{\"448\":1}}],[\"接口中可以存在让抽象方法的默认实现\",{\"1\":{\"376\":1}}],[\"接口中只能定义访问权限为public抽象方法\",{\"1\":{\"376\":1}}],[\"接口中如果定义了与\",{\"1\":{\"376\":1}}],[\"接口中不允许存在成员变量和成员方法\",{\"1\":{\"376\":1}}],[\"接口中并没有定义支持指定下标位置访问的添加和删除操作\",{\"1\":{\"205\":1}}],[\"接口中定义的静态方法也只能是public的\",{\"1\":{\"376\":1}}],[\"接口中定义的静态变量只能是public\",{\"1\":{\"376\":1}}],[\"接口中定义的操作\",{\"1\":{\"213\":1}}],[\"接口中定义的\",{\"1\":{\"192\":1}}],[\"接口中定义的方法都是\",{\"1\":{\"204\":1}}],[\"接口中定义的方法\",{\"1\":{\"181\":1}}],[\"接口\",{\"0\":{\"376\":1,\"595\":1,\"665\":1,\"668\":1,\"670\":1,\"1104\":1,\"1242\":1,\"1316\":1},\"1\":{\"181\":1,\"376\":1,\"412\":1,\"501\":1,\"504\":2}}],[\"按对象进入缓存的顺序来移除它们\",{\"1\":{\"884\":1}}],[\"按从小到大的顺序排列\",{\"1\":{\"449\":1}}],[\"按行读取\",{\"1\":{\"269\":1}}],[\"按照上面的要求\",{\"1\":{\"1218\":1}}],[\"按照名称顺序\",{\"1\":{\"987\":1}}],[\"按照一定规则进行名称处理\",{\"1\":{\"962\":1}}],[\"按照官方文档给定的提示\",{\"1\":{\"824\":1}}],[\"按照正常流程走delegatingfilterproxy的下一个filter\",{\"1\":{\"710\":1}}],[\"按照从大到小顺序出队\",{\"1\":{\"203\":1}}],[\"按照所给定策略j来执行一个动作at​∈a从而获得奖励rt​以及下一个状态st+1​\",{\"1\":{\"13\":1}}],[\"按顺序从前往后存放\",{\"1\":{\"181\":1}}],[\"功能还会更多一些\",{\"1\":{\"181\":1}}],[\"添加到活跃表中\",{\"1\":{\"1246\":1}}],[\"添加额外的动作\",{\"1\":{\"1215\":1}}],[\"添加此注解要求方法的返回值只能是void或是future类型才可以\",{\"1\":{\"1188\":1}}],[\"添加过滤器\",{\"0\":{\"1102\":1},\"1\":{\"1327\":1}}],[\"添加以下内容\",{\"1\":{\"1010\":1}}],[\"添加后\",{\"1\":{\"950\":1}}],[\"添加了二级缓存之后\",{\"1\":{\"885\":1}}],[\"添加了此注解的接口\",{\"1\":{\"447\":1}}],[\"添加每一条批处理语句\",{\"1\":{\"798\":1}}],[\"添加\",{\"0\":{\"1234\":1},\"1\":{\"796\":1,\"1119\":1,\"1188\":1}}],[\"添加回滚点\",{\"1\":{\"782\":1}}],[\"添加角色\",{\"1\":{\"692\":1}}],[\"添加一个constructor\",{\"1\":{\"1134\":1}}],[\"添加一个过滤器非常简单\",{\"1\":{\"1102\":1}}],[\"添加一个时间显示区域\",{\"1\":{\"1076\":1}}],[\"添加一个新的系统变量\",{\"1\":{\"1047\":1}}],[\"添加一个用户角色字段\",{\"1\":{\"692\":1}}],[\"添加一个user类\",{\"1\":{\"464\":1}}],[\"添加路径匹配\",{\"0\":{\"679\":1}}],[\"添加配置类\",{\"0\":{\"652\":1}}],[\"添加拦截器的匹配路径\",{\"1\":{\"596\":1}}],[\"添加用户\",{\"1\":{\"589\":1}}],[\"添加用户信息\",{\"1\":{\"589\":1}}],[\"添加依赖1\",{\"0\":{\"551\":1}}],[\"添加依赖\",{\"0\":{\"544\":1,\"663\":1}}],[\"添加final关键字后\",{\"1\":{\"503\":1}}],[\"添加点内容的话\",{\"1\":{\"399\":1}}],[\"添加元素只有在当前set集合中不存在此元素时才会成功\",{\"1\":{\"204\":1}}],[\"添加的是一个对象\",{\"1\":{\"182\":1}}],[\"添加integer的值10\",{\"1\":{\"182\":1}}],[\"添加成功返回true\",{\"1\":{\"180\":1}}],[\"添加给定集合中所有的元素\",{\"1\":{\"180\":1}}],[\"查找顺序\",{\"0\":{\"885\":1}}],[\"查找位置\",{\"0\":{\"237\":1}}],[\"查看结果\",{\"1\":{\"788\":1}}],[\"查看表中的索引\",{\"1\":{\"780\":1}}],[\"查看浏览器发起的请求\",{\"1\":{\"727\":1}}],[\"查看\",{\"1\":{\"516\":1}}],[\"查看当前类的类加载器\",{\"1\":{\"355\":1}}],[\"查看当前集合是否为空\",{\"1\":{\"180\":1}}],[\"查看map中是否包含指定的值\",{\"1\":{\"213\":1}}],[\"查看map中是否包含指定的键\",{\"1\":{\"213\":1}}],[\"查看前面是否有已经遍历的元素\",{\"1\":{\"194\":1}}],[\"查询一个\",{\"0\":{\"853\":1}}],[\"查询\",{\"0\":{\"851\":1},\"1\":{\"849\":1}}],[\"查询列表时\",{\"1\":{\"836\":1}}],[\"查询列表操作\",{\"0\":{\"836\":1}}],[\"查询操作在xml配置中使用一个select标签进行囊括\",{\"1\":{\"831\":1}}],[\"查询操作\",{\"0\":{\"831\":1}}],[\"查询得到的数据\",{\"1\":{\"791\":1}}],[\"查询条件\",{\"0\":{\"763\":1}}],[\"查询所有的列数据\",{\"1\":{\"762\":1}}],[\"查询相关操作\",{\"1\":{\"213\":1}}],[\"查询某个元素在当前列表中的最后一次出现的下标位置\",{\"1\":{\"181\":1}}],[\"查询某个元素在当前列表中的第一次出现的下标位置\",{\"1\":{\"181\":1}}],[\"查询当前集合是否包含给定集合中所有的元素\",{\"1\":{\"180\":1}}],[\"查询当前集合中是否包含某个元素\",{\"1\":{\"180\":1}}],[\"获得并行流\",{\"1\":{\"330\":1}}],[\"获得cpu资源的概率会越大\",{\"1\":{\"302\":1}}],[\"获得reward\",{\"1\":{\"20\":1}}],[\"获取了学生\",{\"1\":{\"1328\":1}}],[\"获取bean对象\",{\"1\":{\"1296\":1}}],[\"获取bean时会找到有两个子类都满足\",{\"1\":{\"1126\":1}}],[\"获取最早创建的连接\",{\"1\":{\"1246\":1}}],[\"获取切点信息\",{\"0\":{\"1223\":1}}],[\"获取那些满足我们条件的元素\",{\"1\":{\"1209\":1}}],[\"获取\",{\"1\":{\"1202\":1}}],[\"获取外部\",{\"1\":{\"1196\":1}}],[\"获取post请求携带的表单数据\",{\"1\":{\"1072\":1}}],[\"获取任何以js结尾的文件\",{\"1\":{\"1061\":1}}],[\"获取writer直接写入内容\",{\"1\":{\"1058\":1}}],[\"获取头部信息\",{\"1\":{\"1057\":1}}],[\"获取请求方法\",{\"1\":{\"1057\":1}}],[\"获取请求参数\",{\"0\":{\"575\":1}}],[\"获取访问者的ip地址\",{\"1\":{\"1057\":1}}],[\"获取协议版本\",{\"1\":{\"1057\":1}}],[\"获取所有的请求内容\",{\"1\":{\"1056\":1}}],[\"获取logmanager读取配置文件\",{\"1\":{\"939\":1}}],[\"获取系统数据\",{\"0\":{\"938\":1}}],[\"获取一个新的会话\",{\"1\":{\"830\":1}}],[\"获取首个\",{\"1\":{\"819\":1}}],[\"获取参数列表\",{\"1\":{\"799\":1}}],[\"获取用户的各种信息\",{\"1\":{\"643\":1}}],[\"获取用户\",{\"1\":{\"589\":1}}],[\"获取用户信息\",{\"1\":{\"589\":1}}],[\"获取值\",{\"1\":{\"512\":1}}],[\"获取成绩需要进行强制类型转换\",{\"1\":{\"437\":1}}],[\"获取成员变量\",{\"1\":{\"356\":1}}],[\"获取异常的错误信息\",{\"1\":{\"424\":1}}],[\"获取长度\",{\"1\":{\"401\":1}}],[\"获取封装的成员变量\",{\"1\":{\"378\":1}}],[\"获取对象的哈希值\",{\"1\":{\"372\":1}}],[\"获取对应下标位置上的元素\",{\"1\":{\"181\":1}}],[\"获取我们在注解中写入的内容\",{\"1\":{\"365\":2}}],[\"获取我们定义的test\",{\"1\":{\"356\":2}}],[\"获取类型\",{\"1\":{\"365\":2}}],[\"获取类名称\",{\"1\":{\"341\":1}}],[\"获取返回值类型\",{\"1\":{\"349\":1}}],[\"获取方法名称\",{\"1\":{\"349\":1}}],[\"获取非public方法并调用\",{\"1\":{\"349\":1}}],[\"获取父类的原始类型的type\",{\"1\":{\"343\":1}}],[\"获取它的类加载器\",{\"1\":{\"341\":1}}],[\"获取相应类的class对象\",{\"0\":{\"339\":1}}],[\"获取到的servletcontext始终是同一个对象\",{\"1\":{\"1084\":1}}],[\"获取到的是不同的锁\",{\"1\":{\"312\":1}}],[\"获取到用户的会话id\",{\"1\":{\"642\":1}}],[\"获取到cookie值为\",{\"1\":{\"583\":1,\"585\":1}}],[\"获取到类的一些属性\",{\"1\":{\"336\":1}}],[\"获取线程名称\",{\"1\":{\"297\":1}}],[\"获取文件的绝对路径\",{\"1\":{\"255\":1}}],[\"获取文件的大小\",{\"1\":{\"255\":1}}],[\"获取平均值\",{\"1\":{\"228\":1}}],[\"获取数量\",{\"1\":{\"228\":1}}],[\"获取语法统计实例\",{\"1\":{\"228\":1}}],[\"获取键值对的值\",{\"1\":{\"213\":1}}],[\"获取键值对的键\",{\"1\":{\"213\":1}}],[\"获取当前环境\",{\"1\":{\"1242\":1}}],[\"获取当前定位的filter\",{\"1\":{\"710\":1}}],[\"获取当前的类型class对象\",{\"1\":{\"372\":1}}],[\"获取当前线程对象\",{\"1\":{\"297\":1,\"299\":1}}],[\"获取当前存储的键值对数量\",{\"1\":{\"213\":1}}],[\"获取当前集合中的元素数量\",{\"1\":{\"180\":1}}],[\"获取队尾元素\",{\"1\":{\"201\":1}}],[\"获取队首元素\",{\"1\":{\"201\":1}}],[\"树脂666\",{\"1\":{\"180\":1}}],[\"相反的\",{\"1\":{\"985\":1}}],[\"相关操作\",{\"1\":{\"937\":1}}],[\"相关的逻辑需要我们在run\",{\"1\":{\"445\":1}}],[\"相信各位小伙伴在调试代码时\",{\"1\":{\"500\":1}}],[\"相信各位就能感受到注解带来的魅力了\",{\"1\":{\"365\":1}}],[\"相等于\",{\"1\":{\"403\":1}}],[\"相当于bean初始化的一个后置动作\",{\"1\":{\"1307\":1}}],[\"相当于进行一个最终的处理\",{\"1\":{\"1306\":1}}],[\"相当于另一个事务直接加入到此事务中\",{\"1\":{\"1281\":1}}],[\"相当于jdbctransaction只是为数据库驱动提供的connection对象套了层壳\",{\"1\":{\"1273\":1}}],[\"相当于直接使用connection对象\",{\"1\":{\"1273\":1}}],[\"相当于直接从数据中读取数据\",{\"1\":{\"1269\":1}}],[\"相当于各个事务共享一个缓存区域\",{\"1\":{\"1268\":1}}],[\"相当于挨个执行\",{\"1\":{\"1267\":1}}],[\"相当于读取的是这个事务暂时缓存的内容\",{\"1\":{\"1267\":1}}],[\"相当于调用task方法会独立开一个线程\",{\"1\":{\"1225\":1}}],[\"相当于我们的整个业务流程\",{\"1\":{\"1215\":1}}],[\"相当于在程序运行过程中动态生成了一个实现类\",{\"1\":{\"842\":1}}],[\"相当于没有启动事务\",{\"1\":{\"806\":1}}],[\"相当于没有头结点的链表\",{\"1\":{\"215\":1}}],[\"相当于一个指针\",{\"1\":{\"779\":1}}],[\"相当于服务端已经记住当前用户\",{\"1\":{\"685\":1}}],[\"相当于让用户直接帮我们登录了\",{\"1\":{\"642\":1}}],[\"相当于以字符串形式表示了一个js对象\",{\"1\":{\"610\":1}}],[\"相当于dispatcherservlet在将请求交给对应controller中的方法之前进行拦截处理\",{\"1\":{\"593\":1}}],[\"相当于打了个坐标\",{\"1\":{\"534\":1}}],[\"相当于\",{\"1\":{\"376\":1}}],[\"相比传统的xml配置方式\",{\"1\":{\"1179\":1}}],[\"相比junit\",{\"1\":{\"968\":1}}],[\"相比java\",{\"1\":{\"484\":1}}],[\"相比直接添加约束\",{\"1\":{\"781\":1}}],[\"相比之前的方式\",{\"1\":{\"564\":1}}],[\"相比之前的collection接口定义\",{\"1\":{\"181\":1}}],[\"相比reader更方便的是\",{\"1\":{\"269\":1}}],[\"相同之处\",{\"1\":{\"179\":1}}],[\"相应的算法是\",{\"1\":{\"112\":1}}],[\"相应的\",{\"1\":{\"104\":1,\"110\":1}}],[\"使其符合我们指定构造方法的定义\",{\"1\":{\"841\":1}}],[\"使\",{\"1\":{\"714\":1}}],[\"使得用户能够随意登陆别人的账号\",{\"1\":{\"804\":1}}],[\"使得java能够更好的体现面向对象的思想\",{\"1\":{\"383\":1}}],[\"使得持有当前对象锁的线程进入等待状态\",{\"1\":{\"372\":1}}],[\"使得整个过程被模糊了\",{\"1\":{\"349\":1}}],[\"使得线程处于等待状态一段时间\",{\"1\":{\"300\":1}}],[\"使得某些属性不参与序列化\",{\"1\":{\"290\":1}}],[\"使得v^\",{\"1\":{\"132\":1}}],[\"使用我们上面创建的reader注册配置类\",{\"1\":{\"1319\":1}}],[\"使用我们给定的参数再去执行\",{\"1\":{\"1224\":1}}],[\"使用beandefinitionreader就可以\",{\"1\":{\"1296\":1}}],[\"使用beandefinitionbuilder快速创建bean定义\",{\"1\":{\"1296\":1}}],[\"使用beforeeach不能为static方法\",{\"1\":{\"985\":1}}],[\"使用beforeall必须为static方法\",{\"1\":{\"985\":1}}],[\"使用声明式事务非常简单\",{\"1\":{\"1274\":1}}],[\"使用自定义的事务管理器可以根据具体需求来实现一些特定的事务管理行为\",{\"1\":{\"1272\":1}}],[\"使用例子\",{\"0\":{\"1253\":1}}],[\"使用连接池的数据源\",{\"1\":{\"1242\":1}}],[\"使用完后立即关闭连接\",{\"1\":{\"1242\":1}}],[\"使用命名绑定模式\",{\"1\":{\"1235\":1}}],[\"使用接口实现aop\",{\"0\":{\"1231\":1}}],[\"使用接口的引用来操作具体的集合类实现\",{\"1\":{\"182\":1}}],[\"使用配置实现aop\",{\"0\":{\"1216\":1}}],[\"使用配置文件进行配置\",{\"1\":{\"1165\":1}}],[\"使用构造方法等\",{\"1\":{\"1202\":1}}],[\"使用factory\",{\"1\":{\"1159\":1}}],[\"使用foreach来完成它就很简单了\",{\"1\":{\"876\":1}}],[\"使用for循环来一个一个执行insert语句\",{\"1\":{\"871\":1}}],[\"使用forward\",{\"1\":{\"587\":1}}],[\"使用xhr请求数据\",{\"0\":{\"1076\":1}}],[\"使用此注解来进行自动装配\",{\"1\":{\"1173\":1}}],[\"使用此注解来表示此测试是一个参数化测试\",{\"1\":{\"991\":1}}],[\"使用此类库可以快速完成io操作\",{\"1\":{\"1074\":1}}],[\"使用parseexpression方法来创建一个表达式\",{\"1\":{\"1202\":1}}],[\"使用property来指定需要注入的值是一个bean\",{\"1\":{\"1133\":1}}],[\"使用post请求完成登陆\",{\"0\":{\"1069\":1}}],[\"使用put方法添加键值对\",{\"1\":{\"214\":1}}],[\"使用load方法读取本地文件中的所有配置到map中\",{\"1\":{\"937\":1}}],[\"使用lombok之后\",{\"1\":{\"810\":1}}],[\"使用lombok\",{\"0\":{\"812\":1},\"1\":{\"501\":1}}],[\"使用lombok提供的注解\",{\"1\":{\"468\":1}}],[\"使用起来还是挺简单的\",{\"1\":{\"1231\":1}}],[\"使用起来和hashmap是差不多的\",{\"1\":{\"937\":1}}],[\"使用起来非常简单\",{\"1\":{\"908\":1}}],[\"使用起来也是非常方便\",{\"1\":{\"501\":1}}],[\"使用循环操作执行数据库相关操作实际上非常耗费资源\",{\"1\":{\"871\":1}}],[\"使用嵌套的结果映射来处理连接结果的重复子集\",{\"1\":{\"849\":1}}],[\"使用managed的事务管理机制\",{\"1\":{\"1272\":1}}],[\"使用map类型变量进行接受\",{\"1\":{\"833\":1}}],[\"使用main类的成员方法\",{\"1\":{\"452\":1}}],[\"使用哪个账号进行登陆了\",{\"1\":{\"824\":1}}],[\"使用原生方式和小辣椒方式编写类的区别\",{\"1\":{\"810\":1}}],[\"使用原始类型接收一个integer类型的arraylist\",{\"1\":{\"237\":1}}],[\"使用这种方式\",{\"1\":{\"805\":1}}],[\"使用反射的好处是\",{\"1\":{\"799\":1}}],[\"使用jdbc的事务管理机制\",{\"1\":{\"1272\":1}}],[\"使用jdbc连接数据库\",{\"0\":{\"788\":1}}],[\"使用jndi实现的数据源\",{\"1\":{\"1242\":1}}],[\"使用java读取xml内容不要求掌握\",{\"1\":{\"819\":1}}],[\"使用jconsole也可以进行监测\",{\"1\":{\"313\":1}}],[\"使用浏览器访问socket服务器\",{\"0\":{\"727\":1}}],[\"使用注解实现aop\",{\"0\":{\"1232\":1}}],[\"使用注解虽然可以省事很多\",{\"1\":{\"1181\":1}}],[\"使用注解开发\",{\"0\":{\"893\":1,\"1165\":1}}],[\"使用注解权限判断\",{\"0\":{\"694\":1}}],[\"使用注解的时候可以不用传入属性值\",{\"1\":{\"364\":1}}],[\"使用本地cookie存储的方式实现了记住我功能\",{\"1\":{\"685\":1}}],[\"使用方法跟之前一样\",{\"1\":{\"1234\":1}}],[\"使用方法一样\",{\"1\":{\"1175\":1}}],[\"使用方法是相同的\",{\"1\":{\"1169\":1}}],[\"使用方法是一样的\",{\"1\":{\"699\":1}}],[\"使用方法同输入流一样\",{\"1\":{\"249\":1}}],[\"使用方式很简单\",{\"1\":{\"959\":1}}],[\"使用方式是相同的\",{\"1\":{\"693\":1}}],[\"使用方式和之前是完全一样的\",{\"1\":{\"664\":1}}],[\"使用handleradapter进行处理\",{\"1\":{\"626\":1}}],[\"使用纯注解开发\",{\"1\":{\"550\":1}}],[\"使用空的构造函数加setter函数赋值\",{\"1\":{\"523\":1}}],[\"使用全量的构造函数\",{\"1\":{\"523\":1}}],[\"使用新增的ofnullable方法\",{\"1\":{\"477\":1}}],[\"使用uses指定\",{\"1\":{\"467\":1}}],[\"使用thymeleaf解析后端的一些数据时\",{\"1\":{\"563\":1}}],[\"使用throws关键字告知调用方此方法会抛出哪些异常\",{\"1\":{\"423\":1}}],[\"使用throw关键字来抛出异常\",{\"1\":{\"423\":1}}],[\"使用transitive来向其他模块传递此依赖\",{\"1\":{\"465\":1}}],[\"使用exports将com\",{\"1\":{\"465\":2}}],[\"使用equals判断\",{\"1\":{\"228\":1}}],[\"使用钻石运算符可以省略其中的类型\",{\"1\":{\"438\":1}}],[\"使用object类型作为引用\",{\"1\":{\"437\":1}}],[\"使用泛型的原因\",{\"0\":{\"437\":1}}],[\"使用运行时异常同样可以捕获到\",{\"1\":{\"424\":1}}],[\"使用new表示\",{\"1\":{\"415\":1}}],[\"使用newline进行换行\",{\"1\":{\"270\":1}}],[\"使用双冒号来进行方法引用\",{\"1\":{\"415\":1}}],[\"使用外部静态变量\",{\"1\":{\"411\":1}}],[\"使用频率很低\",{\"1\":{\"410\":1}}],[\"使用频率极高\",{\"1\":{\"178\":1}}],[\"使用service做一个顶层抽象\",{\"1\":{\"1117\":1}}],[\"使用servlet\",{\"1\":{\"1053\":1}}],[\"使用session作用域定义的bean都将产生一个新实例\",{\"1\":{\"588\":1}}],[\"使用system\",{\"1\":{\"978\":1}}],[\"使用synchronized关键字创建同步代码块\",{\"1\":{\"312\":1}}],[\"使用socket进行数据传输\",{\"0\":{\"720\":1}}],[\"使用spring\",{\"1\":{\"1219\":7}}],[\"使用spring首要目的是为了使得软件项目进行解耦\",{\"1\":{\"1118\":1}}],[\"使用springmvc\",{\"1\":{\"587\":1}}],[\"使用split方法进行字符串分割\",{\"1\":{\"401\":1}}],[\"使用stream\",{\"1\":{\"513\":1}}],[\"使用就像对象的参数一样\",{\"1\":{\"378\":1}}],[\"使用枚举类也非常方便\",{\"1\":{\"378\":1}}],[\"使用desc表示降序排序\",{\"1\":{\"764\":1}}],[\"使用default关键字为接口中的方法添加默认实现\",{\"1\":{\"376\":1}}],[\"使用datainputstream可以读取\",{\"1\":{\"286\":1}}],[\"使用implements关键字来实现接口\",{\"1\":{\"376\":1}}],[\"使用import关键字导入其他包中的类\",{\"1\":{\"277\":1}}],[\"使用interface表示这是一个接口\",{\"1\":{\"376\":1}}],[\"使用value则无需填入\",{\"1\":{\"364\":1}}],[\"使用getbean方法来获取对应的对象\",{\"1\":{\"1119\":1}}],[\"使用getdeclaredconstructor\",{\"1\":{\"348\":1}}],[\"使用get方法根据键获取对应的值\",{\"1\":{\"214\":1}}],[\"使用class类静态方法forname\",{\"1\":{\"339\":1}}],[\"使用class关键字\",{\"1\":{\"339\":1}}],[\"使用copyof快速将内容拷贝到扩容后的新数组中并设定为新的elementdata底层数组\",{\"1\":{\"182\":1}}],[\"使用多线程进行并行排序\",{\"1\":{\"330\":1}}],[\"使用\",{\"0\":{\"446\":1,\"805\":1,\"959\":1,\"1119\":1},\"1\":{\"312\":1,\"424\":1,\"448\":1,\"497\":1,\"510\":1,\"511\":1,\"525\":1,\"558\":1,\"812\":5,\"901\":1,\"903\":1,\"979\":1,\"1208\":1,\"1210\":1,\"1219\":3,\"1310\":1}}],[\"使用的是系统提供的输入流\",{\"1\":{\"285\":1}}],[\"使用长度为10的byte\",{\"1\":{\"251\":1}}],[\"使用asserttrue方法\",{\"1\":{\"970\":1}}],[\"使用asc表示升序排序\",{\"1\":{\"764\":1}}],[\"使用arg标签来代表每一个参数\",{\"1\":{\"841\":1}}],[\"使用available方法能查看当前可读的剩余字节数量\",{\"1\":{\"248\":1}}],[\"使用add添加元素\",{\"1\":{\"182\":1}}],[\"使用returning指定接收方法返回值的参数returnval\",{\"1\":{\"1236\":1}}],[\"使用resulthandler来处理结果\",{\"1\":{\"836\":1}}],[\"使用resulttype属性来指定\",{\"1\":{\"831\":1}}],[\"使用request作用域定义的bean都将产生一个新实例\",{\"1\":{\"588\":1}}],[\"使用read可以直接读取一个字节的数据\",{\"1\":{\"248\":1}}],[\"使用reduce方法\",{\"1\":{\"228\":1}}],[\"使用一种类似用\",{\"1\":{\"228\":1}}],[\"使用即可\",{\"1\":{\"207\":1}}],[\"使用示例\",{\"0\":{\"191\":1}}],[\"使用匿名内部类\",{\"1\":{\"182\":1}}],[\"使用时可以直接调用\",{\"1\":{\"1260\":1}}],[\"使用时\",{\"1\":{\"172\":1}}],[\"上传\",{\"0\":{\"1075\":1}}],[\"上传和下载文件\",{\"0\":{\"1073\":1}}],[\"上面提到的beanfactorypostprocessor就开始工作了\",{\"1\":{\"1320\":1}}],[\"上面已经提到过了\",{\"1\":{\"1273\":1}}],[\"上面的路径表示\",{\"1\":{\"1061\":1}}],[\"上面两种方式就很难进行验证了\",{\"1\":{\"667\":1}}],[\"上午\",{\"1\":{\"919\":1,\"929\":2}}],[\"上开启\",{\"1\":{\"695\":1}}],[\"上例中\",{\"1\":{\"604\":1}}],[\"上来就是截断状态\",{\"1\":{\"479\":1}}],[\"上\",{\"1\":{\"374\":1}}],[\"上下文切换速度也高于进程\",{\"1\":{\"295\":1}}],[\"上头啊\",{\"1\":{\"182\":1}}],[\"上界number\",{\"1\":{\"173\":1}}],[\"上界\",{\"1\":{\"172\":1}}],[\"上行\",{\"1\":{\"13\":1}}],[\"返回得到的connection对象\",{\"1\":{\"1244\":1}}],[\"返回结果为一个405页面\",{\"1\":{\"1083\":1}}],[\"返回结点内部存放的元素\",{\"1\":{\"190\":1}}],[\"返回缓存对象的拷贝\",{\"1\":{\"884\":1}}],[\"返回多个\",{\"0\":{\"853\":1}}],[\"返回filter\",{\"1\":{\"706\":1}}],[\"返回给浏览器的就是我们直接返回的字符串内容\",{\"1\":{\"615\":1}}],[\"返回后会经过视图解析器进行处理\",{\"1\":{\"561\":1}}],[\"返回\",{\"0\":{\"598\":1},\"1\":{\"560\":1}}],[\"返回modelandview对象\",{\"1\":{\"561\":1}}],[\"返回modelandview之后\",{\"1\":{\"558\":1}}],[\"返回map中存放的所有值\",{\"1\":{\"213\":1}}],[\"返回map中存放的所有键\",{\"1\":{\"213\":1}}],[\"返回响应\",{\"1\":{\"541\":1}}],[\"返回一个规范的响应文本\",{\"1\":{\"727\":1}}],[\"返回一个结果\",{\"1\":{\"519\":1}}],[\"返回一个string类型结果\",{\"1\":{\"447\":1}}],[\"返回它\",{\"1\":{\"512\":1}}],[\"返回对应的等级\",{\"1\":{\"495\":1}}],[\"返回void\",{\"1\":{\"454\":1}}],[\"返回负数\",{\"1\":{\"449\":1}}],[\"返回正数\",{\"1\":{\"449\":1}}],[\"返回泛型t\",{\"1\":{\"348\":1}}],[\"返回的是pooledconnection对象\",{\"1\":{\"1246\":1}}],[\"返回的是一个\",{\"1\":{\"488\":1}}],[\"返回的参数数组获取第1个参数\",{\"1\":{\"1223\":1}}],[\"返回的仍然是\",{\"1\":{\"343\":1}}],[\"返回的类型就是什么\",{\"1\":{\"171\":1}}],[\"返回备选方案\",{\"1\":{\"214\":1}}],[\"返回值为void\",{\"1\":{\"454\":1}}],[\"返回值为null\",{\"1\":{\"349\":1}}],[\"返回值一样\",{\"1\":{\"415\":1}}],[\"返回值就是方法的返回值\",{\"1\":{\"349\":1}}],[\"返回值是\",{\"1\":{\"1236\":1}}],[\"返回值是当前是否有中断标记\",{\"1\":{\"301\":1}}],[\"返回值是读取的字节数\",{\"1\":{\"248\":1}}],[\"返回值\",{\"1\":{\"217\":1,\"349\":1}}],[\"返回值我们会在后面讨论\",{\"1\":{\"214\":1}}],[\"返回值类型\",{\"1\":{\"162\":1}}],[\"返回当前键值对的哈希值\",{\"1\":{\"213\":1}}],[\"返回当前集合在指定范围内的子集\",{\"1\":{\"181\":1}}],[\"返回当前集合的迭代器\",{\"1\":{\"180\":1}}],[\"返回所有的键值对\",{\"1\":{\"213\":1}}],[\"返回其映射的值\",{\"1\":{\"213\":1}}],[\"返回上一个已遍历元素的下标\",{\"1\":{\"194\":1}}],[\"返回下一个待遍历元素的下标\",{\"1\":{\"194\":1}}],[\"效率很低\",{\"1\":{\"1267\":1}}],[\"效率会更高\",{\"1\":{\"882\":1}}],[\"效率会截然不同\",{\"1\":{\"871\":1}}],[\"效率就会提升很多\",{\"1\":{\"871\":1}}],[\"效率非常低\",{\"1\":{\"871\":1}}],[\"效率更高\",{\"1\":{\"330\":1}}],[\"效率过低\",{\"1\":{\"76\":1}}],[\"效果相同\",{\"1\":{\"1298\":1}}],[\"效果和之前是一样的\",{\"1\":{\"1231\":1}}],[\"效果和之前我们编写xml形式的动态sql一致\",{\"1\":{\"902\":1}}],[\"效果和上面是一样的\",{\"1\":{\"1138\":1}}],[\"效果和上面是一模一样\",{\"1\":{\"449\":1}}],[\"效果和第一种方法是一样的\",{\"1\":{\"851\":1}}],[\"效果是一样的\",{\"1\":{\"480\":1}}],[\"效果是完全一样的\",{\"1\":{\"191\":1}}],[\"效果跟上面是一样的\",{\"1\":{\"171\":1}}],[\"瞬间变一行\",{\"1\":{\"171\":1}}],[\">default\",{\"1\":{\"1199\":1}}],[\">file\",{\"1\":{\"1199\":1}}],[\">editor\",{\"1\":{\"1199\":1}}],[\">更新数据<\",{\"1\":{\"1076\":1}}],[\">点我下载高清资源<\",{\"1\":{\"1074\":1}}],[\">点击下载全套视频<\",{\"1\":{\"641\":1}}],[\">login<\",{\"1\":{\"682\":1}}],[\">修改密码<\",{\"1\":{\"666\":1}}],[\">立即转账<\",{\"1\":{\"636\":1}}],[\">立即登录<\",{\"1\":{\"617\":1}}],[\">登录失败\",{\"1\":{\"636\":1}}],[\">登录<\",{\"1\":{\"636\":1}}],[\">下载最新资源<\",{\"1\":{\"620\":1}}],[\"><\",{\"1\":{\"563\":2,\"564\":1,\"605\":1,\"617\":4,\"636\":1,\"641\":1,\"642\":1,\"683\":1,\"818\":1,\"1076\":1}}],[\"><img\",{\"1\":{\"490\":1}}],[\">=\",{\"1\":{\"216\":1,\"217\":2,\"228\":1,\"384\":1,\"747\":1,\"748\":1,\"763\":1}}],[\">>>\",{\"1\":{\"223\":1}}],[\">>\",{\"1\":{\"182\":1,\"550\":1,\"616\":1}}],[\">\",{\"1\":{\"171\":1,\"180\":3,\"182\":2,\"203\":1,\"204\":3,\"207\":1,\"216\":1,\"217\":2,\"221\":3,\"222\":2,\"228\":9,\"297\":2,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"313\":2,\"318\":3,\"319\":2,\"320\":2,\"322\":4,\"329\":3,\"330\":2,\"339\":3,\"340\":1,\"341\":1,\"343\":4,\"349\":4,\"356\":3,\"372\":1,\"384\":8,\"414\":7,\"415\":2,\"425\":1,\"438\":1,\"446\":3,\"447\":6,\"454\":1,\"476\":1,\"478\":3,\"479\":4,\"480\":4,\"487\":1,\"490\":1,\"496\":4,\"497\":5,\"509\":1,\"510\":1,\"511\":2,\"518\":1,\"521\":2,\"522\":2,\"545\":2,\"547\":2,\"548\":1,\"549\":4,\"552\":2,\"562\":2,\"563\":2,\"564\":3,\"605\":2,\"617\":4,\"619\":3,\"636\":10,\"641\":3,\"642\":2,\"643\":3,\"652\":1,\"660\":1,\"666\":2,\"680\":2,\"681\":1,\"682\":4,\"683\":3,\"684\":1,\"686\":3,\"687\":1,\"692\":1,\"693\":1,\"708\":6,\"710\":1,\"763\":1,\"779\":1,\"789\":1,\"799\":2,\"817\":4,\"824\":11,\"826\":6,\"831\":4,\"832\":2,\"833\":1,\"834\":1,\"835\":5,\"836\":3,\"841\":4,\"842\":5,\"843\":1,\"849\":2,\"850\":9,\"851\":7,\"852\":1,\"853\":7,\"854\":7,\"855\":15,\"861\":1,\"862\":1,\"863\":1,\"864\":1,\"873\":4,\"874\":4,\"876\":2,\"877\":2,\"884\":2,\"886\":1,\"887\":1,\"894\":2,\"895\":1,\"897\":1,\"898\":3,\"900\":3,\"902\":9,\"951\":2,\"972\":6,\"973\":1,\"980\":1,\"995\":1,\"1002\":2,\"1017\":16,\"1023\":2,\"1026\":1,\"1032\":2,\"1047\":4,\"1054\":2,\"1069\":4,\"1071\":11,\"1072\":1,\"1075\":2,\"1093\":1,\"1119\":4,\"1124\":3,\"1125\":2,\"1126\":2,\"1127\":6,\"1128\":2,\"1130\":1,\"1131\":2,\"1133\":11,\"1134\":4,\"1135\":2,\"1136\":8,\"1137\":3,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1149\":5,\"1150\":5,\"1151\":3,\"1158\":1,\"1159\":2,\"1160\":2,\"1167\":3,\"1172\":3,\"1180\":1,\"1204\":1,\"1209\":1,\"1211\":2,\"1217\":2,\"1218\":2,\"1219\":2,\"1220\":5,\"1223\":1,\"1224\":3,\"1225\":5,\"1231\":5,\"1242\":11,\"1246\":2,\"1247\":1,\"1253\":4,\"1255\":11,\"1273\":1,\"1301\":1,\"1309\":6,\"1311\":7,\"1317\":1,\"1319\":2,\"1321\":1,\"1327\":2,\"1328\":1}}],[\"大体内容和jdbctransaction差不多\",{\"1\":{\"1273\":1}}],[\"大体内容其实普通类差不多\",{\"1\":{\"375\":1}}],[\"大部分的web服务器都支持此标准\",{\"1\":{\"1053\":1}}],[\"大部分情况下\",{\"1\":{\"1015\":1}}],[\"大部分功能只需要一个注解就可以搞定了\",{\"1\":{\"586\":1}}],[\"大于符号\",{\"1\":{\"836\":1}}],[\"大于0表示大于\",{\"1\":{\"171\":1}}],[\"大型数据库系统\",{\"1\":{\"732\":1}}],[\"大大提高工作效率\",{\"1\":{\"782\":1}}],[\"大大提升开发效\",{\"1\":{\"437\":1}}],[\"大大降低依赖库的规模\",{\"1\":{\"460\":1}}],[\"大小直接变成11\",{\"1\":{\"350\":1}}],[\"大数定理\",{\"1\":{\"75\":1}}],[\"8<\",{\"1\":{\"1002\":1}}],[\"8月\",{\"1\":{\"919\":1,\"929\":2,\"1260\":3}}],[\"854\",{\"1\":{\"746\":2}}],[\"81\",{\"1\":{\"727\":1}}],[\"8192\",{\"1\":{\"721\":1}}],[\"83421936\",{\"1\":{\"660\":1}}],[\"8到java\",{\"1\":{\"494\":1}}],[\"8及之前\",{\"1\":{\"480\":1}}],[\"8就有了\",{\"1\":{\"478\":1}}],[\"8新增的stream\",{\"1\":{\"476\":1}}],[\"8新增方法\",{\"1\":{\"181\":1}}],[\"8中的一个函数式接口\",{\"1\":{\"508\":1}}],[\"8中引入了optional类\",{\"1\":{\"480\":1}}],[\"8中\",{\"1\":{\"474\":1}}],[\"8中新引入了optional特性\",{\"1\":{\"454\":1}}],[\"8以下的编程模式\",{\"1\":{\"463\":1}}],[\"8代码才能正常地在java\",{\"1\":{\"463\":1}}],[\"8也为我们提供了一些内置的函数式接口供我们使用\",{\"1\":{\"453\":1}}],[\"8之后能这样写\",{\"1\":{\"1211\":1}}],[\"8之后的又一个tls长期维护版本\",{\"1\":{\"486\":1}}],[\"8之后\",{\"1\":{\"446\":1}}],[\"8之前\",{\"1\":{\"445\":1}}],[\"8之前存放在永久代\",{\"1\":{\"337\":1}}],[\"8已经为集合框架中包含的所有数据结构提供了一个默认的spliterator实现\",{\"1\":{\"330\":1}}],[\"89\",{\"1\":{\"222\":1}}],[\"88\",{\"1\":{\"222\":1}}],[\"800\",{\"1\":{\"910\":1}}],[\"807\",{\"1\":{\"746\":1}}],[\"8081\",{\"1\":{\"1091\":2,\"1096\":2}}],[\"808\",{\"1\":{\"746\":1}}],[\"8080\",{\"1\":{\"589\":5,\"641\":1,\"642\":1,\"658\":1,\"719\":3,\"720\":2,\"721\":1,\"726\":2,\"727\":5,\"1047\":5,\"1093\":1}}],[\"80\",{\"1\":{\"222\":1,\"495\":1,\"1136\":1}}],[\"8\",{\"0\":{\"1351\":1},\"1\":{\"171\":3,\"182\":2,\"228\":1,\"234\":2,\"245\":1,\"361\":1,\"362\":1,\"396\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"495\":1,\"496\":1,\"519\":1,\"528\":2,\"545\":1,\"547\":1,\"549\":1,\"560\":2,\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"727\":2,\"817\":2,\"824\":1,\"826\":1,\"977\":2,\"978\":1,\"1002\":1,\"1003\":1,\"1017\":2,\"1023\":1,\"1032\":1,\"1033\":2,\"1047\":1,\"1058\":1,\"1059\":1,\"1064\":1,\"1071\":1,\"1072\":1,\"1075\":1,\"1076\":1,\"1091\":3,\"1096\":4,\"1119\":1,\"1124\":1,\"1167\":1,\"1199\":2,\"1208\":1,\"1217\":1,\"1242\":1,\"1255\":1}}],[\"999\",{\"1\":{\"971\":2}}],[\"99\",{\"1\":{\"727\":1,\"1204\":2}}],[\"94\",{\"1\":{\"727\":3}}],[\"9+\",{\"1\":{\"528\":1}}],[\"900\",{\"1\":{\"910\":1}}],[\"90\",{\"1\":{\"495\":1}}],[\"9隔了整整三年\",{\"1\":{\"494\":1}}],[\"9开始为半年更新一次\",{\"1\":{\"494\":1}}],[\"9带来的直观改变不是很多\",{\"1\":{\"484\":1}}],[\"9新增了一些更加方便的操作\",{\"1\":{\"480\":1}}],[\"9得到了进一步的增强\",{\"1\":{\"476\":1}}],[\"9之后\",{\"1\":{\"475\":1,\"480\":1}}],[\"9中\",{\"1\":{\"474\":1}}],[\"9为我们通过了一种交互式编程工具jshell\",{\"1\":{\"473\":1}}],[\"9的时候其实就已经引入了全新的http\",{\"1\":{\"489\":1}}],[\"9的多版本jar包支持\",{\"1\":{\"480\":1}}],[\"9的模块新特性\",{\"1\":{\"463\":1}}],[\"9的主要特性有\",{\"1\":{\"458\":1}}],[\"9以及之后的版本下运行\",{\"1\":{\"463\":1}}],[\"9以上的模块项目\",{\"1\":{\"463\":1}}],[\"9引入了模块机制来对这种情况进行优化\",{\"1\":{\"460\":1}}],[\"92\",{\"1\":{\"222\":1,\"437\":1,\"1136\":1}}],[\"95\",{\"1\":{\"222\":1}}],[\"98597252\",{\"1\":{\"1190\":1}}],[\"98\",{\"1\":{\"222\":1}}],[\"9\",{\"0\":{\"1338\":1},\"1\":{\"171\":3,\"234\":1,\"330\":2,\"403\":1,\"431\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"462\":1,\"495\":1,\"496\":1,\"528\":1,\"727\":3,\"746\":2,\"1091\":2,\"1096\":2,\"1208\":1,\"1290\":1}}],[\"77\",{\"1\":{\"1204\":1,\"1278\":1}}],[\"775\",{\"1\":{\"746\":2}}],[\"7478463438252262094l\",{\"1\":{\"1104\":1}}],[\"74f6c5d8\",{\"1\":{\"852\":1}}],[\"7<\",{\"1\":{\"1017\":1,\"1033\":1,\"1071\":1}}],[\"700\",{\"1\":{\"910\":1}}],[\"70\",{\"1\":{\"495\":2}}],[\"7新增了try\",{\"1\":{\"247\":1}}],[\"72\",{\"1\":{\"222\":1}}],[\"75的hashmap\",{\"1\":{\"224\":1}}],[\"75\",{\"1\":{\"215\":1,\"217\":2,\"437\":1}}],[\"7\",{\"0\":{\"1350\":1},\"1\":{\"171\":3,\"361\":1,\"396\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"495\":1,\"496\":1,\"687\":1,\"727\":2,\"797\":1,\"865\":1,\"1025\":2,\"1047\":1,\"1091\":2,\"1096\":2,\"1208\":1,\"1260\":2}}],[\"66\",{\"1\":{\"1204\":1}}],[\"666\",{\"1\":{\"385\":1,\"979\":2}}],[\"6要求你使用的java版本为17及以上\",{\"1\":{\"1118\":1}}],[\"6<\",{\"1\":{\"1074\":1}}],[\"64\",{\"1\":{\"1047\":1}}],[\"60000\",{\"1\":{\"884\":1}}],[\"60\",{\"1\":{\"172\":1,\"437\":1,\"495\":2}}],[\"6\",{\"0\":{\"429\":1,\"1349\":1,\"1358\":1},\"1\":{\"171\":3,\"235\":1,\"330\":2,\"397\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"495\":1,\"496\":1,\"521\":2,\"788\":1,\"791\":1,\"1091\":1,\"1096\":1,\"1113\":1,\"1208\":1,\"1253\":1}}],[\"6746\",{\"1\":{\"10\":1}}],[\"<value>ccc<\",{\"1\":{\"1136\":1}}],[\"<value>bbb<\",{\"1\":{\"1136\":1}}],[\"<value>aaa<\",{\"1\":{\"1136\":1}}],[\"<version>5\",{\"1\":{\"1017\":1,\"1033\":2,\"1260\":1,\"1290\":1}}],[\"<version>1\",{\"1\":{\"1002\":1,\"1008\":1,\"1023\":2,\"1025\":3,\"1026\":1,\"1032\":1,\"1033\":1,\"1260\":2}}],[\"<version>8\",{\"1\":{\"663\":1,\"1017\":1,\"1033\":1,\"1071\":1,\"1253\":1}}],[\"<version>2\",{\"1\":{\"611\":1,\"616\":1,\"1018\":1,\"1074\":1,\"1175\":1}}],[\"<version>3\",{\"1\":{\"559\":1,\"663\":2,\"1017\":1,\"1024\":1,\"1033\":1,\"1037\":1,\"1071\":1,\"1253\":2}}],[\"<version>6\",{\"1\":{\"544\":1,\"551\":1,\"649\":2,\"663\":1,\"1118\":1,\"1217\":1,\"1253\":1,\"1290\":1}}],[\"<role\",{\"1\":{\"1047\":2}}],[\"<result\",{\"1\":{\"835\":2,\"850\":5,\"851\":2,\"853\":3,\"854\":2,\"855\":5,\"898\":1}}],[\"<resultmap\",{\"1\":{\"835\":1,\"841\":1,\"849\":1,\"850\":1,\"851\":1,\"853\":1,\"854\":1,\"855\":2,\"898\":1}}],[\"<路径>\",{\"1\":{\"1042\":1}}],[\"<端口>\",{\"1\":{\"1042\":1}}],[\"<主机>\",{\"1\":{\"1042\":1}}],[\"<协议>\",{\"1\":{\"1042\":1}}],[\"<goal>single<\",{\"1\":{\"1037\":1}}],[\"<goals>\",{\"1\":{\"1037\":1}}],[\"<groupid>jakarta\",{\"1\":{\"1175\":1}}],[\"<groupid>javax\",{\"1\":{\"1018\":1}}],[\"<groupid>log4j<\",{\"1\":{\"1025\":1}}],[\"<groupid>mysql<\",{\"1\":{\"1017\":1,\"1033\":1,\"1071\":1}}],[\"<groupid>commons\",{\"1\":{\"1074\":1}}],[\"<groupid>com\",{\"1\":{\"611\":1,\"616\":1,\"663\":1,\"1002\":1,\"1023\":2,\"1026\":1,\"1253\":1,\"1260\":1}}],[\"<groupid>org\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"649\":2,\"663\":3,\"1008\":1,\"1017\":2,\"1024\":1,\"1025\":2,\"1026\":1,\"1032\":1,\"1033\":5,\"1071\":1,\"1118\":1,\"1217\":1,\"1253\":3,\"1260\":2,\"1290\":2}}],[\"<entry\",{\"1\":{\"1136\":3}}],[\"<environment\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"<environments\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"<execution>\",{\"1\":{\"1037\":1}}],[\"<executions>\",{\"1\":{\"1037\":1}}],[\"<exclusion>\",{\"1\":{\"1026\":1}}],[\"<exclusions>\",{\"1\":{\"1026\":1}}],[\"<foreach\",{\"1\":{\"876\":1,\"877\":1}}],[\"<form\",{\"1\":{\"619\":1,\"636\":1,\"641\":1,\"660\":1,\"682\":1,\"683\":1,\"1069\":1,\"1075\":1}}],[\"<optional>true<\",{\"1\":{\"1025\":4}}],[\"<otherwise>\",{\"1\":{\"874\":1}}],[\"<outer>\",{\"1\":{\"817\":1}}],[\"<when\",{\"1\":{\"874\":2}}],[\"<web\",{\"1\":{\"545\":1}}],[\"<cache\",{\"1\":{\"884\":2}}],[\"<choose>\",{\"1\":{\"874\":1}}],[\"<collection\",{\"1\":{\"853\":1,\"854\":1}}],[\"<constructor\",{\"1\":{\"1134\":1,\"1135\":2}}],[\"<constructor>\",{\"1\":{\"841\":2,\"900\":1}}],[\"<configuration>\",{\"1\":{\"824\":1,\"1017\":1,\"1037\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"<context\",{\"1\":{\"549\":1,\"1086\":1}}],[\"<code>run<\",{\"1\":{\"296\":2}}],[\"<code>runnable<\",{\"1\":{\"296\":1}}],[\"<user\",{\"1\":{\"1047\":2}}],[\"<update\",{\"1\":{\"863\":1}}],[\"<url>https\",{\"1\":{\"1010\":1}}],[\"<url\",{\"1\":{\"545\":1,\"1054\":4}}],[\"<mirrorof>central<\",{\"1\":{\"1010\":1}}],[\"<mirror>\",{\"1\":{\"1010\":1}}],[\"<map>\",{\"1\":{\"1136\":1}}],[\"<mappers>\",{\"1\":{\"826\":1,\"842\":1,\"894\":2,\"1017\":1,\"1071\":1,\"1255\":1}}],[\"<mapper\",{\"1\":{\"826\":2,\"842\":2,\"894\":1,\"1017\":1,\"1071\":1,\"1255\":1}}],[\"<mainclass>com\",{\"1\":{\"1037\":1}}],[\"<manifest>\",{\"1\":{\"1037\":1}}],[\"<maven\",{\"1\":{\"1002\":2,\"1032\":2}}],[\"<modelversion>4\",{\"1\":{\"1002\":1,\"1023\":1,\"1032\":1}}],[\"<meta\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"<name>阿里云公共仓库<\",{\"1\":{\"1010\":1}}],[\"<name>阿伟<\",{\"1\":{\"817\":1}}],[\"<name><\",{\"1\":{\"818\":1}}],[\"<list>\",{\"1\":{\"1136\":1}}],[\"<li>\",{\"1\":{\"683\":1}}],[\"<label>\",{\"1\":{\"636\":3,\"666\":1,\"686\":1,\"1069\":2,\"1093\":1}}],[\"<import\",{\"1\":{\"1124\":1}}],[\"<if\",{\"1\":{\"873\":1,\"902\":2}}],[\"<iframe\",{\"1\":{\"641\":1}}],[\"<id>make\",{\"1\":{\"1037\":1}}],[\"<id>aliyunmaven<\",{\"1\":{\"1010\":1}}],[\"<id\",{\"1\":{\"850\":2,\"851\":1,\"853\":2,\"854\":1,\"855\":3,\"898\":1}}],[\"<idarg\",{\"1\":{\"841\":1,\"900\":1}}],[\"<i\",{\"1\":{\"683\":1}}],[\"<insert\",{\"1\":{\"861\":1,\"862\":1,\"877\":1,\"897\":1}}],[\"<inner\",{\"1\":{\"817\":1}}],[\"<input\",{\"1\":{\"619\":2,\"636\":3,\"641\":1,\"660\":2,\"666\":2,\"682\":3,\"683\":1,\"686\":1,\"1069\":2,\"1075\":1,\"1093\":1}}],[\"<init\",{\"1\":{\"548\":1}}],[\"<datasource\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"<descriptorref>jar\",{\"1\":{\"1037\":1}}],[\"<descriptorrefs>\",{\"1\":{\"1037\":1}}],[\"<desc>怎么又在玩电动啊<\",{\"1\":{\"817\":1}}],[\"<dependencymanagement>\",{\"1\":{\"1033\":2}}],[\"<dependency>\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"611\":1,\"616\":1,\"649\":2,\"663\":4,\"1008\":1,\"1017\":3,\"1018\":1,\"1023\":1,\"1024\":1,\"1025\":3,\"1026\":1,\"1033\":6,\"1071\":2,\"1074\":1,\"1118\":1,\"1175\":1,\"1217\":1,\"1253\":4,\"1260\":3,\"1290\":2}}],[\"<dependencies>\",{\"1\":{\"1008\":1,\"1024\":1,\"1033\":4}}],[\"<delete\",{\"1\":{\"864\":1,\"876\":1}}],[\"<div>\",{\"1\":{\"619\":1,\"636\":1,\"666\":1,\"1069\":3,\"1075\":2,\"1093\":1}}],[\"<div\",{\"1\":{\"563\":1,\"605\":1,\"636\":1,\"643\":2,\"682\":1,\"686\":1,\"1076\":1}}],[\"<systempath>c\",{\"1\":{\"1018\":1}}],[\"<scope>provided<\",{\"1\":{\"1033\":2}}],[\"<scope>system<\",{\"1\":{\"1018\":1}}],[\"<scope>test<\",{\"1\":{\"1017\":1,\"1033\":2,\"1290\":1}}],[\"<script>\",{\"1\":{\"617\":3,\"636\":1,\"642\":1,\"902\":1,\"1076\":1}}],[\"<script\",{\"1\":{\"563\":1,\"564\":1,\"617\":2,\"636\":1,\"641\":1,\"642\":1}}],[\"<session\",{\"1\":{\"1097\":2}}],[\"<setting\",{\"1\":{\"852\":1,\"951\":2,\"1017\":3}}],[\"<settings>\",{\"1\":{\"852\":1,\"1017\":1}}],[\"<select\",{\"1\":{\"826\":1,\"831\":4,\"833\":1,\"834\":1,\"835\":1,\"836\":2,\"841\":1,\"842\":3,\"843\":1,\"849\":1,\"851\":2,\"854\":2,\"855\":3,\"873\":1,\"874\":1,\"886\":1,\"887\":1,\"895\":1,\"902\":1}}],[\"<sex>男<\",{\"1\":{\"817\":1}}],[\"<servlet\",{\"1\":{\"545\":4,\"548\":2,\"1054\":8}}],[\"<servlet>\",{\"1\":{\"545\":1,\"548\":1,\"1054\":1}}],[\"<strong>萨达睡觉了大数据<\",{\"1\":{\"643\":2}}],[\"<span>remember\",{\"1\":{\"686\":1}}],[\"<span\",{\"1\":{\"617\":2}}],[\"<bean\",{\"1\":{\"1119\":2,\"1125\":2,\"1126\":2,\"1127\":6,\"1128\":1,\"1130\":1,\"1131\":2,\"1133\":7,\"1134\":3,\"1136\":2,\"1137\":2,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1149\":3,\"1150\":2,\"1151\":2,\"1158\":1,\"1159\":2,\"1160\":1,\"1167\":1,\"1172\":2,\"1211\":1,\"1218\":2,\"1231\":2}}],[\"<beans\",{\"1\":{\"547\":1,\"549\":1,\"1119\":1,\"1124\":1,\"1167\":1,\"1217\":1}}],[\"<br>\",{\"1\":{\"1076\":1}}],[\"<build>\",{\"1\":{\"1037\":1}}],[\"<button>上传文件<\",{\"1\":{\"1075\":1}}],[\"<button>登录<\",{\"1\":{\"1069\":1}}],[\"<button\",{\"1\":{\"617\":1,\"636\":2,\"641\":1,\"666\":1,\"682\":1,\"683\":1,\"1076\":1}}],[\"<body>\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"1069\":1}}],[\"<hr>\",{\"1\":{\"1069\":1,\"1074\":1,\"1076\":1}}],[\"<h1>登录到系统<\",{\"1\":{\"1069\":1}}],[\"<h1>恭喜你解锁了全新玩法<\",{\"1\":{\"1059\":1,\"1064\":1}}],[\"<head>\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"<html\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"<phase>package<\",{\"1\":{\"1037\":1}}],[\"<plugin>\",{\"1\":{\"1037\":1}}],[\"<plugins>\",{\"1\":{\"1037\":1}}],[\"<properties>\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"<property\",{\"1\":{\"824\":4,\"1017\":4,\"1071\":4,\"1133\":3,\"1136\":2,\"1137\":1,\"1149\":2,\"1150\":3,\"1151\":1,\"1172\":1,\"1211\":1,\"1242\":4,\"1255\":4}}],[\"<project\",{\"1\":{\"1002\":2,\"1023\":1,\"1032\":1}}],[\"<packaging>pom<\",{\"1\":{\"1038\":1}}],[\"<package\",{\"1\":{\"832\":1,\"894\":1,\"1017\":1}}],[\"<parent>\",{\"1\":{\"1032\":1}}],[\"<param\",{\"1\":{\"548\":2,\"1086\":2}}],[\"<p\",{\"1\":{\"643\":1}}],[\"<p>撒大大撒大声地<\",{\"1\":{\"643\":2}}],[\"<p>密码\",{\"1\":{\"617\":1}}],[\"<p>用户名\",{\"1\":{\"617\":1}}],[\"<p>欢迎来到gayhub全球最大同性交友网站<\",{\"1\":{\"617\":2}}],[\"<p>penguin\",{\"1\":{\"564\":1}}],[\"<p>penguin<\",{\"1\":{\"562\":1}}],[\"<p>\",{\"1\":{\"296\":1,\"643\":1}}],[\"<aop\",{\"1\":{\"1218\":1,\"1219\":2,\"1220\":5,\"1223\":1,\"1224\":3,\"1225\":4,\"1231\":5}}],[\"<alias\",{\"1\":{\"1128\":1}}],[\"<addclasspath>true<\",{\"1\":{\"1037\":1}}],[\"<association\",{\"1\":{\"850\":1,\"851\":1,\"855\":2}}],[\"<archive>\",{\"1\":{\"1037\":1}}],[\"<arg\",{\"1\":{\"841\":1,\"900\":2}}],[\"<artifactid>hikaricp<\",{\"1\":{\"1260\":1}}],[\"<artifactid>helloworld<\",{\"1\":{\"1002\":1}}],[\"<artifactid>jakarta\",{\"1\":{\"1175\":1}}],[\"<artifactid>junit\",{\"1\":{\"1017\":1,\"1033\":2,\"1290\":1}}],[\"<artifactid>commons\",{\"1\":{\"1074\":1}}],[\"<artifactid>childmodel<\",{\"1\":{\"1032\":1}}],[\"<artifactid>maven\",{\"1\":{\"1037\":1}}],[\"<artifactid>maventest<\",{\"1\":{\"1032\":1}}],[\"<artifactid>mysql\",{\"1\":{\"663\":1,\"1017\":1,\"1033\":1,\"1071\":1,\"1253\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"663\":1,\"1253\":1}}],[\"<artifactid>mybatis<\",{\"1\":{\"663\":1,\"1017\":1,\"1024\":1,\"1026\":1,\"1033\":1,\"1071\":1,\"1253\":1}}],[\"<artifactid>slf4j\",{\"1\":{\"1025\":2,\"1260\":2}}],[\"<artifactid>spring\",{\"1\":{\"544\":1,\"551\":1,\"649\":2,\"663\":1,\"1118\":1,\"1217\":1,\"1253\":1,\"1290\":1}}],[\"<artifactid>testmaven<\",{\"1\":{\"1023\":2,\"1026\":1}}],[\"<artifactid>thymeleaf\",{\"1\":{\"559\":1}}],[\"<artifactid>log4j<\",{\"1\":{\"1025\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"1008\":1,\"1033\":2}}],[\"<artifactid>lbwnb<\",{\"1\":{\"1018\":1}}],[\"<artifactid>fastjson2\",{\"1\":{\"616\":1}}],[\"<artifactid>fastjson2<\",{\"1\":{\"611\":1}}],[\"<age>10<\",{\"1\":{\"817\":1}}],[\"<a>\",{\"1\":{\"522\":1}}],[\"<a\",{\"1\":{\"490\":1,\"620\":1,\"1074\":1}}],[\"<==向左的箭头就是得到的结果\",{\"1\":{\"852\":1}}],[\"<====\",{\"1\":{\"852\":3}}],[\"<==\",{\"1\":{\"852\":3}}],[\"<=\",{\"1\":{\"228\":1,\"384\":1,\"403\":1,\"763\":1,\"871\":1,\"876\":1}}],[\"<<\",{\"1\":{\"217\":2}}],[\"<\",{\"1\":{\"182\":2,\"217\":1,\"228\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"318\":1,\"329\":2,\"343\":3,\"394\":1,\"431\":1,\"449\":1,\"478\":2,\"479\":2,\"480\":1,\"490\":3,\"544\":1,\"545\":5,\"547\":2,\"548\":3,\"549\":3,\"551\":1,\"559\":1,\"562\":4,\"563\":4,\"564\":6,\"605\":4,\"611\":1,\"616\":1,\"617\":11,\"619\":2,\"636\":19,\"641\":5,\"642\":5,\"643\":4,\"649\":2,\"660\":1,\"663\":4,\"666\":2,\"682\":2,\"683\":3,\"686\":2,\"763\":1,\"799\":1,\"817\":5,\"818\":2,\"819\":1,\"824\":7,\"826\":6,\"831\":4,\"832\":2,\"833\":1,\"834\":1,\"835\":3,\"836\":2,\"841\":4,\"842\":5,\"843\":1,\"849\":2,\"850\":2,\"851\":3,\"852\":1,\"853\":2,\"854\":3,\"855\":6,\"861\":1,\"862\":1,\"863\":1,\"864\":1,\"873\":2,\"874\":5,\"876\":2,\"877\":2,\"886\":1,\"887\":1,\"894\":2,\"895\":1,\"897\":1,\"898\":1,\"900\":1,\"902\":4,\"972\":2,\"1002\":3,\"1008\":2,\"1010\":1,\"1017\":13,\"1018\":1,\"1023\":3,\"1024\":2,\"1025\":3,\"1026\":4,\"1032\":4,\"1033\":10,\"1037\":10,\"1054\":7,\"1059\":1,\"1069\":7,\"1071\":9,\"1074\":1,\"1075\":3,\"1076\":1,\"1086\":1,\"1093\":2,\"1097\":1,\"1118\":1,\"1119\":2,\"1124\":2,\"1133\":4,\"1134\":1,\"1136\":7,\"1137\":1,\"1149\":2,\"1150\":2,\"1151\":1,\"1167\":2,\"1172\":1,\"1175\":1,\"1211\":1,\"1217\":3,\"1218\":1,\"1220\":4,\"1224\":1,\"1225\":2,\"1231\":2,\"1242\":6,\"1246\":1,\"1247\":1,\"1253\":8,\"1255\":7,\"1260\":3,\"1290\":2}}],[\"<typealias\",{\"1\":{\"832\":1}}],[\"<typealiases>\",{\"1\":{\"832\":2,\"1017\":1}}],[\"<transactionmanager\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":2,\"1255\":1,\"1273\":1}}],[\"<test>\",{\"1\":{\"818\":1}}],[\"<title>冠希哥全套视频<\",{\"1\":{\"642\":1}}],[\"<title>坤坤炒粉放鸡精视频在线观看<\",{\"1\":{\"641\":1}}],[\"<title>白马银行\",{\"1\":{\"636\":2}}],[\"<title>登录白马银行<\",{\"1\":{\"636\":1}}],[\"<title>title<\",{\"1\":{\"563\":1,\"605\":1}}],[\"<title>测试<\",{\"1\":{\"562\":1,\"564\":1,\"617\":2}}],[\"<t\",{\"1\":{\"173\":1}}],[\"<t>\",{\"1\":{\"171\":2,\"173\":1,\"180\":1,\"204\":1,\"343\":1,\"799\":1,\"1300\":2}}],[\"<∞\",{\"1\":{\"98\":1}}],[\"泛型和多态\",{\"0\":{\"439\":1}}],[\"泛型只能确定为一个引用类型\",{\"1\":{\"438\":1}}],[\"泛型变量不止可以只有一个\",{\"1\":{\"438\":1}}],[\"泛型将数据类型的确定控制在了编译阶段\",{\"1\":{\"438\":1}}],[\"泛型在定义时并不明确是什么类型\",{\"1\":{\"438\":1}}],[\"泛型其实就一个待定类型\",{\"1\":{\"438\":1}}],[\"泛型其实仅仅是在编译阶段进行类型检查\",{\"1\":{\"173\":1}}],[\"泛型类需要使用<>\",{\"1\":{\"438\":1}}],[\"泛型类\",{\"0\":{\"438\":1}}],[\"泛型的参数获取\",{\"1\":{\"343\":1}}],[\"泛型的类型检查只存在于编译阶段\",{\"1\":{\"237\":1}}],[\"泛型通配符也支持泛型的界限\",{\"1\":{\"172\":1}}],[\"泛型界限\",{\"0\":{\"172\":1}}],[\"泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计\",{\"1\":{\"171\":1}}],[\"泛型方法会在使用时自动确定泛型类型\",{\"1\":{\"171\":1}}],[\"泛型方法\",{\"0\":{\"171\":1}}],[\"泛型\",{\"0\":{\"169\":1,\"170\":1,\"435\":1,\"436\":1}}],[\"成功加载bean实例\",{\"1\":{\"1311\":1}}],[\"成功加载外部class文件\",{\"1\":{\"356\":1}}],[\"成功回收\",{\"1\":{\"1247\":1}}],[\"成功监听到\",{\"1\":{\"1192\":1}}],[\"成功得到结果\",{\"1\":{\"1083\":1}}],[\"成功得到页面\",{\"1\":{\"572\":1}}],[\"成功执行\",{\"1\":{\"697\":1,\"699\":2}}],[\"成功\",{\"1\":{\"636\":1,\"658\":1}}],[\"成绩可能是string类型\",{\"1\":{\"437\":1}}],[\"成员变量一样\",{\"1\":{\"408\":1}}],[\"成员变量的初始化\",{\"1\":{\"166\":1}}],[\"成员内部类的name\",{\"1\":{\"408\":2}}],[\"成员内部类的类型名称就是\",{\"1\":{\"408\":1}}],[\"成员内部类可以访问到外部的成员变量\",{\"1\":{\"408\":1}}],[\"成员内部类也可以使用访问权限控制\",{\"1\":{\"408\":1}}],[\"成员内部类和成员方法\",{\"1\":{\"408\":1}}],[\"成员内部类其实在某些情况下使用起来比较麻烦\",{\"1\":{\"408\":1}}],[\"成员内部类\",{\"0\":{\"408\":1}}],[\"成员\",{\"1\":{\"362\":1,\"406\":1}}],[\"成员属性上\",{\"1\":{\"360\":1}}],[\"成员方法也可以让对象本身不成为参与的那一方\",{\"1\":{\"452\":1}}],[\"成员方法因为需要具体对象使用\",{\"1\":{\"415\":1}}],[\"成员方法只能通过\",{\"1\":{\"415\":1}}],[\"成员方法中不能用\",{\"1\":{\"373\":1}}],[\"成员方法\",{\"1\":{\"278\":1}}],[\"成比例等于\",{\"1\":{\"155\":1}}],[\"必须保证总金额不变\",{\"1\":{\"1266\":1}}],[\"必须存在sqlsessiontemplate或是sqlsessionfactorybean的bean\",{\"1\":{\"1257\":1}}],[\"必须存在一个根节点\",{\"1\":{\"817\":1}}],[\"必须学rust\",{\"1\":{\"1224\":1}}],[\"必须一次性把依赖注入进去\",{\"1\":{\"1181\":1}}],[\"必须添加\",{\"1\":{\"1075\":1}}],[\"必须设置\",{\"1\":{\"862\":1}}],[\"必须和构造方法的顺序一致\",{\"1\":{\"841\":1}}],[\"必须加\",{\"1\":{\"727\":1}}],[\"必须配置临时上传路径\",{\"1\":{\"619\":1}}],[\"必须继承自父类\",{\"1\":{\"504\":1}}],[\"必须有子类继承\",{\"1\":{\"504\":1}}],[\"必须留一个抽象方法出来\",{\"1\":{\"414\":1,\"447\":1}}],[\"必须要进行异常的捕获\",{\"1\":{\"424\":1}}],[\"必须要考虑到出现异常的情况\",{\"1\":{\"421\":1}}],[\"必须要实现抽象类中所有抽象方法\",{\"1\":{\"375\":1}}],[\"必须要有\",{\"1\":{\"318\":1}}],[\"必须使用equals方法\",{\"1\":{\"373\":1}}],[\"必须注意是否安全\",{\"1\":{\"350\":1}}],[\"必须在开始之前\",{\"1\":{\"329\":2}}],[\"必须实现serializable接口才能被序列化\",{\"1\":{\"288\":1}}],[\"必须关闭这个流来完成对资源的释放\",{\"1\":{\"247\":1}}],[\"必须是static方法\",{\"1\":{\"985\":1}}],[\"必须是在持有锁\",{\"1\":{\"318\":1}}],[\"必须是一个对象或是一个类\",{\"1\":{\"312\":1}}],[\"必须是实现\",{\"1\":{\"234\":1}}],[\"必须是number或是number的子类\",{\"1\":{\"172\":1}}],[\"必须是递增的\",{\"1\":{\"98\":1}}],[\"必须调用我们自己定义的构造方法\",{\"1\":{\"166\":1}}],[\"除非bean自己进行配置覆盖掉默认配置\",{\"1\":{\"1152\":1}}],[\"除非有特殊需求\",{\"1\":{\"680\":1}}],[\"除非抛出的异常是一个运行时异常\",{\"1\":{\"424\":1}}],[\"除非我们手动重载一个无参构造\",{\"1\":{\"166\":1}}],[\"除了事务的传播规则\",{\"1\":{\"1280\":1}}],[\"除了\",{\"1\":{\"1236\":1}}],[\"除了此接口以外\",{\"1\":{\"1231\":1}}],[\"除了属性调用\",{\"1\":{\"1204\":1}}],[\"除了获取\",{\"1\":{\"1204\":1}}],[\"除了这些功能之外\",{\"1\":{\"1298\":1}}],[\"除了这个注解之外\",{\"1\":{\"1176\":1}}],[\"除了这种基于构造器或是setter的依赖注入之外\",{\"1\":{\"1173\":1}}],[\"除了这种方式\",{\"1\":{\"1141\":1}}],[\"除了这种简单判断外\",{\"1\":{\"978\":1}}],[\"除了为bean指定对应类型之外\",{\"1\":{\"1127\":1}}],[\"除了用写好的\",{\"1\":{\"1082\":1}}],[\"除了上述介绍的几种命令外\",{\"1\":{\"1035\":1}}],[\"除了上述例子中出现的断言方法之外\",{\"1\":{\"973\":1}}],[\"除了三个基本的属性用于定位坐标外\",{\"1\":{\"1015\":1}}],[\"除了以上方式获取参数\",{\"1\":{\"994\":1}}],[\"除了默认的名称顺序之外\",{\"1\":{\"987\":1}}],[\"除了默认的rootlogger作为父类\",{\"1\":{\"930\":1}}],[\"除了在字段上进行注入之外\",{\"1\":{\"1200\":1}}],[\"除了在所有方法执行前后插入准备工作\",{\"1\":{\"985\":1}}],[\"除了在不为空时执行的操作外\",{\"1\":{\"454\":1}}],[\"除了断言工具外\",{\"1\":{\"974\":1}}],[\"除了我们上面提到的真假判断外\",{\"1\":{\"973\":1}}],[\"除了我们手动编写接口中抽象方法的方法体之外\",{\"1\":{\"448\":1}}],[\"除了使用值进行比较外\",{\"1\":{\"970\":1}}],[\"除了使用批处理之外\",{\"1\":{\"872\":1}}],[\"除了官方为我们提供的两种默认格式外\",{\"1\":{\"944\":1}}],[\"除了if操作之外\",{\"1\":{\"874\":1}}],[\"除了controller以外\",{\"1\":{\"697\":1}}],[\"除了clone\",{\"1\":{\"393\":1}}],[\"除了直接编写一个类\",{\"1\":{\"1054\":1}}],[\"除了直接设置指定类型常量值\",{\"1\":{\"992\":1}}],[\"除了直接配置以外\",{\"1\":{\"695\":1}}],[\"除了直接运行我们写进去的代码之外\",{\"1\":{\"473\":1}}],[\"除了通过我们自己springsecurity使用去解决之外\",{\"1\":{\"641\":1}}],[\"除了jsp\",{\"1\":{\"558\":1}}],[\"除了jdk的一些常用包之外\",{\"1\":{\"461\":1}}],[\"除了map之外\",{\"1\":{\"475\":1}}],[\"除了linkedlist实现了队列接口之外\",{\"1\":{\"202\":1}}],[\"除了可以直接当做列表使用之外\",{\"1\":{\"199\":1}}],[\"除了需要求解\",{\"1\":{\"55\":1}}],[\"注入\",{\"1\":{\"1181\":2,\"1301\":1}}],[\"注入的一个好处是\",{\"1\":{\"1175\":1}}],[\"注释内容\",{\"1\":{\"817\":1}}],[\"注册所有的监听器\",{\"1\":{\"1320\":1}}],[\"注册配置类\",{\"0\":{\"1319\":1},\"1\":{\"1319\":1}}],[\"注册annotationawareaspectjautoproxycreator到容器中\",{\"1\":{\"1310\":1}}],[\"注册sqlsessiontemplate的bean\",{\"1\":{\"1254\":1}}],[\"注册\",{\"0\":{\"1167\":1}}],[\"注册静态资源\",{\"0\":{\"678\":1}}],[\"注册对应包扫描\",{\"0\":{\"671\":1}}],[\"注册二号拦截器\",{\"1\":{\"600\":1}}],[\"注解或是xml配置文件中的value属性使用\",{\"1\":{\"1211\":1}}],[\"注解将外部配置文件中的值注入到任何我们想要的位置\",{\"1\":{\"1199\":1}}],[\"注解形式的配置确实能够减少我们很多工作量\",{\"1\":{\"1179\":1}}],[\"注解顺序可以由我们自己通过注解来手动定义执行顺序\",{\"1\":{\"987\":1}}],[\"注解不允许循环引用\",{\"1\":{\"901\":1}}],[\"注解只支持嵌套查询\",{\"0\":{\"901\":1}}],[\"注解只有成员变量\",{\"1\":{\"364\":1}}],[\"注解定义如下\",{\"1\":{\"569\":1}}],[\"注解定义上等\",{\"1\":{\"360\":1}}],[\"注解就是一个标记\",{\"1\":{\"534\":1}}],[\"注解理解\",{\"0\":{\"534\":1}}],[\"注解之后的又一新类型\",{\"1\":{\"501\":1}}],[\"注解的成员变量在注解的定义中以\",{\"1\":{\"364\":1}}],[\"注解的属性也叫做成员变量\",{\"1\":{\"364\":1}}],[\"注解的使用分成两类\",{\"1\":{\"534\":1}}],[\"注解的使用\",{\"0\":{\"364\":1}}],[\"注解并没有继承于任何子类\",{\"1\":{\"362\":1}}],[\"注解本质上也是一个类\",{\"1\":{\"360\":1}}],[\"注解也可以选择是否保留到运行时\",{\"1\":{\"360\":1}}],[\"注解可以通过反射在运行时获取\",{\"1\":{\"360\":1}}],[\"注解可以被标注在任意地方\",{\"1\":{\"360\":1}}],[\"注解\",{\"0\":{\"359\":1,\"360\":1,\"696\":1,\"697\":1,\"902\":1,\"959\":1},\"1\":{\"373\":1,\"575\":1,\"603\":1,\"1318\":1}}],[\"注意它后置处理器也要进行注册\",{\"1\":{\"1307\":1}}],[\"注意它会抛出instantiationexception和illegalaccessexception异常\",{\"1\":{\"348\":1}}],[\"注意父工厂不能拿到子工厂的\",{\"1\":{\"1298\":1}}],[\"注意版本一定要和slf4j\",{\"1\":{\"1260\":1}}],[\"注意使用的还是之前的connection对象\",{\"1\":{\"1246\":1}}],[\"注意new了之后并没有立即往list里面塞\",{\"1\":{\"1246\":1}}],[\"注意是bean的名字\",{\"1\":{\"1231\":1}}],[\"注意是webapp根目录下的\",{\"1\":{\"1084\":1}}],[\"注意第一个字符必须为\",{\"1\":{\"1092\":1}}],[\"注意最后一个字符必须为\",{\"1\":{\"1092\":1}}],[\"注意不同路径的写法\",{\"1\":{\"1069\":1}}],[\"注意在when中不允许使用<或是>这种模糊匹配的条件\",{\"1\":{\"874\":1}}],[\"注意返回类型必须是int或是long这类数字类型\",{\"1\":{\"861\":1}}],[\"注意返回值是class<\",{\"1\":{\"339\":1}}],[\"注意sql语句中一些字段存在歧义\",{\"1\":{\"855\":1}}],[\"注意send方法后面参数\",{\"1\":{\"490\":1}}],[\"注意set中元素顺序并不一定你的添加顺序\",{\"1\":{\"475\":1}}],[\"注意接口的参数和返回值必须正确对应\",{\"1\":{\"842\":1}}],[\"注意参数的顺序\",{\"1\":{\"841\":1}}],[\"注意全参构造必须与查询结果字段参数一一对应\",{\"1\":{\"841\":1}}],[\"注意由于这里是xml配置\",{\"1\":{\"836\":1}}],[\"注意key的名称需要与我们编写的sql语句中占位符一致\",{\"1\":{\"834\":1}}],[\"注意静态字段不会生成\",{\"1\":{\"812\":1}}],[\"注意前两步都放在try\",{\"1\":{\"788\":1}}],[\"注意必须添加enctype=\",{\"1\":{\"1075\":1}}],[\"注意必须是数字类型\",{\"1\":{\"765\":1}}],[\"注意必须是数字类型的\",{\"1\":{\"765\":1}}],[\"注意必须携带set方法或是构造方法中包含所有参数\",{\"1\":{\"583\":1}}],[\"注意一定要换行再写\",{\"1\":{\"727\":1}}],[\"注意需要跟原方法保持一致\",{\"1\":{\"1235\":1}}],[\"注意需要指明生效的切点\",{\"1\":{\"1220\":1}}],[\"注意需要添加\",{\"1\":{\"720\":1}}],[\"注意需要在配置类中添加一下fastjson转换器\",{\"1\":{\"616\":1}}],[\"注意执行过程中出现任何问题都会抛出异常\",{\"1\":{\"711\":1}}],[\"注意拦截顺序就是注册的顺序\",{\"1\":{\"600\":1}}],[\"注意请求路径我们可以手动添加类似占位符一样的信息\",{\"1\":{\"589\":1}}],[\"注意路径必须全局唯一\",{\"1\":{\"569\":1}}],[\"注意子类格式为\",{\"1\":{\"504\":1}}],[\"注意处理完成后需要返回最终结果\",{\"1\":{\"497\":1}}],[\"注意私有方法必须要提供方法体\",{\"1\":{\"474\":1}}],[\"注意只是相当于外部来说\",{\"1\":{\"409\":1}}],[\"注意传参\",{\"1\":{\"349\":1}}],[\"注意此class对象只会存在一个\",{\"1\":{\"337\":1}}],[\"注意这样的话con就为null了\",{\"1\":{\"1246\":1}}],[\"注意这里一定要区分factorybean和beanfactory的概念\",{\"1\":{\"1328\":1}}],[\"注意这里的初始化不是创建对象\",{\"1\":{\"1307\":1}}],[\"注意这里的路径规则和之前的不同\",{\"1\":{\"1083\":1}}],[\"注意这里仅仅是不允许修改数据\",{\"1\":{\"1267\":1}}],[\"注意这里还入了一些新的aop相关的约束进来\",{\"1\":{\"1217\":1}}],[\"注意这里是过滤器\",{\"1\":{\"704\":1}}],[\"注意这里是在mvc的配置类上添加\",{\"1\":{\"695\":1}}],[\"注意这里需要添加\",{\"1\":{\"588\":1}}],[\"注意这里调用的不是静态方法\",{\"1\":{\"451\":1}}],[\"注意这是一个泛型类\",{\"1\":{\"319\":1}}],[\"注意这个类也得注册为bean才可以\",{\"1\":{\"1218\":1}}],[\"注意这个是一个抽象类\",{\"1\":{\"323\":1}}],[\"注意这个填充是对集合中已有的元素进行覆盖\",{\"1\":{\"235\":1}}],[\"注意这个接口是集合接口的父接口\",{\"1\":{\"193\":1}}],[\"注意\",{\"1\":{\"166\":1,\"182\":2,\"191\":1,\"228\":1,\"234\":1,\"247\":1,\"248\":2,\"249\":1,\"277\":1,\"286\":1,\"287\":1,\"305\":1,\"318\":1,\"340\":1,\"356\":1,\"398\":1,\"400\":1,\"408\":1,\"423\":1,\"424\":2,\"497\":2,\"498\":1,\"499\":1,\"501\":1,\"579\":1,\"625\":1,\"660\":1,\"720\":1,\"755\":1,\"767\":1,\"788\":1,\"799\":1,\"806\":2,\"865\":1,\"884\":1,\"912\":1,\"988\":1,\"1010\":1,\"1024\":1,\"1036\":1,\"1075\":1,\"1118\":1,\"1148\":1,\"1149\":1,\"1151\":1,\"1158\":1,\"1159\":1,\"1198\":1,\"1224\":1,\"1253\":1}}],[\"注重近期的reward\",{\"1\":{\"19\":1}}],[\"跟name功能相同\",{\"1\":{\"1127\":1}}],[\"跟next相反\",{\"1\":{\"194\":1}}],[\"跟jdbc是一样的\",{\"1\":{\"830\":1}}],[\"跟上面一样可自定义\",{\"1\":{\"683\":1}}],[\"跟之前一样\",{\"1\":{\"682\":1,\"1231\":1}}],[\"跟之前的\",{\"1\":{\"219\":1}}],[\"跟对象成员变量的默认值是一样的\",{\"1\":{\"392\":1}}],[\"跟普通的类一样\",{\"1\":{\"376\":1}}],[\"跟普通方法是一样的\",{\"1\":{\"166\":1}}],[\"跟我们之前的图标不太一样\",{\"1\":{\"1224\":1}}],[\"跟我们之前的顺序表思路差不多\",{\"1\":{\"182\":1}}],[\"跟我们之前不一样\",{\"1\":{\"215\":1}}],[\"跟我们之前顺序表的插入是一样的\",{\"1\":{\"181\":1}}],[\"跟随一个\",{\"1\":{\"154\":1}}],[\"跟随策略π\",{\"1\":{\"81\":1}}],[\"男\",{\"1\":{\"166\":2,\"373\":4,\"376\":1,\"377\":1,\"378\":1,\"796\":1,\"1277\":1}}],[\"默认构造后存放在这里的是一个defaultlistablebeanfactory对象\",{\"1\":{\"1296\":1}}],[\"默认发生任何异常都回滚\",{\"1\":{\"1279\":1}}],[\"默认导入的类可以不加包名\",{\"1\":{\"1205\":1}}],[\"默认启动就会运行\",{\"1\":{\"1190\":1}}],[\"默认名称是对应的方法名称\",{\"1\":{\"1178\":1}}],[\"默认全局配置\",{\"0\":{\"1152\":1}}],[\"默认时间为30分钟\",{\"1\":{\"1097\":1}}],[\"默认为单例模式\",{\"1\":{\"1129\":1}}],[\"默认为我们提供了很多类型的监听器\",{\"1\":{\"1105\":1}}],[\"默认为false\",{\"1\":{\"1092\":1}}],[\"默认为升序\",{\"1\":{\"764\":1}}],[\"默认在导入依赖时\",{\"1\":{\"1025\":1}}],[\"默认建立在c盘\",{\"1\":{\"1009\":1}}],[\"默认日志级别\",{\"1\":{\"910\":1}}],[\"默认获取第一个构造方法\",{\"1\":{\"799\":1}}],[\"默认并不是你创建的数据库\",{\"1\":{\"750\":1}}],[\"默认值仅在插入数据时使用\",{\"1\":{\"747\":1}}],[\"默认值为false\",{\"1\":{\"161\":1}}],[\"默认有三种实现httprequesthandleradapter\",{\"1\":{\"625\":1}}],[\"默认有一个指向集合中第一个元素的指针\",{\"1\":{\"188\":1}}],[\"默认即可\",{\"1\":{\"560\":1}}],[\"默认是以xml格式进行写入的\",{\"1\":{\"920\":1}}],[\"默认是restrict\",{\"1\":{\"751\":1}}],[\"默认是webapp目录下\",{\"1\":{\"560\":1}}],[\"默认是不传递的\",{\"1\":{\"465\":1}}],[\"默认是接收控制台输入\",{\"1\":{\"285\":1}}],[\"默认使用的就是任意ip地址\",{\"1\":{\"772\":1}}],[\"默认使用的是池化数据源\",{\"1\":{\"1252\":1}}],[\"默认使用的是\",{\"1\":{\"516\":1}}],[\"默认使用\",{\"0\":{\"451\":1}}],[\"默认会让整个程序终止并打印栈追踪信息\",{\"1\":{\"424\":1}}],[\"默认会交给\",{\"1\":{\"424\":1}}],[\"默认会返回\",{\"1\":{\"214\":1}}],[\"默认继承自\",{\"1\":{\"421\":1}}],[\"默认private\",{\"1\":{\"378\":1}}],[\"默认实现是直接用等号判断\",{\"1\":{\"372\":1}}],[\"默认只有一个属性时\",{\"1\":{\"364\":1}}],[\"默认\",{\"0\":{\"1178\":1},\"1\":{\"278\":2,\"362\":1,\"747\":1}}],[\"默认从小到大排序\",{\"1\":{\"228\":1}}],[\"默认情况\",{\"1\":{\"497\":1}}],[\"默认情况按照自然顺序\",{\"1\":{\"203\":1}}],[\"默认情况下bean都是单例的\",{\"1\":{\"1148\":2}}],[\"默认情况下就是这一种\",{\"1\":{\"1129\":1}}],[\"默认情况下为per\",{\"1\":{\"986\":1}}],[\"默认情况下一个mapper中所有的操作都会使用二级缓存\",{\"1\":{\"886\":1}}],[\"默认情况下如果不配置此项则不会进行定时清理\",{\"1\":{\"884\":1}}],[\"默认情况下别名就是类的名称\",{\"1\":{\"832\":1}}],[\"默认情况下会一并引入所有此项目包含的依赖项\",{\"1\":{\"1024\":1}}],[\"默认情况下会启用csrf保护\",{\"1\":{\"660\":1}}],[\"默认情况下会认为传入的是int类型值\",{\"1\":{\"182\":1}}],[\"默认情况下cookie就会被自动屏蔽\",{\"1\":{\"641\":1}}],[\"默认情况下所有的包都是私有的\",{\"1\":{\"464\":1}}],[\"默认情况下是直接导出所有的包\",{\"1\":{\"463\":1}}],[\"默认情况下直接运行什么都没有\",{\"1\":{\"399\":1}}],[\"默认情况下格式为\",{\"1\":{\"372\":1}}],[\"默认情况下\",{\"1\":{\"278\":1,\"337\":1,\"883\":1,\"921\":1,\"986\":1,\"987\":1,\"1064\":1,\"1129\":1,\"1157\":1}}],[\"默认情况下包名是可以省略的\",{\"1\":{\"277\":1}}],[\"默认情况下阈值也是0\",{\"1\":{\"217\":1}}],[\"默认情况下每个类都会自带一个没有任何参数的无参构造方法\",{\"1\":{\"166\":1}}],[\"默认都是尾插\",{\"1\":{\"200\":1}}],[\"默认的servlet实际上可以帮助我们去访问一些静态资源\",{\"1\":{\"1054\":1}}],[\"默认的依赖有效范围\",{\"1\":{\"1016\":1}}],[\"默认的情况下\",{\"1\":{\"278\":1}}],[\"默认的列表最大长度为integer\",{\"1\":{\"182\":1}}],[\"默认的数组容量\",{\"1\":{\"182\":1}}],[\"默认就是这个\",{\"1\":{\"686\":1}}],[\"默认就是原始类型\",{\"1\":{\"173\":1}}],[\"默认就是object\",{\"1\":{\"173\":1}}],[\"优秀\",{\"1\":{\"437\":1,\"438\":2,\"495\":2,\"496\":1,\"497\":2}}],[\"优先选择\",{\"0\":{\"1141\":1}}],[\"优先查看你的springsecurity配置是否错误\",{\"1\":{\"660\":1}}],[\"优先使用cpu资源\",{\"1\":{\"302\":1}}],[\"优先使用作用域最接近的\",{\"1\":{\"164\":1}}],[\"优先级越高的线程\",{\"1\":{\"302\":2}}],[\"优先级队列只能保证出队顺序是按照优先级进行的\",{\"1\":{\"203\":1}}],[\"优先级队列并不是队列中所有的元素都是按照优先级排放的\",{\"1\":{\"203\":1}}],[\"优先级队列可以根据每一个元素的优先级\",{\"1\":{\"203\":1}}],[\"优先级队列\",{\"0\":{\"203\":1},\"1\":{\"202\":1}}],[\"优化\",{\"1\":{\"275\":1}}],[\"优化方法\",{\"0\":{\"142\":1}}],[\"优化算法\",{\"0\":{\"136\":1}}],[\"优化目标函数的算法\",{\"1\":{\"132\":1}}],[\"优化问题\",{\"1\":{\"103\":1}}],[\"优化问题建立\",{\"0\":{\"11\":1}}],[\"出现严重故障的消息级别\",{\"1\":{\"910\":1}}],[\"出现重名时\",{\"1\":{\"164\":1}}],[\"出来的时候\",{\"1\":{\"217\":1}}],[\"出发的\",{\"1\":{\"82\":1,\"137\":1}}],[\"出发\",{\"1\":{\"78\":2,\"84\":1}}],[\"运用了封装的思想\",{\"1\":{\"384\":1}}],[\"运用到\",{\"1\":{\"29\":1}}],[\"运行之后\",{\"1\":{\"1231\":1}}],[\"运行程序之后\",{\"1\":{\"1172\":1}}],[\"运行服务器\",{\"1\":{\"1069\":1}}],[\"运行\",{\"1\":{\"1016\":1}}],[\"运行时得到如下报错\",{\"1\":{\"1126\":1}}],[\"运行时出现错误\",{\"1\":{\"841\":1}}],[\"运行时异常只需要继承\",{\"1\":{\"422\":1}}],[\"运行时异常\",{\"1\":{\"421\":1}}],[\"运行后发现\",{\"1\":{\"835\":1}}],[\"运行期生效\",{\"1\":{\"534\":1}}],[\"运行函数\",{\"1\":{\"323\":1}}],[\"运行态\",{\"1\":{\"318\":1}}],[\"运行main\",{\"1\":{\"295\":1}}],[\"运算符\",{\"1\":{\"162\":1,\"1209\":1}}],[\"小刘\",{\"1\":{\"877\":2}}],[\"小张\",{\"1\":{\"877\":2}}],[\"小黑子\",{\"1\":{\"871\":1}}],[\"小美\",{\"1\":{\"871\":1,\"877\":2}}],[\"小强\",{\"1\":{\"871\":1}}],[\"小刚\",{\"1\":{\"871\":1}}],[\"小辣椒\",{\"1\":{\"810\":1}}],[\"小王\",{\"1\":{\"376\":1,\"871\":1}}],[\"小于0表示小于\",{\"1\":{\"171\":1}}],[\"小明\",{\"1\":{\"162\":1,\"166\":1,\"214\":4,\"373\":4,\"377\":1,\"378\":1,\"408\":1,\"852\":1,\"1008\":1,\"1149\":2,\"1150\":1,\"1151\":1,\"1208\":1}}],[\"小红\",{\"1\":{\"161\":1,\"214\":2,\"408\":1}}],[\"果直接创建对象\",{\"1\":{\"161\":1}}],[\"它并不是依靠spring直接通过反射创建\",{\"1\":{\"1327\":1}}],[\"它从初始化到实例化所有的bean整个流程都已经完成\",{\"1\":{\"1320\":1}}],[\"它和前者一样\",{\"1\":{\"1311\":1}}],[\"它和map的使用方法一样\",{\"1\":{\"612\":1}}],[\"它实现了beandefinitionregistrypostprocessor\",{\"1\":{\"1327\":1}}],[\"它实现了接口\",{\"1\":{\"1310\":1}}],[\"它实现了getbean\",{\"1\":{\"1300\":1}}],[\"它实际上包含了很多的模块\",{\"1\":{\"1118\":1}}],[\"它非常严格\",{\"1\":{\"1283\":1}}],[\"它非常容易理解\",{\"1\":{\"610\":1}}],[\"它希望将实现交给其他的管理框架来完成\",{\"1\":{\"1273\":1}}],[\"它毫无意义\",{\"1\":{\"1271\":1}}],[\"它规定在其他事务执行时\",{\"1\":{\"1270\":1}}],[\"它规范了多种日志框架的操作\",{\"1\":{\"1260\":1}}],[\"它完全服从acid原则\",{\"1\":{\"1267\":1}}],[\"它完全将此方法包含在中间\",{\"1\":{\"1224\":1}}],[\"它其实是spring提供的一种后置处理机制\",{\"1\":{\"1306\":1}}],[\"它其实是通过动态代理生成的\",{\"1\":{\"842\":1}}],[\"它其实就是官方封装的一个工具类\",{\"1\":{\"1254\":1}}],[\"它预先存储了很多的连接对象\",{\"1\":{\"1252\":1}}],[\"它都最终都会使用drivermanager来创建连接对象\",{\"1\":{\"1247\":1}}],[\"它调用了popconnection\",{\"1\":{\"1245\":1}}],[\"它调用了内部的一个私有的方法opensessionfromdatasource\",{\"1\":{\"1242\":1}}],[\"它存放了一个unpooleddatasource\",{\"1\":{\"1245\":1}}],[\"它叫做unpooleddatasource\",{\"1\":{\"1244\":1}}],[\"它包括了两个方法\",{\"1\":{\"1242\":1}}],[\"它包含一个默认的consolehandler处理器用于进行控制台打印\",{\"1\":{\"927\":1}}],[\"它到底是如何封装jdbc的呢\",{\"1\":{\"1242\":1}}],[\"它到达前端后\",{\"1\":{\"610\":1}}],[\"它用起来就真的像代理一样\",{\"1\":{\"1231\":1}}],[\"它用于将我们的项目打包为jar文件\",{\"1\":{\"1036\":1}}],[\"它用于控制日志的格式\",{\"1\":{\"921\":1}}],[\"它用于处理我们的日志内容打印\",{\"1\":{\"918\":1}}],[\"它用于处理返回值\",{\"1\":{\"699\":1}}],[\"它用于处理请求并返回modelandview对象\",{\"1\":{\"625\":1}}],[\"它用于保存字符串\",{\"1\":{\"400\":1}}],[\"它相当于是一个工具类\",{\"1\":{\"1327\":1}}],[\"它相当于将我们原有的方法\",{\"1\":{\"1215\":1}}],[\"它相当于我们对某样东西的一个标记\",{\"1\":{\"360\":1}}],[\"它来自groovy语言\",{\"1\":{\"1211\":1}}],[\"它甚至还支持根据特定表达式\",{\"1\":{\"1203\":1}}],[\"它需要在哪些包中查找我们提供的\",{\"1\":{\"1177\":1}}],[\"它需要结合聚合函数一起使用\",{\"1\":{\"766\":1}}],[\"它同样可以\",{\"1\":{\"1173\":1}}],[\"它同样也支持mark\",{\"1\":{\"269\":1}}],[\"它没有将类交给父类加载器进行加载\",{\"1\":{\"1109\":1}}],[\"它只加载自己的class文件\",{\"1\":{\"1109\":1}}],[\"它只会拦截所有controller中定义的请求映射对应的请求\",{\"1\":{\"593\":1}}],[\"它要做的是去动态加载我们编写的web应用程序中的类\",{\"1\":{\"1109\":1}}],[\"它针对http请求进行了专门处理\",{\"1\":{\"1104\":1}}],[\"它有很多种实现\",{\"1\":{\"1119\":1}}],[\"它有着自己的过期时间\",{\"1\":{\"1097\":1}}],[\"它有两种用法\",{\"1\":{\"521\":1}}],[\"它根据http协议的规则\",{\"1\":{\"1059\":1}}],[\"它被细分了\",{\"1\":{\"1017\":1}}],[\"它决定了依赖的作用域范围\",{\"1\":{\"1016\":1}}],[\"它决定了当前方法处理的请求路径\",{\"1\":{\"569\":1}}],[\"它与我们之前学习的动态代理更接近一些\",{\"1\":{\"1231\":1}}],[\"它与重复测试比较类似\",{\"1\":{\"991\":1}}],[\"它与java中的for类似\",{\"1\":{\"875\":1}}],[\"它仅会作用于所属内部类中的所有测试用例\",{\"1\":{\"988\":1}}],[\"它仅仅对一个会话中的数据进行缓存\",{\"1\":{\"883\":1}}],[\"它仅仅只是一个登陆\",{\"1\":{\"626\":1}}],[\"它必须用其完全限定的名称来引用\",{\"1\":{\"980\":1}}],[\"它通常在执行给定测试没有意义时使用\",{\"1\":{\"974\":1}}],[\"它通过限制第三方cookie的使用来实现这一目的\",{\"1\":{\"641\":1}}],[\"它通过默认的forkjoinpool实现\",{\"1\":{\"330\":1}}],[\"它详细记录了所有的数据库操作等\",{\"1\":{\"951\":1}}],[\"它继承自beanpostprocessor\",{\"1\":{\"1318\":1}}],[\"它继承自beanfactorypostprocessor\",{\"1\":{\"1318\":1}}],[\"它继承自hashtable类\",{\"1\":{\"937\":1}}],[\"它继承自abstractauthenticationprocessingfilter\",{\"1\":{\"711\":1}}],[\"它之前查询的缓存依然会存在于二级缓存中\",{\"1\":{\"884\":1}}],[\"它也是通过registrar机制\",{\"1\":{\"1326\":1}}],[\"它也是通过代理实现的\",{\"1\":{\"588\":1}}],[\"它也是以键值对形式保存的\",{\"1\":{\"1085\":1}}],[\"它也是使用xml格式编写的\",{\"1\":{\"1002\":1}}],[\"它也是现在提高数据获取效率的良好解决方案\",{\"1\":{\"882\":1}}],[\"它类似于java中的switch语句\",{\"1\":{\"874\":1}}],[\"它采用ognl表达式进行编写\",{\"1\":{\"873\":1}}],[\"它代表的就是ioc容器\",{\"1\":{\"1119\":1}}],[\"它代表执行sql后受影响的行数\",{\"1\":{\"860\":1}}],[\"它代表当前类的版本\",{\"1\":{\"289\":1}}],[\"它适用于单个数据查询或是多行数据查询\",{\"1\":{\"836\":1}}],[\"它返回的map是使用我们想要的属性作为key\",{\"1\":{\"836\":1}}],[\"它提供了当前日志记录的相关信息\",{\"1\":{\"944\":1}}],[\"它提供的接口\",{\"1\":{\"787\":1}}],[\"它提前帮助我们规定了一些标签\",{\"1\":{\"824\":1}}],[\"它内部就还有子节点\",{\"1\":{\"819\":1}}],[\"它更像是一个配置文件\",{\"1\":{\"817\":1}}],[\"它所做的工作就是我们上面所说的\",{\"1\":{\"811\":1}}],[\"它对jdbc进行了深层次的封装\",{\"1\":{\"799\":1}}],[\"它保证数据的参照完整性\",{\"1\":{\"747\":1}}],[\"它专门用于数据库的操作\",{\"1\":{\"744\":1}}],[\"它至少要包含一个响应码\",{\"1\":{\"727\":1}}],[\"它做的事情不像是拦截\",{\"1\":{\"714\":1}}],[\"它由genericfilterbean\",{\"1\":{\"706\":1}}],[\"它本身是一个接口\",{\"1\":{\"1316\":1}}],[\"它本身也是类\",{\"1\":{\"392\":1}}],[\"它本质也是基于tcp协议进行数据传输\",{\"1\":{\"727\":1}}],[\"它本质上也是一个filter\",{\"1\":{\"705\":2}}],[\"它为每个已经登陆的浏览器分配一个携带token的cookie\",{\"1\":{\"686\":1}}],[\"它不同于普通的bean\",{\"1\":{\"1327\":1}}],[\"它不仅仅可以用来进行数据传递\",{\"1\":{\"1084\":1}}],[\"它不仅仅可以是一个固定值\",{\"1\":{\"1061\":1}}],[\"它不仅仅是一个模块\",{\"1\":{\"649\":1}}],[\"它不是一种标准\",{\"1\":{\"589\":1}}],[\"它不是继承自filterinputstream的\",{\"1\":{\"287\":1}}],[\"它负责service\",{\"1\":{\"625\":1}}],[\"它表示一个数组\",{\"1\":{\"613\":1}}],[\"它直接代理了构造方法中传入的connection对象\",{\"1\":{\"1247\":1}}],[\"它直接包括了属性的名称和属性的值\",{\"1\":{\"610\":1}}],[\"它直接利用spring提供的容器来实现各种功能\",{\"1\":{\"546\":1}}],[\"它在初始化方法中做了什么\",{\"1\":{\"625\":1}}],[\"它在servlet与requestmapping之间\",{\"1\":{\"593\":1}}],[\"它在java\",{\"1\":{\"503\":1}}],[\"它就是代理\",{\"1\":{\"1215\":1}}],[\"它就是请求的方法类型\",{\"1\":{\"572\":1}}],[\"它就像一个字符串编辑器\",{\"1\":{\"402\":1}}],[\"它位于java\",{\"1\":{\"508\":1}}],[\"它很好的解决了判空问题\",{\"1\":{\"480\":1}}],[\"它还继续执行了我们的增强方法\",{\"1\":{\"1221\":1}}],[\"它还可以获取根目录下的资源文件\",{\"1\":{\"1084\":1}}],[\"它还可以用来绑定一个接口\",{\"1\":{\"826\":1}}],[\"它还支持事务的处理\",{\"1\":{\"790\":1}}],[\"它还支持表达式\",{\"1\":{\"574\":1}}],[\"它还支持使用命令\",{\"1\":{\"473\":1}}],[\"它还能把每一行内容依次转换为集合类提到的stream流\",{\"1\":{\"269\":1}}],[\"它支持直接向容器中添加bean定义\",{\"1\":{\"1310\":1}}],[\"它支持我们使用lambda的形式进行查询结果的处理\",{\"1\":{\"836\":1}}],[\"它支持我们一条一条命令进行操作\",{\"1\":{\"473\":1}}],[\"它支持定制化\",{\"1\":{\"816\":1}}],[\"它支持多行\",{\"1\":{\"744\":1}}],[\"它支持tcp和udp\",{\"1\":{\"718\":1}}],[\"它支持按行读取\",{\"1\":{\"269\":1}}],[\"它是整个加载过程的最后一步\",{\"1\":{\"1306\":1}}],[\"它是可以自动解决循环依赖问题的\",{\"1\":{\"1301\":1}}],[\"它是如何进行代理的\",{\"1\":{\"1247\":1}}],[\"它是如何实现datasource中提供的接口方法的\",{\"1\":{\"1244\":1}}],[\"它是pooleddatasource类\",{\"1\":{\"1245\":1}}],[\"它是在javax\",{\"1\":{\"1242\":1}}],[\"它是在子类frameworkservlet中定义的\",{\"1\":{\"625\":1}}],[\"它是注解配置的\",{\"1\":{\"1166\":1}}],[\"它是轻量级的ioc和aop的容器框架\",{\"1\":{\"1113\":1}}],[\"它是为了简化开发而生\",{\"1\":{\"1113\":1}}],[\"它是属于整个web应用程序的\",{\"1\":{\"1084\":1}}],[\"它是遵循http协议的一种servlet\",{\"1\":{\"1059\":1}}],[\"它是万维网上能够可靠交换文件的重要基础\",{\"1\":{\"1042\":1}}],[\"它是符合第三范式的\",{\"1\":{\"739\":1}}],[\"它是计算机之间进行通信的一种约定或一种方式\",{\"1\":{\"718\":1}}],[\"它是一个集合类型\",{\"1\":{\"1136\":1}}],[\"它是一个controller增强器\",{\"1\":{\"602\":1}}],[\"它是一个数组\",{\"1\":{\"569\":1}}],[\"它是一个非常优秀的表示层框架\",{\"1\":{\"540\":1}}],[\"它是一个用于操作数组的工具类\",{\"1\":{\"232\":1}}],[\"它是运行时异常的子类\",{\"1\":{\"424\":1}}],[\"它是局部内部类的简化版\",{\"1\":{\"412\":1}}],[\"它可以批量地为这些方法添加动作\",{\"1\":{\"1215\":1}}],[\"它可以通过运行期间执行的表达式将值装配到我们的属性或构造函数当中\",{\"1\":{\"1196\":1}}],[\"它可以很简单地加入到我们已有的项目中\",{\"1\":{\"1118\":1}}],[\"它可以长这样\",{\"1\":{\"817\":1}}],[\"它可以根据请求找到处理器handler\",{\"1\":{\"625\":1}}],[\"它可以指定你希望对集合进行的操作\",{\"1\":{\"513\":1}}],[\"它可以保存类型t的值\",{\"1\":{\"512\":1}}],[\"它可以对给定的对象执行某些操作\",{\"1\":{\"508\":1}}],[\"它可以判断一个对象是否为此接口或是类的实现或是子类\",{\"1\":{\"343\":1}}],[\"它可以提高你的多线程任务的速度\",{\"1\":{\"330\":1}}],[\"它将我们的变量值存储在内部只能存储一个变量\",{\"1\":{\"319\":1}}],[\"它会自动集成junit进行测试\",{\"1\":{\"1290\":1}}],[\"它会自动找到对应接口是否存在bean的实现类\",{\"1\":{\"1119\":1}}],[\"它会读取外部配置文件的属性值装配到属性中\",{\"1\":{\"1199\":1}}],[\"它会负责实例化\",{\"1\":{\"1119\":1}}],[\"它会先将请求转发给父类加载器\",{\"1\":{\"1109\":1}}],[\"它会给浏览器设定一个叫做jsessionid的cookie\",{\"1\":{\"1095\":1}}],[\"它会预编译一个sql语句\",{\"1\":{\"805\":1}}],[\"它会返回一个boolean来表示执行结果是一个resultset还是一个int\",{\"1\":{\"791\":1}}],[\"它会返回一个int类型\",{\"1\":{\"791\":1}}],[\"它会被自动转换为json字符串格式\",{\"1\":{\"616\":1}}],[\"它会被spring扫描并自动注册为controller类型的bean\",{\"1\":{\"561\":1}}],[\"它会将日志以xml的形式进行打印\",{\"1\":{\"921\":1}}],[\"它会将请求映射为handlerexecutionchain\",{\"1\":{\"558\":1}}],[\"它会将操作后的数据保存到另外一个对象中\",{\"1\":{\"514\":1}}],[\"它会注册\",{\"1\":{\"553\":1}}],[\"它会直接打印基本数据类型或是调用对象的tostring\",{\"1\":{\"284\":1}}],[\"它会在编译时\",{\"1\":{\"501\":1}}],[\"它会在元素插入时进行排序\",{\"1\":{\"207\":1}}],[\"它会在\",{\"1\":{\"82\":1}}],[\"它能够以父类的形式代理\",{\"1\":{\"1215\":1}}],[\"它能够很好地实现动态网页的返回\",{\"1\":{\"1053\":1}}],[\"它能够有效地预防sql注入式攻击\",{\"1\":{\"790\":1}}],[\"它能够快速地定位元素存放的位置\",{\"1\":{\"780\":1}}],[\"它能够直接让局部变量自动进行类型推断\",{\"1\":{\"487\":1}}],[\"它能够在编译阶段就检查类型安全\",{\"1\":{\"437\":1}}],[\"它能够在插入数据时利用链表自动维护顺序\",{\"1\":{\"206\":1}}],[\"它能够格式化任意的类型\",{\"1\":{\"284\":1}}],[\"它能够提供一个缓冲\",{\"1\":{\"260\":1}}],[\"它们有着各自的优点\",{\"1\":{\"1181\":1}}],[\"它们效果和init\",{\"1\":{\"1176\":1}}],[\"它们之间就像连接在一起的齿轮\",{\"1\":{\"1116\":1}}],[\"它们都会认为报名成功后人数应该变成6\",{\"1\":{\"1270\":1}}],[\"它们都是student的子类\",{\"1\":{\"1126\":1}}],[\"它们都是容器\",{\"1\":{\"179\":1}}],[\"它们都被封装在一个新的assertions类中\",{\"1\":{\"968\":1}}],[\"它们专门用于配置特殊情况\",{\"1\":{\"912\":1}}],[\"它们分别用于存放java源代码\",{\"1\":{\"1001\":1}}],[\"它们分别代表一对一关联和一对多关联\",{\"1\":{\"901\":1}}],[\"它们分别是\",{\"1\":{\"520\":1}}],[\"它们能够捆绑一组sql语句运行\",{\"1\":{\"782\":1}}],[\"它们通过\",{\"1\":{\"241\":1}}],[\"它给我们提供了大量的工具方法\",{\"1\":{\"232\":1}}],[\"它扩展了大量队列相关操作\",{\"1\":{\"200\":1}}],[\"它的实现类是annotationawareaspectjautoproxycreator\",{\"1\":{\"1310\":1}}],[\"它的结果都不应该受到影响\",{\"1\":{\"1266\":1}}],[\"它的原理实际上就是通过动态代理机制实现的\",{\"1\":{\"1215\":1}}],[\"它的默认名称生产规则依然是类名并按照首字母小写的驼峰命名法来的\",{\"1\":{\"1178\":1}}],[\"它的默认值为\",{\"1\":{\"1064\":1}}],[\"它的目的是\",{\"1\":{\"1083\":1}}],[\"它的目的是用来创建构建器\",{\"1\":{\"525\":1}}],[\"它的作用与\",{\"1\":{\"1175\":1}}],[\"它的作用肯定不仅仅是获取头部信息\",{\"1\":{\"1057\":1}}],[\"它的作用域被继续细分\",{\"1\":{\"588\":1}}],[\"它的格式如下\",{\"1\":{\"936\":1}}],[\"它的使用方式与resultmap几乎没什么区别\",{\"1\":{\"898\":1}}],[\"它的主要作用是充分并正确利用http协议的特性\",{\"1\":{\"589\":1}}],[\"它的主要特性有\",{\"1\":{\"181\":1}}],[\"它的含义是将一个复杂的对象的构建与它的表示分离\",{\"1\":{\"524\":1}}],[\"它的意义不仅仅体现在语法的精简上\",{\"1\":{\"497\":1}}],[\"它的lambda表达式的实现就可以写为\",{\"1\":{\"447\":1}}],[\"它的权限非常高\",{\"1\":{\"336\":1}}],[\"它的底层其实并不只是简简单单的语法糖替换\",{\"1\":{\"446\":1}}],[\"它的底层很简单\",{\"1\":{\"224\":1}}],[\"它的底层就是采用哈希表实现的\",{\"1\":{\"205\":1}}],[\"它的内部直接维护了一个红黑树\",{\"1\":{\"219\":1}}],[\"它的内部对插入顺序进行了维护\",{\"1\":{\"214\":1}}],[\"它的运作机制大概是\",{\"1\":{\"188\":1}}],[\"它的祖先就是collection接口\",{\"1\":{\"180\":1}}],[\"它的属性没有进行赋值\",{\"1\":{\"161\":1}}],[\"我就要学java\",{\"1\":{\"1224\":1}}],[\"我就想一行解决\",{\"1\":{\"454\":1}}],[\"我干嘛不直接写到代码里呢\",{\"1\":{\"1200\":1}}],[\"我的梦想是学java\",{\"1\":{\"1224\":1}}],[\"我的名字是\",{\"1\":{\"1199\":1,\"1200\":1}}],[\"我的性别是\",{\"1\":{\"799\":1}}],[\"我在加载阶段获得了bean名字\",{\"1\":{\"1186\":1}}],[\"我教你学golang\",{\"1\":{\"1132\":1}}],[\"我教你画画\",{\"1\":{\"1132\":1}}],[\"我爱运动\",{\"1\":{\"1126\":1}}],[\"我爱画画\",{\"1\":{\"1126\":1}}],[\"我只管调\",{\"1\":{\"1117\":1}}],[\"我被初始化了\",{\"1\":{\"1064\":1,\"1311\":1}}],[\"我被构造了\",{\"1\":{\"166\":1,\"1157\":1}}],[\"我看你<><><>是一点都不懂哦>>>\",{\"1\":{\"818\":1}}],[\"我希望将这两张表结合到一起来查看完整的数据\",{\"1\":{\"769\":1}}],[\"我现在又有强迫症\",{\"1\":{\"454\":1}}],[\"我会学习\",{\"1\":{\"376\":1,\"377\":1}}],[\"我姓🐴\",{\"1\":{\"355\":1}}],[\"我这里读取的是一个字符串或是一个个字符\",{\"1\":{\"283\":1}}],[\"我是bean工厂后置处理\",{\"1\":{\"1311\":1}}],[\"我是bean定义后置处理\",{\"1\":{\"1311\":1}}],[\"我是依赖注入\",{\"1\":{\"1308\":2}}],[\"我是构造方法\",{\"1\":{\"1308\":2}}],[\"我是之前\",{\"1\":{\"1307\":1,\"1308\":1}}],[\"我是之前执行的内容\",{\"1\":{\"1233\":1,\"1234\":1,\"1235\":1}}],[\"我是之后\",{\"1\":{\"1307\":1,\"1308\":1}}],[\"我是方法执行之后的结果\",{\"1\":{\"1231\":1}}],[\"我是她的家长\",{\"1\":{\"1224\":1}}],[\"我是异步执行的方法\",{\"1\":{\"1188\":2}}],[\"我是同步执行的方法\",{\"1\":{\"1188\":2}}],[\"我是销毁方法\",{\"1\":{\"1176\":1}}],[\"我是初始化方法\",{\"1\":{\"1176\":1,\"1308\":2}}],[\"我是二号构造方法\",{\"1\":{\"1135\":1}}],[\"我是一号构造方法\",{\"1\":{\"1135\":1}}],[\"我是一个默认的初始化参数\",{\"1\":{\"1085\":1}}],[\"我是一个阳光开朗大男孩\",{\"1\":{\"852\":1}}],[\"我是编程老师\",{\"1\":{\"1132\":1}}],[\"我是编译时异常\",{\"1\":{\"423\":1}}],[\"我是美术老师\",{\"1\":{\"1132\":1}}],[\"我是1号过滤器\",{\"1\":{\"1103\":2}}],[\"我是2号过滤器\",{\"1\":{\"1103\":3}}],[\"我是重定向之前的数据\",{\"1\":{\"1084\":1}}],[\"我是请求转发前的数据\",{\"1\":{\"1083\":1}}],[\"我是响应内容\",{\"1\":{\"1058\":1}}],[\"我是内部测试类型2\",{\"1\":{\"988\":2}}],[\"我是内部测试类型1\",{\"1\":{\"988\":2}}],[\"我是外部测试类型\",{\"1\":{\"988\":1}}],[\"我是测试异常\",{\"1\":{\"1277\":1,\"1278\":1,\"1281\":1,\"1282\":1,\"1283\":1}}],[\"我是测试\",{\"1\":{\"1035\":1}}],[\"我是测试用例2\",{\"1\":{\"987\":1}}],[\"我是测试用例1\",{\"1\":{\"987\":1}}],[\"我是测试用例3\",{\"1\":{\"987\":1}}],[\"我是测试前必须要执行的准备工作\",{\"1\":{\"985\":2}}],[\"我是测试方法1\",{\"1\":{\"985\":1}}],[\"我是测试方法\",{\"1\":{\"356\":1}}],[\"我是自定义的测试条件\",{\"1\":{\"980\":1}}],[\"我是自定义日志格式\",{\"1\":{\"944\":2}}],[\"我是只在环境变量\",{\"1\":{\"979\":1}}],[\"我是只在arm64架构下做的测试\",{\"1\":{\"979\":1}}],[\"我是只在java8\",{\"1\":{\"978\":1}}],[\"我是只在java8下执行的测试案例\",{\"1\":{\"977\":1}}],[\"我是只在java17下执行的测试案例\",{\"1\":{\"977\":1}}],[\"我是只在windows下执行的测试案例\",{\"1\":{\"976\":1}}],[\"我是只在mac下执行的测试案例\",{\"1\":{\"976\":1}}],[\"我是第三个功能\",{\"1\":{\"956\":1}}],[\"我是第二个功能\",{\"1\":{\"956\":1}}],[\"我是第一个功能\",{\"1\":{\"956\":1}}],[\"我是日志信息\",{\"1\":{\"950\":2,\"1032\":1}}],[\"我是普通的日志\",{\"1\":{\"908\":2}}],[\"我是处理\",{\"1\":{\"597\":1,\"599\":2,\"600\":1,\"601\":1,\"605\":1}}],[\"我是处理之后\",{\"1\":{\"595\":1,\"597\":1,\"600\":3,\"601\":2}}],[\"我是处理之前\",{\"1\":{\"595\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":5,\"601\":2}}],[\"我是完成之后\",{\"1\":{\"595\":1,\"597\":1,\"599\":1,\"600\":3,\"601\":2}}],[\"我是其他要做的事情\",{\"1\":{\"497\":1}}],[\"我是接口中的私有方法\",{\"1\":{\"474\":1}}],[\"我是test方法默认实现\",{\"1\":{\"474\":2}}],[\"我是已经存在的实现\",{\"1\":{\"448\":1}}],[\"我是学习方法\",{\"1\":{\"414\":2,\"1231\":2,\"1232\":1,\"1235\":1,\"1236\":1}}],[\"我是匿名内部类的实现\",{\"1\":{\"412\":1}}],[\"我是局部内部类\",{\"1\":{\"410\":1}}],[\"我是静态内部类\",{\"1\":{\"409\":1}}],[\"我是静态方法\",{\"1\":{\"274\":1,\"278\":1}}],[\"我是成员内部类\",{\"1\":{\"408\":2}}],[\"我是默认实现\",{\"1\":{\"376\":1}}],[\"我是工人\",{\"1\":{\"373\":1,\"375\":1}}],[\"我是定时任务\",{\"1\":{\"322\":2,\"1190\":1}}],[\"我是另一个线程\",{\"1\":{\"297\":2}}],[\"我是代码块\",{\"1\":{\"166\":1}}],[\"我叫🐴nb\",{\"1\":{\"355\":1}}],[\"我叫\",{\"1\":{\"162\":1,\"799\":1}}],[\"我任性\",{\"1\":{\"161\":1}}],[\"我们其实已经完全可以根据这些实现原理来手写一个spring框架了\",{\"1\":{\"1328\":1}}],[\"我们继续来研究一下finishbeanfactoryinitialization方法\",{\"1\":{\"1321\":1}}],[\"我们继续使用之前的测试项目进行教学\",{\"1\":{\"649\":1}}],[\"我们已知的仅仅是注册了配置类的bean\",{\"1\":{\"1320\":1}}],[\"我们已经清楚\",{\"1\":{\"1252\":1}}],[\"我们已经了解如何将一个类作为bean交由ioc容器管理\",{\"1\":{\"1241\":1}}],[\"我们已经认识了bin目录\",{\"1\":{\"1047\":1}}],[\"我们已经体验到mybatis为我们带来的便捷了\",{\"1\":{\"893\":1}}],[\"我们已经知道如何使用mybatis进行各种查询操作\",{\"1\":{\"841\":1}}],[\"我们已经基本能够基于spring去重新编写一个更加高级的图书管理系统了\",{\"1\":{\"626\":1}}],[\"我们回到一开始的getsingleton\",{\"1\":{\"1301\":1}}],[\"我们分段进行讲解\",{\"1\":{\"1300\":1}}],[\"我们分别编写四个请求映射\",{\"1\":{\"589\":1}}],[\"我们依然能够插手修改\",{\"1\":{\"1307\":1}}],[\"我们依然需要手动去获取mapper对象\",{\"1\":{\"1256\":1}}],[\"我们依次来看看\",{\"1\":{\"1267\":1}}],[\"我们采用池化数据源\",{\"1\":{\"1259\":1}}],[\"我们采用的是\",{\"1\":{\"87\":1}}],[\"我们相当于直接在一开始通过ioc容器配置了sqlsessionfactory\",{\"1\":{\"1259\":1}}],[\"我们看到这里用到了environment\",{\"1\":{\"1242\":1}}],[\"我们怎么才能告诉spring我们要进行切入操作呢\",{\"1\":{\"1218\":1}}],[\"我们切入之后要做什么呢\",{\"1\":{\"1218\":1}}],[\"我们有时候在使用配置文件中的值时\",{\"1\":{\"1211\":1}}],[\"我们有以下几种方法\",{\"1\":{\"101\":1}}],[\"我们创建的applicationcontext对象\",{\"1\":{\"1192\":1}}],[\"我们创建的logger默认是不带任何handler对象的\",{\"1\":{\"918\":1}}],[\"我们注意到\",{\"1\":{\"1190\":1}}],[\"我们注意到comparator要求我们实现的方法为\",{\"1\":{\"451\":1}}],[\"我们原本的类代码已经被修改了\",{\"1\":{\"1189\":1}}],[\"我们甚至连构造方法和setter都不需要去编写了\",{\"1\":{\"1173\":1}}],[\"我们甚至可以使用它来快速配置访问日志打印\",{\"1\":{\"1221\":1}}],[\"我们甚至可以直接设定一个固定值\",{\"1\":{\"574\":1}}],[\"我们甚至可以轻松地做一个爬虫\",{\"1\":{\"490\":1}}],[\"我们正常情况下需要使用工厂才可以得到student对象\",{\"1\":{\"1158\":1}}],[\"我们更希望\",{\"1\":{\"1157\":1}}],[\"我们展开bean标签\",{\"1\":{\"1134\":1}}],[\"我们必须提供一个set方法\",{\"1\":{\"1133\":1}}],[\"我们才能真正认识这个框架为我们带来的便捷之处\",{\"1\":{\"1118\":1}}],[\"我们称此数据为\",{\"1\":{\"1268\":1}}],[\"我们称其为工厂bean\",{\"1\":{\"1159\":1}}],[\"我们称其为bean\",{\"1\":{\"1117\":1}}],[\"我们称为一个项目的基本坐标\",{\"1\":{\"1003\":1}}],[\"我们称为数据库驱动\",{\"1\":{\"787\":1}}],[\"我们添加几个输出语句来判断一下\",{\"1\":{\"1103\":1}}],[\"我们修改一下默认的请求地址\",{\"1\":{\"1093\":1}}],[\"我们修改一下服务器的配置文件\",{\"1\":{\"1047\":1}}],[\"我们进行一个真正的用户登录操作\",{\"1\":{\"1070\":1}}],[\"我们进入tomcat文件夹bin目录下\",{\"1\":{\"1047\":1}}],[\"我们得到是其实是tomcat服务器帮助我们创建的一个实现类\",{\"1\":{\"1056\":1}}],[\"我们得到的观测值是\",{\"1\":{\"99\":1}}],[\"我们后面会讲到\",{\"1\":{\"1047\":1}}],[\"我们后端就可以以json字符串的形式向前端返回数据\",{\"1\":{\"610\":1}}],[\"我们打开刚刚创建的test\",{\"1\":{\"1119\":1}}],[\"我们打开\",{\"1\":{\"1047\":1}}],[\"我们打开浏览器\",{\"1\":{\"1047\":1}}],[\"我们打开idea的安装目录\",{\"1\":{\"1010\":1}}],[\"我们所有的测试用例全部编写到maven项目给我们划分的test目录下\",{\"1\":{\"1017\":1}}],[\"我们着重来讲解一下scope属性\",{\"1\":{\"1016\":1}}],[\"我们尝试使用maven来帮助我们快速导入依赖\",{\"1\":{\"1008\":1}}],[\"我们可能需要一些非常规的操作\",{\"1\":{\"1187\":1}}],[\"我们可能需要多次执行才能确定其是否存在某些问题\",{\"1\":{\"989\":1}}],[\"我们可能不希望外界使用类的构造方法完成对象创建\",{\"1\":{\"1157\":1}}],[\"我们可以导入一下依赖\",{\"1\":{\"1290\":1}}],[\"我们可以得到以下信息\",{\"1\":{\"1246\":1}}],[\"我们可以得到这样的输出结果\",{\"1\":{\"986\":1}}],[\"我们可以试着来猜想一下\",{\"1\":{\"1242\":1}}],[\"我们可以需求方法执行的一些参数\",{\"1\":{\"1223\":1}}],[\"我们可以多级调用\",{\"1\":{\"1203\":1}}],[\"我们可以多次尝试去访问此页面\",{\"1\":{\"1055\":1}}],[\"我们可以像访问属性一样去使用\",{\"1\":{\"1203\":1}}],[\"我们可以像写java一样\",{\"1\":{\"1202\":1}}],[\"我们可以像这样进行编写\",{\"1\":{\"874\":1}}],[\"我们可以更加灵活地使用spring框架\",{\"1\":{\"1201\":1}}],[\"我们可以配合\",{\"1\":{\"1174\":1}}],[\"我们可以让sportstudent这个bean直接继承artstudent这个bean配置的属性\",{\"1\":{\"1149\":1}}],[\"我们可以让他等于一个非常大的数字\",{\"1\":{\"386\":1}}],[\"我们可以调用close方法关闭容器\",{\"1\":{\"1148\":2}}],[\"我们可以随意创建和jdk同包同名的类\",{\"1\":{\"1109\":1}}],[\"我们可以随意在里面使用特殊字符\",{\"1\":{\"498\":1}}],[\"我们可以再来创建一个过滤器看看效果\",{\"1\":{\"1103\":1}}],[\"我们可以给标签添加类型\",{\"1\":{\"1135\":1}}],[\"我们可以给bean起名字\",{\"1\":{\"1128\":1}}],[\"我们可以给一个servlet添加一些初始化参数\",{\"1\":{\"1085\":1}}],[\"我们可以给依赖添加optional标签表示此依赖是可选的\",{\"1\":{\"1025\":1}}],[\"我们可以引入一个工具库\",{\"1\":{\"1074\":1}}],[\"我们可以获取请求的一些信息\",{\"1\":{\"1057\":1}}],[\"我们可以获取到类中所有声明为public的方法\",{\"1\":{\"349\":1}}],[\"我们可以从\",{\"1\":{\"1056\":1}}],[\"我们可以重新进行一次打包任务\",{\"1\":{\"1037\":1}}],[\"我们可以创建一个dependencies节点\",{\"1\":{\"1008\":1}}],[\"我们可以看到此接口提供了一个beandefinitionregistry正是用于注册bean的定义的\",{\"1\":{\"1310\":1}}],[\"我们可以看到在idea右上角maven板块中\",{\"1\":{\"1034\":1}}],[\"我们可以看到\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"我们可以看到其他的类无论是继承a还是继承b都无法通过编译\",{\"1\":{\"504\":1}}],[\"我们可以先来看一下\",{\"1\":{\"1001\":1}}],[\"我们可以自由地进行控制是否进行重定向或是请求转发\",{\"1\":{\"1101\":1}}],[\"我们可以自由设定某些操作在测试开始之前或之后执行\",{\"1\":{\"985\":1}}],[\"我们可以自定义一个异常处理控制器\",{\"1\":{\"605\":1}}],[\"我们可以来尝试一下\",{\"1\":{\"1298\":1}}],[\"我们可以来尝试自己配置一个用于控制台打印的handler处理器\",{\"1\":{\"919\":1}}],[\"我们可以来分别注册两个子类的bean\",{\"1\":{\"1126\":1}}],[\"我们可以来试验一下\",{\"1\":{\"883\":1}}],[\"我们可以来测试一下\",{\"1\":{\"201\":1}}],[\"我们可以提前保存一些测试用例\",{\"1\":{\"956\":1}}],[\"我们可以提前将一部分内容放入缓存\",{\"1\":{\"882\":1}}],[\"我们可以提前准备好合适容量的byte数组来存放\",{\"1\":{\"248\":1}}],[\"我们可以开启mybatis的日志来观察具体执行的操作\",{\"1\":{\"852\":1}}],[\"我们可以尝试自己创建和使用beanfactory对象\",{\"1\":{\"1296\":1}}],[\"我们可以尝试接着来写一个同时查询id和年龄的查询操作\",{\"1\":{\"834\":1}}],[\"我们可以尝试让服务端一直运行来不断接受客户端的连接\",{\"1\":{\"719\":1}}],[\"我们可以断点调试一下\",{\"1\":{\"789\":1}}],[\"我们可以打开idea的数据库连接配置\",{\"1\":{\"788\":1}}],[\"我们可以打开浏览器运行一次\",{\"1\":{\"600\":1}}],[\"我们可以这样来查看支持的引擎\",{\"1\":{\"782\":1}}],[\"我们可以手动指定当前项目的版本号\",{\"1\":{\"1003\":1}}],[\"我们可以手动编写一个带调试信息的无参构造\",{\"1\":{\"841\":1}}],[\"我们可以手动配一个resultmap来解决这种问题\",{\"1\":{\"835\":1}}],[\"我们可以手动为驱动管理器添加一个日志打印\",{\"1\":{\"789\":1}}],[\"我们可以手动调整其大小来优化传输效率\",{\"1\":{\"721\":1}}],[\"我们可以手动关闭单向的流\",{\"1\":{\"721\":1}}],[\"我们可以大致像下面这样进行划分\",{\"1\":{\"691\":1}}],[\"我们可以根据需求导入需要的模块\",{\"1\":{\"649\":1}}],[\"我们可以很轻松地实现文件上传和下载\",{\"1\":{\"618\":1}}],[\"我们可以很轻松的求出各个情况下的q\",{\"1\":{\"77\":1}}],[\"我们可以也直接创建一个实体类\",{\"1\":{\"615\":1}}],[\"我们可以添加一些用于条件判断的标签到xml的sql语句中\",{\"1\":{\"873\":1}}],[\"我们可以添加\",{\"1\":{\"601\":1,\"812\":1}}],[\"我们可以添加transient关键字\",{\"1\":{\"290\":1}}],[\"我们可以按照不同功能进行划分\",{\"1\":{\"589\":1}}],[\"我们可以限定请求方式\",{\"1\":{\"572\":1}}],[\"我们可以在里面编写增强方法\",{\"1\":{\"1233\":1}}],[\"我们可以在配置类上添加\",{\"1\":{\"1190\":1,\"1198\":1}}],[\"我们可以在配置文件\",{\"1\":{\"1097\":1}}],[\"我们可以在需要注册为bean的类上添加\",{\"1\":{\"1177\":1}}],[\"我们可以在最外层的beans标签中进行默认配置\",{\"1\":{\"1152\":1}}],[\"我们可以在浏览器中尝试一下\",{\"1\":{\"1061\":1}}],[\"我们可以在这里填写我们想要发送给浏览器显示的内容\",{\"1\":{\"1058\":1}}],[\"我们可以在网站上搜索junit的依赖\",{\"1\":{\"1017\":1}}],[\"我们可以在\",{\"1\":{\"1008\":1}}],[\"我们可以在主类中使用日志打印\",{\"1\":{\"908\":1}}],[\"我们可以在获取sqlsession关闭自动提交来开启事务模式\",{\"1\":{\"865\":1}}],[\"我们可以在任意方法上添加这个注解\",{\"1\":{\"697\":1}}],[\"我们可以在此方法中获取到抛出的异常\",{\"1\":{\"599\":1}}],[\"我们可以在模块b中去实现一下\",{\"1\":{\"467\":1}}],[\"我们可以在收到中断信号后\",{\"1\":{\"301\":1}}],[\"我们可以为其添加joinpoint参数来获取切入点信息\",{\"1\":{\"1234\":1}}],[\"我们可以为其他模块开放某些运行使用反射的类\",{\"1\":{\"466\":1}}],[\"我们可以为我们切入的方法添加一个joinpoint参数\",{\"1\":{\"1223\":1}}],[\"我们可以为annotationconfigapplicationcontext指定一个默认的配置类\",{\"1\":{\"1166\":1}}],[\"我们可以为bean指定初始化方法和销毁方法\",{\"1\":{\"1147\":1}}],[\"我们可以为成员变量\",{\"1\":{\"278\":1}}],[\"我们可以对cache标签进行一些配置\",{\"1\":{\"884\":1}}],[\"我们可以对类似于这种匿名内部类的写法\",{\"1\":{\"446\":1}}],[\"我们可以对一个集合进行二分搜索\",{\"1\":{\"234\":1}}],[\"我们可以选择在实现类明确泛型类型\",{\"1\":{\"439\":1}}],[\"我们可以下面的方式实现多种字符匹配\",{\"1\":{\"403\":1}}],[\"我们可以快速预览当前服务器的一些信息\",{\"1\":{\"1047\":1}}],[\"我们可以快速获取到我们标记的注解\",{\"1\":{\"365\":1}}],[\"我们可以快速生成一个只读的list\",{\"1\":{\"182\":1}}],[\"我们可以发现\",{\"1\":{\"350\":1,\"787\":1}}],[\"我们可以把这个容器想象成是一个货架\",{\"1\":{\"331\":1}}],[\"我们可以利用jstack命令来检测死锁\",{\"1\":{\"313\":1}}],[\"我们可以理解为是属于这个类的\",{\"1\":{\"274\":1}}],[\"我们可以非常高效的从\",{\"1\":{\"205\":1}}],[\"我们可以直接打开查看\",{\"1\":{\"1326\":1}}],[\"我们可以直接实现此接口\",{\"1\":{\"1307\":1}}],[\"我们可以直接实现接口表示这个bean是一个工厂bean\",{\"1\":{\"1180\":1}}],[\"我们可以直接获取此对象\",{\"1\":{\"1296\":1}}],[\"我们可以直接获取到该数据\",{\"1\":{\"1083\":1}}],[\"我们可以直接找到beanfactory接口的一个抽象实现abstractbeanfactory类\",{\"1\":{\"1300\":1}}],[\"我们可以直接找bean工厂索要对象\",{\"1\":{\"1296\":1}}],[\"我们可以直接找工厂获取bean对象\",{\"1\":{\"1296\":1}}],[\"我们可以直接把sqlsessionfactory\",{\"1\":{\"1241\":1}}],[\"我们可以直接从上下文中获取到它为我们创建的对象\",{\"1\":{\"1119\":1}}],[\"我们可以直接看到\",{\"1\":{\"1092\":1}}],[\"我们可以直接发送\",{\"1\":{\"1082\":1}}],[\"我们可以直接点击package来进行打包操作\",{\"1\":{\"1036\":1}}],[\"我们可以直接设置一系列值\",{\"1\":{\"991\":1}}],[\"我们可以直接使用\",{\"1\":{\"1291\":1}}],[\"我们可以直接使用了\",{\"1\":{\"1159\":1}}],[\"我们可以直接使用标签编辑集合的默认值\",{\"1\":{\"1136\":1}}],[\"我们可以直接使用一个静态变量log\",{\"1\":{\"950\":1}}],[\"我们可以直接使用foreach语法来快速遍历集合类\",{\"1\":{\"191\":1}}],[\"我们可以直接删除掉所有的mapper\",{\"1\":{\"893\":1}}],[\"我们可以直接让一个user对象作为参数传入\",{\"1\":{\"861\":1}}],[\"我们可以直接尝试进行登录\",{\"1\":{\"664\":1}}],[\"我们可以直接返回一个对象类型\",{\"1\":{\"616\":1}}],[\"我们可以直接返回view名称\",{\"1\":{\"563\":1}}],[\"我们可以直接在配置类上方添加注解\",{\"1\":{\"1257\":1}}],[\"我们可以直接在配置类中创建\",{\"1\":{\"1254\":1}}],[\"我们可以直接在这里使用权限判断相关的方法\",{\"1\":{\"696\":1}}],[\"我们可以直接在控制台窗口中测试\",{\"1\":{\"610\":1}}],[\"我们可以直接在方法中使用\",{\"1\":{\"579\":1}}],[\"我们可以直接在idea下方的端点板块中查看当前web应用程序定义的所有请求映射\",{\"1\":{\"570\":1}}],[\"我们可以直接在类的内部定义成员内部类\",{\"1\":{\"408\":1}}],[\"我们可以直接将其注册为bean\",{\"1\":{\"1277\":1}}],[\"我们可以直接将其作为形式参数放到方法中\",{\"1\":{\"1172\":1}}],[\"我们可以直接将其遍历查看\",{\"1\":{\"1069\":1}}],[\"我们可以直接将其设置回去\",{\"1\":{\"806\":1}}],[\"我们可以直接将index的下一级路径作为请求参数进行处理\",{\"1\":{\"589\":1}}],[\"我们可以直接将student替换为模式变量\",{\"1\":{\"499\":1}}],[\"我们可以直接将现有的变量丢进去\",{\"1\":{\"480\":1}}],[\"我们可以直接将此方法\",{\"1\":{\"448\":1}}],[\"我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值\",{\"1\":{\"384\":1}}],[\"我们可以直接将一个\",{\"1\":{\"200\":1}}],[\"我们可以直接创建静态内部类的对象\",{\"1\":{\"409\":1}}],[\"我们可以直接通过servlet的getinitparameter方法获取\",{\"1\":{\"1085\":1}}],[\"我们可以直接通过\",{\"1\":{\"1047\":1}}],[\"我们可以直接通过of方法来快速创建了\",{\"1\":{\"475\":1}}],[\"我们可以直接通过接口名\",{\"1\":{\"376\":1}}],[\"我们可以直接通过method对象来获取这些信息\",{\"1\":{\"349\":1}}],[\"我们可以直接传入一个值\",{\"1\":{\"364\":1}}],[\"我们可以使用sqlsessionfactorybean类\",{\"1\":{\"1259\":1}}],[\"我们可以使用spel快速取出集合中的元素\",{\"1\":{\"1207\":1}}],[\"我们可以使用aop来帮助我们在方法执行前或执行之后\",{\"1\":{\"1215\":1}}],[\"我们可以使用append方法来讲字符串拼接到后面\",{\"1\":{\"402\":1}}],[\"我们可以使用一些其他的注解来配置其他属性\",{\"1\":{\"1171\":1}}],[\"我们可以使用一个map\",{\"1\":{\"834\":1}}],[\"我们可以使用一个特殊的名字表示泛型\",{\"1\":{\"438\":1}}],[\"我们可以使用即将要介绍的servletcontext对象\",{\"1\":{\"1083\":1}}],[\"我们可以使用第四种作用域\",{\"1\":{\"1018\":1}}],[\"我们可以使用此框架来实现日志的规范化打印\",{\"1\":{\"908\":1}}],[\"我们可以使用此方法处理多个请求路径\",{\"1\":{\"569\":1}}],[\"我们可以使用动态sql来一次性生成一个批量操作的sql语句\",{\"1\":{\"872\":1}}],[\"我们可以使用revoke来收回一个权限\",{\"1\":{\"774\":1}}],[\"我们可以使用property标签来实现\",{\"1\":{\"1133\":1}}],[\"我们可以使用preparedstatement来解决\",{\"1\":{\"805\":1}}],[\"我们可以使用params属性来指定请求必须携带哪些请求参数\",{\"1\":{\"574\":1}}],[\"我们可以使用pow方法直接计算a的b次方\",{\"1\":{\"431\":1}}],[\"我们可以使用花括号来将整套逻辑括起来\",{\"1\":{\"497\":1}}],[\"我们可以使用自动类型推断\",{\"1\":{\"485\":1}}],[\"我们可以使用断言表达式来对某些东西进行判断\",{\"1\":{\"425\":1}}],[\"我们可以使用它来对字符串进行拼接\",{\"1\":{\"402\":1}}],[\"我们可以使用getconstructor\",{\"1\":{\"348\":1}}],[\"我们可以使用threadlocal类\",{\"1\":{\"319\":1}}],[\"我们可以使用join\",{\"1\":{\"305\":1}}],[\"我们可以使用\",{\"1\":{\"166\":1,\"206\":1,\"214\":1,\"277\":1,\"897\":1,\"898\":1,\"974\":1,\"1209\":1}}],[\"我们可以进行一次重载\",{\"1\":{\"165\":1}}],[\"我们可以认为\",{\"1\":{\"150\":1}}],[\"我们可以写出\",{\"1\":{\"113\":1}}],[\"我们可以将spel配合\",{\"1\":{\"1211\":1}}],[\"我们可以将对象交给ioc容器进行管理\",{\"1\":{\"1117\":1,\"1119\":1}}],[\"我们可以将用户名和密码全部保存在cookie中\",{\"1\":{\"1093\":1}}],[\"我们可以将其注册为bean\",{\"1\":{\"1254\":1}}],[\"我们可以将其修改为大于等于0的数\",{\"1\":{\"1064\":1}}],[\"我们可以将其名字设定为value\",{\"1\":{\"364\":1}}],[\"我们可以将之前编写的页面放入到webapp目录下\",{\"1\":{\"1054\":1}}],[\"我们可以将我们自己的项目也放到webapp文件夹中\",{\"1\":{\"1047\":1}}],[\"我们可以将dependencies全部放入dependencymanagement节点\",{\"1\":{\"1033\":1}}],[\"我们可以将一些外部配置文件中的配置进行读取\",{\"1\":{\"1197\":1}}],[\"我们可以将一些静态资源\",{\"1\":{\"1017\":1}}],[\"我们可以将一个类定义为一个泛型类\",{\"1\":{\"438\":1}}],[\"我们可以将查询的结果作为另一个查询的条件\",{\"1\":{\"770\":1}}],[\"我们可以将此数据库删除\",{\"1\":{\"749\":1}}],[\"我们可以将书籍信息进行单独拆分为另一张表\",{\"1\":{\"738\":1}}],[\"我们可以将任何的变量包装进optional类中使用\",{\"1\":{\"454\":1}}],[\"我们可以将方法标记为静态\",{\"1\":{\"274\":1}}],[\"我们可以将这个只读的列表作为参数传入\",{\"1\":{\"182\":1}}],[\"我们可以将这个问题可以转化为一个随机变量的方法\",{\"1\":{\"105\":1}}],[\"我们可以将各种需要初始化的操作都在这里进行处理\",{\"1\":{\"166\":1}}],[\"我们可以将该问题定义为一个\",{\"1\":{\"110\":1}}],[\"我们可以将\",{\"1\":{\"101\":1,\"103\":1,\"104\":1}}],[\"我们可以修改为噪音\",{\"1\":{\"99\":1}}],[\"我们可以设计如下方程\",{\"1\":{\"99\":1}}],[\"我们可以确保其可以遍历所有的\",{\"1\":{\"86\":1}}],[\"我们可以生成一个统计实例来帮助我们快速进行统计\",{\"1\":{\"228\":1}}],[\"我们可以生成一个\",{\"1\":{\"78\":1}}],[\"我们可以通过factory\",{\"1\":{\"1158\":1}}],[\"我们可以通过配置文件告诉容器需要管理哪些bean以及bean的属性\",{\"1\":{\"1119\":1}}],[\"我们可以通过配置来进行调整\",{\"1\":{\"911\":1}}],[\"我们可以通过实现\",{\"1\":{\"1053\":1}}],[\"我们可以通过断言工具类assertions来对结果进行判定\",{\"1\":{\"963\":1}}],[\"我们可以通过logger的getparent方法来获取其父logger对象\",{\"1\":{\"927\":1}}],[\"我们可以通过limit来限制查询的数量\",{\"1\":{\"766\":1}}],[\"我们可以通过gethandlers方法来获取logger对象中已经配置的handler对象\",{\"1\":{\"918\":1}}],[\"我们可以通过二级缓存来实现\",{\"1\":{\"884\":1}}],[\"我们可以通过sqlsessionfactory来创建多个新的会话\",{\"1\":{\"825\":1}}],[\"我们可以通过securitycontextholder对象获取当前登陆的用户\",{\"1\":{\"712\":1}}],[\"我们可以通过添加\",{\"1\":{\"812\":2}}],[\"我们可以通过下面的命令创建索引\",{\"1\":{\"780\":1}}],[\"我们可以通过使用getresultset\",{\"1\":{\"791\":1}}],[\"我们可以通过使用grant来为一个数据库用户进行授权\",{\"1\":{\"774\":1}}],[\"我们可以通过使用delete来删除表中的数据\",{\"1\":{\"756\":1}}],[\"我们可以通过\",{\"1\":{\"772\":1}}],[\"我们可以通过order\",{\"1\":{\"764\":1}}],[\"我们可以通过update语句来更新表中的数据\",{\"1\":{\"755\":1}}],[\"我们可以通过drop\",{\"1\":{\"752\":1}}],[\"我们可以通过add来添加一个新的列\",{\"1\":{\"751\":1}}],[\"我们可以通过alter\",{\"1\":{\"751\":1}}],[\"我们可以通过create\",{\"1\":{\"749\":1,\"772\":1,\"779\":1}}],[\"我们可以通过java来实现socket通信\",{\"1\":{\"718\":1}}],[\"我们可以通过继承\",{\"1\":{\"503\":1}}],[\"我们可以通过迭代快速生成一组数据\",{\"1\":{\"478\":1}}],[\"我们可以通过一个注解直接读取到外部配置文件中对应的属性值\",{\"1\":{\"1198\":1}}],[\"我们可以通过一个注解快速生成构造方法\",{\"1\":{\"949\":1}}],[\"我们可以通过一个关键字解决\",{\"1\":{\"465\":1}}],[\"我们可以通过一些特定的算法进行求解\",{\"1\":{\"96\":1}}],[\"我们可以通过类名直接使用\",{\"1\":{\"429\":1}}],[\"我们可以通过method对象的invoke\",{\"1\":{\"349\":1}}],[\"我们可以通过反射来无视权限修饰符\",{\"1\":{\"349\":1}}],[\"我们可以通过反射来调用类的方法\",{\"1\":{\"349\":1}}],[\"我们可以通过反射机制\",{\"1\":{\"336\":1}}],[\"我们可以通过调用getclass\",{\"1\":{\"842\":1}}],[\"我们可以通过调用getconnection\",{\"1\":{\"789\":1}}],[\"我们可以通过调用setsotimeout\",{\"1\":{\"721\":1}}],[\"我们可以通过调用foreachordered\",{\"1\":{\"330\":1}}],[\"我们可以通过调用cancel\",{\"1\":{\"324\":1}}],[\"我们可以通过此对象来创建任意类型的定时任务\",{\"1\":{\"323\":1}}],[\"我们可以通过创建一个timer类来让它进行定时任务调度\",{\"1\":{\"323\":1}}],[\"我们可以通过包的形式将这些类进行分类存放\",{\"1\":{\"277\":1}}],[\"我们可以通过它来获取文件的输入流\",{\"1\":{\"247\":1}}],[\"我们可以通过对象的引用来间接操作对象\",{\"1\":{\"161\":1}}],[\"我们可以通过对应的迭代算法来求解贝尔曼最优公式\",{\"1\":{\"62\":1}}],[\"我们可以通过前面所引入的\",{\"1\":{\"77\":1}}],[\"我们可以分析出在该状态下采取哪个\",{\"1\":{\"48\":1}}],[\"我们肯定希望测试的结果是我们所期望的一个值\",{\"1\":{\"963\":1}}],[\"我们刚刚在filehandler中见到的是默认生成的xmlformatter\",{\"1\":{\"921\":1}}],[\"我们去掉类上的\",{\"1\":{\"883\":1}}],[\"我们基本上可以解决大部分的sql查询和批量处理场景了\",{\"1\":{\"877\":1}}],[\"我们都可以从httpsession中读取到存储在会话中的数据\",{\"1\":{\"1096\":1}}],[\"我们都需要flushstatements\",{\"1\":{\"871\":1}}],[\"我们都要编写将近十个servlet\",{\"1\":{\"540\":1}}],[\"我们每一次执行sql语句\",{\"1\":{\"871\":1}}],[\"我们每次上菜的时候只从厨房端一个菜\",{\"1\":{\"871\":1}}],[\"我们每次都需要去找映射器对应操作的名称\",{\"1\":{\"842\":1}}],[\"我们接着来研究一下\",{\"1\":{\"1279\":1}}],[\"我们接着来介绍安全导航运算符\",{\"1\":{\"1211\":1}}],[\"我们接着来了解一下测试类的生命周期\",{\"1\":{\"986\":1}}],[\"我们接着来尝试将日志记录到我们本地的文件中\",{\"1\":{\"920\":1}}],[\"我们接着来测试一下回滚操作\",{\"1\":{\"865\":1}}],[\"我们接着来看第三步\",{\"1\":{\"1320\":1}}],[\"我们接着来看mandatory\",{\"1\":{\"1283\":1}}],[\"我们接着来看mybatis\",{\"1\":{\"951\":1}}],[\"我们接着来看读已提交级别\",{\"1\":{\"1269\":1}}],[\"我们接着来看自定义度更高的环绕方法\",{\"1\":{\"1224\":1}}],[\"我们接着来看loadonstartup属性\",{\"1\":{\"1064\":1}}],[\"我们接着来看webservlet注解\",{\"1\":{\"1060\":1}}],[\"我们接着来看package命令\",{\"1\":{\"1036\":1}}],[\"我们接着来看修改操作\",{\"1\":{\"863\":1}}],[\"我们接着来看修改相关操作\",{\"1\":{\"860\":1}}],[\"我们接着来看一对多查询\",{\"1\":{\"853\":1}}],[\"我们接着来看更方便的用法\",{\"1\":{\"843\":1}}],[\"我们接着来看看它在bean信息后置处理中做了什么\",{\"1\":{\"1327\":1}}],[\"我们接着来看看\",{\"1\":{\"706\":1}}],[\"我们接着来看dispatcherservlet中实现的onrefresh\",{\"1\":{\"625\":1}}],[\"我们接着来看initservletbean\",{\"1\":{\"625\":1}}],[\"我们接着来看如果存在多个拦截器会如何执行\",{\"1\":{\"600\":1}}],[\"我们接着来看\",{\"1\":{\"578\":1,\"1244\":1,\"1258\":1,\"1310\":1,\"1327\":1}}],[\"我们接着来看下一个method属性\",{\"1\":{\"572\":1}}],[\"我们使用的applicationcontext实际上内部就有一个beanfactory在进行bean管理\",{\"1\":{\"1297\":1}}],[\"我们使用的始终是jdk中提供的接口\",{\"1\":{\"1016\":1}}],[\"我们使用容器的目标之一是消除类之间的强关联\",{\"1\":{\"1132\":1}}],[\"我们使用别名也是可以拿到对应的bean的\",{\"1\":{\"1128\":1}}],[\"我们使用setuseparenthandlers方法来屏蔽所有父级提供的日志处理器\",{\"1\":{\"918\":1}}],[\"我们使用其他软件手动修改数据库中的数据\",{\"1\":{\"888\":1}}],[\"我们使用一个map作为参数\",{\"1\":{\"843\":1}}],[\"我们使用instanceof进行类型比较\",{\"1\":{\"343\":1}}],[\"我们放在最后一节进行讲解\",{\"1\":{\"842\":1}}],[\"我们主要还是以selectone和selectlist为主\",{\"1\":{\"836\":1}}],[\"我们输入的参数一旦出现\",{\"1\":{\"805\":1}}],[\"我们输入以下命令来看看能否访问所有数据库\",{\"1\":{\"773\":1}}],[\"我们该怎么去写\",{\"1\":{\"804\":1}}],[\"我们仍可在old表中拿到被删除的数据\",{\"1\":{\"781\":1}}],[\"我们仍需要估计\",{\"1\":{\"79\":1}}],[\"我们平时所说的crud其实就是增删改查\",{\"1\":{\"744\":1}}],[\"我们平时使用的println方法就是printstream中的方法\",{\"1\":{\"284\":1}}],[\"我们要知道\",{\"1\":{\"1247\":1}}],[\"我们要做的流程都是一样的\",{\"1\":{\"1237\":1}}],[\"我们要明确这是在方法执行之前切入还是执行之后切入\",{\"1\":{\"1218\":1}}],[\"我们要切入的是这个study方法\",{\"1\":{\"1218\":1}}],[\"我们要限制某个测试案例只在指定操作系统下进行\",{\"1\":{\"976\":1}}],[\"我们要学习的就是以下四种类型的sql语言\",{\"1\":{\"744\":1}}],[\"我们要学习一下每一个表该如何去设计\",{\"1\":{\"735\":1}}],[\"我们要创建一个数组\",{\"1\":{\"392\":1}}],[\"我们差不多已经了解了整个springsecurity的实现机制了\",{\"1\":{\"710\":1}}],[\"我们倒回去看\",{\"1\":{\"706\":1}}],[\"我们重启服务器登录看看\",{\"1\":{\"692\":1}}],[\"我们网站的登录系统就更加完善了\",{\"1\":{\"687\":1}}],[\"我们网站的登录验证模块相当于直接被接管了\",{\"1\":{\"658\":1}}],[\"我们关闭浏览器后下次再次访问网站时\",{\"1\":{\"686\":1}}],[\"我们首先来回顾一下tcp的通信原理\",{\"1\":{\"1042\":1}}],[\"我们首先来看看一对一查询\",{\"1\":{\"901\":1}}],[\"我们首先来看一下一级缓存\",{\"1\":{\"883\":1}}],[\"我们首先继续完善配置类\",{\"1\":{\"683\":1}}],[\"我们首先需要导入以下依赖\",{\"1\":{\"611\":1}}],[\"我们首先需要编写对应请求路径的controller\",{\"1\":{\"558\":1}}],[\"我们首先需要创建对象\",{\"1\":{\"408\":1}}],[\"我们存储的密码就是更加安全的密码了\",{\"1\":{\"659\":1}}],[\"我们再完善一下bean加载流程\",{\"1\":{\"1311\":1}}],[\"我们再来编写业务层的实现\",{\"1\":{\"1277\":1}}],[\"我们再来了解一下http的报文结构\",{\"1\":{\"1042\":1}}],[\"我们再来看mybatis的\",{\"1\":{\"1326\":1}}],[\"我们再来看看之前在resultmap中配置的关联查询该如何编写\",{\"1\":{\"901\":1}}],[\"我们再来看一个例子\",{\"1\":{\"877\":1}}],[\"我们再来尝试编写一下查询一个列表\",{\"1\":{\"836\":1}}],[\"我们再来使用这个对象的泛型成员\",{\"1\":{\"172\":1}}],[\"我们再次运行项目\",{\"1\":{\"652\":1}}],[\"我们之后拿到的都是这个对象\",{\"1\":{\"1129\":1}}],[\"我们之后再探讨\",{\"1\":{\"650\":1}}],[\"我们之前一直都在使用工具类管理和创建会话\",{\"1\":{\"1253\":1}}],[\"我们之前一个结点只有键\",{\"1\":{\"215\":1}}],[\"我们之前都是在将我们的增强处理添加到目标对象\",{\"1\":{\"1226\":1}}],[\"我们之前都是直接创建的类\",{\"1\":{\"277\":1}}],[\"我们之前在xml中定义的就是切面\",{\"1\":{\"1226\":1}}],[\"我们之前在学习mybatis的时候学习了xml\",{\"1\":{\"936\":1}}],[\"我们之前在计算机组成原理中可能学习过缓存一致性问题\",{\"1\":{\"888\":1}}],[\"我们之前在javaweb阶段\",{\"1\":{\"685\":1}}],[\"我们之前的例子就失效了\",{\"1\":{\"805\":1}}],[\"我们之前使用了executequery\",{\"1\":{\"791\":1}}],[\"我们之前使用的都是通过构造方法直接连接服务端\",{\"1\":{\"721\":1}}],[\"我们之前学习的类就是对现实世界数据的一种抽象\",{\"1\":{\"733\":1}}],[\"我们之前也已经测试过了\",{\"1\":{\"711\":1}}],[\"我们之前编写的图书管理系统就存在这样的安全漏洞\",{\"1\":{\"641\":1}}],[\"我们时常会在qq上收到别人发送的钓鱼网站链接\",{\"1\":{\"641\":1}}],[\"我们以同样的方式创建二号拦截器\",{\"1\":{\"600\":1}}],[\"我们调用bean中的方法会被转发到真正的bean对象去执行\",{\"1\":{\"588\":1}}],[\"我们现在在主方法中连续获取两次bean对象\",{\"1\":{\"1129\":1}}],[\"我们现在循环地每三秒读取一次\",{\"1\":{\"888\":1}}],[\"我们现在同样需要使用resultmap来自定义映射规则\",{\"1\":{\"849\":1}}],[\"我们现在无论提交什么请求都需要csrf校验\",{\"1\":{\"684\":1}}],[\"我们现在推崇的是前后端分离的开发模式\",{\"1\":{\"609\":1}}],[\"我们现在再去端点中用post方式去访问\",{\"1\":{\"572\":1}}],[\"我们现在只拿到了一个inputstream\",{\"1\":{\"283\":1}}],[\"我们编写的请求映射方法在这个位置才真正地执行了\",{\"1\":{\"626\":1}}],[\"我们编写一下前端内容\",{\"1\":{\"564\":1}}],[\"我们编写了大量的servlet\",{\"1\":{\"540\":1}}],[\"我们删除项目自带的servlet类\",{\"1\":{\"549\":1}}],[\"我们同时处理两种情况\",{\"1\":{\"480\":1}}],[\"我们同样只需要将新的实现类交给ioc容器管理\",{\"1\":{\"1117\":1}}],[\"我们同样需要使用\",{\"1\":{\"902\":1}}],[\"我们同样需要使用对象来进行方法引用\",{\"1\":{\"415\":1}}],[\"我们同样可以进行简单的条件查询\",{\"1\":{\"836\":1}}],[\"我们同样可以使用\",{\"1\":{\"214\":1}}],[\"我们对于集合的一些操作就大大地简化了\",{\"1\":{\"476\":1}}],[\"我们对无人机的发射功率有一个约束\",{\"1\":{\"9\":1}}],[\"我们一次输入一行\",{\"1\":{\"473\":1}}],[\"我们一般使用http协议\",{\"1\":{\"1042\":1}}],[\"我们一般只会在测试阶段使用junit\",{\"1\":{\"1016\":1}}],[\"我们一般只会在类的内部自己使用\",{\"1\":{\"408\":1}}],[\"我们一般都使用\",{\"1\":{\"831\":1}}],[\"我们一般通过create\",{\"1\":{\"750\":1}}],[\"我们一般称为限定符\",{\"1\":{\"403\":1}}],[\"我们少考虑了一个问题\",{\"1\":{\"454\":1}}],[\"我们为所需要的接口提供了一个方法作为它的实现\",{\"1\":{\"448\":1}}],[\"我们希望让spring直接帮助我们管理所有的mapper\",{\"1\":{\"1257\":1}}],[\"我们希望在增强的方法中也能拿到这个参数\",{\"1\":{\"1223\":1}}],[\"我们希望这个bean的属性跟刚刚创建的bean属性是一样的\",{\"1\":{\"1149\":1}}],[\"我们希望这个案例抛出指定的异常\",{\"1\":{\"973\":1}}],[\"我们希望能够分不同情况处理不同类型的异常\",{\"1\":{\"424\":1}}],[\"我们希望cpu花费更多的时间去处理更重要的任务\",{\"1\":{\"302\":1}}],[\"我们抛出异常实际上就是将这个异常对象抛出\",{\"1\":{\"423\":1}}],[\"我们自己创建的一个java项目\",{\"1\":{\"463\":1}}],[\"我们自己写的java模块项目\",{\"1\":{\"463\":1}}],[\"我们自己写的都行\",{\"1\":{\"193\":1}}],[\"我们自定义异常也是从这两类中进行选择\",{\"1\":{\"422\":1}}],[\"我们知道日志的默认打印级别为info\",{\"1\":{\"912\":1}}],[\"我们知道\",{\"1\":{\"400\":1,\"841\":1,\"951\":1,\"1083\":1,\"1299\":1}}],[\"我们如果需要创建一个jdbc的连接\",{\"1\":{\"1242\":1}}],[\"我们如果需要控制单个方法的缓存\",{\"1\":{\"903\":1}}],[\"我们如果直接让\",{\"1\":{\"384\":1}}],[\"我们如果想一次性全部读取的话\",{\"1\":{\"248\":1}}],[\"我们如果想要在方法中访问到当前对象的属性\",{\"1\":{\"164\":1}}],[\"我们直接将其添加到dependencies节点中即可\",{\"1\":{\"1008\":1}}],[\"我们直接使用xmlbeandefinitionreader就可以快速进行扫描\",{\"1\":{\"1296\":1}}],[\"我们直接使用即可\",{\"1\":{\"788\":1}}],[\"我们直接使用成员变量即可\",{\"1\":{\"162\":1}}],[\"我们直接选择前者进行实现\",{\"1\":{\"668\":1}}],[\"我们直接创建一个新的jakartaee项目\",{\"1\":{\"542\":1}}],[\"我们直接调用父类的实现就可以了\",{\"1\":{\"377\":1}}],[\"我们无法完全通过注解来实现之前的联合查询解析\",{\"1\":{\"901\":1}}],[\"我们无法在代码中直接使用此类型\",{\"1\":{\"356\":1}}],[\"我们无论通过什么方式访问\",{\"1\":{\"337\":1}}],[\"我们把它放到根目录下\",{\"1\":{\"356\":1}}],[\"我们来探究一下\",{\"1\":{\"1301\":1}}],[\"我们来编写一个测试用例尝试一下\",{\"1\":{\"1032\":1}}],[\"我们来编写一下spring的配置文件\",{\"1\":{\"549\":1}}],[\"我们来尝试编写一下\",{\"1\":{\"948\":1}}],[\"我们来尝试编写一个插入操作\",{\"1\":{\"861\":1}}],[\"我们来尝试以全注解的形式重现编写咱们的sql语句映射\",{\"1\":{\"893\":1}}],[\"我们来尝试一下直接读取实体类\",{\"1\":{\"826\":1}}],[\"我们来尝试模拟一下这种操作\",{\"1\":{\"641\":1}}],[\"我们来接着尝试一下使用回滚操作\",{\"1\":{\"806\":1}}],[\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的sql语句\",{\"1\":{\"770\":1}}],[\"我们来看一下http的传输过程\",{\"1\":{\"1042\":1}}],[\"我们来看一下虚拟过滤链的dofilter是怎么处理的\",{\"1\":{\"710\":1}}],[\"我们来看看mapperscannerregistrar是个什么东西\",{\"1\":{\"1326\":1}}],[\"我们来看看maven项目的依赖管理流程\",{\"1\":{\"1009\":1}}],[\"我们来看看源码\",{\"1\":{\"1244\":1}}],[\"我们来看看如何使用advice接口实现aop\",{\"1\":{\"1231\":1}}],[\"我们来看看如何从resultset中去获取数据\",{\"1\":{\"797\":1}}],[\"我们来看看结果\",{\"1\":{\"1189\":1}}],[\"我们来看看使用注解能有多方便\",{\"1\":{\"1166\":1}}],[\"我们来看看各个加载器的不同之处\",{\"1\":{\"1109\":1}}],[\"我们来看看这个例子\",{\"1\":{\"888\":1}}],[\"我们来看看这里面是怎么定义的\",{\"1\":{\"215\":1}}],[\"我们来看看下面这段代码\",{\"1\":{\"883\":1}}],[\"我们来看看实际执行的sql语句是什么\",{\"1\":{\"805\":1}}],[\"我们来看看它是如何定义就知道了\",{\"1\":{\"1310\":1}}],[\"我们来看看它是怎么进行过滤的\",{\"1\":{\"711\":1}}],[\"我们来看看它配置了什么\",{\"1\":{\"705\":1}}],[\"我们来看看它的详细规则\",{\"1\":{\"497\":1}}],[\"我们来看看processrequest做了什么\",{\"1\":{\"626\":1}}],[\"我们来看看initwebapplicationcontext是如何进行初始化的\",{\"1\":{\"625\":1}}],[\"我们来看看是不是类型也能正常获取\",{\"1\":{\"485\":1}}],[\"我们来看看以下这段代码会得到什么结果\",{\"1\":{\"313\":1}}],[\"我们来看看resize\",{\"1\":{\"217\":1}}],[\"我们来试试看向我们刚刚创建的表中添加三条数据\",{\"1\":{\"754\":1}}],[\"我们来试试看修改成员字段之后\",{\"1\":{\"356\":1}}],[\"我们来试试看修改一些其他的类型\",{\"1\":{\"350\":1}}],[\"我们来试试看创建一个此类的对象并调用其方法\",{\"1\":{\"356\":1}}],[\"我们也能实现依赖注入\",{\"1\":{\"1134\":1}}],[\"我们也体会到lombok给我们带来的便捷\",{\"1\":{\"949\":1}}],[\"我们也没有导入student类\",{\"1\":{\"349\":1}}],[\"我们也可以尝试编写一个自己的importbeandefinitionregistrar实现\",{\"1\":{\"1311\":1}}],[\"我们也可以调用表达式的setvalue方法来设定属性的值\",{\"1\":{\"1204\":1}}],[\"我们也可以选择使用\",{\"1\":{\"1200\":1}}],[\"我们也可以自己编写一个实现\",{\"1\":{\"1328\":1}}],[\"我们也可以自己编写事件\",{\"1\":{\"1192\":1}}],[\"我们也可以自定义我们想要的日志打印格式\",{\"1\":{\"944\":1}}],[\"我们也可以自定义排序规则\",{\"1\":{\"207\":1}}],[\"我们也可以自定义比较规则\",{\"1\":{\"203\":1}}],[\"我们也可以设定primary属性\",{\"1\":{\"1141\":1}}],[\"我们也可以开启自动装配\",{\"1\":{\"1137\":1}}],[\"我们也可以开启懒加载\",{\"1\":{\"1130\":1}}],[\"我们也可以实现前面ioc提到的例子\",{\"1\":{\"1119\":1}}],[\"我们也可以在需要注入的方法中使用\",{\"1\":{\"1200\":1}}],[\"我们也可以在代码中使用invalidate方法来使session立即失效\",{\"1\":{\"1097\":1}}],[\"我们也可以在web\",{\"1\":{\"1054\":1}}],[\"我们也可以在类中添加代码块\",{\"1\":{\"166\":1}}],[\"我们也可以访问example项目\",{\"1\":{\"1047\":1}}],[\"我们也可以传入空值或是一些为空的字符串\",{\"1\":{\"992\":1}}],[\"我们也可以利用这些属性来编写一个类似于的simpleformatter的日志格式\",{\"1\":{\"948\":1}}],[\"我们也可以利用反射机制来将查询结果映射为对象\",{\"1\":{\"799\":1}}],[\"我们也可以通过这种方式来获取我们的一些系统属性\",{\"1\":{\"938\":1}}],[\"我们也可以通过log方法来主动设定该条日志的输出级别\",{\"1\":{\"911\":1}}],[\"我们也可以通过下面的命令删除一个索引\",{\"1\":{\"780\":1}}],[\"我们也可以单独配置其不使用二级缓存\",{\"1\":{\"886\":1}}],[\"我们也可以去创建一个回滚点来实现定点回滚\",{\"1\":{\"806\":1}}],[\"我们也可以去修改为其他的引擎\",{\"1\":{\"782\":1}}],[\"我们也可以进行关联查询来让mybatis自动解析结果并封装为对象\",{\"1\":{\"853\":1}}],[\"我们也可以进行分页\",{\"1\":{\"766\":1}}],[\"我们也可以进行近似\",{\"1\":{\"156\":1}}],[\"我们也可以可以同时添加多个排序\",{\"1\":{\"764\":1}}],[\"我们也可以添加where字句来限定查询目标\",{\"1\":{\"762\":1}}],[\"我们也可以添加httpservletresponse作为形式参数\",{\"1\":{\"582\":1}}],[\"我们也可以一次性向数据库中插入多条数据\",{\"1\":{\"754\":1}}],[\"我们也可以从内部击溃网站\",{\"1\":{\"643\":1}}],[\"我们也可以快速创建集合\",{\"1\":{\"1208\":1}}],[\"我们也可以快速创建一个方法供后续的调用\",{\"1\":{\"473\":1}}],[\"我们也可以快速获取请求携带的cookie信息\",{\"1\":{\"585\":1}}],[\"我们也可以将某个工厂类直接注册为工厂bean\",{\"1\":{\"1159\":1}}],[\"我们也可以将其作用域进行修改\",{\"1\":{\"1129\":1}}],[\"我们也可以将js对象转换为json字符串的形式进行传输\",{\"1\":{\"617\":1}}],[\"我们也可以将js对象转换为json字符串\",{\"1\":{\"610\":1}}],[\"我们也可以将require属性设定为false来将属性设定为非必须\",{\"1\":{\"580\":1}}],[\"我们也可以将一个可修改的集合变成只读的集合\",{\"1\":{\"236\":1}}],[\"我们也可以像之前一样使用thymeleaf作为视图解析器\",{\"1\":{\"558\":1}}],[\"我们也可以直接到bean对应的类中使用自动装配\",{\"1\":{\"1173\":1}}],[\"我们也可以直接读取环境变量\",{\"1\":{\"979\":1}}],[\"我们也可以直接对某个boolean类型的结果快速进行判断\",{\"1\":{\"970\":1}}],[\"我们也可以直接在配置中关闭csrf校验\",{\"1\":{\"684\":1}}],[\"我们也可以直接将其绑定到一个接口上\",{\"1\":{\"861\":1}}],[\"我们也可以直接将这两个参数定义到形参列表中\",{\"1\":{\"843\":1}}],[\"我们也可以直接将\",{\"1\":{\"569\":1}}],[\"我们也可以直接指定将包暴露给指定的模块\",{\"1\":{\"464\":1}}],[\"我们也可以直接使用java\",{\"1\":{\"463\":1}}],[\"我们也可以写一个\",{\"1\":{\"447\":1}}],[\"我们也可以定义全局初始化参数\",{\"1\":{\"1086\":1}}],[\"我们也可以定义多个\",{\"1\":{\"438\":1}}],[\"我们也可以定义泛型方法\",{\"1\":{\"171\":1}}],[\"我们也可以手动跳过\",{\"1\":{\"1036\":1}}],[\"我们也可以手动修改测试类的初始化行为\",{\"1\":{\"986\":1}}],[\"我们也可以手动指定名称\",{\"1\":{\"950\":1}}],[\"我们也可以手动指定版本\",{\"1\":{\"289\":1}}],[\"我们也可以手动添加一个\",{\"1\":{\"843\":1}}],[\"我们也可以手动声明\",{\"1\":{\"166\":1}}],[\"我们也可以使用methodinterceptor\",{\"1\":{\"1231\":1}}],[\"我们也可以使用运算符进行各种高级运算\",{\"1\":{\"1204\":1}}],[\"我们也可以使用entry来注入\",{\"1\":{\"1136\":1}}],[\"我们也可以使用常见的压缩工具打开jar包查看其内部文件\",{\"1\":{\"1036\":1}}],[\"我们也可以使用特定的方法来生成我们需要的测试参数\",{\"1\":{\"994\":1}}],[\"我们也可以使用枚举值来进行测试\",{\"1\":{\"993\":1}}],[\"我们也可以使用java8的lambda来编写结果判断逻辑\",{\"1\":{\"972\":1}}],[\"我们也可以使用\",{\"1\":{\"960\":1}}],[\"我们也可以使用where来添加条件\",{\"1\":{\"756\":1}}],[\"我们也可以使用衍生注解直接设定为指定类型的请求映射\",{\"1\":{\"573\":1}}],[\"我们也可以使用or\",{\"1\":{\"480\":1}}],[\"我们也可以使用default关键字来为这些属性指定默认值\",{\"1\":{\"364\":1}}],[\"我们也可以使用stop\",{\"1\":{\"299\":1}}],[\"我们也可以使用scanner来扫描其他的输入流\",{\"1\":{\"285\":1}}],[\"我们也可以使用泛型来表示\",{\"1\":{\"171\":1}}],[\"我们也可以让它向文件中打印\",{\"1\":{\"284\":1}}],[\"我们也可以寻找子集合的位置\",{\"1\":{\"237\":1}}],[\"我们也可以对集合的元素进行快速填充\",{\"1\":{\"235\":1}}],[\"我们也可以只通过stream来完成所有数字的和\",{\"1\":{\"228\":1}}],[\"我们也可以为bean指定一个名称用于区分\",{\"1\":{\"1127\":1}}],[\"我们也可以为所有的方法单个插入准备工作\",{\"1\":{\"985\":1}}],[\"我们也可以为本次断言添加一个message来助于我们快速了解是什么类型的测试结果出现问题\",{\"1\":{\"969\":1}}],[\"我们也可以为这种情况添加一个预备方案\",{\"1\":{\"214\":1}}],[\"我们也可以为构造方法设定参数\",{\"1\":{\"166\":1}}],[\"我们也可以不对任何对象进行引用\",{\"1\":{\"161\":1}}],[\"我们从\",{\"1\":{\"343\":1}}],[\"我们从开始\",{\"1\":{\"295\":1}}],[\"我们前面已经学习了各种各样的bean配置属性\",{\"1\":{\"1152\":1}}],[\"我们前面已经得知\",{\"1\":{\"1060\":1}}],[\"我们前面学习tcp通信的时候已经介绍过了\",{\"1\":{\"1042\":1}}],[\"我们前面提到的stop\",{\"1\":{\"301\":1}}],[\"我们前面创建对象\",{\"1\":{\"166\":1}}],[\"我们实际上是将\",{\"1\":{\"275\":1}}],[\"我们并不会通过一个具体的对象去修改和使用静态属性\",{\"1\":{\"274\":1}}],[\"我们发现它使用了\",{\"1\":{\"1310\":1}}],[\"我们发现除了普通的statement\",{\"1\":{\"790\":1}}],[\"我们发现浏览器是无法打开这个链接的\",{\"1\":{\"727\":1}}],[\"我们发现这个接口中定义了大量数据库操作的方法\",{\"1\":{\"825\":1}}],[\"我们发现这个浏览器同样已经登录成功了\",{\"1\":{\"642\":1}}],[\"我们发现这里放回的对象是一个filterchainproxy类型的\",{\"1\":{\"706\":1}}],[\"我们发现此页面中有一个表单\",{\"1\":{\"641\":1}}],[\"我们发现控制台会输出异常信息\",{\"1\":{\"605\":1}}],[\"我们发现如果处理过程中抛出异常\",{\"1\":{\"599\":1}}],[\"我们发现如果我们依赖了一个模块\",{\"1\":{\"466\":1}}],[\"我们发现现在不见了\",{\"1\":{\"461\":1}}],[\"我们发现integer类中有一个compareto方法\",{\"1\":{\"451\":1}}],[\"我们发现type实际上是class类的父接口\",{\"1\":{\"343\":1}}],[\"我们发现实际上效果是相同的\",{\"1\":{\"312\":1}}],[\"我们发现\",{\"1\":{\"304\":1,\"305\":1,\"313\":1,\"330\":1,\"349\":1,\"384\":1,\"453\":1,\"588\":1,\"600\":1,\"773\":1,\"791\":1,\"804\":1,\"805\":3,\"810\":2,\"824\":1,\"842\":1,\"865\":1,\"908\":1,\"949\":1,\"1017\":1,\"1033\":1,\"1047\":1,\"1054\":1,\"1057\":1,\"1059\":1,\"1083\":1,\"1092\":1,\"1102\":1,\"1103\":1,\"1116\":1,\"1129\":1,\"1172\":1,\"1231\":1,\"1242\":1,\"1245\":1,\"1246\":1,\"1273\":1,\"1278\":1,\"1301\":1,\"1307\":1,\"1326\":1}}],[\"我们发现虽然后面的部分没有保存\",{\"1\":{\"265\":1}}],[\"我们发现得到的是一个optional类实例\",{\"1\":{\"228\":1}}],[\"我们惊奇地发现\",{\"1\":{\"237\":1}}],[\"我们想快速求得list中的最大值和最小值\",{\"1\":{\"233\":1}}],[\"我们想让每一个元素通过\",{\"1\":{\"228\":1}}],[\"我们想要遍历一个集合中所有的元素\",{\"1\":{\"190\":1}}],[\"我们用一堆随机数来进行更多流操作的演示\",{\"1\":{\"228\":1}}],[\"我们用就完事\",{\"1\":{\"217\":1}}],[\"我们通过添加\",{\"1\":{\"812\":2}}],[\"我们通过实战来演示一下lombok的实用注解\",{\"1\":{\"812\":1}}],[\"我们通过以下例子来探究以下事务\",{\"1\":{\"782\":1}}],[\"我们通过\",{\"1\":{\"348\":1}}],[\"我们通过使用\",{\"1\":{\"274\":1}}],[\"我们通过保存键值对的形式来存储映射关系\",{\"1\":{\"212\":1}}],[\"我们通常将\",{\"1\":{\"27\":1}}],[\"我们还要继续对我们之前讲解的beanfactory进行深入介绍\",{\"1\":{\"1300\":1}}],[\"我们还得写判断\",{\"1\":{\"1211\":1}}],[\"我们还是从单配置文件开始讲起\",{\"1\":{\"1124\":1}}],[\"我们还会遇到hikaripool\",{\"1\":{\"1260\":1}}],[\"我们还会遇到更多需要使用aop的地方\",{\"1\":{\"1237\":1}}],[\"我们还会遇到它\",{\"1\":{\"1168\":1}}],[\"我们还会继续深入使用此框架\",{\"1\":{\"699\":1}}],[\"我们还会面对各种各样的需求\",{\"1\":{\"676\":1}}],[\"我们还会回来看我们\",{\"1\":{\"207\":1}}],[\"我们还可以针对某个属性创建对应的投影集合\",{\"1\":{\"1210\":1}}],[\"我们还可以为一个servlet配置多个访问路径\",{\"1\":{\"1063\":1}}],[\"我们还可以为测试案例添加一个自定义的名称\",{\"1\":{\"961\":1}}],[\"我们还可以通过使用test命令\",{\"1\":{\"1035\":1}}],[\"我们还可以通过flat来对整个流进行进一步细分\",{\"1\":{\"228\":1}}],[\"我们还可以让父maven项目统一管理所有的依赖\",{\"1\":{\"1033\":1}}],[\"我们还可以利用单元测试来评估某个模块或是功能的耗时和性能\",{\"1\":{\"956\":1}}],[\"我们还可以添加having来限制分组条件\",{\"1\":{\"766\":1}}],[\"我们还可以使用它来完成更多操作\",{\"1\":{\"1057\":1}}],[\"我们还可以使用assertall来包含多个判断操作\",{\"1\":{\"972\":1}}],[\"我们还可以使用注解进行动态sql的配置\",{\"1\":{\"902\":1}}],[\"我们还可以使用executeupdate\",{\"1\":{\"791\":1}}],[\"我们还可以使用\",{\"1\":{\"699\":1,\"812\":1}}],[\"我们还可以使用方法引用\",{\"1\":{\"414\":1}}],[\"我们还可以以注解形式直接配置\",{\"1\":{\"695\":1}}],[\"我们还可以直接将参数放入\",{\"1\":{\"1235\":1}}],[\"我们还可以直接将请求参数传递给一个实体类\",{\"1\":{\"583\":1}}],[\"我们还可以直接从系统属性中获取我们需要的参数来进行判断\",{\"1\":{\"978\":1}}],[\"我们还可以直接设定一个默认值\",{\"1\":{\"581\":1}}],[\"我们还可以单独添加一个model作为形参进行设置\",{\"1\":{\"563\":1}}],[\"我们还可以指定模块需要使用的抽象类或是接口实现\",{\"1\":{\"467\":1}}],[\"我们还可以指定如果get的对象为null的替代方案\",{\"1\":{\"454\":1}}],[\"我们还可以在注解中定义一些属性\",{\"1\":{\"364\":1}}],[\"我们还可以在当前线程的工作不重要时\",{\"1\":{\"304\":1}}],[\"我们还可以对byte\",{\"1\":{\"356\":1}}],[\"我们还需要单独编写一个类来做这种事情\",{\"1\":{\"902\":1}}],[\"我们还需要去依赖对应的模块\",{\"1\":{\"468\":1}}],[\"我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题\",{\"1\":{\"217\":1}}],[\"我们还需要理解其所描述的最优策略π∗\",{\"1\":{\"56\":1}}],[\"我们在了解这个流程之前\",{\"1\":{\"1301\":1}}],[\"我们在juc篇视频教程中介绍过\",{\"1\":{\"1245\":1}}],[\"我们在javaweb阶段已经了解了session和cookie的机制\",{\"1\":{\"641\":1}}],[\"我们在studentaop类用一个async\",{\"1\":{\"1225\":1}}],[\"我们在里面继续添加aop\",{\"1\":{\"1220\":1}}],[\"我们在里面写入了一个select标签\",{\"1\":{\"826\":1}}],[\"我们在项目里使用service来创建对象\",{\"1\":{\"1119\":1}}],[\"我们在用户登录成功之后\",{\"1\":{\"1096\":1}}],[\"我们在登陆成功时进行判断\",{\"1\":{\"1093\":1}}],[\"我们在登陆成功之后\",{\"1\":{\"1082\":1}}],[\"我们在登录之后\",{\"1\":{\"679\":1}}],[\"我们在webapp目录下新建test文件夹\",{\"1\":{\"1047\":1}}],[\"我们在前面已经给大家讲解过了\",{\"1\":{\"1047\":1}}],[\"我们在前面介绍了arrays\",{\"1\":{\"232\":1}}],[\"我们在查询时\",{\"1\":{\"882\":1}}],[\"我们在查询时mybatis就可以自动把额外信息也封装好了\",{\"1\":{\"850\":1}}],[\"我们在配置\",{\"1\":{\"901\":1}}],[\"我们在配置文件中添加这个mapper映射器\",{\"1\":{\"826\":1}}],[\"我们在配置用户信息的时候\",{\"1\":{\"659\":2}}],[\"我们在移动行数后\",{\"1\":{\"797\":1}}],[\"我们在数据库中的用户表上添加一个新的字段\",{\"1\":{\"692\":1}}],[\"我们在一开始说了springmvc有两个容器\",{\"1\":{\"625\":1}}],[\"我们在之前\",{\"1\":{\"563\":1}}],[\"我们在之前其实已经接触过一些异常了\",{\"1\":{\"421\":1}}],[\"我们在某些情况下可能需要用到匿名内部类\",{\"1\":{\"445\":1}}],[\"我们在方法中使用待确定类型的变量时\",{\"1\":{\"438\":1}}],[\"我们在重写方法时\",{\"1\":{\"423\":1}}],[\"我们在重写父类方法时\",{\"1\":{\"373\":1}}],[\"我们在编写程序时\",{\"1\":{\"313\":1}}],[\"我们在自己的包中也建一个名为string的类\",{\"1\":{\"277\":1}}],[\"我们在\",{\"1\":{\"275\":1}}],[\"我们在创建时可以设定编码格式\",{\"1\":{\"749\":1}}],[\"我们在创建时\",{\"1\":{\"219\":1}}],[\"我们在正常插入一个键值对时\",{\"1\":{\"217\":1}}],[\"我们在获取所有键和所有值时\",{\"1\":{\"214\":1}}],[\"我们在获取一个不存在的映射时\",{\"1\":{\"214\":1}}],[\"我们在这里先不去探讨实现原理\",{\"1\":{\"205\":1}}],[\"我们在使用applicationcontext时\",{\"1\":{\"1298\":1}}],[\"我们在使用注解传参时\",{\"1\":{\"364\":1}}],[\"我们在使用\",{\"1\":{\"182\":1}}],[\"我们的配置可能是xml\",{\"1\":{\"1296\":1}}],[\"我们的applicationcontext中就维护了一个autowirecapablebeanfactory对象\",{\"1\":{\"1296\":1}}],[\"我们的代码量能够进一步的减少\",{\"1\":{\"1256\":1}}],[\"我们的学生一开始有一个老师教他\",{\"1\":{\"1132\":1}}],[\"我们的浏览器会去重新请求另一个网址\",{\"1\":{\"1082\":1}}],[\"我们的浏览器请求一个页面\",{\"1\":{\"1042\":1}}],[\"我们的maven项目也是这样\",{\"1\":{\"1003\":1}}],[\"我们的项目可能会很庞大\",{\"1\":{\"956\":1}}],[\"我们的内容是没有进入到数据库的\",{\"1\":{\"865\":1}}],[\"我们的查询操作可能需要不止一个参数\",{\"1\":{\"843\":1}}],[\"我们的数据源配置信息\",{\"1\":{\"1242\":1}}],[\"我们的数据插入后使用的是一个自增主键id\",{\"1\":{\"862\":1}}],[\"我们的数据可以交给数据库来帮助我们进行管理\",{\"1\":{\"732\":1}}],[\"我们的数据库可能并不会像springsecurity默认的那样进行设计\",{\"1\":{\"667\":1}}],[\"我们的页面已经基本完善为我们想要的样子了\",{\"1\":{\"1104\":1}}],[\"我们的页面只有一个纯文本\",{\"1\":{\"681\":1}}],[\"我们的页面中可能还会包含一些静态资源\",{\"1\":{\"564\":1}}],[\"我们的网站还有一个重要的功能\",{\"1\":{\"685\":1}}],[\"我们的网站就成功用上了更加安全的springsecurity框架了\",{\"1\":{\"658\":1}}],[\"我们的网站不需要再自己编写登录模块了\",{\"1\":{\"658\":1}}],[\"我们的个人信息就从网站内部被泄露了\",{\"1\":{\"643\":1}}],[\"我们的请求只有穿过层层阻碍\",{\"1\":{\"1101\":1}}],[\"我们的请求现在是被另一个servlet进行处理\",{\"1\":{\"1083\":1}}],[\"我们的请求会被直接转交给专门用于异常处理的控制器进行处理\",{\"1\":{\"602\":1}}],[\"我们的请求到达tomcat服务器之后\",{\"1\":{\"558\":1}}],[\"我们的每一个异常也是一个类\",{\"1\":{\"421\":1}}],[\"我们的包就可以命名为com\",{\"1\":{\"277\":1}}],[\"我们的元素之间是两两对应的\",{\"1\":{\"212\":1}}],[\"我们的插入顺序虽然是10\",{\"1\":{\"203\":1}}],[\"我们的方法需要能够同时应对多种情况\",{\"1\":{\"165\":1}}],[\"我们先将artstudent注册一个bean\",{\"1\":{\"1149\":1}}],[\"我们先在前端页面的表单中添加一个勾选框\",{\"1\":{\"1093\":1}}],[\"我们先点击取消\",{\"1\":{\"1047\":1}}],[\"我们先来画一个流程图理清整个过程\",{\"1\":{\"1301\":1}}],[\"我们先来看第一种方式\",{\"1\":{\"850\":1}}],[\"我们先来看看\",{\"1\":{\"1244\":1}}],[\"我们先来看看如果我们想模拟登陆一个用户\",{\"1\":{\"804\":1}}],[\"我们先来看看下面这个例子\",{\"1\":{\"454\":1}}],[\"我们先来看看队列接口\",{\"1\":{\"200\":1}}],[\"我们先来测试一下它的特性\",{\"1\":{\"205\":1}}],[\"我们先直接求解\",{\"1\":{\"142\":1}}],[\"我们这里就直接使用类进行加载\",{\"1\":{\"1291\":1}}],[\"我们这里就使用jul作为日志实现\",{\"1\":{\"1260\":1}}],[\"我们这里就演示一下监听session的创建即可\",{\"1\":{\"1105\":1}}],[\"我们这里导入最新的junit5作为依赖\",{\"1\":{\"1017\":1}}],[\"我们这里指定了jdk的源代码和编译版本为17\",{\"1\":{\"1003\":1}}],[\"我们这里要删除的是刚刚传入的值为10的integer对象\",{\"1\":{\"182\":1}}],[\"我们这里强行初始化为vπ0​​\",{\"1\":{\"70\":1}}],[\"我们会继续学习redis\",{\"1\":{\"888\":1}}],[\"我们会发现我们本地存在一个\",{\"1\":{\"1009\":1}}],[\"我们会发现\",{\"1\":{\"686\":1,\"826\":1,\"841\":1}}],[\"我们会进入到一个退出登录界面\",{\"1\":{\"658\":1}}],[\"我们会详细讲解如何使用更加高级的springsecurity框架来进行权限验证\",{\"1\":{\"626\":1}}],[\"我们会使用接口的引用\",{\"1\":{\"182\":1}}],[\"我们会在日志中惊奇地发现\",{\"1\":{\"883\":1}}],[\"我们会在本章进行详细介绍\",{\"1\":{\"549\":1}}],[\"我们会在第六章多线程部分中讲解\",{\"1\":{\"372\":1}}],[\"我们会在第五章集合类中使用到\",{\"1\":{\"372\":1}}],[\"我们会在jvm篇视频教程中进行介绍\",{\"1\":{\"372\":1}}],[\"我们会在下一章多线程部分中进行介绍\",{\"1\":{\"180\":2}}],[\"我们会在后面的部分中详细介绍beanpostprocessor以及aop的实现原理\",{\"1\":{\"1301\":1}}],[\"我们会在后面讲解\",{\"1\":{\"826\":1}}],[\"我们会在后面继续了解\",{\"1\":{\"299\":1}}],[\"我们会在后面进行详细介绍\",{\"1\":{\"182\":1}}],[\"我们会在后面进行讲解\",{\"1\":{\"180\":1}}],[\"我们会在后面进行介绍\",{\"1\":{\"180\":1,\"1300\":1}}],[\"我们会在后面介绍\",{\"1\":{\"180\":1}}],[\"我们就得到bean的实例对象了\",{\"1\":{\"1300\":1}}],[\"我们就已经知道\",{\"1\":{\"1297\":1}}],[\"我们就已经完全了解了mybatis的池化数据源的执行流程了\",{\"1\":{\"1247\":1}}],[\"我们就已经完成了两种依赖注入的学习\",{\"1\":{\"1136\":1}}],[\"我们就成功将mybatis与spring完成了初步整合\",{\"1\":{\"1256\":1}}],[\"我们就成功配置好了\",{\"1\":{\"1220\":1}}],[\"我们就成功配置了数据库持久化存储记住我信息\",{\"1\":{\"687\":1}}],[\"我们就知道到底如何创建connection对象了\",{\"1\":{\"1242\":1}}],[\"我们就不用再去使用drivermanager为我们提供连接对象\",{\"1\":{\"1242\":1}}],[\"我们就不需要再往页面中嵌入csrf相关的输入框了\",{\"1\":{\"684\":1}}],[\"我们就不需要了\",{\"1\":{\"499\":1}}],[\"我们就相当于需要自己来调用代理方法\",{\"1\":{\"1224\":1}}],[\"我们就指明了需要切入的方法\",{\"1\":{\"1219\":1}}],[\"我们就无法再通过配置文件对bean进行依赖注入等操作了\",{\"1\":{\"1158\":1}}],[\"我们就用不到测试了\",{\"1\":{\"1016\":1}}],[\"我们就将默认的远程仓库地址\",{\"1\":{\"1010\":1}}],[\"我们就将此class文件读取并解析为class了\",{\"1\":{\"356\":1}}],[\"我们就暂时介绍到这里\",{\"1\":{\"904\":1}}],[\"我们就提到过批量执行语句的问题\",{\"1\":{\"871\":1}}],[\"我们就告诉了mybatis我们链接数据库的一些信息\",{\"1\":{\"824\":1}}],[\"我们就能很好地理清不同数据模型之间的关系和特点\",{\"1\":{\"733\":1}}],[\"我们就能快速执行用户相关的管理操作\",{\"1\":{\"665\":1}}],[\"我们就能快速得到文件的所有信息\",{\"1\":{\"255\":1}}],[\"我们就全部介绍完毕了\",{\"1\":{\"699\":1}}],[\"我们就需要使用类来编写配置文件\",{\"1\":{\"1166\":1}}],[\"我们就需要使用mybatis提前帮助我们规定好的标签来进行配置\",{\"1\":{\"824\":1}}],[\"我们就需要使用到泛型的上界定义\",{\"1\":{\"172\":1}}],[\"我们就需要执行大量的sql语句来完成\",{\"1\":{\"782\":1}}],[\"我们就需要了解数据库的关系规范化\",{\"1\":{\"735\":1}}],[\"我们就需要进一步进行配置\",{\"1\":{\"686\":1}}],[\"我们就完成了简单的自定义登录界面配置\",{\"1\":{\"684\":1}}],[\"我们就通过自定义的方式实现了数据库信息查询\",{\"1\":{\"672\":1}}],[\"我们就实现了环绕方法\",{\"1\":{\"1224\":1}}],[\"我们就实现了前后端使用json字符串进行通信\",{\"1\":{\"617\":1}}],[\"我们就实现了从服务端获取数据并更新到页面中\",{\"1\":{\"617\":1}}],[\"我们就统一使用全注解形式编写\",{\"1\":{\"554\":1}}],[\"我们就又可以一气呵成了\",{\"1\":{\"454\":1}}],[\"我们就直接使用匿名内部类的方式传入一个实现\",{\"1\":{\"445\":1}}],[\"我们就来尝试定义一个自己的注解\",{\"1\":{\"363\":1}}],[\"我们就可以配置bean之间的继承关系了\",{\"1\":{\"1149\":1}}],[\"我们就可以根据类型向容器索要bean实例对象了\",{\"1\":{\"1125\":1}}],[\"我们就可以将原有的强关联解除\",{\"1\":{\"1117\":1}}],[\"我们就可以放心地让一个人去写视图层的代码\",{\"1\":{\"1117\":1}}],[\"我们就可以不用再关心我们要去使用哪一个实现类了\",{\"1\":{\"1117\":1}}],[\"我们就可以给我们的应用程序添加一个过滤器\",{\"1\":{\"1104\":1}}],[\"我们就可以很好地控制用户的登陆验证了\",{\"1\":{\"1101\":1}}],[\"我们就可以很好地存储这样带有一定联系的数据\",{\"1\":{\"733\":1}}],[\"我们就可以更好地控制用户对于资源的访问\",{\"1\":{\"1097\":1}}],[\"我们就可以更加谨慎地进行一些操作了\",{\"1\":{\"806\":1}}],[\"我们就可以更加灵活地控制泛型的具体类型范围\",{\"1\":{\"172\":1}}],[\"我们就可以快速部署我们的web项目\",{\"1\":{\"1047\":1}}],[\"我们就可以删除此触发器\",{\"1\":{\"781\":1}}],[\"我们就可以获取到对应的i\",{\"1\":{\"720\":1}}],[\"我们就可以让某些用户只能访问部分页面\",{\"1\":{\"692\":1}}],[\"我们就可以前往登录界面\",{\"1\":{\"658\":1}}],[\"我们就可以直接使用安全导航运算符\",{\"1\":{\"1211\":1}}],[\"我们就可以直接上手使用了\",{\"1\":{\"958\":1}}],[\"我们就可以直接从请求路径中读取参数\",{\"1\":{\"589\":1}}],[\"我们就可以直接通过set\",{\"1\":{\"350\":1}}],[\"我们就可以简单地进行模块的使用了\",{\"1\":{\"468\":1}}],[\"我们就可以按照模块的方式进行管理了\",{\"1\":{\"460\":1}}],[\"我们就可以实现两台计算机之间的通信\",{\"1\":{\"718\":1}}],[\"我们就可以实现外部加载甚至是网络加载一个类\",{\"1\":{\"356\":1}}],[\"我们就可以实现对集合中的元素的进行遍历\",{\"1\":{\"188\":1}}],[\"我们就可以使用aop来帮助我们完成\",{\"1\":{\"1215\":1}}],[\"我们就可以使用监听器来实现\",{\"1\":{\"1105\":1}}],[\"我们就可以使用重定向来完成\",{\"1\":{\"1082\":1}}],[\"我们就可以使用继承关系来快速配置\",{\"1\":{\"1032\":1}}],[\"我们就可以使用select语句来直接查询视图上的数据了\",{\"1\":{\"779\":1}}],[\"我们就可以使用biginteger来完成\",{\"1\":{\"386\":1}}],[\"我们就可以使用inputstreamreader来帮助我们实现\",{\"1\":{\"283\":1}}],[\"我们就可以使用\",{\"1\":{\"228\":1}}],[\"我们就可以把一个\",{\"1\":{\"228\":1}}],[\"我们就可以自定义\",{\"1\":{\"171\":1}}],[\"我们就可以通过更方便的方式来使用mybatis框架\",{\"1\":{\"1241\":1}}],[\"我们就可以通过使用外连接来进行查询\",{\"1\":{\"769\":1}}],[\"我们就可以通过\",{\"1\":{\"104\":1}}],[\"我们就可以得到\",{\"1\":{\"99\":1}}],[\"我们便称为\",{\"1\":{\"156\":1}}],[\"我们定义的每一个状态其实就是一个public\",{\"1\":{\"378\":1}}],[\"我们定义\",{\"1\":{\"148\":1}}],[\"我们定义最优的策略为\",{\"1\":{\"148\":1}}],[\"我们将请求转发给处理时间的servlet\",{\"1\":{\"1083\":1}}],[\"我们将其中的两个页面和资源文件放到类路径下\",{\"1\":{\"677\":1}}],[\"我们将类放到包中\",{\"1\":{\"277\":1}}],[\"我们将变量p2赋值为p1的值\",{\"1\":{\"161\":1}}],[\"我们将\",{\"1\":{\"138\":1}}],[\"我们是没办法直接得到的\",{\"1\":{\"500\":1}}],[\"我们是没办法在其他地方使用的\",{\"1\":{\"485\":1}}],[\"我们是无法估计的\",{\"1\":{\"136\":1}}],[\"我们是引入了\",{\"1\":{\"105\":1}}],[\"我们很难直接获得\",{\"1\":{\"101\":1}}],[\"我们只有告诉工厂我们要生产什么\",{\"1\":{\"1296\":1}}],[\"我们只需在方法上添加\",{\"1\":{\"1277\":1}}],[\"我们只需右键左侧栏\",{\"1\":{\"1032\":1}}],[\"我们只需要把一个事务要做的所有事情封装到service层的一个方法中即可\",{\"1\":{\"1274\":1}}],[\"我们只需要一个\",{\"1\":{\"1257\":1}}],[\"我们只需要让bean继承applicationlistener就可以了\",{\"1\":{\"1191\":1}}],[\"我们只需要让查询出来的每一个用户都左连接分组信息即可\",{\"1\":{\"855\":1}}],[\"我们只需要实现这个接口就可以了\",{\"1\":{\"1186\":1}}],[\"我们只需要实现servlet类即可\",{\"1\":{\"1054\":1}}],[\"我们只需要提供一个对应参数的构造方法就可以了\",{\"1\":{\"1139\":1}}],[\"我们只需要将其添加到对应的方法上即可\",{\"1\":{\"1176\":1}}],[\"我们只需要将autowire修改为\",{\"1\":{\"1139\":1}}],[\"我们只需要将set方法提供好就可以了\",{\"1\":{\"1137\":1}}],[\"我们只需要将对应的viewresolver注册为bean即可\",{\"1\":{\"560\":1}}],[\"我们只需要关心\",{\"1\":{\"1117\":1}}],[\"我们只需要重写这些具体方法就行\",{\"1\":{\"1059\":1}}],[\"我们只需要执行java\",{\"1\":{\"1037\":1}}],[\"我们只需要点击类旁边的运行按钮\",{\"1\":{\"959\":1}}],[\"我们只需要继承formatter类\",{\"1\":{\"944\":1}}],[\"我们只需要直接导入其依赖就可以使用了\",{\"1\":{\"1118\":1}}],[\"我们只需要直接通过浏览器访问我们的项目即可\",{\"1\":{\"1047\":1}}],[\"我们只需要直接在其中编写sql语句即可\",{\"1\":{\"896\":1}}],[\"我们只需要直接拿来用就行了\",{\"1\":{\"180\":1}}],[\"我们只需要编写对应的映射器\",{\"1\":{\"893\":1}}],[\"我们只需要告诉一个映射关系\",{\"1\":{\"826\":1}}],[\"我们只需要稍微进行一下配置就可以实现\",{\"1\":{\"683\":1}}],[\"我们只需要返回true或是false表示是否被拦截即可\",{\"1\":{\"597\":1}}],[\"我们只需要为方法添加一个形式参数\",{\"1\":{\"579\":1}}],[\"我们只需要输入jshell命令即可开启交互式编程了\",{\"1\":{\"473\":1}}],[\"我们只需要在最后添加一句\",{\"1\":{\"1103\":1}}],[\"我们只需要在对应的\",{\"1\":{\"1059\":1}}],[\"我们只需要在编译阶段使用它\",{\"1\":{\"1016\":1}}],[\"我们只需要在创建sqlsession时进行一些配置即可\",{\"1\":{\"871\":1}}],[\"我们只需要在mybatis的配置文件中进行编写即可\",{\"1\":{\"832\":1}}],[\"我们只需要在一张表中去查找数据即可\",{\"1\":{\"762\":1}}],[\"我们只需要在视图名称前面添加一个前缀即可\",{\"1\":{\"587\":1}}],[\"我们只需要在类名前面把完整的包名也给写上\",{\"1\":{\"277\":1}}],[\"我们只需要在当前状态下\",{\"1\":{\"57\":1}}],[\"我们只需要使用\",{\"1\":{\"162\":1}}],[\"我们只需要挑选在当前迭代下最大的\",{\"1\":{\"63\":1}}],[\"我们只能将各个模块进行解耦\",{\"1\":{\"1116\":1}}],[\"我们只能关闭所有二级缓存\",{\"1\":{\"888\":1}}],[\"我们只能使用对应的包装类\",{\"1\":{\"438\":1}}],[\"我们只能去创建它的子类对象\",{\"1\":{\"375\":1}}],[\"我们只能把它当做一个不得已才去使用的工具\",{\"1\":{\"350\":1}}],[\"我们只能简单的删除\",{\"1\":{\"205\":1}}],[\"我们只能通过\",{\"1\":{\"97\":1}}],[\"我们不用去修改\",{\"1\":{\"1002\":1}}],[\"我们不需要删除这些多余的构造方法\",{\"1\":{\"841\":1}}],[\"我们不知道这是一个表单\",{\"1\":{\"641\":1}}],[\"我们不必再像之前那样一个请求地址创建一个servlet了\",{\"1\":{\"558\":1}}],[\"我们不仅可以通过构造方法\",{\"1\":{\"166\":1}}],[\"我们不仅可以用来估计q\",{\"1\":{\"81\":1}}],[\"我们不断地与环境进行交互\",{\"1\":{\"135\":1}}],[\"我们不能直接得到随机变量的值\",{\"1\":{\"99\":1}}],[\"我们不能通过之前的方法来求出q\",{\"1\":{\"77\":1}}],[\"我们选取其\",{\"1\":{\"79\":1}}],[\"我们需要得到的是一个经过aop代理的对象\",{\"1\":{\"1301\":1}}],[\"我们需要执行之后进行切入\",{\"1\":{\"1218\":1}}],[\"我们需要知道这些内容\",{\"1\":{\"1217\":1}}],[\"我们需要指定\",{\"1\":{\"1190\":1}}],[\"我们需要指明一个可以用的构造方法\",{\"1\":{\"1134\":1}}],[\"我们需要添加一个自动扫描\",{\"1\":{\"1177\":1}}],[\"我们需要对property参数进行配置\",{\"1\":{\"1137\":1}}],[\"我们需要对继承关系有一些限制的控制手段\",{\"1\":{\"503\":1}}],[\"我们需要用这个新的类来完成业务了\",{\"1\":{\"1116\":1}}],[\"我们需要用到反射机制\",{\"1\":{\"365\":1}}],[\"我们需要完成后面内容的学习\",{\"1\":{\"1086\":1}}],[\"我们需要填写servlet上指明的路径\",{\"1\":{\"1083\":1}}],[\"我们需要导入另一个依赖\",{\"1\":{\"1260\":1}}],[\"我们需要导入依赖\",{\"1\":{\"1260\":1}}],[\"我们需要导入之前的jdbc驱动依赖\",{\"1\":{\"1008\":1}}],[\"我们需要导入mybatis的依赖\",{\"1\":{\"824\":1}}],[\"我们需要使用一个特殊的语法\",{\"1\":{\"1205\":1}}],[\"我们需要使用servletcontext来读取全局初始化参数\",{\"1\":{\"1086\":1}}],[\"我们需要使用另一个插件来实现一起打包\",{\"1\":{\"1037\":1}}],[\"我们需要使用resources类的getresourceasstream来获取内部的资源文件\",{\"1\":{\"1017\":1}}],[\"我们需要使用国内的镜像仓库服务器来加速访问\",{\"1\":{\"1010\":1}}],[\"我们需要使用\",{\"1\":{\"961\":1}}],[\"我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试\",{\"1\":{\"956\":1}}],[\"我们需要使用thymeleafviewresolver作为视图解析器\",{\"1\":{\"560\":1}}],[\"我们需要同时调整handler和logger的level属性\",{\"1\":{\"912\":1}}],[\"我们需要先创建一个类编写我们的动态sql操作\",{\"1\":{\"902\":1}}],[\"我们需要先修改访问权限\",{\"1\":{\"348\":1}}],[\"我们需要手动为其起个别名\",{\"1\":{\"855\":1}}],[\"我们需要配置一个collection标签来让其可以正确处理关联的集合结果\",{\"1\":{\"853\":1}}],[\"我们需要配置为用户自行勾选\",{\"1\":{\"686\":1}}],[\"我们需要修改一下我们的servlet\",{\"1\":{\"1069\":1}}],[\"我们需要修改一下配置文件中的mapper文件目录\",{\"1\":{\"842\":1}}],[\"我们需要修改一下前端页面中的表单\",{\"1\":{\"686\":1}}],[\"我们需要提前给到preparedstatement一个sql语句\",{\"1\":{\"805\":1}}],[\"我们需要更多的用户来一起管理整个数据库\",{\"1\":{\"771\":1}}],[\"我们需要更加高级的权限校验框架来帮助我们实现登陆操作\",{\"1\":{\"626\":1}}],[\"我们需要创建什么样子的表\",{\"1\":{\"734\":1}}],[\"我们需要创建一个基于jdbc的tokenrepository实现\",{\"1\":{\"687\":1}}],[\"我们需要做的就是指定哪些请求可以由哪些用户发起\",{\"1\":{\"691\":1}}],[\"我们需要保证服务器一直处于运行状态\",{\"1\":{\"686\":1}}],[\"我们需要保证策略是不断提升\",{\"1\":{\"68\":1}}],[\"我们需要进行一个简单的环境搭建\",{\"1\":{\"1047\":1}}],[\"我们需要进行配置\",{\"1\":{\"951\":1}}],[\"我们需要进行简单配置\",{\"1\":{\"686\":1}}],[\"我们需要进行导入\",{\"1\":{\"464\":1}}],[\"我们需要一种更加简洁高效的方式来和数据库进行交互\",{\"1\":{\"816\":1}}],[\"我们需要一种更加安全的机制来维持秩序\",{\"1\":{\"311\":1}}],[\"我们需要一种既能隐藏用户密码也能完成认证的机制\",{\"1\":{\"659\":1}}],[\"我们需要了解一种比较容易发生的恶意操作\",{\"1\":{\"641\":1}}],[\"我们需要让配置类实现一下webmvcconfigurer接口\",{\"1\":{\"564\":1}}],[\"我们需要传入一个runnable接口的实现类\",{\"1\":{\"445\":1}}],[\"我们需要在配置类上添加\",{\"1\":{\"1188\":1}}],[\"我们需要在tomcat官网下载最新的tomcat服务端程序\",{\"1\":{\"1047\":1}}],[\"我们需要在映射器xml文件中添加\",{\"1\":{\"884\":1}}],[\"我们需要在resultmap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系\",{\"1\":{\"853\":1}}],[\"我们需要在java程序启动时\",{\"1\":{\"824\":1}}],[\"我们需要在maininitializer中添加一个新的方法\",{\"1\":{\"619\":1}}],[\"我们需要在\",{\"1\":{\"579\":1}}],[\"我们需要在里面添加1\",{\"1\":{\"438\":1}}],[\"我们需要在虚拟机参数中手动开启一下\",{\"1\":{\"425\":1}}],[\"我们需要在使用时手动指定注解的属性名称\",{\"1\":{\"364\":1}}],[\"我们需要明确指定一下\",{\"1\":{\"277\":1}}],[\"我们需要结合具体的场景来决定\",{\"1\":{\"182\":1}}],[\"我们需要从经验池\",{\"1\":{\"142\":1}}],[\"我们需要思考使用\",{\"1\":{\"104\":1}}],[\"我们需要找到一个\",{\"1\":{\"26\":1}}],[\"关联查询\",{\"0\":{\"901\":1}}],[\"关闭\",{\"1\":{\"1272\":2}}],[\"关闭连接会持续消耗网络资源\",{\"1\":{\"1242\":1}}],[\"关闭浏览器即失效\",{\"1\":{\"1092\":1}}],[\"关闭自动提交\",{\"1\":{\"806\":4}}],[\"关闭自动提交后相当于开启事务\",{\"1\":{\"806\":1}}],[\"关闭输入方向的流\",{\"1\":{\"721\":1}}],[\"关闭输出方向的流\",{\"1\":{\"721\":1}}],[\"关于使用配置文件的形式修改jul部分内容的默认值就先讲解到这里\",{\"1\":{\"939\":1}}],[\"关于springmvc的相关内容就学习得差不多了\",{\"1\":{\"624\":1}}],[\"关于对象类型的变量\",{\"1\":{\"161\":1}}],[\"关键代码如下\",{\"1\":{\"1326\":1}}],[\"关键\",{\"1\":{\"531\":1,\"1317\":1}}],[\"关键字推荐使用大写\",{\"1\":{\"744\":1}}],[\"关键字\",{\"0\":{\"290\":1},\"1\":{\"373\":1,\"392\":1}}],[\"关键字来声明一个变量或一个方法为静态的\",{\"1\":{\"274\":1}}],[\"关键元素\",{\"1\":{\"20\":1}}],[\"访问权限不够是不行的\",{\"1\":{\"1203\":1}}],[\"访问权限控制\",{\"0\":{\"278\":1}}],[\"访问登陆页面后\",{\"1\":{\"1093\":1}}],[\"访问成功说明我们的tomcat环境已经部署成功了\",{\"1\":{\"1047\":1}}],[\"访问速度更快\",{\"1\":{\"1010\":1}}],[\"访问日志等内容中泄露\",{\"1\":{\"714\":1}}],[\"访问后默认使用的项目为root项目\",{\"1\":{\"1047\":1}}],[\"访问后\",{\"1\":{\"605\":1}}],[\"访问第三行第二列的元素\",{\"1\":{\"397\":1}}],[\"访问元素\",{\"0\":{\"394\":1}}],[\"访问类的静态变量\",{\"1\":{\"275\":1}}],[\"访问\",{\"1\":{\"161\":1}}],[\"概念\",{\"1\":{\"1000\":1}}],[\"概念上的定义\",{\"1\":{\"161\":1}}],[\"概率分布\",{\"1\":{\"150\":1}}],[\"类比写入硬盘的文件\",{\"1\":{\"1266\":1}}],[\"类比多个人同时编辑同一文档\",{\"1\":{\"1266\":1}}],[\"类比银行转账\",{\"1\":{\"1266\":1}}],[\"类中生成一个名为\",{\"1\":{\"1260\":1}}],[\"类中的某些参数是在构造方法中就已经完成初始化\",{\"1\":{\"1134\":1}}],[\"类中的\",{\"1\":{\"707\":1}}],[\"类上直接添加\",{\"1\":{\"1232\":1}}],[\"类路径下的文件名称需要在前面加上classpath\",{\"1\":{\"1198\":1}}],[\"类提供了三个方法可供进行元素匹配\",{\"1\":{\"520\":1}}],[\"类是一个可以为null的容器对象\",{\"1\":{\"512\":1}}],[\"类使用\",{\"0\":{\"490\":1}}],[\"类进行存储成绩\",{\"1\":{\"437\":1}}],[\"类呢\",{\"1\":{\"437\":1}}],[\"类的哪个方法需要被切入\",{\"1\":{\"1217\":1}}],[\"类的\",{\"1\":{\"519\":1}}],[\"类的引入很好的解决空指针异常\",{\"1\":{\"512\":1}}],[\"类的构造方法默认返回自身对象\",{\"1\":{\"453\":1}}],[\"类的构造方法\",{\"1\":{\"453\":1}}],[\"类的子类\",{\"1\":{\"438\":1}}],[\"类的异常都是编译时异常\",{\"1\":{\"421\":1}}],[\"类的内部类它会单独生成一个\",{\"1\":{\"411\":1}}],[\"类的创建\",{\"1\":{\"161\":1}}],[\"类只能继承一个\",{\"1\":{\"376\":1}}],[\"类可以实现这个接口\",{\"1\":{\"376\":1}}],[\"类加载器就是用于加载一个类的\",{\"1\":{\"355\":1}}],[\"类加载器\",{\"0\":{\"355\":1}}],[\"类加载机制\",{\"0\":{\"337\":1}}],[\"类名称\",{\"1\":{\"948\":1}}],[\"类名\",{\"1\":{\"415\":3,\"448\":1,\"504\":1,\"921\":1,\"1219\":2}}],[\"类名上\",{\"1\":{\"360\":1}}],[\"类名必须和我们定义的保持一致\",{\"1\":{\"356\":1}}],[\"类名获取\",{\"1\":{\"339\":1}}],[\"类名的首字母通常是大写的\",{\"1\":{\"161\":1}}],[\"类还有三个方法我们从来没有使用过\",{\"1\":{\"318\":1}}],[\"类锁\",{\"1\":{\"312\":1}}],[\"类锁只有一个\",{\"1\":{\"312\":1}}],[\"类就是专用于集合的工具类\",{\"1\":{\"232\":1}}],[\"类似\",{\"1\":{\"228\":1,\"412\":1,\"782\":1}}],[\"类似于这种判空问题\",{\"1\":{\"1211\":1}}],[\"类似于map\",{\"1\":{\"1197\":1}}],[\"类似于递归的结构\",{\"1\":{\"1103\":1}}],[\"类似于下面图中的日志格式\",{\"1\":{\"948\":1}}],[\"类似于之前的filter\",{\"1\":{\"625\":1}}],[\"类似于一个插件\",{\"1\":{\"376\":1}}],[\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制\",{\"1\":{\"311\":1}}],[\"类似于c++中的namespace\",{\"1\":{\"277\":1}}],[\"类似于c++指针的情况\",{\"1\":{\"161\":1}}],[\"类似于vip用户可以优先结束排队\",{\"1\":{\"203\":1}}],[\"类型是\",{\"1\":{\"1260\":1}}],[\"类型名称\",{\"1\":{\"831\":1}}],[\"类型中包含该指定类型才返回\",{\"1\":{\"577\":1}}],[\"类型的bean\",{\"1\":{\"1320\":1}}],[\"类型的参数\",{\"1\":{\"519\":1}}],[\"类型的变量\",{\"1\":{\"438\":1}}],[\"类型的\",{\"1\":{\"398\":1,\"560\":1,\"1320\":1}}],[\"类型的成绩了\",{\"1\":{\"172\":1}}],[\"类型为\",{\"1\":{\"343\":1}}],[\"类型比较\",{\"0\":{\"343\":1}}],[\"类型作为存储\",{\"1\":{\"253\":1}}],[\"类型擦除\",{\"0\":{\"173\":1}}],[\"类型\",{\"1\":{\"171\":2,\"392\":8,\"437\":1,\"438\":1,\"488\":1,\"528\":1}}],[\"类型变量并不是只能在泛型类中才可以使用\",{\"1\":{\"171\":1}}],[\"类除了具有属性外\",{\"1\":{\"162\":1}}],[\"类\",{\"0\":{\"255\":1,\"338\":1,\"372\":1,\"401\":1,\"402\":1,\"409\":1,\"1254\":1,\"1259\":1,\"1327\":1},\"1\":{\"161\":1,\"180\":1,\"241\":1,\"312\":1,\"365\":1,\"374\":1,\"406\":1,\"421\":1,\"431\":1,\"451\":1,\"453\":1,\"524\":1,\"552\":1}}],[\"类与对象4\",{\"0\":{\"381\":1}}],[\"类与对象3\",{\"0\":{\"368\":1}}],[\"类与对象2\",{\"0\":{\"273\":1}}],[\"类与对象\",{\"0\":{\"161\":1}}],[\"类与对象1\",{\"0\":{\"160\":1}}],[\"梯度上升算法的本质就是最大化目标函数\",{\"1\":{\"156\":1}}],[\"梯度上升算法\",{\"0\":{\"156\":1}}],[\"梯度下降\",{\"1\":{\"136\":1}}],[\"梯度下降法\",{\"1\":{\"101\":1}}],[\"近似\",{\"1\":{\"155\":1}}],[\"时不会立刻去创建\",{\"1\":{\"1181\":1}}],[\"时间等\",{\"1\":{\"948\":1}}],[\"时间\",{\"1\":{\"921\":1}}],[\"时mybatis就会自动调用类中对应的get方法来获取结果\",{\"1\":{\"861\":1}}],[\"时\",{\"1\":{\"182\":1,\"218\":1,\"372\":1,\"805\":1,\"1056\":1,\"1181\":1}}],[\"时的平均reward\",{\"1\":{\"153\":1}}],[\"时wk​→w∗\",{\"1\":{\"104\":1}}],[\"确实做不到\",{\"1\":{\"1189\":1}}],[\"确实向服务器发起了一个post请求\",{\"1\":{\"1069\":1}}],[\"确保某列的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"748\":1}}],[\"确保列中的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"747\":1}}],[\"确保列中的每个值都是唯一的\",{\"1\":{\"747\":2}}],[\"确保根是存在且唯一的\",{\"1\":{\"98\":1}}],[\"确定\",{\"1\":{\"148\":1}}],[\"固定不动\",{\"1\":{\"142\":1}}],[\"固定\",{\"1\":{\"142\":1}}],[\"目的是用于处理一些其他比较特殊的bean\",{\"1\":{\"1320\":1}}],[\"目的是让url看起来更简洁实用\",{\"1\":{\"589\":1}}],[\"目的是最小化目标函数\",{\"1\":{\"141\":1}}],[\"目前似乎也没看到有实现\",{\"1\":{\"1320\":1}}],[\"目前没有看到有实现\",{\"1\":{\"1320\":1}}],[\"目前只做了解即可\",{\"1\":{\"1168\":1}}],[\"目前依然是可以正常登录的\",{\"1\":{\"692\":1}}],[\"目前各位小伙伴就暂时理解为会返回对象存放的内存地址\",{\"1\":{\"372\":1}}],[\"目前暂时不会用到\",{\"1\":{\"372\":3}}],[\"目前\",{\"1\":{\"207\":1}}],[\"目前的优化算法只是在估计给定策略的\",{\"1\":{\"136\":1}}],[\"目标函数梯度求解\",{\"0\":{\"155\":1}}],[\"目标函数定义\",{\"0\":{\"149\":1}}],[\"目标\",{\"1\":{\"132\":1}}],[\"目标是获得无人机的最佳3d位置\",{\"1\":{\"13\":1}}],[\"≥0\",{\"1\":{\"135\":1,\"150\":1,\"155\":1}}],[\"≥vπ​\",{\"1\":{\"53\":1}}],[\"下次就可以直接在第二层拿到了\",{\"1\":{\"1301\":1}}],[\"下次需要获取数据时\",{\"1\":{\"882\":1}}],[\"下午\",{\"1\":{\"908\":1,\"1181\":1,\"1260\":3,\"1278\":1}}],[\"下一个隔离级别可重复读就能够解决这样的问题\",{\"1\":{\"1270\":1}}],[\"下一板块讲解\",{\"1\":{\"1242\":1}}],[\"下一次读取将直接无法获取到这行数据\",{\"1\":{\"888\":1}}],[\"下一章\",{\"1\":{\"626\":1}}],[\"下同\",{\"1\":{\"765\":1}}],[\"下面注解主要就是利用这个函数来进行判断\",{\"1\":{\"978\":1}}],[\"下面这种情况\",{\"1\":{\"835\":1}}],[\"下面我们接着了解了其中一个内部过滤器就明白了\",{\"1\":{\"710\":1}}],[\"下面具体保存过程的不用我多说了吧\",{\"1\":{\"490\":1}}],[\"下载完成后\",{\"1\":{\"1047\":1}}],[\"下载\",{\"0\":{\"1074\":1},\"1\":{\"1047\":1}}],[\"下载速度缓慢\",{\"1\":{\"1010\":1}}],[\"下载好模版后\",{\"1\":{\"677\":1}}],[\"下载其实和我们之前的写法大致一样\",{\"1\":{\"620\":1}}],[\"下划线\",{\"1\":{\"403\":1}}],[\"下界限定就像这样\",{\"1\":{\"172\":1}}],[\"下界\",{\"1\":{\"172\":1}}],[\"下的一个纯\",{\"1\":{\"1000\":1}}],[\"下的\",{\"1\":{\"135\":1,\"152\":1}}],[\"下行\",{\"1\":{\"13\":1}}],[\"寻找一个最优的参数w\",{\"1\":{\"132\":1}}],[\"版本需要在3\",{\"1\":{\"1253\":1}}],[\"版本号也会不断更新\",{\"1\":{\"1003\":1}}],[\"版本要求\",{\"1\":{\"528\":1}}],[\"版本\",{\"0\":{\"125\":1,\"126\":1},\"1\":{\"978\":1}}],[\"||\",{\"1\":{\"216\":4,\"241\":2,\"626\":1}}],[\"|\",{\"0\":{\"121\":1,\"233\":1,\"389\":2},\"1\":{\"189\":2,\"268\":1,\"288\":1,\"290\":1,\"312\":1,\"318\":1,\"343\":1,\"424\":2,\"432\":3,\"625\":1,\"626\":1,\"799\":1,\"918\":2,\"951\":6}}],[\"≐e\",{\"1\":{\"155\":1}}],[\"≐g\",{\"1\":{\"110\":1}}],[\"≐w−x\",{\"1\":{\"99\":1}}],[\"≐w−e\",{\"1\":{\"99\":1}}],[\"ω=e\",{\"1\":{\"110\":1}}],[\"计算结果验证\",{\"1\":{\"969\":1,\"970\":1,\"972\":1}}],[\"计算出来的结果一般是单向的\",{\"1\":{\"659\":1}}],[\"计算机网络\",{\"1\":{\"438\":2}}],[\"计算10\",{\"1\":{\"386\":1}}],[\"计算的话也只能通过\",{\"1\":{\"386\":1}}],[\"计算规则为\",{\"1\":{\"228\":1}}],[\"计算并将键值对放入map中\",{\"1\":{\"221\":1}}],[\"计算当前整个集合对象的哈希值\",{\"1\":{\"180\":1}}],[\"计算\",{\"1\":{\"110\":1}}],[\"∇w​f\",{\"1\":{\"104\":2}}],[\"让另一个\",{\"1\":{\"1181\":1}}],[\"让容器自己反射获取构造方法去生成这个对象呢\",{\"1\":{\"1177\":1}}],[\"让各个模块之间的依赖性不再那么地强\",{\"1\":{\"1116\":1}}],[\"让其中一个依赖延迟到使用时再初始化\",{\"1\":{\"1181\":1}}],[\"让其能够接收一个post请求\",{\"1\":{\"1069\":1}}],[\"让其实现iterable接口\",{\"1\":{\"193\":1}}],[\"让mybatis对配置文件进行读取并得到一个sqlsessionfactory对象\",{\"1\":{\"824\":1}}],[\"让request具有更加丰富的内容\",{\"1\":{\"714\":1}}],[\"让controller类中所有的方法都可以获取到通过\",{\"1\":{\"602\":1}}],[\"让静态资源通过tomcat提供的默认servlet进行解析\",{\"1\":{\"564\":1}}],[\"让字符串重复拼接\",{\"1\":{\"488\":1}}],[\"让子类继续为一个泛型类\",{\"1\":{\"439\":1}}],[\"让程序继续运行下去\",{\"1\":{\"424\":1}}],[\"让程序员写出高效率\",{\"1\":{\"228\":1}}],[\"让类来使用这个接口\",{\"1\":{\"376\":1}}],[\"让我们使用switch语句更加的灵活\",{\"1\":{\"495\":1}}],[\"让我们的java程序更加生动形象\",{\"1\":{\"369\":1}}],[\"让我看看\",{\"1\":{\"274\":1}}],[\"让线程1加入\",{\"1\":{\"305\":1}}],[\"让线程自行处理后续\",{\"1\":{\"301\":1}}],[\"让位\",{\"1\":{\"304\":1}}],[\"让p等于e一会覆盖就行了\",{\"1\":{\"216\":1}}],[\"让当前对象的name变量值等于参数传入的值\",{\"1\":{\"164\":1}}],[\"让\",{\"1\":{\"104\":1}}],[\"往往可以转化为导数为\",{\"1\":{\"104\":1}}],[\"=\",{\"1\":{\"116\":1,\"120\":1}}],[\"=e\",{\"1\":{\"104\":1}}],[\"=n\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"⇓wk+1​=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"到这里\",{\"1\":{\"1244\":1}}],[\"到这里其实页面就已经直接跳转了\",{\"1\":{\"712\":1}}],[\"到达指定时间再去执行\",{\"1\":{\"1187\":1}}],[\"到事务开始前的状态\",{\"1\":{\"782\":1}}],[\"到目前为止\",{\"1\":{\"624\":1,\"1320\":1}}],[\"到此为止\",{\"1\":{\"504\":1}}],[\"到最后编译完成后还是会变成具体类型的\",{\"1\":{\"485\":1}}],[\"到\",{\"1\":{\"104\":1,\"531\":1,\"810\":1}}],[\"转义字符\",{\"0\":{\"818\":1}}],[\"转账失败\",{\"1\":{\"636\":1}}],[\"转账成功\",{\"1\":{\"636\":1}}],[\"转账账号\",{\"1\":{\"636\":1}}],[\"转账给\",{\"1\":{\"636\":2,\"658\":1}}],[\"转化为\",{\"1\":{\"103\":1}}],[\"转换\",{\"0\":{\"833\":1}}],[\"转换流\",{\"0\":{\"283\":1,\"522\":1}}],[\"转换到\",{\"1\":{\"130\":1}}],[\"转换到状态s\",{\"1\":{\"20\":1}}],[\"转换为httpservletresponse\",{\"1\":{\"1058\":1}}],[\"转换为数字666\",{\"1\":{\"385\":1}}],[\"转换为\",{\"1\":{\"58\":1,\"76\":1,\"77\":1,\"148\":1}}],[\"均为非负整数\",{\"1\":{\"403\":1}}],[\"均是随机变量\",{\"1\":{\"110\":1,\"141\":1}}],[\"均值估计\",{\"1\":{\"103\":1}}],[\"均收集完\",{\"1\":{\"82\":1}}],[\"分组和分页查询\",{\"0\":{\"766\":1}}],[\"分数\",{\"1\":{\"495\":1}}],[\"分为多个字符串\",{\"1\":{\"488\":2}}],[\"分割字符串\",{\"1\":{\"401\":1}}],[\"分割字符串并生成新的流\",{\"1\":{\"228\":1}}],[\"分割操作\",{\"1\":{\"401\":1}}],[\"分别位于main和test目录下\",{\"1\":{\"1001\":1}}],[\"分别是user表和user\",{\"1\":{\"852\":1}}],[\"分别是wait\",{\"1\":{\"318\":1}}],[\"分别执行两个选择语句\",{\"1\":{\"851\":1}}],[\"分别需要使用\",{\"1\":{\"836\":1}}],[\"分别代表插入\",{\"1\":{\"744\":1}}],[\"分别适用于快速创建包含0~10对键值对的map\",{\"1\":{\"475\":1}}],[\"分别设为1\",{\"1\":{\"10\":1}}],[\"分析随机变量\",{\"1\":{\"133\":1}}],[\"分析\",{\"0\":{\"102\":1,\"1222\":1,\"1300\":1,\"1317\":1}}],[\"▽w​q^​\",{\"1\":{\"142\":2}}],[\"▽w​qt​^​\",{\"1\":{\"139\":1,\"140\":1}}],[\"▽w​vt​^​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"▽w​v^\",{\"1\":{\"136\":1}}],[\"▽w​\",{\"1\":{\"136\":1}}],[\"▽w​j​=e\",{\"1\":{\"142\":1}}],[\"▽w​j\",{\"1\":{\"104\":1,\"136\":1}}],[\"▽w​f\",{\"1\":{\"101\":2,\"104\":10}}],[\"▽θ​π\",{\"1\":{\"155\":1}}],[\"▽θ​lnπ\",{\"1\":{\"155\":6,\"156\":1}}],[\"▽θ​ln\",{\"1\":{\"26\":3}}],[\"▽θ​j\",{\"1\":{\"26\":1,\"155\":3}}],[\"输出节点名称\",{\"1\":{\"819\":1}}],[\"输出到浏览器\",{\"1\":{\"560\":1}}],[\"输出为\",{\"1\":{\"411\":1}}],[\"输出为标量\",{\"1\":{\"101\":1}}],[\"输出流没有read\",{\"1\":{\"249\":1}}],[\"输出流也需要在最后调用close\",{\"1\":{\"249\":1}}],[\"输出流\",{\"0\":{\"249\":1}}],[\"输入mvn\",{\"1\":{\"1036\":1}}],[\"输入密码后即可登陆此用户\",{\"1\":{\"773\":1}}],[\"输入的不是数字\",{\"1\":{\"531\":1}}],[\"输入help来查看命令列表\",{\"1\":{\"473\":1}}],[\"输入流会以某种方式保留之后读取的readlimit\",{\"1\":{\"265\":1}}],[\"输入流\",{\"0\":{\"247\":1,\"285\":1}}],[\"输入序列\",{\"1\":{\"97\":1}}],[\"⋅▽w​q^​\",{\"1\":{\"142\":1}}],[\"⋅\",{\"1\":{\"101\":1,\"110\":1}}],[\"η\",{\"1\":{\"99\":2,\"104\":2,\"110\":1,\"155\":1}}],[\"ηk2​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​\",{\"1\":{\"97\":3,\"99\":1,\"104\":1,\"110\":1}}],[\"应该是根据对应的属性的类去找有没有对应的bean\",{\"1\":{\"1173\":1}}],[\"应该是无人机最终停的位置即是部署的最佳位置\",{\"1\":{\"13\":1}}],[\"应该这是\",{\"1\":{\"631\":1}}],[\"应用程序上下文详解\",{\"0\":{\"1315\":1}}],[\"应用程序上下文\",{\"0\":{\"1314\":1}}],[\"应用程序模块无法访问这些类\",{\"1\":{\"463\":1}}],[\"应用程序模块\",{\"1\":{\"463\":1}}],[\"应用\",{\"0\":{\"605\":1,\"1093\":1,\"1096\":1}}],[\"应用现有的方法函数作为方法体\",{\"0\":{\"448\":1}}],[\"应用于\",{\"0\":{\"99\":1}}],[\"要想获取factorybean的实现类本身\",{\"1\":{\"1328\":1}}],[\"要更换数据源实现\",{\"1\":{\"1260\":1}}],[\"要等task结束才会输出pppp\",{\"1\":{\"1225\":1}}],[\"要实现aop操作\",{\"1\":{\"1217\":1}}],[\"要实现此功能\",{\"1\":{\"1076\":1}}],[\"要发布事件\",{\"1\":{\"1192\":1}}],[\"要编写监听器\",{\"1\":{\"1191\":1}}],[\"要注册这个类的bean\",{\"1\":{\"1177\":1}}],[\"要注意传参问题\",{\"1\":{\"182\":1}}],[\"要有对应的构造函数或者对应setteacher\",{\"1\":{\"1172\":1}}],[\"要使用aop我们需要先导入一个依赖\",{\"1\":{\"1217\":1}}],[\"要使用依赖注入\",{\"1\":{\"1133\":1}}],[\"要使用抽象类\",{\"1\":{\"375\":1}}],[\"要配置一个bean\",{\"1\":{\"1125\":1}}],[\"要开启日志系统\",{\"1\":{\"951\":1}}],[\"要开启二级缓存\",{\"1\":{\"884\":1}}],[\"要解决这种问题\",{\"1\":{\"1271\":1}}],[\"要解决这种问题也很简单\",{\"1\":{\"841\":1}}],[\"要解决这种问题很简单\",{\"1\":{\"237\":1}}],[\"要去设计存放一个实体的表\",{\"1\":{\"735\":1}}],[\"要保持服务器一直在线\",{\"1\":{\"727\":1}}],[\"要把csrf的输入框也加上\",{\"1\":{\"682\":1}}],[\"要快速使用map\",{\"1\":{\"475\":1}}],[\"要求tomcat版本必须为10以上\",{\"1\":{\"1118\":1}}],[\"要求填写转账人账号名称\",{\"1\":{\"636\":1}}],[\"要求\",{\"0\":{\"504\":1}}],[\"要求设计一个score对象\",{\"1\":{\"437\":1}}],[\"要求g\",{\"1\":{\"98\":1}}],[\"要么就啥都别做\",{\"1\":{\"1266\":1}}],[\"要么就往上一级函数上\",{\"1\":{\"423\":1}}],[\"要么完全不起作用\",{\"1\":{\"1266\":1}}],[\"要么全部不完成\",{\"1\":{\"782\":1}}],[\"要么全部完成\",{\"1\":{\"782\":1}}],[\"要么在当前函数通过\",{\"1\":{\"424\":1}}],[\"要么一直\",{\"1\":{\"424\":1}}],[\"要么自己处理好\",{\"1\":{\"423\":1}}],[\"要创建一个子项目非常简单\",{\"1\":{\"1032\":1}}],[\"要创建一个抽象类的实例对象\",{\"1\":{\"412\":1}}],[\"要创建一个缓冲字节流\",{\"1\":{\"262\":1}}],[\"要是还是没有\",{\"1\":{\"1301\":1}}],[\"要是之前拿到的con是null的话\",{\"1\":{\"1246\":1}}],[\"要是超过等待时间还是没等到\",{\"1\":{\"1246\":1}}],[\"要是有强迫症不能忍受黄标但是又实在想用字段注入\",{\"1\":{\"1175\":1}}],[\"要是由一种更简单的方式就好了\",{\"1\":{\"843\":1}}],[\"要是都不是这个类型还比什么\",{\"1\":{\"373\":1}}],[\"要是扩容之后比最大的大小还大\",{\"1\":{\"182\":1}}],[\"要是扩容之后的大小还没最小的大小大\",{\"1\":{\"182\":1}}],[\"要生成正常使用的\",{\"1\":{\"182\":1}}],[\"要给成员变量设定初始值\",{\"1\":{\"166\":1}}],[\"要在对象创建时进行处理\",{\"1\":{\"166\":1}}],[\"要证明加入baseline成立\",{\"1\":{\"26\":1}}],[\"收钱的\",{\"1\":{\"732\":2}}],[\"收到服务器返回\",{\"1\":{\"720\":1}}],[\"收集collect\",{\"1\":{\"515\":1}}],[\"收集完毕才能进行一次迭代\",{\"1\":{\"101\":1}}],[\"收敛性情况\",{\"1\":{\"116\":1}}],[\"收敛性分析\",{\"0\":{\"98\":1}}],[\"收益最大\",{\"1\":{\"48\":1}}],[\"次且最多匹配\",{\"1\":{\"403\":1}}],[\"次\",{\"1\":{\"403\":4}}],[\"次的观测值\",{\"1\":{\"97\":1}}],[\"次方程根的估计\",{\"1\":{\"97\":1}}],[\"第四步\",{\"1\":{\"1218\":1}}],[\"第四个作用域\",{\"0\":{\"1018\":1}}],[\"第264页\",{\"1\":{\"1042\":1}}],[\"第七版\",{\"1\":{\"1042\":1}}],[\"第三步\",{\"1\":{\"1218\":1}}],[\"第三方框架兼容性\",{\"0\":{\"949\":1}}],[\"第三方网站恶意脚本\",{\"1\":{\"642\":1}}],[\"第三范式\",{\"0\":{\"738\":1}}],[\"第三个参数是读取流中的字节数\",{\"1\":{\"248\":1}}],[\"第一步结束之后\",{\"1\":{\"1318\":1}}],[\"第一步就是配置视图解析器\",{\"1\":{\"559\":1}}],[\"第一次的插入操作确实被回滚了\",{\"1\":{\"1278\":1}}],[\"第一个spring项目\",{\"0\":{\"1118\":1}}],[\"第一个参数只能用数组\",{\"1\":{\"1298\":1}}],[\"第一个参数值存在\",{\"1\":{\"512\":1}}],[\"第一个参数是种子\",{\"1\":{\"478\":1}}],[\"第一个参数排前面\",{\"1\":{\"449\":1}}],[\"第一范式是指数据库的每一列都是不可分割的基本数据项\",{\"1\":{\"736\":1}}],[\"第一范式\",{\"0\":{\"736\":1}}],[\"第一种是singleton\",{\"1\":{\"1129\":1}}],[\"第一种情况和ifpresent是一样的\",{\"1\":{\"480\":1}}],[\"第一种\",{\"1\":{\"94\":1}}],[\"第二步\",{\"1\":{\"1218\":1}}],[\"第二次获取的时候会进行重新查询\",{\"1\":{\"883\":1}}],[\"第二范式要求表中必须存在主键\",{\"1\":{\"737\":1}}],[\"第二范式\",{\"0\":{\"737\":1}}],[\"第二个是\",{\"1\":{\"511\":1}}],[\"第二个参数开启后会续写已有的日志\",{\"1\":{\"920\":1}}],[\"第二个参数值存在\",{\"1\":{\"512\":1}}],[\"第二个参数排前面\",{\"1\":{\"449\":1}}],[\"第二个参数是从给定数组的哪个位置开始放入内容\",{\"1\":{\"248\":1}}],[\"第二种情况是如果为null的情况\",{\"1\":{\"480\":1}}],[\"第二种\",{\"1\":{\"94\":1}}],[\"引导用户访问对应网站执行操作的方式称为\",{\"1\":{\"641\":1}}],[\"引用静态资源\",{\"1\":{\"564\":1}}],[\"引用了一个方法过来\",{\"1\":{\"448\":1}}],[\"引用尾结点\",{\"1\":{\"182\":1}}],[\"引用首结点\",{\"1\":{\"182\":1}}],[\"引言\",{\"0\":{\"93\":1}}],[\"引入允许我们向现有的类添加新的方法或者属性\",{\"1\":{\"1226\":1}}],[\"引入其他配置类\",{\"0\":{\"1168\":1}}],[\"引入两个网络\",{\"1\":{\"142\":1}}],[\"引入\",{\"0\":{\"88\":1,\"110\":1,\"131\":1},\"1\":{\"48\":1,\"312\":1,\"1226\":1}}],[\"引入随机变量后对应的discounted\",{\"1\":{\"39\":1}}],[\"引入discount\",{\"1\":{\"19\":1}}],[\"针对csrf相关校验\",{\"1\":{\"714\":1}}],[\"针对于bean和factorybean分开进行处理\",{\"1\":{\"1321\":1}}],[\"针对于不同类型的配置方式\",{\"1\":{\"1297\":1}}],[\"针对于记住我cookie进行校验\",{\"1\":{\"714\":1}}],[\"针对于string类的方法增强\",{\"0\":{\"488\":1}}],[\"针对于这些特性\",{\"1\":{\"181\":1}}],[\"针对\",{\"1\":{\"92\":1}}],[\"随便什么的路径名称\",{\"1\":{\"1061\":1}}],[\"随便找一个地方添加以下内容\",{\"1\":{\"660\":1}}],[\"随便写就行\",{\"1\":{\"658\":1}}],[\"随时间而变化\",{\"1\":{\"617\":1}}],[\"随时都认为有其他线程在对数据进行修改\",{\"1\":{\"312\":1}}],[\"随着java版本的更新迭代\",{\"1\":{\"1175\":1}}],[\"随着我们项目的开发和改进\",{\"1\":{\"1003\":1}}],[\"随着我们的程序不断变大\",{\"1\":{\"277\":1}}],[\"随着现在的浏览器不断发展\",{\"1\":{\"641\":1}}],[\"随着无人机与用户之间距离和发射功率的变化\",{\"1\":{\"9\":1}}],[\"随机数生成\",{\"1\":{\"431\":1}}],[\"随机int型数字\",{\"1\":{\"228\":1}}],[\"随机变量\",{\"1\":{\"105\":1}}],[\"随机梯度下降\",{\"1\":{\"101\":1}}],[\"随机近似理论与随机梯度下降算法\",{\"0\":{\"92\":1}}],[\"ϵ−greedy\",{\"1\":{\"125\":1}}],[\"ϵ∈\",{\"1\":{\"87\":1}}],[\"ϵ\",{\"1\":{\"87\":2}}],[\"足够长的情况下\",{\"1\":{\"86\":1}}],[\"据目前而言\",{\"1\":{\"84\":1}}],[\"未验证成功的情况下进行匿名登录操作\",{\"1\":{\"714\":1}}],[\"未命名模块默认可以使用其他所有模块提供的类\",{\"1\":{\"468\":1}}],[\"未命名模块只能默认暴露给其他未命名的模块和自动模块\",{\"1\":{\"463\":1}}],[\"未命名模块同样可以访问所有其他模块提供的类\",{\"1\":{\"463\":1}}],[\"未命名模块\",{\"1\":{\"463\":1}}],[\"未能访问\",{\"1\":{\"84\":1}}],[\"未知时的情况\",{\"1\":{\"97\":1}}],[\"未知\",{\"1\":{\"77\":1,\"96\":1,\"166\":1}}],[\"直接开始加载xml文件中的bean定义\",{\"1\":{\"1297\":1}}],[\"直接编写一个测试用例即可\",{\"1\":{\"1288\":1}}],[\"直接编写逻辑\",{\"1\":{\"297\":1}}],[\"直接避免所有并发问题\",{\"1\":{\"1271\":1}}],[\"直接避免了编写大量的servlet来处理请求\",{\"1\":{\"564\":1}}],[\"直接导致两次读取的数据不一致\",{\"1\":{\"1269\":1}}],[\"直接参数得到bean对象\",{\"1\":{\"1259\":1,\"1276\":1}}],[\"直接参数传递实体类\",{\"0\":{\"583\":1}}],[\"直接从容器中就能获取到sqlsessiontemplate\",{\"1\":{\"1256\":1}}],[\"直接抛异常\",{\"1\":{\"1246\":2}}],[\"直接替换掉就可以了\",{\"1\":{\"1175\":1}}],[\"直接替换为新的\",{\"1\":{\"223\":1}}],[\"直接new创建对应的对象就可以了\",{\"1\":{\"1132\":1}}],[\"直接右键点击即可创建\",{\"1\":{\"1119\":1}}],[\"直接先使用\",{\"1\":{\"1109\":1}}],[\"直接转交给get请求处理\",{\"1\":{\"1083\":1}}],[\"直接转换打印一气呵成\",{\"1\":{\"454\":1}}],[\"直接跳转到网站的首页\",{\"1\":{\"1082\":1}}],[\"直接搜索lombok即可\",{\"1\":{\"1008\":1}}],[\"直接填写字符串即可\",{\"1\":{\"908\":1}}],[\"直接填写访问路径\",{\"1\":{\"561\":1}}],[\"直接清除所有缓存\",{\"1\":{\"887\":1}}],[\"直接得到用户所属的所有书籍信息\",{\"1\":{\"853\":1}}],[\"直接获取实现类\",{\"1\":{\"842\":1}}],[\"直接获取这些图片然后保存到本地吧\",{\"1\":{\"490\":1}}],[\"直接运行test2\",{\"1\":{\"1283\":1}}],[\"直接运行会产生报错\",{\"1\":{\"824\":1}}],[\"直接运行即可\",{\"1\":{\"824\":1}}],[\"直接这样查询会得到两张表的笛卡尔积\",{\"1\":{\"767\":1}}],[\"直接调用传入的filterchain的dofilter方法\",{\"1\":{\"711\":1}}],[\"直接继续使用之前登陆的身份\",{\"1\":{\"686\":1}}],[\"直接继承\",{\"0\":{\"1160\":1}}],[\"直接继承过来的方法\",{\"1\":{\"204\":1}}],[\"直接继承自前面介绍的\",{\"1\":{\"181\":1}}],[\"直接403\",{\"1\":{\"660\":1}}],[\"直接明文存储并不好\",{\"1\":{\"659\":1}}],[\"直接创个新的\",{\"1\":{\"625\":1}}],[\"直接创建一个新的httpclient\",{\"1\":{\"490\":1}}],[\"直接创建一个匿名的接口实现类\",{\"1\":{\"412\":1}}],[\"直接创建文件对象\",{\"1\":{\"255\":1}}],[\"直接创建新的结点连在后面\",{\"1\":{\"216\":1}}],[\"直接创建就行了\",{\"1\":{\"182\":1}}],[\"直接访问第一个学生的名称\",{\"1\":{\"610\":1}}],[\"直接添加后续动作\",{\"1\":{\"1220\":1}}],[\"直接添加httpservletrequest为形式参数即可\",{\"1\":{\"582\":1}}],[\"直接添加注解即可\",{\"1\":{\"561\":1}}],[\"直接添加open关键字开放整个模块的反射权限\",{\"1\":{\"466\":1}}],[\"直接读取对象的name属性\",{\"1\":{\"1203\":1}}],[\"直接读取实体类\",{\"0\":{\"826\":1}}],[\"直接读取html编写的页面\",{\"1\":{\"558\":1}}],[\"直接读取到char\",{\"1\":{\"253\":1}}],[\"直接把consolehandler的默认formatter配置为我们自己的类\",{\"1\":{\"947\":1}}],[\"直接把字段写在括号中\",{\"1\":{\"501\":1}}],[\"直接把要close的变量放进来就行\",{\"1\":{\"490\":1}}],[\"直接写一起\",{\"1\":{\"1231\":1}}],[\"直接写变量名字\",{\"1\":{\"499\":1}}],[\"直接写每个状态的名字即可\",{\"1\":{\"378\":1}}],[\"直接定位\",{\"1\":{\"490\":1}}],[\"直接一句搞定\",{\"1\":{\"475\":1}}],[\"直接输入\",{\"1\":{\"473\":1}}],[\"直接缩写\",{\"1\":{\"451\":1}}],[\"直接指定一手\",{\"1\":{\"449\":1}}],[\"直接指定值和大小\",{\"1\":{\"392\":1}}],[\"直接作为接口中抽象方法的实现\",{\"1\":{\"415\":2}}],[\"直接判断引用的对象是不是teacher类型\",{\"1\":{\"376\":1}}],[\"直接判断是否为test\",{\"1\":{\"365\":2}}],[\"直接判断是否为这个类型\",{\"1\":{\"343\":1}}],[\"直接int\",{\"1\":{\"376\":1}}],[\"直接==\",{\"1\":{\"373\":1}}],[\"直接使用value可以直接传入一个具体值\",{\"1\":{\"1133\":1}}],[\"直接使用copy方法完成转换\",{\"1\":{\"1074\":1}}],[\"直接使用lombok\",{\"1\":{\"826\":1}}],[\"直接使用hasrole方法判断是否包含某个角色\",{\"1\":{\"695\":1}}],[\"直接使用httpservletresponse\",{\"1\":{\"620\":1}}],[\"直接使用这种方式就能快速完成了\",{\"1\":{\"664\":1}}],[\"直接使用integer为我们通过好的求和方法\",{\"1\":{\"415\":1}}],[\"直接使用就可以\",{\"1\":{\"278\":1}}],[\"直接使用即可\",{\"1\":{\"277\":1}}],[\"直接做参数\",{\"1\":{\"255\":1}}],[\"直接在mapper中添加\",{\"1\":{\"835\":1}}],[\"直接在navicat中执行以下查询\",{\"1\":{\"662\":1}}],[\"直接在方法中创建局部内部类\",{\"1\":{\"410\":1}}],[\"直接在try\",{\"1\":{\"247\":1}}],[\"直接在类中定义变量\",{\"1\":{\"161\":1}}],[\"直接处理原始字节数据\",{\"1\":{\"245\":1}}],[\"直接构造一个默认大小为16负载因子0\",{\"1\":{\"224\":1}}],[\"直接给予一个比较规则即可\",{\"1\":{\"219\":1}}],[\"直接将本次请求转发给其他servlet进行处理\",{\"1\":{\"1083\":1}}],[\"直接将字符串的666\",{\"1\":{\"385\":1}}],[\"直接将数据读取为任意基本数据类型\",{\"1\":{\"286\":1}}],[\"直接将新的容量变成旧的阈值\",{\"1\":{\"217\":1}}],[\"直接将对应位置上的元素替换为给定元素\",{\"1\":{\"181\":1}}],[\"直接结束\",{\"1\":{\"216\":2}}],[\"直接返回beaninstance作为结果\",{\"1\":{\"1300\":1}}],[\"直接返回\",{\"1\":{\"1093\":1}}],[\"直接返回true\",{\"1\":{\"193\":1}}],[\"直接返回指针所指元素\",{\"1\":{\"190\":1}}],[\"直接认为就是要删除的对象\",{\"1\":{\"182\":1}}],[\"直接安排了\",{\"1\":{\"171\":1}}],[\"直接赋值\",{\"1\":{\"166\":1}}],[\"直接估计的是\",{\"1\":{\"120\":1}}],[\"直接通过applicationeventpublisher的publishevent方法发布事件\",{\"1\":{\"1192\":1}}],[\"直接通过registration配置multipart相关配置\",{\"1\":{\"619\":1}}],[\"直接通过\",{\"1\":{\"94\":1}}],[\"直接\",{\"1\":{\"82\":1,\"461\":1,\"1246\":1}}],[\"直到客户端主动关闭连接\",{\"1\":{\"719\":1}}],[\"直到有一方主动关闭连接\",{\"1\":{\"1042\":1}}],[\"直到有一个能把\",{\"1\":{\"560\":1}}],[\"直到有客户端连接为止\",{\"1\":{\"719\":1,\"720\":1}}],[\"直到对应的线程执行resume\",{\"1\":{\"313\":1}}],[\"直到读取完成为止\",{\"1\":{\"251\":1}}],[\"直到完成每一个元素的遍历\",{\"1\":{\"188\":1}}],[\"直到设置的收敛条件为止\",{\"1\":{\"66\":1}}],[\"直到各个簇的成员没有太大变化\",{\"1\":{\"13\":1}}],[\"才可以被通知\",{\"1\":{\"1231\":1}}],[\"才可以顺利地到达对应的servlet\",{\"1\":{\"1101\":1}}],[\"才可以访问一些页面\",{\"1\":{\"1101\":1}}],[\"才可以进行数据交换\",{\"1\":{\"1042\":1}}],[\"才不会重新读取\",{\"1\":{\"884\":1}}],[\"才会作为事务的一部分\",{\"1\":{\"1282\":1}}],[\"才会以事务的方式执行\",{\"1\":{\"1282\":1}}],[\"才会到达我们的servlet中\",{\"1\":{\"1103\":1}}],[\"才会到达对应的servlet进行处理\",{\"1\":{\"1103\":1}}],[\"才会正常通过\",{\"1\":{\"990\":1}}],[\"才会请求数据库\",{\"1\":{\"885\":1}}],[\"才会从一级缓存中获取\",{\"1\":{\"885\":1}}],[\"才会保存在二级缓存\",{\"1\":{\"884\":1}}],[\"才会初始化外部类\",{\"1\":{\"411\":1}}],[\"才会让appclassloader来加载\",{\"1\":{\"355\":1}}],[\"才会转换\",{\"1\":{\"318\":1}}],[\"才会依次进行\",{\"1\":{\"228\":1}}],[\"才能调用原方法\",{\"1\":{\"1231\":1}}],[\"才能与servlet相拥\",{\"1\":{\"1101\":1}}],[\"才能理解\",{\"1\":{\"1086\":1}}],[\"才能去\",{\"1\":{\"408\":1}}],[\"才能用这三个方法\",{\"1\":{\"318\":1}}],[\"才能进行比较\",{\"1\":{\"373\":1}}],[\"才能进行\",{\"1\":{\"82\":1}}],[\"才正确\",{\"1\":{\"312\":1}}],[\"才认为这两个元素是相同的\",{\"1\":{\"241\":1}}],[\"才是灵魂\",{\"1\":{\"224\":1}}],[\"才进行替换\",{\"1\":{\"223\":1}}],[\"才进行更新\",{\"1\":{\"82\":1}}],[\"等同于旧版本的\",{\"1\":{\"1291\":1}}],[\"等\",{\"0\":{\"1171\":1},\"1\":{\"603\":1,\"843\":1,\"1272\":1}}],[\"等操作函数和代码\",{\"1\":{\"1059\":1}}],[\"等操作\",{\"1\":{\"528\":1}}],[\"等于比较完就强制转换\",{\"1\":{\"499\":1}}],[\"等级\",{\"1\":{\"495\":1}}],[\"等待打包完成即可得到我们的jar文件\",{\"1\":{\"1037\":1}}],[\"等待结束\",{\"1\":{\"318\":1}}],[\"等待态的线程变为\",{\"1\":{\"318\":1}}],[\"等待\",{\"1\":{\"318\":1}}],[\"等待下一次获得cpu资源\",{\"1\":{\"300\":1}}],[\"等待通知\",{\"1\":{\"299\":1}}],[\"等方法来打印日志\",{\"1\":{\"1260\":1}}],[\"等方法\",{\"1\":{\"241\":1,\"501\":1}}],[\"等价于value\",{\"1\":{\"569\":1}}],[\"等价于\",{\"1\":{\"216\":1,\"403\":6}}],[\"等候时间过长\",{\"1\":{\"82\":1}}],[\"等均未知\",{\"1\":{\"75\":1}}],[\"缺点\",{\"1\":{\"82\":1}}],[\"估计了q\",{\"1\":{\"82\":1}}],[\"估计中\",{\"1\":{\"81\":2}}],[\"高等数学\",{\"1\":{\"1209\":2}}],[\"高内聚\",{\"1\":{\"1117\":1}}],[\"高耦合度带来的缺点是很明显的\",{\"1\":{\"1116\":1}}],[\"高于等于此级别的所有日志都会被打印\",{\"1\":{\"912\":1}}],[\"高智文\",{\"1\":{\"643\":1}}],[\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问\",{\"1\":{\"311\":1}}],[\"高效地更新\",{\"0\":{\"82\":1}}],[\"高度h=hn​\",{\"1\":{\"11\":1}}],[\"高度的上界是最大发射功率pmax​的函数\",{\"1\":{\"9\":1}}],[\"都别学java了\",{\"1\":{\"1223\":1}}],[\"都像是去厨房端菜到客人桌上一样\",{\"1\":{\"871\":1}}],[\"都需要一定的时间开销\",{\"1\":{\"871\":1}}],[\"都需要编写大量的代码\",{\"1\":{\"816\":1}}],[\"都需要有多个\",{\"1\":{\"84\":1}}],[\"都不再继续\",{\"1\":{\"600\":1}}],[\"都支持lambda表达式\",{\"1\":{\"447\":1}}],[\"都会监听到这个事件发生了\",{\"1\":{\"1192\":1}}],[\"都会直接报错\",{\"1\":{\"1181\":1}}],[\"都会由我们自己定义的servlet处理\",{\"1\":{\"1061\":1}}],[\"都会单独创建一个线程来处理执行\",{\"1\":{\"1056\":1}}],[\"都会创建一个线程执行一次service方法\",{\"1\":{\"1055\":1}}],[\"都会创建一个新的对象\",{\"1\":{\"986\":1}}],[\"都会执行一次这里的准备工作\",{\"1\":{\"985\":1}}],[\"都会关联到这个二级缓存\",{\"1\":{\"884\":1}}],[\"都会使用反射进行一次赋值\",{\"1\":{\"841\":1}}],[\"都会进入到springsecurity为我们提供的一个默认登录页面\",{\"1\":{\"652\":1}}],[\"都会经过dispatcherservlet进行处理\",{\"1\":{\"558\":1}}],[\"都会抛出\",{\"1\":{\"528\":1}}],[\"都会对应创建类似于setter的方法\",{\"1\":{\"525\":1}}],[\"都会在构建器中创建对应属性\",{\"1\":{\"525\":1}}],[\"都会在最后执行任务\",{\"1\":{\"424\":1}}],[\"都会将指针后移一位\",{\"1\":{\"188\":1}}],[\"都可以获取到\",{\"1\":{\"1125\":1}}],[\"都可以访问此servlet\",{\"1\":{\"1061\":1}}],[\"都可以通过httpservletrequest对象来获取\",{\"1\":{\"1057\":1}}],[\"都可以通过实现此接口\",{\"1\":{\"787\":1}}],[\"都可以从servletrequest对象中获取\",{\"1\":{\"1056\":1}}],[\"都可以直接进行方法引用\",{\"1\":{\"415\":1}}],[\"都可以使用getannotations\",{\"1\":{\"365\":1}}],[\"都可以使用\",{\"1\":{\"193\":1}}],[\"都在\",{\"1\":{\"386\":1}}],[\"都能调用它的任意一个方法和属性\",{\"1\":{\"336\":1}}],[\"都能够知道这个类所有的属性和方法\",{\"1\":{\"336\":1}}],[\"都能够容纳一组元素\",{\"1\":{\"179\":1}}],[\"都只能获取到当前线程所属的变量\",{\"1\":{\"319\":1}}],[\"都有学习的能力\",{\"1\":{\"376\":1}}],[\"都有一个获取原始类型class方法\",{\"1\":{\"340\":1}}],[\"都有一个interrupt\",{\"1\":{\"301\":1}}],[\"都有自己的内存空间\",{\"1\":{\"295\":1}}],[\"都有可选择的动作\",{\"1\":{\"19\":1}}],[\"都是由\",{\"1\":{\"1328\":1}}],[\"都是由于需要处理aop设计的\",{\"1\":{\"1310\":1}}],[\"都是非常优秀的数据源实现\",{\"1\":{\"1260\":1}}],[\"都是采用池化技术\",{\"1\":{\"1242\":1}}],[\"都是用于获取连接的\",{\"1\":{\"1242\":1}}],[\"都是用于拦截一些非法请求\",{\"1\":{\"593\":1}}],[\"都是支持这样编写的\",{\"1\":{\"1136\":1}}],[\"都是storehousemanage的候选关键字\",{\"1\":{\"739\":1}}],[\"都是string类型的一个实例对象\",{\"1\":{\"401\":1}}],[\"都是hello\",{\"1\":{\"511\":1}}],[\"都是可以支持泛型的\",{\"1\":{\"439\":1}}],[\"都是始终是那一个对象\",{\"1\":{\"337\":1}}],[\"都是根据\",{\"1\":{\"241\":1}}],[\"都是直接使用new关键字就能直接搞定了\",{\"1\":{\"166\":1}}],[\"都是最大的\",{\"1\":{\"148\":1}}],[\"都记录\",{\"1\":{\"81\":1}}],[\"仅在编译\",{\"1\":{\"1016\":1}}],[\"仅第一次需要\",{\"1\":{\"687\":1}}],[\"仅首次启动时创建一个新的用户用于测试\",{\"1\":{\"664\":1}}],[\"仅当request请求头中的\",{\"1\":{\"577\":1}}],[\"仅支持接口\",{\"1\":{\"414\":1}}],[\"仅仅引用方法\",{\"1\":{\"452\":1}}],[\"仅仅是几个很小的功能\",{\"1\":{\"540\":1}}],[\"仅仅是se中就有700多个\",{\"1\":{\"422\":1}}],[\"仅仅是检查\",{\"1\":{\"361\":1}}],[\"仅仅编译器阶段\",{\"1\":{\"361\":1}}],[\"仅使用默认类加载器\",{\"1\":{\"337\":1}}],[\"仅获取队首元素\",{\"1\":{\"200\":1}}],[\"仅适用于通配符\",{\"1\":{\"172\":1}}],[\"仅用作估计\",{\"1\":{\"81\":1}}],[\"仅需要考虑无人机的7个移动方向即可\",{\"1\":{\"14\":1}}],[\"有空闲的连接时\",{\"1\":{\"1246\":1}}],[\"有可能是直接创建的新的\",{\"1\":{\"1246\":1}}],[\"有可能是从空闲列表中得到\",{\"1\":{\"1246\":1}}],[\"有可能整个连接池就是一个类似于栈的集合类型结构实现的\",{\"1\":{\"1245\":1}}],[\"有可能会使得这个类的一些结构发生变化\",{\"1\":{\"289\":1}}],[\"有着特殊的支持\",{\"1\":{\"1136\":1}}],[\"有着不同程度的访问限制\",{\"1\":{\"278\":1}}],[\"有2种方式\",{\"1\":{\"1135\":1}}],[\"有一个session被创建了\",{\"1\":{\"1105\":1}}],[\"有两种方式配置\",{\"1\":{\"1010\":1}}],[\"有两种不同的方式加载关联\",{\"1\":{\"849\":1}}],[\"有助于优化性能\",{\"1\":{\"841\":1}}],[\"有助于提高性能\",{\"1\":{\"835\":1}}],[\"有助于保护cookie不被跨站脚本攻击窃取或篡改\",{\"1\":{\"642\":1}}],[\"有很多\",{\"1\":{\"708\":1}}],[\"有群主\",{\"1\":{\"691\":1}}],[\"有些操作可能比较特殊\",{\"1\":{\"887\":1}}],[\"有些太麻烦了\",{\"1\":{\"684\":1}}],[\"有些时候我们可能需要对测试用例进行进一步的分层\",{\"1\":{\"988\":1}}],[\"有些时候我们可能需要控制某些测试案例的顺序\",{\"1\":{\"987\":1}}],[\"有些时候我们可能需要配置各种条件来执行某些测试案例\",{\"1\":{\"975\":1}}],[\"有些时候我们可能需要生成一个空的集合类返回\",{\"1\":{\"236\":1}}],[\"有些时候我们可以会打印一些比较重要的日志信息\",{\"1\":{\"909\":1}}],[\"有些时候并不需要创建那么多对象\",{\"1\":{\"384\":1}}],[\"有些时候\",{\"1\":{\"165\":1,\"667\":1,\"843\":1,\"862\":1,\"960\":1,\"1140\":1}}],[\"有机会我们会分享如何防范此类攻击\",{\"1\":{\"643\":1}}],[\"有运算规则\",{\"1\":{\"521\":1}}],[\"有起始值\",{\"1\":{\"521\":1}}],[\"有且仅有一个抽象方法\",{\"1\":{\"447\":1}}],[\"有了session之后\",{\"1\":{\"1101\":1}}],[\"有了springmvc之后\",{\"1\":{\"558\":1}}],[\"有了\",{\"1\":{\"343\":1}}],[\"有哪些方法\",{\"1\":{\"336\":1}}],[\"有时我们可能也需要对多个输入参数进行测试\",{\"1\":{\"991\":1}}],[\"有时候为了方便\",{\"1\":{\"979\":1}}],[\"有时候我们的方法中可能会出现一些与成员变量重名的变量\",{\"1\":{\"164\":1}}],[\"有时会遇到这样一个很麻烦的问题\",{\"1\":{\"283\":1}}],[\"有点混乱\",{\"1\":{\"277\":1}}],[\"有表示\",{\"1\":{\"155\":1}}],[\"有\",{\"1\":{\"79\":1}}],[\"有关详细实现过程\",{\"1\":{\"1310\":1}}],[\"有关更多详细语法教程\",{\"1\":{\"1211\":1}}],[\"有关spring和jakartaee的渊源\",{\"1\":{\"1176\":1}}],[\"有关servletcontext其他的内容\",{\"1\":{\"1086\":1}}],[\"有关security的基本功能\",{\"1\":{\"699\":1}}],[\"有关mybatis的基本使用\",{\"1\":{\"904\":1}}],[\"有关mybatis这一部分的原理\",{\"1\":{\"842\":1}}],[\"有关java\",{\"1\":{\"485\":1}}],[\"有关注解我们会在最后一章进行介绍\",{\"1\":{\"373\":1}}],[\"有关锁的内容\",{\"1\":{\"372\":1}}],[\"有关线程中断相关问题\",{\"1\":{\"299\":1}}],[\"有关\",{\"1\":{\"48\":1,\"152\":1}}],[\"迭代器的使用是一次性的\",{\"1\":{\"191\":1}}],[\"迭代器\",{\"0\":{\"187\":1,\"190\":1},\"1\":{\"187\":1}}],[\"迭代器我们会在下一个部分讲解\",{\"1\":{\"181\":2}}],[\"迭代\",{\"1\":{\"79\":1}}],[\"≈▽θ​lnπ\",{\"1\":{\"155\":1}}],[\"≈vπ​\",{\"1\":{\"131\":1}}],[\"≈n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"≈n1​i=1∑n​g\",{\"1\":{\"78\":1}}],[\"≈xˉ\",{\"1\":{\"94\":1}}],[\"≈xˉ=n1​j=1∑n​xj​\",{\"1\":{\"75\":1}}],[\"样本\",{\"1\":{\"142\":1}}],[\"样本必须是独立同分布\",{\"1\":{\"75\":1}}],[\"样本采样\",{\"1\":{\"75\":1}}],[\"蒙特卡洛方法\",{\"0\":{\"75\":1}}],[\"就已经学完了\",{\"1\":{\"1291\":1}}],[\"就new一个新的\",{\"1\":{\"1246\":1}}],[\"就非常方便\",{\"1\":{\"1231\":1}}],[\"就能更加方便的去使用mapper\",{\"1\":{\"1265\":1}}],[\"就能进行一些简单的处理了\",{\"1\":{\"1211\":1}}],[\"就能直接完成自动装配\",{\"1\":{\"1173\":1}}],[\"就能够收到服务器发来的响应内容了\",{\"1\":{\"1058\":1}}],[\"就能够很好地解决缓存一致性问题\",{\"1\":{\"888\":1}}],[\"就能够直接将查询结果转化为一个实体类\",{\"1\":{\"826\":1}}],[\"就能够解决掉我们之前长长的一串代码\",{\"1\":{\"810\":1}}],[\"就根据参数数量来区分就行\",{\"1\":{\"1135\":1}}],[\"就被创建\",{\"1\":{\"1129\":1}}],[\"就被tomcat服务器封装为了一个servletrequest对象\",{\"1\":{\"1056\":1}}],[\"就无法使用class来进行区分了\",{\"1\":{\"1127\":1}}],[\"就无法再进行回滚了\",{\"1\":{\"782\":1}}],[\"就出现了几个新的类加载器\",{\"1\":{\"1109\":1}}],[\"就相当于添加了很多堵墙\",{\"1\":{\"1101\":1}}],[\"就属于同一个会话\",{\"1\":{\"1094\":1}}],[\"就获取不了共享参数了\",{\"1\":{\"1083\":1}}],[\"就行\",{\"1\":{\"1076\":1}}],[\"就行了\",{\"1\":{\"224\":2,\"422\":2}}],[\"就把所请求的文档作为响应报文返回给客户\",{\"1\":{\"1042\":1}}],[\"就存在大量的可选依赖\",{\"1\":{\"1025\":1}}],[\"就存放在resultset中\",{\"1\":{\"791\":1}}],[\"就算我们切换老师的实现为另一个类\",{\"1\":{\"1133\":1}}],[\"就算像这样进行了修改\",{\"1\":{\"841\":1}}],[\"就算其他项目将此项目作为依赖也无法使用\",{\"1\":{\"464\":1}}],[\"就依次执行内置的filter\",{\"1\":{\"708\":1}}],[\"就一直卡这里了\",{\"1\":{\"660\":1}}],[\"就按照倒序执行处理后方法\",{\"1\":{\"600\":1}}],[\"就用它来配置servlet容器\",{\"1\":{\"550\":1}}],[\"就没有这个\",{\"1\":{\"528\":1}}],[\"就没办法了\",{\"1\":{\"386\":1}}],[\"就返回connection对象了\",{\"1\":{\"1244\":1}}],[\"就返回\",{\"1\":{\"520\":3}}],[\"就类似于使用\",{\"1\":{\"513\":1}}],[\"就很好地解决了我们上面所提到的问题\",{\"1\":{\"1109\":1}}],[\"就很头疼\",{\"1\":{\"500\":1}}],[\"就很蠢\",{\"1\":{\"480\":1}}],[\"就好像默认其是\",{\"1\":{\"438\":1}}],[\"就好了\",{\"1\":{\"63\":1}}],[\"就明确指出了在运行的时候会出现的异常\",{\"1\":{\"421\":1}}],[\"就近原则\",{\"1\":{\"408\":1}}],[\"就表示这个是一个数组类型\",{\"1\":{\"392\":1}}],[\"就支持像这样编写\",{\"1\":{\"384\":1}}],[\"就连被定义为final字段的值都能强行修改\",{\"1\":{\"350\":1}}],[\"就保证三个线程的锁是一致的\",{\"1\":{\"312\":1}}],[\"就必须确保这样做是安全的\",{\"1\":{\"349\":1}}],[\"就必须等待当前同步代码块的内容执行完毕\",{\"1\":{\"312\":1}}],[\"就必须运行两个进程\",{\"1\":{\"295\":1}}],[\"就会有这两个关键的后置处理器放在容器中\",{\"1\":{\"1318\":1}}],[\"就会一直向下直到servlet\",{\"1\":{\"1103\":1}}],[\"就会重新读取\",{\"1\":{\"884\":1}}],[\"就会向下移动一行\",{\"1\":{\"797\":1}}],[\"就会被拦截并自动退回到登录界面\",{\"1\":{\"692\":1}}],[\"就会转接到此控制器执行\",{\"1\":{\"605\":1}}],[\"就会根据设置的值进行创建实体对象\",{\"1\":{\"525\":1}}],[\"就会直接\",{\"1\":{\"500\":1}}],[\"就会直接交给jvm进行处理\",{\"1\":{\"424\":1}}],[\"就会报错\",{\"1\":{\"413\":1,\"1181\":1}}],[\"就会得到不同的对象了\",{\"1\":{\"384\":1}}],[\"就会结束循环\",{\"1\":{\"324\":1}}],[\"就会出现问题\",{\"1\":{\"311\":1}}],[\"就会暂时处于休眠状态\",{\"1\":{\"299\":1}}],[\"就可能导致各自的高速缓存数据不一致\",{\"1\":{\"311\":1}}],[\"就可以获取到bean的实例了\",{\"1\":{\"1327\":1}}],[\"就可以有效地避免不可重复读的问题\",{\"1\":{\"1270\":1}}],[\"就可以向ioc容器去索要\",{\"1\":{\"1119\":1}}],[\"就可以通过初始化参数来给予servlet\",{\"1\":{\"1085\":1}}],[\"就可以通过set中提供的方法\",{\"1\":{\"797\":1}}],[\"就可以快速完成servlet的编写\",{\"1\":{\"1059\":1}}],[\"就可以快速获取\",{\"1\":{\"610\":1}}],[\"就可以正常显示中文了\",{\"1\":{\"1047\":1}}],[\"就可以正常使用logger了\",{\"1\":{\"461\":1}}],[\"就可以创建一个自定义的日志格式处理逻辑了\",{\"1\":{\"944\":1}}],[\"就可以创造出不同的对象\",{\"1\":{\"524\":1}}],[\"就可以编写为这种形式\",{\"1\":{\"936\":1}}],[\"就可以直接拿到bean的实例\",{\"1\":{\"1300\":1}}],[\"就可以直接添加这个注解\",{\"1\":{\"1188\":1}}],[\"就可以直接帮助用户跳转到用户首页了\",{\"1\":{\"1082\":1}}],[\"就可以直接执行当前类中所有的测试案例\",{\"1\":{\"959\":1}}],[\"就可以直接执行我们的测试方法了\",{\"1\":{\"959\":1}}],[\"就可以直接在二级缓存中命中了\",{\"1\":{\"884\":1}}],[\"就可以直接从缓存中读取\",{\"1\":{\"882\":1}}],[\"就可以直接就创出对象\",{\"1\":{\"412\":1}}],[\"就可以解决这样的问题\",{\"1\":{\"810\":1}}],[\"就可以访问某个路径\",{\"1\":{\"691\":1}}],[\"就可以访问到我们之前的界面了\",{\"1\":{\"658\":1}}],[\"就可以看到正常显示的登录界面了\",{\"1\":{\"681\":1}}],[\"就可以进行数据库操作\",{\"1\":{\"1242\":1}}],[\"就可以进行一定操作\",{\"1\":{\"161\":1}}],[\"就可以进入到自定义的登录界面了\",{\"1\":{\"680\":1}}],[\"就可以展示前端模版页面了\",{\"1\":{\"679\":1}}],[\"就可以很方便地实现重定向\",{\"1\":{\"587\":1}}],[\"就可以配套使用\",{\"1\":{\"522\":1}}],[\"就可以让客户端帮助我们发送出去了\",{\"1\":{\"490\":1}}],[\"就可以简写为\",{\"1\":{\"447\":1}}],[\"就可以使用多重异常捕获\",{\"1\":{\"424\":1}}],[\"就可以使用tostring转换为字符串了\",{\"1\":{\"402\":1}}],[\"就可以使用非public方法了\",{\"1\":{\"348\":1}}],[\"就可以表示这个是哪一个包里的类了\",{\"1\":{\"277\":1}}],[\"就可以轻松地通过键找到对应的映射值\",{\"1\":{\"212\":1}}],[\"就可以执行定义好的方法了\",{\"1\":{\"162\":1}}],[\"就开始按顺序执行我们给定的程序\",{\"1\":{\"299\":1}}],[\"就需要b\",{\"1\":{\"1301\":1}}],[\"就需要先将这个工厂类注册为一个bean\",{\"1\":{\"1159\":1}}],[\"就需要用到javascript来帮助我们\",{\"1\":{\"1076\":1}}],[\"就需要用到java多线程框架\",{\"1\":{\"295\":1}}],[\"就需要给出列名\",{\"1\":{\"754\":1}}],[\"就需要调用\",{\"1\":{\"691\":1}}],[\"就需要将页面中的数据全部渲染到view中\",{\"1\":{\"558\":1}}],[\"就需要将这三种类型都进行明确指定\",{\"1\":{\"438\":1}}],[\"就需要对异常进行捕获\",{\"1\":{\"424\":1}}],[\"就需要注意了\",{\"1\":{\"277\":1}}],[\"就需要新的算法进行解决\",{\"1\":{\"96\":1}}],[\"就像死锁那种感觉\",{\"1\":{\"1301\":1}}],[\"就像类的继承一样\",{\"1\":{\"1298\":1}}],[\"就像产生幻觉一样\",{\"1\":{\"1271\":1}}],[\"就像一个工具库一样\",{\"1\":{\"1118\":1}}],[\"就像一个团队\",{\"1\":{\"1116\":1}}],[\"就像之前的jdbc一样\",{\"1\":{\"1053\":1}}],[\"就像之前使用thymeleaf那样\",{\"1\":{\"541\":1}}],[\"就像lol一样\",{\"1\":{\"1003\":1}}],[\"就像下面这个图一样\",{\"1\":{\"930\":1}}],[\"就像下面这样\",{\"1\":{\"274\":1}}],[\"就像包名一样\",{\"1\":{\"930\":1}}],[\"就像是我们之前使用association和collection那样\",{\"1\":{\"901\":1}}],[\"就像我们之前在配置文件中也要将其注册为bean那样\",{\"1\":{\"1233\":1}}],[\"就像我们之前在使用constrator标签一样\",{\"1\":{\"900\":1}}],[\"就像我们的项目\",{\"1\":{\"1015\":1}}],[\"就像我们遍历数组那样\",{\"1\":{\"188\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"782\":1}}],[\"就像hash表一样\",{\"1\":{\"780\":1}}],[\"就像使用普通类型那样\",{\"1\":{\"378\":1}}],[\"就像注释一样\",{\"1\":{\"360\":1}}],[\"就像在这个类定义的方法一样\",{\"1\":{\"278\":1}}],[\"就像你进了公司\",{\"1\":{\"224\":1}}],[\"就跟我们之前的顺序表插入是一样的\",{\"1\":{\"181\":1}}],[\"就不用这样了\",{\"1\":{\"1187\":1}}],[\"就不会被加载\",{\"1\":{\"1109\":1}}],[\"就不会执行接口的默认方法\",{\"1\":{\"376\":1}}],[\"就不再是通过预编译\",{\"1\":{\"831\":1}}],[\"就不需要我们再次进行登录操作了\",{\"1\":{\"686\":1}}],[\"就不需要是\",{\"1\":{\"125\":1}}],[\"就不分这么详细了\",{\"1\":{\"552\":1}}],[\"就不一定需要实现\",{\"1\":{\"375\":1}}],[\"就不是正常的\",{\"1\":{\"343\":1}}],[\"就不太可行\",{\"1\":{\"134\":1}}],[\"就不能确保所选择的\",{\"1\":{\"84\":1}}],[\"就直接去更新策略\",{\"1\":{\"82\":1}}],[\"就是经过后置处理器返回的结果\",{\"1\":{\"1306\":1}}],[\"就是在一开始就创建好n个连接\",{\"1\":{\"1242\":1}}],[\"就是在运行时进行类型检查\",{\"1\":{\"237\":1}}],[\"就是这个student类\",{\"1\":{\"1218\":1}}],[\"就是applicationeventpublisher的实现类\",{\"1\":{\"1192\":1}}],[\"就是单纯的new一个对象出来\",{\"1\":{\"1177\":1}}],[\"就是用来处理这种问题的\",{\"1\":{\"1094\":1}}],[\"就是用于分割的\",{\"1\":{\"277\":1}}],[\"就是我们的首页\",{\"1\":{\"1093\":1}}],[\"就是代表当前servlet的访问路径\",{\"1\":{\"1061\":1}}],[\"就是写到里面\",{\"1\":{\"988\":1}}],[\"就是inner标签的一个属性\",{\"1\":{\"817\":1}}],[\"就是记住我\",{\"1\":{\"685\":1}}],[\"就是黑客把他的jsessionid直接给你\",{\"1\":{\"642\":1}}],[\"就是运算规则\",{\"1\":{\"521\":1}}],[\"就是一个getter\",{\"1\":{\"1203\":1}}],[\"就是一个典型的web应用服务器软件\",{\"1\":{\"1047\":1}}],[\"就是一个已经实现了抽象方法的对象\",{\"1\":{\"412\":1}}],[\"就是一种一对一的联系\",{\"1\":{\"733\":1}}],[\"就是一次遍历执行多个操作\",{\"1\":{\"515\":1}}],[\"就是后面的unaryoperator的参数i一开始的值\",{\"1\":{\"478\":1}}],[\"就是哪个模块用了什么依赖\",{\"1\":{\"465\":1}}],[\"就是说如果这个函数结束时有异常\",{\"1\":{\"423\":1}}],[\"就是内存溢出错误\",{\"1\":{\"421\":1}}],[\"就是将表本身和表进行笛卡尔积计算\",{\"1\":{\"768\":1}}],[\"就是将一个已实现的方法\",{\"1\":{\"415\":1}}],[\"就是将当前集合变成当前集合与给定集合的并集\",{\"1\":{\"180\":1}}],[\"就是创建在内部的类\",{\"1\":{\"407\":1}}],[\"就是专门用于构造字符串的\",{\"1\":{\"402\":1}}],[\"就是0\",{\"1\":{\"392\":1}}],[\"就是null\",{\"1\":{\"392\":1}}],[\"就是精确到最后一位时\",{\"1\":{\"386\":1}}],[\"就是生产者在不断的生产\",{\"1\":{\"331\":1}}],[\"就是使用的对象锁\",{\"1\":{\"312\":1}}],[\"就是使用的类锁\",{\"1\":{\"312\":1}}],[\"就是类锁\",{\"1\":{\"312\":1}}],[\"就是对象锁\",{\"1\":{\"312\":1}}],[\"就是域名\",{\"1\":{\"277\":1}}],[\"就是为了实现这种数据结构而存在的\",{\"1\":{\"212\":1}}],[\"就是不断向后寻找结点\",{\"1\":{\"190\":1}}],[\"就是直接按下标访问\",{\"1\":{\"190\":1}}],[\"就是重复\",{\"1\":{\"181\":1}}],[\"就是求当前集合与给定集合的交集\",{\"1\":{\"180\":1}}],[\"就是求当前集合与给定集合的差集\",{\"1\":{\"180\":1}}],[\"就是看给定集合是不是当前集合的子集\",{\"1\":{\"180\":1}}],[\"就是要操作\",{\"1\":{\"161\":1}}],[\"就是\",{\"1\":{\"87\":1}}],[\"就是前面\",{\"1\":{\"78\":1}}],[\"就是进行迭代\",{\"1\":{\"71\":1}}],[\"⋮\",{\"1\":{\"70\":4}}],[\"方言\",{\"1\":{\"744\":1}}],[\"方便之后更换\",{\"1\":{\"1259\":1}}],[\"方便我们直接对用户进行处理\",{\"1\":{\"665\":1}}],[\"方便后续直接展示\",{\"1\":{\"643\":1}}],[\"方便后续比较\",{\"1\":{\"70\":1}}],[\"方便可以根据对应的请求路径找到对应的controller来进行处理\",{\"1\":{\"558\":1}}],[\"方法中\",{\"1\":{\"1301\":1}}],[\"方法中包括了很多的参数\",{\"1\":{\"1231\":1}}],[\"方法中实现\",{\"1\":{\"445\":1}}],[\"方法执行之后\",{\"1\":{\"1237\":1}}],[\"方法执行之前\",{\"1\":{\"1237\":1}}],[\"方法执行完成\",{\"1\":{\"1224\":1}}],[\"方法执行操作\",{\"1\":{\"510\":1}}],[\"方法开始之前\",{\"1\":{\"1224\":1}}],[\"方法返回值为\",{\"1\":{\"1231\":1}}],[\"方法返回值可以是一个视图名\",{\"1\":{\"604\":1}}],[\"方法返回后等等\",{\"1\":{\"1220\":1}}],[\"方法使该类的对象能够在以后重新配置或重新注入\",{\"1\":{\"1175\":1}}],[\"方法参数\",{\"1\":{\"1219\":2}}],[\"方法参数注入\",{\"0\":{\"1200\":1}}],[\"方法参数上\",{\"1\":{\"1175\":1}}],[\"方法参数的name\",{\"1\":{\"408\":1}}],[\"方法必须是static\",{\"1\":{\"1017\":1}}],[\"方法二\",{\"1\":{\"523\":1}}],[\"方法一\",{\"1\":{\"523\":1}}],[\"方法设置\",{\"1\":{\"523\":1}}],[\"方法将元素收集到一个可以用分隔符指定的字符串中\",{\"1\":{\"522\":1}}],[\"方法将元素收集到一个新的\",{\"1\":{\"522\":2}}],[\"方法将其转换成新的集合\",{\"1\":{\"522\":1}}],[\"方法和\",{\"1\":{\"522\":1}}],[\"方法接收的是一个\",{\"1\":{\"519\":1}}],[\"方法创建集合的流后\",{\"1\":{\"522\":1}}],[\"方法创建并发流\",{\"1\":{\"516\":1}}],[\"方法创建流\",{\"1\":{\"516\":1}}],[\"方法内部其实调用了arrays\",{\"1\":{\"516\":1}}],[\"方法内部本质上也是迭代器在处理\",{\"1\":{\"192\":1}}],[\"方法会返回该对象\",{\"1\":{\"512\":1}}],[\"方法会返回true\",{\"1\":{\"512\":1}}],[\"方法会暂时使得此线程进入等待状态\",{\"1\":{\"318\":1}}],[\"方法连接两个\",{\"1\":{\"511\":1}}],[\"方法仅做成员字段之间的值比较\",{\"1\":{\"501\":1}}],[\"方法快速替换为另一个optional类\",{\"1\":{\"480\":1}}],[\"方法抛出的异常\",{\"1\":{\"446\":1}}],[\"方法在内的所有内容\",{\"1\":{\"446\":1}}],[\"方法转换字符串\",{\"1\":{\"432\":1}}],[\"方法引用其实本质上就相当于将其他方法的实现\",{\"1\":{\"415\":1}}],[\"方法引用\",{\"0\":{\"415\":1,\"448\":1,\"449\":1},\"1\":{\"415\":2}}],[\"方法名与该参数名相同\",{\"1\":{\"525\":1}}],[\"方法名\",{\"1\":{\"410\":1,\"415\":4}}],[\"方法名称作为测试名称\",{\"1\":{\"962\":1}}],[\"方法名称上会出现黄线\",{\"1\":{\"589\":1}}],[\"方法名称\",{\"1\":{\"162\":2,\"448\":1,\"944\":1,\"1219\":2}}],[\"方法名称同样可以随便起\",{\"1\":{\"162\":1}}],[\"方法等实现\",{\"1\":{\"501\":1}}],[\"方法等\",{\"1\":{\"408\":1}}],[\"方法重写\",{\"0\":{\"373\":1}}],[\"方法上的标记是不是也可以通过这种方式获取注解\",{\"1\":{\"365\":1}}],[\"方法定义为\",{\"1\":{\"355\":1}}],[\"方法为某个对象\",{\"1\":{\"350\":1}}],[\"方法可以将流转换成数组\",{\"1\":{\"522\":1}}],[\"方法可以将当前线程进入休眠\",{\"1\":{\"300\":1}}],[\"方法可以找到类中的非public构造方法\",{\"1\":{\"348\":1}}],[\"方法用于获取可拆分迭代器\",{\"1\":{\"330\":1}}],[\"方法暂时处于等待状态\",{\"1\":{\"324\":1}}],[\"方法后\",{\"1\":{\"313\":1,\"318\":1}}],[\"方法是如何实现的\",{\"1\":{\"625\":1}}],[\"方法是让该线程从\",{\"1\":{\"318\":1}}],[\"方法是强制终止线程\",{\"1\":{\"301\":1}}],[\"方法是语句的集合\",{\"1\":{\"162\":1}}],[\"方法强行停止\",{\"1\":{\"300\":1}}],[\"方法能够终止此线程\",{\"1\":{\"299\":1}}],[\"方法来直接获取单例对象\",{\"1\":{\"1300\":1}}],[\"方法来处理客户端的请求\",{\"1\":{\"1055\":1}}],[\"方法来看看实现类是个什么\",{\"1\":{\"842\":1}}],[\"方法来执行一个dml或是ddl语句\",{\"1\":{\"791\":1}}],[\"方法来执行select语句\",{\"1\":{\"791\":1}}],[\"方法来防止此类情况发生\",{\"1\":{\"721\":1}}],[\"方法来设定io超时时间\",{\"1\":{\"721\":1}}],[\"方法来获取连接对象\",{\"1\":{\"1245\":1}}],[\"方法来获取一个类定义的指定字段\",{\"1\":{\"350\":1}}],[\"方法来获取类的权限为\",{\"1\":{\"348\":1}}],[\"方法来创建对应类型的实例\",{\"1\":{\"348\":1}}],[\"方法来使用单线程维持原本的顺序\",{\"1\":{\"330\":1}}],[\"方法来关闭它的工作线程\",{\"1\":{\"324\":1}}],[\"方法来实现线程的加入\",{\"1\":{\"305\":1}}],[\"方法来将当前资源让位给其他同优先级线程\",{\"1\":{\"304\":1}}],[\"方法来强行终止此线程\",{\"1\":{\"299\":1}}],[\"方法来让当前线程休眠一段时间\",{\"1\":{\"299\":1}}],[\"方法来运行此线程\",{\"1\":{\"297\":1}}],[\"方法得到一个字符串\",{\"1\":{\"284\":1}}],[\"方法时\",{\"1\":{\"241\":1,\"300\":1}}],[\"方法也相同\",{\"1\":{\"241\":1}}],[\"方法判断相同时\",{\"1\":{\"241\":1}}],[\"方法判断相同后\",{\"1\":{\"241\":1}}],[\"方法判断的\",{\"1\":{\"241\":1}}],[\"方法判定为\",{\"1\":{\"181\":1}}],[\"方法进行连接了\",{\"1\":{\"680\":1}}],[\"方法进行处理\",{\"1\":{\"604\":1}}],[\"方法进行实现\",{\"1\":{\"446\":1}}],[\"方法进行错误检查\",{\"1\":{\"284\":1}}],[\"方法进行判断的\",{\"1\":{\"241\":1}}],[\"方法进行求解\",{\"1\":{\"136\":1}}],[\"方法比较的是地址\",{\"1\":{\"241\":1}}],[\"方法体\",{\"1\":{\"162\":1}}],[\"方法的返回值可以是任何可迭代\",{\"1\":{\"994\":1}}],[\"方法的返回类型\",{\"1\":{\"165\":1}}],[\"方法的源码\",{\"1\":{\"522\":1}}],[\"方法的主要作用是把\",{\"1\":{\"521\":1}}],[\"方法的具体实现\",{\"1\":{\"446\":1}}],[\"方法的名称等内容\",{\"1\":{\"349\":1}}],[\"方法的权限修饰符改为private后\",{\"1\":{\"349\":1}}],[\"方法的内容\",{\"1\":{\"295\":1}}],[\"方法的重载是为某个方法提供更多种类\",{\"1\":{\"373\":1}}],[\"方法的重载\",{\"0\":{\"165\":1}}],[\"方法的进阶使用\",{\"0\":{\"163\":1}}],[\"方法的调用\",{\"1\":{\"162\":1}}],[\"方法的定义如下\",{\"1\":{\"162\":1}}],[\"方法的创建与使用\",{\"0\":{\"162\":1}}],[\"方法2\",{\"1\":{\"82\":1,\"523\":1}}],[\"方法1\",{\"1\":{\"82\":1,\"523\":1}}],[\"方法\",{\"0\":{\"23\":1,\"216\":1,\"217\":1,\"297\":1,\"298\":1,\"299\":1,\"318\":1,\"393\":1,\"1056\":1,\"1246\":1,\"1321\":1},\"1\":{\"77\":1,\"155\":1,\"192\":1,\"217\":1,\"223\":1,\"241\":2,\"248\":3,\"249\":1,\"284\":1,\"301\":1,\"348\":1,\"349\":2,\"355\":1,\"356\":2,\"365\":1,\"372\":1,\"451\":1,\"452\":1,\"500\":1,\"516\":1,\"519\":1,\"522\":1,\"525\":3,\"625\":1,\"626\":2,\"708\":1,\"721\":1,\"806\":1,\"812\":1,\"921\":1,\"1055\":2,\"1056\":1,\"1059\":1,\"1203\":1,\"1242\":1,\"1282\":2,\"1283\":1,\"1300\":1,\"1327\":2}}],[\"之外的任何单个字符\",{\"1\":{\"403\":1}}],[\"之外\",{\"1\":{\"393\":1}}],[\"之前javaweb阶段已经讲解过了\",{\"1\":{\"1273\":1}}],[\"之前一直使用的是官方的默认配置\",{\"1\":{\"1242\":1}}],[\"之前写好的代码\",{\"1\":{\"1116\":1}}],[\"之前通过info方法直接输出的结果就是使用的默认级别的日志\",{\"1\":{\"910\":1}}],[\"之前通过创建一个映射器来将结果快速转换为实体类\",{\"1\":{\"842\":1}}],[\"之前被删除的数据回来了\",{\"1\":{\"865\":1}}],[\"之前的操作也就不会生效\",{\"1\":{\"806\":1}}],[\"之前的写法是\",{\"1\":{\"495\":1}}],[\"之前我们需要像这样编写\",{\"1\":{\"895\":1}}],[\"之前我们需要完整地编写一个servlet来实现\",{\"1\":{\"569\":1}}],[\"之前我们定义变量必须指定类型\",{\"1\":{\"485\":1}}],[\"之前执行\",{\"1\":{\"313\":1}}],[\"之前使用的scanner\",{\"1\":{\"285\":1}}],[\"之前就是直接使用的\",{\"1\":{\"277\":1}}],[\"之前介绍的方法都是\",{\"1\":{\"147\":1}}],[\"之后执行的所有方法都会在同一个事务中执行\",{\"1\":{\"1277\":1}}],[\"之后一直使用这个对象了\",{\"1\":{\"1130\":1}}],[\"之后我们还可以为这两个bean分别设置不同的其他属性\",{\"1\":{\"1127\":1}}],[\"之后我们会讲解如何进行配置\",{\"1\":{\"652\":1}}],[\"之后容器就会根据这里的配置进行处理了\",{\"1\":{\"1119\":1}}],[\"之后的结果\",{\"1\":{\"1328\":1}}],[\"之后的语句需要等处理完\",{\"1\":{\"1103\":1}}],[\"之后的所有流程全部取消\",{\"1\":{\"598\":1}}],[\"之后网页收到服务器的响应请求后就会存储对应\",{\"1\":{\"1091\":1}}],[\"之后会讲解文件传输\",{\"1\":{\"1058\":1}}],[\"之后idea会自动帮助我们创建maven项目\",{\"1\":{\"1048\":1}}],[\"之后就是http\",{\"1\":{\"1042\":1}}],[\"之后通过其他方式欺骗用户登录该会话\",{\"1\":{\"642\":1}}],[\"之后还可以继续补充添加拦截器\",{\"1\":{\"558\":1}}],[\"之后要配置好我们需要的viewresolver即可\",{\"1\":{\"558\":1}}],[\"之后为了方便\",{\"1\":{\"554\":1}}],[\"之后\",{\"1\":{\"207\":1,\"265\":2}}],[\"之后进行迭代\",{\"1\":{\"70\":1}}],[\"之间存在什么关系\",{\"1\":{\"68\":1}}],[\"一秒一次\",{\"1\":{\"1192\":1}}],[\"一律使用service\",{\"1\":{\"1117\":1}}],[\"一律需要经过此过滤器\",{\"1\":{\"1102\":1}}],[\"一律需要验证\",{\"1\":{\"680\":1,\"681\":1}}],[\"一键测试所有位于test目录下的测试案例\",{\"1\":{\"1035\":1}}],[\"一只企鹅\",{\"1\":{\"961\":1}}],[\"一级缓存给我们提供了很高速的访问效率\",{\"1\":{\"883\":1}}],[\"一级缓存只针对于单个会话\",{\"1\":{\"883\":1}}],[\"一级缓存强制启用\",{\"1\":{\"883\":1}}],[\"一级缓存\",{\"0\":{\"883\":1}}],[\"一次性开启所有测试案例每个案例开始之前都会执行一次\",{\"1\":{\"1017\":1}}],[\"一次性开启所有测试案例只会执行一次\",{\"1\":{\"1017\":1}}],[\"一次性提交一个批量操作给数据库\",{\"1\":{\"871\":1}}],[\"一次性读取全部内容\",{\"1\":{\"248\":1}}],[\"一对多查询\",{\"0\":{\"853\":1}}],[\"一对一查询我们可以使用association标签来进行指定\",{\"1\":{\"850\":1}}],[\"一对一查询\",{\"0\":{\"849\":1}}],[\"一起执行\",{\"1\":{\"798\":1}}],[\"一开始是在第一行上面\",{\"1\":{\"797\":1}}],[\"一开始创建时\",{\"1\":{\"402\":1}}],[\"一套完整的\",{\"1\":{\"787\":1}}],[\"一条记录\",{\"1\":{\"754\":1}}],[\"一步到位\",{\"1\":{\"684\":1}}],[\"一号拦截器\",{\"1\":{\"600\":6,\"601\":3}}],[\"一会观察一下加密出来之后的密码长啥样\",{\"1\":{\"659\":1}}],[\"一会要保存的格式\",{\"1\":{\"490\":1}}],[\"一会直接覆盖\",{\"1\":{\"216\":1}}],[\"一直都是此版本作为广泛使用的版本\",{\"1\":{\"486\":1}}],[\"一直以来编写的都是单线程应用程序\",{\"1\":{\"295\":1}}],[\"一定知道三引号\",{\"1\":{\"498\":1}}],[\"一定是\",{\"1\":{\"438\":1}}],[\"一定要先明确\",{\"1\":{\"1301\":1}}],[\"一定要先切换到我们要创建表的数据库内\",{\"1\":{\"750\":1}}],[\"一定要先检查是否因为没有放行导致被springsecurity给拦截了\",{\"1\":{\"681\":1}}],[\"一定要添加在全部请求拦截之前\",{\"1\":{\"681\":1}}],[\"一定要用equals\",{\"1\":{\"401\":1}}],[\"一定要注意\",{\"1\":{\"313\":1}}],[\"一定比线程t先醒来\",{\"1\":{\"301\":1}}],[\"一定可以遍历所给定的\",{\"1\":{\"84\":1}}],[\"一旦发现异常\",{\"1\":{\"1277\":1}}],[\"一旦事务完成\",{\"1\":{\"1266\":2}}],[\"一旦声明为抽象bean\",{\"1\":{\"1151\":1}}],[\"一旦使用\",{\"1\":{\"812\":1}}],[\"一旦关闭自动提交\",{\"1\":{\"806\":1}}],[\"一旦提交\",{\"1\":{\"782\":1}}],[\"一旦tcp连接建立\",{\"1\":{\"719\":1}}],[\"一旦被设定是无法被随意修改的\",{\"1\":{\"642\":1}}],[\"一旦被声明为静态\",{\"1\":{\"274\":1}}],[\"一旦出现指定异常\",{\"1\":{\"605\":1}}],[\"一旦在类上加了\",{\"1\":{\"603\":1}}],[\"一旦拦截器返回false\",{\"1\":{\"600\":1}}],[\"一旦添加\",{\"1\":{\"580\":1}}],[\"一旦大于等于10直接截断\",{\"1\":{\"479\":1}}],[\"一旦类型明确\",{\"1\":{\"438\":1}}],[\"一旦获取到\",{\"1\":{\"299\":1}}],[\"一部分内容可以被暂时保存bufferedinputstream\",{\"1\":{\"265\":1}}],[\"一致性\",{\"1\":{\"782\":1,\"1266\":1}}],[\"一致\",{\"1\":{\"241\":1}}],[\"一致也是可以的\",{\"1\":{\"124\":1}}],[\"一般比较常用的datasource实现\",{\"1\":{\"1242\":1}}],[\"一般通过\",{\"1\":{\"1069\":1}}],[\"一般是此接口实现\",{\"1\":{\"1057\":1}}],[\"一般是4\",{\"1\":{\"1002\":1}}],[\"一般仅用作测试的依赖如junit只保留在测试中即可\",{\"1\":{\"1017\":1}}],[\"一般表示这是一个处于开发中的项目\",{\"1\":{\"1003\":1}}],[\"一般不咋用\",{\"1\":{\"841\":1}}],[\"一般都是将其转换为对应的实体类对象\",{\"1\":{\"831\":1}}],[\"一般聚集函数是这样使用的\",{\"1\":{\"765\":1}}],[\"一般\",{\"1\":{\"726\":1}}],[\"一般用于注册bean\",{\"1\":{\"1310\":1}}],[\"一般用于指定项目在当前组中的唯一名称\",{\"1\":{\"1003\":1}}],[\"一般用于指定组名称\",{\"1\":{\"1003\":1}}],[\"一般用于配置service\",{\"1\":{\"625\":1}}],[\"一般用于业务层配置\",{\"1\":{\"552\":1}}],[\"一般指的是前端页面\",{\"1\":{\"541\":1}}],[\"一般构建对象时会有两种方法\",{\"1\":{\"523\":1}}],[\"一般出现错误可能jvm就无法继续正常运行了\",{\"1\":{\"421\":1}}],[\"一般他们是配合一起使用的\",{\"1\":{\"286\":1}}],[\"一般遇到以下情况时才会会加载类\",{\"1\":{\"275\":1}}],[\"一般情况\",{\"1\":{\"386\":1}}],[\"一般情况下使用不到\",{\"1\":{\"1047\":1}}],[\"一般情况下只是为了进行一些额外的初始化工作而已\",{\"1\":{\"412\":1}}],[\"一般情况下\",{\"1\":{\"274\":1,\"363\":1}}],[\"一般情况都是真实的数据量\",{\"1\":{\"248\":1}}],[\"一般在java\",{\"1\":{\"245\":1}}],[\"一般的比较运算符\",{\"1\":{\"763\":1}}],[\"一般的方法是\",{\"1\":{\"523\":1}}],[\"一般的\",{\"1\":{\"182\":1}}],[\"一般使用驼峰命名法最规范\",{\"1\":{\"162\":1}}],[\"一般化的推广\",{\"1\":{\"69\":1}}],[\"一些浏览器可以阻止客户端脚本对cookie的读操作\",{\"1\":{\"642\":1}}],[\"一些方法\",{\"1\":{\"432\":1}}],[\"一些集合是有序的\",{\"1\":{\"178\":1}}],[\"一些特性\",{\"1\":{\"155\":1}}],[\"一些细节\",{\"1\":{\"142\":1,\"156\":1}}],[\"一些状态可能很少被访问\",{\"1\":{\"134\":1}}],[\"一些问题\",{\"0\":{\"68\":1}}],[\"一个对象注入自己\",{\"1\":{\"1301\":1}}],[\"一个对象改变了静态变量的值\",{\"1\":{\"274\":1}}],[\"一个bean的实例对象到底是如何创建出来的呢\",{\"1\":{\"1299\":1}}],[\"一个build\",{\"1\":{\"525\":1}}],[\"一个数据库连接对象均对应一个物理数据库连接\",{\"1\":{\"1242\":1}}],[\"一个由spring\",{\"1\":{\"1117\":1}}],[\"一个人去写业务层的代码\",{\"1\":{\"1117\":1}}],[\"一个cookie包含信息\",{\"1\":{\"1092\":1}}],[\"一个servlet的生命周期为\",{\"1\":{\"1055\":1}}],[\"一个jar包实际上就是对我们生成的字节码文件进行的压缩打包\",{\"1\":{\"1036\":1}}],[\"一个json格式的数据长这样\",{\"1\":{\"610\":1}}],[\"一个maven项目可以继承自另一个maven项目\",{\"1\":{\"1032\":1}}],[\"一个maven项目和我们普通的项目有什么区别\",{\"1\":{\"1001\":1}}],[\"一个项目有可能依赖于其他项目\",{\"1\":{\"1015\":1}}],[\"一个项目依赖一般是存储在中央仓库中\",{\"1\":{\"1009\":1}}],[\"一个组下面可以有很多个项目\",{\"1\":{\"1003\":1}}],[\"一个标准的pom配置长这样\",{\"1\":{\"1002\":1}}],[\"一个测试类中可以同时有多个测试案例\",{\"1\":{\"959\":1}}],[\"一个logger中可以包含多个handler用于同时向不同的地方打印日志\",{\"1\":{\"918\":1}}],[\"一个会话dml操作只会重置当前会话的缓存\",{\"1\":{\"883\":1}}],[\"一个比较特殊的选择方法selectmap\",{\"1\":{\"836\":1}}],[\"一个节点下可能会有很多个节点\",{\"1\":{\"819\":1}}],[\"一个xml文件存在以下的格式规范\",{\"1\":{\"817\":1}}],[\"一个事务可以包括n个子事务\",{\"1\":{\"1279\":1}}],[\"一个事务无非就是创建\",{\"1\":{\"1272\":1}}],[\"一个事务必须等待其他事务结束之后才能开始执行\",{\"1\":{\"1267\":1}}],[\"一个事务\",{\"1\":{\"782\":1}}],[\"一个不允许更新的视图上定义的视图也不允许更新\",{\"1\":{\"779\":1}}],[\"一个表可以有多个唯一约束\",{\"1\":{\"747\":1}}],[\"一个表只能有一个主键\",{\"1\":{\"747\":1,\"748\":1}}],[\"一个仓库可以存储多种物品\",{\"1\":{\"739\":1}}],[\"一个实体的属性可以有很多个\",{\"1\":{\"733\":1}}],[\"一个用户可以有一个或多个角色\",{\"1\":{\"692\":1}}],[\"一个qq群里面\",{\"1\":{\"691\":1}}],[\"一个页面\",{\"1\":{\"588\":1}}],[\"一个名为foobuilder的内部静态类\",{\"1\":{\"525\":1}}],[\"一个默认的构造函数\",{\"1\":{\"523\":1}}],[\"一个可以产生所需的新数组的函数\",{\"1\":{\"522\":1}}],[\"一个注解就搞定了\",{\"1\":{\"501\":1}}],[\"一个注解可以有很多个作用域\",{\"1\":{\"363\":1}}],[\"一个repeat就搞定了\",{\"1\":{\"488\":1}}],[\"一个是postprocessafterinitialization用于在bean初始化之后进行处理\",{\"1\":{\"1307\":1}}],[\"一个是活跃列表\",{\"1\":{\"1246\":1}}],[\"一个是空闲列表\",{\"1\":{\"1246\":1}}],[\"一个是根据类型\",{\"1\":{\"1138\":1}}],[\"一个是byname\",{\"1\":{\"1138\":1}}],[\"一个是web容器一个是根容器\",{\"1\":{\"625\":1}}],[\"一个是运行时异常\",{\"1\":{\"422\":1}}],[\"一个是编译时异常\",{\"1\":{\"422\":1}}],[\"一个成员内部类\",{\"1\":{\"408\":1}}],[\"一个三行两列的数组\",{\"1\":{\"397\":1}}],[\"一个类可以附加很多个功能\",{\"1\":{\"376\":1}}],[\"一个类中可以包含多个同名的方法\",{\"1\":{\"165\":1}}],[\"一个最简单的注解就被我们创建了\",{\"1\":{\"363\":1}}],[\"一个线程处于运行状态下\",{\"1\":{\"300\":1}}],[\"一个进程可以有多个线程\",{\"1\":{\"295\":1}}],[\"一个新的迭代器就像上面这样\",{\"1\":{\"188\":1}}],[\"一个集合中可以存放多个集合\",{\"1\":{\"182\":1}}],[\"一个泛型类型编译之后\",{\"1\":{\"173\":1}}],[\"一个\",{\"1\":{\"103\":1}}],[\"一样才行\",{\"1\":{\"415\":1}}],[\"一样\",{\"1\":{\"82\":1}}],[\"一种最简单的方式就是和之前一样\",{\"1\":{\"843\":1}}],[\"一种则是有所偏向\",{\"1\":{\"152\":1}}],[\"一种是以优秀\",{\"1\":{\"437\":1}}],[\"一种是将所有状态视为同等重要\",{\"1\":{\"152\":1}}],[\"一种是通过迭代算法来求解\",{\"1\":{\"68\":1}}],[\"一种是可以直接通过矩阵求逆进行求解\",{\"1\":{\"68\":1}}],[\"一种迭代策略\",{\"1\":{\"47\":1}}],[\"jndi\",{\"1\":{\"1242\":1}}],[\"jntm<\",{\"1\":{\"1018\":1}}],[\"jc\",{\"1\":{\"1071\":1}}],[\"jmx\",{\"1\":{\"1047\":5}}],[\"jre\",{\"1\":{\"977\":3,\"978\":2,\"1047\":2}}],[\"juc有关\",{\"1\":{\"1188\":1}}],[\"jupiter<\",{\"1\":{\"1017\":2,\"1033\":4,\"1290\":2}}],[\"junit整合\",{\"0\":{\"1287\":1,\"1288\":1,\"1357\":1}}],[\"junit框架\",{\"1\":{\"1016\":1}}],[\"junit依赖\",{\"1\":{\"1008\":1}}],[\"junit5\",{\"1\":{\"995\":1}}],[\"junit\",{\"0\":{\"1349\":1},\"1\":{\"995\":1,\"1017\":1,\"1033\":2,\"1290\":1}}],[\"junit还支持从csv表格中导入或自定义参数提供器等\",{\"1\":{\"995\":1}}],[\"junit还提供了上百种断言方法供大家使用\",{\"1\":{\"973\":1}}],[\"junit还提供了一些预设的名称生成器\",{\"1\":{\"962\":1}}],[\"junit提供了以下顺序\",{\"1\":{\"987\":1}}],[\"junit提供了非常多的断言操作\",{\"1\":{\"968\":1}}],[\"junit支持我们就为测试案例设置条件来实现这些功能\",{\"1\":{\"975\":1}}],[\"junit单元测试3\",{\"0\":{\"984\":1}}],[\"junit单元测试2\",{\"0\":{\"967\":1}}],[\"junit单元测试1\",{\"0\":{\"955\":1}}],[\"junit2\",{\"0\":{\"966\":1,\"983\":1}}],[\"junit使用\",{\"0\":{\"957\":1}}],[\"junit1\",{\"0\":{\"954\":1}}],[\"jul设置默认配置\",{\"0\":{\"939\":1}}],[\"jul中logger之间存在父子关系\",{\"1\":{\"927\":1}}],[\"jul\",{\"0\":{\"1348\":1},\"1\":{\"1091\":1,\"1096\":1},\"2\":{\"914\":1,\"923\":1,\"932\":1,\"941\":1,\"953\":1,\"965\":1,\"982\":1,\"997\":1}}],[\"jul基本使用\",{\"0\":{\"909\":1}}],[\"jul日志5\",{\"0\":{\"942\":1}}],[\"jul日志4\",{\"0\":{\"933\":1}}],[\"jul日志3\",{\"0\":{\"924\":1}}],[\"jul日志2\",{\"0\":{\"915\":1}}],[\"jul日志系统5\",{\"0\":{\"943\":1}}],[\"jul日志系统4\",{\"0\":{\"934\":1}}],[\"jul日志系统3\",{\"0\":{\"925\":1}}],[\"jul日志系统2\",{\"0\":{\"916\":1}}],[\"jul日志系统\",{\"0\":{\"908\":1}}],[\"jul日志1\",{\"0\":{\"907\":1}}],[\"jul日志模块\",{\"1\":{\"468\":1}}],[\"jdbc为我们定义了一个数据源的标准\",{\"1\":{\"1242\":1}}],[\"jdbctransaction\",{\"1\":{\"1273\":4}}],[\"jdbctransactionfactory\",{\"1\":{\"904\":1}}],[\"jdbctokenrepositoryimpl\",{\"1\":{\"687\":2}}],[\"jdbc很方便\",{\"1\":{\"816\":1}}],[\"jdbc默认的事务处理行为是自动提交\",{\"1\":{\"806\":1}}],[\"jdbc英文名为\",{\"1\":{\"787\":1}}],[\"jdbcuserdetailsmanager\",{\"1\":{\"664\":2,\"666\":2}}],[\"jdbc\",{\"0\":{\"787\":1,\"795\":1,\"803\":1},\"1\":{\"664\":2,\"788\":4,\"789\":1,\"796\":1,\"805\":1,\"816\":1,\"824\":2,\"852\":3,\"872\":1,\"904\":2,\"936\":4,\"1017\":3,\"1071\":2,\"1242\":2,\"1255\":3,\"1259\":2,\"1260\":3,\"1273\":2,\"1276\":2}}],[\"jdbc<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"jdkdynamicaopproxy\",{\"1\":{\"1283\":2}}],[\"jdk自带了一个java\",{\"1\":{\"787\":1}}],[\"jdk为我们提供了一个叫做properties的类型\",{\"1\":{\"937\":1}}],[\"jdk为我们提供了一个自带的日志框架\",{\"1\":{\"908\":1}}],[\"jdk为我们提供了很多种类的handler用于多种不同类型的日志打印\",{\"1\":{\"918\":1}}],[\"jdk为我们提供的某些框架不见了\",{\"1\":{\"461\":1}}],[\"jdk为我们内置了一个叫做org\",{\"1\":{\"819\":1}}],[\"jdk为我们准备的\",{\"1\":{\"232\":1}}],[\"jdk\",{\"1\":{\"437\":1,\"842\":1,\"951\":2,\"1017\":1,\"1196\":1,\"1278\":3}}],[\"jdk预设了以下注解\",{\"1\":{\"361\":1}}],[\"jdk提供的string类也是\",{\"1\":{\"355\":1}}],[\"jdk14<\",{\"1\":{\"1260\":1}}],[\"jdk1\",{\"1\":{\"337\":1,\"340\":1}}],[\"j<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"jasperloader\",{\"1\":{\"1109\":1}}],[\"jar命令即可运行打包好的java程序\",{\"1\":{\"1037\":1}}],[\"jar<\",{\"1\":{\"1018\":1}}],[\"jar\",{\"1\":{\"789\":1,\"1038\":1}}],[\"jakartaee\",{\"1\":{\"545\":3}}],[\"jakarta\",{\"1\":{\"545\":3,\"1000\":1}}],[\"javax\",{\"1\":{\"1175\":1}}],[\"java<\",{\"1\":{\"1017\":1,\"1033\":1,\"1071\":1}}],[\"java读取\",{\"0\":{\"937\":1}}],[\"javatype\",{\"1\":{\"900\":3}}],[\"javatype=\",{\"1\":{\"841\":2,\"850\":1,\"851\":1,\"855\":1,\"900\":3}}],[\"java对象\",{\"1\":{\"816\":1}}],[\"java的编译过程可以分成三个阶段\",{\"1\":{\"811\":1}}],[\"java的内存模型也是这样类似设计的\",{\"1\":{\"311\":1}}],[\"java与数据库3\",{\"0\":{\"802\":1}}],[\"java与数据库2\",{\"0\":{\"794\":1}}],[\"java与数据库1\",{\"0\":{\"785\":1}}],[\"java应用程序\",{\"1\":{\"787\":1}}],[\"java数据库连接\",{\"1\":{\"787\":1}}],[\"javaweb\",{\"0\":{\"717\":1,\"724\":1,\"730\":1,\"742\":1,\"759\":1,\"777\":1,\"785\":1,\"794\":1,\"802\":1,\"809\":1,\"815\":1,\"822\":1,\"829\":1,\"839\":1,\"846\":1,\"858\":1,\"868\":1,\"880\":1,\"891\":1,\"907\":1,\"915\":1,\"924\":1,\"933\":1,\"942\":1,\"954\":1,\"966\":1,\"983\":1,\"1344\":1},\"2\":{\"723\":1,\"729\":1,\"741\":1,\"758\":1,\"776\":1,\"784\":1,\"793\":1,\"801\":1,\"808\":1,\"814\":1,\"821\":1,\"828\":1,\"838\":1,\"845\":1,\"857\":1,\"867\":1,\"879\":1,\"890\":1,\"906\":1,\"914\":1,\"923\":1,\"932\":1,\"941\":1,\"953\":1,\"965\":1,\"982\":1,\"997\":1,\"1005\":1,\"1012\":1,\"1020\":1,\"1028\":1,\"1040\":1,\"1044\":1,\"1050\":1,\"1066\":1,\"1078\":1,\"1088\":1,\"1099\":1,\"1107\":1,\"1111\":1}}],[\"javascript\",{\"1\":{\"609\":1}}],[\"javassm\",{\"0\":{\"539\":1,\"557\":1,\"567\":1,\"592\":1,\"608\":1,\"623\":1,\"629\":1,\"634\":1,\"639\":1,\"646\":1,\"655\":1,\"675\":1,\"690\":1,\"702\":1,\"1112\":1,\"1122\":1,\"1144\":1,\"1155\":1,\"1163\":1,\"1184\":1,\"1195\":1,\"1214\":1,\"1229\":1,\"1240\":1,\"1250\":1,\"1263\":1,\"1287\":1,\"1294\":1,\"1304\":1,\"1314\":1,\"1324\":1},\"2\":{\"556\":1,\"566\":1,\"591\":1,\"607\":1,\"622\":1,\"628\":1,\"633\":1,\"638\":1,\"645\":1,\"654\":1,\"674\":1,\"689\":1,\"701\":1,\"716\":1,\"1121\":1,\"1143\":1,\"1154\":1,\"1162\":1,\"1183\":1,\"1194\":1,\"1213\":1,\"1228\":1,\"1239\":1,\"1249\":1,\"1262\":1,\"1286\":1,\"1293\":1,\"1303\":1,\"1313\":1,\"1323\":1,\"1330\":1}}],[\"java13也带了这样的特性\",{\"1\":{\"498\":1}}],[\"java12\",{\"1\":{\"494\":1}}],[\"java11\",{\"0\":{\"486\":1}}],[\"java10\",{\"0\":{\"483\":1,\"484\":1}}],[\"java17版本的string类\",{\"1\":{\"462\":1}}],[\"java文件\",{\"1\":{\"468\":2}}],[\"java文件表示此项目采用模块管理机制\",{\"1\":{\"461\":1}}],[\"java为我们提供的logging相关日志库\",{\"1\":{\"461\":1}}],[\"java9\",{\"0\":{\"457\":1,\"458\":1,\"471\":1,\"472\":1}}],[\"java新特性\",{\"2\":{\"456\":1,\"470\":1,\"482\":1,\"492\":1,\"506\":1,\"527\":1}}],[\"java提供的基本类型包装类\",{\"1\":{\"383\":1}}],[\"java并不是纯面向对象的语言\",{\"1\":{\"383\":1}}],[\"javaconfig\",{\"1\":{\"1181\":1}}],[\"javac\",{\"1\":{\"356\":1}}],[\"java高版本不行\",{\"1\":{\"350\":1}}],[\"java中也可以使用这样的三引号来表示字符串\",{\"1\":{\"498\":1}}],[\"java中也有些使用并行来进行操作的\",{\"1\":{\"330\":1}}],[\"java中接口的方法默认是\",{\"1\":{\"447\":1}}],[\"java中没有字符串这种基本类型\",{\"1\":{\"400\":1}}],[\"java中的基本类型\",{\"1\":{\"383\":1}}],[\"java中所有的线程都执行完毕后\",{\"1\":{\"329\":1}}],[\"java中引入了访问权限控制\",{\"1\":{\"278\":1}}],[\"java采用的是抢占式调度方式\",{\"1\":{\"302\":1}}],[\"java程序中的每个线程并不是平均分配cpu时间的\",{\"1\":{\"302\":1}}],[\"java会默认导入java\",{\"1\":{\"277\":1}}],[\"java8tester\",{\"1\":{\"512\":5}}],[\"java8只能像这样生成无限的流\",{\"1\":{\"478\":1}}],[\"java8回顾\",{\"0\":{\"442\":1}}],[\"java8开始\",{\"1\":{\"376\":1}}],[\"java8新增操作\",{\"1\":{\"214\":1}}],[\"java8新增方法\",{\"1\":{\"180\":1,\"193\":1}}],[\"java8\",{\"0\":{\"443\":1},\"1\":{\"192\":1,\"214\":1,\"513\":1}}],[\"java\",{\"0\":{\"160\":1,\"169\":1,\"176\":1,\"185\":1,\"197\":1,\"210\":1,\"227\":1,\"231\":1,\"240\":1,\"244\":1,\"258\":1,\"273\":1,\"281\":1,\"293\":1,\"308\":1,\"316\":1,\"327\":1,\"334\":1,\"337\":1,\"346\":1,\"353\":1,\"359\":1,\"368\":1,\"381\":1,\"389\":1,\"406\":1,\"418\":1,\"428\":1,\"435\":1,\"493\":1,\"494\":1,\"502\":1,\"507\":1,\"1336\":1,\"1338\":1,\"1339\":1,\"1341\":1},\"1\":{\"180\":2,\"181\":1,\"182\":2,\"199\":1,\"224\":1,\"228\":2,\"252\":2,\"275\":1,\"277\":1,\"296\":1,\"330\":1,\"339\":1,\"343\":3,\"349\":4,\"355\":2,\"356\":2,\"361\":2,\"362\":2,\"365\":6,\"377\":1,\"378\":3,\"386\":3,\"399\":1,\"412\":2,\"431\":2,\"432\":1,\"453\":1,\"454\":1,\"458\":1,\"460\":2,\"461\":4,\"462\":2,\"463\":1,\"465\":2,\"468\":2,\"473\":1,\"484\":1,\"486\":1,\"494\":1,\"502\":1,\"512\":1,\"519\":1,\"522\":2,\"528\":5,\"531\":1,\"720\":2,\"721\":1,\"726\":2,\"787\":3,\"789\":4,\"796\":2,\"816\":2,\"841\":3,\"843\":1,\"901\":1,\"910\":1,\"927\":1,\"939\":1,\"947\":1,\"951\":1,\"977\":3,\"978\":2,\"991\":2,\"1000\":2,\"1032\":1,\"1047\":1,\"1048\":1,\"1053\":1,\"1205\":1,\"1211\":2,\"1224\":4,\"1278\":12,\"1283\":7},\"2\":{\"168\":1,\"175\":1,\"184\":1,\"196\":1,\"209\":1,\"226\":1,\"230\":1,\"239\":1,\"243\":1,\"257\":1,\"272\":1,\"280\":1,\"292\":1,\"307\":1,\"315\":1,\"326\":1,\"333\":1,\"345\":1,\"352\":1,\"358\":1,\"367\":1,\"380\":1,\"388\":1,\"405\":1,\"417\":1,\"427\":1,\"434\":1,\"441\":1,\"530\":1,\"533\":1,\"538\":1}}],[\"job\",{\"1\":{\"525\":2}}],[\"joinpoint实例会被自动传入\",{\"1\":{\"1223\":1}}],[\"joinpoint\",{\"1\":{\"1223\":1,\"1224\":5,\"1225\":3,\"1234\":1}}],[\"join同理\",{\"1\":{\"769\":1}}],[\"joining\",{\"1\":{\"522\":2}}],[\"join\",{\"1\":{\"305\":1,\"769\":5,\"850\":1,\"853\":1,\"855\":2,\"1226\":1}}],[\"jpg\",{\"1\":{\"490\":1}}],[\"jsp类加载器\",{\"1\":{\"1109\":1}}],[\"jspx<\",{\"1\":{\"1054\":1}}],[\"jsp<\",{\"1\":{\"1054\":1}}],[\"jsp\",{\"1\":{\"1054\":1}}],[\"jsp等\",{\"1\":{\"787\":1}}],[\"jsessionid\",{\"1\":{\"1096\":1}}],[\"jsessionid=84abdd94fb965f266818b9dbb6172807\",{\"1\":{\"1096\":2}}],[\"jsessionid=6aaf677ec2b630704a80d36311f08e01\",{\"1\":{\"642\":1}}],[\"jsessionid会得到重新分配\",{\"1\":{\"658\":1}}],[\"jsonarray\",{\"1\":{\"613\":2}}],[\"jsonobject\",{\"1\":{\"612\":2,\"613\":2,\"617\":4,\"636\":3,\"658\":3,\"666\":3}}],[\"json解析框架有很多种\",{\"1\":{\"611\":1}}],[\"json数据格式\",{\"0\":{\"610\":1}}],[\"json数据格式与axios请求\",{\"0\":{\"609\":1}}],[\"json\",{\"0\":{\"611\":1},\"1\":{\"577\":1,\"604\":1,\"609\":1,\"610\":2,\"615\":3,\"616\":1,\"617\":2}}],[\"js并编写如下内容\",{\"1\":{\"564\":1}}],[\"js\",{\"1\":{\"563\":1,\"564\":1,\"609\":1,\"617\":2,\"636\":1,\"641\":1,\"642\":1,\"1047\":1,\"1061\":1,\"1104\":1}}],[\"jshell交互式编程\",{\"0\":{\"473\":1}}],[\"jstack自动帮助我们找到了一个死锁\",{\"1\":{\"313\":1}}],[\"jstack\",{\"1\":{\"313\":1}}],[\"j++\",{\"1\":{\"312\":6}}],[\"j+1\",{\"1\":{\"66\":2,\"68\":1}}],[\"jvm发现任何异常都会立即终止程序运行\",{\"1\":{\"424\":1}}],[\"jvm会加载这个类吗\",{\"1\":{\"355\":1}}],[\"jvm会将一部分类\",{\"1\":{\"337\":1}}],[\"jvm\",{\"0\":{\"356\":1},\"1\":{\"275\":2,\"424\":2,\"1055\":1}}],[\"jvm都c++实现中\",{\"1\":{\"182\":1}}],[\"j\",{\"1\":{\"66\":2,\"68\":1,\"78\":1,\"101\":1,\"104\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"148\":1,\"151\":1,\"155\":1,\"156\":1,\"312\":12}}],[\"步骤类似\",{\"1\":{\"79\":1}}],[\"步骤中\",{\"1\":{\"68\":2}}],[\"步来求解\",{\"1\":{\"71\":1}}],[\"步\",{\"1\":{\"63\":1}}],[\"动态地将代码切入到类的指定方法\",{\"1\":{\"1215\":1}}],[\"动态地更新页面中的内容\",{\"1\":{\"1076\":1}}],[\"动态\",{\"0\":{\"902\":1},\"1\":{\"872\":1}}],[\"动态sql在执行时可以进行各种条件判断以及循环拼接等操作\",{\"1\":{\"872\":1}}],[\"动态sql介绍\",{\"0\":{\"872\":1}}],[\"动态sql\",{\"0\":{\"870\":1}}],[\"动态规划\",{\"0\":{\"61\":1}}],[\"动作\",{\"1\":{\"19\":1,\"142\":1}}],[\"动作空间包含两个部分\",{\"1\":{\"14\":1}}],[\"动作空间\",{\"1\":{\"13\":1}}],[\"外连接有三种方式\",{\"1\":{\"769\":1}}],[\"外连接就是专门用于联合查询情景的\",{\"1\":{\"769\":1}}],[\"外连接查询\",{\"0\":{\"769\":1}}],[\"外键约束用于在两个表之间建立参照完整性关系\",{\"1\":{\"748\":1}}],[\"外键\",{\"1\":{\"747\":1,\"748\":2}}],[\"外部属性注入\",{\"0\":{\"1197\":1}}],[\"外部类初始化\",{\"1\":{\"411\":2}}],[\"外部类父类的tostring方法\",{\"1\":{\"408\":1}}],[\"外部类的tosrting方法\",{\"1\":{\"408\":1}}],[\"外部是无法访问到这个内部类的\",{\"1\":{\"408\":1}}],[\"外层\",{\"1\":{\"408\":1}}],[\"外\",{\"1\":{\"55\":1}}],[\"作为父级项目\",{\"1\":{\"1038\":1}}],[\"作为用户id的逻辑外键\",{\"1\":{\"849\":1}}],[\"作为内部资源后\",{\"1\":{\"842\":1}}],[\"作为内部资源\",{\"1\":{\"842\":1}}],[\"作为占位符\",{\"1\":{\"805\":1}}],[\"作为key\",{\"1\":{\"734\":1}}],[\"作为后缀去匹配位置\",{\"1\":{\"490\":1}}],[\"作为前缀去匹配位置\",{\"1\":{\"490\":1}}],[\"作为lambda表达式的方法体实现\",{\"1\":{\"448\":1}}],[\"作为附加功能存在\",{\"1\":{\"376\":1}}],[\"作为结果\",{\"1\":{\"214\":1}}],[\"作为返回值\",{\"1\":{\"171\":1}}],[\"作为参数\",{\"1\":{\"171\":1}}],[\"作为下一步的\",{\"1\":{\"53\":1}}],[\"作用域和provided是一样的\",{\"1\":{\"1018\":1}}],[\"作用域\",{\"1\":{\"1015\":1}}],[\"作用在我们自己的项目中\",{\"1\":{\"1026\":1}}],[\"作用在被导入的项目中\",{\"1\":{\"1025\":1}}],[\"作用在\",{\"0\":{\"883\":1,\"884\":1}}],[\"作用于代码\",{\"1\":{\"361\":1}}],[\"作用\",{\"1\":{\"26\":1,\"603\":1,\"604\":1}}],[\"选择增强方法\",{\"0\":{\"1220\":1}}],[\"选择学分大于3分的科目\",{\"1\":{\"1209\":1}}],[\"选择\",{\"1\":{\"1048\":1}}],[\"选择执行maven目标来手动执行maven命令\",{\"1\":{\"1036\":1}}],[\"选择判断\",{\"0\":{\"874\":1}}],[\"选择对应的动作\",{\"1\":{\"84\":1}}],[\"选择移动方向和选择关联用户\",{\"1\":{\"14\":1}}],[\"选取元素\",{\"0\":{\"1207\":1}}],[\"选取当前状态下最大的\",{\"1\":{\"70\":2}}],[\"选取状态中最大的\",{\"1\":{\"53\":1}}],[\"唯一约束允许有空值\",{\"1\":{\"747\":1}}],[\"唯一约束保证列中所有的非空数据都是唯一的\",{\"1\":{\"747\":1}}],[\"唯一遗憾的是依然不支持区间匹配\",{\"1\":{\"497\":1}}],[\"唯一\",{\"1\":{\"53\":1,\"747\":1,\"748\":1}}],[\"贝尔曼最优公式\",{\"0\":{\"52\":1},\"1\":{\"61\":1}}],[\"贝尔曼公式\",{\"0\":{\"36\":1}}],[\"总分\",{\"1\":{\"222\":1}}],[\"总结\",{\"0\":{\"49\":1}}],[\"总用户的mos取决于无人机的发射功率\",{\"1\":{\"11\":1}}],[\"加粗部分是新增的\",{\"1\":{\"1311\":1}}],[\"加锁再执行一次上述流程\",{\"1\":{\"1301\":1}}],[\"加锁\",{\"1\":{\"1246\":1}}],[\"加了这种注解是可以正常运行的不会报错\",{\"1\":{\"1181\":1}}],[\"加载bean定义\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"加载流程\",{\"0\":{\"1309\":1}}],[\"加载此xml文件中所有的bean定义到bean工厂中\",{\"1\":{\"1296\":1}}],[\"加载后依然会被容器存储\",{\"1\":{\"1130\":1}}],[\"加载类的时候\",{\"1\":{\"1109\":1}}],[\"加入注解\",{\"0\":{\"1291\":1}}],[\"加入到当前事务中\",{\"1\":{\"1281\":1}}],[\"加入\",{\"1\":{\"1096\":1}}],[\"加入解析链\",{\"1\":{\"560\":1}}],[\"加密工具\",{\"0\":{\"659\":1}}],[\"加事务\",{\"1\":{\"534\":1}}],[\"加\",{\"1\":{\"374\":1}}],[\"加权均值\",{\"1\":{\"48\":1}}],[\"加上它们在参数列表中的位置来命名\",{\"1\":{\"843\":1}}],[\"加上\",{\"1\":{\"48\":1}}],[\"和aop一样\",{\"1\":{\"1326\":1}}],[\"和一个m\",{\"1\":{\"1291\":1}}],[\"和hikaripool\",{\"1\":{\"1260\":1}}],[\"和其他语言编写的项目\",{\"1\":{\"1000\":1}}],[\"和方法一样\",{\"1\":{\"995\":1}}],[\"和二级缓存\",{\"1\":{\"882\":1}}],[\"和jdbc其实都差不多\",{\"1\":{\"865\":1}}],[\"和jdbc依赖是一样的\",{\"1\":{\"811\":1}}],[\"和之前insert一样\",{\"1\":{\"863\":1}}],[\"和之前一样\",{\"1\":{\"861\":1}}],[\"和之前javaweb阶段一样\",{\"1\":{\"560\":1}}],[\"和串行化\",{\"1\":{\"782\":1}}],[\"和前面是一样的\",{\"1\":{\"617\":1}}],[\"和多级filter相同\",{\"1\":{\"600\":1}}],[\"和上面相反\",{\"1\":{\"479\":1}}],[\"和上面效果依然是一样的\",{\"1\":{\"451\":1}}],[\"和匿名内部类不同\",{\"1\":{\"414\":1,\"447\":1}}],[\"和iterator一样\",{\"1\":{\"330\":1}}],[\"和reset\",{\"1\":{\"269\":1}}],[\"和\",{\"0\":{\"199\":1,\"318\":1,\"699\":1,\"1147\":1,\"1328\":1},\"1\":{\"48\":1,\"82\":1,\"87\":1,\"101\":1,\"105\":1,\"122\":1,\"123\":1,\"142\":2,\"241\":2,\"245\":4,\"265\":1,\"283\":1,\"386\":1,\"402\":1,\"403\":1,\"528\":1,\"726\":1,\"739\":1,\"836\":1,\"1119\":1}}],[\"和动作\",{\"1\":{\"48\":1}}],[\"和e\",{\"1\":{\"42\":1}}],[\"采取动作\",{\"1\":{\"78\":1}}],[\"采取一个指定的action可以得到的平均return\",{\"1\":{\"48\":1}}],[\"采用mvc思想设计实现\",{\"1\":{\"540\":1}}],[\"采用mos作为用户qos衡量的标准\",{\"1\":{\"10\":1}}],[\"采用梯度下降\",{\"1\":{\"142\":1}}],[\"采用\",{\"1\":{\"79\":1,\"136\":1}}],[\"采用的是the\",{\"1\":{\"14\":1}}],[\"采用q\",{\"1\":{\"13\":1}}],[\"采用基于遗传算法的gak\",{\"1\":{\"13\":1}}],[\"khtml\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"keep\",{\"1\":{\"727\":1,\"1091\":3,\"1096\":3}}],[\"key=\",{\"1\":{\"1136\":3}}],[\"keycolumn\",{\"1\":{\"897\":1}}],[\"keycolumn为数据库中自增的字段名称\",{\"1\":{\"862\":1}}],[\"keycolumn=\",{\"1\":{\"862\":1,\"897\":1}}],[\"keyproperty\",{\"1\":{\"897\":1}}],[\"keyproperty设置为user类中的需要获取自增结果的属性名\",{\"1\":{\"862\":1}}],[\"keyproperty=\",{\"1\":{\"862\":1,\"897\":1}}],[\"key为string类型\",{\"1\":{\"833\":1}}],[\"keyset\",{\"1\":{\"213\":1,\"224\":1,\"582\":1}}],[\"key\",{\"1\":{\"213\":4,\"215\":1,\"216\":15,\"218\":2,\"221\":3,\"222\":1,\"224\":2,\"662\":2,\"747\":4,\"748\":4,\"1207\":1}}],[\"killed\",{\"1\":{\"324\":1}}],[\"k→0∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"k→∞\",{\"1\":{\"47\":1,\"58\":1,\"104\":1}}],[\"k\",{\"1\":{\"97\":2,\"213\":3,\"215\":1,\"216\":8,\"218\":1,\"221\":3,\"222\":2,\"1069\":2}}],[\"k−1\",{\"1\":{\"94\":1}}],[\"k=2\",{\"1\":{\"94\":1}}],[\"k=1∑n​rt+k​\",{\"1\":{\"154\":1}}],[\"k=1∑n​rt+k​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"k=1\",{\"1\":{\"62\":1,\"94\":1,\"97\":1}}],[\"kth\",{\"1\":{\"79\":1}}],[\"kn​∩kn\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"kn​\",{\"1\":{\"8\":1,\"9\":2}}],[\"无效的连接\",{\"1\":{\"1246\":1}}],[\"无需进行修改\",{\"1\":{\"1003\":1}}],[\"无需完整启动项目\",{\"1\":{\"956\":1}}],[\"无需再下载jar文件\",{\"1\":{\"1003\":1}}],[\"无需再次输入账号和密码进行登陆\",{\"1\":{\"685\":1}}],[\"无需再编写finally语句块\",{\"1\":{\"247\":1}}],[\"无参构造方法被覆盖\",{\"1\":{\"378\":1}}],[\"无形参的方法\",{\"1\":{\"364\":1}}],[\"无限循环等待客户端连接\",{\"1\":{\"719\":1}}],[\"无限循环执行\",{\"1\":{\"322\":1}}],[\"无限循环\",{\"1\":{\"301\":1}}],[\"无论发生什么系统错误\",{\"1\":{\"1266\":1}}],[\"无论数据源再高级\",{\"1\":{\"1247\":1}}],[\"无论connection管理方式如何变换\",{\"1\":{\"1247\":1}}],[\"无论上一次定时任务有没有执行完成\",{\"1\":{\"1190\":1}}],[\"无论成员变量的访问权限是什么\",{\"1\":{\"1133\":1}}],[\"无论什么时间\",{\"1\":{\"1084\":1}}],[\"无论什么类型都可以通过我们的方法来进行实体类型映射\",{\"1\":{\"799\":1}}],[\"无论哪个会话失效\",{\"1\":{\"884\":1}}],[\"无论哪个会话对于数据的查询缓存都可以直接被所有会话使用\",{\"1\":{\"883\":1}}],[\"无论哪行进行指定操作都会执行触发器\",{\"1\":{\"781\":1}}],[\"无论哪种方法所获取到的\",{\"1\":{\"339\":1}}],[\"无论我们访问哪个页面\",{\"1\":{\"652\":1}}],[\"无论你是调用方法\",{\"1\":{\"295\":1}}],[\"无论是使用注解或是xml配置\",{\"1\":{\"1237\":1}}],[\"无论是构造器注入还是\",{\"1\":{\"1181\":1}}],[\"无论是通过\",{\"1\":{\"1178\":1}}],[\"无论是什么级别都进行打印\",{\"1\":{\"912\":1}}],[\"无论是一级缓存还是二级缓存\",{\"1\":{\"887\":1}}],[\"无论是我们上节课认识的inmemoryuserdetailsmanager还是现在认识的jdbcuserdetailsmanager\",{\"1\":{\"665\":1}}],[\"无论是否处于事务模式下\",{\"1\":{\"871\":1}}],[\"无论是否登陆\",{\"1\":{\"660\":1,\"1093\":1}}],[\"无论是否出现异常\",{\"1\":{\"424\":1}}],[\"无论是基本类型还是引用类型\",{\"1\":{\"377\":1}}],[\"无论是方法\",{\"1\":{\"365\":1}}],[\"无论是静态方法还是成员方法\",{\"1\":{\"171\":1}}],[\"无论是\",{\"1\":{\"92\":1}}],[\"无法像\",{\"1\":{\"1181\":1}}],[\"无法关闭\",{\"1\":{\"883\":1}}],[\"无法查到\",{\"1\":{\"865\":1}}],[\"无法代表其原本的意思\",{\"1\":{\"836\":1}}],[\"无法再使用之前的and\",{\"1\":{\"680\":1}}],[\"无法还原为原文\",{\"1\":{\"659\":1}}],[\"无法解密\",{\"1\":{\"659\":1}}],[\"无法访问\",{\"1\":{\"605\":1}}],[\"无法继续申请内存了\",{\"1\":{\"421\":1}}],[\"无法显式定义构造函数或初始化块\",{\"1\":{\"412\":1}}],[\"无法直接定义新的属性\",{\"1\":{\"412\":1}}],[\"无法进行修改\",{\"1\":{\"400\":1}}],[\"无法表示一个非常大的数\",{\"1\":{\"386\":1}}],[\"无法使用lambda表达式简化\",{\"1\":{\"323\":1}}],[\"无法使用this关键字\",{\"1\":{\"274\":1}}],[\"无法获取成员变量的值\",{\"1\":{\"274\":1}}],[\"无法reset\",{\"1\":{\"265\":1}}],[\"无关\",{\"1\":{\"152\":1}}],[\"无记忆性\",{\"1\":{\"44\":1}}],[\"无人机需要进行移动\",{\"1\":{\"14\":1}}],[\"无人机的动态移动设计\",{\"0\":{\"14\":1}}],[\"无人机的位置初始化也是随机部署的\",{\"1\":{\"13\":1}}],[\"无人机的3d部署\",{\"0\":{\"13\":1}}],[\"无人机3d部署算法\",{\"1\":{\"13\":1}}],[\"无人机\",{\"1\":{\"13\":1}}],[\"无人机n以可变高度悬停在用户上方\",{\"1\":{\"13\":1}}],[\"无人机n的高度需满足\",{\"1\":{\"9\":1}}],[\"无人机n与用户kn​在时间t的距离表示为\",{\"1\":{\"8\":1}}],[\"无人机往往有更高的los链接概率\",{\"1\":{\"9\":1}}],[\"用注解\",{\"1\":{\"843\":1}}],[\"用java代码就能操作数据库的增删改查\",{\"1\":{\"787\":1}}],[\"用的最多的\",{\"1\":{\"732\":1}}],[\"用的就是\",{\"1\":{\"224\":1}}],[\"用法和list一样\",{\"1\":{\"613\":1}}],[\"用来传回信息给用户\",{\"1\":{\"1058\":1}}],[\"用来排除传递性依赖\",{\"1\":{\"1015\":1}}],[\"用来设置webdatabinder\",{\"1\":{\"602\":1}}],[\"用来描述所有状态的state\",{\"1\":{\"42\":1}}],[\"用\",{\"1\":{\"525\":1,\"545\":1,\"1246\":1}}],[\"用|隔开每种类型即可\",{\"1\":{\"424\":1}}],[\"用了之后就不能用了\",{\"1\":{\"191\":1}}],[\"用于自动注入\",{\"1\":{\"1318\":1}}],[\"用于自动绑定前台请求参数到model中\",{\"1\":{\"602\":1}}],[\"用于处理后续生成的bean对象\",{\"1\":{\"1318\":1}}],[\"用于扫描类路径上的bean\",{\"1\":{\"1318\":1}}],[\"用于后续处理\",{\"1\":{\"1318\":1}}],[\"用于保存实例化完成的\",{\"1\":{\"1301\":1}}],[\"用于保存实例化\",{\"1\":{\"1301\":1}}],[\"用于匹配方法执行连接点\",{\"1\":{\"1219\":1}}],[\"用于表达式\",{\"1\":{\"1219\":1}}],[\"用于表示角色\",{\"1\":{\"692\":1}}],[\"用于表示此枚举的作用域\",{\"1\":{\"363\":1}}],[\"用于去存放我们需要使用的对象\",{\"1\":{\"1119\":1}}],[\"用于下载此文件\",{\"1\":{\"1074\":1}}],[\"用于一台主机搭建多个web站点\",{\"1\":{\"1047\":1}}],[\"用于唯一区别每个项目\",{\"1\":{\"1003\":1}}],[\"用于唯一区分不同实体的的属性\",{\"1\":{\"733\":1}}],[\"用于配置动态sql\",{\"1\":{\"902\":1}}],[\"用于实现分页效果\",{\"1\":{\"835\":1}}],[\"用于定义列是否可以为空\",{\"1\":{\"747\":1}}],[\"用于定义列的值必须满足某些条件\",{\"1\":{\"747\":1}}],[\"用于为列指定默认值\",{\"1\":{\"747\":1}}],[\"用于建立和维护两表之间的关系\",{\"1\":{\"747\":1}}],[\"用于区别于其他实体数据的唯一标记\",{\"1\":{\"734\":1}}],[\"用于存放用户借阅的图书\",{\"1\":{\"853\":1}}],[\"用于存放教师与学生的授课信息\",{\"1\":{\"734\":1}}],[\"用于存放所有教师的数据\",{\"1\":{\"734\":1}}],[\"用于存放所有学生的数据\",{\"1\":{\"734\":1}}],[\"用于防止客户端脚本通过document\",{\"1\":{\"642\":1}}],[\"用于映射\",{\"1\":{\"515\":1}}],[\"用于取代之前比较老旧的httpurlconnection类\",{\"1\":{\"489\":1}}],[\"用于lambda的形参局部变量语法\",{\"0\":{\"487\":1}}],[\"用于便捷操作数组\",{\"1\":{\"432\":1}}],[\"用于规定给定组件必须要出现多少次才能满足匹配的\",{\"1\":{\"403\":1}}],[\"用于计算超大数字\",{\"1\":{\"386\":1}}],[\"用于我们编写自定义的注解\",{\"1\":{\"362\":1}}],[\"用于写入基本数据类型\",{\"1\":{\"286\":1}}],[\"用于指定当前类所处的包的\",{\"1\":{\"277\":1}}],[\"用于简化这样的写法\",{\"1\":{\"247\":1}}],[\"用于记录数组的长\",{\"1\":{\"182\":1}}],[\"用于解释\",{\"1\":{\"76\":1}}],[\"用户在未登录情况下\",{\"1\":{\"1104\":1}}],[\"用户在点击鼠标链接某个万维网文档时\",{\"1\":{\"1042\":1}}],[\"用户发起的http请求\",{\"1\":{\"1056\":1}}],[\"用户发帖会向后端上传以下内容\",{\"1\":{\"643\":1}}],[\"用户可以通过自己输入用户名和密码来登陆\",{\"1\":{\"804\":1}}],[\"用户可以自由发帖\",{\"1\":{\"643\":1}}],[\"用户\",{\"1\":{\"774\":2}}],[\"用户授权\",{\"0\":{\"774\":1}}],[\"用户的发送请求会携带对应的cookie\",{\"1\":{\"1096\":1}}],[\"用户的一个操作实际上就是在访问我们提供的接口\",{\"1\":{\"691\":1}}],[\"用户的速度设为\",{\"1\":{\"14\":1}}],[\"用户提供的密码属于隐私信息\",{\"1\":{\"659\":1}}],[\"用户需要登录之后才能进入\",{\"1\":{\"656\":1}}],[\"用户未登录\",{\"1\":{\"636\":1}}],[\"用户名和密码的表单字段名称\",{\"1\":{\"680\":1}}],[\"用户名或密码错误\",{\"1\":{\"636\":1,\"672\":1,\"692\":1}}],[\"用户名\",{\"1\":{\"636\":1,\"772\":2,\"773\":1,\"804\":1,\"805\":1,\"806\":4,\"824\":2,\"1069\":1,\"1071\":1,\"1242\":1}}],[\"用户登录后\",{\"1\":{\"691\":1}}],[\"用户登录\",{\"1\":{\"635\":1}}],[\"用户上传的文件已保存到\",{\"1\":{\"619\":1}}],[\"用户漫游模型\",{\"1\":{\"14\":1}}],[\"用户区域划分算法\",{\"1\":{\"13\":1}}],[\"用户关联策略\",{\"1\":{\"13\":1}}],[\"用户是保持静态的\",{\"1\":{\"13\":1}}],[\"用户rkn​​在一段时间ts​内的mos总和为\",{\"1\":{\"10\":1}}],[\"求一列的最小值\",{\"1\":{\"765\":1}}],[\"求一列的最大值\",{\"1\":{\"765\":1}}],[\"求一列的平均值\",{\"1\":{\"765\":1}}],[\"求一列的和\",{\"1\":{\"765\":1}}],[\"求一个数的算术平方根\",{\"1\":{\"431\":1}}],[\"求均值的方法\",{\"0\":{\"94\":1}}],[\"求在策略πk​下所有的\",{\"1\":{\"79\":1}}],[\"求解梯度还是很好求的\",{\"1\":{\"142\":1}}],[\"求解给定策略\",{\"1\":{\"111\":1}}],[\"求解当前策略的\",{\"1\":{\"70\":1}}],[\"求解下一步的vk+1​\",{\"1\":{\"63\":1}}],[\"求解方法\",{\"1\":{\"58\":1}}],[\"求解\",{\"0\":{\"58\":1},\"1\":{\"49\":1}}],[\"求解bellman\",{\"1\":{\"45\":1}}],[\"求出其对应状态的\",{\"1\":{\"47\":1}}],[\"求\",{\"1\":{\"41\":1}}],[\"也有着相应的封装\",{\"1\":{\"1272\":1}}],[\"也有可能存储在一些其他的远程仓库\",{\"1\":{\"1009\":1}}],[\"也有可能是给当前线程发送一个其他的信号\",{\"1\":{\"301\":1}}],[\"也有可能是数组存储\",{\"1\":{\"188\":1}}],[\"也无法像单例那样从缓存取\",{\"1\":{\"1181\":1}}],[\"也更加便于控制bean对象的创建\",{\"1\":{\"1169\":1}}],[\"也没什么区别\",{\"1\":{\"1127\":1}}],[\"也不用去调整代码\",{\"1\":{\"1133\":1}}],[\"也不会导致与其相关联的类出现错误\",{\"1\":{\"1117\":1}}],[\"也不知道表单会提交给那个地址\",{\"1\":{\"641\":1}}],[\"也由程序来动态决定\",{\"1\":{\"1116\":1}}],[\"也符合逻辑\",{\"1\":{\"871\":1}}],[\"也放到后面来详细进行讲解\",{\"1\":{\"790\":1}}],[\"也能展示\",{\"1\":{\"615\":1}}],[\"也能执行线程里面定义的内容\",{\"1\":{\"298\":1}}],[\"也支持自动装配\",{\"1\":{\"1139\":1}}],[\"也支持向下转型\",{\"1\":{\"395\":1}}],[\"也支持键值同时匹配\",{\"1\":{\"223\":1}}],[\"也只有这里能进行方法的具体实现了\",{\"1\":{\"474\":1}}],[\"也只有这一个静态的变量或方法\",{\"1\":{\"274\":1}}],[\"也只能表示64bit的数据\",{\"1\":{\"386\":1}}],[\"也会优先选择\",{\"1\":{\"1141\":1}}],[\"也会在数据更新时产生额外建立索引的开销\",{\"1\":{\"780\":1}}],[\"也会返回左边表中的全部数据\",{\"1\":{\"769\":1}}],[\"也会执行\",{\"1\":{\"531\":1}}],[\"也会进行拷贝\",{\"1\":{\"377\":1}}],[\"也会等待获取cpu资源\",{\"1\":{\"299\":1}}],[\"也就印证了它确实是通过aop实现的\",{\"1\":{\"1278\":1}}],[\"也就正式引入到我们这一节的话题了\",{\"1\":{\"1242\":1}}],[\"也就不难理解为什么调用方法会直接得到增强之后的结果了\",{\"1\":{\"1222\":1}}],[\"也就自然找不到main方法了\",{\"1\":{\"355\":1}}],[\"也就是初始化方法\",{\"1\":{\"1307\":1}}],[\"也就是表中所描述的那样\",{\"1\":{\"1281\":1}}],[\"也就是表示层实现\",{\"1\":{\"540\":1}}],[\"也就是直接读取数据库中已经发生更改的内容\",{\"1\":{\"1267\":1}}],[\"也就是直接判断是否为同一个对象\",{\"1\":{\"372\":1}}],[\"也就是池化数据源\",{\"1\":{\"1242\":1}}],[\"也就是datasource接口\",{\"1\":{\"1242\":1}}],[\"也就是织入\",{\"1\":{\"1226\":1}}],[\"也就是新开一个线程执行\",{\"1\":{\"1188\":1}}],[\"也就是新的键值对\",{\"1\":{\"213\":1}}],[\"也就是核心容器模块\",{\"1\":{\"1118\":1}}],[\"也就是需要进行测试的参数列表\",{\"1\":{\"991\":1}}],[\"也就是让所有的mybatis都使用同一个缓存进行数据存取\",{\"1\":{\"888\":1}}],[\"也就是每一个sqlsession都有有一个对应的缓存\",{\"1\":{\"883\":1}}],[\"也就是每一项数据和另一张表的每一项数据都结合一次\",{\"1\":{\"767\":1}}],[\"也就是一级缓存\",{\"1\":{\"883\":1}}],[\"也就是一个完整的过滤链\",{\"1\":{\"704\":1}}],[\"也就是删除\",{\"1\":{\"865\":1}}],[\"也就是标签名称\",{\"1\":{\"819\":1}}],[\"也就是filterchainproxy对象\",{\"1\":{\"706\":1}}],[\"也就是在一个切点位置插入内容\",{\"1\":{\"1215\":1}}],[\"也就是在\",{\"1\":{\"705\":1}}],[\"也就是\",{\"1\":{\"643\":1,\"660\":1,\"1328\":2}}],[\"也就是容器\",{\"1\":{\"546\":1}}],[\"也就是相当于返回了一个指定长度的字符串数组\",{\"1\":{\"522\":1}}],[\"也就是把\",{\"1\":{\"519\":1}}],[\"也就是将多个consumer组合在一起\",{\"1\":{\"511\":1}}],[\"也就是只包含方法的定义\",{\"1\":{\"376\":1}}],[\"也就是构造方法需要的类型\",{\"1\":{\"348\":1}}],[\"也就是结束工作线程\",{\"1\":{\"324\":1}}],[\"也就是异步的\",{\"1\":{\"295\":1}}],[\"也就是同步的\",{\"1\":{\"295\":1}}],[\"也就是同时保存两个方向\",{\"1\":{\"182\":1}}],[\"也就是所在进程的内存空间\",{\"1\":{\"295\":1}}],[\"也就是我们上面编写的方法实现\",{\"1\":{\"1226\":1}}],[\"也就是我们上面编写的servlet路径\",{\"1\":{\"1069\":1}}],[\"也就是我们默认打开的网站\",{\"1\":{\"1047\":1}}],[\"也就是我们刚刚无参\",{\"1\":{\"217\":1}}],[\"也就是我们之前讲解的链表\",{\"1\":{\"182\":1}}],[\"也就是移除对应的键值对\",{\"1\":{\"213\":1}}],[\"也就是说它为bean信息加载提供了后置处理\",{\"1\":{\"1327\":1}}],[\"也就是说它被作为一个统一的访问点\",{\"1\":{\"558\":1}}],[\"也就是说一会会在beanfactory初始化完成之后进行后置处理\",{\"1\":{\"1318\":1}}],[\"也就是说会使用类型进行配\",{\"1\":{\"1174\":1}}],[\"也就是说怎么让这个请求顺利通过呢\",{\"1\":{\"1103\":1}}],[\"也就是说在服务器启动后\",{\"1\":{\"1054\":1}}],[\"也就是说在组中用于区分于其他项目的标记\",{\"1\":{\"1003\":1}}],[\"也就是说保证整个通信是稳定的\",{\"1\":{\"1042\":1}}],[\"也就是说不打印\",{\"1\":{\"951\":1}}],[\"也就是说没有任何日志级别的值大于它\",{\"1\":{\"912\":1}}],[\"也就是说mybatis知道我们对数据库里面的数据进行了修改\",{\"1\":{\"883\":1}}],[\"也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了\",{\"1\":{\"841\":1}}],[\"也就是说这里之后就与delegatingfilterproxy没有任何关系了\",{\"1\":{\"710\":1}}],[\"也就是说这个方法只有定义\",{\"1\":{\"375\":1}}],[\"也就是说我们导入mybatis之后想用什么日志框架再自己加就可以了\",{\"1\":{\"1025\":1}}],[\"也就是说我们第二次查询不仅压根就没执行sql语句\",{\"1\":{\"883\":1}}],[\"也就是说我们可以在登陆之后的一段时间内\",{\"1\":{\"685\":1}}],[\"也就是说我们直接以代码的形式配置我们网站的用户和密码\",{\"1\":{\"657\":1}}],[\"也就是说现在的请求参数包含在了请求路径中\",{\"1\":{\"589\":1}}],[\"也就是说此方法不仅仅可以只用于处理某一个请求路径\",{\"1\":{\"569\":1}}],[\"也就是说依然是采用的object中的默认实现\",{\"1\":{\"393\":1}}],[\"也就是说数组的长度一旦确定\",{\"1\":{\"393\":1}}],[\"也就是说只能同时执行一个任务\",{\"1\":{\"295\":1}}],[\"也就是说只要整个哈希表用了75\",{\"1\":{\"217\":1}}],[\"也就是说需要的时候\",{\"1\":{\"228\":1}}],[\"也就是说对于刚访问过的元素\",{\"1\":{\"218\":1}}],[\"也就是说\",{\"1\":{\"212\":1,\"224\":1,\"274\":1,\"329\":1,\"451\":1,\"522\":1,\"558\":1,\"597\":1,\"609\":1,\"691\":1,\"1016\":1,\"1024\":1,\"1042\":1,\"1083\":1,\"1109\":3,\"1116\":1,\"1129\":1,\"1132\":1,\"1215\":1,\"1242\":1,\"1268\":1,\"1273\":1,\"1281\":1}}],[\"也就是对遍历的每一个元素进行的操作\",{\"1\":{\"192\":1}}],[\"也包含大量的并行方法\",{\"1\":{\"330\":1}}],[\"也存在大量的transient关键字\",{\"1\":{\"290\":1}}],[\"也需要使用到\",{\"1\":{\"468\":1}}],[\"也需要考虑重写\",{\"1\":{\"241\":1}}],[\"也需要相同\",{\"1\":{\"241\":1}}],[\"也可被用于构建和管理各种项目\",{\"1\":{\"1000\":1}}],[\"也可能是integer类型\",{\"1\":{\"437\":1}}],[\"也可能是小数\",{\"1\":{\"172\":1}}],[\"也可以设定这样的父子关系\",{\"1\":{\"1298\":1}}],[\"也可以拿到父工厂的\",{\"1\":{\"1298\":1}}],[\"也可以修改参数之后调用proceed\",{\"1\":{\"1224\":1}}],[\"也可以代表包下的所有类\",{\"1\":{\"1219\":1}}],[\"也可以写成这种表达式而已\",{\"1\":{\"1203\":1}}],[\"也可以实现自动装配\",{\"1\":{\"1175\":1}}],[\"也可以在继承的基础上单独配置\",{\"1\":{\"1150\":1}}],[\"也可以在类上添加\",{\"1\":{\"615\":1}}],[\"也可以指定为对应的参数名称\",{\"1\":{\"1135\":1}}],[\"也可以指定目标开放反射\",{\"1\":{\"466\":1}}],[\"也可以起别名\",{\"1\":{\"1128\":1}}],[\"也可以进行某个扩展名称的匹配\",{\"1\":{\"1061\":1}}],[\"也可以用init\",{\"1\":{\"1158\":1}}],[\"也可以用于其他的通信\",{\"1\":{\"1053\":1}}],[\"也可以用来将我们的类进行分类\",{\"1\":{\"277\":1}}],[\"也可以根本版本号进行选择\",{\"1\":{\"1003\":1}}],[\"也可以作为参数来源\",{\"1\":{\"995\":1}}],[\"也可以嵌套select\",{\"1\":{\"855\":1}}],[\"也可以为它起个别名\",{\"1\":{\"832\":1}}],[\"也可以通过excute\",{\"1\":{\"791\":1}}],[\"也可以不使用配置文件\",{\"1\":{\"824\":1}}],[\"也可以不带密码\",{\"1\":{\"772\":1}}],[\"也可以不同\",{\"1\":{\"165\":1}}],[\"也可以存储任意数量字符串\",{\"1\":{\"746\":1}}],[\"也可以自定义\",{\"1\":{\"686\":1}}],[\"也可以使用传统的即用即连的方式获取connection对象\",{\"1\":{\"1242\":1}}],[\"也可以使用其他属性来进行匹配\",{\"1\":{\"1219\":1}}],[\"也可以使用其他类型\",{\"1\":{\"826\":1}}],[\"也可以使用初始化参数来实现\",{\"1\":{\"1085\":1}}],[\"也可以使用之前的\",{\"1\":{\"986\":1}}],[\"也可以使用cdata\",{\"1\":{\"818\":1}}],[\"也可以使用rollback\",{\"1\":{\"806\":1}}],[\"也可以使用\",{\"1\":{\"513\":1,\"744\":1,\"977\":1,\"1219\":1}}],[\"也可以使用访问顺序\",{\"1\":{\"218\":1}}],[\"也可以像这样\",{\"1\":{\"497\":1}}],[\"也可以象征性\",{\"1\":{\"401\":1}}],[\"也可以被子类访问\",{\"1\":{\"278\":1}}],[\"也可以理解为是所有对象共享的内容\",{\"1\":{\"274\":1}}],[\"也可以直接给个connection对象\",{\"1\":{\"1273\":1}}],[\"也可以直接填入固定值\",{\"1\":{\"1200\":1}}],[\"也可以直接扫描整个包下的所有实体类\",{\"1\":{\"832\":1}}],[\"也可以直接像下面这样给塞到表单里\",{\"1\":{\"660\":1}}],[\"也可以直接访问\",{\"1\":{\"658\":1}}],[\"也可以直接写入byte\",{\"1\":{\"249\":1}}],[\"也可以直接在定义时赋值\",{\"1\":{\"166\":1}}],[\"也可以控制读取的数量\",{\"1\":{\"248\":1}}],[\"也可以精准匹配\",{\"1\":{\"223\":1}}],[\"也可以当做栈来使用\",{\"1\":{\"201\":1}}],[\"也可以当做双端队列使用\",{\"1\":{\"182\":1}}],[\"也可以从后向前\",{\"1\":{\"194\":1}}],[\"也可以利用静态代码块\",{\"1\":{\"182\":1}}],[\"也可以采用基于\",{\"1\":{\"156\":1}}],[\"也可以是一段文本内容\",{\"1\":{\"819\":1}}],[\"也可以是一个简单的值\",{\"1\":{\"1133\":1}}],[\"也可以是一个ip地址\",{\"1\":{\"1042\":1}}],[\"也可以是一个\",{\"1\":{\"604\":1}}],[\"也可以是继承自其他抽象类的子类或是实现其他接口的类等\",{\"1\":{\"504\":1}}],[\"也可以是绝对路径\",{\"1\":{\"255\":1}}],[\"也可以是向量\",{\"1\":{\"101\":1}}],[\"也可以是无限长的trajectory\",{\"1\":{\"19\":1}}],[\"也是使用jdk的动态代理实现的\",{\"1\":{\"1247\":1}}],[\"也是spring框架的核心概念之一\",{\"1\":{\"1132\":1}}],[\"也是现代软件开发中很致命的问题\",{\"1\":{\"1116\":1}}],[\"也是整个项目的所有依赖\",{\"1\":{\"1002\":1}}],[\"也是可用的日志级别中最大的\",{\"1\":{\"910\":1}}],[\"也是通过迭代器的形式去进行数据的读取\",{\"1\":{\"836\":1}}],[\"也是我们需要给的\",{\"1\":{\"510\":1}}],[\"也是帮助我们实现好了的\",{\"1\":{\"501\":1}}],[\"也是无法进行修改的\",{\"1\":{\"475\":1}}],[\"也是一样的\",{\"1\":{\"408\":1}}],[\"也是以对象的形式存在的\",{\"1\":{\"392\":1}}],[\"也是支持拆箱的\",{\"1\":{\"384\":1}}],[\"也是用于我们自己处理后置动作的\",{\"1\":{\"1311\":1}}],[\"也是用于唤醒\",{\"1\":{\"318\":1}}],[\"也是用到了泛型\",{\"1\":{\"171\":1}}],[\"也是同样的值\",{\"1\":{\"311\":1}}],[\"也是更加推荐的做法\",{\"1\":{\"301\":1}}],[\"也是程序执行的最小单位\",{\"1\":{\"295\":1}}],[\"也是不同的两个类\",{\"1\":{\"277\":1}}],[\"也是由缓冲区处理\",{\"1\":{\"260\":1}}],[\"也是根据\",{\"1\":{\"241\":1}}],[\"也是头结点数组\",{\"1\":{\"215\":1}}],[\"也是1\",{\"1\":{\"182\":1}}],[\"也是尽量使用小写字母开头的单词\",{\"1\":{\"162\":1}}],[\"也称为\",{\"1\":{\"40\":1}}],[\"核心配置\",{\"0\":{\"1002\":1}}],[\"核心部分\",{\"0\":{\"918\":1}}],[\"核心\",{\"1\":{\"553\":1}}],[\"核心方法是accept\",{\"1\":{\"510\":1}}],[\"核心内容\",{\"0\":{\"37\":1}}],[\"核心思想\",{\"1\":{\"25\":1,\"76\":1}}],[\"中被管理\",{\"1\":{\"1328\":1}}],[\"中实现的\",{\"1\":{\"1320\":1}}],[\"中提供的静态常量\",{\"1\":{\"1196\":1}}],[\"中修改过期时间\",{\"1\":{\"1097\":1}}],[\"中写对应的登录逻辑\",{\"1\":{\"1072\":1}}],[\"中装好\",{\"1\":{\"1071\":1}}],[\"中重写对应的请求方式\",{\"1\":{\"1059\":1}}],[\"中能够线程安全地获取到用户上下文认证信息\",{\"1\":{\"714\":1}}],[\"中包含的属性\",{\"1\":{\"1167\":1}}],[\"中包含\",{\"1\":{\"714\":1}}],[\"中文释义为表现层状态转换\",{\"1\":{\"589\":1}}],[\"中国加油\",{\"1\":{\"515\":1}}],[\"中处理集合的关键抽象概念\",{\"1\":{\"513\":1}}],[\"中间使用等号进行连接\",{\"1\":{\"936\":1,\"1197\":1}}],[\"中间可以添加一个断言\",{\"1\":{\"478\":1}}],[\"中间操作不会立即执行\",{\"1\":{\"515\":1}}],[\"中间操作\",{\"1\":{\"228\":1,\"515\":1}}],[\"中导入\",{\"1\":{\"461\":1}}],[\"中方法\",{\"1\":{\"412\":1}}],[\"中除了\",{\"1\":{\"403\":1}}],[\"中字符的所有字符\",{\"1\":{\"403\":1}}],[\"中所有的\",{\"1\":{\"403\":1}}],[\"中找不到\",{\"1\":{\"355\":1}}],[\"中途是不允许转换的\",{\"1\":{\"329\":2}}],[\"中断\",{\"0\":{\"301\":1}}],[\"中使用一个类之前\",{\"1\":{\"275\":1}}],[\"中定义的\",{\"1\":{\"375\":1}}],[\"中定义的差不多\",{\"1\":{\"204\":1}}],[\"中定义要在完成之后释放的资源\",{\"1\":{\"247\":1}}],[\"中不存在时\",{\"1\":{\"214\":1}}],[\"中不断切换\",{\"1\":{\"82\":1}}],[\"中无法添加相同的键\",{\"1\":{\"214\":1}}],[\"中存取元素\",{\"1\":{\"205\":1}}],[\"中直接继承的\",{\"1\":{\"204\":1}}],[\"中直接根据\",{\"1\":{\"115\":1}}],[\"中已经帮我们将常用的集合类型都实现好了\",{\"1\":{\"180\":1}}],[\"中取出一定数量的样本\",{\"1\":{\"142\":1}}],[\"中采用一个\",{\"1\":{\"142\":1}}],[\"中的beanname之前加上\",{\"1\":{\"1328\":1}}],[\"中的元素组合起来\",{\"1\":{\"521\":1}}],[\"中的前三个\",{\"1\":{\"403\":1}}],[\"中的所有操作\",{\"1\":{\"782\":1}}],[\"中的所有字符\",{\"1\":{\"403\":1}}],[\"中的所有\",{\"1\":{\"403\":1}}],[\"中的两个\",{\"1\":{\"403\":1}}],[\"中的某个对象\",{\"1\":{\"205\":1}}],[\"中的\",{\"0\":{\"525\":1},\"1\":{\"88\":1,\"142\":2,\"403\":3}}],[\"中第一次出现的\",{\"1\":{\"81\":1}}],[\"中求解\",{\"1\":{\"68\":1}}],[\"中涉及的\",{\"1\":{\"62\":1}}],[\"中\",{\"0\":{\"99\":1,\"356\":1},\"1\":{\"29\":1,\"71\":1,\"77\":1,\"88\":1,\"92\":1,\"137\":1,\"142\":1,\"182\":1,\"213\":1,\"253\":1,\"311\":1,\"386\":1,\"399\":1,\"412\":1,\"413\":1,\"431\":1,\"432\":1,\"522\":2,\"531\":1,\"788\":1,\"862\":1,\"1042\":1,\"1056\":1}}],[\"重置标记\",{\"1\":{\"1320\":1}}],[\"重点是\",{\"1\":{\"1219\":1}}],[\"重点在这里\",{\"1\":{\"626\":2,\"705\":1}}],[\"重定向之后\",{\"1\":{\"1083\":1}}],[\"重定向地址栏会发生改变\",{\"1\":{\"1083\":1}}],[\"重定向是两次请求\",{\"1\":{\"1083\":1}}],[\"重定向属于2次请求\",{\"1\":{\"1083\":1}}],[\"重定向会使得浏览器去重新请求一个页面\",{\"1\":{\"1083\":1}}],[\"重定向无法携带数据\",{\"1\":{\"1083\":1}}],[\"重定向\",{\"0\":{\"1082\":1}}],[\"重定向与请求转发\",{\"0\":{\"1081\":1}}],[\"重定向和请求转发也非常简单\",{\"1\":{\"587\":1}}],[\"重定向和请求转发\",{\"0\":{\"587\":1}}],[\"重启服务器\",{\"1\":{\"1047\":1}}],[\"重启idea\",{\"1\":{\"811\":1}}],[\"重新再来运行\",{\"1\":{\"1259\":1}}],[\"重新开启自动提交\",{\"1\":{\"806\":1}}],[\"重新开放为普通类\",{\"1\":{\"504\":1}}],[\"重新输入\",{\"1\":{\"531\":1}}],[\"重新修改为\",{\"1\":{\"46\":1}}],[\"重写方法可以添加\",{\"1\":{\"373\":1}}],[\"重写方法要求与父类的定义完全一致\",{\"1\":{\"373\":2}}],[\"重复测试\",{\"0\":{\"990\":1}}],[\"重复和参数化测试\",{\"0\":{\"989\":1}}],[\"重复\",{\"0\":{\"929\":1}}],[\"重复字符串\",{\"1\":{\"228\":1}}],[\"重复步骤\",{\"1\":{\"13\":1}}],[\"重要性采样\",{\"0\":{\"30\":1},\"1\":{\"29\":1}}],[\"382\",{\"1\":{\"1283\":1}}],[\"343\",{\"1\":{\"1278\":1}}],[\"34<\",{\"1\":{\"611\":1,\"616\":1}}],[\"39\",{\"1\":{\"929\":2}}],[\"37\",{\"1\":{\"908\":1,\"919\":1}}],[\"372\",{\"1\":{\"746\":2}}],[\"32767\",{\"1\":{\"746\":1}}],[\"32768\",{\"1\":{\"746\":1}}],[\"3nf\",{\"0\":{\"738\":1}}],[\"3nf对依赖关系进一步加强\",{\"1\":{\"735\":1}}],[\"362\",{\"1\":{\"1283\":1}}],[\"36<\",{\"1\":{\"1008\":1}}],[\"36\",{\"1\":{\"727\":2,\"1091\":2,\"1096\":2}}],[\"3600\",{\"1\":{\"687\":1}}],[\"3306\",{\"1\":{\"664\":1,\"788\":1,\"796\":1,\"904\":1,\"936\":1,\"1017\":1,\"1255\":1,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"31<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"30秒内都不需要登陆\",{\"1\":{\"1093\":1}}],[\"302\",{\"0\":{\"1082\":1},\"1\":{\"1082\":2,\"1091\":1,\"1096\":1}}],[\"304\",{\"1\":{\"1059\":1}}],[\"30<\",{\"1\":{\"1025\":2}}],[\"300\",{\"1\":{\"910\":1}}],[\"3000\",{\"1\":{\"301\":1,\"322\":2,\"331\":1,\"721\":1,\"888\":1,\"1188\":2,\"1225\":1}}],[\"30\",{\"1\":{\"431\":1,\"843\":1,\"1093\":2}}],[\"3的结果\",{\"1\":{\"386\":1}}],[\"3\",{\"0\":{\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":2,\"41\":1,\"45\":1,\"47\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"79\":1,\"83\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":2,\"89\":2,\"98\":1,\"100\":1,\"101\":1,\"102\":1,\"105\":2,\"106\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":2,\"124\":1,\"139\":1,\"155\":1,\"197\":1,\"198\":1,\"266\":1,\"760\":1,\"1145\":1,\"1278\":1,\"1346\":1,\"1355\":1},\"1\":{\"62\":2,\"70\":1,\"94\":1,\"97\":1,\"101\":1,\"171\":4,\"207\":2,\"214\":2,\"228\":6,\"234\":1,\"235\":1,\"236\":1,\"237\":3,\"330\":2,\"386\":1,\"396\":1,\"397\":1,\"401\":1,\"403\":1,\"431\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"521\":1,\"528\":1,\"788\":1,\"799\":1,\"824\":3,\"826\":2,\"873\":1,\"876\":2,\"902\":4,\"974\":1,\"991\":1,\"1017\":4,\"1071\":2,\"1204\":1,\"1208\":2,\"1209\":1,\"1242\":2,\"1245\":1,\"1255\":2,\"1260\":1,\"1317\":1}}],[\"3d部署和移动问题\",{\"1\":{\"5\":1}}],[\"3d位置进行优化处理\",{\"1\":{\"5\":1}}],[\"只允许静态资源和登陆页面请求通过\",{\"1\":{\"1104\":1}}],[\"只允许我们自己写的类继承a\",{\"1\":{\"503\":1}}],[\"只用作开发阶段测试使用\",{\"1\":{\"1017\":1}}],[\"只在测试时有效\",{\"1\":{\"1016\":1}}],[\"只仅用于测试\",{\"1\":{\"1001\":1}}],[\"只启用了本地的会话缓存\",{\"1\":{\"883\":1}}],[\"只取前n个结果\",{\"1\":{\"766\":1}}],[\"只查询不重复的值\",{\"1\":{\"762\":1}}],[\"只删除指定的数据\",{\"1\":{\"756\":1}}],[\"只留下主页面\",{\"1\":{\"658\":1}}],[\"只包含视图名称即可\",{\"1\":{\"558\":1}}],[\"只使用上面的基本配置类\",{\"1\":{\"552\":1}}],[\"只读的缓存会给所有调用者返回相同的缓存对象\",{\"1\":{\"884\":1}}],[\"只读\",{\"1\":{\"884\":1}}],[\"只读整数\",{\"1\":{\"531\":1}}],[\"只读集合\",{\"1\":{\"236\":1}}],[\"只需添加exclusion标签即可\",{\"1\":{\"1026\":1}}],[\"只需添加一个\",{\"1\":{\"959\":1}}],[\"只需添加一个无参构造或是全参构造即可\",{\"1\":{\"841\":1}}],[\"只需在一个类上添加一个\",{\"1\":{\"561\":1}}],[\"只需留下我们需要具体实现的方法体\",{\"1\":{\"446\":1}}],[\"只需要key\",{\"1\":{\"1208\":1}}],[\"只需要创建一个配置类就可以了\",{\"1\":{\"1166\":1}}],[\"只需要修改这里的class即可\",{\"1\":{\"1133\":1}}],[\"只需要修改usecache属性即可\",{\"1\":{\"886\":1}}],[\"只需要变动一下bean的类型就可以\",{\"1\":{\"1133\":1}}],[\"只需要实现filter接口\",{\"1\":{\"1102\":1}}],[\"只需要实现comparator方法即可\",{\"1\":{\"449\":1}}],[\"只需要调用一个方法即可\",{\"1\":{\"1082\":1}}],[\"只需要组名和项目名称\",{\"1\":{\"1026\":1}}],[\"只需要填写和这边一样的坐标\",{\"1\":{\"1023\":1}}],[\"只需要添加\",{\"1\":{\"994\":1,\"1125\":1,\"1177\":1}}],[\"只需要添加一个\",{\"1\":{\"950\":1}}],[\"只需要添加几个注解\",{\"1\":{\"810\":1}}],[\"只需要提供实现对应的\",{\"1\":{\"708\":1}}],[\"只需要决定用户是否能够访问对应的servlet即可\",{\"1\":{\"691\":1}}],[\"只需要写路径就可以了\",{\"1\":{\"680\":1}}],[\"只需要将one或是many参数进行填写即可\",{\"1\":{\"901\":1}}],[\"只需要将其注册为\",{\"1\":{\"668\":1}}],[\"只需要将原本的流作为构造参数传入bufferedinputstream即可\",{\"1\":{\"262\":1}}],[\"只需要去实现这个loaduserbyusername方法\",{\"1\":{\"668\":1}}],[\"只需要一个前缀就可以实现重定向和请求转发\",{\"1\":{\"587\":1}}],[\"只需要用\",{\"1\":{\"376\":1}}],[\"只需要把类文件传递即可\",{\"1\":{\"356\":1}}],[\"只需要在配置类添加\",{\"1\":{\"1274\":1}}],[\"只需要在web\",{\"1\":{\"1086\":1}}],[\"只需要在后面填写路径即可\",{\"1\":{\"1047\":1}}],[\"只需要在security配置类中注册一个bean即可\",{\"1\":{\"658\":1}}],[\"只需要在stream中一气呵成\",{\"1\":{\"476\":1}}],[\"只需要在比较后面加个变量名\",{\"1\":{\"499\":1}}],[\"只需要在类名前面添加包名就行了\",{\"1\":{\"277\":1}}],[\"只需要在泛型变量的后面添加extends关键字即可指定上界\",{\"1\":{\"172\":1}}],[\"只需要存储\",{\"1\":{\"224\":2}}],[\"只需要各个集合类根据自己的情况进行对应实现就行了\",{\"1\":{\"188\":1}}],[\"只需要\",{\"1\":{\"162\":1,\"1231\":1}}],[\"只需要保证\",{\"1\":{\"26\":1}}],[\"只添加一个元素\",{\"1\":{\"350\":1}}],[\"只适合快速搭建demo使用\",{\"1\":{\"666\":1}}],[\"只适合打打杂\",{\"1\":{\"329\":1}}],[\"只适用于默认无参构造\",{\"1\":{\"348\":1}}],[\"只能从singletonfactory中获取了\",{\"1\":{\"1301\":1}}],[\"只能放弃了\",{\"1\":{\"1246\":1}}],[\"只能卡住了\",{\"1\":{\"1246\":1}}],[\"只能做调整\",{\"1\":{\"883\":1}}],[\"只能由触发器使用\",{\"1\":{\"781\":1}}],[\"只能用于日常管理\",{\"1\":{\"691\":1}}],[\"只能选择其一\",{\"1\":{\"504\":1}}],[\"只能调试\",{\"1\":{\"500\":1}}],[\"只能对其进行继承\",{\"1\":{\"412\":1}}],[\"只能表示内部类对象\",{\"1\":{\"408\":1}}],[\"只能重新创建\",{\"1\":{\"393\":1,\"400\":1}}],[\"只能\",{\"1\":{\"386\":1}}],[\"只能内部使用\",{\"1\":{\"378\":1}}],[\"只能作为一个附属功能加在主体上\",{\"1\":{\"376\":1}}],[\"只能在构造函数进行赋值\",{\"1\":{\"374\":1}}],[\"只能得到\",{\"1\":{\"373\":1,\"375\":1}}],[\"只能使用最后一种隔离级别串行化来实现了\",{\"1\":{\"1271\":1}}],[\"只能使用前者完成注册\",{\"1\":{\"1177\":1}}],[\"只能使用这种嵌套查询来完成复杂查询操作\",{\"1\":{\"901\":1}}],[\"只能使用\",{\"1\":{\"413\":1}}],[\"只能使用匿名内部类\",{\"1\":{\"323\":1}}],[\"只能使用获取内容相关的方法\",{\"1\":{\"182\":1}}],[\"只能被类本身和同包中的其他类访问\",{\"1\":{\"278\":1}}],[\"只保留mapper相关的接口\",{\"1\":{\"893\":1}}],[\"只保留方法的定义\",{\"1\":{\"375\":1}}],[\"只保留之后的1个字符\",{\"1\":{\"265\":2}}],[\"只保留小于0的数字\",{\"1\":{\"228\":1}}],[\"只保留当前集合中在给定集合中出现的元素\",{\"1\":{\"180\":1}}],[\"只获取前10个数字\",{\"1\":{\"228\":1}}],[\"只放行前两个元素\",{\"1\":{\"228\":1}}],[\"只有实现此接口\",{\"1\":{\"1231\":1}}],[\"只有写在student中才是正确的\",{\"1\":{\"1158\":1}}],[\"只有了解了spring的核心技术\",{\"1\":{\"1118\":1}}],[\"只有两个过滤器全部经过之后\",{\"1\":{\"1103\":1}}],[\"只有过滤器允许通过的请求\",{\"1\":{\"1101\":1}}],[\"只有授权的用户\",{\"1\":{\"1101\":1}}],[\"只有完成登陆的用户才有资格访问首页\",{\"1\":{\"1097\":1}}],[\"只有比较新的版本才支持此注解\",{\"1\":{\"1054\":1}}],[\"只有commit了\",{\"1\":{\"884\":1}}],[\"只有提交之后\",{\"1\":{\"806\":1}}],[\"只有innodb引擎支持事务\",{\"1\":{\"782\":1}}],[\"只有sysadmin\",{\"1\":{\"744\":1}}],[\"只有具有以下角色的用户才能访问路径\",{\"1\":{\"692\":1}}],[\"只有返回true才会继续\",{\"1\":{\"595\":1}}],[\"只有经过层层的过滤器才可以成功到达servlet\",{\"1\":{\"593\":1}}],[\"只有一个参数\",{\"1\":{\"521\":1}}],[\"只有有一个元素不匹配传入的条件\",{\"1\":{\"520\":1}}],[\"只有等到终端操作的时候\",{\"1\":{\"515\":1}}],[\"只有我们明确需要的模块才会导入依赖库\",{\"1\":{\"461\":1}}],[\"只有这一个抽象方法\",{\"1\":{\"447\":1}}],[\"只有抽象类中的抽象方法\",{\"1\":{\"376\":1}}],[\"只有是当前类型的对象\",{\"1\":{\"373\":1}}],[\"只有bootstarpclassloader都没有加载的类\",{\"1\":{\"355\":1}}],[\"只有在真正第一次使用时才会创建对象\",{\"1\":{\"1130\":1}}],[\"只有在获取时才会被创建\",{\"1\":{\"1129\":1}}],[\"只有在运行的时候才知道会不会出错\",{\"1\":{\"421\":1}}],[\"只有在你使用到外部类的静态变量或方法后\",{\"1\":{\"411\":1}}],[\"只有在类不在同一个包下时才需要进行导入\",{\"1\":{\"277\":1}}],[\"只有在不存在相同键的键值对时才会存放\",{\"1\":{\"214\":1}}],[\"只有同时匹配时才移除\",{\"1\":{\"223\":1}}],[\"只有键和值都匹配时\",{\"1\":{\"223\":1}}],[\"只有可能是前面出现了相同键的情况\",{\"1\":{\"216\":1}}],[\"只有当满足条件时再开始通过\",{\"1\":{\"479\":1}}],[\"只有当对象作为锁时\",{\"1\":{\"318\":1}}],[\"只有当样本全部收集完才能估计\",{\"1\":{\"94\":1}}],[\"只有当所有\",{\"1\":{\"82\":1}}],[\"只有当所有东西都是确定性的\",{\"1\":{\"41\":1}}],[\"只会得到一个null\",{\"1\":{\"1211\":1}}],[\"只会根据类型寻找\",{\"1\":{\"1175\":1}}],[\"只会返回两个表满足条件的交集部分\",{\"1\":{\"769\":1}}],[\"只会从笛卡尔积的结果中得到满足条件的数据\",{\"1\":{\"767\":1}}],[\"只会复制对象的地址\",{\"1\":{\"377\":1}}],[\"只会存放在线程自己的工作空间中\",{\"1\":{\"319\":1}}],[\"只会删除排在前面的第一个元素\",{\"1\":{\"182\":1}}],[\"只会调用equals方法进行判断是否为指定元素\",{\"1\":{\"182\":1}}],[\"只要能够处理好对象之间的引用关系\",{\"1\":{\"1301\":1}}],[\"只要原型\",{\"1\":{\"1181\":1}}],[\"只要容器没有被销毁\",{\"1\":{\"1129\":1}}],[\"只要filter列表不是空\",{\"1\":{\"708\":1}}],[\"只要满足条件的元素才会留下\",{\"1\":{\"699\":1}}],[\"只要不具备表达式中指定的访问权限\",{\"1\":{\"697\":1}}],[\"只要拥有某权限的用户\",{\"1\":{\"691\":1}}],[\"只要我们的浏览器携带此cookie访问服务器\",{\"1\":{\"1095\":1}}],[\"只要我们不清理浏览器的cookie\",{\"1\":{\"686\":1}}],[\"只要我们绕过这个阶段\",{\"1\":{\"237\":1}}],[\"只要此会话的用户执行了登录操作\",{\"1\":{\"641\":1}}],[\"只要用户携带此cookie访问我们的网站\",{\"1\":{\"641\":1}}],[\"只要你在上面登陆了你的qq账号\",{\"1\":{\"641\":1}}],[\"只要匹配一律拦截\",{\"1\":{\"596\":1}}],[\"只要是此用户发起的请求\",{\"1\":{\"1096\":1}}],[\"只要是使用这个mapper的会话\",{\"1\":{\"884\":1}}],[\"只要是由spring管理的bean都可以使用注解形式来控制权限\",{\"1\":{\"697\":1}}],[\"只要是同一个会话\",{\"1\":{\"588\":1}}],[\"只要是实现这个接口的类\",{\"1\":{\"376\":1}}],[\"只要清理浏览器的cookie\",{\"1\":{\"588\":1}}],[\"只要有一个元素匹配传入的条件\",{\"1\":{\"520\":2}}],[\"只要重写的内容中不会抛出对应的异常我们可以直接省去\",{\"1\":{\"423\":1}}],[\"只要一个类的父类或者自身有对应方法\",{\"1\":{\"376\":1}}],[\"只要判断成功\",{\"1\":{\"182\":1}}],[\"只要\",{\"1\":{\"181\":1}}],[\"只给出了梯度的公式\",{\"1\":{\"155\":1}}],[\"只不过在一开始\",{\"1\":{\"1296\":1}}],[\"只不过在spring中用的不是很频繁罢了\",{\"1\":{\"1191\":1}}],[\"只不过现在变成了由java代码为我们提供bean配置\",{\"1\":{\"1169\":1}}],[\"只不过现在我们将依赖注入的时机提前到了对象构造时\",{\"1\":{\"1134\":1}}],[\"只不过现在的方向变为我们向文件里写入内容\",{\"1\":{\"249\":1}}],[\"只不过并没有写具体操作\",{\"1\":{\"1059\":1}}],[\"只不过格式稍微有点炸裂\",{\"1\":{\"951\":1}}],[\"只不过由于idea不支持这种语法的识别\",{\"1\":{\"902\":1}}],[\"只不过使用起来和我们之前jdbc中的resultset比较类似\",{\"1\":{\"836\":1}}],[\"只不过这里的继承并不是类的继承\",{\"1\":{\"1149\":1}}],[\"只不过这种操作实际上是治标不治本的\",{\"1\":{\"888\":1}}],[\"只不过这种方式只适用于我们自己编写类的情况\",{\"1\":{\"1177\":1}}],[\"只不过这种方式查询的话\",{\"1\":{\"843\":1}}],[\"只不过这种方式在大部分请情况下还是用的比较少\",{\"1\":{\"836\":1}}],[\"只不过这和我们之前说的map不太一样\",{\"1\":{\"836\":1}}],[\"只不过这个方法并不是静态的\",{\"1\":{\"451\":1}}],[\"只不过这个锁不用你去给\",{\"1\":{\"312\":1}}],[\"只不过是使用了过滤器机制进行实现罢了\",{\"1\":{\"714\":1}}],[\"只不过会删除其他不符合条件的\",{\"1\":{\"479\":1}}],[\"只不过默认情况下没有开启断言\",{\"1\":{\"425\":1}}],[\"只不过还能更简单\",{\"1\":{\"415\":1}}],[\"只不过意义不大\",{\"1\":{\"412\":1}}],[\"只不过它比较特殊\",{\"1\":{\"401\":1}}],[\"只不过它的用法比较特殊\",{\"1\":{\"360\":1}}],[\"只不过它只是代表这个文件\",{\"1\":{\"255\":1}}],[\"只不过它是一个双向链表\",{\"1\":{\"182\":1}}],[\"只不过它是采用的链式实现\",{\"1\":{\"182\":1}}],[\"只不过多了一些特殊的东西\",{\"1\":{\"215\":1}}],[\"只不过hashmap中没有设计头结点\",{\"1\":{\"215\":1}}],[\"只不过对这些方法有更加特殊的定义\",{\"1\":{\"204\":1}}],[\"只不过\",{\"1\":{\"204\":1,\"843\":1,\"1173\":1,\"1175\":1,\"1200\":1,\"1247\":1}}],[\"只不过需要注意的是\",{\"1\":{\"203\":1}}],[\"只不过list也是一样的\",{\"1\":{\"200\":1}}],[\"只不过linkedlist不仅可以当做list来使用\",{\"1\":{\"182\":1}}],[\"只不过此时编译器会给出警告\",{\"1\":{\"173\":1}}],[\"只不过下界仅适用于通配符\",{\"1\":{\"172\":1}}],[\"只不过我们此时需要遍历所有的\",{\"1\":{\"79\":1}}],[\"只不过根据区域划分\",{\"1\":{\"13\":1}}],[\"只是不清楚创建到哪一个阶段了\",{\"1\":{\"1301\":1}}],[\"只是不用我们去写\",{\"1\":{\"166\":1}}],[\"只是被重新封装了\",{\"1\":{\"1246\":1}}],[\"只是存了一些基本信息\",{\"1\":{\"1246\":1}}],[\"只是类型一样而已\",{\"1\":{\"1127\":1}}],[\"只是反过来而已\",{\"1\":{\"769\":1}}],[\"只是反向操作\",{\"1\":{\"267\":1}}],[\"只是连接对象变成自己和自己了\",{\"1\":{\"768\":1}}],[\"只是现在由我们自己来提供用户查询方式\",{\"1\":{\"668\":1}}],[\"只是对操作进行了记录\",{\"1\":{\"514\":1}}],[\"只是借用了一下刚好匹配的方法\",{\"1\":{\"452\":1}}],[\"只是初始化了内部类的\",{\"1\":{\"411\":1}}],[\"只是数组的地址不准修改\",{\"1\":{\"396\":1}}],[\"只是语法上为了简单\",{\"1\":{\"384\":1}}],[\"只是一个代理\",{\"1\":{\"707\":1}}],[\"只是一个表壳\",{\"1\":{\"224\":1}}],[\"只是一定程度上\",{\"1\":{\"356\":1}}],[\"只是利用反射机制实现了方法的调用\",{\"1\":{\"349\":1}}],[\"只是编程不可见\",{\"1\":{\"341\":1}}],[\"只是可以使用包装类来表示\",{\"1\":{\"340\":1}}],[\"只是进行了一步求解\",{\"1\":{\"71\":1}}],[\"只是求解各状态的\",{\"1\":{\"56\":1}}],[\"证明了\",{\"1\":{\"1083\":1}}],[\"证明\",{\"1\":{\"26\":1}}],[\"θt+1​=θt​+α▽θ​lnπ\",{\"1\":{\"156\":2}}],[\"θt+1​=θt​+α▽θ​j\",{\"1\":{\"148\":1}}],[\"θt+1​​=θt​+α▽θ​j\",{\"1\":{\"156\":1}}],[\"θt​\",{\"1\":{\"148\":1,\"156\":3}}],[\"θ∈rm表示参数向量\",{\"1\":{\"148\":1}}],[\"θ\",{\"1\":{\"26\":4,\"148\":2,\"151\":1,\"155\":20,\"156\":2}}],[\"θkn​​\",{\"1\":{\"9\":1}}],[\"提交\",{\"1\":{\"1272\":1}}],[\"提交事务\",{\"1\":{\"782\":1,\"806\":2}}],[\"提示需要用户名和密码\",{\"1\":{\"1047\":1}}],[\"提高性能\",{\"1\":{\"836\":1}}],[\"提高安全性\",{\"0\":{\"462\":1}}],[\"提高泛化能力\",{\"1\":{\"131\":1}}],[\"提升clone方法的访问权限\",{\"1\":{\"377\":1}}],[\"提升采样的效率\",{\"1\":{\"25\":1}}],[\"提前将部分内容存入内存\",{\"1\":{\"260\":1}}],[\"提供一个booleansupplier对象\",{\"1\":{\"972\":1}}],[\"提供了一种特殊的语法\",{\"1\":{\"412\":1}}],[\"提供了一个支持\",{\"1\":{\"192\":1}}],[\"提供的异常处理注解\",{\"1\":{\"604\":1}}],[\"提供的\",{\"1\":{\"603\":1}}],[\"提供的方法进行计算\",{\"1\":{\"386\":1}}],[\"提供的迭代器生成方法\",{\"1\":{\"193\":1}}],[\"提出解决总用户mos最大化问题的三步骤\",{\"1\":{\"5\":1}}],[\"提出了一个理想的由qoe驱动的多无人机协助通信框架\",{\"1\":{\"5\":1}}],[\"而刷新操作就是配置所有bean的关键部分了\",{\"1\":{\"1320\":1}}],[\"而testserviceimpl的加载顺序为\",{\"1\":{\"1308\":1}}],[\"而test和main目录下又具有java\",{\"1\":{\"1001\":1}}],[\"而执行test\",{\"1\":{\"1281\":1}}],[\"而一个事务方法包含了另一个事务方法\",{\"1\":{\"1281\":1}}],[\"而又无法感知到表中记录条数发生变化\",{\"1\":{\"1271\":1}}],[\"而正常情况下应该是7\",{\"1\":{\"1270\":1}}],[\"而另一个事务此时修改了此数据\",{\"1\":{\"1267\":1}}],[\"而另一些则不允许\",{\"1\":{\"178\":1}}],[\"而此对象正是通过drivermanager来创建的\",{\"1\":{\"1244\":1}}],[\"而此cookie就对应了你属于哪一个对话\",{\"1\":{\"1095\":1}}],[\"而采用\",{\"1\":{\"1181\":1}}],[\"而有了依赖注入之后\",{\"1\":{\"1132\":1}}],[\"而原型模式才是相当于在要用的时候直接new了一个对象\",{\"1\":{\"1129\":1}}],[\"而原来保存的数据只适用于之前版本的这个类\",{\"1\":{\"289\":1}}],[\"而处于原型模式下\",{\"1\":{\"1129\":1}}],[\"而进行大面积修改\",{\"1\":{\"1117\":1}}],[\"而进行自增操作之后\",{\"1\":{\"311\":1}}],[\"而要解决以上提到的一些问题\",{\"1\":{\"1109\":1}}],[\"而要修改日志的默认打印级别\",{\"1\":{\"912\":1}}],[\"而传统的类加载机制无法做到这一点\",{\"1\":{\"1109\":1}}],[\"而传输到客户端时\",{\"1\":{\"1042\":1}}],[\"而过滤器不允许的通过的请求\",{\"1\":{\"1101\":1}}],[\"而超过20秒\",{\"1\":{\"1092\":1}}],[\"而请求转发则是服务器内部进行跳转\",{\"1\":{\"1083\":1}}],[\"而urlpatterns和value实际上是同样功能\",{\"1\":{\"1061\":1}}],[\"而每次访问都会执行的是service方法\",{\"1\":{\"1055\":1}}],[\"而每一个\",{\"1\":{\"275\":1}}],[\"而具体实现由我们来编写\",{\"1\":{\"1053\":1}}],[\"而具体的实现\",{\"1\":{\"375\":1}}],[\"而服务端返回给客户端的称为响应报文\",{\"1\":{\"1042\":1}}],[\"而http是应用层协议\",{\"1\":{\"1042\":1}}],[\"而http和tcp并不是一个层次的通信协议\",{\"1\":{\"1042\":1}}],[\"而hash处理就是一种很好的解决方案\",{\"1\":{\"659\":1}}],[\"而hashmap也是这样的\",{\"1\":{\"215\":1}}],[\"而版本全由父项目管理\",{\"1\":{\"1033\":1}}],[\"而modelversion定义了当前模型的版本\",{\"1\":{\"1002\":1}}],[\"而mybatis也会这样\",{\"1\":{\"888\":1}}],[\"而mybatis不知道该如何选择\",{\"1\":{\"841\":1}}],[\"而下面的pom\",{\"1\":{\"1002\":1}}],[\"而下面这样的就存在可分割的情况\",{\"1\":{\"736\":1}}],[\"而管理相关的测试全部归为一个组\",{\"1\":{\"988\":1}}],[\"而管理员可以访问任何页面\",{\"1\":{\"692\":1}}],[\"而管理员只有群主的一部分权限\",{\"1\":{\"691\":1}}],[\"而单元测试则可以针对某一个方法直接进行测试执行\",{\"1\":{\"956\":1}}],[\"而默认情况下是未配置\",{\"1\":{\"951\":1}}],[\"而日志在打印时\",{\"1\":{\"927\":1}}],[\"而aop机制正是通过它来实现\",{\"1\":{\"1306\":1}}],[\"而a等着b\",{\"1\":{\"1301\":1}}],[\"而a中需要注入b\",{\"1\":{\"1301\":1}}],[\"而all则相反\",{\"1\":{\"912\":1}}],[\"而admin用户的角色为admin\",{\"1\":{\"692\":1}}],[\"而info级别以下的日志则会直接省略\",{\"1\":{\"911\":1}}],[\"而返回类型mybatis会自动根据方法的返回值进行判断\",{\"1\":{\"896\":1}}],[\"而可读写的缓存会\",{\"1\":{\"884\":1}}],[\"而数据库也是这样\",{\"1\":{\"871\":1}}],[\"而构造方法中没有传入的字段\",{\"1\":{\"841\":1}}],[\"而字段的赋值无论是什么构造方法\",{\"1\":{\"841\":1}}],[\"而字符串则是一系列字符的序列\",{\"1\":{\"400\":1}}],[\"而通过sqlsession就可以完成几乎所有的数据库操作\",{\"1\":{\"825\":1}}],[\"而xml主要是存放数据\",{\"1\":{\"817\":1}}],[\"而使用我们的\",{\"1\":{\"1062\":1}}],[\"而使用lombok之后\",{\"1\":{\"810\":1}}],[\"而使用springmvc后\",{\"1\":{\"563\":1}}],[\"而最关键的则是最上方的mapperscannerconfigurer\",{\"1\":{\"1326\":1}}],[\"而最后得到的结果\",{\"1\":{\"1306\":1}}],[\"而最终使用的也是drivermanager提供的connection对象\",{\"1\":{\"1247\":1}}],[\"而最外层有一个真正的\",{\"1\":{\"805\":1}}],[\"而最小值问题\",{\"1\":{\"104\":1}}],[\"而它就是在最后对bean进行了代理\",{\"1\":{\"1310\":1}}],[\"而它就是自动生成的logger\",{\"1\":{\"950\":1}}],[\"而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换\",{\"1\":{\"799\":1}}],[\"而它的run方法会循环地读取队列中是否还有任务\",{\"1\":{\"324\":1}}],[\"而cascade会强制连带引用此列的约束\",{\"1\":{\"751\":1}}],[\"而书籍名称和书籍作者依赖于书籍编号\",{\"1\":{\"738\":1}}],[\"而学习了mybatis之后\",{\"1\":{\"1242\":1}}],[\"而学号唯一对应\",{\"1\":{\"733\":1}}],[\"而学生相对于老师就是被教授的关系\",{\"1\":{\"733\":1}}],[\"而像一个老师教多个学生的联系就是一种一对多的联系\",{\"1\":{\"733\":1}}],[\"而java就对socket底层支持进行了一套完整的封装\",{\"1\":{\"718\":1}}],[\"而现在再调用test\",{\"1\":{\"1282\":1}}],[\"而现在\",{\"1\":{\"643\":1}}],[\"而现在我们只需要添加一个\",{\"1\":{\"569\":1}}],[\"而帖子是以富文本形式进行编辑和上传的\",{\"1\":{\"643\":1}}],[\"而spring就为mybatis提供了一个非常好的事务管理实现\",{\"1\":{\"1273\":1}}],[\"而spring框架就给我们提供了这样的一个ioc容器进行对象的的管理\",{\"1\":{\"1117\":1}}],[\"而springsecurity就解决了这样的问题\",{\"1\":{\"641\":1}}],[\"而springmvc使用dispatcherservlet来处理所有的请求\",{\"1\":{\"558\":1}}],[\"而异步请求通过将请求发送到后台\",{\"1\":{\"617\":1}}],[\"而其中的数据由前端执行js代码来向服务器动态获取\",{\"1\":{\"609\":1}}],[\"而其他的流程已经由springmvc帮助我们完成了\",{\"1\":{\"558\":1}}],[\"而其他的部分实际上在任何地方编写都是一模一样的\",{\"1\":{\"446\":1}}],[\"而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容\",{\"1\":{\"312\":1}}],[\"而其他则是无序的\",{\"1\":{\"178\":1}}],[\"而完成后是在所有的posthandle执行之后再同样的以倒序方式执行\",{\"1\":{\"600\":1}}],[\"而拦截器并不是在servlet之前\",{\"1\":{\"593\":1}}],[\"而方法的形参列表中必须包括一个与占位符同名的并且添加了\",{\"1\":{\"589\":1}}],[\"而方法的重写是覆盖原有的方法实现\",{\"1\":{\"373\":1}}],[\"而密封类的作用就是限制类的继承\",{\"1\":{\"503\":1}}],[\"而记录类型本质上也是一个普通的类\",{\"1\":{\"501\":1}}],[\"而在单例模式下\",{\"1\":{\"1148\":1}}],[\"而在这个过程中\",{\"1\":{\"888\":1}}],[\"而在右表中缺失的数据会使用null来代替\",{\"1\":{\"769\":1}}],[\"而在frameworkservlet中\",{\"1\":{\"626\":1}}],[\"而在之前的实战开发中\",{\"1\":{\"540\":1}}],[\"而在java\",{\"1\":{\"474\":1,\"475\":1}}],[\"而在引入模块机制之后\",{\"1\":{\"460\":1}}],[\"而之后创建实现类就只需要交给jvm去处理就好了\",{\"1\":{\"446\":1}}],[\"而计算机网络实验这门课是以等级进行结算\",{\"1\":{\"437\":1}}],[\"而错误是致命问题\",{\"1\":{\"421\":1}}],[\"而b这时也没创建完成\",{\"1\":{\"1301\":1}}],[\"而bigdecimal可以实现小数的精确计算\",{\"1\":{\"386\":1}}],[\"而bufferedinputstream虽然有着同样的方法\",{\"1\":{\"264\":1}}],[\"而实际项目运行时\",{\"1\":{\"1016\":1}}],[\"而实际上指向的还是原来的那个对象\",{\"1\":{\"377\":1}}],[\"而实际要去启动的是真正的string类\",{\"1\":{\"355\":1}}],[\"而与注释不同的是\",{\"1\":{\"360\":1}}],[\"而我们之前一直使用的其实就是jdbc的事务\",{\"1\":{\"1273\":1}}],[\"而我们之前的图书管理系统中\",{\"1\":{\"691\":1}}],[\"而我们如果需要使用spring为我们提供的ioc容器\",{\"1\":{\"1119\":1}}],[\"而我们首先要去学习的就是core\",{\"1\":{\"1118\":1}}],[\"而我们可以选择不使用这些框架或是选择其中一个即可\",{\"1\":{\"1025\":1}}],[\"而我们可以通过连地址法解决这种问题\",{\"1\":{\"215\":1}}],[\"而我们又不一定能立即察觉到\",{\"1\":{\"956\":1}}],[\"而我们看到的只有一个按钮\",{\"1\":{\"641\":1}}],[\"而我们后端开发者只需要关心接口返回正确的数据即可\",{\"1\":{\"617\":1}}],[\"而我们这里指定为post方法访问此地址\",{\"1\":{\"572\":1}}],[\"而我们自己编写的类实际上是appclassloader加载的\",{\"1\":{\"355\":1}}],[\"而反射机制其实就是利用这些存放的类信息\",{\"1\":{\"338\":1}}],[\"而当货架有货物的时候\",{\"1\":{\"331\":1}}],[\"而当我们需要使用其他包中的类时\",{\"1\":{\"277\":1}}],[\"而守护线程就不一样了\",{\"1\":{\"329\":1}}],[\"而后者是看运气随机选择一个\",{\"1\":{\"318\":1}}],[\"而如果是自己定义\",{\"1\":{\"1109\":1}}],[\"而如果是普通成员方法\",{\"1\":{\"312\":1}}],[\"而如果抽象类定义的是\",{\"1\":{\"375\":1}}],[\"而如果我们希望同时执行多个任务\",{\"1\":{\"295\":1}}],[\"而这时\",{\"1\":{\"1270\":1}}],[\"而这时如果其他使用同样的锁的同步代码块也想执行内容\",{\"1\":{\"312\":1}}],[\"而这种问题\",{\"1\":{\"805\":1}}],[\"而这些都由springsecurity帮我们实现了\",{\"1\":{\"642\":1}}],[\"而这个变量就是类型转换之后的\",{\"1\":{\"499\":1}}],[\"而这里面就定义了大量的接口\",{\"1\":{\"787\":1}}],[\"而这里传入的正好是virtualfilterchain对象\",{\"1\":{\"711\":1}}],[\"而这里的filter列表中的所有filter并没有被注册\",{\"1\":{\"708\":1}}],[\"而这里的登陆表单正好是一个post类型的请求\",{\"1\":{\"660\":1}}],[\"而这里的结点既存放键也存放值\",{\"1\":{\"215\":1}}],[\"而这里\",{\"1\":{\"641\":1}}],[\"而这里我们就通过lambda的形式给了它一个方法体\",{\"1\":{\"446\":1}}],[\"而这里定义为只在代码中\",{\"1\":{\"363\":1}}],[\"而类似这样的发送通知来告知线程需要中断\",{\"1\":{\"301\":1}}],[\"而并非完全由readlimit确定\",{\"1\":{\"265\":1}}],[\"而缓冲流提供了缓冲机制\",{\"1\":{\"265\":1}}],[\"而缓冲流正如其名称一样\",{\"1\":{\"260\":1}}],[\"而filenotfoundexception是继承自ioexception的\",{\"1\":{\"247\":1}}],[\"而且可以灵活地被重用和扩展\",{\"1\":{\"1115\":1}}],[\"而且也传送任何可从互联网上得到的信息\",{\"1\":{\"1042\":1}}],[\"而且也不需要我们自己考虑break或是return来结束switch了\",{\"1\":{\"496\":1}}],[\"而且没有执行\",{\"1\":{\"884\":1}}],[\"而且还要知道对应的返回类型\",{\"1\":{\"842\":1}}],[\"而且如果数据库内容被窃取\",{\"1\":{\"659\":1}}],[\"而且如果是子类\",{\"1\":{\"375\":1}}],[\"而且语义明确\",{\"1\":{\"497\":1}}],[\"而且是\",{\"1\":{\"393\":1}}],[\"而且在更多情况下\",{\"1\":{\"356\":1}}],[\"而且我们不仅可以通过class关键字获取\",{\"1\":{\"340\":1}}],[\"而且执行不同进程会产生上下文切换\",{\"1\":{\"295\":1}}],[\"而且通过对对象的序列化操作\",{\"1\":{\"287\":1}}],[\"而且逻辑也更加清晰明了\",{\"1\":{\"228\":1}}],[\"而且接口中本身就已经定义了主要的方法\",{\"1\":{\"182\":1}}],[\"而内部维护的\",{\"1\":{\"224\":1}}],[\"而冲突时会得到一个被覆盖的值\",{\"1\":{\"217\":1}}],[\"而值就是学生信息\",{\"1\":{\"213\":1}}],[\"而双端队列允许在队列的两端进行入队和出队操作\",{\"1\":{\"201\":1}}],[\"而不会是部分完成部分失败\",{\"1\":{\"1266\":1}}],[\"而不会直接存放到主内存中\",{\"1\":{\"319\":1}}],[\"而不用自己再去编写一个工具类了\",{\"1\":{\"1254\":1}}],[\"而不仅仅是接口\",{\"1\":{\"1215\":1}}],[\"而不需要我们再使用代码进行配置\",{\"1\":{\"939\":1}}],[\"而不需要关心集合类是如何实现\",{\"1\":{\"190\":1}}],[\"而不同的数据库厂商实现的这套标准\",{\"1\":{\"787\":1}}],[\"而不太重要的任务\",{\"1\":{\"302\":1}}],[\"而不是我们自己创建工具类来管理\",{\"1\":{\"1253\":1}}],[\"而不是在当前线程执行\",{\"1\":{\"1188\":1}}],[\"而不是在对象创建的时候分配\",{\"1\":{\"275\":1}}],[\"而不是对应工厂的\",{\"1\":{\"1158\":1}}],[\"而不是对象本身的复制\",{\"1\":{\"161\":1}}],[\"而不是创建之后\",{\"1\":{\"1134\":1}}],[\"而不是创建一个数组\",{\"1\":{\"364\":1}}],[\"而不是为了去简化代码\",{\"1\":{\"1118\":1}}],[\"而不是包含外部类中和其他内部类中的全部测试用例\",{\"1\":{\"988\":1}}],[\"而不是失败\",{\"1\":{\"974\":1}}],[\"而不是让整个项目完全跑起来\",{\"1\":{\"956\":1}}],[\"而不是启动整个项目\",{\"1\":{\"956\":1}}],[\"而不是传统的直接打印\",{\"1\":{\"949\":1}}],[\"而不是再去向数据库进行请求\",{\"1\":{\"882\":1}}],[\"而不是再去使用filterchain进行向下传递\",{\"1\":{\"597\":1}}],[\"而不是预先定义好的\",{\"1\":{\"842\":1}}],[\"而不是所有的内容全部交给后端渲染再发送给浏览器\",{\"1\":{\"609\":1}}],[\"而不是char\",{\"1\":{\"462\":1}}],[\"而不是类所有的\",{\"1\":{\"408\":1}}],[\"而不是具体的某个对象\",{\"1\":{\"274\":1}}],[\"而不是字节\",{\"1\":{\"253\":1}}],[\"而不是直接创建出来的对象\",{\"1\":{\"1301\":1}}],[\"而不是直接抛出一个异常\",{\"1\":{\"1211\":1}}],[\"而不是直接执行\",{\"1\":{\"986\":1}}],[\"而不是直接向外部设备写入\",{\"1\":{\"260\":1}}],[\"而不是直接替换原文件内容\",{\"1\":{\"250\":1}}],[\"而不是直接开始执行内容\",{\"1\":{\"228\":1}}],[\"而不是进行等号判断\",{\"1\":{\"182\":1}}],[\"而不是本体\",{\"1\":{\"161\":1}}],[\"而不是仅考虑吞吐量\",{\"1\":{\"4\":1}}],[\"而迭代器则可以将多种多样不同的集合类遍历方式进行统一\",{\"1\":{\"188\":1}}],[\"而非\",{\"1\":{\"166\":1}}],[\"而对应的销毁方法不会被调用\",{\"1\":{\"1148\":1}}],[\"而对应的真实梯度可以用一个估计的梯度来替代\",{\"1\":{\"156\":1}}],[\"而对应的策略梯度上升算法就是对应\",{\"1\":{\"23\":1}}],[\"而是返回其生成的对象\",{\"1\":{\"1328\":1}}],[\"而是调用类的初始化方法\",{\"1\":{\"1307\":1}}],[\"而是调用之前数据源的pushconnection方法\",{\"1\":{\"1247\":1}}],[\"而是让程序的容器\",{\"1\":{\"1272\":1}}],[\"而是让程序自己决定\",{\"1\":{\"1116\":1}}],[\"而是推荐使用\",{\"1\":{\"1175\":1}}],[\"而是工厂bean生产的bean的实例\",{\"1\":{\"1159\":1}}],[\"而是只能在工厂方法中完成\",{\"1\":{\"1158\":1}}],[\"而是只有一个jar怎么办呢\",{\"1\":{\"1018\":1}}],[\"而是利用反射机制先找到对应的工厂类\",{\"1\":{\"1157\":1}}],[\"而是属性的继承\",{\"1\":{\"1149\":1}}],[\"而是采用的原型模式\",{\"1\":{\"1148\":1}}],[\"而是采用自定义的表结构\",{\"1\":{\"667\":1}}],[\"而是由ioc容器自动进行创建并提供\",{\"1\":{\"1119\":1}}],[\"而是由我们通过java\",{\"1\":{\"1053\":1}}],[\"而是编写对应的配置\",{\"1\":{\"1119\":1}}],[\"而是再次回到webappclassloader进行加载\",{\"1\":{\"1109\":1}}],[\"而是将所有的依赖进行集中管理\",{\"1\":{\"1033\":1}}],[\"而是将处理器和拦截器封装\",{\"1\":{\"625\":1}}],[\"而是maven自动帮助我们下载依赖并导入\",{\"1\":{\"1003\":1}}],[\"而是它们能够使得我们在不同的开发场景下\",{\"1\":{\"816\":1}}],[\"而是直接导入本地jar包\",{\"1\":{\"1018\":1}}],[\"而是直接使用现成的connection对象进行数据库操作\",{\"1\":{\"1242\":1}}],[\"而是直接使用mybatis为我们提供的sqlsessionfactory工具类来获取对应的sqlsession通过会话对象去操作数据库\",{\"1\":{\"1242\":1}}],[\"而是直接使用注解在接口上进行配置呢\",{\"1\":{\"893\":1}}],[\"而是直接使用类似于\",{\"1\":{\"446\":1}}],[\"而是直接获取之前创建好的\",{\"1\":{\"883\":1}}],[\"而是直接传值\",{\"1\":{\"831\":1}}],[\"而是直接继续上一次的登录状态\",{\"1\":{\"686\":1}}],[\"而是默认保存一段时间\",{\"1\":{\"686\":1}}],[\"而是使用接口中的方法\",{\"1\":{\"1327\":1}}],[\"而是使用datasource的实现类来获取的\",{\"1\":{\"1242\":1}}],[\"而是使用的第三方库实现\",{\"1\":{\"1215\":1}}],[\"而是使用list内部所包含的类型\",{\"1\":{\"836\":1}}],[\"而是使用加密算法将密码进行加密\",{\"1\":{\"659\":1}}],[\"而是使用内部检查机制checkerror\",{\"1\":{\"284\":1}}],[\"而是发送以下内容给服务端\",{\"1\":{\"643\":1}}],[\"而是不法分子搭建的恶意网站\",{\"1\":{\"641\":1}}],[\"而是能够实时更新内容\",{\"1\":{\"617\":1}}],[\"而是一样等到需要时再加载\",{\"1\":{\"1130\":1}}],[\"而是一口气全部交给数据库处理\",{\"1\":{\"798\":1}}],[\"而是一种设计风格\",{\"1\":{\"589\":1}}],[\"而是一个参数化类型\",{\"1\":{\"343\":1}}],[\"而是yield关键字\",{\"1\":{\"497\":1}}],[\"而是需要做点什么其他的工作才能返回结果呢\",{\"1\":{\"497\":1}}],[\"而是需要到使用时才会确定对应的泛型类型\",{\"1\":{\"438\":1}}],[\"而是jdk1\",{\"1\":{\"476\":1}}],[\"而是类似\",{\"1\":{\"452\":1}}],[\"而是对象所有\",{\"1\":{\"451\":1}}],[\"而是对应的上界\",{\"1\":{\"172\":1}}],[\"而是对应的样本\",{\"1\":{\"99\":1}}],[\"而是动态进行传递\",{\"1\":{\"356\":1}}],[\"而是通过invokedynamic指令实现的\",{\"1\":{\"446\":1}}],[\"而是通过获取构造器\",{\"1\":{\"348\":1}}],[\"而是通过这个类去使用\",{\"1\":{\"274\":1}}],[\"而是通知程序做其他事情\",{\"1\":{\"301\":1}}],[\"而是在其他线程启动的\",{\"1\":{\"1188\":1}}],[\"而是在这里进行内部调用\",{\"1\":{\"708\":2}}],[\"而是在这之前就已经完成了\",{\"1\":{\"166\":1}}],[\"而是在需要时才会去加载\",{\"1\":{\"275\":1}}],[\"而是我们传入的fileinputstream\",{\"1\":{\"264\":1}}],[\"而是单独的一个体系\",{\"1\":{\"212\":1,\"213\":1}}],[\"而是按照数字的大小进行排列\",{\"1\":{\"207\":1}}],[\"而是\",{\"1\":{\"206\":1}}],[\"而是等\",{\"1\":{\"142\":1}}],[\"而言\",{\"1\":{\"70\":1,\"241\":1}}],[\"而\",{\"1\":{\"41\":1,\"70\":1,\"71\":1,\"747\":1,\"1094\":1}}],[\"策略梯度法\",{\"0\":{\"147\":1}}],[\"策略梯度上升\",{\"1\":{\"23\":1}}],[\"策略了\",{\"1\":{\"125\":1}}],[\"策略求解\",{\"1\":{\"70\":2}}],[\"策略提升\",{\"1\":{\"66\":1}}],[\"策略评估\",{\"1\":{\"66\":1}}],[\"策略更新\",{\"1\":{\"29\":1,\"82\":1}}],[\"策略为贪心策略\",{\"1\":{\"13\":1}}],[\"volatile\",{\"1\":{\"1296\":1}}],[\"void类\",{\"1\":{\"386\":1}}],[\"void\",{\"1\":{\"161\":3,\"162\":2,\"164\":2,\"171\":6,\"172\":3,\"173\":1,\"180\":2,\"181\":3,\"182\":10,\"187\":2,\"189\":2,\"191\":2,\"192\":2,\"193\":1,\"194\":3,\"200\":1,\"201\":4,\"202\":1,\"203\":2,\"204\":1,\"205\":3,\"206\":1,\"207\":2,\"213\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":2,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":2,\"277\":2,\"278\":2,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"296\":1,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":7,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":4,\"323\":2,\"324\":4,\"329\":2,\"330\":2,\"331\":3,\"339\":1,\"340\":1,\"341\":1,\"343\":9,\"348\":4,\"349\":5,\"350\":3,\"355\":3,\"356\":2,\"363\":1,\"364\":3,\"365\":2,\"372\":7,\"373\":1,\"375\":2,\"376\":7,\"377\":2,\"378\":2,\"384\":4,\"385\":1,\"386\":3,\"392\":1,\"393\":1,\"394\":1,\"395\":2,\"396\":1,\"397\":1,\"398\":4,\"399\":1,\"401\":3,\"402\":3,\"403\":2,\"408\":6,\"409\":2,\"410\":2,\"411\":3,\"412\":8,\"413\":2,\"414\":4,\"415\":5,\"423\":2,\"424\":6,\"425\":1,\"431\":2,\"432\":1,\"437\":1,\"438\":3,\"439\":2,\"445\":2,\"446\":1,\"447\":1,\"448\":1,\"449\":2,\"451\":1,\"452\":1,\"453\":1,\"454\":4,\"461\":1,\"462\":1,\"464\":1,\"468\":1,\"474\":3,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":6,\"485\":2,\"487\":1,\"488\":3,\"490\":4,\"500\":1,\"501\":1,\"504\":1,\"509\":1,\"512\":1,\"518\":1,\"519\":1,\"521\":1,\"522\":1,\"523\":4,\"550\":1,\"564\":2,\"595\":2,\"596\":1,\"600\":3,\"601\":1,\"616\":1,\"619\":1,\"620\":1,\"625\":4,\"626\":5,\"631\":1,\"665\":4,\"678\":2,\"697\":1,\"699\":2,\"705\":2,\"706\":1,\"707\":2,\"708\":3,\"710\":1,\"711\":2,\"712\":1,\"713\":1,\"719\":3,\"720\":2,\"726\":2,\"727\":2,\"789\":1,\"796\":1,\"798\":1,\"799\":1,\"805\":1,\"806\":4,\"810\":3,\"824\":1,\"826\":1,\"830\":1,\"841\":1,\"908\":1,\"910\":1,\"950\":2,\"956\":4,\"959\":4,\"960\":1,\"961\":1,\"963\":1,\"969\":1,\"974\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":2,\"980\":1,\"985\":3,\"986\":2,\"987\":4,\"988\":5,\"990\":1,\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"995\":2,\"1008\":1,\"1017\":3,\"1023\":2,\"1032\":1,\"1035\":1,\"1054\":3,\"1057\":1,\"1059\":4,\"1064\":2,\"1069\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":1,\"1103\":3,\"1104\":3,\"1105\":1,\"1117\":1,\"1119\":4,\"1125\":1,\"1126\":2,\"1132\":4,\"1133\":1,\"1136\":1,\"1149\":2,\"1173\":1,\"1176\":2,\"1186\":2,\"1188\":3,\"1190\":1,\"1191\":1,\"1192\":4,\"1199\":1,\"1200\":1,\"1218\":2,\"1221\":1,\"1223\":2,\"1224\":1,\"1225\":3,\"1231\":4,\"1232\":1,\"1233\":2,\"1234\":1,\"1235\":2,\"1236\":1,\"1247\":1,\"1256\":1,\"1257\":1,\"1260\":1,\"1272\":3,\"1273\":3,\"1277\":3,\"1278\":1,\"1281\":2,\"1282\":2,\"1283\":2,\"1288\":1,\"1291\":1,\"1296\":3,\"1297\":2,\"1298\":2,\"1308\":2,\"1310\":1,\"1311\":4,\"1319\":1,\"1320\":1,\"1321\":2,\"1326\":1,\"1327\":1,\"1328\":1}}],[\"v是指用户界面\",{\"1\":{\"541\":1}}],[\"vvv\",{\"1\":{\"454\":1}}],[\"view来创建视图\",{\"1\":{\"779\":1}}],[\"viewresolver\",{\"1\":{\"560\":2}}],[\"view\",{\"1\":{\"541\":1,\"560\":1,\"779\":3,\"1047\":1}}],[\"virtualfilterchaindecorator\",{\"1\":{\"709\":2}}],[\"virtualfilterchain\",{\"1\":{\"708\":5,\"709\":2}}],[\"virtual\",{\"1\":{\"340\":1}}],[\"via\",{\"1\":{\"324\":1,\"788\":1,\"1296\":1}}],[\"visit\",{\"1\":{\"81\":4,\"84\":2}}],[\"v+\",{\"1\":{\"221\":2}}],[\"v会返回null\",{\"1\":{\"221\":1}}],[\"v>>\",{\"1\":{\"213\":1}}],[\"v>\",{\"1\":{\"213\":3,\"215\":7,\"216\":4,\"217\":4,\"218\":4}}],[\"v就是值的类型\",{\"1\":{\"213\":1}}],[\"validate\",{\"1\":{\"1034\":1}}],[\"validate命令可以验证项目的可用性\",{\"1\":{\"1034\":1}}],[\"val\",{\"1\":{\"524\":6,\"1237\":2}}],[\"value这种注解\",{\"1\":{\"1318\":1}}],[\"value+\",{\"1\":{\"1231\":1}}],[\"value++\",{\"1\":{\"311\":2,\"312\":3}}],[\"value就可以了\",{\"1\":{\"1208\":1}}],[\"value就是要设置的值\",{\"1\":{\"841\":1}}],[\"value进行注入\",{\"1\":{\"1200\":1}}],[\"value中的$\",{\"1\":{\"1199\":1}}],[\"value属性表示赋给这个属性的值为value对应的值\",{\"1\":{\"1133\":1}}],[\"value为object类型\",{\"1\":{\"833\":1}}],[\"value与\",{\"1\":{\"812\":1}}],[\"value=\",{\"1\":{\"641\":1,\"660\":2,\"682\":1,\"683\":1,\"824\":4,\"852\":1,\"951\":2,\"1017\":7,\"1071\":4,\"1133\":1,\"1135\":2,\"1136\":3,\"1149\":2,\"1150\":3,\"1151\":1,\"1199\":1,\"1211\":1,\"1242\":4,\"1255\":4}}],[\"value>我是全局初始化参数<\",{\"1\":{\"1086\":1}}],[\"value>\",{\"1\":{\"548\":1,\"1086\":1,\"1136\":3}}],[\"value>classpath\",{\"1\":{\"548\":1}}],[\"valueof\",{\"1\":{\"378\":1,\"384\":1,\"385\":1,\"386\":4,\"1135\":1,\"1327\":1}}],[\"value2\",{\"1\":{\"364\":1,\"512\":4}}],[\"value1\",{\"1\":{\"364\":1,\"512\":4}}],[\"valuesource是最简单的一种参数设定\",{\"1\":{\"991\":1}}],[\"valuesource来进行参数来源设定\",{\"1\":{\"991\":1}}],[\"valuesource\",{\"1\":{\"991\":1}}],[\"values\",{\"1\":{\"131\":2,\"213\":1,\"378\":1,\"516\":2,\"631\":1,\"754\":3,\"796\":1,\"798\":2,\"806\":11,\"861\":1,\"862\":1,\"871\":1,\"877\":2,\"896\":1,\"897\":2,\"987\":1,\"1277\":1}}],[\"value后\",{\"1\":{\"77\":1}}],[\"value的关系\",{\"1\":{\"42\":1}}],[\"value\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1,\"58\":1,\"62\":1,\"70\":1,\"111\":1,\"115\":1,\"119\":1,\"130\":1,\"132\":1,\"150\":1,\"153\":1},\"1\":{\"23\":1,\"37\":1,\"40\":5,\"41\":3,\"42\":1,\"45\":1,\"47\":1,\"48\":10,\"49\":4,\"52\":1,\"53\":1,\"55\":1,\"56\":1,\"57\":2,\"62\":1,\"63\":3,\"66\":3,\"68\":2,\"69\":1,\"70\":12,\"71\":2,\"75\":2,\"77\":6,\"79\":6,\"81\":3,\"82\":2,\"84\":1,\"92\":2,\"111\":1,\"113\":2,\"115\":2,\"116\":1,\"119\":2,\"120\":1,\"130\":1,\"147\":1,\"148\":1,\"150\":1,\"172\":5,\"182\":2,\"213\":3,\"215\":1,\"216\":9,\"217\":2,\"218\":2,\"222\":1,\"224\":2,\"311\":2,\"312\":4,\"350\":6,\"364\":3,\"365\":3,\"386\":1,\"437\":3,\"438\":8,\"451\":2,\"453\":2,\"462\":2,\"563\":3,\"569\":2,\"572\":1,\"573\":1,\"574\":3,\"575\":2,\"576\":1,\"579\":1,\"580\":2,\"581\":2,\"582\":2,\"583\":1,\"585\":2,\"586\":2,\"588\":1,\"589\":4,\"612\":1,\"613\":1,\"615\":1,\"616\":1,\"617\":2,\"619\":1,\"620\":1,\"636\":1,\"660\":2,\"666\":3,\"699\":1,\"841\":2,\"912\":2,\"963\":2,\"1064\":1,\"1072\":1,\"1085\":2,\"1092\":2,\"1167\":2,\"1199\":2,\"1200\":3,\"1203\":1,\"1208\":2,\"1211\":2,\"1224\":6,\"1231\":1,\"1235\":1,\"1236\":1,\"1279\":2,\"1326\":1}}],[\"var8\",{\"1\":{\"1242\":3}}],[\"var6\",{\"1\":{\"711\":2,\"1247\":2}}],[\"var5\",{\"1\":{\"711\":3}}],[\"var15\",{\"1\":{\"1246\":1}}],[\"var10000\",{\"1\":{\"1246\":9,\"1247\":5}}],[\"var12\",{\"1\":{\"1242\":3}}],[\"var1\",{\"1\":{\"708\":1}}],[\"var16\",{\"1\":{\"626\":1,\"1246\":1}}],[\"varchar\",{\"1\":{\"662\":4,\"746\":1,\"747\":3,\"748\":2}}],[\"var4\",{\"1\":{\"625\":4}}],[\"var关键字必须位于有初始值设定的变量上\",{\"1\":{\"485\":1}}],[\"var\",{\"1\":{\"485\":2,\"487\":1,\"488\":1,\"497\":3}}],[\"vars命令来展示当前定义的变量列表\",{\"1\":{\"473\":1}}],[\"various\",{\"1\":{\"324\":1}}],[\"var23\",{\"1\":{\"626\":2}}],[\"var22\",{\"1\":{\"626\":2}}],[\"var21\",{\"1\":{\"626\":2}}],[\"var20\",{\"1\":{\"626\":2}}],[\"var2\",{\"1\":{\"187\":3,\"708\":1}}],[\"vˉπ0​\",{\"1\":{\"152\":1,\"155\":1}}],[\"vˉπ​=es∼d​\",{\"1\":{\"150\":1}}],[\"vˉπ​=s∈s∑​d\",{\"1\":{\"150\":1}}],[\"vˉπ​\",{\"1\":{\"150\":1,\"152\":1,\"155\":1}}],[\"v^\",{\"1\":{\"131\":1}}],[\"vt​\",{\"1\":{\"112\":3}}],[\"vt+1​\",{\"1\":{\"112\":2}}],[\"vu\",{\"1\":{\"70\":1}}],[\"v0​\",{\"1\":{\"70\":2}}],[\"vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ1​​=rπ1​​+γpπ1​​vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ0​​是通过迭代算法来求的\",{\"1\":{\"70\":1}}],[\"vπ0​​=rπ0​​+γpπ0​​vπ0​​\",{\"1\":{\"70\":1}}],[\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",{\"1\":{\"68\":1}}],[\"vπk​​=\",{\"1\":{\"68\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​policyimprovement\",{\"1\":{\"77\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​\",{\"1\":{\"66\":1,\"70\":1}}],[\"vπk​​\",{\"1\":{\"66\":1,\"68\":1,\"77\":1}}],[\"vπk​\",{\"1\":{\"66\":2,\"68\":1}}],[\"vπ​=\",{\"1\":{\"46\":1,\"47\":1}}],[\"vπ​=rπ​+γpπ​vπ​​\",{\"1\":{\"46\":1}}],[\"vπ​\",{\"1\":{\"27\":1,\"40\":2,\"42\":1,\"44\":1,\"45\":3,\"46\":4,\"48\":5,\"49\":1,\"55\":2,\"57\":1,\"75\":1,\"112\":1,\"113\":4,\"133\":1,\"134\":2,\"135\":2,\"136\":5,\"137\":1,\"138\":1,\"150\":2}}],[\"v\",{\"1\":{\"58\":5,\"61\":1,\"63\":2,\"110\":1,\"213\":7,\"215\":1,\"216\":5,\"218\":1,\"221\":3,\"222\":2,\"386\":1,\"1069\":2}}],[\"v=b3\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"v=\",{\"1\":{\"727\":3,\"1096\":3}}],[\"v=f\",{\"1\":{\"58\":1,\"61\":1}}],[\"v=πmax​\",{\"1\":{\"55\":1}}],[\"vk​\",{\"1\":{\"62\":1}}],[\"vk​→vπ​=\",{\"1\":{\"47\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​\",{\"1\":{\"70\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​这里的vk​并不是\",{\"1\":{\"63\":1}}],[\"vk+1​=rπ​+γpπ​vk​​\",{\"1\":{\"47\":1}}],[\"vk+1​=f\",{\"1\":{\"62\":1}}],[\"v2​\",{\"1\":{\"47\":1}}],[\"v1​=rπ1​​+γpπ1​​v0​\",{\"1\":{\"70\":1}}],[\"v1​\",{\"1\":{\"47\":1}}],[\"verify命令可以按顺序执行每个默认生命周期阶段\",{\"1\":{\"1034\":1}}],[\"version这三个元素合在一起\",{\"1\":{\"1003\":1}}],[\"version\",{\"1\":{\"938\":1,\"1003\":1,\"1092\":1}}],[\"version=\",{\"1\":{\"545\":2,\"547\":1,\"549\":1,\"817\":2,\"824\":1,\"826\":1,\"1002\":1,\"1017\":1,\"1023\":1,\"1032\":1,\"1071\":1,\"1119\":1,\"1124\":1,\"1167\":1,\"1217\":1,\"1242\":1,\"1255\":1}}],[\"version>\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"611\":1,\"616\":1,\"649\":2,\"663\":4,\"1002\":1,\"1008\":1,\"1017\":3,\"1018\":1,\"1023\":2,\"1024\":1,\"1025\":3,\"1026\":1,\"1032\":1,\"1033\":5,\"1037\":1,\"1071\":2,\"1074\":1,\"1118\":1,\"1175\":1,\"1217\":1,\"1253\":4,\"1260\":3,\"1290\":2}}],[\"very\",{\"1\":{\"10\":1}}],[\"vector\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"vehicles\",{\"1\":{\"4\":1}}],[\"vehicular\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"∣\",{\"1\":{\"87\":1}}],[\"∣−1action\",{\"1\":{\"87\":1}}],[\"∣−1\",{\"1\":{\"87\":1}}],[\"∣a\",{\"1\":{\"87\":3}}],[\"∣ϵ​\",{\"1\":{\"87\":2}}],[\"∣∣≤δ\",{\"1\":{\"66\":1}}],[\"∣∣≤γ∣∣x1​−x2​∣∣\",{\"1\":{\"58\":1}}],[\"∣∣vπk+1​\",{\"1\":{\"66\":1}}],[\"∣∣f\",{\"1\":{\"58\":1}}],[\"∣st​=s\",{\"1\":{\"119\":1}}],[\"∣s=s\",{\"1\":{\"113\":2}}],[\"∣s\",{\"1\":{\"20\":1,\"41\":1,\"44\":4,\"45\":3,\"46\":1,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"113\":1,\"115\":1}}],[\"∣kn​∣为第n个簇的用户总数\",{\"1\":{\"14\":1}}],[\"会对一些特别的beanpostprocessor进行处理\",{\"1\":{\"1301\":1}}],[\"会对底层哈希表数组进行扩容\",{\"1\":{\"216\":1}}],[\"会有哪些结果\",{\"1\":{\"1301\":1}}],[\"会有一个很特殊的判断issingletoncurrentlyincreation\",{\"1\":{\"1301\":1}}],[\"会有更加方便的方式来注册mapper\",{\"1\":{\"1257\":1}}],[\"会回滚另一个事务吗\",{\"1\":{\"1281\":1}}],[\"会导致和前一次读取的数据不一致\",{\"1\":{\"1267\":1}}],[\"会导致我们挨个对之前用到teacher的类进行修改\",{\"1\":{\"1132\":1}}],[\"会记录是来自哪一个数据源创建的的\",{\"1\":{\"1247\":1}}],[\"会默认生成jdbctransaction\",{\"1\":{\"1242\":1}}],[\"会不会是mybatis每次都是帮助我们调用drivermanager来实现的数据库连接创建\",{\"1\":{\"1242\":1}}],[\"会异步执行\",{\"1\":{\"1188\":1}}],[\"会在编译时被一起放到类路径下\",{\"1\":{\"1119\":1}}],[\"会在类刚加载的时候就分配\",{\"1\":{\"275\":1}}],[\"会开始大面积报错\",{\"1\":{\"1116\":1}}],[\"会继续前往第二个过滤器\",{\"1\":{\"1103\":1}}],[\"会按照重定向响应给出的地址\",{\"1\":{\"1082\":1}}],[\"会按照以下语法来解析\",{\"1\":{\"614\":1}}],[\"会依次进行解包\",{\"1\":{\"1042\":1}}],[\"会暂时存储在本地仓库\",{\"1\":{\"1009\":1}}],[\"会优先进行指定的准备工作\",{\"1\":{\"985\":1}}],[\"会优先匹配合适的\",{\"1\":{\"604\":1}}],[\"会根据我们提供的信息作为对象的属性来提前注入到对象中\",{\"1\":{\"1132\":1}}],[\"会根据我们重写方法里面的内容进行进一步的配置\",{\"1\":{\"564\":1}}],[\"会根据子模块的相互依赖关系整理一个build顺序\",{\"1\":{\"1038\":1}}],[\"会根据eviction配置的策略进行清理\",{\"1\":{\"884\":1}}],[\"会发现不是原本的类型了\",{\"1\":{\"1222\":1}}],[\"会发现得到的两个对象实际上就是同一个\",{\"1\":{\"883\":1}}],[\"会发现无法进入的我们的页面中\",{\"1\":{\"652\":1}}],[\"会执行destroy\",{\"1\":{\"1148\":2}}],[\"会执行init\",{\"1\":{\"1148\":2}}],[\"会执行\",{\"1\":{\"811\":1}}],[\"会执行unsuccessfulauthentication\",{\"1\":{\"711\":1}}],[\"会存在严重的sql注入攻击漏洞\",{\"1\":{\"805\":1}}],[\"会产生庞大的数据\",{\"1\":{\"767\":1}}],[\"会产生异常\",{\"1\":{\"343\":1}}],[\"会以别名显示此列\",{\"1\":{\"762\":1}}],[\"会抛出异常\",{\"1\":{\"721\":1}}],[\"会话1在重复查询数据时\",{\"1\":{\"883\":1}}],[\"会话之间相互隔离\",{\"1\":{\"825\":1}}],[\"会话劫持\",{\"1\":{\"642\":2}}],[\"会话传递\",{\"1\":{\"642\":1}}],[\"会话固定攻击\",{\"1\":{\"642\":1}}],[\"会话过期后bean也消失\",{\"1\":{\"588\":1}}],[\"会携带之前登陆我们网站的cookie信息\",{\"1\":{\"641\":1}}],[\"会选择一个合适的handleradapter处理请求\",{\"1\":{\"625\":1}}],[\"会怎么样呢\",{\"1\":{\"1267\":1}}],[\"会怎么样\",{\"1\":{\"598\":1}}],[\"会显示405方法不支持\",{\"1\":{\"572\":1}}],[\"会调用doscan\",{\"1\":{\"1327\":1}}],[\"会调用getproxyconnection来获取一个代理对象\",{\"1\":{\"1247\":1}}],[\"会调用类中实现的对应感知方法\",{\"1\":{\"1186\":1}}],[\"会调用这些\",{\"1\":{\"560\":1}}],[\"会调用wait\",{\"1\":{\"324\":1}}],[\"会交给viewresolver\",{\"1\":{\"558\":1}}],[\"会交给当前的web应用程序进行处理\",{\"1\":{\"558\":1}}],[\"会先走handlermapping\",{\"1\":{\"558\":1}}],[\"会先记录每一步操作\",{\"1\":{\"228\":1}}],[\"会创建一个builder\",{\"1\":{\"525\":1}}],[\"会创建很多线程\",{\"1\":{\"295\":1}}],[\"会自动匹配符合里面参数数量的构造方法\",{\"1\":{\"1134\":1}}],[\"会自动向后台发送一个post请求\",{\"1\":{\"1069\":1}}],[\"会自动将那些添加了\",{\"1\":{\"1177\":1}}],[\"会自动将查询的结果转换为我们所需要的实体类\",{\"1\":{\"841\":1}}],[\"会自动将对应用户的cookie进行替换\",{\"1\":{\"642\":1}}],[\"会自动生成两个临时的表\",{\"1\":{\"781\":1}}],[\"会自动执行我们预先设定的内容\",{\"1\":{\"781\":1}}],[\"会自动编译出\",{\"1\":{\"501\":1}}],[\"会自动强制转换类型为指定类型\",{\"1\":{\"499\":1}}],[\"会自动转换为红黑树\",{\"1\":{\"217\":1}}],[\"会提示\",{\"1\":{\"1047\":1}}],[\"会提示找不到\",{\"1\":{\"461\":1}}],[\"会提取一个类的信息生成class对象存放在内存中\",{\"1\":{\"338\":1}}],[\"会识别\",{\"1\":{\"451\":1}}],[\"会隐式修改为\",{\"1\":{\"413\":1}}],[\"会限制其子类不允许其重写所对应的成员变量\",{\"1\":{\"374\":1}}],[\"会由jvm来调用一次此方法进行资源释放之类的操作\",{\"1\":{\"372\":1}}],[\"会报编译警告\",{\"1\":{\"361\":1}}],[\"会报编译错误\",{\"1\":{\"361\":1}}],[\"会报错\",{\"1\":{\"341\":1,\"395\":1}}],[\"会极大地降低后期维护性\",{\"1\":{\"349\":1}}],[\"会无法找到此构造方法\",{\"1\":{\"348\":1}}],[\"会更加合理\",{\"1\":{\"348\":1}}],[\"会更加合理一些\",{\"1\":{\"301\":1}}],[\"会出现问题\",{\"1\":{\"1009\":1}}],[\"会出现以下报错\",{\"1\":{\"355\":1}}],[\"会出现illegalaccessexception异常\",{\"1\":{\"348\":1}}],[\"会出现instantiationexception异常\",{\"1\":{\"348\":1}}],[\"会出现异常\",{\"1\":{\"161\":1}}],[\"会唤醒刚才变成等待状态的线程\",{\"1\":{\"318\":1}}],[\"会获取到当前的锁\",{\"1\":{\"312\":1}}],[\"会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作\",{\"1\":{\"301\":1}}],[\"会从运行状态回到就绪\",{\"1\":{\"300\":1}}],[\"会被逐渐弃用并移除\",{\"1\":{\"1175\":1}}],[\"会被变为转义形式\",{\"1\":{\"805\":1}}],[\"会被回滚\",{\"1\":{\"782\":1}}],[\"会被唤醒\",{\"1\":{\"324\":1}}],[\"会被自动添加这个属性\",{\"1\":{\"289\":1}}],[\"会被排到最后一位\",{\"1\":{\"218\":1}}],[\"会使用抽象方参数列表的第一个作为目标对象\",{\"1\":{\"451\":1}}],[\"会使用默认的负载因子\",{\"1\":{\"215\":1}}],[\"会使得线程的运行终止\",{\"1\":{\"300\":1}}],[\"会使得线程处于等待状态\",{\"1\":{\"300\":1}}],[\"会使得当前的读取位置回到\",{\"1\":{\"265\":1}}],[\"会直接出现异常\",{\"1\":{\"1283\":1}}],[\"会直接报错显示空指针\",{\"1\":{\"1211\":1}}],[\"会直接继承给sportstudent\",{\"1\":{\"1149\":1}}],[\"会直接导致整个流水线的引用关系大面积更新\",{\"1\":{\"1116\":1}}],[\"会直接跳转到time页面\",{\"1\":{\"1093\":1}}],[\"会直接替换掉默认的\",{\"1\":{\"1062\":1}}],[\"会直接展示在前端页面\",{\"1\":{\"602\":1}}],[\"会直接复制值给拷贝对象\",{\"1\":{\"377\":1}}],[\"会直接创建这个文件\",{\"1\":{\"249\":1}}],[\"会直接抛出异常告诉我们这个测试案例没有通过\",{\"1\":{\"969\":1}}],[\"会直接抛出异常\",{\"1\":{\"200\":1,\"236\":2}}],[\"会生成一个只有一个元素的list\",{\"1\":{\"236\":1}}],[\"会将我们当前的实体类对象的id修改为得到的id\",{\"1\":{\"897\":1}}],[\"会将子类的也捕获\",{\"1\":{\"424\":1}}],[\"会将类的信息提取出来\",{\"1\":{\"337\":1}}],[\"会将指定key的值进行重新计算\",{\"1\":{\"221\":1}}],[\"会将指定\",{\"1\":{\"221\":1}}],[\"会将其划分为n个簇\",{\"1\":{\"8\":1}}],[\"会得到一个badcredentialsexception\",{\"1\":{\"711\":1}}],[\"会得到\",{\"1\":{\"217\":1}}],[\"会返回一个modelandview对象\",{\"1\":{\"558\":1}}],[\"会返回\",{\"1\":{\"221\":1}}],[\"会返回原本的被覆盖值\",{\"1\":{\"216\":1}}],[\"会返回null\",{\"1\":{\"200\":2}}],[\"会转变为效率更高的红黑树结构\",{\"1\":{\"215\":1}}],[\"会变成什么类型呢\",{\"1\":{\"172\":1}}],[\"会覆盖掉默认的那一个无参构造方法\",{\"1\":{\"166\":1}}],[\"会一直进行更新\",{\"1\":{\"142\":1}}],[\"会与环境一直交互下去\",{\"1\":{\"19\":1}}],[\"这不是多此一举吗\",{\"1\":{\"1301\":1}}],[\"这不仅使得我们类定义中充满了get和set方法\",{\"1\":{\"810\":1}}],[\"这正是我们前面例子中提到的问题\",{\"1\":{\"1269\":1}}],[\"这下\",{\"1\":{\"1247\":1}}],[\"这下知道为什么上面说是递归了吧\",{\"1\":{\"711\":1}}],[\"这名字挺有文艺范的\",{\"1\":{\"1226\":1}}],[\"这实际上就是动态代理做到的\",{\"1\":{\"1221\":1}}],[\"这实际上是logger的父级提供的\",{\"1\":{\"918\":1}}],[\"这则是来匹配满足条件的切点调用的是什么方法\",{\"1\":{\"1220\":1}}],[\"这其实都是aop的功劳\",{\"1\":{\"1189\":1}}],[\"这只是冰山一角\",{\"1\":{\"1189\":1}}],[\"这只是一种设计风格而已\",{\"1\":{\"589\":1}}],[\"这只是一种写法而已\",{\"1\":{\"446\":1}}],[\"这跟使用xml配置是一样的\",{\"1\":{\"1169\":1}}],[\"这也是为什么用代理\",{\"1\":{\"1247\":1}}],[\"这也是为什么我们启动tomcat服务器之后\",{\"1\":{\"1054\":1}}],[\"这也证明了mybatis的缓存在生效\",{\"1\":{\"888\":1}}],[\"这需要使用三报文握手\",{\"1\":{\"1042\":1}}],[\"这需求有点抽象\",{\"1\":{\"874\":1}}],[\"这将依次测试枚举类中的所有枚举\",{\"1\":{\"993\":1}}],[\"这将会导致无限循环\",{\"1\":{\"193\":1}}],[\"这会导致我们要花费大量时间来等待每次测试用例的初始化操作\",{\"1\":{\"986\":1}}],[\"这会导致mybatis自动处理出现问题\",{\"1\":{\"835\":1}}],[\"这在某些场景下可能会显得不太方便\",{\"1\":{\"986\":1}}],[\"这导致尽管会话2更新了数据\",{\"1\":{\"883\":1}}],[\"这非常适合处理我们前面说的批量执行sql的问题\",{\"1\":{\"875\":1}}],[\"这看似是一个很奇怪的查询条件\",{\"1\":{\"873\":1}}],[\"这与我们之前的xml配置完全一致\",{\"1\":{\"900\":1}}],[\"这与我们之前jdbc中是一样的\",{\"1\":{\"860\":1}}],[\"这与之前的一对一比较类似\",{\"1\":{\"855\":1}}],[\"这并不是解决问题的最好办法\",{\"1\":{\"804\":1}}],[\"这包含资料的精确度\",{\"1\":{\"782\":1}}],[\"这表示写入的资料必须完全符合所有的预设规则\",{\"1\":{\"782\":1}}],[\"这显然是不对的\",{\"1\":{\"681\":1}}],[\"这同样是利用cookie中相同的jsessionid进行的攻击\",{\"1\":{\"642\":1}}],[\"这同样不是se中需要学习的内容\",{\"1\":{\"372\":1}}],[\"这才是整个处理过程中最核心的部分\",{\"1\":{\"626\":1}}],[\"这可以通过andthen方法来实现\",{\"1\":{\"511\":1}}],[\"这一步结束之后\",{\"1\":{\"1320\":1}}],[\"这一步中\",{\"1\":{\"1320\":1}}],[\"这一次请求直接返回了请求转发后的处理结果\",{\"1\":{\"1083\":1}}],[\"这一次我们在resultmap中添加constructor标签\",{\"1\":{\"841\":1}}],[\"这一部分我们先来看单例模式下的处理\",{\"1\":{\"1300\":1}}],[\"这一部分我们将详细介绍\",{\"1\":{\"1295\":1}}],[\"这一部分我们将详细介绍如何使用springsecurity实现用户登录\",{\"1\":{\"656\":1}}],[\"这一部分我们接着来进行更加深层次的配置\",{\"1\":{\"676\":1}}],[\"这一出场\",{\"1\":{\"501\":1}}],[\"这一条\",{\"1\":{\"81\":1}}],[\"这两个依赖不用我说了吧\",{\"1\":{\"1253\":1}}],[\"这两个方法都指向了内部的一个dogetconnection方法\",{\"1\":{\"1244\":1}}],[\"这两个类互相需要注入对方的实例对象\",{\"1\":{\"1181\":1}}],[\"这两个bean我们就可以区分出来了\",{\"1\":{\"1127\":1}}],[\"这两个算法是一致的\",{\"1\":{\"70\":1}}],[\"这两种写法效果是完全一样的\",{\"1\":{\"897\":1}}],[\"这两种使用方法的弊端有\",{\"1\":{\"523\":1}}],[\"这两种分数类型都有可能出现\",{\"1\":{\"437\":1}}],[\"这\",{\"1\":{\"402\":2}}],[\"这玩意就是为了处理\",{\"1\":{\"1318\":1}}],[\"这玩意学来有啥用\",{\"1\":{\"365\":1}}],[\"这玩意居然能存字符串进去\",{\"1\":{\"237\":1}}],[\"这意味着第三方cookie只能在用户导航到与原始站点相同的站点时发送\",{\"1\":{\"641\":1}}],[\"这意味着\",{\"1\":{\"348\":1,\"884\":1,\"1181\":1}}],[\"这时就会出现a还未创建完成\",{\"1\":{\"1301\":1}}],[\"这时就需要获取数据库的链接信息了\",{\"1\":{\"1242\":1}}],[\"这时候借助aop\",{\"1\":{\"1225\":1}}],[\"这时在进行四次挥手\",{\"1\":{\"1042\":1}}],[\"这时整个页面就非常有迷惑性了\",{\"1\":{\"641\":1}}],[\"这时该咋写\",{\"1\":{\"503\":1}}],[\"这时\",{\"1\":{\"454\":1,\"1082\":1}}],[\"这时为了方便\",{\"1\":{\"445\":1}}],[\"这时我们首先想到的就是创建一个新的线程来处理\",{\"1\":{\"1187\":1}}],[\"这时我们就可以使用三引号来囊括字符串\",{\"1\":{\"498\":1}}],[\"这时我们就可以手动抛出一个异常来终止程序继续运行下去\",{\"1\":{\"423\":1}}],[\"这时我们可以考虑使用optional进行包装\",{\"1\":{\"480\":1}}],[\"这时我们不希望用户将泛型指定为除数字类型外的其他类型\",{\"1\":{\"172\":1}}],[\"这时并没有立即释放锁\",{\"1\":{\"318\":1}}],[\"这时其他线程可以获取到此对象的锁\",{\"1\":{\"318\":1}}],[\"这就很难受了\",{\"1\":{\"1132\":1}}],[\"这就需要用到session了\",{\"1\":{\"1093\":1}}],[\"这就导致我们还是会连带引入这些依赖\",{\"1\":{\"1026\":1}}],[\"这就非常麻烦了\",{\"1\":{\"956\":1}}],[\"这就提供了可观的性能提升\",{\"1\":{\"884\":1}}],[\"这就是一种典型的数据虚读现象\",{\"1\":{\"1267\":1}}],[\"这就是一种多对多的联系\",{\"1\":{\"733\":1}}],[\"这就是日志的配置文件\",{\"1\":{\"1047\":1}}],[\"这就是maven本地仓库文件夹\",{\"1\":{\"1009\":1}}],[\"这就是xss漏洞的前身\",{\"1\":{\"643\":1}}],[\"这就是引入高速缓存引发的新问题\",{\"1\":{\"311\":1}}],[\"这就已经有前后端分离开发的雏形了\",{\"1\":{\"617\":1}}],[\"这就必然存在一个中间容器\",{\"1\":{\"331\":1}}],[\"这就产生了死锁\",{\"1\":{\"313\":1}}],[\"这些注解都是jakarta\",{\"1\":{\"1176\":1}}],[\"这些注解并不能像之前xml那样直接修改一些属性\",{\"1\":{\"897\":1}}],[\"这些对象类通过封装以后\",{\"1\":{\"1115\":1}}],[\"这些断言操作基本上都是用于判断某个测试结果是否符合我们的预期情况\",{\"1\":{\"968\":1}}],[\"这些操作相比查询操作来说非常简单就可以实现\",{\"1\":{\"864\":1}}],[\"这些数据库操作语句就可以构成一个事务\",{\"1\":{\"782\":1}}],[\"这些数据被存放在结构化的数据表里\",{\"1\":{\"732\":1}}],[\"这些特征也称为实体的一种属性\",{\"1\":{\"733\":1}}],[\"这些大型框架的底层一般都是层层套娃\",{\"1\":{\"626\":1}}],[\"这些方法默认情况下返回的结果都是int类型的\",{\"1\":{\"860\":1}}],[\"这些方法都被重写\",{\"1\":{\"626\":1}}],[\"这些方法并没有被重写\",{\"1\":{\"393\":1}}],[\"这些都可以通过单元测试来完成\",{\"1\":{\"956\":1}}],[\"这些都需要通过js完成异步请求来实现\",{\"1\":{\"617\":1}}],[\"这些都是大佬写出来的\",{\"1\":{\"217\":1}}],[\"这些可以省\",{\"1\":{\"376\":1}}],[\"这些映射关系被存储为键值对\",{\"1\":{\"213\":1}}],[\"这些是经过转换得到的正常html代码\",{\"1\":{\"643\":1}}],[\"这些是新的容量和扩容阈值\",{\"1\":{\"217\":1}}],[\"这些是list的特殊转换\",{\"1\":{\"181\":1}}],[\"这些是list的专用迭代器\",{\"1\":{\"181\":1}}],[\"这些是list中独特的搜索操作\",{\"1\":{\"181\":1}}],[\"这些是list中独特的位置直接访问操作\",{\"1\":{\"181\":1}}],[\"这些是比较以及哈希计算相关的操作\",{\"1\":{\"180\":1}}],[\"这些是批量执行的操作\",{\"1\":{\"180\":1}}],[\"这些是修改相关的操作\",{\"1\":{\"180\":1}}],[\"这些是查询相关的操作\",{\"1\":{\"180\":1}}],[\"这种机制mybatis自身不会去实现事务管理\",{\"1\":{\"1272\":1}}],[\"这种机制能够提升用户体验\",{\"1\":{\"617\":1}}],[\"这种现象称为虚读也可以称为不可重复读\",{\"1\":{\"1269\":1}}],[\"这种现象称为脏读\",{\"1\":{\"1268\":1}}],[\"这种配置文件格式很简单\",{\"1\":{\"1197\":1}}],[\"这种模式每次得到的对象都是一个新的\",{\"1\":{\"1129\":1}}],[\"这种父子关系类似于继承\",{\"1\":{\"927\":1}}],[\"这种格式有助于程序的日志读取\",{\"1\":{\"920\":1}}],[\"这种方式\",{\"1\":{\"1159\":1}}],[\"这种方式的权限校验虽然能够直接使用数据库\",{\"1\":{\"666\":1}}],[\"这种方式创建的列表\",{\"1\":{\"528\":1}}],[\"这种攻击一般需要前端配合后端进行防御\",{\"1\":{\"643\":1}}],[\"这种攻击方式非常好理解\",{\"1\":{\"641\":1}}],[\"这种构建恶意页面\",{\"1\":{\"641\":1}}],[\"这种风格的连接\",{\"1\":{\"589\":1}}],[\"这种风格将要处理的元素集合看作一种流\",{\"1\":{\"228\":1}}],[\"这种全新的语法\",{\"1\":{\"497\":1}}],[\"这种全新的switch语法称为switch表达式\",{\"1\":{\"497\":1}}],[\"这种类型推断仅仅发生在编译期间\",{\"1\":{\"485\":1}}],[\"这种写法就有点像kotlin或是js中的语法\",{\"1\":{\"480\":1}}],[\"这种时候就需要做兼容了\",{\"1\":{\"463\":1}}],[\"这种形式也可以\",{\"1\":{\"438\":1}}],[\"这种局部内部类的形式\",{\"1\":{\"410\":1}}],[\"这种即可\",{\"1\":{\"376\":1}}],[\"这种动态获取信息及动态调用对象方法的功能叫java的反射机制\",{\"1\":{\"336\":1}}],[\"这种语法只支持实现了autocloseable接口的类\",{\"1\":{\"247\":2}}],[\"这种集合类型比较特殊\",{\"1\":{\"204\":1}}],[\"这种迭代器因为能够双向遍历\",{\"1\":{\"194\":1}}],[\"这种迭代算法称为\",{\"1\":{\"62\":1}}],[\"这种情况\",{\"1\":{\"1149\":1}}],[\"这种情况默认也是bytype寻找的\",{\"1\":{\"1139\":1}}],[\"这种情况是可以简化的\",{\"1\":{\"414\":1}}],[\"这种情况实际上会被优化为下面的写法\",{\"1\":{\"402\":1}}],[\"这种情况不用扩了\",{\"1\":{\"217\":1}}],[\"这种情况就是哈希冲突了\",{\"1\":{\"216\":1}}],[\"这种情况下就很容易出问题\",{\"1\":{\"330\":1}}],[\"这种情况下\",{\"1\":{\"182\":1,\"667\":1,\"1127\":1}}],[\"这种情况下的\",{\"1\":{\"152\":1}}],[\"这种情况我们将\",{\"1\":{\"152\":1}}],[\"这是classpathmapperscanner中的扫描方法\",{\"1\":{\"1327\":1}}],[\"这是很方便的\",{\"1\":{\"1298\":1}}],[\"这是beanfactory的一个默认实现类\",{\"1\":{\"1296\":2}}],[\"这是要干嘛\",{\"1\":{\"1245\":1}}],[\"这是为他好\",{\"1\":{\"1224\":1}}],[\"这是为了提升效率\",{\"1\":{\"384\":1}}],[\"这是使用spring\",{\"1\":{\"1219\":1}}],[\"这是spring推荐的方式\",{\"1\":{\"1188\":1}}],[\"这是日志级别中倒数第二大的\",{\"1\":{\"910\":1}}],[\"这是在开始之前必须要掌握的内容\",{\"1\":{\"819\":1}}],[\"这是一种高度耦合的体系\",{\"1\":{\"1116\":1}}],[\"这是一种特殊的语言\",{\"1\":{\"744\":1}}],[\"这是一个非常常用的功能\",{\"1\":{\"685\":1}}],[\"这是一个无限制的流\",{\"1\":{\"228\":1}}],[\"这是我们不希望看到的结果\",{\"1\":{\"659\":1}}],[\"这是我们所求的量\",{\"1\":{\"136\":1}}],[\"这是目前号称最快的json解析框架\",{\"1\":{\"611\":1}}],[\"这是\",{\"1\":{\"603\":1,\"604\":1}}],[\"这是抽象方法\",{\"1\":{\"510\":1}}],[\"这是浅拷贝\",{\"1\":{\"377\":1}}],[\"这是强制要求的\",{\"1\":{\"375\":1}}],[\"这是因为java代码编译后形参名称无法保留\",{\"1\":{\"843\":1}}],[\"这是因为数据库字段名称与类中字段名称不匹配导致的\",{\"1\":{\"835\":1}}],[\"这是因为此用户还没有权限\",{\"1\":{\"773\":1}}],[\"这是因为我们前面配置的是user角色\",{\"1\":{\"692\":1}}],[\"这是因为我们的网页是动态的\",{\"1\":{\"617\":1}}],[\"这是因为在获取静态资源的时候\",{\"1\":{\"681\":1}}],[\"这是因为spring默认会从容器中选择一个executor类型\",{\"1\":{\"1188\":1}}],[\"这是因为springsecurity自带了csrf防护\",{\"1\":{\"660\":1}}],[\"这是因为springsecurity的密码校验不推荐直接使用原文进行比较\",{\"1\":{\"659\":1}}],[\"这是因为springmvc为我们提供了默认的异常处理页面\",{\"1\":{\"602\":1}}],[\"这是因为\",{\"1\":{\"384\":1,\"901\":1}}],[\"这是因为timer内存维护了一个任务队列和一个工作线程\",{\"1\":{\"324\":1}}],[\"这是因为集合类在删除元素时\",{\"1\":{\"182\":1}}],[\"这是arraylist的其中一个构造方法\",{\"1\":{\"182\":1}}],[\"这是来求解\",{\"1\":{\"79\":1}}],[\"这另一个策略会更新到最优的策略\",{\"1\":{\"123\":1}}],[\"这类算法统称为\",{\"1\":{\"82\":1}}],[\"这样容器才拥有了最基本的bean管理功能\",{\"1\":{\"1297\":1}}],[\"这样很容易出现并发相关的问题\",{\"1\":{\"1267\":1}}],[\"这样之后使用就无需再次进行连接\",{\"1\":{\"1242\":1}}],[\"这样在每个bean创建之后\",{\"1\":{\"1310\":1}}],[\"这样在main里\",{\"1\":{\"1225\":1}}],[\"这样在web应用程序启动时\",{\"1\":{\"564\":1}}],[\"这样同样可以获取到\",{\"1\":{\"1178\":1}}],[\"这样同样可以完成自动注入\",{\"1\":{\"1139\":1}}],[\"这样spring就会去扫描对应包下所有的类\",{\"1\":{\"1177\":1}}],[\"这样sqlsession会开启批处理模式\",{\"1\":{\"871\":1}}],[\"这样写还是不太方便\",{\"1\":{\"1177\":1}}],[\"这样写相对于配置文件中的\",{\"1\":{\"1167\":1}}],[\"这样确实可以直接得到对应的bean并使用\",{\"1\":{\"1172\":1}}],[\"这样被依赖的bean一定会在之前加载\",{\"1\":{\"1131\":1}}],[\"这样最终实现的类就是对应的\",{\"1\":{\"1119\":1}}],[\"这样父项目就完全作为依赖统一管理\",{\"1\":{\"1033\":1}}],[\"这样项目中就不会包含此依赖了\",{\"1\":{\"1026\":1}}],[\"这样显然会降低我们的开发效率\",{\"1\":{\"956\":1}}],[\"这样显然是很冗余的\",{\"1\":{\"949\":1}}],[\"这样显然比我们之前的写法更加简便\",{\"1\":{\"686\":1}}],[\"这样用mapper2时\",{\"1\":{\"884\":1}}],[\"这样下面在使用\",{\"1\":{\"861\":1}}],[\"这样mybatis运行时就会打印日志到控制台了\",{\"1\":{\"852\":1}}],[\"这样mybatis就可以通过association来自动处理了\",{\"1\":{\"855\":1}}],[\"这样mybatis就可以正确识别了\",{\"1\":{\"843\":1}}],[\"这样mybatis就可以按照我们的配置来正确找到对应的位置并赋值了\",{\"1\":{\"835\":1}}],[\"这样mybatis就知道该链接哪个数据库\",{\"1\":{\"824\":1}}],[\"这样编写实在是太复杂了\",{\"1\":{\"843\":1}}],[\"这样编写就不会报错了\",{\"1\":{\"487\":1}}],[\"这样会向数据库中插入一条新的学生信息\",{\"1\":{\"1277\":1}}],[\"这样会更加的灵活\",{\"1\":{\"1169\":1}}],[\"这样会更加方便一些\",{\"1\":{\"830\":1}}],[\"这样会节省很多的时间\",{\"1\":{\"798\":1}}],[\"这样会先按照列名1进行排序\",{\"1\":{\"764\":1}}],[\"这样会把\",{\"1\":{\"241\":1}}],[\"这样创建了虚拟过滤器链\",{\"1\":{\"709\":1}}],[\"这样是会报错的\",{\"1\":{\"1119\":1}}],[\"这样是为了规范\",{\"1\":{\"615\":1}}],[\"这样是不能赋值的\",{\"1\":{\"395\":1}}],[\"这样前端在拿到数据之后\",{\"1\":{\"610\":1}}],[\"这样可以大幅度减少后端的压力\",{\"1\":{\"609\":1}}],[\"这样占位符位置的所有内容都会被作为请求参数\",{\"1\":{\"589\":1}}],[\"这样作用域就上升到session\",{\"1\":{\"588\":1}}],[\"这样thymeleaf就能收到我们传递的数据进行解析\",{\"1\":{\"563\":1}}],[\"这样解决了缓冲区存在\",{\"1\":{\"531\":1}}],[\"这样有一个缺点\",{\"1\":{\"503\":1}}],[\"这样其他模块才能导入\",{\"1\":{\"465\":2}}],[\"这样进行比较也行\",{\"1\":{\"451\":1}}],[\"这样我们随时都可以向ioc容器索要对象\",{\"1\":{\"1254\":1}}],[\"这样我们无需修改之前的任何代码\",{\"1\":{\"1117\":1}}],[\"这样我们的控制台也可以看到对应的名称\",{\"1\":{\"961\":1}}],[\"这样我们同样可以正常访问\",{\"1\":{\"554\":1}}],[\"这样我们就不需要显式指定property了\",{\"1\":{\"1138\":1}}],[\"这样我们就不用显式进行空值检测\",{\"1\":{\"512\":1}}],[\"这样我们就成功地添加了一个过滤器\",{\"1\":{\"1102\":1}}],[\"这样我们就成功搭建好网络安全的测试项目了\",{\"1\":{\"636\":1}}],[\"这样我们就完成了最基本的页面配置\",{\"1\":{\"564\":1}}],[\"这样我们就完成了基本的配置\",{\"1\":{\"549\":1}}],[\"这样我们就可以获取到自增后的值了\",{\"1\":{\"862\":1}}],[\"这样我们就可以成功实现多对一查询了\",{\"1\":{\"855\":1}}],[\"这样我们就可以在首页进行修改密码操作了\",{\"1\":{\"666\":1}}],[\"这样我们就可以进行简单登录了\",{\"1\":{\"636\":1}}],[\"这样我们就可以根据给定的视图名称\",{\"1\":{\"558\":1}}],[\"这样我们就可以根据不同的类型进行选择了\",{\"1\":{\"438\":1}}],[\"这样我们就可以正常使用了\",{\"1\":{\"468\":1}}],[\"这样我们之前写的java\",{\"1\":{\"463\":1}}],[\"这样我们在遍历\",{\"1\":{\"218\":1}}],[\"这样参数名称所表示的就是一个数组\",{\"1\":{\"398\":1}}],[\"这样就只能无限循环下去了\",{\"1\":{\"1301\":1}}],[\"这样就能从任何系统崩溃中恢复过来\",{\"1\":{\"1266\":1}}],[\"这样就引入了ioc理论\",{\"1\":{\"1116\":1}}],[\"这样就消除了传递依赖\",{\"1\":{\"738\":1}}],[\"这样就会给我们省去很多的时间\",{\"1\":{\"1059\":1}}],[\"这样就会占用资源\",{\"1\":{\"721\":1}}],[\"这样就会导致我们可能只用到一部分内容\",{\"1\":{\"460\":1}}],[\"这样就很好的保证了用户密码的安全性\",{\"1\":{\"659\":1}}],[\"这样就简单很多了\",{\"1\":{\"564\":1}}],[\"这样就显得非常灵活了\",{\"1\":{\"504\":1}}],[\"这样就可以自动将mapper注入到类中了\",{\"1\":{\"1277\":1}}],[\"这样就可以开启spring的事务支持了\",{\"1\":{\"1274\":1}}],[\"这样就可以避免脏读问题了\",{\"1\":{\"1269\":1}}],[\"这样就可以保证bean的加载顺序了\",{\"1\":{\"1131\":1}}],[\"这样就可以追踪到底是哪一个浏览器在访问服务器\",{\"1\":{\"1095\":1}}],[\"这样就可以直接访问到了\",{\"1\":{\"1047\":1}}],[\"这样就可以通过配置文件的形式修改一些功能的默认属性了\",{\"1\":{\"939\":1}}],[\"这样就可以访问其他页面不会被拦截了\",{\"1\":{\"692\":1}}],[\"这样就可以了\",{\"1\":{\"692\":1}}],[\"这样就可以正常继承了\",{\"1\":{\"504\":1}}],[\"这样就可以与\",{\"1\":{\"111\":1}}],[\"这样就仿造了静态方法时的情况\",{\"1\":{\"452\":1}}],[\"这样就万事具备了\",{\"1\":{\"446\":1}}],[\"这样就是一个实现\",{\"1\":{\"412\":1}}],[\"这样就不用再去用那么多的转义字符了\",{\"1\":{\"498\":1}}],[\"这样就不会了\",{\"1\":{\"477\":1}}],[\"这样就不会得到同一个对象了\",{\"1\":{\"384\":1}}],[\"这样就不同\",{\"1\":{\"401\":1}}],[\"这样就无需再将代码写在本地\",{\"1\":{\"356\":1}}],[\"这样不会得到工厂bean的实例\",{\"1\":{\"1159\":1}}],[\"这样不断的循环\",{\"1\":{\"331\":1}}],[\"这样不仅代码量大幅度减少\",{\"1\":{\"228\":1}}],[\"这样的类加载机制\",{\"1\":{\"1109\":1}}],[\"这样的话\",{\"1\":{\"1061\":1,\"1109\":1,\"1298\":1}}],[\"这样的话相当于直接从内存中获取而不是再去向数据库索要数据\",{\"1\":{\"882\":1}}],[\"这样的方式也能注册servlet\",{\"1\":{\"1054\":1}}],[\"这样的写法终于可以编译通过了\",{\"1\":{\"480\":1}}],[\"这样的写法称为装饰者模式\",{\"1\":{\"264\":1}}],[\"这样的数字分数\",{\"1\":{\"437\":1}}],[\"这样的异常称为运行时异常\",{\"1\":{\"421\":1}}],[\"这样的\",{\"1\":{\"395\":1}}],[\"这样的做法虽然简单粗暴\",{\"1\":{\"301\":1}}],[\"这样的任务称为episodic\",{\"1\":{\"19\":1}}],[\"这样保存的元素数量就会存在限制\",{\"1\":{\"215\":1}}],[\"这样做是为了更加明确方法的具体功能\",{\"1\":{\"181\":1}}],[\"这样才能去估计相应的qπ​\",{\"1\":{\"84\":1}}],[\"这样\",{\"1\":{\"81\":1,\"363\":1,\"454\":1,\"574\":1,\"615\":1,\"617\":2,\"619\":1,\"642\":1,\"643\":1,\"652\":1,\"658\":1,\"659\":1,\"664\":1,\"672\":1,\"679\":1,\"684\":1,\"687\":2,\"767\":1,\"832\":1,\"951\":1,\"976\":1,\"985\":2,\"1010\":1,\"1082\":1,\"1117\":3,\"1125\":1,\"1127\":1,\"1128\":1,\"1133\":2,\"1139\":1,\"1149\":1,\"1151\":1,\"1152\":1,\"1181\":1,\"1191\":1,\"1192\":1,\"1211\":1,\"1219\":1,\"1220\":1,\"1224\":1,\"1233\":1,\"1241\":1,\"1247\":1,\"1256\":1,\"1257\":1,\"1259\":1,\"1260\":1,\"1270\":1,\"1318\":1,\"1328\":1}}],[\"这个过程需要beanpostprocessor来完成\",{\"1\":{\"1301\":1}}],[\"这个datasource到底是个什么\",{\"1\":{\"1242\":1}}],[\"这个点可以是方法的调用\",{\"1\":{\"1226\":1}}],[\"这个表达式支持很多种方式进行选择\",{\"1\":{\"1219\":1}}],[\"这个随便起都可以\",{\"1\":{\"1219\":1}}],[\"这个的目的就是来找那些满足条件的匹配的函数\",{\"1\":{\"1219\":1}}],[\"这个属性得有访问权限且能set才可以\",{\"1\":{\"1204\":1}}],[\"这个事件会在spring容器初始化完成会触发一次\",{\"1\":{\"1191\":1}}],[\"这个接口也是spring提供的一种bean加载机制\",{\"1\":{\"1310\":1}}],[\"这个接口获取的资源就是beanname\",{\"1\":{\"1186\":1}}],[\"这个接口中有着一套完整的增删改查操作\",{\"1\":{\"665\":1}}],[\"这个接口中什么都没定义\",{\"1\":{\"377\":1}}],[\"这个构造方法可以接收多个配置类\",{\"1\":{\"1166\":2}}],[\"这个参数可以写很多个\",{\"1\":{\"1134\":1}}],[\"这个参数就是异常的原因\",{\"1\":{\"422\":1}}],[\"这个bean将不再作为自动装配的候选bean\",{\"1\":{\"1140\":1}}],[\"这个bean的class就变成了新的类型\",{\"1\":{\"1133\":1}}],[\"这个b的实现已经过时了\",{\"1\":{\"1116\":1}}],[\"这个对象只会被创建一次\",{\"1\":{\"1129\":1}}],[\"这个对象不需要我们再去创建了\",{\"1\":{\"1119\":1}}],[\"这个实现类\",{\"1\":{\"1119\":1}}],[\"这个实现类是由mybatis根据我们的配置自动生成的\",{\"1\":{\"842\":1}}],[\"这个依赖中包含了如下依赖\",{\"1\":{\"1118\":1}}],[\"这个rootlogger对象为所有日志记录器的最顶层父级对象\",{\"1\":{\"927\":1}}],[\"这个数据库表中存在如下决定关系\",{\"1\":{\"739\":1}}],[\"这个根据我们配置文件决定\",{\"1\":{\"712\":1}}],[\"这个cookie信息的过期时间并不是仅会话\",{\"1\":{\"686\":1}}],[\"这个没有任何提示\",{\"1\":{\"660\":1}}],[\"这个时候\",{\"1\":{\"1223\":1}}],[\"这个时候spring会怎么进行处理呢\",{\"1\":{\"1181\":1}}],[\"这个时候我们就可以通过排除依赖来防止添加不必要的依赖\",{\"1\":{\"1026\":1}}],[\"这个时候就需要我们在网页展示时向后端发起请求\",{\"1\":{\"1076\":1}}],[\"这个时候就需要进行更多的配置了\",{\"1\":{\"677\":1}}],[\"这个时候就会给黑客可乘之机了\",{\"1\":{\"643\":1}}],[\"这个时候如果阈值大于0\",{\"1\":{\"217\":1}}],[\"这个页面并不是我们官方提供的页面\",{\"1\":{\"641\":1}}],[\"这个阶段会为根容器和web容器进行父子关系建立\",{\"1\":{\"625\":1}}],[\"这个类没有被注册啊\",{\"1\":{\"1310\":1}}],[\"这个类完善了配置文件读取和servlet信息相关的的操作\",{\"1\":{\"1059\":1}}],[\"这个类反过来会查找实现\",{\"1\":{\"550\":1}}],[\"这个类在初始化时会对类中其他本地方法进行注册\",{\"1\":{\"372\":1}}],[\"这个是干嘛的\",{\"1\":{\"1301\":1}}],[\"这个是服务端的响应内容\",{\"1\":{\"1058\":1}}],[\"这个是tomcat的一些文档\",{\"1\":{\"1047\":1}}],[\"这个是初始化方法\",{\"1\":{\"706\":1}}],[\"这个是源源不断的\",{\"1\":{\"478\":1}}],[\"这个是内部接口entry\",{\"1\":{\"213\":1}}],[\"这个抽象类直接就定义好了\",{\"1\":{\"412\":1}}],[\"这个长度是字符的数量\",{\"1\":{\"401\":1}}],[\"这个默认方法没有任何作用\",{\"1\":{\"376\":1}}],[\"这个注解默认情况下可以省略\",{\"1\":{\"373\":1}}],[\"这个我们会在最后一章的反射中进行讲解\",{\"1\":{\"372\":1}}],[\"这个工具类也经常被使用到\",{\"1\":{\"237\":1}}],[\"这个东西决定了hashmap的扩容效果\",{\"1\":{\"215\":1}}],[\"这个就是哈希表本体了\",{\"1\":{\"215\":1}}],[\"这个需要我们学习了map之后再来讨论\",{\"1\":{\"205\":1}}],[\"这个同样是删除指定元素\",{\"1\":{\"204\":1}}],[\"这个迭代器也是单向的\",{\"1\":{\"201\":1}}],[\"这个迭代器是针对于list的强化版本\",{\"1\":{\"194\":1}}],[\"这个效果跟上面的写法是完全一样的\",{\"1\":{\"192\":1}}],[\"这个方法由子类实现\",{\"1\":{\"1320\":1}}],[\"这个方法比较长\",{\"1\":{\"1300\":1}}],[\"这个方法里面定义了的内容\",{\"1\":{\"1242\":1}}],[\"这个方法就会在指定方法执行之前执行了\",{\"1\":{\"1233\":1}}],[\"这个方法就是我们打算对其进行的增强操作\",{\"1\":{\"1218\":1}}],[\"这个方法很明显我们并没有去编写异步执行的逻辑\",{\"1\":{\"1189\":1}}],[\"这个方法是一个静态方法\",{\"1\":{\"449\":1}}],[\"这个方法是在\",{\"1\":{\"192\":1}}],[\"这个方法我们会在jvm篇视频教程中详细介绍\",{\"1\":{\"372\":1}}],[\"这个方法我们同样会放到多线程中进行介绍\",{\"1\":{\"204\":1}}],[\"这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量\",{\"1\":{\"248\":1}}],[\"这个方法会在多线程部分中进行介绍\",{\"1\":{\"193\":1}}],[\"这个方法会在执行排序时被调用\",{\"1\":{\"171\":1}}],[\"这个方法接受一个consumer\",{\"1\":{\"192\":1}}],[\"这个生成的list是只读的\",{\"1\":{\"182\":1}}],[\"这个套娃是可以一直套下去的\",{\"1\":{\"182\":1}}],[\"这个只做了解就行\",{\"1\":{\"182\":1}}],[\"这个操作并不是一定会添加成功\",{\"1\":{\"180\":1}}],[\"这个仍然与之前一致\",{\"1\":{\"79\":1}}],[\"这个\",{\"1\":{\"78\":1,\"708\":1}}],[\"这个便成为\",{\"1\":{\"23\":1}}],[\"这步是更新策略π\",{\"1\":{\"63\":1}}],[\"这里注册了注解处理配置相关的后置处理器\",{\"1\":{\"1318\":1}}],[\"这里很关键\",{\"1\":{\"1301\":1}}],[\"这里很明显是同步调用的方法\",{\"1\":{\"1189\":1}}],[\"这里getobjectforbeaninstance会进行最终处理\",{\"1\":{\"1300\":1}}],[\"这里导入的是junit5和springtest模块依赖\",{\"1\":{\"1290\":1}}],[\"这里暂时不做介绍\",{\"1\":{\"1284\":1}}],[\"这里暂时不提及\",{\"1\":{\"1047\":1}}],[\"这里要介绍的\",{\"1\":{\"1260\":1}}],[\"这里要获取field类的modifiers字段进行修改\",{\"1\":{\"350\":1}}],[\"这里写一个测试的mapper类\",{\"1\":{\"1255\":1}}],[\"这里写上刚刚的名字\",{\"1\":{\"1119\":1}}],[\"这里并不会真的关闭连接\",{\"1\":{\"1247\":1}}],[\"这里依靠unpooleddatasource创建了一个connection对象\",{\"1\":{\"1246\":1}}],[\"这里依然使用axios发送post请求\",{\"1\":{\"617\":1}}],[\"这里args指明参数\",{\"1\":{\"1235\":1}}],[\"这里介绍一下\",{\"1\":{\"1226\":1}}],[\"这里其实是spring通过cglib为我们生成的动态代理类\",{\"1\":{\"1222\":1}}],[\"这里其实是使用的就是我们之前讲解的spel表达式\",{\"1\":{\"696\":1}}],[\"这里创建的时课程名称组成的新集合\",{\"1\":{\"1210\":1}}],[\"这里创建一个虚拟的过滤链\",{\"1\":{\"708\":1}}],[\"这里表示exp为某个对应的name属性\",{\"1\":{\"1203\":1}}],[\"这里表示匹配所有请求\",{\"1\":{\"1102\":1}}],[\"这里得到的就是一个很简单的\",{\"1\":{\"1202\":1}}],[\"这里得到的student对象是由spring通过反射机制帮助我们创建的\",{\"1\":{\"1119\":1}}],[\"这里都是常量值了\",{\"1\":{\"1200\":1}}],[\"这里甚至还会直接显示对应配置项的值\",{\"1\":{\"1199\":1}}],[\"这里拿到的就是\",{\"1\":{\"1192\":1}}],[\"这里简单讲解一下cron表达式\",{\"1\":{\"1190\":1}}],[\"这里还有一个很细节的操作\",{\"1\":{\"1159\":1}}],[\"这里最后再提一下\",{\"1\":{\"1152\":1}}],[\"这里匹配的就是我们刚刚编写的需要一个参数的构造方法\",{\"1\":{\"1134\":1}}],[\"这里一共有两种作用域\",{\"1\":{\"1129\":1}}],[\"这里一定要区分两者的不同\",{\"1\":{\"593\":1}}],[\"这里出现了一个bean定义不唯一异常\",{\"1\":{\"1126\":1}}],[\"这里出现的都是spring核心相关的内容\",{\"1\":{\"1118\":1}}],[\"这里只需要传入一个datasource的实现即可\",{\"1\":{\"1259\":1}}],[\"这里只需要添加我们刚刚写好的advisor就可以了\",{\"1\":{\"1231\":1}}],[\"这里只需要包括一个script标签我们就能像之前xml那样编写动态sql了\",{\"1\":{\"902\":1}}],[\"这里只是对两个对象进行equals判断\",{\"1\":{\"182\":1}}],[\"这里就跟我们之前讲的连起来了\",{\"1\":{\"1321\":1}}],[\"这里就根据之前的连接对象直接new一个新的连接\",{\"1\":{\"1246\":1}}],[\"这里就暂时先介绍这么多\",{\"1\":{\"865\":1}}],[\"这里就不深入讲解具体实现了\",{\"1\":{\"1318\":1}}],[\"这里就不进行列举了\",{\"1\":{\"1310\":1}}],[\"这里就不一一列出了\",{\"1\":{\"1298\":1}}],[\"这里就不一一列举了\",{\"1\":{\"573\":1}}],[\"这里就不挨个介绍了\",{\"1\":{\"973\":1}}],[\"这里就不多做介绍了\",{\"1\":{\"864\":1}}],[\"这里就不多说了\",{\"1\":{\"480\":1,\"1181\":1}}],[\"这里就不再介绍了\",{\"1\":{\"769\":1}}],[\"这里就不再演示了\",{\"1\":{\"583\":1,\"1018\":1}}],[\"这里就不做详细介绍了\",{\"1\":{\"995\":1}}],[\"这里就不做演示了\",{\"1\":{\"698\":1,\"1047\":1}}],[\"这里就不做介绍了\",{\"1\":{\"480\":1}}],[\"这里就不提了\",{\"1\":{\"485\":1}}],[\"这里就不解释了\",{\"1\":{\"217\":1}}],[\"这里就不列出了\",{\"1\":{\"201\":1}}],[\"这里usegeneratedkeys设置为true表示我们希望获取数据库生成的键\",{\"1\":{\"862\":1}}],[\"这里url\",{\"1\":{\"545\":1}}],[\"这里id实际上就是param1\",{\"1\":{\"843\":1}}],[\"这里调用我们编写的接口方法\",{\"1\":{\"842\":1}}],[\"这里建议将对应的xml配置也放到放到同包中\",{\"1\":{\"842\":1}}],[\"这里截取部分mybatis源代码进行演示\",{\"1\":{\"841\":1}}],[\"这里也可以使用<id>标签\",{\"1\":{\"835\":1}}],[\"这里列出14个常见的内部过滤器\",{\"1\":{\"714\":1}}],[\"这里获取的都是springsecurity提供的过滤器\",{\"1\":{\"708\":1}}],[\"这里获取的是根容器\",{\"1\":{\"625\":1}}],[\"这里获取了一个filter列表\",{\"1\":{\"708\":1}}],[\"这里才是真正的调用\",{\"1\":{\"707\":1}}],[\"这里省略\",{\"1\":{\"707\":1}}],[\"这里通过webapplicationcontext获取了一个bean\",{\"1\":{\"706\":1}}],[\"这里插入了关键的filterchain\",{\"1\":{\"705\":1}}],[\"这里设置为登录界面\",{\"1\":{\"683\":1}}],[\"这里登陆页面填写为\",{\"1\":{\"680\":1}}],[\"这里为了简单\",{\"1\":{\"668\":1}}],[\"这里为了教学简单\",{\"1\":{\"552\":1}}],[\"这里指的是任何请求路径\",{\"1\":{\"660\":1}}],[\"这里温馨提醒一下\",{\"1\":{\"660\":1}}],[\"这里将用户名和密码配置封装为一个properties对象\",{\"1\":{\"1244\":1}}],[\"这里将密码进行加密后存储\",{\"1\":{\"659\":2}}],[\"这里将bcryptpasswordencoder直接注册为bean\",{\"1\":{\"659\":1}}],[\"这里实际上会自动注册一个filter\",{\"1\":{\"650\":1}}],[\"这里实际上是将方法参数的局部变量name赋值为本身\",{\"1\":{\"164\":1}}],[\"这里有一个误区\",{\"1\":{\"1158\":1}}],[\"这里有一个rowbounds参数\",{\"1\":{\"835\":1}}],[\"这里有一个恶意脚本\",{\"1\":{\"642\":1}}],[\"这里有多种mobility\",{\"1\":{\"14\":1}}],[\"这里主要会遍历\",{\"1\":{\"631\":1}}],[\"这里进行了service的执行\",{\"1\":{\"626\":1}}],[\"这里进行4次加法运算\",{\"1\":{\"402\":1}}],[\"这里以简单的登录为例\",{\"1\":{\"617\":1}}],[\"这里以输入流的方式获取\",{\"1\":{\"490\":1}}],[\"这里填入了视图的名称\",{\"1\":{\"561\":1}}],[\"这里和之前的switch语句是一样的\",{\"1\":{\"497\":1}}],[\"这里打印一下看看网页\",{\"1\":{\"490\":1}}],[\"这里虽然是有了var关键字进行自动类型推断\",{\"1\":{\"485\":1}}],[\"这里类型写为string\",{\"1\":{\"480\":1}}],[\"这里限制生成20个\",{\"1\":{\"478\":1}}],[\"这里新增的是允许结束迭代的\",{\"1\":{\"478\":1}}],[\"这里不多介绍了\",{\"1\":{\"1244\":1}}],[\"这里不多做阐述\",{\"1\":{\"693\":1}}],[\"这里不进行介绍\",{\"1\":{\"835\":1}}],[\"这里不要开启始终记住\",{\"1\":{\"686\":1}}],[\"这里不仅仅可以是model\",{\"1\":{\"563\":1}}],[\"这里不是指进行io操作的流\",{\"1\":{\"476\":1}}],[\"这里不讲解原理\",{\"1\":{\"330\":1}}],[\"这里添加一个模块的依赖\",{\"1\":{\"465\":1}}],[\"这里t可以是任何类型\",{\"1\":{\"438\":1}}],[\"这里发生的是数组越界异常\",{\"1\":{\"424\":1}}],[\"这里仅仅是对正则表达式的简单使用\",{\"1\":{\"403\":1}}],[\"这里字符串是oooo\",{\"1\":{\"403\":1}}],[\"这里ceiling表示向上取整\",{\"1\":{\"386\":1}}],[\"这里会配置为所有的接口都能被扫描\",{\"1\":{\"1327\":1}}],[\"这里会判断bean是否为正在创建状态\",{\"1\":{\"1300\":1}}],[\"这里会判断容量是否充足\",{\"1\":{\"182\":1}}],[\"这里会明确指出是哪一个变量调用出现了空指针\",{\"1\":{\"500\":1}}],[\"这里会有一个integercache\",{\"1\":{\"384\":1}}],[\"这里本质上就是被自动包装成了一个integer类型的对象\",{\"1\":{\"384\":1}}],[\"这里使用filehandler类型\",{\"1\":{\"920\":1}}],[\"这里使用gid作为分组id的逻辑外键\",{\"1\":{\"855\":1}}],[\"这里使用了\",{\"1\":{\"573\":1}}],[\"这里使用thymeleaf的网址链接表达式\",{\"1\":{\"564\":1}}],[\"这里使用javap命令对class文件进行反编译得到\",{\"1\":{\"378\":1}}],[\"这里使用的是list的迭代器在进行遍历操作\",{\"1\":{\"187\":1}}],[\"这里向上抛出一下异常\",{\"1\":{\"377\":1}}],[\"这里变成ioexception是因为调用close\",{\"1\":{\"247\":1}}],[\"这里因为本来就是integer\",{\"1\":{\"228\":1}}],[\"这里返回的bean会交给下一个阶段\",{\"1\":{\"1307\":1}}],[\"这里返回的bean相当于最终的结果了\",{\"1\":{\"1307\":1}}],[\"这里返回之后是什么就是什么了\",{\"1\":{\"1307\":1}}],[\"这里返回m\",{\"1\":{\"221\":1}}],[\"这里返回原来的value+m\",{\"1\":{\"221\":2}}],[\"这里多了一个指向前一个结点和后一个结点的引用\",{\"1\":{\"218\":1}}],[\"这里直接创建一个新的consolehandler对象\",{\"1\":{\"919\":1}}],[\"这里直接设定为控制台输出\",{\"1\":{\"789\":1}}],[\"这里直接将待插入结点等于原本冲突的结点\",{\"1\":{\"216\":1}}],[\"这里直接o2\",{\"1\":{\"171\":1}}],[\"这里计算完键的哈希值之后\",{\"1\":{\"216\":1}}],[\"这里用的是url\",{\"1\":{\"826\":1}}],[\"这里用的是内部类entry在表示\",{\"1\":{\"213\":1}}],[\"这里用到了迭代器\",{\"1\":{\"180\":1}}],[\"这里做了解就行了\",{\"1\":{\"202\":1}}],[\"这里随便写的\",{\"1\":{\"193\":1}}],[\"这里我们还是以study方法为例\",{\"1\":{\"1224\":1}}],[\"这里我们按照上面的要求\",{\"1\":{\"1220\":1}}],[\"这里我们按照规律\",{\"1\":{\"490\":1}}],[\"这里我们在resource目录下创建一个test\",{\"1\":{\"1197\":1}}],[\"这里我们在resultmap标签中配置了一些result标签\",{\"1\":{\"835\":1}}],[\"这里我们通过aware在初始化的时候拿到\",{\"1\":{\"1192\":1}}],[\"这里我们通过getclass来获取一下类型\",{\"1\":{\"1189\":1}}],[\"这里我们通过反射来获取string类中的value字段\",{\"1\":{\"462\":1}}],[\"这里我们会注入一个name的初始值\",{\"1\":{\"1149\":1}}],[\"这里我们会得到一个\",{\"1\":{\"927\":1}}],[\"这里我们先介绍第一种\",{\"1\":{\"1119\":1}}],[\"这里我们先暂时不介绍继承关系\",{\"1\":{\"918\":1}}],[\"这里我们来测试一下junit\",{\"1\":{\"1017\":1}}],[\"这里我们来尝试一下第一种方案\",{\"1\":{\"642\":1}}],[\"这里我们尝试新建一个类用于单元测试\",{\"1\":{\"959\":1}}],[\"这里我们打印一下系统名称和版本\",{\"1\":{\"938\":1}}],[\"这里我们不如再做的更加极致一点\",{\"1\":{\"904\":1}}],[\"这里我们连续获取了两次id为1的用户\",{\"1\":{\"883\":1}}],[\"这里我们连续插入两个同样的字符串\",{\"1\":{\"205\":1}}],[\"这里我们将parametertype类型设置为我们的实体类型\",{\"1\":{\"861\":1}}],[\"这里我们将com\",{\"1\":{\"464\":2}}],[\"这里我们让user左连接到book表中\",{\"1\":{\"853\":1}}],[\"这里我们让age在赋值时增加一次\",{\"1\":{\"841\":1}}],[\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息\",{\"1\":{\"851\":1}}],[\"这里我们填写刚刚的id\",{\"1\":{\"832\":1}}],[\"这里我们只需要配置一下登录的地址和登录按钮即可\",{\"1\":{\"682\":1}}],[\"这里我们首先用另一个浏览器访问目标网站\",{\"1\":{\"642\":1}}],[\"这里我们首先讲解最传统的xml配置形式\",{\"1\":{\"543\":1}}],[\"这里我们基于mvc框架重新搭建一个采用之前的验证方式的简易网站\",{\"1\":{\"636\":1}}],[\"这里我们以axios框架的简单使用为例子\",{\"1\":{\"617\":1}}],[\"这里我们修改了produces的值\",{\"1\":{\"615\":1}}],[\"这里我们使用\",{\"1\":{\"991\":1}}],[\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",{\"1\":{\"873\":1}}],[\"这里我们使用阿里巴巴的fastjson进行解析\",{\"1\":{\"611\":1}}],[\"这里我们使用thymeleaf为我们提供的视图解析器\",{\"1\":{\"559\":1}}],[\"这里我们创建一个用于测试的简单项目\",{\"1\":{\"1023\":1}}],[\"这里我们创建一个测试类来试试看\",{\"1\":{\"588\":1}}],[\"这里我们创建一个新的项目\",{\"1\":{\"461\":1}}],[\"这里我们直接通过getargs\",{\"1\":{\"1223\":1}}],[\"这里我们直接创建一个新的类\",{\"1\":{\"1218\":1}}],[\"这里我们直接使用左连接\",{\"1\":{\"850\":1}}],[\"这里我们直接记录下这个jsessionid\",{\"1\":{\"642\":1}}],[\"这里我们直接在配置类中编写\",{\"1\":{\"560\":1}}],[\"这里我们直接配置包扫描\",{\"1\":{\"549\":1}}],[\"这里我们继续使用之前的tomcat10服务器\",{\"1\":{\"542\":1}}],[\"这里我们选择programteacher\",{\"1\":{\"1133\":1}}],[\"这里我们选择ofstring直接响应实体转换为string字符串\",{\"1\":{\"490\":1}}],[\"这里我们选择使用父类的带参构造\",{\"1\":{\"422\":1}}],[\"这里我们写一个泛型类\",{\"1\":{\"480\":1}}],[\"这里我们可以将其嵌入到页面中\",{\"1\":{\"660\":1}}],[\"这里我们可以直接尝试进行事务的提交\",{\"1\":{\"865\":1}}],[\"这里我们可以直接去掉\",{\"1\":{\"658\":1}}],[\"这里我们可以直接将一些元素封装到stream中\",{\"1\":{\"476\":1}}],[\"这里我们可以自由传入任意数量的字符串\",{\"1\":{\"398\":1}}],[\"这里我们就先从构造方法开始走起\",{\"1\":{\"1317\":1}}],[\"这里我们就先演示以角色方式来进行授权\",{\"1\":{\"691\":1}}],[\"这里我们就直接演示beandefinitionregistrypostprocessor的实现\",{\"1\":{\"1311\":1}}],[\"这里我们就只是简单的执行\",{\"1\":{\"1219\":1}}],[\"这里我们就在配置文件中编写好了对应bean的信息\",{\"1\":{\"1119\":1}}],[\"这里我们就来创建两个项目\",{\"1\":{\"464\":1}}],[\"这里我们就简单将i转换为字符串形式\",{\"1\":{\"447\":1}}],[\"这里我们导入java\",{\"1\":{\"461\":1}}],[\"这里我们需要在配置文件中进行aop配置\",{\"1\":{\"1218\":1}}],[\"这里我们需要在mybatis配置文件中添加\",{\"1\":{\"852\":1}}],[\"这里我们需要修改一下user表来记录每一个用户所属的小组id\",{\"1\":{\"855\":1}}],[\"这里我们需要使用selectlist方法来执行\",{\"1\":{\"836\":1}}],[\"这里我们需要根据用户id查询\",{\"1\":{\"831\":1}}],[\"这里我们需要添加一个断点来查看到底获取到了什么bean\",{\"1\":{\"706\":1}}],[\"这里我们需要特别注意一下\",{\"1\":{\"408\":1}}],[\"这里我们需进行模块导入\",{\"1\":{\"461\":1}}],[\"这里我们拋个异常看看\",{\"1\":{\"446\":1}}],[\"这里我们定义一个test注解\",{\"1\":{\"363\":1}}],[\"这里我们定义一个info静态变量\",{\"1\":{\"274\":1}}],[\"这里我们随便写一个类\",{\"1\":{\"193\":1}}],[\"这里我们接着介绍另一个列表实现类\",{\"1\":{\"182\":1}}],[\"这里同样是进行取余操作\",{\"1\":{\"216\":1}}],[\"这里同样只需要一个comparator就行了\",{\"1\":{\"181\":1}}],[\"这里同样用到了迭代器\",{\"1\":{\"181\":1}}],[\"这里传入的类型是什么\",{\"1\":{\"171\":1}}],[\"这里是关键\",{\"1\":{\"1242\":1}}],[\"这里是每两秒钟打印一次\",{\"1\":{\"1190\":1}}],[\"这里是每个无人机都有一张自己的q\",{\"1\":{\"13\":1}}],[\"这里是个究极大坑\",{\"1\":{\"660\":1}}],[\"这里是求和\",{\"1\":{\"228\":1}}],[\"这里是倒着往回遍历\",{\"1\":{\"194\":1}}],[\"这里是\",{\"1\":{\"166\":1}}],[\"这里需要在外层套上\",{\"1\":{\"1199\":1}}],[\"这里需要提一下\",{\"1\":{\"1175\":1}}],[\"这里需要添加autowire属性\",{\"1\":{\"1137\":1}}],[\"这里需要用到insert标签\",{\"1\":{\"861\":1}}],[\"这里需要使用ajax方法来处理\",{\"1\":{\"617\":1}}],[\"这里需要先添加一个依赖\",{\"1\":{\"616\":1}}],[\"这里需要特别说一下\",{\"1\":{\"395\":1}}],[\"这里需要特别注意\",{\"1\":{\"166\":1}}],[\"这里需要填写两个泛型参数\",{\"1\":{\"213\":1}}],[\"这里需要介绍一下优先级队列\",{\"1\":{\"203\":1}}],[\"这里需要通过迭代算法来精确求出\",{\"1\":{\"70\":1}}],[\"这里没有使用this\",{\"1\":{\"164\":1}}],[\"这里编写代码跟我们之前在main中是一样的\",{\"1\":{\"162\":1}}],[\"这里定义的人类具有三个属性\",{\"1\":{\"161\":1}}],[\"这里可以用不同的方法来近似\",{\"1\":{\"156\":1}}],[\"这里的type属性一共三个选项\",{\"1\":{\"1242\":1}}],[\"这里的transient关键字我们会在后面i\",{\"1\":{\"182\":1}}],[\"这里的bean类型需要填写为student类的工厂类\",{\"1\":{\"1158\":1}}],[\"这里的constructor\",{\"1\":{\"1134\":1}}],[\"这里的column和javatype可以不填\",{\"1\":{\"850\":1}}],[\"这里的初始化参数仅仅是针对于此servlet\",{\"1\":{\"1086\":1}}],[\"这里的snapshot代表快照\",{\"1\":{\"1003\":1}}],[\"这里的查询操作实际上只进行了一次\",{\"1\":{\"883\":1}}],[\"这里的参数我们依然选择使用user\",{\"1\":{\"863\":1}}],[\"这里的id与用户id一致\",{\"1\":{\"849\":1}}],[\"这里的i就是最终得到的下标位置了\",{\"1\":{\"216\":1}}],[\"这里的object就是刚刚构造好的实体类对象\",{\"1\":{\"841\":1}}],[\"这里的filter列表中的所有filter并没有被注册\",{\"1\":{\"708\":1}}],[\"这里的动态不是指有动画效果\",{\"1\":{\"617\":1}}],[\"这里的name是其所依附对象的\",{\"1\":{\"408\":1}}],[\"这里的话只能使用接口中的方法\",{\"1\":{\"376\":1}}],[\"这里的\",{\"1\":{\"237\":1,\"552\":1,\"708\":1,\"896\":1,\"991\":1}}],[\"这里的p1存放的是对象的引用\",{\"1\":{\"161\":1}}],[\"这里的a存放的是具体的某个值\",{\"1\":{\"161\":1}}],[\"这里的策略是随机性\",{\"1\":{\"155\":1}}],[\"这里的最优策略πk+1​是一个\",{\"1\":{\"63\":1}}],[\"这里在视频没有详细介绍\",{\"1\":{\"155\":1}}],[\"这里包含了一个\",{\"1\":{\"136\":1}}],[\"这里\",{\"1\":{\"66\":1}}],[\"这里采用离散化空间坐标\",{\"1\":{\"13\":1}}],[\"通知描述了切面何时执行以及如何执行增强处理\",{\"1\":{\"1226\":1}}],[\"通知\",{\"1\":{\"1226\":1}}],[\"通俗点说\",{\"1\":{\"515\":1}}],[\"通俗的讲就是页面中数据和页面本身\",{\"1\":{\"558\":1}}],[\"通俗的讲就是我们之前用于封装数据传递的实体类\",{\"1\":{\"541\":1}}],[\"通俗的讲\",{\"1\":{\"331\":1,\"589\":1}}],[\"通配符匹配\",{\"0\":{\"571\":1}}],[\"通配符\",{\"1\":{\"438\":1}}],[\"通常是启动类或配置类\",{\"1\":{\"1310\":1}}],[\"通常是具有有限步长的trajectory\",{\"1\":{\"19\":1}}],[\"通常情况下\",{\"1\":{\"1266\":1}}],[\"通常\",{\"1\":{\"1211\":1}}],[\"通常为\",{\"1\":{\"528\":2}}],[\"通常也称为\",{\"1\":{\"135\":1}}],[\"通过断点我们发现\",{\"1\":{\"1327\":1}}],[\"通过断点调试\",{\"1\":{\"706\":1}}],[\"通过之前的了解\",{\"1\":{\"1326\":1}}],[\"通过工厂获取早期对象代码如下\",{\"1\":{\"1301\":1}}],[\"通过此方法就能快速得到\",{\"1\":{\"1299\":1}}],[\"通过此参数就可以快速获取切点位置的一些信息\",{\"1\":{\"1223\":1}}],[\"通过了解数据源\",{\"1\":{\"1252\":1}}],[\"通过advice实现aop\",{\"1\":{\"1231\":2}}],[\"通过aop我们可以在保证原有业务不变的情况下\",{\"1\":{\"1215\":1}}],[\"通过合理利用aop带来的便捷\",{\"1\":{\"1224\":1}}],[\"通过proceed方法来执行代理的方法\",{\"1\":{\"1224\":1}}],[\"通过成员属性对应的set方法完成注入\",{\"1\":{\"1136\":1}}],[\"通过依赖注入\",{\"1\":{\"1133\":1}}],[\"通过定义抽象+容器管理的形式\",{\"1\":{\"1117\":1}}],[\"通过运行tomcat服务器\",{\"1\":{\"1047\":1}}],[\"通过流程图我们得知\",{\"1\":{\"1009\":1}}],[\"通过modules标签将项目的所有子项目引用进来\",{\"1\":{\"1038\":1}}],[\"通过maven\",{\"1\":{\"1000\":1}}],[\"通过method对象的invoke方法来调用方法\",{\"1\":{\"349\":2}}],[\"通过在类中定义多个内部类来完成\",{\"1\":{\"988\":1}}],[\"通过修改form标签的属性\",{\"1\":{\"1069\":1}}],[\"通过修改对应的format函数来实现自定义\",{\"1\":{\"944\":1}}],[\"通过修改页面的dom结构来执行恶意代码\",{\"1\":{\"643\":1}}],[\"通过日志输出的结果会更加规范\",{\"1\":{\"908\":1}}],[\"通过序列化\",{\"1\":{\"884\":1}}],[\"通过执行另外一个\",{\"1\":{\"849\":1}}],[\"通过namespace来将各种操作绑定到一个接口上\",{\"1\":{\"842\":1}}],[\"通过前面的学习\",{\"1\":{\"841\":1}}],[\"通过进行配置\",{\"1\":{\"824\":1}}],[\"通过一个xml文件去配置\",{\"1\":{\"824\":1}}],[\"通过ioc容器\",{\"1\":{\"1259\":1}}],[\"通过ioc容器进行管理的bean都是单例模式的\",{\"1\":{\"1129\":1}}],[\"通过init\",{\"1\":{\"1147\":1}}],[\"通过invoker为传入的实体类对象赋值\",{\"1\":{\"841\":1}}],[\"通过idea我们可以使用ctrl+\",{\"1\":{\"817\":1}}],[\"通过isinterrupted\",{\"1\":{\"301\":1}}],[\"通过开启事务\",{\"1\":{\"806\":1}}],[\"通过直接将我们的内容进行替换的方式来填写数据\",{\"1\":{\"805\":1}}],[\"通过drivermanager获取的数据库连接\",{\"1\":{\"1242\":1}}],[\"通过drivermanager来获得数据库连接\",{\"1\":{\"788\":1}}],[\"通过drop来删除一个视图\",{\"1\":{\"779\":1}}],[\"通过drop来删除一个列\",{\"1\":{\"751\":1}}],[\"通过java如何去使用数据库来帮助我们存储数据\",{\"1\":{\"786\":1}}],[\"通过javac命令\",{\"1\":{\"356\":1}}],[\"通过学习它们能够让你的数据库管理能力更上一层楼\",{\"1\":{\"782\":1}}],[\"通过下面的命令来查看触发器\",{\"1\":{\"781\":1}}],[\"通过构造方法完成注入\",{\"1\":{\"1136\":1}}],[\"通过构造函数来构建\",{\"1\":{\"523\":1}}],[\"通过构建一个er图\",{\"1\":{\"733\":1}}],[\"通过访问\",{\"1\":{\"727\":1}}],[\"通过httpsessionsecuritycontextrepository接口从session中读取securitycontext或是直接创建新的\",{\"1\":{\"714\":1}}],[\"通过session\",{\"1\":{\"1097\":1}}],[\"通过setattribute方法来给当前请求添加一个附加数据\",{\"1\":{\"1083\":1}}],[\"通过servletcontext注册delegatingfilterproxy这个filter\",{\"1\":{\"705\":1}}],[\"通过sqlsession进行事务提交\",{\"1\":{\"865\":1}}],[\"通过socket对象\",{\"1\":{\"720\":1}}],[\"通过socket技术\",{\"1\":{\"718\":1}}],[\"通过string\",{\"1\":{\"248\":1}}],[\"通过查询数据库中的用户信息来进行用户登录呢\",{\"1\":{\"661\":1}}],[\"通过将对应的bean类型注册到容器中\",{\"1\":{\"1265\":1}}],[\"通过将用户的密码进行hash值计算\",{\"1\":{\"659\":1}}],[\"通过将这些包分出不同的模块\",{\"1\":{\"460\":1}}],[\"通过这方法名字我们可以猜测\",{\"1\":{\"1245\":1}}],[\"通过这样进行划分\",{\"1\":{\"1109\":1}}],[\"通过这样的方式\",{\"1\":{\"641\":1}}],[\"通过这种方式创建的map和通过arrays创建的list比较类似\",{\"1\":{\"475\":1}}],[\"通过这种方式\",{\"1\":{\"356\":1,\"756\":1,\"1134\":1}}],[\"通过结果发现一旦返回false\",{\"1\":{\"598\":1}}],[\"通过添加\",{\"1\":{\"696\":1}}],[\"通过添加redirect\",{\"1\":{\"587\":1}}],[\"通过添加abstract关键字\",{\"1\":{\"375\":1}}],[\"通过yield指定返回结果\",{\"1\":{\"497\":1}}],[\"通过过滤器过滤\",{\"1\":{\"476\":1}}],[\"通过它大大方便了我们的编程\",{\"1\":{\"476\":1}}],[\"通过具体对象\",{\"1\":{\"452\":1}}],[\"通过自动装箱转换的integer对象\",{\"1\":{\"384\":1}}],[\"通过反射机制\",{\"1\":{\"365\":1}}],[\"通过反射可以直接将final修饰符直接去除\",{\"1\":{\"350\":1}}],[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值\",{\"1\":{\"350\":1}}],[\"通过方法名和形参类型获取类中的方法\",{\"1\":{\"349\":2}}],[\"通过调用getmethod\",{\"1\":{\"349\":1}}],[\"通过调用sleep\",{\"1\":{\"300\":1}}],[\"通过调用start\",{\"1\":{\"297\":1}}],[\"通过获取类的构造方法\",{\"1\":{\"348\":1}}],[\"通过实例对象获取\",{\"1\":{\"339\":1}}],[\"通过包名\",{\"1\":{\"339\":1}}],[\"通过类名获取\",{\"1\":{\"339\":1}}],[\"通过classloader将类加载\",{\"1\":{\"337\":1}}],[\"通过多线程编程\",{\"1\":{\"331\":1}}],[\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了\",{\"1\":{\"312\":1}}],[\"通过创建statement对象\",{\"1\":{\"1242\":1}}],[\"通过创建索引\",{\"1\":{\"780\":1}}],[\"通过创建thread对象来创建一个新的线程\",{\"1\":{\"296\":1}}],[\"通过创建泛型接口的匿名内部类\",{\"1\":{\"171\":1}}],[\"通过file对象\",{\"1\":{\"255\":2}}],[\"通过while循环来一次性读完内容\",{\"1\":{\"248\":1}}],[\"通过getobject\",{\"1\":{\"1327\":1}}],[\"通过getbean方法就可以直接拿到了\",{\"1\":{\"1299\":1}}],[\"通过getfield\",{\"1\":{\"350\":1}}],[\"通过get方法返回得到的值\",{\"1\":{\"228\":1}}],[\"通过gak\",{\"1\":{\"5\":1}}],[\"通过观察\",{\"1\":{\"224\":1}}],[\"通过resize方法初始化底层哈希表\",{\"1\":{\"216\":1}}],[\"通过给定的键\",{\"1\":{\"213\":1}}],[\"通过给设定泛型上限\",{\"1\":{\"172\":1}}],[\"通过使用表达式\",{\"1\":{\"1201\":1}}],[\"通过使用空格和换行来完成分段\",{\"1\":{\"1042\":1}}],[\"通过使用这些工具\",{\"1\":{\"888\":1}}],[\"通过使用动态sql语句\",{\"1\":{\"877\":1}}],[\"通过使用left\",{\"1\":{\"769\":1}}],[\"通过使用group\",{\"1\":{\"766\":1}}],[\"通过使用inner\",{\"1\":{\"769\":1}}],[\"通过使用insert\",{\"1\":{\"754\":1}}],[\"通过使用ifpresentorelse\",{\"1\":{\"480\":1}}],[\"通过使用drop\",{\"1\":{\"749\":1}}],[\"通过使用关系型数据库\",{\"1\":{\"733\":1}}],[\"通过使用角色控制页面的访问\",{\"1\":{\"692\":1}}],[\"通过使用userdetailsmanager对象\",{\"1\":{\"665\":1}}],[\"通过使用select语句来进行单表查询\",{\"1\":{\"762\":1}}],[\"通过使用setpriority方法来设定优先级\",{\"1\":{\"302\":1}}],[\"通过使用springmvc框架\",{\"1\":{\"586\":1}}],[\"通过使用\",{\"1\":{\"585\":1,\"744\":1,\"810\":1,\"812\":2,\"831\":1}}],[\"通过使用opens关键字来为其他模块开放反射权限\",{\"1\":{\"466\":1}}],[\"通过使用newinstance\",{\"1\":{\"348\":1}}],[\"通过使用yield\",{\"1\":{\"304\":1}}],[\"通过使用迭代器\",{\"1\":{\"188\":1}}],[\"通过使用一个函数来进行拟合\",{\"1\":{\"131\":1}}],[\"通过梯度的算法来最小化对应的损失函数\",{\"1\":{\"142\":1}}],[\"通过采取\",{\"1\":{\"85\":1}}],[\"通过迭代算法求解\",{\"1\":{\"77\":1}}],[\"通过求解\",{\"1\":{\"48\":1}}],[\"通过\",{\"1\":{\"29\":1,\"45\":1,\"47\":1,\"70\":1,\"75\":1,\"82\":1,\"241\":1,\"522\":1,\"524\":1,\"550\":1,\"727\":1,\"1168\":1,\"1199\":1,\"1326\":1}}],[\"通过k\",{\"1\":{\"13\":1}}],[\"通过优化无人机的部署和动态移动来解决总用户mos最大化问题\",{\"1\":{\"5\":1}}],[\"更多详细内容请查阅\",{\"1\":{\"1219\":1}}],[\"更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署\",{\"1\":{\"4\":1}}],[\"更可以调用\",{\"1\":{\"1196\":1}}],[\"更准确的说是多个组件\",{\"1\":{\"1166\":2}}],[\"更准确地说应该进行hash处理\",{\"1\":{\"659\":1}}],[\"更积极地基于垃圾收集器状态和弱引用规则移除对象\",{\"1\":{\"884\":1}}],[\"更推荐使用批处理来优化这种情况\",{\"1\":{\"871\":1}}],[\"更不用说如果我还需要进行实体类映射\",{\"1\":{\"816\":1}}],[\"更像是完成自己对应的职责\",{\"1\":{\"714\":1}}],[\"更像是一个处理业务的servlet\",{\"1\":{\"714\":1}}],[\"更加精细地划分对应的职责\",{\"1\":{\"541\":1}}],[\"更加高效利用\",{\"1\":{\"80\":1}}],[\"更简洁\",{\"1\":{\"528\":1}}],[\"更新\",{\"1\":{\"796\":1,\"865\":1}}],[\"更新与删除\",{\"1\":{\"744\":1}}],[\"更新用户信息\",{\"1\":{\"665\":1}}],[\"更新页面中的数据等等\",{\"1\":{\"617\":1}}],[\"更新一定次数后\",{\"1\":{\"142\":1}}],[\"更新策略的步骤就是选择此时\",{\"1\":{\"77\":1}}],[\"更注重长远的reward\",{\"1\":{\"19\":1}}],[\"更远视\",{\"1\":{\"19\":1}}],[\"γa∑​π\",{\"1\":{\"45\":1}}],[\"γ\",{\"1\":{\"39\":1,\"48\":1,\"110\":1}}],[\"γ接近1\",{\"1\":{\"19\":1}}],[\"γ∈\",{\"1\":{\"19\":1}}],[\"γkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"γkn​​\",{\"1\":{\"9\":1}}],[\"γk0​σ2μlos​pmax​​\",{\"1\":{\"9\":1}}],[\"π2\",{\"1\":{\"70\":1}}],[\"π2​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"π1​=argmaxπ​\",{\"1\":{\"70\":2}}],[\"π180​θkn​​−ζ\",{\"1\":{\"9\":1}}],[\"π0​\",{\"1\":{\"70\":1}}],[\"π0​pe​vπ0​​pi​π1​pe​vπ1​​pi​π2​pe​vπ2​​pi​\",{\"1\":{\"65\":1,\"70\":1}}],[\"πk​的\",{\"1\":{\"68\":1}}],[\"πk​\",{\"1\":{\"66\":2,\"78\":1}}],[\"πk+1​=πargmax​\",{\"1\":{\"66\":1,\"70\":2}}],[\"πk+1​=argmaxπ​\",{\"1\":{\"63\":1,\"77\":1}}],[\"πk+1​\",{\"1\":{\"63\":2,\"66\":2,\"68\":1,\"79\":2}}],[\"π∗\",{\"1\":{\"53\":2}}],[\"π\",{\"1\":{\"19\":1,\"20\":1,\"40\":1,\"41\":1,\"44\":1,\"45\":1,\"48\":1,\"53\":1,\"57\":1,\"87\":1,\"111\":1,\"112\":1,\"113\":2,\"135\":1,\"148\":2,\"152\":3,\"155\":1}}],[\"所获得的数据信息的规则\",{\"1\":{\"1267\":1}}],[\"所获得的均值\",{\"1\":{\"48\":1}}],[\"所在类\",{\"1\":{\"944\":1}}],[\"所谓的生产者消费者模型\",{\"1\":{\"331\":1}}],[\"所处的包和对应的目录是一一对应的\",{\"1\":{\"277\":1}}],[\"所生成的数据\",{\"1\":{\"112\":1}}],[\"所求出的\",{\"1\":{\"66\":1}}],[\"所有这个事件的监听器\",{\"1\":{\"1192\":1}}],[\"所有配置的属性\",{\"1\":{\"1149\":1}}],[\"所有对象之间的关系\",{\"1\":{\"1116\":1}}],[\"所有之前用了b的类\",{\"1\":{\"1116\":1}}],[\"所有不会被加载\",{\"1\":{\"1109\":1}}],[\"所有人都可以访问\",{\"1\":{\"1093\":1}}],[\"所有匹配\",{\"1\":{\"1061\":1}}],[\"所有内容写入完成之后\",{\"1\":{\"1058\":1}}],[\"所有常规提示日志信息都以info级别进行打印\",{\"1\":{\"910\":1}}],[\"所有源文件会被解析成语法树\",{\"1\":{\"811\":1}}],[\"所有此表满足第二范式\",{\"1\":{\"737\":1}}],[\"所有可执行文件\",{\"1\":{\"1047\":1}}],[\"所有可以进行权限判断的方法在securityexpressionroot类中有定义\",{\"1\":{\"696\":1}}],[\"所有可能动作的\",{\"1\":{\"48\":1}}],[\"所有包装类如下\",{\"0\":{\"384\":1}}],[\"所有其他类都是继承它的\",{\"1\":{\"372\":1}}],[\"所有代码执行结束时\",{\"1\":{\"300\":1}}],[\"所有被标记为静态的内容\",{\"1\":{\"275\":1}}],[\"所有子文件的file对象\",{\"1\":{\"255\":1}}],[\"所有直接覆盖就行\",{\"1\":{\"216\":1}}],[\"所有的\",{\"1\":{\"1328\":1}}],[\"所有的事务操作实际上是直接调用connection对象\",{\"1\":{\"1273\":1}}],[\"所有的实现类对象\",{\"1\":{\"1116\":1}}],[\"所有的web项目都在这里\",{\"1\":{\"1047\":1}}],[\"所有的日志信息都在这里\",{\"1\":{\"1047\":1}}],[\"所有的父级项目的packing都为pom\",{\"1\":{\"1038\":1}}],[\"所有的命令在执行完成之后都会显示build\",{\"1\":{\"1034\":1}}],[\"所有的版本全部由父项目决定\",{\"1\":{\"1033\":1}}],[\"所有的项目一般都有自己的maven坐标\",{\"1\":{\"1003\":1}}],[\"所有的测试案例都是按照方法的名称顺序来进行的\",{\"1\":{\"987\":1}}],[\"所有的测试结果将合并到一起输出\",{\"1\":{\"972\":1}}],[\"所有的标签必须成对出现\",{\"1\":{\"817\":1}}],[\"所有的操作才会被保存\",{\"1\":{\"806\":1}}],[\"所有的操作都有着对应的servlet来进行处理\",{\"1\":{\"691\":1}}],[\"所有的操作都有分别对应队首和队尾的\",{\"1\":{\"201\":1}}],[\"所有的属性都不传递依赖于主键\",{\"1\":{\"738\":1}}],[\"所有的内置过滤器已经完成\",{\"1\":{\"710\":1}}],[\"所有的controller是由mvc配置类进行注册的\",{\"1\":{\"695\":1}}],[\"所有的静态资源默认情况下也会被拦截\",{\"1\":{\"681\":1}}],[\"所有的post请求都被403了\",{\"1\":{\"660\":1}}],[\"所有的请求全部由它来进行调度\",{\"1\":{\"558\":1}}],[\"所有的运行时异常都继承自\",{\"1\":{\"421\":1}}],[\"所有的集合类最终都是实现自集合根接口的\",{\"1\":{\"180\":1}}],[\"所有状态的集合\",{\"1\":{\"19\":1}}],[\"所得到的\",{\"1\":{\"40\":1}}],[\"所以它并不是一个简单的bean\",{\"1\":{\"1328\":1}}],[\"所以它支持两种方向的遍历操作\",{\"1\":{\"194\":1}}],[\"所以还得要解析一下变成原本的bean名字\",{\"1\":{\"1300\":1}}],[\"所以即使是\",{\"1\":{\"1181\":1}}],[\"所以就出现了循环依赖的问题\",{\"1\":{\"1301\":1}}],[\"所以就只能抛出异常了\",{\"1\":{\"1126\":1}}],[\"所以就会被自动拦截掉了\",{\"1\":{\"692\":1}}],[\"所以无法辨别当前的请求是来自哪个用户发起\",{\"1\":{\"1094\":1}}],[\"所以使用package标签来指定一个包\",{\"1\":{\"894\":1}}],[\"所以依然在使用缓存中的数据\",{\"1\":{\"888\":1}}],[\"所以之前缓存的内容可能就不是当前数据库里面最新的内容了\",{\"1\":{\"883\":1}}],[\"所以默认情况下它们将会以\",{\"1\":{\"843\":1}}],[\"所以需要填入一个占位符\",{\"1\":{\"831\":1}}],[\"所以要获取内部的节点\",{\"1\":{\"819\":1}}],[\"所以jdbc需要进行事务管理时\",{\"1\":{\"806\":1}}],[\"所以前面我们执行一个sql语句就会被直接提交\",{\"1\":{\"806\":1}}],[\"所以视图good\",{\"1\":{\"779\":1}}],[\"所以其不符合bcnf范式\",{\"1\":{\"739\":1}}],[\"所以如果没有始终在线\",{\"1\":{\"727\":1}}],[\"所以出来的是404页面\",{\"1\":{\"692\":1}}],[\"所以访问失败\",{\"1\":{\"572\":1}}],[\"所以对象都是一个\",{\"1\":{\"531\":1}}],[\"所以很多特性都是一种处于实验性功能\",{\"1\":{\"494\":1}}],[\"所以各个版本之间的更新内容比较少了\",{\"1\":{\"494\":1}}],[\"所以在java\",{\"1\":{\"487\":1}}],[\"所以在无人机辅助通信网络中我们需要考虑qoe模型\",{\"1\":{\"10\":1}}],[\"所以明明有机会进行类型推断\",{\"1\":{\"480\":1}}],[\"所以这个选项非常适合测试相关的框架\",{\"1\":{\"1016\":1}}],[\"所以这个8就是存了数组\",{\"1\":{\"182\":1}}],[\"所以这里相当于是优化也算是一种捡漏的方式\",{\"1\":{\"1246\":1}}],[\"所以这里还是填写com\",{\"1\":{\"836\":1}}],[\"所以这里也需要设定一下模板引擎\",{\"1\":{\"560\":1}}],[\"所以这里使用我们前面提到的方法引用的写法\",{\"1\":{\"454\":1}}],[\"所以我们通过mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置\",{\"1\":{\"897\":1}}],[\"所以我们接着来看\",{\"1\":{\"708\":1}}],[\"所以我们项目的代码级别需要调整到16以上\",{\"1\":{\"499\":1,\"501\":1}}],[\"所以我们项目的代码级别需要调整到15以上\",{\"1\":{\"498\":1}}],[\"所以我们项目的代码级别需要调整到14以上\",{\"1\":{\"497\":1}}],[\"所以我们先创建好module\",{\"1\":{\"468\":1}}],[\"所以我们修改一下\",{\"1\":{\"462\":1}}],[\"所以我们来优化一下\",{\"1\":{\"454\":1}}],[\"所以我们还得判空一下\",{\"1\":{\"454\":1}}],[\"所以可以用注解来进行配置\",{\"1\":{\"1165\":1}}],[\"所以可以被变量接收\",{\"1\":{\"497\":1}}],[\"所以可以直接写最终返回的结果\",{\"1\":{\"447\":1}}],[\"所以可能不满足真实需求\",{\"1\":{\"393\":1}}],[\"所以只需要构造一个\",{\"1\":{\"524\":1}}],[\"所以只初始化了内部类\",{\"1\":{\"411\":1}}],[\"所以只要\",{\"1\":{\"241\":1}}],[\"所以相对外部来说\",{\"1\":{\"409\":1}}],[\"所以是需要添加default的\",{\"1\":{\"497\":1}}],[\"所以是\",{\"1\":{\"343\":1}}],[\"所以类锁本质上就是对应的类的\",{\"1\":{\"339\":1}}],[\"所以仍然需要等在运行的线程结束才会转为运行态\",{\"1\":{\"318\":1}}],[\"所以自己定义的类要自己重写\",{\"1\":{\"241\":1}}],[\"所以不维护顺序\",{\"1\":{\"214\":1}}],[\"所以添加成功返回true\",{\"1\":{\"180\":1}}],[\"所以说需要单独处理\",{\"1\":{\"1300\":1}}],[\"所以说内部维护的unpooleddatasource对象其实是为了节省代码\",{\"1\":{\"1246\":1}}],[\"所以说只需要这样写就可以了\",{\"1\":{\"1219\":1}}],[\"所以说只能使用\",{\"1\":{\"415\":1}}],[\"所以说并不会在当前线程阻塞\",{\"1\":{\"1188\":1}}],[\"所以说并不能直接判断存储的类型到底是\",{\"1\":{\"437\":1}}],[\"所以说对应的就是student\",{\"1\":{\"1178\":1}}],[\"所以说依然是student的bean\",{\"1\":{\"1158\":1}}],[\"所以说依然是跟之前一样\",{\"1\":{\"172\":1}}],[\"所以说是一个final变量\",{\"1\":{\"1134\":1}}],[\"所以说是可以的\",{\"1\":{\"438\":1}}],[\"所以说断言失败\",{\"1\":{\"973\":1}}],[\"所以说具体类型同样会变成\",{\"1\":{\"438\":1}}],[\"所以说静态方法中是不能用对象定义的泛型的\",{\"1\":{\"438\":1}}],[\"所以说静态内容一定会在第一个对象初始化之前完成加载\",{\"1\":{\"275\":1}}],[\"所以说默认就可以直接使用\",{\"1\":{\"431\":1}}],[\"所以说里面也可以有成员变量\",{\"1\":{\"408\":1}}],[\"所以说int类型的数组时不能被object类型的数组变量接收的\",{\"1\":{\"395\":1}}],[\"所以说可以直接向上转型\",{\"1\":{\"392\":1}}],[\"所以说可以反复使用\",{\"1\":{\"194\":1}}],[\"所以说==判断为假\",{\"1\":{\"384\":1}}],[\"所以说两个不同的对象\",{\"1\":{\"384\":1}}],[\"所以说照着写就行了\",{\"1\":{\"377\":1}}],[\"所以说有些人说接口其实就是java中的多继承\",{\"1\":{\"376\":1}}],[\"所以说不能为私有\",{\"1\":{\"375\":1}}],[\"所以说判断结果为真\",{\"1\":{\"373\":1}}],[\"所以说呢\",{\"1\":{\"365\":1}}],[\"所以说就这样设计了\",{\"1\":{\"318\":1}}],[\"所以说没有包这个概念\",{\"1\":{\"277\":1}}],[\"所以说没必要直接用实现类\",{\"1\":{\"182\":1}}],[\"所以说我们如果直接获取bean的类型\",{\"1\":{\"1222\":1}}],[\"所以说我们还得指定对应的类才可以\",{\"1\":{\"1125\":1}}],[\"所以说我们就使用\",{\"1\":{\"1119\":1}}],[\"所以说我们需要明确指定\",{\"1\":{\"277\":1}}],[\"所以说我们在静态方法中\",{\"1\":{\"274\":1}}],[\"所以说我们可以添加两个一模一样的\",{\"1\":{\"182\":1}}],[\"所以说这里我们之间填写之前建好的实体类名称\",{\"1\":{\"831\":1}}],[\"所以说这里就明确了类型\",{\"1\":{\"171\":1}}],[\"所以说这种解决办法虽然可行\",{\"1\":{\"437\":1}}],[\"所以说这个对象当做每一个键值对的共享\",{\"1\":{\"224\":2}}],[\"所以说直接采用红黑树会更好\",{\"1\":{\"219\":1}}],[\"所以说直接就使用了\",{\"1\":{\"164\":1}}],[\"所以说返回null\",{\"1\":{\"214\":1}}],[\"所以说返回正数表示大于\",{\"1\":{\"171\":1}}],[\"所以说值是学生对象类型的\",{\"1\":{\"213\":1}}],[\"所以说最重要的还是\",{\"1\":{\"207\":1}}],[\"所以说无法维持插入元素的顺序\",{\"1\":{\"205\":1}}],[\"所以说\",{\"1\":{\"190\":1,\"224\":1,\"274\":1,\"415\":1}}],[\"所以说一定要注意\",{\"1\":{\"182\":1}}],[\"所以说哪怕是我们不去指定类型也可以直接使用\",{\"1\":{\"173\":1}}],[\"所以说使用void\",{\"1\":{\"162\":1}}],[\"所以\",{\"1\":{\"48\":1,\"313\":1,\"392\":1,\"446\":1,\"448\":1,\"449\":1,\"451\":1,\"453\":1,\"503\":1,\"560\":1,\"626\":1,\"739\":1,\"1119\":1,\"1134\":1,\"1318\":1,\"1320\":1}}],[\"所以状态其实共有\",{\"1\":{\"13\":1}}],[\"eclipse\",{\"1\":{\"1181\":1}}],[\"etter\",{\"1\":{\"1175\":1}}],[\"edge\",{\"1\":{\"1096\":1}}],[\"edg\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"edit\",{\"1\":{\"691\":2}}],[\"editor\",{\"1\":{\"643\":2}}],[\"ehcache\",{\"1\":{\"888\":1}}],[\"employeeid\",{\"1\":{\"748\":1}}],[\"employees\",{\"1\":{\"748\":1}}],[\"emptysource两个注解的功能\",{\"1\":{\"992\":1}}],[\"emptysource\",{\"1\":{\"992\":1}}],[\"emptylist\",{\"1\":{\"236\":1,\"550\":1}}],[\"empty\",{\"1\":{\"182\":1,\"324\":1}}],[\"email\",{\"1\":{\"682\":1,\"747\":2}}],[\"ee的一个标准\",{\"1\":{\"1053\":1}}],[\"ee\",{\"1\":{\"545\":3}}],[\"errargs\",{\"1\":{\"1059\":3}}],[\"errmsg\",{\"1\":{\"1059\":4}}],[\"err打印到控制台\",{\"1\":{\"918\":1}}],[\"errorcontext\",{\"1\":{\"1242\":1}}],[\"errorcontroller\",{\"1\":{\"605\":1}}],[\"error\",{\"1\":{\"605\":1,\"625\":1,\"711\":2,\"841\":2,\"1181\":3,\"1242\":1,\"1246\":2,\"1260\":1}}],[\"error错误比异常更严重\",{\"1\":{\"421\":1}}],[\"err\",{\"1\":{\"531\":1}}],[\"either\",{\"1\":{\"509\":1,\"1047\":1}}],[\"ekko\",{\"1\":{\"461\":1,\"549\":1,\"1225\":1}}],[\"euqals\",{\"1\":{\"372\":1}}],[\"euqation\",{\"1\":{\"47\":1}}],[\"earlysingletonobjects\",{\"1\":{\"1301\":4}}],[\"eagerly\",{\"1\":{\"1300\":1}}],[\"eat\",{\"1\":{\"331\":1}}],[\"each\",{\"1\":{\"180\":4,\"781\":2,\"1181\":1}}],[\"e+1\",{\"1\":{\"228\":1}}],[\"e+γvπ​\",{\"1\":{\"113\":1}}],[\"end\",{\"1\":{\"1318\":1,\"1319\":1,\"1320\":2}}],[\"endswith\",{\"1\":{\"1104\":4}}],[\"encountered\",{\"1\":{\"1181\":1}}],[\"encodings\",{\"1\":{\"1199\":1}}],[\"encoding\",{\"1\":{\"727\":1,\"939\":2,\"1047\":1,\"1091\":1,\"1096\":1,\"1199\":2}}],[\"encoding=\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"817\":2,\"824\":1,\"826\":1,\"1002\":1,\"1017\":1,\"1023\":1,\"1032\":1,\"1071\":1,\"1119\":1,\"1124\":1,\"1167\":1,\"1217\":1,\"1242\":1,\"1255\":1}}],[\"encode\",{\"1\":{\"659\":3,\"664\":1,\"666\":1}}],[\"encoder\",{\"1\":{\"659\":4,\"664\":2,\"666\":5}}],[\"enctype=\",{\"1\":{\"619\":1,\"1075\":1}}],[\"enabletransactionmanagement\",{\"1\":{\"1276\":1}}],[\"enabletransactionmanagement注解即可\",{\"1\":{\"1274\":1}}],[\"enableaspectjautoproxy吗\",{\"1\":{\"1310\":1}}],[\"enableaspectjautoproxy\",{\"1\":{\"1232\":1,\"1310\":6}}],[\"enableaspectjautoproxy注解之后\",{\"1\":{\"1310\":1}}],[\"enableaspectjautoproxy注解\",{\"1\":{\"1232\":1}}],[\"enableasync\",{\"1\":{\"1188\":1}}],[\"enableasync注解\",{\"1\":{\"1188\":1}}],[\"enablescheduling\",{\"1\":{\"1190\":1}}],[\"enablescheduling注解\",{\"1\":{\"1190\":1}}],[\"enablehttpsessioneventpublisher\",{\"1\":{\"705\":1}}],[\"enablemethodsecurity\",{\"1\":{\"695\":1}}],[\"enabledif或\",{\"1\":{\"980\":2}}],[\"enabledif\",{\"1\":{\"980\":2}}],[\"enabledifenvironmentvariable\",{\"1\":{\"979\":1}}],[\"enabledifsystemproperty\",{\"1\":{\"979\":1}}],[\"enabledifsystemproperty来对系统属性进行判断\",{\"1\":{\"979\":1}}],[\"enabledforjrerange\",{\"1\":{\"978\":1}}],[\"enabledonjre\",{\"1\":{\"977\":2}}],[\"enabledonjre来进行指定\",{\"1\":{\"977\":1}}],[\"enabledonos\",{\"1\":{\"976\":2}}],[\"enabledonos来指定\",{\"1\":{\"976\":1}}],[\"enabled\",{\"1\":{\"662\":1}}],[\"enablewebsecurity\",{\"1\":{\"651\":1,\"658\":1,\"659\":1,\"664\":1,\"666\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"695\":1}}],[\"enablewebmvc\",{\"1\":{\"553\":3,\"560\":1,\"671\":1}}],[\"enable\",{\"1\":{\"564\":1,\"678\":1}}],[\"en\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"727\":1,\"824\":1,\"826\":1,\"1017\":1,\"1071\":1,\"1091\":3,\"1096\":3,\"1242\":1,\"1255\":1}}],[\"engines\",{\"1\":{\"782\":1}}],[\"engine\",{\"1\":{\"560\":3}}],[\"english\",{\"1\":{\"222\":3}}],[\"enumeration\",{\"1\":{\"1057\":3}}],[\"enumeration<string>\",{\"1\":{\"1057\":1}}],[\"enumsource\",{\"1\":{\"993\":3}}],[\"enum<com\",{\"1\":{\"378\":1}}],[\"enum表示这是一个枚举类\",{\"1\":{\"378\":1}}],[\"enum\",{\"1\":{\"378\":2,\"993\":1}}],[\"enterprise\",{\"1\":{\"1048\":1}}],[\"entity\",{\"1\":{\"277\":5,\"278\":1,\"411\":3,\"412\":2,\"826\":1,\"832\":1,\"843\":1,\"849\":1,\"851\":3,\"853\":2,\"854\":2,\"855\":3,\"861\":1,\"862\":1,\"897\":1,\"904\":1,\"1017\":1,\"1133\":6,\"1134\":3,\"1160\":1,\"1218\":2,\"1219\":1,\"1220\":1,\"1223\":1,\"1224\":1,\"1225\":1,\"1231\":3,\"1232\":1,\"1233\":1,\"1234\":1,\"1235\":1,\"1236\":1,\"1254\":1,\"1257\":1,\"1259\":1}}],[\"entry\",{\"1\":{\"218\":1}}],[\"entryset\",{\"1\":{\"213\":1}}],[\"entry<k\",{\"1\":{\"213\":2,\"215\":1,\"218\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"182\":1}}],[\"environmentcapable\",{\"1\":{\"1316\":1}}],[\"environments>\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"environment>\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"environment\",{\"1\":{\"19\":2,\"904\":4,\"1242\":4,\"1318\":5}}],[\"eliminate\",{\"1\":{\"324\":1}}],[\"else\",{\"1\":{\"182\":3,\"216\":3,\"217\":3,\"264\":1,\"423\":1,\"617\":2,\"626\":1,\"636\":4,\"708\":2,\"710\":1,\"711\":1,\"789\":2,\"1059\":11,\"1072\":2,\"1104\":1,\"1224\":1,\"1246\":5,\"1247\":3,\"1300\":3,\"1321\":1,\"1327\":1}}],[\"elementtype是一个枚举类型\",{\"1\":{\"363\":1}}],[\"elementtype\",{\"1\":{\"363\":2,\"364\":8,\"365\":3,\"1167\":2,\"1279\":2,\"1310\":1,\"1326\":1}}],[\"elementdata\",{\"1\":{\"182\":9,\"190\":1}}],[\"element\",{\"1\":{\"181\":2,\"182\":2,\"200\":1,\"518\":2,\"819\":1}}],[\"elementwise\",{\"1\":{\"49\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"equal\",{\"1\":{\"181\":1}}],[\"equalsandhashcode全部注解\",{\"1\":{\"812\":1}}],[\"equalsandhashcode来快速生成比较和哈希值方法\",{\"1\":{\"812\":1}}],[\"equals\",{\"1\":{\"180\":1,\"182\":1,\"204\":1,\"213\":1,\"216\":2,\"241\":16,\"372\":1,\"373\":4,\"401\":1,\"476\":1,\"499\":4,\"501\":3,\"617\":4,\"636\":2,\"699\":2,\"1059\":8,\"1093\":2,\"1224\":2,\"1247\":2}}],[\"equation\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"45\":1,\"46\":2,\"49\":2,\"52\":1,\"58\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"e>\",{\"1\":{\"180\":2,\"181\":2,\"189\":1,\"204\":1}}],[\"ep074512\",{\"1\":{\"172\":3,\"437\":1,\"438\":2}}],[\"eplison\",{\"0\":{\"85\":1}}],[\"episodestartingfrom\",{\"1\":{\"81\":4}}],[\"episodes\",{\"1\":{\"78\":1,\"82\":2,\"84\":2}}],[\"episode\",{\"0\":{\"81\":1},\"1\":{\"19\":2,\"78\":2,\"81\":6,\"82\":1,\"84\":1,\"86\":1,\"137\":1}}],[\"efficient\",{\"1\":{\"81\":1}}],[\"event\",{\"1\":{\"1191\":2,\"1192\":1}}],[\"eventpublisher\",{\"1\":{\"712\":2}}],[\"even\",{\"1\":{\"1181\":1}}],[\"every\",{\"1\":{\"81\":2}}],[\"eviction=\",{\"1\":{\"884\":1}}],[\"evict\",{\"1\":{\"216\":2}}],[\"evaluation\",{\"1\":{\"23\":2,\"45\":1,\"47\":1,\"66\":1,\"70\":1,\"79\":1,\"82\":1}}],[\"es\",{\"1\":{\"403\":1}}],[\"estimation\",{\"0\":{\"99\":1,\"103\":1,\"132\":1},\"1\":{\"75\":2,\"77\":1,\"82\":1,\"92\":1}}],[\"es∼η\",{\"1\":{\"26\":1}}],[\"e\",{\"1\":{\"43\":2,\"44\":4,\"48\":2,\"75\":1,\"94\":1,\"98\":2,\"99\":3,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"180\":2,\"181\":8,\"182\":5,\"189\":1,\"190\":3,\"194\":6,\"200\":8,\"201\":19,\"204\":2,\"216\":11,\"228\":4,\"247\":6,\"248\":6,\"249\":4,\"250\":2,\"251\":2,\"253\":4,\"254\":2,\"255\":2,\"262\":2,\"265\":4,\"267\":2,\"269\":6,\"270\":2,\"283\":4,\"284\":2,\"286\":4,\"288\":2,\"290\":2,\"301\":2,\"305\":2,\"313\":4,\"318\":2,\"319\":2,\"322\":4,\"329\":4,\"331\":4,\"343\":2,\"356\":4,\"403\":2,\"424\":8,\"531\":1,\"605\":5,\"620\":2,\"719\":6,\"720\":4,\"726\":4,\"727\":4,\"788\":2,\"796\":2,\"798\":3,\"799\":2,\"804\":2,\"805\":2,\"806\":8,\"819\":2,\"830\":2,\"1047\":1,\"1072\":2,\"1225\":4}}],[\"exectype\",{\"1\":{\"1242\":2}}],[\"execution写法跟之前一样\",{\"1\":{\"1233\":1}}],[\"execution填写格式如下\",{\"1\":{\"1219\":1}}],[\"execution\",{\"1\":{\"1219\":3,\"1220\":1,\"1223\":1,\"1224\":1,\"1225\":1,\"1231\":1,\"1233\":1,\"1234\":1,\"1235\":1,\"1236\":1,\"1237\":1}}],[\"executions>\",{\"1\":{\"1037\":1}}],[\"execution>\",{\"1\":{\"1037\":1}}],[\"executing\",{\"1\":{\"296\":1,\"324\":1}}],[\"executortype\",{\"1\":{\"871\":1,\"1242\":1}}],[\"executorexception\",{\"1\":{\"841\":1}}],[\"executor\",{\"1\":{\"841\":1,\"1242\":3}}],[\"executebatch\",{\"1\":{\"798\":1}}],[\"executeupdate\",{\"1\":{\"796\":3,\"806\":11,\"871\":1}}],[\"executequery\",{\"1\":{\"788\":1,\"804\":1,\"805\":1}}],[\"extclassloader\",{\"1\":{\"1109\":1}}],[\"extension\",{\"1\":{\"616\":1}}],[\"extendwith是由junit提供的注解\",{\"1\":{\"1291\":1}}],[\"extendwith\",{\"1\":{\"1291\":1}}],[\"extends关键字\",{\"1\":{\"503\":1}}],[\"extends\",{\"1\":{\"172\":3,\"173\":1,\"180\":2,\"181\":2,\"182\":2,\"194\":1,\"199\":1,\"200\":1,\"201\":1,\"204\":2,\"213\":2,\"215\":1,\"218\":1,\"224\":1,\"343\":1,\"348\":1,\"349\":1,\"356\":1,\"375\":1,\"376\":2,\"377\":1,\"378\":1,\"422\":2,\"439\":1,\"504\":4,\"552\":1,\"619\":1,\"650\":1,\"665\":1,\"836\":1,\"937\":1,\"944\":1,\"1059\":1,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1104\":2,\"1126\":2,\"1192\":1,\"1242\":1,\"1279\":2,\"1296\":1,\"1316\":1}}],[\"extend\",{\"1\":{\"172\":1}}],[\"externalcondition\",{\"1\":{\"980\":2}}],[\"extern\",{\"1\":{\"468\":1,\"1032\":1}}],[\"exclusion>\",{\"1\":{\"1026\":1}}],[\"exclusions>\",{\"1\":{\"1026\":1}}],[\"exclusions\",{\"1\":{\"1015\":1}}],[\"excludepathpatterns\",{\"1\":{\"596\":1,\"600\":1}}],[\"exchange\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"excels\",{\"1\":{\"1181\":1}}],[\"excellent\",{\"1\":{\"10\":1}}],[\"exceptionfactory\",{\"1\":{\"843\":2,\"1242\":1}}],[\"exceptions\",{\"1\":{\"841\":1,\"843\":1}}],[\"exceptionutil\",{\"1\":{\"841\":1,\"1247\":1}}],[\"exceptiontranslationfilter\",{\"1\":{\"714\":1}}],[\"exceptionhandler\",{\"1\":{\"604\":2,\"605\":1}}],[\"exceptionhandler注解\",{\"1\":{\"602\":1}}],[\"exception\",{\"1\":{\"356\":2,\"421\":4,\"422\":3,\"423\":3,\"509\":2,\"595\":4,\"600\":5,\"603\":1,\"604\":2,\"605\":2,\"626\":5,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"727\":2,\"789\":1,\"819\":1,\"841\":1,\"1119\":1,\"1160\":1,\"1181\":1,\"1242\":1,\"1278\":1,\"1283\":1,\"1327\":1,\"1328\":2}}],[\"ex\",{\"1\":{\"595\":1,\"600\":1,\"789\":2,\"1320\":3}}],[\"exit退出即可\",{\"1\":{\"473\":1}}],[\"existing\",{\"1\":{\"1283\":1}}],[\"exist\",{\"1\":{\"841\":1}}],[\"exists\",{\"1\":{\"255\":1,\"749\":1}}],[\"existence\",{\"1\":{\"58\":1}}],[\"examine\",{\"1\":{\"1047\":1}}],[\"examples\",{\"1\":{\"1047\":1}}],[\"example<\",{\"1\":{\"1032\":1}}],[\"example\",{\"1\":{\"553\":1,\"560\":1,\"671\":3,\"980\":1,\"1003\":1,\"1047\":1,\"1054\":1,\"1071\":1,\"1218\":2,\"1219\":1,\"1220\":1,\"1223\":1,\"1224\":1,\"1231\":3,\"1232\":1,\"1233\":1,\"1234\":1,\"1235\":1,\"1236\":1,\"1254\":1,\"1255\":1,\"1257\":2,\"1259\":2,\"1276\":2,\"1278\":1}}],[\"exam\",{\"1\":{\"373\":2,\"375\":2}}],[\"exp\",{\"1\":{\"1202\":4,\"1203\":9,\"1204\":6,\"1205\":3,\"1207\":4,\"1208\":5,\"1209\":4,\"1210\":2,\"1211\":4}}],[\"expressed\",{\"1\":{\"1181\":2}}],[\"expression=\",{\"1\":{\"1219\":2,\"1220\":1,\"1223\":1,\"1224\":1,\"1225\":1,\"1231\":1}}],[\"expressions\",{\"1\":{\"1211\":1}}],[\"expressionparser\",{\"1\":{\"1202\":1,\"1203\":1}}],[\"expression\",{\"1\":{\"403\":1,\"1202\":2,\"1203\":5,\"1204\":3,\"1205\":2,\"1207\":2,\"1208\":3,\"1209\":2,\"1210\":1,\"1211\":2}}],[\"exposeproxy\",{\"1\":{\"1310\":2}}],[\"exposedobject\",{\"1\":{\"1301\":4}}],[\"exports\",{\"1\":{\"464\":2,\"465\":2,\"466\":2,\"467\":1}}],[\"exponentially\",{\"1\":{\"58\":1}}],[\"exploded\",{\"1\":{\"1091\":2,\"1096\":3}}],[\"exploration\",{\"1\":{\"87\":1}}],[\"exploring\",{\"0\":{\"80\":1,\"83\":1,\"84\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1,\"88\":1}}],[\"exploitation\",{\"1\":{\"87\":1}}],[\"expensive\",{\"1\":{\"1148\":1}}],[\"expectedconnectiontypecode\",{\"1\":{\"1245\":1,\"1247\":1}}],[\"expected\",{\"0\":{\"118\":1},\"1\":{\"40\":1,\"969\":1,\"1119\":1}}],[\"expection\",{\"1\":{\"40\":1,\"113\":1,\"133\":1,\"136\":1}}],[\"experience\",{\"0\":{\"10\":1},\"1\":{\"4\":1,\"80\":1,\"112\":1,\"116\":1}}],[\"训练阶段\",{\"1\":{\"14\":1}}],[\"与beanpostprocessor差不多的还有beanfactorypostprocessor\",{\"1\":{\"1311\":1}}],[\"与连接点主体\",{\"1\":{\"1219\":1}}],[\"与旧版教程不同的是\",{\"1\":{\"1118\":1}}],[\"与其相似的还有两个相同对象的判断\",{\"1\":{\"971\":1}}],[\"与其说lambda是匿名内部类的语法糖\",{\"1\":{\"446\":1}}],[\"与主键类似\",{\"1\":{\"747\":1}}],[\"与具有相同功能的还有\",{\"1\":{\"698\":1}}],[\"与mvc一样\",{\"1\":{\"650\":1}}],[\"与javascript的对象极为相似\",{\"1\":{\"610\":1}}],[\"与单个拦截器的情况一样\",{\"1\":{\"600\":1}}],[\"与上面一致\",{\"1\":{\"552\":1}}],[\"与加载的类唯一对应\",{\"1\":{\"337\":1}}],[\"与迭代器作用相同\",{\"1\":{\"180\":1}}],[\"与策略\",{\"1\":{\"152\":2}}],[\"与\",{\"0\":{\"41\":1,\"70\":1,\"114\":1},\"1\":{\"41\":1,\"68\":1,\"79\":1,\"124\":1,\"699\":1}}],[\"与基于q\",{\"1\":{\"14\":1}}],[\"与k\",{\"1\":{\"5\":1}}],[\"基于spring的开发将不会再出现mybatis的配置文件\",{\"1\":{\"1259\":1}}],[\"基于项目对象模型\",{\"1\":{\"1000\":1}}],[\"基于垃圾回收器状态和软引用规则移除对象\",{\"1\":{\"884\":1}}],[\"基于权限和基于角色其实差别并不大\",{\"1\":{\"693\":1}}],[\"基于权限授权\",{\"0\":{\"693\":1}}],[\"基于权限的授权与角色类似\",{\"1\":{\"693\":1}}],[\"基于权限的授权\",{\"1\":{\"691\":1}}],[\"基于角色授权\",{\"0\":{\"692\":1}}],[\"基于角色的授权\",{\"1\":{\"691\":1}}],[\"基于数据库验证\",{\"0\":{\"661\":1}}],[\"基于内存验证\",{\"0\":{\"657\":1}}],[\"基于函数表示的策略\",{\"1\":{\"148\":1}}],[\"基于函数的\",{\"1\":{\"130\":1}}],[\"基于策略\",{\"1\":{\"135\":1}}],[\"基于给定策略下\",{\"1\":{\"134\":1}}],[\"基于表格的\",{\"1\":{\"130\":1}}],[\"基于q\",{\"1\":{\"14\":1}}],[\"基本结构是由select子句\",{\"1\":{\"744\":1}}],[\"基本流程实际上跟之前是一样的\",{\"1\":{\"668\":1}}],[\"基本的spring配置类\",{\"1\":{\"552\":1}}],[\"基本上不会用到\",{\"1\":{\"410\":1}}],[\"基本类型是不支持的\",{\"1\":{\"438\":1}}],[\"基本类型\",{\"1\":{\"400\":1}}],[\"基本类型包装类\",{\"0\":{\"383\":1}}],[\"基本类型的比较跟之前一样\",{\"1\":{\"373\":1}}],[\"基本数据类型也有对应的class对象\",{\"1\":{\"340\":1}}],[\"基本数据类型的\",{\"0\":{\"340\":1}}],[\"基本示例\",{\"1\":{\"214\":1}}],[\"基本定义是\",{\"1\":{\"410\":1}}],[\"基本定义\",{\"0\":{\"213\":1}}],[\"基本思路\",{\"0\":{\"148\":1}}],[\"基本形式\",{\"0\":{\"55\":1}}],[\"基本概念\",{\"0\":{\"17\":1,\"19\":1}}],[\"基本设置\",{\"0\":{\"8\":1}}],[\"后置处理器与aop\",{\"0\":{\"1304\":1,\"1305\":1}}],[\"后端处理\",{\"0\":{\"611\":1}}],[\"后处于等待的线程\",{\"1\":{\"318\":1}}],[\"后面跟\",{\"1\":{\"1076\":1}}],[\"后面会一一讲解\",{\"1\":{\"1057\":1}}],[\"后面会专门讲解\",{\"1\":{\"658\":1}}],[\"后面我们会讲解如何通过配置关闭csrf防护\",{\"1\":{\"660\":1}}],[\"后面加上花括号\",{\"1\":{\"412\":1}}],[\"后面在juc中我们还会讲到乐观锁\",{\"1\":{\"312\":1}}],[\"后面的就是实际结果\",{\"1\":{\"969\":1}}],[\"后面的表达式判断结果为\",{\"1\":{\"425\":1}}],[\"后面的\",{\"1\":{\"277\":1}}],[\"后面的元素就被挤到后面去了\",{\"1\":{\"181\":1}}],[\"后保存的读取内容是取readlimit和bufferedinputstream类的缓冲区大小两者中的最大值\",{\"1\":{\"265\":1}}],[\"后续应该有解决方案\",{\"1\":{\"1119\":1}}],[\"后续不需要\",{\"1\":{\"687\":1}}],[\"后续无需创建\",{\"1\":{\"664\":1}}],[\"后续参数作为目标对象成员方法的参数\",{\"1\":{\"451\":1}}],[\"后续参数作为目标对象成员方法的参数来尝试调用\",{\"1\":{\"451\":1}}],[\"后续会根据情况扩容\",{\"1\":{\"216\":1}}],[\"后续可能是未知的\",{\"1\":{\"45\":1}}],[\"后\",{\"1\":{\"48\":1,\"82\":2,\"343\":1}}],[\"后四个方向\",{\"1\":{\"14\":1}}],[\"后退\",{\"1\":{\"13\":1}}],[\"前期准备工作\",{\"1\":{\"626\":1}}],[\"前端登录设置\",{\"0\":{\"682\":1}}],[\"前端开发者利用js发起异步请求\",{\"1\":{\"617\":1}}],[\"前端异步请求指的是在前端中发送请求至服务器或其他资源\",{\"1\":{\"617\":1}}],[\"前端为什么需要用到异步请求\",{\"1\":{\"617\":1}}],[\"前后端数据交互\",{\"0\":{\"563\":1}}],[\"前缀表示转发给其他请求映射\",{\"1\":{\"587\":1}}],[\"前缀\",{\"1\":{\"560\":1,\"587\":1,\"698\":1}}],[\"前面的是预期结果\",{\"1\":{\"969\":1}}],[\"前面我们详细介绍了beanfactory是如何工作的\",{\"1\":{\"1315\":1}}],[\"前面我们讲解了配置的bean是如何被读取并加载到容器中的\",{\"1\":{\"1299\":1}}],[\"前面我们讲解了如何向浏览器发送一个json格式的数据\",{\"1\":{\"617\":1}}],[\"前面我们说了\",{\"1\":{\"1222\":1}}],[\"前面我们学习了lombok\",{\"1\":{\"949\":1}}],[\"前面我们介绍了datasource数据源\",{\"1\":{\"1243\":1}}],[\"前面我们介绍了使用\",{\"1\":{\"1177\":1}}],[\"前面我们介绍了查询操作\",{\"1\":{\"860\":1}}],[\"前面我们介绍了两种攻击方式\",{\"1\":{\"643\":1}}],[\"前面我们已经完成了大部分的配置文件学习\",{\"1\":{\"1165\":1}}],[\"前面我们已经实现了直接认证的方式\",{\"1\":{\"661\":1}}],[\"前面我们已经了解了如何创建一个控制器来处理我们的请求\",{\"1\":{\"569\":1}}],[\"前面我们已经了解如何使用泛型\",{\"1\":{\"173\":1}}],[\"前面介绍了仅仅只有一个拦截器的情况\",{\"1\":{\"600\":1}}],[\"前面说不推荐使用\",{\"1\":{\"313\":1}}],[\"前\",{\"1\":{\"14\":1}}],[\"前进\",{\"1\":{\"13\":1}}],[\"右连接类似\",{\"1\":{\"769\":1}}],[\"右连接right\",{\"1\":{\"769\":1}}],[\"右\",{\"1\":{\"14\":1}}],[\"右转\",{\"1\":{\"13\":1}}],[\"wrapper\",{\"1\":{\"1242\":1}}],[\"wrapexception\",{\"1\":{\"843\":1,\"1242\":1}}],[\"writing\",{\"1\":{\"995\":1}}],[\"writeobject\",{\"1\":{\"288\":1,\"290\":1}}],[\"writeboolean\",{\"1\":{\"286\":1}}],[\"write\",{\"1\":{\"249\":3,\"250\":1,\"251\":1,\"254\":1,\"267\":1,\"270\":1,\"283\":1,\"490\":1,\"720\":3,\"726\":2,\"727\":3,\"1058\":1,\"1059\":1,\"1064\":1,\"1072\":3,\"1075\":1,\"1076\":1}}],[\"writer不会主动加\",{\"1\":{\"720\":1}}],[\"writer除了write方法外\",{\"1\":{\"254\":1}}],[\"writer\",{\"1\":{\"245\":1,\"254\":5,\"283\":2,\"720\":7,\"727\":5}}],[\"weaving\",{\"1\":{\"1226\":1}}],[\"weak\",{\"1\":{\"884\":1}}],[\"were\",{\"1\":{\"1047\":1,\"1260\":1}}],[\"we\",{\"1\":{\"789\":3}}],[\"weblistener\",{\"1\":{\"1105\":1}}],[\"webfilter\",{\"1\":{\"1102\":1,\"1103\":1,\"1104\":1}}],[\"webfilter注解即可\",{\"1\":{\"1102\":1}}],[\"webinitparam\",{\"1\":{\"1085\":1}}],[\"webtest\",{\"1\":{\"1054\":1,\"1091\":2,\"1096\":3}}],[\"webservlet注解详解\",{\"0\":{\"1060\":1}}],[\"webservlet的注解去掉\",{\"1\":{\"1054\":1}}],[\"webservlet\",{\"1\":{\"1054\":1,\"1059\":1,\"1061\":2,\"1062\":1,\"1063\":1,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1085\":1}}],[\"webservlet来进行注册\",{\"1\":{\"1054\":1}}],[\"webp\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"web<\",{\"1\":{\"649\":1}}],[\"webasyncutils\",{\"1\":{\"626\":2}}],[\"webasyncmanagerintegrationfilter\",{\"1\":{\"714\":1}}],[\"webasyncmanager\",{\"1\":{\"626\":2}}],[\"webappclassloader\",{\"1\":{\"1109\":1}}],[\"webappclassloader的加载机制是这样的\",{\"1\":{\"1109\":1}}],[\"webapp\",{\"1\":{\"1047\":1,\"1109\":1}}],[\"webapp目录\",{\"1\":{\"1047\":1}}],[\"webapplicationcontextutils\",{\"1\":{\"625\":1}}],[\"webapplicationcontext\",{\"1\":{\"625\":6,\"706\":2}}],[\"webapplicationinitializer\",{\"1\":{\"550\":3,\"552\":1}}],[\"webappinitializerclasses\",{\"1\":{\"550\":1}}],[\"web容器只负责controller等表现层内容\",{\"1\":{\"625\":1}}],[\"webmvcconfigurer\",{\"1\":{\"553\":1,\"671\":1}}],[\"webmvc<\",{\"1\":{\"544\":1,\"551\":1}}],[\"webconfiguration\",{\"1\":{\"552\":1,\"553\":1,\"560\":1,\"671\":1}}],[\"web\",{\"0\":{\"1048\":1},\"1\":{\"545\":3,\"548\":1,\"705\":1,\"904\":1,\"1017\":1,\"1042\":1,\"1097\":1}}],[\"w3c的xml解析库\",{\"1\":{\"819\":1}}],[\"w3\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"worth\",{\"1\":{\"1181\":1}}],[\"work目录\",{\"1\":{\"1047\":1}}],[\"worker\",{\"1\":{\"375\":2}}],[\"world\",{\"1\":{\"171\":1,\"401\":6,\"445\":1,\"446\":1,\"461\":1,\"468\":1,\"485\":3,\"510\":1,\"511\":2,\"912\":1,\"919\":2,\"939\":1,\"956\":1,\"1042\":1,\"1119\":1,\"1202\":3,\"1203\":3}}],[\"www\",{\"1\":{\"277\":1,\"403\":1,\"490\":1,\"545\":1,\"547\":4,\"549\":7,\"563\":1,\"564\":1,\"617\":1,\"636\":1,\"666\":1,\"852\":2,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":4,\"1167\":4,\"1217\":7,\"1260\":1}}],[\"wt\",{\"1\":{\"1246\":2}}],[\"wt+1​=wt​+αt​n1​i=1∑n​\",{\"1\":{\"142\":1}}],[\"wt​=w\",{\"1\":{\"142\":1}}],[\"wt​\",{\"1\":{\"136\":2,\"137\":2,\"138\":4,\"139\":3,\"140\":3,\"142\":10}}],[\"way\",{\"1\":{\"1181\":2}}],[\"warn\",{\"1\":{\"1327\":1}}],[\"warning\",{\"1\":{\"910\":4,\"911\":1}}],[\"war\",{\"1\":{\"1091\":2,\"1096\":3}}],[\"wargmin​j\",{\"1\":{\"101\":1}}],[\"wac\",{\"1\":{\"625\":11,\"706\":6}}],[\"waiting\",{\"1\":{\"318\":1,\"1246\":1}}],[\"wait需要捕获\",{\"1\":{\"318\":1}}],[\"wait\",{\"1\":{\"318\":6,\"324\":2,\"331\":1,\"372\":3,\"1246\":1}}],[\"was\",{\"1\":{\"264\":1,\"1246\":1,\"1327\":1}}],[\"wang\",{\"1\":{\"222\":3}}],[\"walk\",{\"1\":{\"14\":2,\"789\":1}}],[\"w−e\",{\"1\":{\"99\":1,\"110\":1}}],[\"w∗\",{\"1\":{\"98\":2}}],[\"w∈r\",{\"1\":{\"96\":1}}],[\"w\",{\"1\":{\"96\":3,\"97\":2,\"98\":3,\"99\":5,\"101\":5,\"104\":15,\"110\":4,\"131\":1,\"132\":1,\"133\":2,\"134\":3,\"135\":3,\"136\":6,\"141\":3,\"142\":21,\"403\":1}}],[\"wk−1​\",{\"1\":{\"98\":1}}],[\"wk​−\",{\"1\":{\"110\":1}}],[\"wk​−xk​\",{\"1\":{\"94\":2,\"99\":1}}],[\"wk​\",{\"1\":{\"97\":6,\"98\":1,\"99\":1,\"101\":6,\"104\":12,\"110\":1,\"136\":1}}],[\"wk​+xk​\",{\"1\":{\"94\":1}}],[\"wk​=k−11​i=1∑k−1​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​=wk​+αk​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1}}],[\"wk+1​=wk​−αk​g~​\",{\"1\":{\"110\":1}}],[\"wk+1​=wk​−αk​g​\",{\"1\":{\"99\":1,\"104\":1}}],[\"wk+1​=wk​−αk​e\",{\"1\":{\"104\":1}}],[\"wk+1​=wk​−αk​▽w​j\",{\"1\":{\"136\":1}}],[\"wk+1​=wk​−αk​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​▽w​e\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−ak​g​\",{\"1\":{\"97\":1}}],[\"wk+1​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"wk+1​=k1​i=1∑k​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​​=k1​∑i=1k​xi​​=k1​\",{\"1\":{\"94\":1}}],[\"wk+1​可以由wk​推导出来\",{\"1\":{\"94\":1}}],[\"which\",{\"1\":{\"789\":1,\"1148\":1,\"1181\":1}}],[\"while\",{\"1\":{\"180\":1,\"181\":1,\"187\":1,\"189\":1,\"191\":1,\"248\":1,\"251\":1,\"264\":1,\"301\":1,\"322\":1,\"324\":1,\"329\":2,\"331\":3,\"490\":1,\"711\":1,\"719\":1,\"726\":2,\"727\":3,\"788\":1,\"797\":1,\"799\":2,\"804\":1,\"805\":1,\"888\":1,\"1057\":1,\"1181\":1,\"1246\":1}}],[\"what\",{\"1\":{\"348\":1,\"349\":1}}],[\"whatsoever\",{\"1\":{\"296\":1}}],[\"why\",{\"0\":{\"47\":1}}],[\"whether\",{\"1\":{\"1181\":1}}],[\"where等操作\",{\"1\":{\"902\":1}}],[\"where子句组成的查询块\",{\"1\":{\"744\":1}}],[\"where\",{\"1\":{\"46\":1,\"58\":1,\"670\":1,\"755\":1,\"756\":1,\"762\":1,\"764\":1,\"765\":1,\"766\":2,\"767\":2,\"770\":2,\"779\":1,\"781\":1,\"796\":2,\"804\":2,\"805\":2,\"831\":2,\"833\":1,\"834\":1,\"835\":1,\"836\":1,\"841\":1,\"842\":2,\"843\":2,\"850\":1,\"851\":2,\"852\":2,\"853\":1,\"854\":2,\"855\":1,\"863\":1,\"864\":1,\"873\":1,\"874\":1,\"876\":2,\"886\":1,\"887\":1,\"901\":2,\"902\":4,\"903\":1,\"1071\":1,\"1255\":1}}],[\"when>\",{\"1\":{\"874\":2}}],[\"when\",{\"1\":{\"19\":1,\"296\":1,\"324\":1,\"789\":1}}],[\"wiring\",{\"1\":{\"1181\":2}}],[\"wireless\",{\"1\":{\"4\":1}}],[\"win64\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"windows\",{\"1\":{\"976\":1,\"1047\":1,\"1091\":1,\"1096\":1}}],[\"window\",{\"1\":{\"564\":1}}],[\"wish\",{\"1\":{\"1047\":1}}],[\"wide\",{\"1\":{\"1042\":1}}],[\"will\",{\"1\":{\"509\":1,\"1047\":1}}],[\"within\",{\"1\":{\"1219\":2}}],[\"without\",{\"1\":{\"1181\":2}}],[\"withusername\",{\"1\":{\"659\":2,\"664\":1,\"672\":1,\"692\":1}}],[\"withdefaultpasswordencoder\",{\"1\":{\"658\":2}}],[\"with\",{\"0\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"10\":1,\"19\":2,\"98\":1,\"247\":1,\"249\":1,\"324\":1,\"467\":1,\"480\":1,\"774\":1,\"779\":2,\"788\":1,\"789\":1,\"1037\":1,\"1047\":2,\"1148\":1,\"1181\":3,\"1283\":1}}],[\"如com\",{\"1\":{\"1219\":1}}],[\"如cas算法\",{\"1\":{\"312\":1}}],[\"如beans\",{\"1\":{\"1118\":1}}],[\"如tomcat\",{\"1\":{\"1053\":1}}],[\"如文本\",{\"1\":{\"1042\":1}}],[\"如lombok\",{\"1\":{\"1015\":1}}],[\"如配置文件\",{\"1\":{\"1001\":1}}],[\"如supplier这种懒加载的数据\",{\"1\":{\"995\":1}}],[\"如数组\",{\"1\":{\"994\":1}}],[\"如空字符串\",{\"1\":{\"992\":1}}],[\"如此方便的框架\",{\"1\":{\"476\":1}}],[\"如等待io请求\",{\"1\":{\"300\":1}}],[\"如读取和写入文本文件\",{\"1\":{\"245\":1}}],[\"如下\",{\"1\":{\"241\":1}}],[\"如梯度上升算法\",{\"1\":{\"148\":1}}],[\"如\",{\"1\":{\"79\":1,\"82\":1,\"161\":1,\"245\":2,\"604\":1,\"714\":1}}],[\"如何告诉spring需要进行切入\",{\"1\":{\"1217\":1}}],[\"如何使用aop呢\",{\"1\":{\"1217\":1}}],[\"如何才可以实现只有登陆之后才能访问呢\",{\"1\":{\"1093\":1}}],[\"如何才能很好的去存可能出现的两种类型呢\",{\"1\":{\"437\":1}}],[\"如何在重定向之间传递数据呢\",{\"1\":{\"1083\":1}}],[\"如何在其他项目中引入我们自己编写的maven项目作为依赖使用\",{\"1\":{\"1023\":1}}],[\"如何在没有模型\",{\"1\":{\"75\":1}}],[\"如何设计一个优良的关系模型是最关键的内容\",{\"1\":{\"735\":1}}],[\"如何向服务端发送一个js对象数据并进行解析\",{\"1\":{\"617\":1}}],[\"如何获取到请求中的参数\",{\"1\":{\"578\":1}}],[\"如何获取我们编写的注解\",{\"1\":{\"365\":1}}],[\"如何估计\",{\"0\":{\"78\":1}}],[\"如何将mybatis与spring更好的结合\",{\"1\":{\"1252\":1}}],[\"如何将定义好的xml文件读取到java程序中\",{\"1\":{\"819\":1}}],[\"如何将\",{\"1\":{\"76\":1}}],[\"如何确保策略\",{\"1\":{\"68\":1}}],[\"如何通过\",{\"1\":{\"68\":1}}],[\"如何处理等式右边的\",{\"0\":{\"57\":1}}],[\"如何求解\",{\"0\":{\"56\":1}}],[\"如何得到最优策略\",{\"1\":{\"53\":1}}],[\"如可以在target\",{\"1\":{\"19\":1}}],[\"如果括号中的类是importbeandefinitionregistrar的实现类\",{\"1\":{\"1310\":1}}],[\"如果第一层拿不到\",{\"1\":{\"1301\":1}}],[\"如果第一个结点是treenode类型的\",{\"1\":{\"216\":1}}],[\"如果都没问题\",{\"1\":{\"1300\":1}}],[\"如果单独执行test2\",{\"1\":{\"1281\":1}}],[\"如果单纯地使用statement来执行sql命令\",{\"1\":{\"805\":1}}],[\"如果事务a执行过程中事务b插入了新的数据\",{\"1\":{\"1270\":1}}],[\"如果调用的是connection对象的close方法\",{\"1\":{\"1247\":1}}],[\"如果最后得到了连接对象\",{\"1\":{\"1246\":1}}],[\"如果开启事务\",{\"1\":{\"1246\":1}}],[\"如果代理方法存在返回值\",{\"1\":{\"1224\":1}}],[\"如果student对象中的name属性为null\",{\"1\":{\"1211\":1}}],[\"如果scope为system\",{\"1\":{\"1018\":1}}],[\"如果表示导入的类啥就需要\",{\"1\":{\"1205\":1}}],[\"如果配置正确没问题的话\",{\"1\":{\"1199\":1}}],[\"如果嫌上面两个不够灵活\",{\"1\":{\"1190\":1}}],[\"如果嫌一个一个改太麻烦\",{\"1\":{\"818\":1}}],[\"如果bean变成原型模式\",{\"1\":{\"1181\":1}}],[\"如果bean不是单例模式\",{\"1\":{\"1148\":1,\"1300\":1}}],[\"如果其构造方法不是默认无参构造\",{\"1\":{\"1179\":1}}],[\"如果只是简单将一个类作为bean的话\",{\"1\":{\"1177\":1}}],[\"如果现在冒出来各种各样的类都需要这样去用teacher\",{\"1\":{\"1132\":1}}],[\"如果现在我们想单独测试某一个功能的对应方法\",{\"1\":{\"956\":1}}],[\"如果美术老师不教了\",{\"1\":{\"1132\":1}}],[\"如果还失败\",{\"1\":{\"1109\":1}}],[\"如果还是找不到\",{\"1\":{\"625\":1}}],[\"如果定义了同包同名的类\",{\"1\":{\"1109\":1}}],[\"如果用户没有登录就去访问首页\",{\"1\":{\"1096\":1}}],[\"如果用户勾选了记住我\",{\"1\":{\"1093\":1}}],[\"如果登陆失败\",{\"1\":{\"1093\":1}}],[\"如果登陆成功则直接跳转到首页\",{\"1\":{\"1093\":1}}],[\"如果访问我们的首页时携带了这些cookie\",{\"1\":{\"1093\":1}}],[\"如果设置为\",{\"1\":{\"1092\":3}}],[\"如果设置了keeplive为\",{\"1\":{\"721\":1}}],[\"如果为0\",{\"1\":{\"1092\":1}}],[\"如果为负数\",{\"1\":{\"1092\":1}}],[\"如果为正数\",{\"1\":{\"1092\":1}}],[\"如果为二进制数据\",{\"1\":{\"1092\":1}}],[\"如果直接调用是默认提示没有支持该方法的\",{\"1\":{\"1059\":1}}],[\"如果直接使用加的话\",{\"1\":{\"402\":1}}],[\"如果出现乱码\",{\"1\":{\"1047\":1}}],[\"如果出现键相同的情况\",{\"1\":{\"214\":1}}],[\"如果环境变量配置有误\",{\"1\":{\"1047\":1}}],[\"如果别人要用我们的项目作为依赖\",{\"1\":{\"1015\":1}}],[\"如果maven发现本地仓库中就已经存在某个依赖\",{\"1\":{\"1009\":1}}],[\"如果mybatis缓存中存在数据\",{\"1\":{\"882\":1}}],[\"如果依然对测试用例执行前后有其他准备工作需求\",{\"1\":{\"986\":1}}],[\"如果判断流程比较复杂\",{\"1\":{\"972\":1}}],[\"如果判断失败会抛出错误\",{\"1\":{\"425\":1}}],[\"如果测试的结果并不是我们所期望的结果\",{\"1\":{\"963\":1}}],[\"如果将打印等级配置为off\",{\"1\":{\"912\":1}}],[\"如果遇到乱码的情况\",{\"1\":{\"1199\":1}}],[\"如果遇到了多个参数的情况\",{\"1\":{\"902\":1}}],[\"如果遇到诸如401\",{\"1\":{\"660\":1}}],[\"如果对这种复杂查询有着一定需求的话\",{\"1\":{\"901\":1}}],[\"如果对于\",{\"1\":{\"96\":1}}],[\"如果查询的id大于3\",{\"1\":{\"873\":1}}],[\"如果之前的配置文件编写错误\",{\"1\":{\"824\":1}}],[\"如果注解处理器产生了新的源文件\",{\"1\":{\"811\":1}}],[\"如果前面任何操作出现异常\",{\"1\":{\"806\":1}}],[\"如果允许这样的数据插入\",{\"1\":{\"804\":1}}],[\"如果成功就返回对应的\",{\"1\":{\"789\":1}}],[\"如果加载会提示\",{\"1\":{\"788\":1}}],[\"如果更新视图中的数据\",{\"1\":{\"779\":1}}],[\"如果忘记添加where字句来限定条件\",{\"1\":{\"755\":1}}],[\"如果修改管理员id\",{\"1\":{\"739\":1}}],[\"如果修改了a\",{\"1\":{\"413\":1}}],[\"如果连接的双方发生意外而通知不到对方\",{\"1\":{\"721\":1}}],[\"如果接收端读取的是\",{\"1\":{\"720\":1}}],[\"如果服务端是\",{\"1\":{\"720\":1}}],[\"如果一路绿灯\",{\"1\":{\"711\":1}}],[\"如果一个连接被关闭\",{\"1\":{\"1247\":1}}],[\"如果一个会话结束\",{\"1\":{\"883\":1}}],[\"如果一个方法的参数需要的是一个接口的实现\",{\"1\":{\"414\":1}}],[\"如果一个接口中有且只有一个待实现的抽象方法\",{\"1\":{\"414\":1}}],[\"如果一个类的父类是泛型\",{\"1\":{\"343\":1}}],[\"如果一个包中有多个类\",{\"1\":{\"277\":1}}],[\"如果关闭服务器的话\",{\"1\":{\"686\":1}}],[\"如果各位小伙伴后续在编写项目过程中发现有302的情况\",{\"1\":{\"681\":1}}],[\"如果各位不好理解\",{\"1\":{\"446\":1}}],[\"如果提交的是表单类型的数据\",{\"1\":{\"660\":1}}],[\"如果后续各位小伙伴遇到那种需要再form表单中提交的情况\",{\"1\":{\"660\":1}}],[\"如果抛出异常会出现错误页面\",{\"1\":{\"626\":1}}],[\"如果webapplicationcontext是空\",{\"1\":{\"625\":1}}],[\"如果webapplicationcontext在之前已经存在\",{\"1\":{\"625\":1}}],[\"如果处理前返回false\",{\"1\":{\"598\":1}}],[\"如果参数名称与形式参数名称相同\",{\"1\":{\"579\":1}}],[\"如果参数只有一个\",{\"1\":{\"414\":1}}],[\"如果请求头中携带了connection属性\",{\"1\":{\"576\":1}}],[\"如果发现有默认配置优先使用配置里面的\",{\"1\":{\"939\":1}}],[\"如果发现的话\",{\"1\":{\"550\":1}}],[\"如果发现其父类\",{\"1\":{\"361\":1}}],[\"如果你c盘空间不足\",{\"1\":{\"1009\":1}}],[\"如果你认为这还不够灵活\",{\"1\":{\"980\":1}}],[\"如果你还是觉得这种方式配置起来不如之前方便\",{\"1\":{\"899\":1}}],[\"如果你使用过\",{\"1\":{\"872\":1}}],[\"如果你实在需要使用对应的属性名称\",{\"1\":{\"843\":1}}],[\"如果你不需要转换为实体类\",{\"1\":{\"833\":1}}],[\"如果你觉得像这样每次都要写一个完整的类名太累了\",{\"1\":{\"832\":1}}],[\"如果你希望完完全全丢弃配置文件\",{\"1\":{\"550\":1}}],[\"如果你学习过springsecurity\",{\"1\":{\"680\":1}}],[\"如果你学习过sql的话\",{\"1\":{\"228\":1}}],[\"如果你学习过python\",{\"1\":{\"498\":1}}],[\"如果可以成功在浏览器中出现helloworld则说明配置成功\",{\"1\":{\"549\":1}}],[\"如果全部不匹配\",{\"1\":{\"520\":1}}],[\"如果全部匹配\",{\"1\":{\"520\":1}}],[\"如果传递的参数是\",{\"1\":{\"512\":1}}],[\"如果传入null会报错\",{\"1\":{\"477\":1}}],[\"如果传入了错误的参数导致程序无法正常运行\",{\"1\":{\"423\":1}}],[\"如果传入的对象为null\",{\"1\":{\"373\":1}}],[\"如果值为unicode字符\",{\"1\":{\"1092\":1}}],[\"如果值存在\",{\"1\":{\"512\":1}}],[\"如果值存在则ispresent\",{\"1\":{\"512\":1}}],[\"如果值相同\",{\"1\":{\"384\":1}}],[\"如果添加了final关键字\",{\"1\":{\"503\":1}}],[\"如果当前方法并没有在任何事务中进行\",{\"1\":{\"1283\":1}}],[\"如果当前被包装的类不是null\",{\"1\":{\"480\":1}}],[\"如果当前链表的长度已经很长了\",{\"1\":{\"216\":1}}],[\"如果模块module\",{\"1\":{\"464\":1,\"465\":1}}],[\"如果模块没有明确授权给其他模块使用反射的权限\",{\"1\":{\"462\":1}}],[\"如果未在\",{\"1\":{\"461\":1}}],[\"如果已经没有多余的连接可以分配\",{\"1\":{\"1246\":1}}],[\"如果已经有实现好的方法\",{\"1\":{\"448\":1}}],[\"如果已经是主方法了\",{\"1\":{\"424\":1}}],[\"如果使用之前的selectone会导致异常\",{\"1\":{\"836\":1}}],[\"如果使用非静态方法\",{\"1\":{\"451\":1}}],[\"如果使用通配符\",{\"1\":{\"438\":1}}],[\"如果使用该方法\",{\"1\":{\"361\":1}}],[\"如果要得到一个bean的实例很简单\",{\"1\":{\"1299\":1}}],[\"如果要注册为bean\",{\"1\":{\"1254\":1}}],[\"如果要表示字符串\",{\"1\":{\"1205\":1}}],[\"如果要改善这种情况\",{\"1\":{\"1116\":1}}],[\"如果要使用它\",{\"1\":{\"523\":1}}],[\"如果要存放基本数据类型的值\",{\"1\":{\"438\":1}}],[\"如果要让某个变量支持引用确定了任意类型的泛型\",{\"1\":{\"438\":1}}],[\"如果要往里面写入内容\",{\"1\":{\"283\":1}}],[\"如果类型不符合\",{\"1\":{\"438\":1}}],[\"如果大于10就抛出错误\",{\"1\":{\"425\":1}}],[\"如果父类中的方法表明了会抛出某个异常\",{\"1\":{\"423\":1}}],[\"如果父类的方法是\",{\"1\":{\"373\":1}}],[\"如果不作配置\",{\"1\":{\"1038\":1}}],[\"如果不开启会直接覆盖重写\",{\"1\":{\"920\":1}}],[\"如果不满足\",{\"1\":{\"873\":1}}],[\"如果不自动提交\",{\"1\":{\"830\":1}}],[\"如果不需要\",{\"1\":{\"781\":1}}],[\"如果不添加此注解会导致后续无法通过实现webmvcconfigurer接口进行自定义配置\",{\"1\":{\"553\":1}}],[\"如果不加limit\",{\"1\":{\"478\":1}}],[\"如果不加以限制\",{\"1\":{\"228\":1}}],[\"如果不经比较就很容易出现类型转换异常\",{\"1\":{\"437\":1}}],[\"如果不同的分支条件会出现不同的异常\",{\"1\":{\"423\":1}}],[\"如果不进行处理\",{\"1\":{\"421\":1}}],[\"如果不是则匹配失败\",{\"1\":{\"963\":1}}],[\"如果不是登陆请求\",{\"1\":{\"711\":1}}],[\"如果不是\",{\"1\":{\"413\":1}}],[\"如果想用外部变量\",{\"1\":{\"413\":1}}],[\"如果想通过对象的形式去使用他们\",{\"1\":{\"383\":1}}],[\"如果程序中大量进行字符串的拼接似乎不太好\",{\"1\":{\"402\":1}}],[\"如果内容相同\",{\"1\":{\"401\":1}}],[\"如果同时存在其他参数\",{\"1\":{\"398\":1}}],[\"如果在定义依赖关系的时候\",{\"1\":{\"1016\":1}}],[\"如果在最后添加了with\",{\"1\":{\"774\":1}}],[\"如果在插入数据时没有为该列提供值\",{\"1\":{\"747\":1}}],[\"如果在范围内\",{\"1\":{\"384\":1}}],[\"如果在向下找的过程中发现已经存在相同键的键值对了\",{\"1\":{\"216\":1}}],[\"如果方法体中只有一个返回语句\",{\"1\":{\"414\":1}}],[\"如果方法在接口中存在默认实现\",{\"1\":{\"376\":1}}],[\"如果方法内没有变量出现重名的情况\",{\"1\":{\"164\":1}}],[\"如果抽象方法在抽象类定义的是\",{\"1\":{\"375\":1}}],[\"如果子类中某些属性比较特殊\",{\"1\":{\"1150\":1}}],[\"如果子类是一个普通类\",{\"1\":{\"439\":1}}],[\"如果子类都访问不了\",{\"1\":{\"375\":1}}],[\"如果子线程修改了也是可以\",{\"1\":{\"320\":1}}],[\"如果希望调用父类原本的方法实现\",{\"1\":{\"373\":1}}],[\"如果数组里面只有一个内容\",{\"1\":{\"364\":1}}],[\"如果实在是需要使用别人定义为private的方法\",{\"1\":{\"349\":1}}],[\"如果这个bean是被aop代理的\",{\"1\":{\"1301\":1}}],[\"如果这个bean只是一个简简单单的student类型的对象\",{\"1\":{\"1189\":1}}],[\"如果这个位置上什么都没有\",{\"1\":{\"216\":1}}],[\"如果这种情况\",{\"1\":{\"343\":1}}],[\"如果两个应用程序使用了同一个版本的同一个依赖\",{\"1\":{\"1109\":1}}],[\"如果两个表中都带有此属性\",{\"1\":{\"767\":1}}],[\"如果两个线程同时执行\",{\"1\":{\"330\":1}}],[\"如果两个对象通过\",{\"1\":{\"241\":1}}],[\"如果两个对象使用equals方法相等\",{\"1\":{\"182\":1}}],[\"如果有的话\",{\"1\":{\"1300\":1}}],[\"如果有teacher类型的bean\",{\"1\":{\"1179\":1}}],[\"如果有多个的话\",{\"1\":{\"1119\":1}}],[\"如果有一个参数和返回值的话\",{\"1\":{\"414\":1}}],[\"如果有初始值\",{\"1\":{\"374\":1}}],[\"如果有任务依次执行\",{\"1\":{\"324\":1}}],[\"如果有就可以继续获取到下一个元素\",{\"1\":{\"191\":1}}],[\"如果没有\",{\"1\":{\"1246\":1}}],[\"如果没有找到\",{\"1\":{\"1188\":1}}],[\"如果没有找到匹配当前访问路径的servlet\",{\"1\":{\"1062\":1}}],[\"如果没有commit\",{\"1\":{\"884\":1}}],[\"如果没有对应的权限或是对应的角色\",{\"1\":{\"696\":1}}],[\"如果没有配置正确\",{\"1\":{\"589\":1}}],[\"如果没有创建module\",{\"1\":{\"463\":1}}],[\"如果没有其他线程唤醒自己\",{\"1\":{\"318\":1}}],[\"如果没有出现歧义\",{\"1\":{\"277\":1}}],[\"如果resume\",{\"1\":{\"313\":1}}],[\"如果仅仅是读取还好\",{\"1\":{\"311\":1}}],[\"如果存在多台服务器或者是多个程序都在使用mybatis操作同一个数据库\",{\"1\":{\"888\":1}}],[\"如果存在\",{\"1\":{\"301\":1}}],[\"如果存在一个\",{\"1\":{\"84\":1}}],[\"如果我需要的依赖没有上传的远程仓库\",{\"1\":{\"1018\":1}}],[\"如果我和我的朋友同时在银行取我账户里面的钱\",{\"1\":{\"311\":1}}],[\"如果我希望两个任务同时进行\",{\"1\":{\"295\":1}}],[\"如果我们获取的bean已经注册了\",{\"1\":{\"1301\":1}}],[\"如果我们有很多个测试用例\",{\"1\":{\"1288\":1}}],[\"如果我们只是想简单的注入一个常量值\",{\"1\":{\"1200\":1}}],[\"如果我们只是希望某一个bean仅作为一个配置模版供其他bean继承使用\",{\"1\":{\"1151\":1}}],[\"如果我们成功登陆\",{\"1\":{\"1082\":1}}],[\"如果我们需要获取工厂类的实例\",{\"1\":{\"1159\":1}}],[\"如果我们需要使用依赖注入的话\",{\"1\":{\"1137\":1}}],[\"如果我们需要制定哪个老师教我们\",{\"1\":{\"1132\":1}}],[\"如果我们需要维护bean的加载顺序\",{\"1\":{\"1131\":1}}],[\"如果我们需要一个bean并且使用类型进行获取\",{\"1\":{\"1126\":1}}],[\"如果我们需要打包一个可执行文件\",{\"1\":{\"1037\":1}}],[\"如果我们需要读取前端发送给我们的json格式数据\",{\"1\":{\"617\":1}}],[\"如果我们现在需要全面使用日志系统\",{\"1\":{\"949\":1}}],[\"如果我们在不屏蔽父级handler的情况下为子级配置一个handler\",{\"1\":{\"929\":1}}],[\"如果我们在提交事务之前\",{\"1\":{\"865\":1}}],[\"如果我们在方法中抛出了一个非运行时异常\",{\"1\":{\"423\":1}}],[\"如果我们的项目非常庞大\",{\"1\":{\"1165\":1}}],[\"如果我们的旧项目中引入了一些其他的依赖\",{\"1\":{\"1024\":1}}],[\"如果我们的类中存在其他的构造方法覆盖掉默认的无参构造\",{\"1\":{\"841\":1}}],[\"如果我们的服务器要支持响应http请求\",{\"1\":{\"727\":1}}],[\"如果我们创建错误了\",{\"1\":{\"749\":1}}],[\"如果我们希望直接去除mybatis的配置文件\",{\"1\":{\"1258\":1}}],[\"如果我们希望整个上下文中所有的bean都采用某种配置\",{\"1\":{\"1152\":1}}],[\"如果我们希望单例模式下的bean不用再一开始就加载\",{\"1\":{\"1130\":1}}],[\"如果我们希望每次拿到的对象都是一个新的\",{\"1\":{\"1129\":1}}],[\"如果我们希望\",{\"1\":{\"1105\":1}}],[\"如果我们希望记住我能够一直持久化保存\",{\"1\":{\"686\":1}}],[\"如果我们希望读取某个文件的内容\",{\"1\":{\"255\":1}}],[\"如果我们点击此按钮\",{\"1\":{\"641\":1}}],[\"如果我们依然按照之前的方式编写登陆验证\",{\"1\":{\"626\":1}}],[\"如果我们不希望服务端等待太长的时间\",{\"1\":{\"721\":1}}],[\"如果我们不希望某些属性参与到序列化中进行保存\",{\"1\":{\"290\":1}}],[\"如果我们不创建module\",{\"1\":{\"468\":1}}],[\"如果我们要指定在某个jdk版本执行测试案例\",{\"1\":{\"977\":1}}],[\"如果我们要捕获的异常\",{\"1\":{\"424\":1}}],[\"如果我们要使用成员内部类\",{\"1\":{\"408\":1}}],[\"如果我们要使用一个集合类\",{\"1\":{\"182\":1}}],[\"如果我们确实不想在当前这个方法中进行处理\",{\"1\":{\"424\":1}}],[\"如果我们想获取工厂bean为我们提供的bean\",{\"1\":{\"1159\":1}}],[\"如果我们想从事务模式切换为原有的自动提交模式\",{\"1\":{\"806\":1}}],[\"如果我们想修改表结构\",{\"1\":{\"751\":1}}],[\"如果我们想要创建一个新的beanfactory并且默认具有其他beanfactory中所有的bean定义外加一些其他的\",{\"1\":{\"1298\":1}}],[\"如果我们想要指定使用其中的某一个该怎么办呢\",{\"1\":{\"1174\":1}}],[\"如果我们想要快速创建一个map只能\",{\"1\":{\"475\":1}}],[\"如果我们想要表示一个范围内的字符\",{\"1\":{\"403\":1}}],[\"如果我们想直接作为接口抽象方法的实现\",{\"1\":{\"414\":1}}],[\"如果我们我们将其权限改为private\",{\"1\":{\"408\":1}}],[\"如果我们仅仅是想要判断两个字符串的内容是否相同\",{\"1\":{\"401\":1}}],[\"如果我们已经明确了继承的泛型的类型\",{\"1\":{\"343\":1}}],[\"如果我们并不是希望收到中断信号就是结束程序\",{\"1\":{\"301\":1}}],[\"如果我们给类型变量设定了上界\",{\"1\":{\"173\":1}}],[\"如果我们强制让\",{\"1\":{\"124\":1}}],[\"如果某个方法明确指出会抛出哪些异常\",{\"1\":{\"424\":1}}],[\"如果某个类中存在静态方法或是静态变量\",{\"1\":{\"278\":1}}],[\"如果某个元素在当前集合中不存在\",{\"1\":{\"180\":1}}],[\"如果缓冲区中存在此数据\",{\"1\":{\"260\":1}}],[\"如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型\",{\"1\":{\"237\":1}}],[\"如果集合中本身没有元素\",{\"1\":{\"235\":1}}],[\"如果旧的数组不为空\",{\"1\":{\"217\":1}}],[\"如果旧的容量已经大于最大限制了\",{\"1\":{\"217\":1}}],[\"如果旧容量大于0\",{\"1\":{\"217\":1}}],[\"如果超过阈值\",{\"1\":{\"216\":1}}],[\"如果e不为空\",{\"1\":{\"216\":1}}],[\"如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同\",{\"1\":{\"216\":1}}],[\"如果底层哈希表没初始化\",{\"1\":{\"216\":1}}],[\"如果需要自定义\",{\"1\":{\"1272\":1}}],[\"如果需要更加灵活地控制日志级别\",{\"1\":{\"911\":1}}],[\"如果需要让mybatis完全使用构造方法进行对象构建与赋值工作\",{\"1\":{\"841\":1}}],[\"如果需要为service或其他bean也启用权限判断\",{\"1\":{\"695\":1}}],[\"如果需要验证是否与此密码一致\",{\"1\":{\"659\":1}}],[\"如果需要使用aop\",{\"1\":{\"1310\":1}}],[\"如果需要使用这个注解\",{\"1\":{\"1175\":1}}],[\"如果需要使用servlet原本的一些类\",{\"1\":{\"582\":1}}],[\"如果需要使用多个的话\",{\"1\":{\"438\":1}}],[\"如果需要使用更大的数组\",{\"1\":{\"393\":1}}],[\"如果需要指定为外部的对象\",{\"1\":{\"408\":2}}],[\"如果需要完整学习正则表达式\",{\"1\":{\"403\":1}}],[\"如果需要维护顺序\",{\"1\":{\"214\":1}}],[\"如果需要再次进行遍历操作\",{\"1\":{\"191\":1}}],[\"如果插入的数据与列一一对应\",{\"1\":{\"754\":1}}],[\"如果插入的长度小于定义长度时\",{\"1\":{\"746\":1}}],[\"如果插入时该列有明确值\",{\"1\":{\"747\":1}}],[\"如果插入重复元素\",{\"1\":{\"204\":1}}],[\"如果插入失败\",{\"1\":{\"200\":1}}],[\"如果o2比o1大\",{\"1\":{\"171\":1}}],[\"如果是普通bean直接原样返回beaninstance接收到最终结果\",{\"1\":{\"1300\":1}}],[\"如果是普通成员方法\",{\"1\":{\"415\":1}}],[\"如果是通过\",{\"1\":{\"1178\":1}}],[\"如果是第三方包提供的类\",{\"1\":{\"1177\":1}}],[\"如果是参数数量不同\",{\"1\":{\"1135\":1}}],[\"如果是单数则匹配成功\",{\"1\":{\"963\":1}}],[\"如果是自己编写的类型\",{\"1\":{\"831\":1}}],[\"如果是jdk内置的包装类型或是其他类型\",{\"1\":{\"831\":1}}],[\"如果是json数据格式发送的\",{\"1\":{\"660\":1}}],[\"如果是登陆请求\",{\"1\":{\"711\":1}}],[\"如果是更加大型的网站系统\",{\"1\":{\"540\":1}}],[\"如果是集合的话\",{\"1\":{\"516\":1}}],[\"如果是数组的话\",{\"1\":{\"516\":1}}],[\"如果是null的话会引起空指针异常\",{\"1\":{\"480\":1}}],[\"如果是null的话\",{\"1\":{\"454\":1}}],[\"如果是直接使用双引号创建的字符串\",{\"1\":{\"401\":1}}],[\"如果是基本数据类型\",{\"1\":{\"392\":1}}],[\"如果是基本类型的数组\",{\"1\":{\"438\":1}}],[\"如果是基本类型\",{\"1\":{\"161\":1,\"831\":1}}],[\"如果是\",{\"1\":{\"318\":1,\"499\":1,\"528\":1}}],[\"如果是静态方法\",{\"1\":{\"312\":1}}],[\"如果是类路径下需要添加classpath\",{\"1\":{\"560\":1}}],[\"如果是类\",{\"1\":{\"312\":1}}],[\"如果是文件夹\",{\"1\":{\"255\":1}}],[\"如果是其他类型的文件不适用\",{\"1\":{\"253\":1}}],[\"如果是多个单词\",{\"1\":{\"162\":1}}],[\"如果是引用类型\",{\"1\":{\"161\":1,\"392\":1}}],[\"如果是boolean的话\",{\"1\":{\"161\":1}}],[\"如果\",{\"1\":{\"96\":1,\"425\":1,\"560\":1}}],[\"如果ϵ=1\",{\"1\":{\"87\":1}}],[\"如果经过了\",{\"1\":{\"84\":1}}],[\"如果从其他状态出发\",{\"1\":{\"84\":1}}],[\"如果该容器找到了对应的需要的实例就会采用该服务然后返回\",{\"1\":{\"1058\":1}}],[\"如果该\",{\"1\":{\"81\":1}}],[\"如果γ接近0\",{\"1\":{\"19\":1}}],[\"如果agent在当前时刻t所执行的动作能够提高总mos\",{\"1\":{\"13\":1}}],[\"如p\",{\"1\":{\"19\":1}}],[\"如a\",{\"1\":{\"14\":1}}],[\"需求我们在post请求中携带页面中的csrftoken才可以\",{\"1\":{\"660\":1}}],[\"需考虑用户的移动性\",{\"1\":{\"14\":1}}],[\"需要传入事务对象\",{\"1\":{\"1242\":1}}],[\"需要手动proceed\",{\"1\":{\"1231\":1}}],[\"需要我们手动调用才可以执行此方法\",{\"1\":{\"1224\":1}}],[\"需要切入的类\",{\"1\":{\"1217\":1}}],[\"需要打印日志\",{\"1\":{\"1215\":1}}],[\"需要加入单引号\",{\"1\":{\"1205\":1}}],[\"需要一个key和一个value\",{\"1\":{\"1197\":1}}],[\"需要一个初始化器\",{\"1\":{\"650\":1}}],[\"需要拿到applicationeventpublisher\",{\"1\":{\"1192\":1}}],[\"需要将我们预先给定的属性注入到对象中\",{\"1\":{\"1132\":1}}],[\"需要全部推翻\",{\"1\":{\"1116\":1}}],[\"需要为字符编码\",{\"1\":{\"1092\":1}}],[\"需要重定向到哪一个网址\",{\"1\":{\"1082\":1}}],[\"需要两倍的往返时间\",{\"1\":{\"1042\":1}}],[\"需要用到很多种不同的日志框架\",{\"1\":{\"1025\":1}}],[\"需要和之前一样使用完全限定的方法名称来引用\",{\"1\":{\"994\":1}}],[\"需要配置这些额外的参数\",{\"1\":{\"897\":1}}],[\"需要配置登陆页面的地址和登陆请求发送的地址\",{\"1\":{\"680\":1}}],[\"需要解决这个问题\",{\"1\":{\"888\":1}}],[\"需要解析的html页面文件存放的位置\",{\"1\":{\"560\":1}}],[\"需要解析的后缀名称\",{\"1\":{\"560\":1}}],[\"需要自动携带他们的小组\",{\"1\":{\"855\":1}}],[\"需要完整的包名+类名才可以\",{\"1\":{\"831\":1}}],[\"需要编写大量的get\",{\"1\":{\"810\":1}}],[\"需要编写一个配置文件\",{\"1\":{\"547\":1}}],[\"需要添加一个参数\",{\"1\":{\"991\":1}}],[\"需要添加表名前缀来指明是哪一个表的数据\",{\"1\":{\"767\":1}}],[\"需要添加其对应的角色\",{\"1\":{\"692\":1}}],[\"需要以hasanyauthority或hasauthority进行判断\",{\"1\":{\"693\":1}}],[\"需要在environments的上方\",{\"1\":{\"1017\":1}}],[\"需要在mybatis中开启批处理\",{\"1\":{\"871\":1}}],[\"需要在请求的时候加入csrftoken才行\",{\"1\":{\"660\":1}}],[\"需要在类的最上面添加package关键字来指明当前类所处的包\",{\"1\":{\"277\":1}}],[\"需要使用关联查询将用户的详细信息一并获取\",{\"1\":{\"850\":1}}],[\"需要使用\",{\"1\":{\"831\":1}}],[\"需要使用filtertarget进行指定\",{\"1\":{\"699\":1}}],[\"需要使用模板引擎进行解析\",{\"1\":{\"560\":1}}],[\"需要使用逗号隔开\",{\"1\":{\"497\":1}}],[\"需要清理对应的换行符\",{\"1\":{\"531\":1}}],[\"需要等到执行终止操作的时候才会进行实际的计算\",{\"1\":{\"514\":1}}],[\"需要指定由哪些类继承\",{\"1\":{\"504\":1}}],[\"需要先初始化\",{\"1\":{\"1244\":1}}],[\"需要先进行登录才可以访问\",{\"1\":{\"1096\":1}}],[\"需要先进行导入才可以\",{\"1\":{\"277\":1}}],[\"需要先引入context命名空间\",{\"1\":{\"549\":1}}],[\"需要先创建一个map对象\",{\"1\":{\"475\":1}}],[\"需要由子类来完成\",{\"1\":{\"375\":1}}],[\"需要通过context进行传递\",{\"1\":{\"563\":1}}],[\"需要通过关键字\",{\"1\":{\"277\":2}}],[\"需要通过采样解决\",{\"1\":{\"45\":1}}],[\"需要进行大小限制\",{\"1\":{\"182\":1}}],[\"需要接受的参数类型并不确定时\",{\"1\":{\"171\":1}}],[\"需要考虑怎样对状态进行平均\",{\"1\":{\"133\":1}}],[\"需要求解一个优化问题\",{\"1\":{\"101\":1}}],[\"需要从\",{\"1\":{\"77\":1}}],[\"需要初始化猜测的\",{\"1\":{\"70\":1}}],[\"需要初始化策略π0​\",{\"1\":{\"70\":1}}],[\"需要确定几件事\",{\"1\":{\"53\":1}}],[\"需要推导e\",{\"1\":{\"42\":1}}],[\"需要调整相应无人机的高度\",{\"1\":{\"9\":1}}],[\"需要合理选择无人机n的垂直高度hn​\",{\"1\":{\"9\":1}}],[\"∑s∈s​d\",{\"1\":{\"150\":1}}],[\"∑s∈s​dπ​\",{\"1\":{\"135\":1}}],[\"∑k=1∞​ak2​=∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak2​<∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"∑kn​=1kn​​pkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"∑i=1k−1​xi​+xk​\",{\"1\":{\"94\":1}}],[\"∑​pπ​\",{\"1\":{\"46\":1}}],[\"∑​p\",{\"1\":{\"44\":2,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2,\"77\":1,\"113\":1}}],[\"∑​vπ​\",{\"1\":{\"44\":2}}],[\"∑​e\",{\"1\":{\"44\":3}}],[\"∑n=1n​∣kn​∣是总用户数\",{\"1\":{\"14\":1}}],[\"则此方法单独创建一个子事务\",{\"1\":{\"1284\":1}}],[\"则此视图不允许更新\",{\"1\":{\"779\":5}}],[\"则清理浏览器中的cookie\",{\"1\":{\"1093\":1}}],[\"则所有以\",{\"1\":{\"1092\":1}}],[\"则本域名下contextpath都可以访问该cookie\",{\"1\":{\"1092\":1}}],[\"则只有contextpath为\",{\"1\":{\"1092\":1}}],[\"则只是进行一次带入求解\",{\"1\":{\"70\":1}}],[\"则该cookie在maxage秒后失效\",{\"1\":{\"1092\":1}}],[\"则需要使用base64编码\",{\"1\":{\"1092\":1}}],[\"则需要在security的配置类上添加\",{\"1\":{\"695\":1}}],[\"则默认采用该依赖有效范围\",{\"1\":{\"1016\":1}}],[\"则默认值不会生效\",{\"1\":{\"747\":1}}],[\"则会调用接口中方法\",{\"1\":{\"1310\":1}}],[\"则会直接让内部的test2\",{\"1\":{\"1281\":1}}],[\"则会开启一个新的事务\",{\"1\":{\"1281\":1}}],[\"则会变成事务操作\",{\"1\":{\"830\":1}}],[\"则会使用默认值\",{\"1\":{\"747\":1}}],[\"则不允许对此视图执行insert和update操作\",{\"1\":{\"779\":1}}],[\"则用空格填充\",{\"1\":{\"746\":1}}],[\"则用户的关联动作数为2n∑n=1n​∣kn​∣\",{\"1\":{\"14\":1}}],[\"则直接给到wac\",{\"1\":{\"625\":1}}],[\"则构造函数冗长\",{\"1\":{\"523\":1}}],[\"则返回\",{\"1\":{\"520\":2}}],[\"则等价于\",{\"1\":{\"403\":1}}],[\"则表示只能赋一次值\",{\"1\":{\"374\":1}}],[\"则表示永久等待\",{\"1\":{\"318\":1}}],[\"则主动唤醒自己\",{\"1\":{\"318\":1}}],[\"则是让处于\",{\"1\":{\"318\":1}}],[\"则是对多个\",{\"1\":{\"41\":1}}],[\"则可以先让出一部分资源\",{\"1\":{\"302\":1}}],[\"则必须实现serializable接口才能被序列化\",{\"1\":{\"288\":1}}],[\"则之后的内容不会被保留\",{\"1\":{\"265\":1}}],[\"则无需再去请求外部设备\",{\"1\":{\"260\":1}}],[\"则无人机将获得正奖励\",{\"1\":{\"13\":1}}],[\"则总动作空间的大小为7+2n∑n=1n​∣kn​∣会导致动作空间过大\",{\"1\":{\"14\":1}}],[\"设计的\",{\"1\":{\"1094\":1}}],[\"设计一种基于\",{\"1\":{\"5\":2}}],[\"设置启动事件和活动标志以及执行其他初始化\",{\"1\":{\"1320\":1}}],[\"设置作用域为原型模式\",{\"1\":{\"1296\":1}}],[\"设置的配置\",{\"0\":{\"1170\":1}}],[\"设置完成后\",{\"1\":{\"1047\":1}}],[\"设置记住我有效时间为7天\",{\"1\":{\"687\":1}}],[\"设置刚刚的记住我持久化存储库\",{\"1\":{\"687\":1}}],[\"设置\",{\"1\":{\"550\":1}}],[\"设置初始值\",{\"1\":{\"320\":1}}],[\"设置为守护线程\",{\"1\":{\"329\":2}}],[\"设置为\",{\"1\":{\"27\":1}}],[\"设定为20秒\",{\"1\":{\"1092\":1}}],[\"设定内容类型以及编码格式\",{\"1\":{\"1058\":1}}],[\"设定根容器为web容器的父容器\",{\"1\":{\"625\":1}}],[\"设定此属性的值\",{\"1\":{\"350\":1}}],[\"设定上界为number\",{\"1\":{\"173\":1}}],[\"设定类型参数上界\",{\"1\":{\"172\":1}}],[\"设\",{\"1\":{\"135\":1,\"137\":1}}],[\"设无人机总数为n\",{\"1\":{\"14\":1}}],[\"对内部维护的beanfactory进行刷新操作\",{\"1\":{\"1320\":1}}],[\"对bean的管理都是依靠beanfactory在进行\",{\"1\":{\"1296\":1}}],[\"对连接进行额外的一些配置\",{\"1\":{\"1244\":1}}],[\"对其进行全方面处理\",{\"1\":{\"1224\":1}}],[\"对其进行修改\",{\"1\":{\"166\":1}}],[\"对方法的调用进行各种增强\",{\"1\":{\"1221\":1}}],[\"对这个字符串进行各种操作\",{\"1\":{\"1202\":1}}],[\"对父项目执行的任何操作除了作用于本身\",{\"1\":{\"1038\":1}}],[\"对数据的修改就是永久的\",{\"1\":{\"782\":1}}],[\"对视图的修改就是对基本表的修改\",{\"1\":{\"779\":1}}],[\"对视图进行渲染等\",{\"1\":{\"626\":1}}],[\"对servletrequest进行进一步包装\",{\"1\":{\"714\":1}}],[\"对登录的请求进行处理\",{\"1\":{\"714\":1}}],[\"对退出登录的请求进行处理\",{\"1\":{\"714\":1}}],[\"对流的操作分为两种\",{\"1\":{\"515\":1}}],[\"对集合数据进行操作\",{\"1\":{\"513\":1}}],[\"对集合中元素的批量处理\",{\"1\":{\"476\":1}}],[\"对反射进行了限制\",{\"1\":{\"350\":1}}],[\"对\",{\"1\":{\"224\":1,\"714\":1}}],[\"对出队顺序进行调整\",{\"1\":{\"203\":1}}],[\"对剩下的元素进行自定义遍历操作\",{\"1\":{\"189\":1}}],[\"对当前集合按照给定的规则进行排序操作\",{\"1\":{\"181\":1}}],[\"对象不应该直接创建出来吗\",{\"1\":{\"1301\":1}}],[\"对象不再始终是同一个了\",{\"1\":{\"1129\":1}}],[\"对象只会存在一个\",{\"1\":{\"1300\":1}}],[\"对象一定会被放在活跃列表中\",{\"1\":{\"1246\":1}}],[\"对象构造完成后\",{\"1\":{\"1148\":2}}],[\"对象始终为同一个\",{\"1\":{\"1129\":1}}],[\"对象始终是相同的\",{\"1\":{\"339\":1}}],[\"对象里\",{\"1\":{\"1095\":1}}],[\"对象判断\",{\"0\":{\"971\":1}}],[\"对象简谱\",{\"1\":{\"609\":1}}],[\"对象与多态\",{\"0\":{\"342\":1}}],[\"对象序列化\",{\"0\":{\"288\":1}}],[\"对象流\",{\"0\":{\"287\":1}}],[\"对象再多\",{\"1\":{\"274\":1}}],[\"对象在创建之后\",{\"1\":{\"166\":1}}],[\"对象创建成功之后\",{\"1\":{\"161\":1}}],[\"对象实例的创建\",{\"1\":{\"161\":1}}],[\"对象\",{\"0\":{\"340\":1,\"341\":1,\"408\":1},\"1\":{\"161\":1,\"312\":1,\"339\":1,\"406\":1,\"415\":2,\"452\":1,\"560\":1,\"604\":1,\"1260\":1}}],[\"对应示例操作\",{\"0\":{\"1277\":1}}],[\"对应mybatis的源码\",{\"1\":{\"1242\":1}}],[\"对应属性就需要有对应的getter方法\",{\"1\":{\"1203\":1}}],[\"对应设置监听器\",{\"1\":{\"1192\":1}}],[\"对应事件的监听器就会被通知\",{\"1\":{\"1191\":1}}],[\"对应depends\",{\"1\":{\"1171\":1}}],[\"对应scope属性\",{\"1\":{\"1171\":1}}],[\"对应s就是uav的部署位置\",{\"1\":{\"13\":1}}],[\"对应lazy\",{\"1\":{\"1171\":1}}],[\"对应实现类\",{\"1\":{\"1119\":1}}],[\"对应实体类如下\",{\"1\":{\"853\":1}}],[\"对应实体类属性名\",{\"1\":{\"835\":1}}],[\"对应用户会收到相应请求\",{\"1\":{\"1096\":1}}],[\"对应用户发起的请求信息\",{\"1\":{\"1057\":1}}],[\"对应数据库字段名\",{\"1\":{\"835\":1}}],[\"对应java进行调用\",{\"1\":{\"831\":1}}],[\"对应哪个数据库的jdbc驱动\",{\"1\":{\"824\":1}}],[\"对应支持http协议的响应内容\",{\"1\":{\"727\":1}}],[\"对应关系如下表\",{\"1\":{\"384\":1}}],[\"对应地\",{\"1\":{\"343\":1}}],[\"对应多个文件夹\",{\"1\":{\"277\":1}}],[\"对应缓冲流的close源码\",{\"1\":{\"264\":1}}],[\"对应目标函数的真实梯度是\",{\"1\":{\"136\":1}}],[\"对应收敛性证明\",{\"1\":{\"104\":1}}],[\"对应一个向量\",{\"1\":{\"58\":1}}],[\"对应策略表示为\",{\"1\":{\"57\":1}}],[\"对应的配置为\",{\"1\":{\"1273\":1}}],[\"对应的实现类为managedtransaction\",{\"1\":{\"1272\":1}}],[\"对应的实现类为jdbctransaction\",{\"1\":{\"1272\":1}}],[\"对应的实体类为\",{\"1\":{\"849\":1}}],[\"对应的事件的source参数随便给一个对象就行\",{\"1\":{\"1192\":1}}],[\"对应的用户请求头就会包含\",{\"1\":{\"1091\":1}}],[\"对应的服务器响应头就会包含\",{\"1\":{\"1091\":1}}],[\"对应的前端用\",{\"1\":{\"1069\":1}}],[\"对应的class\",{\"1\":{\"343\":1}}],[\"对应的vk+1​\",{\"1\":{\"63\":1}}],[\"对应的动作\",{\"1\":{\"57\":1}}],[\"对应的\",{\"1\":{\"42\":2,\"46\":1,\"66\":1,\"94\":1,\"116\":1,\"343\":1,\"1059\":1}}],[\"对应的discounted\",{\"1\":{\"39\":1}}],[\"对应算法\",{\"0\":{\"28\":1}}],[\"对应\",{\"1\":{\"23\":2,\"154\":1,\"212\":1,\"1096\":1}}],[\"对应状态中所有可选择的动作集合\",{\"1\":{\"19\":1}}],[\"对于此接口的实现\",{\"1\":{\"1272\":1}}],[\"对于虚读和幻读的区分\",{\"1\":{\"1271\":1}}],[\"对于spring\",{\"1\":{\"1253\":1}}],[\"对于list\",{\"1\":{\"1207\":1}}],[\"对于map这里映射型\",{\"1\":{\"1207\":1}}],[\"对于那些需要导入才能使用的类以及静态方法使用\",{\"1\":{\"1205\":1}}],[\"对于那些我们需要通过构造方法或是setter完成依赖注入的bean\",{\"1\":{\"1172\":1}}],[\"对于构造方法\",{\"1\":{\"1203\":1}}],[\"对于构造方法或是setter\",{\"1\":{\"1173\":1}}],[\"对于getter方法\",{\"1\":{\"1203\":1}}],[\"对于单例情况\",{\"1\":{\"1181\":1}}],[\"对于我们之前使用的工厂模式\",{\"1\":{\"1180\":1}}],[\"对于我们来说\",{\"1\":{\"659\":1,\"691\":1}}],[\"对于原型模式下的bean\",{\"1\":{\"1148\":1}}],[\"对于使用构造方法完成的依赖注入\",{\"1\":{\"1139\":1}}],[\"对于使用者来说\",{\"1\":{\"437\":1}}],[\"对于集合类型\",{\"1\":{\"1136\":1}}],[\"对于项目坐标定义的packaging\",{\"1\":{\"1015\":1}}],[\"对于其他类中的方法\",{\"1\":{\"994\":1}}],[\"对于某些存在随机性的测试案例\",{\"1\":{\"989\":1}}],[\"对于更加复杂的组合结果判断\",{\"1\":{\"972\":1}}],[\"对于一些不影响结果的测试\",{\"1\":{\"974\":1}}],[\"对于一对多查询\",{\"1\":{\"853\":1}}],[\"对于一个测试案例来说\",{\"1\":{\"963\":1}}],[\"对于一个\",{\"1\":{\"81\":1}}],[\"对于实体类中的每个参数\",{\"1\":{\"525\":1}}],[\"对于目标类中的所有的属性和未初始化的final字段\",{\"1\":{\"525\":1}}],[\"对于已经实现的方法\",{\"1\":{\"414\":1}}],[\"对于这种别人编写的类型\",{\"1\":{\"1254\":1}}],[\"对于这种使用\",{\"1\":{\"1179\":1}}],[\"对于这种集合类型\",{\"1\":{\"1136\":1}}],[\"对于这种成员内部类\",{\"1\":{\"408\":1}}],[\"对于这个问题\",{\"1\":{\"101\":1}}],[\"对于普通字符来说\",{\"1\":{\"403\":1}}],[\"对于变量来说\",{\"1\":{\"402\":1}}],[\"对于基本类型的数组来说\",{\"1\":{\"395\":1}}],[\"对于需要精确计算的场景\",{\"1\":{\"386\":1}}],[\"对于非常大的整数计算\",{\"1\":{\"386\":1}}],[\"对于引用类型\",{\"1\":{\"377\":1}}],[\"对于类中基本数据类型\",{\"1\":{\"377\":1}}],[\"对于类型变量来说是不支持的\",{\"1\":{\"172\":2}}],[\"对于人类的不同子类\",{\"1\":{\"376\":1}}],[\"对于成员方法\",{\"1\":{\"374\":1}}],[\"对于成员变量\",{\"1\":{\"374\":1}}],[\"对于任意一个对象\",{\"1\":{\"336\":1}}],[\"对于任意一个类\",{\"1\":{\"336\":1}}],[\"对于泛型类test\",{\"1\":{\"173\":1}}],[\"对于对象而言\",{\"1\":{\"161\":1}}],[\"对于策略\",{\"1\":{\"113\":1}}],[\"对于观测值g​\",{\"1\":{\"104\":1}}],[\"对于函数\",{\"1\":{\"101\":1}}],[\"对于贝尔曼最优公式而言\",{\"1\":{\"55\":1,\"56\":1}}],[\"对于\",{\"1\":{\"48\":1,\"70\":3,\"77\":2,\"79\":1,\"81\":1,\"88\":1,\"130\":1,\"142\":1,\"241\":3,\"413\":1,\"1181\":1}}],[\"对于所有状态s\",{\"1\":{\"46\":1}}],[\"对于不同的策略\",{\"1\":{\"40\":1}}],[\"对于每一个会话\",{\"1\":{\"588\":1}}],[\"对于每一个状态\",{\"1\":{\"19\":1}}],[\"对于每次http请求\",{\"1\":{\"588\":1}}],[\"对于每个\",{\"1\":{\"81\":1}}],[\"对于每个智能体\",{\"1\":{\"13\":1}}],[\"对于动作空间而言\",{\"1\":{\"14\":1}}],[\"对于用户kn​存在特定的信噪比目标γkn​​\",{\"1\":{\"9\":1}}],[\"对于用户kn​∈kn​\",{\"1\":{\"8\":1}}],[\"对于无人机的总发射功率也均匀地分配给每个用户\",{\"1\":{\"9\":1}}],[\"对于无人机n\",{\"1\":{\"8\":1,\"9\":1}}],[\"对于指定区域\",{\"1\":{\"8\":1}}],[\"值是一个随机的排列组合\",{\"1\":{\"1095\":1}}],[\"值判断\",{\"0\":{\"969\":1}}],[\"值为int的最大值\",{\"1\":{\"912\":1}}],[\"值为1000\",{\"1\":{\"910\":1}}],[\"值为0\",{\"1\":{\"215\":1}}],[\"值3\",{\"1\":{\"754\":1}}],[\"值2\",{\"1\":{\"754\":5}}],[\"值1\",{\"1\":{\"754\":5}}],[\"值需要存在\",{\"1\":{\"512\":1}}],[\"值还是可以修改\",{\"1\":{\"396\":1}}],[\"值也相同\",{\"1\":{\"241\":1}}],[\"值函数近似\",{\"0\":{\"130\":1}}],[\"值迭代和策略迭代\",{\"0\":{\"61\":1}}],[\"值的估计通过一个网络来进行描述\",{\"1\":{\"23\":1}}],[\"值\",{\"1\":{\"13\":1}}],[\"最关键的来了\",{\"1\":{\"1218\":1}}],[\"最关键的其实是name\",{\"1\":{\"1092\":1}}],[\"最低日志级别\",{\"1\":{\"910\":1}}],[\"最低优先级\",{\"1\":{\"302\":1}}],[\"最高日志级别\",{\"1\":{\"910\":1}}],[\"最高优先级\",{\"1\":{\"302\":1}}],[\"最近最少使用\",{\"1\":{\"884\":1}}],[\"最近的是参数\",{\"1\":{\"408\":1}}],[\"最核心的部分了\",{\"1\":{\"626\":1}}],[\"最少匹配\",{\"1\":{\"403\":1}}],[\"最方便的是\",{\"1\":{\"284\":1}}],[\"最好是一个域名的格式\",{\"1\":{\"277\":1}}],[\"最好的\",{\"0\":{\"27\":1}}],[\"最小\",{\"0\":{\"233\":1}}],[\"最大\",{\"0\":{\"233\":1}}],[\"最大的不同是它支持基本数据类型的直接读取\",{\"1\":{\"286\":1}}],[\"最大的\",{\"1\":{\"77\":1,\"79\":1}}],[\"最大的q\",{\"1\":{\"13\":1}}],[\"最后处理得到的bean定义发现此bean是一个mapperfactorybean\",{\"1\":{\"1327\":1}}],[\"最后处理结果\",{\"1\":{\"626\":1}}],[\"最后都是通过调用getbean方法来初始化实例\",{\"1\":{\"1321\":1}}],[\"最后进行刷新操作\",{\"1\":{\"1317\":1}}],[\"最后返回所有的bean定义集合\",{\"1\":{\"1327\":1}}],[\"最后返回一个代理对象\",{\"1\":{\"1310\":1}}],[\"最后返回给dispatcherservlet一个包含所有数据的成形页面\",{\"1\":{\"558\":1}}],[\"最后还会进行一次类型判断\",{\"1\":{\"1300\":1}}],[\"最后还有一个普通的select方法\",{\"1\":{\"836\":1}}],[\"最后设定子工厂的父工厂\",{\"1\":{\"1298\":1}}],[\"最后这张图\",{\"1\":{\"1271\":1}}],[\"最后是配置文件\",{\"1\":{\"1255\":1}}],[\"最后该干嘛干嘛\",{\"1\":{\"1246\":1}}],[\"最后得到的结果为true\",{\"1\":{\"1129\":1}}],[\"最后得到的结果并不是我们插入顺序\",{\"1\":{\"207\":1}}],[\"最后总结三种情况\",{\"1\":{\"1271\":1}}],[\"最后总结\",{\"1\":{\"1083\":1}}],[\"最后创建一个servlet用于处理时间更新请求\",{\"1\":{\"1076\":1}}],[\"最后交给web服务器\",{\"1\":{\"1053\":1}}],[\"最后实际执行的sql为\",{\"1\":{\"876\":1}}],[\"最后实际上调用的是filterchainproxy的dofilter方法\",{\"1\":{\"707\":1}}],[\"最后实际上只有一个成功插入了\",{\"1\":{\"205\":1}}],[\"最后一个参数为我们希望作为key的属性\",{\"1\":{\"836\":1}}],[\"最后\",{\"1\":{\"811\":1,\"1042\":1,\"1055\":1,\"1180\":1,\"1311\":1}}],[\"最后需要\",{\"1\":{\"720\":1}}],[\"最后请求结束时会进行清理\",{\"1\":{\"714\":1}}],[\"最后附上完整的过滤器清单\",{\"1\":{\"714\":1}}],[\"最后我们得到结果\",{\"1\":{\"1281\":1}}],[\"最后我们得到的结果为\",{\"1\":{\"612\":1}}],[\"最后我们来调用一下此方法\",{\"1\":{\"1278\":1}}],[\"最后我们来看一下二级缓存相关的配置\",{\"1\":{\"903\":1}}],[\"最后我们发现\",{\"1\":{\"1260\":1}}],[\"最后我们就可以得到一个日志文件了\",{\"1\":{\"920\":1}}],[\"最后我们查询到结果后\",{\"1\":{\"831\":1}}],[\"最后我们在配置类上添加相应的包扫描\",{\"1\":{\"671\":1}}],[\"最后将用户提供的密码以同样的方式加密后与密文进行比较\",{\"1\":{\"659\":1}}],[\"最后handleradapter会将结果封装为modelandview返回给mv\",{\"1\":{\"626\":1}}],[\"最后根据方法的返回值将其封装为modelandview对象\",{\"1\":{\"625\":1}}],[\"最后在方法上添加\",{\"1\":{\"959\":1}}],[\"最后在构造sqlsessionfactory时也可以通过此对象进行创建\",{\"1\":{\"904\":1}}],[\"最后在程序中使用我们定义好的mapper即可\",{\"1\":{\"826\":1}}],[\"最后在前端添加一个文件的上传点\",{\"1\":{\"619\":1}}],[\"最后在后续版本中正式开放使用\",{\"1\":{\"494\":1}}],[\"最后访问页面\",{\"1\":{\"564\":1}}],[\"最后再等等\",{\"1\":{\"1246\":1}}],[\"最后再完成填充\",{\"1\":{\"1181\":1}}],[\"最后再由mybatis将其结果合并\",{\"1\":{\"851\":1}}],[\"最后再将view和model进行渲染\",{\"1\":{\"541\":1}}],[\"最后再提一下\",{\"1\":{\"423\":1}}],[\"最后写个注解处理器来捕获并处理\",{\"1\":{\"534\":1}}],[\"最后使用哪个注解\",{\"1\":{\"1175\":1}}],[\"最后使用\",{\"1\":{\"524\":1}}],[\"最后通过\",{\"1\":{\"522\":1}}],[\"最后会被映射为一个实体类\",{\"1\":{\"501\":1}}],[\"最后会返回一个值作为i的新值\",{\"1\":{\"478\":1}}],[\"最后才能使用的方式\",{\"1\":{\"499\":1}}],[\"最后比对属性是否一样\",{\"1\":{\"499\":1}}],[\"最后打印\",{\"1\":{\"476\":1}}],[\"最后面分号可以不打\",{\"1\":{\"378\":1}}],[\"最后也得不到我们想要的结果\",{\"1\":{\"312\":1}}],[\"最后由mybatis来对查询的结果进行处理即可\",{\"1\":{\"850\":1}}],[\"最后由\",{\"1\":{\"228\":1}}],[\"最后哈希表就长这样了\",{\"1\":{\"215\":1}}],[\"最优的策略\",{\"1\":{\"148\":1}}],[\"最优策略\",{\"0\":{\"57\":1}}],[\"最优策略是\",{\"1\":{\"53\":1}}],[\"最优策略是否唯一\",{\"1\":{\"53\":1}}],[\"最优策略是否存在\",{\"1\":{\"53\":1}}],[\"最优策略的定义\",{\"1\":{\"53\":1}}],[\"最接近真实的vπ​\",{\"1\":{\"132\":1}}],[\"最简单的示例算法\",{\"1\":{\"76\":1}}],[\"最终得到的bean加载完成的实例\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"最终的结果依然是被赋值为数据库中的结果\",{\"1\":{\"841\":1}}],[\"最终的图片地址就有了\",{\"1\":{\"490\":1}}],[\"最终只需要将resulttype改为resultmap并指定对应id即可\",{\"1\":{\"835\":1}}],[\"最终渲染视图\",{\"1\":{\"560\":1}}],[\"最终到\",{\"1\":{\"424\":1}}],[\"最终操作\",{\"1\":{\"228\":1}}],[\"最终会达到一个平稳的状态\",{\"1\":{\"135\":1}}],[\"最终优化的策略\",{\"1\":{\"121\":1}}],[\"最终可以证明\",{\"1\":{\"47\":1}}],[\"最终输出结果\",{\"1\":{\"13\":1}}],[\"最终输出的结果\",{\"1\":{\"13\":1}}],[\"当使用容器中factory\",{\"1\":{\"1328\":1}}],[\"当下次再读取时会莫名其妙多出或缺失数据\",{\"1\":{\"1271\":1}}],[\"当两个事务同时在执行\",{\"1\":{\"1267\":1}}],[\"当两个线程同时读取value的时候\",{\"1\":{\"311\":1}}],[\"当多个事务\",{\"1\":{\"1267\":1}}],[\"当多个cpu在操作自己的缓存时\",{\"1\":{\"888\":1}}],[\"当需要时\",{\"1\":{\"1257\":1}}],[\"当需要一个connection对象时\",{\"1\":{\"1242\":1}}],[\"当需要等待外部io操作\",{\"1\":{\"299\":1}}],[\"当遇到空时\",{\"1\":{\"1211\":1}}],[\"当遇到null时很不方便\",{\"1\":{\"1211\":1}}],[\"当遇到大量的复杂操作时\",{\"1\":{\"228\":1}}],[\"当发生异常时\",{\"1\":{\"1282\":1}}],[\"当发生某个事件时就会通知我们\",{\"1\":{\"1191\":1}}],[\"当发送请求时\",{\"1\":{\"617\":1}}],[\"当事件触发时\",{\"1\":{\"1191\":1}}],[\"当此方法被调用时\",{\"1\":{\"1188\":1}}],[\"当容器创建时\",{\"1\":{\"1148\":1}}],[\"当bean的作用域为单例模式时\",{\"1\":{\"1129\":1}}],[\"当autowire\",{\"1\":{\"1140\":1}}],[\"当aservice被更新了\",{\"1\":{\"1119\":1}}],[\"当a为静止时\",{\"1\":{\"13\":1}}],[\"当具体实现类发生修改时\",{\"1\":{\"1117\":1}}],[\"当service发现要从数据库中获取数据时\",{\"1\":{\"1116\":1}}],[\"当dofilter方法调用时\",{\"1\":{\"1103\":1}}],[\"当没有下一个过滤器时\",{\"1\":{\"1103\":1}}],[\"当没有客户端连接时\",{\"1\":{\"719\":1,\"720\":1}}],[\"当满足条件时\",{\"1\":{\"1091\":1}}],[\"当浏览器收到一个重定向的响应时\",{\"1\":{\"1082\":1}}],[\"当建立tcp连接的三报文握手的前两部分完成后\",{\"1\":{\"1042\":1}}],[\"当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时\",{\"1\":{\"1025\":1}}],[\"当测试出现问题时\",{\"1\":{\"1036\":1}}],[\"当测试开始前\",{\"1\":{\"985\":1}}],[\"当测试案例失败时\",{\"1\":{\"963\":1}}],[\"当条件方法位于外部类中时\",{\"1\":{\"980\":1}}],[\"当断言操作发现实际结果与预期不符时\",{\"1\":{\"969\":1}}],[\"当父级和子级都配置时\",{\"1\":{\"929\":1}}],[\"当一级缓存中都还没有数据时\",{\"1\":{\"885\":1}}],[\"当一个请求经过dispatcherservlet之后\",{\"1\":{\"558\":1}}],[\"当一个线程进入到同步代码块时\",{\"1\":{\"312\":1}}],[\"当二级缓存中没有时\",{\"1\":{\"885\":1}}],[\"当到达指定时间时会自动清理所有缓存\",{\"1\":{\"884\":1}}],[\"当缓存达到上限时\",{\"1\":{\"884\":1}}],[\"当主键列不是表中的第一列的时候\",{\"1\":{\"862\":1}}],[\"当触发器表上发生select\",{\"1\":{\"781\":1}}],[\"当数据库和表为\",{\"1\":{\"774\":1}}],[\"当对方没有发送任何数据过来\",{\"1\":{\"721\":1}}],[\"当对象被判定为已经不再使用的\",{\"1\":{\"372\":1}}],[\"当对象不同时\",{\"1\":{\"312\":1}}],[\"当客户端连接后\",{\"1\":{\"721\":1}}],[\"当超过设定时间都依然没有收到客户端或是服务端的数据时\",{\"1\":{\"721\":1}}],[\"当filter返回之后\",{\"1\":{\"706\":1}}],[\"当有对对象的引用时\",{\"1\":{\"1211\":1}}],[\"当有多个集合时\",{\"1\":{\"699\":1}}],[\"当有新的任务时\",{\"1\":{\"324\":1}}],[\"当用户点击包含恶意代码的url时\",{\"1\":{\"643\":1}}],[\"当用户访问受到注入攻击的页面时\",{\"1\":{\"643\":1}}],[\"当用户使用该会话id登录时\",{\"1\":{\"642\":1}}],[\"当用户在两个不同域名的站点操作时\",{\"1\":{\"641\":1}}],[\"当你把对应的init方法写在studentfactory中\",{\"1\":{\"1158\":1}}],[\"当你发现上当受骗时\",{\"1\":{\"641\":1}}],[\"当你使用内部类静态方法\",{\"1\":{\"411\":1}}],[\"当handlermapping找到处理请求的controller之后\",{\"1\":{\"625\":1}}],[\"当控制器方法抛出异常时\",{\"1\":{\"604\":1}}],[\"当请求参数缺失时\",{\"1\":{\"581\":1}}],[\"当收到请求时就可以根据映射关系调用对应的请求处理方法\",{\"1\":{\"569\":1}}],[\"当只需要部分参数的时候需要再定义个构造函数\",{\"1\":{\"523\":1}}],[\"当i小于10时正常通过\",{\"1\":{\"479\":1}}],[\"当integer不是number的子类时\",{\"1\":{\"343\":1}}],[\"当子类实现此接口时\",{\"1\":{\"439\":1}}],[\"当代码可能出现多种类型的异常时\",{\"1\":{\"424\":1}}],[\"当程序没有按照我们理想的样子运行而出现异常时\",{\"1\":{\"424\":1}}],[\"当程序在运行时\",{\"1\":{\"173\":1}}],[\"当别人调用我们的方法时\",{\"1\":{\"423\":1}}],[\"当前一个事务紧接着再次读取时\",{\"1\":{\"1267\":1}}],[\"当前数组长度为\",{\"1\":{\"393\":1}}],[\"当前类\",{\"1\":{\"278\":1}}],[\"当属性为数组\",{\"1\":{\"364\":1}}],[\"当属性为数组时呢\",{\"1\":{\"364\":1}}],[\"当属性存在默认值时\",{\"1\":{\"364\":1}}],[\"当访问private字段时\",{\"1\":{\"350\":1}}],[\"当访问权限不是public的时候\",{\"1\":{\"348\":1}}],[\"当方法是静态方法时\",{\"1\":{\"349\":1}}],[\"当方法的参数为可变参数时\",{\"1\":{\"349\":1}}],[\"当出现歧义时\",{\"1\":{\"1141\":1}}],[\"当出现循环引用时\",{\"1\":{\"614\":1}}],[\"当出现异常时\",{\"1\":{\"602\":1}}],[\"当出现非public方法时\",{\"1\":{\"349\":1}}],[\"当出现多个进程需要同时运行时\",{\"1\":{\"295\":1}}],[\"当默认无参构造的权限不是public时\",{\"1\":{\"348\":1}}],[\"当类默认的构造方法被带参构造覆盖时\",{\"1\":{\"348\":1}}],[\"当货架空的时候\",{\"1\":{\"331\":1}}],[\"当其他用户访问包含恶意代码的页面时\",{\"1\":{\"643\":1}}],[\"当其他所有的非守护线程结束之后\",{\"1\":{\"329\":1}}],[\"当其他线程调用对象的notify\",{\"1\":{\"318\":1}}],[\"当被唤醒后都没有任务时\",{\"1\":{\"324\":1}}],[\"当队列为空同时没有被关闭时\",{\"1\":{\"324\":1}}],[\"当线程出现异常或错误\",{\"1\":{\"300\":1}}],[\"当线程进入休眠\",{\"1\":{\"300\":1}}],[\"当等待状态结束后会回到就绪状态\",{\"1\":{\"300\":1}}],[\"当cpu给予的运行时间结束时\",{\"1\":{\"300\":1}}],[\"当读取的内容数量超过\",{\"1\":{\"265\":1}}],[\"当调用\",{\"1\":{\"265\":2}}],[\"当向外部设备写入数据时\",{\"1\":{\"260\":1}}],[\"当整个链式调用完成后\",{\"1\":{\"228\":1}}],[\"当key存在时存在则计算并赋予新的值\",{\"1\":{\"221\":1}}],[\"当链表长度到达一定限制时\",{\"1\":{\"215\":1}}],[\"当我们打上了\",{\"1\":{\"1310\":1}}],[\"当我们采用工厂模式后\",{\"1\":{\"1158\":1}}],[\"当我们尝试获取该类的bean来创建对象时\",{\"1\":{\"1125\":1}}],[\"当我们希望用户登录完成之后\",{\"1\":{\"1082\":1}}],[\"当我们希望一个线程等待另一个线程执行完成后再继续进行\",{\"1\":{\"305\":1}}],[\"当我们的spring程序启动后\",{\"1\":{\"1190\":1}}],[\"当我们的项目依赖于其他内容时\",{\"1\":{\"1024\":1}}],[\"当我们的请求映射方法中出现异常时\",{\"1\":{\"602\":1}}],[\"当我们在嵌套测试中使用诸如\",{\"1\":{\"988\":1}}],[\"当我们在指定操作系统下执行时\",{\"1\":{\"976\":1}}],[\"当我们在使用变量时\",{\"1\":{\"172\":1}}],[\"当我们开启二级缓存后\",{\"1\":{\"886\":1}}],[\"当我们查询条件不同时\",{\"1\":{\"873\":1}}],[\"当我们要将bean的某个方法设计为异步执行时\",{\"1\":{\"1188\":1}}],[\"当我们要执行很多条语句时\",{\"1\":{\"798\":1,\"871\":1}}],[\"当我们要进行的操作非常多时\",{\"1\":{\"782\":1}}],[\"当我们登录之后\",{\"1\":{\"687\":1}}],[\"当我们下次需要快速创建一个用户登录的应用程序时\",{\"1\":{\"664\":1}}],[\"当我们想要退出时\",{\"1\":{\"658\":1}}],[\"当我们需要这个对象时再申请\",{\"1\":{\"1119\":1}}],[\"当我们需要使用对象时\",{\"1\":{\"1119\":1}}],[\"当我们需要使用复杂字符串时\",{\"1\":{\"498\":1}}],[\"当我们需要把一个集合按照某种规则转成另外一个集合的时候\",{\"1\":{\"522\":1}}],[\"当我们不想使用jshell时\",{\"1\":{\"473\":1}}],[\"当我们按下tab键还可以进行自动补全\",{\"1\":{\"473\":1}}],[\"当我们导入一个jar包作为依赖时\",{\"1\":{\"460\":1}}],[\"当我们使用非静态方法时\",{\"1\":{\"451\":1}}],[\"当我们使用同一个包中的类时\",{\"1\":{\"277\":1}}],[\"当我们字符串编辑完成之后\",{\"1\":{\"402\":1}}],[\"当我们同时去操作一个共享变量时\",{\"1\":{\"311\":1}}],[\"当我们创建对象时\",{\"1\":{\"215\":1}}],[\"当不存在对应的键值对时\",{\"1\":{\"214\":1}}],[\"当\",{\"1\":{\"214\":1,\"221\":1,\"884\":1,\"980\":2}}],[\"当做流水线处理\",{\"1\":{\"228\":1}}],[\"当做队列使用\",{\"1\":{\"200\":1}}],[\"当做一个队列来使用\",{\"1\":{\"200\":1}}],[\"当某个方法\",{\"1\":{\"171\":1}}],[\"当然还有prototype\",{\"1\":{\"1129\":1}}],[\"当然还支持直接转换为stream\",{\"1\":{\"480\":1}}],[\"当然如果仍然需要提交的话也可以使用commit\",{\"1\":{\"865\":1}}],[\"当然如果要导入javase的所有依赖\",{\"1\":{\"461\":1}}],[\"当然我们也可以打印到一个日志文件中\",{\"1\":{\"918\":1}}],[\"当然我们也可以将此方法设计为两个参数的形式\",{\"1\":{\"863\":1}}],[\"当然我们也可以通过反射来获取类是否为密封类型\",{\"1\":{\"504\":1}}],[\"当然这个关系哪怕只写一个mybatis也可以自动推断其他的\",{\"1\":{\"853\":1}}],[\"当然也可以直接不填这个属性\",{\"1\":{\"831\":1}}],[\"当然前提是先得正常访问一次网站才行\",{\"1\":{\"642\":1}}],[\"当然前提是方法定义\",{\"1\":{\"415\":1}}],[\"当然不设置也行\",{\"1\":{\"615\":1}}],[\"当然不加效果也是一样的\",{\"1\":{\"360\":1}}],[\"当然除了以上的特性之外还有java\",{\"1\":{\"480\":1}}],[\"当然除了普通的exports进行包的暴露之外\",{\"1\":{\"464\":1}}],[\"当然除了上面提到的这些情况可以使用方法引用之外\",{\"1\":{\"453\":1}}],[\"当然在磁盘io下\",{\"1\":{\"248\":1}}],[\"当然计算哈希还是使用键\",{\"1\":{\"215\":1}}],[\"当然\",{\"1\":{\"164\":1,\"166\":3,\"171\":1,\"173\":1,\"182\":1,\"202\":1,\"207\":1,\"218\":1,\"269\":1,\"277\":2,\"375\":1,\"403\":1,\"412\":1,\"424\":1,\"438\":1,\"453\":1,\"454\":1,\"475\":1,\"497\":1,\"563\":1,\"641\":1,\"642\":1,\"666\":1,\"682\":1,\"686\":1,\"719\":1,\"817\":1,\"819\":1,\"832\":1,\"833\":1,\"843\":1,\"855\":1,\"899\":1,\"902\":1,\"911\":1,\"918\":1,\"929\":1,\"936\":1,\"938\":1,\"963\":1,\"979\":1,\"986\":1,\"995\":1,\"1033\":1,\"1037\":1,\"1053\":1,\"1057\":1,\"1130\":1,\"1133\":1,\"1150\":1,\"1159\":2,\"1173\":1,\"1175\":1,\"1188\":1,\"1189\":1,\"1200\":2,\"1220\":1,\"1242\":1,\"1260\":1,\"1298\":2}}],[\"当策略是以函数的形式存在时\",{\"1\":{\"148\":1}}],[\"当策略是以表格的形式保存时\",{\"1\":{\"148\":1}}],[\"当执行动作at​时\",{\"1\":{\"13\":1}}],[\"发生异常时\",{\"1\":{\"1281\":1}}],[\"发生异常情况\",{\"0\":{\"599\":1}}],[\"发生指定异常时回滚或是不回滚\",{\"1\":{\"1279\":1}}],[\"发生了一次自定义事件\",{\"1\":{\"1192\":1}}],[\"发送给万维网服务器\",{\"1\":{\"1042\":1}}],[\"发送给后台的帖子往往是直接以html代码的形式\",{\"1\":{\"643\":1}}],[\"发送请求时也不会进行校验\",{\"1\":{\"684\":1}}],[\"发送端的时间\",{\"1\":{\"10\":1}}],[\"发现异常直接销毁所有bean\",{\"1\":{\"1320\":1}}],[\"发现\",{\"1\":{\"560\":1}}],[\"发现对于\",{\"1\":{\"375\":1}}],[\"发现在该位置静止是最优的\",{\"1\":{\"13\":1}}],[\"不急着执行\",{\"1\":{\"1320\":1}}],[\"不多说了\",{\"1\":{\"1279\":1}}],[\"不管成功还是失败\",{\"1\":{\"1266\":1}}],[\"不重要\",{\"1\":{\"1246\":2}}],[\"不使用池化的数据源实现\",{\"1\":{\"1244\":1}}],[\"不使用池化的数据源\",{\"0\":{\"1244\":1}}],[\"不使用连接池的数据源\",{\"1\":{\"1242\":1}}],[\"不使用url而是resource表示是jar内部的文件\",{\"1\":{\"842\":1}}],[\"不太常用\",{\"1\":{\"910\":1}}],[\"不太一样\",{\"1\":{\"144\":1}}],[\"不满足将无法插入\",{\"1\":{\"779\":1}}],[\"不好\",{\"1\":{\"735\":1}}],[\"不被视为\",{\"1\":{\"714\":1}}],[\"不适合实际生产环境下编写\",{\"1\":{\"666\":1}}],[\"不做讲解\",{\"1\":{\"588\":1}}],[\"不断往上找最终继承的就是\",{\"1\":{\"552\":1}}],[\"不论\",{\"1\":{\"531\":1}}],[\"不读换行符\",{\"1\":{\"531\":1}}],[\"不可重复读\",{\"1\":{\"1271\":1}}],[\"不可能每次都去完整地启动一个项目来测试某一个功能\",{\"1\":{\"956\":1}}],[\"不可变\",{\"1\":{\"528\":1}}],[\"不可修改\",{\"1\":{\"528\":1}}],[\"不及格\",{\"1\":{\"495\":1,\"496\":1,\"497\":2}}],[\"不再要求指定class\",{\"1\":{\"1159\":1}}],[\"不再由我们决定\",{\"1\":{\"1116\":1}}],[\"不再是直接由tomcat\",{\"1\":{\"1053\":1}}],[\"不再继续操作后面的元素\",{\"1\":{\"479\":1}}],[\"不再推荐使用newinstance\",{\"1\":{\"348\":1}}],[\"不知道怎么写\",{\"1\":{\"478\":1}}],[\"不然测试案例一多我们就分不清楚到底哪个案例是干嘛的\",{\"1\":{\"961\":1}}],[\"不然可能会映射失败导致查询结果丢失\",{\"1\":{\"826\":1}}],[\"不然会报错\",{\"1\":{\"720\":1}}],[\"不然之前版本的库就用不了了\",{\"1\":{\"463\":1}}],[\"不然就无法通过编译\",{\"1\":{\"424\":1}}],[\"不如说是我们为所需要的接口提供了一个方法作为它的实现\",{\"1\":{\"446\":1}}],[\"不只是类\",{\"1\":{\"439\":1}}],[\"不见当年倒茶人\",{\"1\":{\"415\":1}}],[\"不包括换行\",{\"1\":{\"403\":1}}],[\"不是resource中的资源\",{\"1\":{\"1084\":1}}],[\"不是拦截器\",{\"1\":{\"704\":1}}],[\"不是数据结构\",{\"1\":{\"514\":1}}],[\"不是静态方法\",{\"1\":{\"415\":1}}],[\"不是基本类型\",{\"1\":{\"384\":1}}],[\"不是接口\",{\"1\":{\"323\":1}}],[\"不需要调用\",{\"1\":{\"1190\":1}}],[\"不需要给bean取别名对应\",{\"1\":{\"1173\":1}}],[\"不需要注册工厂bean\",{\"1\":{\"1160\":1}}],[\"不需要直接使用特定驱动中的类或是方法\",{\"1\":{\"1016\":1}}],[\"不需要此依赖\",{\"1\":{\"1016\":1}}],[\"不需要手动导入jar包\",{\"1\":{\"1000\":1}}],[\"不需要我们做任何事情\",{\"1\":{\"842\":1}}],[\"不需要声明访问权限\",{\"1\":{\"410\":1}}],[\"不需要依附任何对象\",{\"1\":{\"409\":1}}],[\"不需要\",{\"1\":{\"384\":1,\"409\":1}}],[\"不需要和用户交互\",{\"1\":{\"329\":1}}],[\"不保留到运行时\",{\"1\":{\"361\":2}}],[\"不会受其他人的影响\",{\"1\":{\"1266\":1}}],[\"不会缓存它\",{\"1\":{\"1181\":1}}],[\"不会再创建新的\",{\"1\":{\"1130\":1}}],[\"不会导入可选的依赖\",{\"1\":{\"1025\":1}}],[\"不会重置其他会话的缓存\",{\"1\":{\"883\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"782\":1}}],[\"不会用空格填充\",{\"1\":{\"746\":1}}],[\"不会保持长久连接\",{\"1\":{\"727\":1}}],[\"不会保存数据\",{\"1\":{\"514\":1}}],[\"不会拦截静态资源\",{\"1\":{\"593\":1}}],[\"不会修改原来的数据源\",{\"1\":{\"514\":1}}],[\"不会调用外部类的\",{\"1\":{\"411\":1}}],[\"不会终止\",{\"0\":{\"324\":1}}],[\"不会影响所求的梯度\",{\"1\":{\"26\":1}}],[\"不要修改我的梦想\",{\"1\":{\"1224\":1}}],[\"不要直接去反射搞构造方法创建\",{\"1\":{\"1158\":1}}],[\"不要直接利用反射机制通过构造方法创建bean对象\",{\"1\":{\"1157\":1}}],[\"不要关闭\",{\"1\":{\"1047\":1}}],[\"不要使用\",{\"1\":{\"401\":1}}],[\"不要出现这种死锁的情况\",{\"1\":{\"313\":1}}],[\"不要跟之前的迭代器接口搞混了\",{\"1\":{\"193\":1}}],[\"不过这里是用于处理beanfactory加载的后置动作\",{\"1\":{\"1311\":1}}],[\"不过这样的话流里面就没东西了\",{\"1\":{\"477\":1}}],[\"不过难免会存在冲突\",{\"1\":{\"1266\":1}}],[\"不过spring底层并不是使用的jdk提供的动态代理\",{\"1\":{\"1215\":1}}],[\"不过要实现这样的方式\",{\"1\":{\"1177\":1}}],[\"不过bean的继承使用频率不是很高\",{\"1\":{\"1151\":1}}],[\"不过需要注意一下顺序\",{\"1\":{\"929\":1}}],[\"不过很遗憾的是\",{\"1\":{\"901\":1}}],[\"不过建议还是写完整一点\",{\"1\":{\"853\":1}}],[\"不过我们每次都可以通过打开视图来按照我们想要的样子查看数据\",{\"1\":{\"779\":1}}],[\"不过我们可以添加restrict或cascade\",{\"1\":{\"751\":1}}],[\"不过我们发现\",{\"1\":{\"461\":1}}],[\"不过因为我们没配置这个路径\",{\"1\":{\"692\":1}}],[\"不过默认就是这个\",{\"1\":{\"680\":1}}],[\"不过默认是向控制台打印\",{\"1\":{\"284\":1}}],[\"不过现在依然是默认进入到springsecurity默认的登录界面\",{\"1\":{\"679\":1}}],[\"不过都是从外部干涉\",{\"1\":{\"643\":1}}],[\"不过是在dispatcherservlet中定义的\",{\"1\":{\"626\":1}}],[\"不过在reader中会将configurationclasspostprocessor后置处理器加入到beanfactory中\",{\"1\":{\"1318\":1}}],[\"不过在有些时候\",{\"1\":{\"1126\":1}}],[\"不过在处理前\",{\"1\":{\"597\":1}}],[\"不过在springmvc中我们使用的是拦截器\",{\"1\":{\"558\":1}}],[\"不过它是用于获取请求头参数的\",{\"1\":{\"583\":1}}],[\"不过它不支持在lambda中使用\",{\"1\":{\"487\":1}}],[\"不过最后编译出来的样子\",{\"1\":{\"496\":1}}],[\"不过貌似可以直接下载文件\",{\"1\":{\"490\":1}}],[\"不过\",{\"1\":{\"463\":1,\"660\":1,\"684\":1,\"861\":1,\"1178\":1,\"1296\":1}}],[\"不过此时当被包装的对象为null时会直接抛出异常\",{\"1\":{\"454\":1}}],[\"不过还可以进行优化\",{\"1\":{\"447\":1}}],[\"不过没必要\",{\"1\":{\"401\":1,\"686\":1}}],[\"不过可以省略\",{\"1\":{\"376\":1}}],[\"不过如果子类也是抽象类\",{\"1\":{\"375\":1}}],[\"不过上面写法比较繁琐\",{\"1\":{\"247\":1}}],[\"不涉及字符编码转换\",{\"1\":{\"245\":1}}],[\"不支持抽象类\",{\"1\":{\"414\":1,\"447\":1}}],[\"不支持\",{\"1\":{\"236\":2}}],[\"不支持随机访问\",{\"1\":{\"204\":1}}],[\"不存在key时\",{\"1\":{\"221\":1}}],[\"不存在\",{\"1\":{\"221\":1}}],[\"不允许修改数据\",{\"1\":{\"1270\":1}}],[\"不允许有重复的值和空值\",{\"1\":{\"747\":1}}],[\"不允许对此类继承\",{\"1\":{\"503\":1}}],[\"不允许\",{\"1\":{\"396\":1,\"528\":1}}],[\"不允许进行修改\",{\"1\":{\"393\":1}}],[\"不允许通过下标访问\",{\"1\":{\"204\":1}}],[\"不允许出现重复元素\",{\"1\":{\"204\":1}}],[\"不用关心\",{\"1\":{\"1047\":2}}],[\"不用手动加载驱动\",{\"1\":{\"788\":1}}],[\"不用重写任何内容\",{\"1\":{\"650\":1}}],[\"不用多说了吧\",{\"1\":{\"201\":3}}],[\"不用进行求导\",{\"1\":{\"142\":1}}],[\"不进行出队操作\",{\"1\":{\"200\":1}}],[\"不仅能调用方法\",{\"1\":{\"1202\":1}}],[\"不仅能从前向后\",{\"1\":{\"194\":1}}],[\"不仅带来网络上的额外开销\",{\"1\":{\"871\":1}}],[\"不仅仅是list\",{\"1\":{\"1136\":1}}],[\"不仅仅是一个普通的集合或是数组可以作为字段参数来源\",{\"1\":{\"995\":1}}],[\"不仅仅是mybatis\",{\"1\":{\"819\":1}}],[\"不仅仅适用于xml\",{\"1\":{\"817\":1}}],[\"不仅仅只是登陆请求\",{\"1\":{\"660\":1}}],[\"不仅仅只运行一个主线程\",{\"1\":{\"295\":1}}],[\"不仅会返回两个表满足条件的交集部分\",{\"1\":{\"769\":1}}],[\"不仅代码简短\",{\"1\":{\"497\":1}}],[\"不仅可以一定程度上防止源代码被反编译\",{\"1\":{\"356\":1}}],[\"不仅保存指向下一个结点的引用\",{\"1\":{\"182\":1}}],[\"不能转发给其他站点或是其他web应用程序\",{\"1\":{\"1083\":1}}],[\"不能一个socket之后就done了\",{\"1\":{\"727\":1}}],[\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组\",{\"1\":{\"438\":1}}],[\"不能匹配\",{\"1\":{\"403\":2}}],[\"不能随便进行修改\",{\"1\":{\"393\":1}}],[\"不能\",{\"1\":{\"386\":1}}],[\"不能直接通过\",{\"1\":{\"412\":1}}],[\"不能直接创建对象\",{\"1\":{\"376\":1}}],[\"不能直接用10\",{\"1\":{\"182\":1}}],[\"不能使用不同的变量进行接收\",{\"1\":{\"438\":1}}],[\"不能使用默认\",{\"1\":{\"376\":1}}],[\"不能使用==\",{\"1\":{\"373\":1}}],[\"不能是懒加载的\",{\"1\":{\"1321\":1}}],[\"不能是非单例模式\",{\"1\":{\"1321\":1}}],[\"不能是静态方法\",{\"1\":{\"959\":1}}],[\"不能是\",{\"1\":{\"375\":1}}],[\"不能认为每一步是直接依次执行的\",{\"1\":{\"228\":1}}],[\"不能进行修改操作\",{\"1\":{\"182\":1}}],[\"不能用同一个q\",{\"1\":{\"13\":1}}],[\"不充足需要扩容\",{\"1\":{\"182\":1}}],[\"不指定具体类型也是可以的\",{\"1\":{\"173\":1}}],[\"不得是其他类型\",{\"1\":{\"172\":1}}],[\"不同路径配置\",{\"0\":{\"1061\":1}}],[\"不同类型的数据库\",{\"1\":{\"787\":1}}],[\"不同类的重名问题\",{\"1\":{\"277\":1}}],[\"不同于主键\",{\"1\":{\"747\":1}}],[\"不同线程向threadlocal存放数据\",{\"1\":{\"319\":1}}],[\"不同包下的类\",{\"1\":{\"278\":1}}],[\"不同包下的子类\",{\"1\":{\"278\":1}}],[\"不同集合类\",{\"0\":{\"190\":1}}],[\"不同之处\",{\"1\":{\"179\":1}}],[\"不同的数据库会根据只读属性进行优化\",{\"1\":{\"1279\":1}}],[\"不同的隔离级别会导致什么问题\",{\"1\":{\"1267\":1}}],[\"不同的bean名字不能相同\",{\"1\":{\"1127\":1}}],[\"不同的路径代表访问不同的资源\",{\"1\":{\"1042\":1}}],[\"不同的协议决定了服务器返回信息的格式\",{\"1\":{\"1042\":1}}],[\"不同的可执行文件都能通过jdbc访问数据库\",{\"1\":{\"787\":1}}],[\"不同的壁纸似乎都是这样\",{\"1\":{\"490\":1}}],[\"不同的模块会导出不同的包供我们使用\",{\"1\":{\"463\":1}}],[\"不同的线程访问到threadlocal对象时\",{\"1\":{\"319\":1}}],[\"不同的对象代表不同的对象锁\",{\"1\":{\"312\":1}}],[\"不同的访问权限\",{\"1\":{\"278\":1}}],[\"不同的文本文件可能会有不同的编码类型\",{\"1\":{\"254\":1}}],[\"不同的实现有着不同的遍历方式\",{\"1\":{\"188\":1}}],[\"不同的集合类具体实现可能会对插入的元素有要求\",{\"1\":{\"180\":1}}],[\"不同的集合有着不同的性质\",{\"1\":{\"178\":1}}],[\"不同的无人机agent的q\",{\"1\":{\"13\":1}}],[\"不同对象的属性是分开独立存放的\",{\"1\":{\"161\":1}}],[\"不记录\",{\"1\":{\"81\":1}}],[\"不动点x∗是唯一的\",{\"1\":{\"58\":1}}],[\"不常用\",{\"1\":{\"47\":1,\"588\":1}}],[\"还记得\",{\"1\":{\"1310\":1}}],[\"还剩下一个springmvc需要去学习\",{\"1\":{\"1291\":1}}],[\"还请各位小伙伴自行了解\",{\"1\":{\"1176\":1}}],[\"还请各位小伙伴自行探索了\",{\"1\":{\"453\":1}}],[\"还必须保证应用程序之间的类无法相互访问\",{\"1\":{\"1109\":1}}],[\"还原为最开始的http数据\",{\"1\":{\"1042\":1}}],[\"还会作用于他的所有子项目\",{\"1\":{\"1038\":1}}],[\"还要注意去掉列表最后一个列名的逗号\",{\"1\":{\"872\":1}}],[\"还支持很多种类型的文件\",{\"1\":{\"817\":1}}],[\"还存在preparedstatement\",{\"1\":{\"790\":1}}],[\"还能在视图的基础上\",{\"1\":{\"779\":1}}],[\"还没学异常\",{\"1\":{\"377\":1}}],[\"还体会不到注解带来的快乐\",{\"1\":{\"365\":1}}],[\"还有三个对象之间\",{\"1\":{\"1301\":1}}],[\"还有可能是经过回收策略回收得到的\",{\"1\":{\"1246\":1}}],[\"还有其他的接口\",{\"1\":{\"1231\":1}}],[\"还有其他的实现类\",{\"1\":{\"202\":1}}],[\"还有target表示执行此方法的实例对象\",{\"1\":{\"1231\":1}}],[\"还有两个参数\",{\"1\":{\"1056\":1}}],[\"还有很多可以直接使用的注解\",{\"1\":{\"1236\":1}}],[\"还有很多不同类型的结果判断\",{\"1\":{\"973\":1}}],[\"还有很多地方都可以\",{\"1\":{\"453\":1}}],[\"还有数据库的额外开销\",{\"1\":{\"871\":1}}],[\"还有\",{\"1\":{\"478\":1,\"573\":1,\"1176\":1,\"1188\":1}}],[\"还有我们前面演示的反射\",{\"1\":{\"466\":1}}],[\"还有几个同名的\",{\"1\":{\"365\":1}}],[\"还有一个postprocessbeforeinitialization用于在bean初始化之前进行处理\",{\"1\":{\"1307\":1}}],[\"还有一个是根据名字\",{\"1\":{\"1138\":1}}],[\"还有一个是bytype\",{\"1\":{\"1138\":1}}],[\"还有一个虚拟主机管理页面\",{\"1\":{\"1047\":1}}],[\"还有一个重要的属性\",{\"1\":{\"1038\":1}}],[\"还有一个就是包含了所有依赖以及配置了主类的jar文件\",{\"1\":{\"1037\":1}}],[\"还有一个比较特殊的选择操作是selectcursor\",{\"1\":{\"836\":1}}],[\"还有一个append方法\",{\"1\":{\"254\":1}}],[\"还有一张用户详细信息的表\",{\"1\":{\"769\":1}}],[\"还有一种就是\",{\"1\":{\"437\":1}}],[\"还有一种set叫做treeset\",{\"1\":{\"207\":1}}],[\"还保存指向上一个结点的引用\",{\"1\":{\"182\":1}}],[\"还可以是抛出异常之类的\",{\"1\":{\"1226\":1}}],[\"还可以是map\",{\"1\":{\"563\":1}}],[\"还可以访问属性\",{\"1\":{\"1202\":1}}],[\"还可以做一些其他的事情\",{\"1\":{\"1084\":1}}],[\"还可以进行通配符匹配\",{\"1\":{\"1061\":1}}],[\"还可以通过alter来修改此列的属性\",{\"1\":{\"751\":1}}],[\"还可以直接从optional中获取被包装的对象\",{\"1\":{\"454\":1}}],[\"还可以获取文件夹内部的文件列表等内容\",{\"1\":{\"255\":1}}],[\"还可以当做其他的数据结构使用\",{\"1\":{\"199\":1}}],[\"还可以定义一些方法来描述同一类的行为\",{\"1\":{\"162\":1}}],[\"还可以估计q\",{\"1\":{\"81\":1}}],[\"还需要回滚一下\",{\"1\":{\"1246\":1}}],[\"还需要额外导入包\",{\"1\":{\"1175\":1}}],[\"还需要一个响应体处理器\",{\"1\":{\"490\":1}}],[\"还需要判断\",{\"1\":{\"241\":1}}],[\"还需要求解最优策略π\",{\"1\":{\"55\":1}}],[\"还需要考虑所有用户的2d位置\",{\"1\":{\"14\":1}}],[\"还是熟悉的玩法\",{\"1\":{\"1232\":1}}],[\"还是以简单的study方法为例\",{\"1\":{\"1231\":1}}],[\"还是以查询所有的用户为例\",{\"1\":{\"894\":1}}],[\"还是看你自己\",{\"1\":{\"1175\":1}}],[\"还是之前的代码\",{\"1\":{\"1117\":1}}],[\"还是太过复杂\",{\"1\":{\"1101\":1}}],[\"还是字段\",{\"1\":{\"365\":1}}],[\"还是编入class文件中\",{\"1\":{\"362\":1}}],[\"还是进行计算\",{\"1\":{\"295\":1}}],[\"还是很方便的\",{\"1\":{\"200\":1}}],[\"还是\",{\"1\":{\"53\":1,\"75\":1,\"92\":1,\"437\":1}}],[\"还是同一张q\",{\"1\":{\"13\":1}}],[\"还与los的概率有关\",{\"1\":{\"13\":1}}],[\"但如果我改成这样\",{\"1\":{\"1181\":1}}],[\"但如果是\",{\"1\":{\"528\":1}}],[\"但允许执行delete操作\",{\"1\":{\"779\":1}}],[\"但允许空值\",{\"1\":{\"747\":1}}],[\"但允许写操作\",{\"1\":{\"642\":1}}],[\"但现在改成这样\",{\"1\":{\"708\":1}}],[\"但现实场景中不太经常使用\",{\"1\":{\"76\":1}}],[\"但功能灵活\",{\"1\":{\"528\":1}}],[\"但\",{\"1\":{\"525\":1}}],[\"但有的时候\",{\"1\":{\"503\":1}}],[\"但并不是简单的返回处理器\",{\"1\":{\"625\":1}}],[\"但并不是最好的方案\",{\"1\":{\"437\":1}}],[\"但并不是这个文件本身\",{\"1\":{\"255\":1}}],[\"但它必须是静态的\",{\"1\":{\"995\":1}}],[\"但它继承自一个现有的类或实现了一个接口\",{\"1\":{\"412\":1}}],[\"但它是为了并行执行而设计的\",{\"1\":{\"330\":1}}],[\"但类名必须与接口一致\",{\"1\":{\"412\":1}}],[\"但我们可以在方法中使用匿名内部类\",{\"1\":{\"412\":1}}],[\"但能匹配\",{\"1\":{\"403\":1}}],[\"但能否保证其精确度\",{\"1\":{\"101\":1}}],[\"但不能超过n\",{\"1\":{\"746\":1}}],[\"但不能匹配\",{\"1\":{\"403\":1}}],[\"但不产生任何结果\",{\"1\":{\"508\":1}}],[\"但不一定会导致致命的问题\",{\"1\":{\"421\":1}}],[\"但不推荐\",{\"1\":{\"392\":1}}],[\"但不支持\",{\"1\":{\"386\":1}}],[\"但对象中的属性都是同一个地址\",{\"1\":{\"377\":1}}],[\"但对于原型模式\",{\"1\":{\"1181\":1}}],[\"但对于\",{\"1\":{\"142\":1}}],[\"但包装类的class和基本类的class显然是不同的\",{\"1\":{\"340\":1}}],[\"但效果是一致的\",{\"1\":{\"254\":1}}],[\"但集合可以有不同种类的元素\",{\"1\":{\"179\":1}}],[\"但集合只能存放对象\",{\"1\":{\"179\":1}}],[\"但还是先初始化内部类\",{\"1\":{\"411\":1}}],[\"但还未复制\",{\"1\":{\"166\":1}}],[\"但还存在\",{\"1\":{\"156\":1}}],[\"但是万一是别名呢\",{\"1\":{\"1300\":1}}],[\"但是效率爆减\",{\"1\":{\"1271\":1}}],[\"但是出现了一个报错\",{\"1\":{\"1260\":1}}],[\"但是出队顺序是按照优先级来的\",{\"1\":{\"203\":1}}],[\"但是仅仅只能简单的切入还是不能满足一些需求\",{\"1\":{\"1223\":1}}],[\"但是仅返回类型不同\",{\"1\":{\"165\":1}}],[\"但是你如果写过kotlin\",{\"1\":{\"1211\":1}}],[\"但是太过机械\",{\"1\":{\"1140\":1}}],[\"但是有些时候为了方便\",{\"1\":{\"1137\":1}}],[\"但是有了ioc容器加持之后\",{\"1\":{\"1117\":1}}],[\"但是加载顺序我们并不清楚\",{\"1\":{\"1131\":1}}],[\"但是此时有两个bean定义都满足这个类型\",{\"1\":{\"1126\":1}}],[\"但是此时我们在创建student类时\",{\"1\":{\"1126\":1}}],[\"但是为了简单起见\",{\"1\":{\"1124\":1}}],[\"但是之前的代码并不会报错\",{\"1\":{\"1117\":1}}],[\"但是之后的版本可以\",{\"1\":{\"182\":1}}],[\"但是某一天\",{\"1\":{\"1116\":1}}],[\"但是某些数据库\",{\"1\":{\"862\":1}}],[\"但是对于tomcat容器不可见\",{\"1\":{\"1109\":1}}],[\"但是对于我们人来说\",{\"1\":{\"920\":1}}],[\"但是仍然有一个问题\",{\"1\":{\"1093\":1}}],[\"但是init和构造方法只会执行一次\",{\"1\":{\"1055\":1}}],[\"但是idea已经自带了maven环境\",{\"1\":{\"1000\":1}}],[\"但是显然直接使用注解更加方便\",{\"1\":{\"1054\":1}}],[\"但是通信的双方在交换http报文之前不需要先建立http连接\",{\"1\":{\"1042\":1}}],[\"但是http协议本身是无连接的\",{\"1\":{\"1042\":1}}],[\"但是http协议并不会保持长连接\",{\"1\":{\"727\":1}}],[\"但是在这里我们就可以快速获取到更多信息\",{\"1\":{\"1231\":1}}],[\"但是在idea中并不推荐使用\",{\"1\":{\"1175\":1}}],[\"但是在某些时候\",{\"1\":{\"1157\":1}}],[\"但是在编译代码时无效\",{\"1\":{\"1016\":1}}],[\"但是在运行时无效\",{\"1\":{\"1016\":1}}],[\"但是在使用之前\",{\"1\":{\"348\":1}}],[\"但是参数可以由我们自己决定\",{\"1\":{\"991\":1}}],[\"但是结果却是依然能够读取\",{\"1\":{\"888\":1}}],[\"但是缓存存在一个问题\",{\"1\":{\"888\":1}}],[\"但是更安全\",{\"1\":{\"884\":1}}],[\"但是会检查命名是否规范\",{\"1\":{\"1127\":1}}],[\"但是会用空格替换方法名称中的下划线\",{\"1\":{\"962\":1}}],[\"但是会删除无参数方法的尾随括号\",{\"1\":{\"962\":1}}],[\"但是会话1中的数据是从缓存得到的\",{\"1\":{\"883\":1}}],[\"但是会执行aftercompletion方法\",{\"1\":{\"599\":1}}],[\"但是依然没有去实现service方法\",{\"1\":{\"1059\":1}}],[\"但是依然没有影响会话1之中的缓存\",{\"1\":{\"883\":1}}],[\"但是依然能够正常读取\",{\"1\":{\"265\":1}}],[\"但是并没有提交\",{\"1\":{\"865\":1}}],[\"但是并不会生成setter并且成员属性都是final的\",{\"1\":{\"812\":1}}],[\"但是并不能查看完整的数据库列表\",{\"1\":{\"773\":1}}],[\"但是并不是同一个对象\",{\"1\":{\"384\":1}}],[\"但是并不是所推荐的做法\",{\"1\":{\"299\":1}}],[\"但是并不是很常用\",{\"1\":{\"202\":1}}],[\"但是一般都是用于\",{\"1\":{\"1053\":1}}],[\"但是一般情况下不需要手动设置\",{\"1\":{\"862\":1}}],[\"但是一定注意\",{\"1\":{\"883\":1}}],[\"但是一旦确定\",{\"1\":{\"438\":1}}],[\"但是其分页功能是对查询到的数据进行划分\",{\"1\":{\"835\":1}}],[\"但是转换的实体类数据并没有被添加上去\",{\"1\":{\"835\":1}}],[\"但是还是会有人警告你最好别这样做\",{\"1\":{\"910\":1}}],[\"但是还是请注意检查运行配置中的url和应用程序上下文名称是否一致\",{\"1\":{\"542\":1}}],[\"但是还不够方便\",{\"1\":{\"816\":1,\"1256\":1}}],[\"但是哪怕只是完成一个sql语句的执行\",{\"1\":{\"816\":1}}],[\"但是关键字非常多\",{\"1\":{\"804\":1}}],[\"但是他们一开始读取到的人数都是5\",{\"1\":{\"1270\":1}}],[\"但是他们目前都是在同一个小组中\",{\"1\":{\"855\":1}}],[\"但是他们之间会存在一些细微的差异\",{\"1\":{\"744\":1}}],[\"但是他们的相同和不同之处在于\",{\"1\":{\"179\":1}}],[\"但是提供技术支持\",{\"1\":{\"732\":1}}],[\"但是请注意默认的test命令有以下要求\",{\"1\":{\"1035\":1}}],[\"但是请注意\",{\"1\":{\"708\":1}}],[\"但是请一定谨慎使用\",{\"1\":{\"349\":1}}],[\"但是存在一定的局限性\",{\"1\":{\"666\":1}}],[\"但是实际上我们发现\",{\"1\":{\"1177\":1}}],[\"但是实际上我们每次执行sql语句\",{\"1\":{\"871\":1}}],[\"但是实际上这种情况完全可以简写为一个sql语句\",{\"1\":{\"876\":1}}],[\"但是实际上这里是完全可以进行类型推断的\",{\"1\":{\"487\":1}}],[\"但是实际项目中往往都是将用户信息存储在数据库中\",{\"1\":{\"661\":1}}],[\"但是表单中的输入框被隐藏了\",{\"1\":{\"641\":1}}],[\"但是没有任何的权限划分或是加密处理\",{\"1\":{\"626\":1}}],[\"但是登陆验证复杂的问题依然没有解决\",{\"1\":{\"626\":1}}],[\"但是处理完成之后\",{\"1\":{\"600\":1}}],[\"但是只要在最外层编写了默认配置\",{\"1\":{\"1152\":1}}],[\"但是只适用于jsp页面\",{\"1\":{\"558\":1}}],[\"但是只能在定义时赋值\",{\"1\":{\"392\":1}}],[\"但是不会进行回滚操作\",{\"1\":{\"1282\":1}}],[\"但是不会出现错误\",{\"1\":{\"824\":1}}],[\"但是不能和final\",{\"1\":{\"504\":1}}],[\"但是不允许别人写的类继承a\",{\"1\":{\"503\":1}}],[\"但是不支持继承\",{\"1\":{\"501\":1}}],[\"但是不再是object类型\",{\"1\":{\"172\":1}}],[\"但是当我们在java\",{\"1\":{\"500\":1}}],[\"但是当前作用域下只有对象属性的name变量\",{\"1\":{\"164\":1}}],[\"但是到底是a为null还是b为null呢\",{\"1\":{\"500\":1}}],[\"但是这些代码都是在添加一些bean定义的属性\",{\"1\":{\"1326\":1}}],[\"但是这里仅仅是禁止了事务执行过程中的update操作\",{\"1\":{\"1270\":1}}],[\"但是这里还是要简单介绍一下\",{\"1\":{\"1191\":1}}],[\"但是这里很明显是另一个网站跳转\",{\"1\":{\"641\":1}}],[\"但是这并不代表xml配置文件就是没有意义的\",{\"1\":{\"1181\":1}}],[\"但是这并不代表它们就不重要\",{\"1\":{\"782\":1}}],[\"但是这确实是两个不同的bean\",{\"1\":{\"1127\":1}}],[\"但是这实在是太过复杂了\",{\"1\":{\"902\":1}}],[\"但是这是一种极其不推荐的做法\",{\"1\":{\"877\":1}}],[\"但是这种方式并不安全\",{\"1\":{\"685\":1}}],[\"但是这个版本instanceof加强之后\",{\"1\":{\"499\":1}}],[\"但是这样的话\",{\"1\":{\"1288\":1}}],[\"但是这样的写法实在是太过臃肿了\",{\"1\":{\"445\":1}}],[\"但是这样还远远不够\",{\"1\":{\"1132\":1}}],[\"但是这样写的话\",{\"1\":{\"1125\":1}}],[\"但是这样写着就不能一气呵成了\",{\"1\":{\"454\":1}}],[\"但是这样一修改\",{\"1\":{\"1116\":1}}],[\"但是这样存在一个很严重的问题\",{\"1\":{\"1116\":1}}],[\"但是这样很明显是不正确的\",{\"1\":{\"888\":1}}],[\"但是这样可能还是不够方便\",{\"1\":{\"842\":1}}],[\"但是这样并不是使用return\",{\"1\":{\"497\":1}}],[\"但是这样实现的话\",{\"1\":{\"454\":1}}],[\"但是这样始终治标不治本\",{\"1\":{\"217\":1}}],[\"但是最后注册的是工厂方法的返回类型\",{\"1\":{\"1158\":1}}],[\"但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串\",{\"1\":{\"498\":1}}],[\"但是最终还是会变成string类型\",{\"1\":{\"485\":1}}],[\"但是java终究不像js那样进行动态推断\",{\"1\":{\"485\":1}}],[\"但是java中的基本数据类型却不是面向对象的\",{\"1\":{\"383\":1}}],[\"但是很多情况下往往都是我们使用自定义的登录界面\",{\"1\":{\"677\":1}}],[\"但是很明显我们这里给的参数是string类型的\",{\"1\":{\"480\":1}}],[\"但是很有可能导致资源不能完全释放\",{\"1\":{\"301\":1}}],[\"但是去单独进行一次null判断写起来又不太简洁\",{\"1\":{\"480\":1}}],[\"但是需要注意\",{\"1\":{\"1188\":1}}],[\"但是需要知道mybatis就是通过这种方式来读取配置文件的\",{\"1\":{\"819\":1}}],[\"但是需要引用一个完整的类库\",{\"1\":{\"460\":1}}],[\"但是需要的形式参数不一样\",{\"1\":{\"165\":1}}],[\"但是由于表名相同\",{\"1\":{\"768\":1}}],[\"但是由于我们这里a和b都调用了length\",{\"1\":{\"500\":1}}],[\"但是由于我们不清楚给进来的str到底是不是null\",{\"1\":{\"480\":1}}],[\"但是由于它们是属于同一个依赖捆绑在一起\",{\"1\":{\"460\":1}}],[\"但是由于仅仅是语法糖\",{\"1\":{\"187\":1}}],[\"但是mainobject对象并未参与进来\",{\"1\":{\"452\":1}}],[\"但是lambda却不会\",{\"1\":{\"446\":1}}],[\"但是注意这样的switch是有返回值的\",{\"1\":{\"497\":1}}],[\"但是注意语法还是和java是一样的\",{\"1\":{\"473\":1}}],[\"但是注意必须是唯一的\",{\"1\":{\"461\":1}}],[\"但是注意\",{\"1\":{\"438\":1,\"446\":1,\"475\":1,\"485\":1,\"841\":1}}],[\"但是注意两个线程必须使用同一把锁\",{\"1\":{\"312\":1}}],[\"但是编程式事务过于复杂并且具有高度耦合性\",{\"1\":{\"1274\":1}}],[\"但是编程不可见\",{\"1\":{\"392\":1}}],[\"但是编译不会报错\",{\"1\":{\"437\":1}}],[\"但是object类型在编译阶段并不具有良好的类型判断能力\",{\"1\":{\"437\":1}}],[\"但是outputstream又只支持byte类型\",{\"1\":{\"283\":1}}],[\"但是成绩分为两种\",{\"1\":{\"437\":1}}],[\"但是成绩依然可能是整数\",{\"1\":{\"172\":1}}],[\"但是要注意一下顺序\",{\"1\":{\"424\":1}}],[\"但是必须保证其他方法有默认实现\",{\"1\":{\"414\":1,\"447\":1}}],[\"但是可以直接new了\",{\"1\":{\"409\":1}}],[\"但是可以存在静态变量和静态方法\",{\"1\":{\"376\":1}}],[\"但是能匹配\",{\"1\":{\"403\":1}}],[\"但是拼接字符串实际上底层需要进行很多操作\",{\"1\":{\"402\":1}}],[\"但是biginteger没有这些限制\",{\"1\":{\"386\":1}}],[\"但是各位小伙伴只需要知道\",{\"1\":{\"384\":1}}],[\"但是它并没有实现任何的事务操作\",{\"1\":{\"1273\":1}}],[\"但是它并没有禁止insert这类操作\",{\"1\":{\"1270\":1}}],[\"但是它还是存在以下问题\",{\"1\":{\"1269\":1}}],[\"但是它真的只是一个简简单单的student类型对象吗\",{\"1\":{\"1189\":1}}],[\"但是它不是从远程仓库获取\",{\"1\":{\"1018\":1}}],[\"但是它是第三个\",{\"1\":{\"987\":1}}],[\"但是它是在方法执行之后再进行拦截\",{\"1\":{\"697\":1}}],[\"但是它的作用范围实在是有限\",{\"1\":{\"883\":1}}],[\"但是它要求的是请求头中需要携带什么内容\",{\"1\":{\"576\":1}}],[\"但是它却和comparator需要实现的方法返回值和参数定义一模一样\",{\"1\":{\"449\":1}}],[\"但是它继承自enum类\",{\"1\":{\"378\":1}}],[\"但是它存在自动刷新机制\",{\"1\":{\"284\":1}}],[\"但是推荐打上\",{\"1\":{\"378\":1}}],[\"但是像这样的拷贝操作其实也分为浅拷贝和深拷贝\",{\"1\":{\"377\":1}}],[\"但是类加载器并不是只有一个\",{\"1\":{\"355\":1}}],[\"但是获取到的type的实现并不一定是class\",{\"1\":{\"343\":1}}],[\"但是前者是唤醒所有调用wait\",{\"1\":{\"318\":1}}],[\"但是又被对方牢牢把握\",{\"1\":{\"313\":1}}],[\"但是又迟迟不释放\",{\"1\":{\"313\":1}}],[\"但是class类实例同样的类无论怎么获取都是同一个\",{\"1\":{\"312\":1}}],[\"但是如果事件b修改并提交了数据\",{\"1\":{\"1269\":1}}],[\"但是如果属性太多的话\",{\"1\":{\"1149\":1}}],[\"但是如果别人的项目中没有将我们不希望的依赖作为可选依赖\",{\"1\":{\"1026\":1}}],[\"但是如果我把这些任务合在一起告诉数据库\",{\"1\":{\"871\":1}}],[\"但是如果我们每次上菜推一个小推车装满n个菜一起上\",{\"1\":{\"871\":1}}],[\"但是如果我们使用构造方法主动创建两个新的对象\",{\"1\":{\"401\":1}}],[\"但是如果我们在运行时\",{\"1\":{\"399\":1}}],[\"但是如果存在多个构造方法\",{\"1\":{\"841\":1}}],[\"但是如果使用$\",{\"1\":{\"831\":1}}],[\"但是如果希望向指定列上插入数据\",{\"1\":{\"754\":1}}],[\"但是如果此时我们主动将b设定为non\",{\"1\":{\"504\":1}}],[\"但是如果是null\",{\"1\":{\"480\":1}}],[\"但是如果是引用类型的话\",{\"1\":{\"395\":1}}],[\"但是如果超出这个缓存范围的话\",{\"1\":{\"384\":1}}],[\"但是如果同时写入内容\",{\"1\":{\"311\":1}}],[\"但是如果多个处理器的运算任务都涉及同一块内存区域\",{\"1\":{\"311\":1}}],[\"但是如果队列为空\",{\"1\":{\"200\":2}}],[\"但是如果队列已经为空\",{\"1\":{\"200\":2}}],[\"但是run是直接在当前线程执行\",{\"1\":{\"298\":1}}],[\"但是\",{\"1\":{\"295\":1,\"313\":1,\"393\":1,\"642\":1,\"739\":1,\"1086\":1,\"1181\":1,\"1301\":1}}],[\"但是name属性并没有保存\",{\"1\":{\"290\":1}}],[\"但是我个人认为这种说法是错的\",{\"1\":{\"376\":1}}],[\"但是我只能往一个outputstream里输出\",{\"1\":{\"283\":1}}],[\"但是我们有了spring框架之后\",{\"1\":{\"1187\":1}}],[\"但是我们其实希望programteacher这个bean在任何情况下都不参与到自动装配中\",{\"1\":{\"1140\":1}}],[\"但是我们得先为这个容器编写一个配置文件\",{\"1\":{\"1119\":1}}],[\"但是我们需要一个一个去进行配置\",{\"1\":{\"1101\":1}}],[\"但是我们项目中并不一定会使用这些日志框架作为mybatis的日志打印器\",{\"1\":{\"1025\":1}}],[\"但是我们希望缓存能够扩展到所有会话都能使用\",{\"1\":{\"883\":1}}],[\"但是我们希望能够按字符的方式读取\",{\"1\":{\"283\":1}}],[\"但是我们不能过度使用索引\",{\"1\":{\"780\":1}}],[\"但是我们不能滥用\",{\"1\":{\"350\":1}}],[\"但是我们服务端却收到了不少的信息\",{\"1\":{\"727\":1}}],[\"但是我们随便访问一个其他的页面\",{\"1\":{\"692\":1}}],[\"但是我们之前讲解的过滤器是作用于servlet之前\",{\"1\":{\"593\":1}}],[\"但是我们的程序依然可以正常运行\",{\"1\":{\"1188\":1}}],[\"但是我们的程序并没有停止\",{\"1\":{\"324\":1}}],[\"但是我们的main类中压根没有这个方法\",{\"1\":{\"446\":1}}],[\"但是我们也可以将接口实现类的对象以接口的形式去使用\",{\"1\":{\"376\":1}}],[\"但是我们明明在自己写的string类中定义了main方法\",{\"1\":{\"355\":1}}],[\"但是我们限定下界的话\",{\"1\":{\"172\":1}}],[\"但是我们发现xml配置文件读取实在是太麻烦\",{\"1\":{\"936\":1}}],[\"但是我们发现\",{\"1\":{\"166\":1,\"449\":1,\"462\":1,\"540\":1,\"681\":1,\"897\":1,\"1083\":1,\"1109\":1,\"1132\":1,\"1165\":1}}],[\"但是我们前面说了\",{\"1\":{\"161\":1}}],[\"但是同样需要有访问权限的情况下才可以\",{\"1\":{\"278\":1}}],[\"但是现在没有任何的日志实现\",{\"1\":{\"1260\":1}}],[\"但是现在它没有了\",{\"1\":{\"1175\":1}}],[\"但是现在我们可以使用密封类型sealed\",{\"1\":{\"503\":1}}],[\"但是现在我们可以使用新的特性了\",{\"1\":{\"496\":1}}],[\"但是现在我们有一个需求\",{\"1\":{\"503\":1}}],[\"但是现在我们想要一个abcdabcd这样的基于原本字符串的重复字符串\",{\"1\":{\"488\":1}}],[\"但是现在我们希望依赖可以传递\",{\"1\":{\"465\":1}}],[\"但是现在支持以reader的方式进行读取\",{\"1\":{\"283\":1}}],[\"但是现在支持以writer的方式进行写入\",{\"1\":{\"283\":1}}],[\"但是现在\",{\"1\":{\"277\":1}}],[\"但是静态方法是可以访问到静态变量的\",{\"1\":{\"274\":1}}],[\"但是进行了一些额外的处理然后再调用fileinputstream的同名方法\",{\"1\":{\"264\":1}}],[\"但是每次都需要从外部i\",{\"1\":{\"260\":1}}],[\"但是学习\",{\"1\":{\"207\":1}}],[\"但是是那个意思\",{\"1\":{\"1117\":1}}],[\"但是是可以正常运行的\",{\"1\":{\"902\":1}}],[\"但是是固定长度为n\",{\"1\":{\"746\":1}}],[\"但是是多个filter的集合\",{\"1\":{\"705\":2}}],[\"但是是next方法是从后往前进行遍历的\",{\"1\":{\"201\":1}}],[\"但是是并行执行的\",{\"1\":{\"180\":1}}],[\"但是插入失败不会抛出异常\",{\"1\":{\"200\":1}}],[\"但是都是按照迭代器的标准进行了实现\",{\"1\":{\"190\":1}}],[\"但是规则跟变量的命名差不多\",{\"1\":{\"162\":1}}],[\"但在发表\",{\"1\":{\"144\":1}}],[\"但这里还有一个难点\",{\"1\":{\"136\":1}}],[\"但实际上还是遍历了20个\",{\"1\":{\"479\":1}}],[\"但实际上还是在调用本身的方法\",{\"1\":{\"373\":1}}],[\"但实际上我们往往是选择一个非常小的常数\",{\"1\":{\"98\":1}}],[\"但实际情况可能并不是所有状态的概率都是一致的\",{\"1\":{\"134\":1}}],[\"但需要大量的\",{\"1\":{\"101\":1}}],[\"但由于\",{\"1\":{\"101\":1}}],[\"但目前无法保证\",{\"1\":{\"84\":1}}],[\"但存在一定的浪费\",{\"1\":{\"81\":1}}],[\"但若考虑集群情况\",{\"1\":{\"14\":1}}],[\"但每个无人机所管理的用户不同\",{\"1\":{\"13\":1}}],[\"但即使仅考虑用户聚类\",{\"1\":{\"13\":1}}],[\"否则正常返回\",{\"1\":{\"1246\":1}}],[\"否则就是在执行过程中出现了什么错误\",{\"1\":{\"1034\":1}}],[\"否则无法创建定时任务\",{\"1\":{\"1190\":1}}],[\"否则无法下载\",{\"1\":{\"1009\":1}}],[\"否则无法访问\",{\"1\":{\"574\":3}}],[\"否则必须保证形参列表与这边接口一致\",{\"1\":{\"902\":1}}],[\"否则可能会出现问题\",{\"1\":{\"842\":1}}],[\"否则可能无法生效\",{\"1\":{\"642\":1}}],[\"否则登录界面都没法正常展示\",{\"1\":{\"681\":1}}],[\"否则未登录的用户连登录界面都进不去\",{\"1\":{\"680\":1}}],[\"否则一律进行拦截操作\",{\"1\":{\"660\":1}}],[\"否则一律报错\",{\"1\":{\"172\":1}}],[\"否则仍然存在安全隐患\",{\"1\":{\"642\":1}}],[\"否则直接结束\",{\"1\":{\"595\":1}}],[\"否则注解模式跑不起来\",{\"1\":{\"553\":1}}],[\"否则返回默认值\",{\"1\":{\"512\":1}}],[\"否则返回false\",{\"1\":{\"180\":2,\"403\":1}}],[\"否则鬼知道你要用什么类型\",{\"1\":{\"485\":1}}],[\"否则报错\",{\"1\":{\"424\":1,\"1127\":1}}],[\"否则我们必须要使用\",{\"1\":{\"424\":1}}],[\"否则会无法初始化\",{\"1\":{\"1257\":1}}],[\"否则会无法通过编译\",{\"1\":{\"375\":1}}],[\"否则会报错\",{\"1\":{\"1204\":1}}],[\"否则会出现错误\",{\"1\":{\"1149\":1}}],[\"否则会显示黄标\",{\"1\":{\"1127\":1}}],[\"否则会直接忽略\",{\"1\":{\"976\":1}}],[\"否则会导致mybatis无法确认\",{\"1\":{\"841\":1}}],[\"否则会被拦截\",{\"1\":{\"660\":1}}],[\"否则会屏蔽自动配置\",{\"1\":{\"553\":1}}],[\"否则会抛出异常\",{\"1\":{\"318\":1}}],[\"否则资源会被一直占用\",{\"1\":{\"247\":1}}],[\"否则给你当成\",{\"1\":{\"241\":1}}],[\"否则太过死板\",{\"1\":{\"215\":1}}],[\"否则抛出\",{\"1\":{\"182\":1}}],[\"否则false\",{\"1\":{\"180\":3}}],[\"否则要创建这个类的对象\",{\"1\":{\"166\":1}}],[\"否则\",{\"1\":{\"13\":1,\"364\":1,\"461\":1}}],[\"奖励\",{\"1\":{\"13\":1,\"19\":1}}],[\"并注册到容器中\",{\"1\":{\"1327\":1}}],[\"并设定bean的名称\",{\"1\":{\"1296\":1}}],[\"并发相关类\",{\"1\":{\"1245\":1}}],[\"并发会用到\",{\"1\":{\"264\":1}}],[\"并创建一个被增强的对象\",{\"1\":{\"1226\":1}}],[\"并创建一个新的用户\",{\"1\":{\"692\":1}}],[\"并组成一个新的集合\",{\"1\":{\"1209\":2}}],[\"并完成注入\",{\"1\":{\"1197\":1}}],[\"并完成用户登录操作\",{\"1\":{\"672\":1}}],[\"并使用ref属性将其指向我们刚刚注册的aop类bean\",{\"1\":{\"1220\":1}}],[\"并使用它来创建线程执行任务\",{\"1\":{\"1188\":1}}],[\"并使用association标签的select属性来指定关联查询操作\",{\"1\":{\"851\":1}}],[\"并调用init\",{\"1\":{\"1148\":1}}],[\"并由它来决定给我们哪一个对象\",{\"1\":{\"1119\":1}}],[\"并由其他servlet来返回结果\",{\"1\":{\"1083\":1}}],[\"并交给ioc容器管理\",{\"1\":{\"1117\":1}}],[\"并交由tomcat进行管理\",{\"1\":{\"1047\":1}}],[\"并添加\",{\"1\":{\"1102\":1,\"1190\":1}}],[\"并添加注解\",{\"1\":{\"1054\":1}}],[\"并放入桌面\",{\"1\":{\"1047\":1}}],[\"并继续向下一层进行传递\",{\"1\":{\"1042\":1}}],[\"并支持自定义种子的配置\",{\"1\":{\"987\":1}}],[\"并通过实例化对象来调用其中的测试方法\",{\"1\":{\"986\":1}}],[\"并最终以失败状态结束\",{\"1\":{\"969\":1}}],[\"并填写以下内容\",{\"1\":{\"824\":1,\"826\":1}}],[\"并得到结果集\",{\"1\":{\"788\":1}}],[\"并封装为userdetails对象返回\",{\"1\":{\"668\":1}}],[\"并返回403错误\",{\"1\":{\"660\":1}}],[\"并返回一个新的子串对象\",{\"1\":{\"401\":1}}],[\"并诱使用户在该会话中进行操作\",{\"1\":{\"642\":1}}],[\"并传入方法作为实参\",{\"1\":{\"625\":1}}],[\"并直接被注册为对应的mapper作为bean管理\",{\"1\":{\"1257\":1}}],[\"并直接将根容器作为父容器\",{\"1\":{\"625\":1}}],[\"并直接创建实例对象\",{\"1\":{\"412\":1}}],[\"并进行配置\",{\"1\":{\"625\":1}}],[\"并向输出流中传输数据即可\",{\"1\":{\"620\":1}}],[\"并解析我们的html页面\",{\"1\":{\"560\":1}}],[\"并具有和实体类一致的属性\",{\"1\":{\"525\":1}}],[\"并根据后端响应的结果\",{\"1\":{\"1076\":1}}],[\"并根据反馈进行调整\",{\"1\":{\"494\":1}}],[\"并根据实际需求扩展出新的行为\",{\"1\":{\"369\":1}}],[\"并转换为stream进行操作\",{\"1\":{\"488\":2}}],[\"并在断掉的位置添加了一个额外的操作\",{\"1\":{\"1215\":1}}],[\"并在请求中完成动态更新\",{\"1\":{\"1076\":1}}],[\"并在当前位置打开cmd窗口\",{\"1\":{\"1047\":1}}],[\"并在方法内编写我们的需要进行测试的代码\",{\"1\":{\"959\":1}}],[\"并在方法体内定义具体的操作\",{\"1\":{\"510\":1}}],[\"并在数据库中添加用于存放数据的表\",{\"1\":{\"734\":1}}],[\"并在形式参数前面添加\",{\"1\":{\"579\":1}}],[\"并在src目录下\",{\"1\":{\"461\":1}}],[\"并在控制台打印栈追踪信息\",{\"1\":{\"424\":1}}],[\"并没有什么很难理解的地方\",{\"1\":{\"1300\":1}}],[\"并没有额外的管理机制\",{\"1\":{\"1273\":1}}],[\"并没有创建新的对象\",{\"1\":{\"1246\":1}}],[\"并没有再次请求新的url\",{\"1\":{\"1083\":1}}],[\"并没有进行依赖传递\",{\"1\":{\"465\":1}}],[\"并没有初始化内部类\",{\"1\":{\"411\":1}}],[\"并没有考虑到多线程运行的情况\",{\"1\":{\"330\":1}}],[\"并提供对外访问的接口\",{\"1\":{\"369\":1}}],[\"并行流\",{\"1\":{\"330\":2}}],[\"并打印出了相关线程的栈追踪信息\",{\"1\":{\"313\":1}}],[\"并将所有的连接全部交给数据源进行集中管理\",{\"1\":{\"1242\":1}}],[\"并将此方法添加到一个切点中\",{\"1\":{\"1233\":1}}],[\"并将要执行的操作写成一个方法\",{\"1\":{\"1218\":1}}],[\"并将我们刚才下载的文件又上传给服务端\",{\"1\":{\"1075\":1}}],[\"并将结果响应给用户\",{\"1\":{\"1055\":1}}],[\"并将其封装到pooledconnection中\",{\"1\":{\"1246\":1}}],[\"并将其绑定到一个接口上\",{\"1\":{\"893\":1}}],[\"并将其分配给用户\",{\"1\":{\"642\":1}}],[\"并将其保留到运行时\",{\"1\":{\"363\":1}}],[\"并将配置的任务交给他们来完成\",{\"1\":{\"550\":1}}],[\"并将字符串转换为字符\",{\"1\":{\"284\":1}}],[\"并将下一个元素作为待遍历元素\",{\"1\":{\"189\":1}}],[\"并将元素替换为处理之后的结果\",{\"1\":{\"181\":1}}],[\"并不推荐\",{\"1\":{\"1271\":1}}],[\"并不编写方法的主体\",{\"1\":{\"375\":1}}],[\"并不一定真实的数据量就是这么多\",{\"1\":{\"248\":1}}],[\"并不会以事务的方式执行\",{\"1\":{\"1282\":1}}],[\"并不会被保存\",{\"1\":{\"1129\":1}}],[\"并不会立即执行\",{\"1\":{\"514\":1}}],[\"并不会去释放任何锁资源\",{\"1\":{\"313\":1}}],[\"并不会在一开始就去加载它\",{\"1\":{\"275\":1}}],[\"并不会真的进行类型检查\",{\"1\":{\"237\":1}}],[\"并不会真的去检查对应类型\",{\"1\":{\"173\":1}}],[\"并不会维持插入的顺序\",{\"1\":{\"218\":1}}],[\"并不是它本身就实现了这些功能\",{\"1\":{\"1316\":1}}],[\"并不是数据库中的内容\",{\"1\":{\"1267\":1}}],[\"并不是通过之前drivermanager的方法去获取连接了\",{\"1\":{\"1242\":1}}],[\"并不是为了一定要去使用它\",{\"1\":{\"816\":1}}],[\"并不是真实存在的\",{\"1\":{\"779\":1}}],[\"并不是说只有抽象类和接口才可以像这样创建匿名内部类\",{\"1\":{\"412\":1}}],[\"并不是说一定优先级越高的线程越先执行\",{\"1\":{\"302\":1}}],[\"并不是基本数据类型\",{\"1\":{\"392\":1}}],[\"并不是包装类型\",{\"1\":{\"340\":1}}],[\"并不是所有的类都会在一开始加载\",{\"1\":{\"337\":1}}],[\"并不是我们实际list中的顺序\",{\"1\":{\"330\":1}}],[\"并不是将另一个线程和当前线程合并\",{\"1\":{\"305\":1}}],[\"并不是创建一个线程执行\",{\"1\":{\"298\":1}}],[\"并不是写入的字符串\",{\"1\":{\"286\":1}}],[\"并不是\",{\"1\":{\"212\":1}}],[\"并不是在构造方法之后\",{\"1\":{\"166\":1}}],[\"并不是一直进行更新\",{\"1\":{\"142\":1}}],[\"并非是某种特殊的计算机网络\",{\"1\":{\"1042\":1}}],[\"并非是所对应的对象本身\",{\"1\":{\"161\":1}}],[\"并非java定义\",{\"1\":{\"340\":1}}],[\"并非只是一个单一的轨迹\",{\"1\":{\"19\":1}}],[\"并且还添加了新的动作postprocessbeandefinitionregistry\",{\"1\":{\"1311\":1}}],[\"并且还要考虑如何合理地存放大量的链接对象\",{\"1\":{\"1245\":1}}],[\"并且已经认定为处于循环状态\",{\"1\":{\"1301\":1}}],[\"并且已经成功分配到连接对象的情况下\",{\"1\":{\"1246\":1}}],[\"并且直接在测试方法中使用注入的bean\",{\"1\":{\"1291\":1}}],[\"并且同时在操作同一个数据\",{\"1\":{\"1267\":1}}],[\"并且同样支持try\",{\"1\":{\"249\":1}}],[\"并且速度非常的快\",{\"1\":{\"1260\":1}}],[\"并且将类型指定为对应的event事件\",{\"1\":{\"1191\":1}}],[\"并且这种方式并不是那么的灵活\",{\"1\":{\"1177\":1}}],[\"并且这些配置文件是可以相互导入的\",{\"1\":{\"1124\":1}}],[\"并且会继续庞大下去\",{\"1\":{\"1165\":1}}],[\"并且添加factory\",{\"1\":{\"1158\":1}}],[\"并且我们可以直接获取更多的参数\",{\"1\":{\"1224\":1}}],[\"并且我们可以充分使用多种http请求方式\",{\"1\":{\"589\":1}}],[\"并且我们不需要再去调整其他位置的代码\",{\"1\":{\"1133\":1}}],[\"并且所有的请求都没有任何的响应内容\",{\"1\":{\"1102\":1}}],[\"并且所有的请求都会经过它进行解析\",{\"1\":{\"540\":1}}],[\"并且过滤器可以添加很多个\",{\"1\":{\"1101\":1}}],[\"并且请求的信息全部被转交给另一个servlet\",{\"1\":{\"1083\":1}}],[\"并且请求转发只能转发到此应用程序内部的servlet\",{\"1\":{\"1083\":1}}],[\"并且响应头中添加了一个location属性\",{\"1\":{\"1082\":1}}],[\"并且携带了表单中文本框的数据\",{\"1\":{\"1069\":1}}],[\"并且数字的大小决定了此servlet的启动优先级\",{\"1\":{\"1064\":1}}],[\"并且它的生态已经发展得极为庞大\",{\"1\":{\"1113\":1}}],[\"并且它已经帮助我们提前实现了一些操作\",{\"1\":{\"1059\":1}}],[\"并且它是web容器的父容器\",{\"1\":{\"625\":1}}],[\"并且在下次请求时\",{\"1\":{\"1090\":1}}],[\"并且在连接已经建立的过程中\",{\"1\":{\"1042\":1}}],[\"并且在mybatis每个操作都配置flushcache为true来保证刷新\",{\"1\":{\"888\":1}}],[\"并且每个参数都会进行一次测试\",{\"1\":{\"991\":1}}],[\"并且每个学生的所有属性都依赖于学号\",{\"1\":{\"737\":1}}],[\"并且当每一次执行都没有出现问题时\",{\"1\":{\"990\":1}}],[\"并且\",{\"1\":{\"986\":1,\"1179\":1}}],[\"并且都开启了缓存\",{\"1\":{\"888\":1}}],[\"并且sid并没有发生改变\",{\"1\":{\"888\":1}}],[\"并且使用\",{\"1\":{\"805\":1}}],[\"并且使用processrequest来进行处理\",{\"1\":{\"626\":1}}],[\"并且内层查询的from子句中涉及的表也是导出该视图的基本表\",{\"1\":{\"779\":1}}],[\"并且不同的事务之间相互隔离\",{\"1\":{\"1266\":1}}],[\"并且不能为空\",{\"1\":{\"747\":1}}],[\"并且不阻塞用户界面或其他操作\",{\"1\":{\"617\":1}}],[\"并且需要使用\",{\"1\":{\"744\":1}}],[\"并且需要添加\",{\"1\":{\"698\":1}}],[\"并且调用了它的初始化方法\",{\"1\":{\"706\":1}}],[\"并且具有解散和升级群的资格\",{\"1\":{\"691\":1}}],[\"并且此cookie默认会被保留14天\",{\"1\":{\"686\":1}}],[\"并且此方法只能被接口中的其他私有方法或是默认实现调用\",{\"1\":{\"474\":1}}],[\"并且为了防止我们之前提到的会话固定问题\",{\"1\":{\"658\":1}}],[\"并且允许页面进行实时更新\",{\"1\":{\"617\":1}}],[\"并且是有序的\",{\"1\":{\"612\":1}}],[\"并且现在已经强势推出fastjson\",{\"1\":{\"611\":1}}],[\"并且与前端的兼容性极好\",{\"1\":{\"610\":1}}],[\"并且与状态\",{\"1\":{\"48\":1}}],[\"并且后端只需要传输关键数据即可\",{\"1\":{\"609\":1}}],[\"并且password必须为123\",{\"1\":{\"574\":1}}],[\"并且可以支持事务\",{\"1\":{\"1277\":1}}],[\"并且可以通过注入的方式快速地使用它们\",{\"1\":{\"1241\":1}}],[\"并且可以通过idea为我们提供的内置web客户端直接访问某个路径\",{\"1\":{\"570\":1}}],[\"并且可以进行注入\",{\"1\":{\"1149\":1}}],[\"并且可以反复使用\",{\"1\":{\"782\":1}}],[\"并且可以为他们设定解析顺序\",{\"1\":{\"560\":1}}],[\"并且可以在管道的节点上进行处理\",{\"1\":{\"228\":1}}],[\"并且返回值是构建器本身\",{\"1\":{\"525\":1}}],[\"并且tostring也是被重写了的\",{\"1\":{\"501\":1}}],[\"并且var关键字仅适用于局部变量\",{\"1\":{\"485\":1}}],[\"并且无需花括号\",{\"1\":{\"447\":1}}],[\"并且接口没有继承数量限制\",{\"1\":{\"376\":1}}],[\"并且默认在类中实现的权限是\",{\"1\":{\"376\":1}}],[\"并且也导入了我们自己定义的string类\",{\"1\":{\"277\":1}}],[\"并且方法名称与类名相同\",{\"1\":{\"166\":2}}],[\"并且如果按照这样一个策略\",{\"1\":{\"86\":1}}],[\"并获得奖励rt​的这一过程可以用条件转移概率p\",{\"1\":{\"13\":1}}],[\"并与传统的基于遗传的学习算法进行对比\",{\"1\":{\"5\":1}}],[\"左转\",{\"1\":{\"13\":1}}],[\"共同完成一个操作\",{\"1\":{\"1116\":1}}],[\"共有三种方法\",{\"1\":{\"339\":1}}],[\"共两步\",{\"1\":{\"132\":1}}],[\"共分为\",{\"1\":{\"63\":1}}],[\"共考虑7个方向\",{\"1\":{\"13\":1}}],[\"共划分5个等级\",{\"1\":{\"10\":1}}],[\"个类型的实参\",{\"1\":{\"398\":1}}],[\"个样本\",{\"1\":{\"142\":1}}],[\"个人目前感觉\",{\"1\":{\"534\":1}}],[\"个人推导\",{\"1\":{\"44\":1}}],[\"个人感觉是这个\",{\"1\":{\"13\":1}}],[\"个人理解\",{\"1\":{\"13\":1,\"19\":1,\"1267\":1}}],[\"个\",{\"1\":{\"13\":1}}],[\"×\",{\"1\":{\"13\":2}}],[\"00\",{\"1\":{\"1278\":1}}],[\"0中\",{\"1\":{\"1260\":1}}],[\"0来说\",{\"1\":{\"1253\":1}}],[\"06\",{\"1\":{\"1181\":1}}],[\"0表示遵循netscape的cookie规范\",{\"1\":{\"1092\":1}}],[\"09\",{\"1\":{\"1091\":1,\"1096\":1,\"1278\":1}}],[\"07\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"0协议\",{\"1\":{\"1042\":1}}],[\"0<\",{\"1\":{\"1002\":1,\"1018\":1,\"1023\":1,\"1032\":1,\"1037\":1,\"1290\":1}}],[\"0<c1​≤▽w​g\",{\"1\":{\"98\":1}}],[\"08\",{\"1\":{\"852\":1}}],[\"08001\",{\"1\":{\"789\":2}}],[\"0版本以上\",{\"1\":{\"788\":1}}],[\"03\",{\"1\":{\"763\":1,\"852\":2}}],[\"036\",{\"1\":{\"746\":2}}],[\"0开始\",{\"1\":{\"660\":1}}],[\"0xa6\",{\"1\":{\"385\":1}}],[\"0\",{\"1\":{\"13\":17,\"14\":1,\"19\":1,\"47\":1,\"87\":1,\"104\":1,\"166\":1,\"171\":5,\"180\":1,\"182\":7,\"193\":1,\"205\":1,\"206\":1,\"216\":2,\"217\":4,\"221\":1,\"223\":6,\"228\":4,\"249\":1,\"251\":1,\"296\":1,\"299\":1,\"304\":3,\"305\":2,\"311\":3,\"312\":14,\"318\":2,\"329\":2,\"330\":2,\"356\":1,\"394\":1,\"396\":1,\"398\":1,\"401\":1,\"403\":5,\"423\":1,\"431\":1,\"432\":1,\"437\":1,\"449\":3,\"451\":2,\"452\":1,\"478\":3,\"479\":2,\"480\":1,\"490\":6,\"495\":2,\"512\":1,\"521\":3,\"545\":3,\"547\":1,\"549\":1,\"552\":1,\"610\":1,\"611\":1,\"616\":1,\"663\":3,\"708\":1,\"726\":1,\"727\":7,\"748\":1,\"799\":2,\"817\":2,\"819\":2,\"824\":2,\"826\":2,\"928\":1,\"946\":1,\"973\":1,\"980\":1,\"990\":1,\"1002\":11,\"1017\":3,\"1023\":10,\"1032\":9,\"1033\":1,\"1059\":1,\"1071\":3,\"1091\":9,\"1096\":9,\"1113\":1,\"1118\":1,\"1119\":3,\"1124\":1,\"1136\":2,\"1167\":1,\"1181\":2,\"1208\":1,\"1211\":1,\"1217\":2,\"1223\":1,\"1224\":1,\"1242\":2,\"1246\":3,\"1253\":3,\"1255\":2,\"1260\":1,\"1290\":1}}],[\"0≤t≤ts​\",{\"1\":{\"8\":2,\"11\":2}}],[\"状态s时可以得到的平均reward\",{\"1\":{\"153\":1}}],[\"状态转换\",{\"1\":{\"19\":1}}],[\"状态转换模型\",{\"1\":{\"13\":1}}],[\"状态除了要考虑无人机的3d位置外\",{\"1\":{\"14\":1}}],[\"状态空间\",{\"1\":{\"13\":1,\"19\":1}}],[\"状态\",{\"1\":{\"13\":1,\"19\":1,\"135\":1,\"142\":1,\"300\":1,\"378\":1}}],[\"智能体\",{\"1\":{\"13\":1}}],[\"来模拟一下a和b循环依赖的情况\",{\"1\":{\"1301\":1}}],[\"来模拟一个餐厅的2个厨师和3个顾客\",{\"1\":{\"331\":1}}],[\"来指明对应的bean和切入点\",{\"1\":{\"1231\":1}}],[\"来指定具体的在新的线程中要执行的任务\",{\"1\":{\"445\":1}}],[\"来代表任意一个参数\",{\"1\":{\"1219\":1}}],[\"来取出value\",{\"1\":{\"1207\":1}}],[\"来解循环\",{\"1\":{\"1181\":1}}],[\"来解析生成最终页面\",{\"1\":{\"558\":1}}],[\"来告诉spring\",{\"1\":{\"1177\":1}}],[\"来加载类\",{\"1\":{\"1109\":1}}],[\"来加载驱动类\",{\"1\":{\"788\":1}}],[\"来判断是否登录\",{\"1\":{\"1096\":1}}],[\"来开启启动时加载\",{\"1\":{\"1064\":1}}],[\"来让我们处理用户的请求\",{\"1\":{\"1055\":1}}],[\"来让我们更优雅的处理空指针异常\",{\"1\":{\"454\":1}}],[\"来测试一下是否能直接访问\",{\"1\":{\"1054\":1}}],[\"来运行我们编写的\",{\"1\":{\"1053\":1}}],[\"来更加合理地对项目中代码进行职责划分\",{\"1\":{\"1032\":1}}],[\"来更新参数值\",{\"1\":{\"142\":1}}],[\"来做到全方面的问题排查\",{\"1\":{\"991\":1}}],[\"来做事\",{\"1\":{\"224\":1}}],[\"来确保之前的功能没有因为后续的修改而出现问题\",{\"1\":{\"956\":1}}],[\"来继承formatter\",{\"1\":{\"944\":1}}],[\"来一次性提交之前是所有批处理操作\",{\"1\":{\"871\":1}}],[\"来强制提交\",{\"1\":{\"865\":1}}],[\"来有效地防止sql注入问题\",{\"1\":{\"831\":1}}],[\"来填入我们给定的属性\",{\"1\":{\"831\":1}}],[\"来手动回滚之前的全部操作\",{\"1\":{\"806\":1}}],[\"来提交事务的话\",{\"1\":{\"806\":1}}],[\"来提升当前策略\",{\"1\":{\"66\":1}}],[\"来将我们输入的内容进行包裹\",{\"1\":{\"805\":1}}],[\"来获取到此对象\",{\"1\":{\"1084\":1}}],[\"来获取所有的系统属性\",{\"1\":{\"978\":1}}],[\"来获取每一列的数据\",{\"1\":{\"797\":1}}],[\"来获取\",{\"1\":{\"791\":1}}],[\"来获取类的信息和操作类\",{\"1\":{\"338\":1}}],[\"来执行任意的sql语句\",{\"1\":{\"791\":1}}],[\"来执行相同请求地址的不同类型操作\",{\"1\":{\"589\":1}}],[\"来分析我们设定的驱动是否可以连接\",{\"1\":{\"789\":1}}],[\"来限制用户登录的登录ip地址\",{\"1\":{\"772\":1}}],[\"来编写注释内容\",{\"1\":{\"744\":1}}],[\"来编写一个钓鱼网站\",{\"1\":{\"641\":1}}],[\"来连接我们本地端口的服务器\",{\"1\":{\"727\":1}}],[\"来应对各种任意变化的情况\",{\"1\":{\"667\":1}}],[\"来看看dispatcherservlet中是如何实现的\",{\"1\":{\"626\":1}}],[\"来看一下\",{\"1\":{\"522\":1}}],[\"来向前端页面传输后端提供的数据\",{\"1\":{\"610\":1}}],[\"来规定拦截器的顺序\",{\"1\":{\"601\":1}}],[\"来启动\",{\"1\":{\"553\":1}}],[\"来替换\",{\"1\":{\"545\":1}}],[\"来初始化你的实例对象\",{\"1\":{\"525\":1}}],[\"来辅助设计\",{\"1\":{\"525\":1}}],[\"来并行执行操作\",{\"1\":{\"513\":1}}],[\"来返回如果匹配此case语句的结果\",{\"1\":{\"497\":1}}],[\"来迭代生成数据\",{\"0\":{\"478\":1}}],[\"来自浏览器的所有访问请求都会首先经过过滤器\",{\"1\":{\"1101\":1}}],[\"来自同一个浏览器的所有请求\",{\"1\":{\"1094\":1}}],[\"来自jdk和jre的模块\",{\"1\":{\"463\":1}}],[\"来自定义排序规则\",{\"1\":{\"171\":1}}],[\"来个数组\",{\"1\":{\"449\":1}}],[\"来作为结果\",{\"1\":{\"437\":1}}],[\"来处理来自浏览器的各种请求\",{\"1\":{\"540\":1}}],[\"来处理\",{\"1\":{\"424\":1,\"1116\":1}}],[\"来快速创建list集合\",{\"1\":{\"1208\":1}}],[\"来快速创建不解析区域\",{\"1\":{\"818\":1}}],[\"来快速添加注释文本\",{\"1\":{\"817\":1}}],[\"来快速获取我们标记的注解\",{\"1\":{\"365\":1}}],[\"来快速编写代码\",{\"1\":{\"228\":1}}],[\"来调用已经获取到的方法\",{\"1\":{\"349\":1}}],[\"来创建连接\",{\"1\":{\"1242\":1}}],[\"来创建一个子项目\",{\"1\":{\"1032\":1}}],[\"来创建虚拟队列\",{\"1\":{\"708\":1}}],[\"来创建对象实例\",{\"1\":{\"348\":1}}],[\"来创建工作内存中的变量\",{\"1\":{\"319\":1}}],[\"来实例化对象\",{\"1\":{\"348\":1}}],[\"来实现对事务的管理\",{\"1\":{\"1272\":1}}],[\"来实现具体对应方法的请求\",{\"1\":{\"1059\":1}}],[\"来实现这个功能\",{\"1\":{\"503\":1}}],[\"来实现类的能力复用\",{\"1\":{\"503\":1}}],[\"来实现\",{\"1\":{\"375\":1}}],[\"来实现多个进程的同时运行\",{\"1\":{\"295\":1}}],[\"来实现更加方便的操作\",{\"1\":{\"283\":1}}],[\"来支持对象类型的io\",{\"1\":{\"287\":1}}],[\"来保证项目能够正常运行\",{\"1\":{\"1036\":1}}],[\"来保证数据正确写入到硬盘文件中\",{\"1\":{\"249\":1}}],[\"来保证这个梯度的方差最小即可\",{\"1\":{\"26\":1}}],[\"来完成\",{\"1\":{\"166\":1}}],[\"来明确表示当前类的示例对象本身\",{\"1\":{\"164\":1}}],[\"来定义最优的策略\",{\"1\":{\"148\":1}}],[\"来近似\",{\"1\":{\"137\":1,\"138\":1}}],[\"来进行管理\",{\"1\":{\"1328\":1}}],[\"来进行重定向操作外\",{\"1\":{\"1082\":1}}],[\"来进行提交\",{\"1\":{\"1069\":1}}],[\"来进行动态网页响应\",{\"1\":{\"1053\":1}}],[\"来进行访问\",{\"1\":{\"1047\":1}}],[\"来进行转义\",{\"1\":{\"836\":1}}],[\"来进行操作保证安全性\",{\"1\":{\"831\":1}}],[\"来进行数据库的链接\",{\"1\":{\"789\":1}}],[\"来进行多行注释\",{\"1\":{\"744\":1}}],[\"来进行求解\",{\"1\":{\"77\":1}}],[\"来进行迭代\",{\"1\":{\"13\":1}}],[\"来表示此表单用于文件传输\",{\"1\":{\"1075\":1}}],[\"来表示\",{\"1\":{\"13\":1}}],[\"来最大化mos总和\",{\"1\":{\"13\":1}}],[\"来考虑无人机的机动性\",{\"1\":{\"4\":1}}],[\"划分完毕\",{\"1\":{\"13\":1}}],[\"再连接起来\",{\"1\":{\"1215\":1}}],[\"再回头注入依赖\",{\"1\":{\"1181\":1}}],[\"再向对应的mapper发起请求\",{\"1\":{\"1116\":1}}],[\"再使用appclassloader进行加载\",{\"1\":{\"1109\":1}}],[\"再倒回来处理\",{\"1\":{\"1103\":1}}],[\"再去编写对应逻辑\",{\"1\":{\"1071\":1}}],[\"再发送给浏览器\",{\"1\":{\"1058\":1}}],[\"再父logger\",{\"1\":{\"929\":1}}],[\"再到前端进行渲染\",{\"1\":{\"609\":1}}],[\"再响应给浏览器\",{\"1\":{\"558\":1}}],[\"再通过sqlsession来执行对应的方法\",{\"1\":{\"842\":1}}],[\"再通过\",{\"1\":{\"522\":1}}],[\"再通过这些经验来不断改进更新另一个策略\",{\"1\":{\"123\":1}}],[\"再找好我们要截取的屁股后面紧接着的位置\",{\"1\":{\"490\":1}}],[\"再找到新的簇的各中心\",{\"1\":{\"13\":1}}],[\"再也不用arrays了\",{\"1\":{\"475\":1}}],[\"再来调用我们编写的请求映射方法\",{\"1\":{\"626\":1}}],[\"再来调用此方法\",{\"1\":{\"356\":1}}],[\"再来看看servletresponse\",{\"1\":{\"1058\":1}}],[\"再来看\",{\"1\":{\"224\":1}}],[\"再次向此地址发出请求\",{\"1\":{\"1082\":1}}],[\"再次执行我们之前的操作\",{\"1\":{\"884\":1}}],[\"再次获取\",{\"1\":{\"883\":1}}],[\"再次访问\",{\"1\":{\"1083\":1}}],[\"再次访问时就可以免登陆进入\",{\"1\":{\"685\":1}}],[\"再次访问我们的网站\",{\"1\":{\"681\":1}}],[\"再次尝试\",{\"1\":{\"616\":1}}],[\"再次强调\",{\"1\":{\"350\":1,\"816\":1}}],[\"再次出现\",{\"1\":{\"81\":1}}],[\"再写回主内存后\",{\"1\":{\"311\":1}}],[\"再继续执行的线程2内容\",{\"1\":{\"305\":1}}],[\"再将\",{\"1\":{\"77\":1}}],[\"再将用户划分给距离最近的无人机\",{\"1\":{\"13\":1}}],[\"再求平均值\",{\"1\":{\"41\":1}}],[\"再根据欧几里得距离重新划分\",{\"1\":{\"13\":1}}],[\"每当浏览器向服务器发起一个请求时\",{\"1\":{\"1055\":1}}],[\"每调用一次next\",{\"1\":{\"797\":1}}],[\"每组列名1相同的数据再按照列名2排序\",{\"1\":{\"764\":1}}],[\"每一级使用\",{\"1\":{\"936\":1}}],[\"每一行必须有值\",{\"1\":{\"747\":1}}],[\"每一种数据库都支持sql\",{\"1\":{\"744\":1}}],[\"每一张表都代表一种实体的数据\",{\"1\":{\"734\":1}}],[\"每一层都有着各自的职责\",{\"1\":{\"540\":1}}],[\"每一轮都会执行unaryoperator并生成一个新值到流中\",{\"1\":{\"478\":1}}],[\"每一轮循环\",{\"1\":{\"394\":1}}],[\"每一个测试用例执行之前\",{\"1\":{\"986\":1}}],[\"每一个handler都可以配置一个对应的formatter来决定日志打印的格式\",{\"1\":{\"944\":1}}],[\"每一个result标签都可以配置数据库字段和类属性的对应关系\",{\"1\":{\"835\":1}}],[\"每一个标签都作为一个节点\",{\"1\":{\"819\":1}}],[\"每一个学生也可以有多个教师\",{\"1\":{\"733\":1}}],[\"每一个老师不仅可以教多个学生\",{\"1\":{\"733\":1}}],[\"每一个userdetails就代表一个用户信息\",{\"1\":{\"658\":1}}],[\"每一个thread对象中\",{\"1\":{\"301\":1}}],[\"每一个进程都是一个应用程序\",{\"1\":{\"295\":1}}],[\"每一个对象我们都可以称其为元素\",{\"1\":{\"178\":1}}],[\"每一次next操作\",{\"1\":{\"188\":1}}],[\"每次操作都打开一个物理连接\",{\"1\":{\"1242\":1}}],[\"每次请求都会新建一个实例\",{\"1\":{\"1181\":1}}],[\"每次访问对应的\",{\"1\":{\"1056\":1}}],[\"每次赛季更新都会有一个大版本更新\",{\"1\":{\"1003\":1}}],[\"每次执行测试用例都会创建一个新的对象来执行\",{\"1\":{\"986\":1}}],[\"每次完成代码后都可以跑一遍测试用例\",{\"1\":{\"956\":1}}],[\"每次发起得到的bean实例都不同\",{\"1\":{\"588\":1}}],[\"每次返回一个新的流\",{\"1\":{\"515\":1}}],[\"每次运算都会生成一个新的对象\",{\"1\":{\"402\":1}}],[\"每次就直接返回一个字符串吧\",{\"1\":{\"193\":1}}],[\"每次循环一定要判断是否还有元素剩余\",{\"1\":{\"191\":1}}],[\"每次都是从对应的状态\",{\"1\":{\"84\":1}}],[\"每次迭代都会使得策略进行提升\",{\"1\":{\"68\":1}}],[\"每次无人机会根据当前状态st​∈s\",{\"1\":{\"13\":1}}],[\"每个事务不能同时进行\",{\"1\":{\"1271\":1}}],[\"每个人看到的结果都是独立的\",{\"1\":{\"1266\":1}}],[\"每个人的分工都很明确\",{\"1\":{\"1116\":1}}],[\"每个jsp文件都有一个自己的类加载器\",{\"1\":{\"1109\":1}}],[\"每个web应用程序都有一个自己的类加载器\",{\"1\":{\"1109\":1}}],[\"每个文件夹都是一个web应用程序\",{\"1\":{\"1047\":1}}],[\"每个插件都有各自的功能\",{\"1\":{\"1034\":1}}],[\"每个maven项目都有一个生命周期\",{\"1\":{\"1034\":1}}],[\"每个mapper都是唯一的\",{\"1\":{\"826\":1}}],[\"每个会话就相当于我不同的地方登陆一个账号去访问数据库\",{\"1\":{\"825\":1}}],[\"每个基于\",{\"1\":{\"825\":1}}],[\"每个学生都有着不同的学号\",{\"1\":{\"737\":1}}],[\"每个流只能进行一次终端操作\",{\"1\":{\"515\":1}}],[\"每个对象中都有一个单独的类定义\",{\"1\":{\"408\":1}}],[\"每个对象都有这样的一个类定义\",{\"1\":{\"408\":1}}],[\"每个对象都有一个自己的空间\",{\"1\":{\"161\":1}}],[\"每个对象都应该有针对于锁的一些操作\",{\"1\":{\"318\":1}}],[\"每个类可以创建一个对象\",{\"1\":{\"408\":1}}],[\"每个类都有且只有一个唯一的class对象存放在jvm中\",{\"1\":{\"337\":1}}],[\"每个用双引号括起来的字符串\",{\"1\":{\"401\":1}}],[\"每个用户的会话都会有一个自己的session对象\",{\"1\":{\"1094\":1}}],[\"每个用户的移动方向均匀分布在左\",{\"1\":{\"14\":1}}],[\"每个用户都需要判断是否与每个无人机关联\",{\"1\":{\"14\":1}}],[\"每个用户只能属于一个集群\",{\"1\":{\"8\":1}}],[\"每个包装类中\",{\"1\":{\"340\":1}}],[\"每个线程都有一个私有的工作内存\",{\"1\":{\"311\":1}}],[\"每个元素都要执行+1操作\",{\"1\":{\"228\":1}}],[\"每个元素都有一个自己的下标位置\",{\"1\":{\"181\":2}}],[\"每个集群中无人机的最优位置也会发生变化\",{\"1\":{\"14\":1}}],[\"每架无人机的带宽和发射功率都均匀分配给每个用户\",{\"1\":{\"13\":1}}],[\"将剩余所有非懒加载单例bean全部实例化\",{\"1\":{\"1320\":1,\"1321\":1}}],[\"将这些变成对应的beandefinition对象呢\",{\"1\":{\"1296\":1}}],[\"将这些值提前做成包装类放在数组中存放\",{\"1\":{\"384\":1}}],[\"将此连接改为为空闲状态\",{\"1\":{\"1247\":1}}],[\"将增强处理添加到目标对象中\",{\"1\":{\"1226\":1}}],[\"将bean的名称给到我们\",{\"1\":{\"1186\":1}}],[\"将bean标签展开\",{\"1\":{\"1133\":1}}],[\"将用户对象添加到session中\",{\"1\":{\"1096\":1}}],[\"将我们之前编写的前端代码全部放入其中\",{\"1\":{\"1047\":1}}],[\"将我们的tomcat服务器集成到idea中\",{\"1\":{\"1048\":1}}],[\"将我们的前端模版中的登录页面作为springsecurity的默认登录界面\",{\"1\":{\"680\":1}}],[\"将我们的项目从未命名模块改进为应用程序模块\",{\"1\":{\"468\":1}}],[\"将consolehandler的默认编码格式修改为gbk编码格式\",{\"1\":{\"1047\":1}}],[\"将cpu资源让位给其他线程\",{\"1\":{\"304\":1}}],[\"将值设置为空进行测试\",{\"1\":{\"992\":1}}],[\"将值设置为null进行测试\",{\"1\":{\"992\":1}}],[\"将忽略二号测试案例进行测试\",{\"1\":{\"960\":1}}],[\"将日志利用socket通过网络发送到另一个主机\",{\"1\":{\"918\":1}}],[\"将日志直接写入到指定的文件中\",{\"1\":{\"918\":1}}],[\"将日志通过system\",{\"1\":{\"918\":1}}],[\"将1号用户的id改成100\",{\"1\":{\"888\":1}}],[\"将不会通过反射给字段单独赋值\",{\"1\":{\"841\":1}}],[\"将不会执行commit\",{\"1\":{\"806\":1}}],[\"将接口和\",{\"1\":{\"816\":1}}],[\"将数据转换为我们可以直接操作的实体类型\",{\"1\":{\"816\":1}}],[\"将startup\",{\"1\":{\"1047\":1}}],[\"将str包装进optional\",{\"1\":{\"454\":2}}],[\"将sql语句的提交\",{\"1\":{\"806\":1}}],[\"将查询结果映射为对象\",{\"0\":{\"799\":1}}],[\"将删除表中全部数据\",{\"1\":{\"756\":1}}],[\"将使得整个表中此列的所有数据都被修改\",{\"1\":{\"755\":1}}],[\"将服务端创建在端口8080上\",{\"1\":{\"719\":2,\"727\":1}}],[\"将记住我勾选框也作为表单的一部分进行提交\",{\"1\":{\"686\":1}}],[\"将登录相关的地址放行\",{\"1\":{\"680\":1}}],[\"将登录页设置为我们自己的登录页面\",{\"1\":{\"680\":1}}],[\"将所有的子标签全部包含\",{\"1\":{\"817\":1}}],[\"将所有的静态资源放行\",{\"1\":{\"681\":1}}],[\"将所有请求全部拦截\",{\"1\":{\"680\":1,\"681\":1}}],[\"将所有状态的\",{\"1\":{\"46\":1}}],[\"将一个有效的会话id分配给用户\",{\"1\":{\"642\":1}}],[\"将返回的内容类型设定为application\",{\"1\":{\"615\":1}}],[\"将实体类转换为json格式的数据\",{\"1\":{\"615\":1}}],[\"将json格式字符串转换为js对象\",{\"1\":{\"610\":1}}],[\"将name传递给model\",{\"1\":{\"563\":1}}],[\"将传入的字符串转换为小写并打印\",{\"1\":{\"454\":1}}],[\"将抛出\",{\"1\":{\"425\":1}}],[\"将无法删除\",{\"1\":{\"751\":1}}],[\"将无法访问页面\",{\"1\":{\"696\":1}}],[\"将无法访问\",{\"1\":{\"576\":1}}],[\"将无法通过编译\",{\"1\":{\"421\":1,\"438\":1}}],[\"将无限生成下去\",{\"1\":{\"478\":1}}],[\"将无人机部署在每个中心内\",{\"1\":{\"13\":1}}],[\"将其copy到stream中\",{\"1\":{\"1075\":1}}],[\"将其与数据库打通\",{\"1\":{\"1070\":1}}],[\"将其修改为per\",{\"1\":{\"986\":1}}],[\"将其配置为jdk\",{\"1\":{\"951\":1}}],[\"将其设定为stdout\",{\"1\":{\"951\":1}}],[\"将其映射为字符串长度的一个新流\",{\"1\":{\"522\":1}}],[\"将其中的抽象方法实现\",{\"1\":{\"412\":1}}],[\"将其平均分配给其∣kn​∣个关联用户\",{\"1\":{\"9\":1}}],[\"将匹配\",{\"1\":{\"403\":1}}],[\"将匹配的子串替换或者从某个串中取出符合某个条件的子串等\",{\"1\":{\"403\":1}}],[\"将int类型值作为包装类型使用\",{\"1\":{\"384\":1}}],[\"将当前对象转换为string的形式\",{\"1\":{\"372\":1}}],[\"将test\",{\"1\":{\"349\":1}}],[\"将变量的值给予threadlocal\",{\"1\":{\"319\":2}}],[\"将文件内容作为输入流进行扫描\",{\"1\":{\"285\":1}}],[\"将它们以字符串的形式写入到输出流\",{\"1\":{\"284\":1}}],[\"将main类放到com\",{\"1\":{\"277\":1}}],[\"将缓冲区大小设置为1\",{\"1\":{\"265\":1}}],[\"将每一个元素映射为integer类型\",{\"1\":{\"228\":1}}],[\"将会无限进行下去\",{\"1\":{\"228\":1}}],[\"将底层数组变成新的扩容之后的数组\",{\"1\":{\"217\":1}}],[\"将另一个map中的所有键值对添加到当前map中\",{\"1\":{\"213\":1}}],[\"将元素从栈顶出栈\",{\"1\":{\"201\":1}}],[\"将元素推向栈顶\",{\"1\":{\"201\":1}}],[\"将上一个已遍历元素修改为新的元素\",{\"1\":{\"194\":1}}],[\"将上述优化问题简化\",{\"1\":{\"13\":1}}],[\"将给定集合中所有元素插入到当前结合的给定位置上\",{\"1\":{\"181\":1}}],[\"将集合转换为数组的形式\",{\"1\":{\"180\":1}}],[\"将基于表格表示的策略\",{\"1\":{\"148\":1}}],[\"将该网络的\",{\"1\":{\"142\":1}}],[\"将\",{\"1\":{\"58\":1,\"85\":1,\"142\":2}}],[\"将处于\",{\"1\":{\"29\":1}}],[\"将对应的配置文件修改就行\",{\"1\":{\"1119\":1}}],[\"将对应的轨迹所获得的所有reward的总和\",{\"1\":{\"19\":1}}],[\"将对于\",{\"1\":{\"23\":1}}],[\"水平位置和高度\",{\"1\":{\"11\":1}}],[\"数学\",{\"1\":{\"1136\":1}}],[\"数学工具类\",{\"0\":{\"431\":1}}],[\"数字\",{\"1\":{\"403\":1,\"490\":1}}],[\"数量\",{\"1\":{\"739\":3,\"766\":2}}],[\"数量的内容\",{\"1\":{\"265\":1}}],[\"数量和位置\",{\"1\":{\"11\":1}}],[\"数组这类\",{\"1\":{\"1207\":1}}],[\"数组等\",{\"1\":{\"992\":1}}],[\"数组中可以嵌套其他的jsonobject或是jsonarray\",{\"1\":{\"613\":1}}],[\"数组工具类\",{\"0\":{\"432\":1}}],[\"数组同样支持向上转型\",{\"1\":{\"395\":1}}],[\"数组大小\",{\"1\":{\"392\":2}}],[\"数组类型比较特殊\",{\"1\":{\"392\":1}}],[\"数组类型也是一种类型\",{\"1\":{\"341\":1}}],[\"数组可以代表任何相同类型的一组内容\",{\"1\":{\"391\":1}}],[\"数组可以存放基本数据类型\",{\"1\":{\"179\":1}}],[\"数组是相同类型数据的有序集合\",{\"1\":{\"391\":1}}],[\"数组\",{\"0\":{\"389\":1,\"391\":1}}],[\"数组的\",{\"0\":{\"341\":1},\"1\":{\"393\":1}}],[\"数组的大小是固定的\",{\"1\":{\"179\":1}}],[\"数组实现的栈和队列\",{\"1\":{\"202\":1}}],[\"数组存放的类型只能是一种\",{\"1\":{\"179\":1}}],[\"数据实际上还是存放在原来的表中\",{\"1\":{\"779\":1}}],[\"数据类型\",{\"1\":{\"750\":2,\"751\":1}}],[\"数据操纵语言\",{\"1\":{\"744\":1}}],[\"数据查询语言\",{\"1\":{\"744\":1}}],[\"数据模型与现实世界中的模型一样\",{\"1\":{\"733\":1}}],[\"数据模型\",{\"0\":{\"733\":1}}],[\"数据表之间相互关联\",{\"1\":{\"732\":1}}],[\"数据库中没有任何新增的内容\",{\"1\":{\"1278\":1}}],[\"数据库中会自动记录相关的信息\",{\"1\":{\"687\":1}}],[\"数据库需要通过一定的规则和策略\",{\"1\":{\"1267\":1}}],[\"数据库框架整合\",{\"0\":{\"1356\":1}}],[\"数据库框架整合3\",{\"0\":{\"1264\":1}}],[\"数据库框架整合2\",{\"0\":{\"1250\":1,\"1251\":1,\"1263\":1}}],[\"数据库框架整合1\",{\"0\":{\"1240\":1,\"1241\":1}}],[\"数据库链接的建立和关闭是极其耗费系统资源的操作\",{\"1\":{\"1242\":1}}],[\"数据库驱动信息\",{\"1\":{\"1244\":1}}],[\"数据库驱动\",{\"1\":{\"1071\":1}}],[\"数据库连接url\",{\"1\":{\"824\":1,\"1071\":1,\"1242\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"782\":1}}],[\"数据库的完整性没有被破坏\",{\"1\":{\"782\":1}}],[\"数据库的规范化\",{\"0\":{\"735\":1}}],[\"数据库4\",{\"0\":{\"777\":1}}],[\"数据库控制语言\",{\"0\":{\"771\":1}}],[\"数据库查询语言\",{\"0\":{\"761\":1}}],[\"数据库3\",{\"0\":{\"759\":1}}],[\"数据库操纵语言\",{\"0\":{\"753\":1}}],[\"数据库操作\",{\"0\":{\"749\":1}}],[\"数据库名\",{\"1\":{\"749\":3}}],[\"数据库定义语言\",{\"0\":{\"745\":1}}],[\"数据库定义语言ddl\",{\"1\":{\"744\":1}}],[\"数据库2\",{\"0\":{\"742\":1}}],[\"数据库创建完成后\",{\"1\":{\"750\":1}}],[\"数据库创建\",{\"0\":{\"734\":1}}],[\"数据库能有效地帮助一个组织或企业科学地管理各类信息资源\",{\"1\":{\"732\":1}}],[\"数据库是数据管理的有效技术\",{\"1\":{\"732\":1}}],[\"数据库\",{\"0\":{\"731\":1,\"743\":1,\"760\":1,\"778\":1,\"1345\":1},\"1\":{\"774\":2}}],[\"数据库1\",{\"0\":{\"730\":1}}],[\"数据已发送\",{\"1\":{\"720\":1}}],[\"数据源还有其他实现\",{\"1\":{\"1260\":1}}],[\"数据源实现其实有很多\",{\"1\":{\"1252\":1}}],[\"数据源会根据内部机制\",{\"1\":{\"1242\":1}}],[\"数据源\",{\"0\":{\"1242\":1},\"1\":{\"1273\":1}}],[\"数据源配置\",{\"1\":{\"664\":1}}],[\"数据源等\",{\"1\":{\"625\":1}}],[\"数据我们可以直接向model模型层进行提供\",{\"1\":{\"563\":1}}],[\"数据截断\",{\"0\":{\"479\":1}}],[\"数据流datainputstream也是filterinputstream的子类\",{\"1\":{\"286\":1}}],[\"数据流\",{\"0\":{\"286\":1}}],[\"数据结构与算法基础\",{\"1\":{\"172\":2,\"437\":1}}],[\"数据结构与算法\",{\"1\":{\"172\":1,\"203\":1}}],[\"数据包从发送端\",{\"1\":{\"10\":1}}],[\"因而也被称为实例\",{\"1\":{\"161\":1}}],[\"因为b需要a\",{\"1\":{\"1301\":1}}],[\"因为bean有两个特殊的类型\",{\"1\":{\"1300\":1}}],[\"因为b指定了non\",{\"1\":{\"504\":1}}],[\"因为所有的bean默认都是单例模式\",{\"1\":{\"1300\":1}}],[\"因为所有的对象都是属于一个普通的类型\",{\"1\":{\"173\":1}}],[\"因为创建数据库连接其实都是一样的方式\",{\"1\":{\"1246\":1}}],[\"因为有可能很多个线程都需要获取连接对象\",{\"1\":{\"1246\":1}}],[\"因为使用的是接口\",{\"1\":{\"1231\":1}}],[\"因为方法变动了\",{\"1\":{\"1224\":1}}],[\"因为方法参数有变动\",{\"1\":{\"1223\":1}}],[\"因为构造函数必须一次性拿到所有参数\",{\"1\":{\"1181\":1}}],[\"因为都是固定模式\",{\"1\":{\"1177\":1}}],[\"因为都直接在一个缺省的包中\",{\"1\":{\"277\":1}}],[\"因为单例模式下bean是由ioc容器加载\",{\"1\":{\"1131\":1}}],[\"因为类之间的关联性太强了\",{\"1\":{\"1116\":1}}],[\"因为配置文件位于内部\",{\"1\":{\"1017\":1}}],[\"因为jdbc驱动由数据库厂商开发\",{\"1\":{\"1016\":1}}],[\"因为中心仓库服务器位于国外\",{\"1\":{\"1010\":1}}],[\"因为mybatis的日志级别都比较低\",{\"1\":{\"951\":1}}],[\"因为并没有保存在缓存中\",{\"1\":{\"884\":1}}],[\"因为并没有使用到外部类的任何静态变量\",{\"1\":{\"411\":1}}],[\"因为id已经发生变化了\",{\"1\":{\"888\":1}}],[\"因为id为主键\",{\"1\":{\"835\":1}}],[\"因为integer类中默认提供了求两个int值之和的静态方法\",{\"1\":{\"415\":1}}],[\"因为只有这样mybatis才能正确识别我们配置的内容\",{\"1\":{\"824\":1}}],[\"因为equal方法可能不符合预期结果\",{\"1\":{\"812\":1}}],[\"因为浏览器不止发一个请求\",{\"1\":{\"727\":1}}],[\"因为浏览器访问时会不止发一个请求\",{\"1\":{\"727\":1}}],[\"因为浏览器默认是直接使用get方法获取页面\",{\"1\":{\"572\":1}}],[\"因为会话\",{\"1\":{\"714\":1}}],[\"因为spring框架为我们提供了更加便捷的方式进行任务调度\",{\"1\":{\"1187\":1}}],[\"因为springmvc是基于spring开发的\",{\"1\":{\"546\":1}}],[\"因为security已经帮我们做了\",{\"1\":{\"658\":1}}],[\"因为这是数据库最基本的信息\",{\"1\":{\"1259\":1}}],[\"因为这这里off的值为int的最大值\",{\"1\":{\"912\":1}}],[\"因为这样写起来层次会更加清晰\",{\"1\":{\"626\":1}}],[\"因为这里使用的是xml配置文件\",{\"1\":{\"1119\":1}}],[\"因为这里需要多个参数\",{\"1\":{\"834\":1}}],[\"因为这里只针对controller进行过滤\",{\"1\":{\"695\":1}}],[\"因为这里也是提交的表单数据\",{\"1\":{\"617\":1}}],[\"因为这里是void\",{\"1\":{\"349\":1}}],[\"因为tomcat还提供了一个jsp的servlet\",{\"1\":{\"558\":1}}],[\"因为this关键字代表的是当前的对象本身\",{\"1\":{\"274\":1}}],[\"因为该方法已经添加到\",{\"1\":{\"516\":1}}],[\"因为继承的坑位已经默认被占了\",{\"1\":{\"501\":1}}],[\"因为完全可以从后面的值来判断是什么类型\",{\"1\":{\"485\":1}}],[\"因为权限为私有的\",{\"1\":{\"474\":1}}],[\"因为没有模块只需要导包就行\",{\"1\":{\"463\":1}}],[\"因为数组本身是引用类型\",{\"1\":{\"438\":1}}],[\"因为无论在哪里\",{\"1\":{\"1084\":1}}],[\"因为无论具体类型是什么\",{\"1\":{\"438\":1}}],[\"因为无论是\",{\"1\":{\"75\":1}}],[\"因为此时并不明确具体是什么类型\",{\"1\":{\"438\":1}}],[\"因为现在父项目没有依赖\",{\"1\":{\"1033\":1}}],[\"因为现在是以类为单位\",{\"1\":{\"986\":1}}],[\"因为现在有了类型变量\",{\"1\":{\"438\":1}}],[\"因为现在只需要使用接口来进行配置\",{\"1\":{\"894\":1}}],[\"因为现在只需要一个string类型的返回值\",{\"1\":{\"415\":1}}],[\"因为现在只可能出现number的子类\",{\"1\":{\"173\":1}}],[\"因为object是所有类型的父类\",{\"1\":{\"437\":1}}],[\"因为不太常用\",{\"1\":{\"480\":1}}],[\"因为不这样就无法编译了\",{\"1\":{\"423\":1}}],[\"因为不需要\",{\"1\":{\"125\":1}}],[\"因为匿名内部类不支持自动类型推断\",{\"1\":{\"480\":1}}],[\"因为匿名内部类就是接口的实现类\",{\"1\":{\"171\":1}}],[\"因为匿名对象没有类名\",{\"1\":{\"412\":1}}],[\"因为成员内部类本身就是某个对象所有的\",{\"1\":{\"408\":1}}],[\"因为父类都是\",{\"1\":{\"395\":1}}],[\"因为同样是类\",{\"1\":{\"392\":1}}],[\"因为超出了缓存的范围\",{\"1\":{\"384\":1}}],[\"因为小的数使用频率非常高\",{\"1\":{\"384\":1}}],[\"因为包装类是一个类\",{\"1\":{\"384\":1}}],[\"因为底层是c++实现\",{\"1\":{\"377\":1}}],[\"因为底层实质上是借用的一个\",{\"1\":{\"205\":1}}],[\"因为其他类就算继承这个接口\",{\"1\":{\"376\":1}}],[\"因为其满足该理论\",{\"1\":{\"58\":1}}],[\"因为抽象方法一定要由子类实现\",{\"1\":{\"375\":1}}],[\"因为普通的classloader无法加载二进制文件\",{\"1\":{\"356\":1}}],[\"因为是具体使用对象时才会明确具体类型\",{\"1\":{\"438\":1}}],[\"因为是属于类的\",{\"1\":{\"349\":1}}],[\"因为是在顶层接口中定义的\",{\"1\":{\"193\":1}}],[\"因为newinstance\",{\"1\":{\"348\":1}}],[\"因为静态方法属于类的\",{\"1\":{\"274\":1}}],[\"因为关闭流是任何情况都必须要执行的\",{\"1\":{\"247\":1}}],[\"因为它还要考虑并发的问题\",{\"1\":{\"1245\":1}}],[\"因为它们都被认为是一个文本节点\",{\"1\":{\"819\":1}}],[\"因为它们直接操作字符\",{\"1\":{\"245\":1}}],[\"因为它相当于就是直接与用户的浏览器打交道的一层\",{\"1\":{\"540\":1}}],[\"因为它本质上就相当于是对应类型的子类\",{\"1\":{\"412\":1}}],[\"因为它作用范围就只是方法内\",{\"1\":{\"410\":1}}],[\"因为它是我们直接加载的\",{\"1\":{\"356\":1}}],[\"因为它会将我们插入的结点按照规则进行排序\",{\"1\":{\"219\":1}}],[\"因为重写了\",{\"1\":{\"241\":1}}],[\"因为传入的哈希值可能会很大\",{\"1\":{\"216\":1}}],[\"因为操作特殊\",{\"1\":{\"212\":1,\"213\":1}}],[\"因为list是有序集合\",{\"1\":{\"194\":1}}],[\"因为还是有可能是\",{\"1\":{\"172\":1}}],[\"因为我们需要的类型是student\",{\"1\":{\"1126\":1}}],[\"因为我们需要计算的是\",{\"1\":{\"155\":1}}],[\"因为我们使用了别人为我们提供的框架\",{\"1\":{\"1037\":1}}],[\"因为我们是从外部进行修改\",{\"1\":{\"888\":1}}],[\"因为我们前面学习了lambda表达式\",{\"1\":{\"171\":1}}],[\"因为在bean创建得到最终对象之前\",{\"1\":{\"1310\":1}}],[\"因为在最后需要释放资源\",{\"1\":{\"788\":1}}],[\"因为在最后自动帮我们调用了close\",{\"1\":{\"247\":1}}],[\"因为在编译的时候\",{\"1\":{\"411\":1}}],[\"因为在\",{\"1\":{\"92\":1}}],[\"因为在不考虑用户自由穿梭集群的情况\",{\"1\":{\"14\":1}}],[\"因为最终策略更新的核心仍然是\",{\"1\":{\"79\":1}}],[\"因为\",{\"1\":{\"77\":1,\"104\":1,\"124\":1,\"192\":1,\"214\":1,\"224\":2,\"241\":1,\"560\":1,\"1175\":1}}],[\"因为q\",{\"1\":{\"13\":1}}],[\"因为目标函数对于无人机的3d坐标是非凸的\",{\"1\":{\"11\":1}}],[\"因此即使你不添加\",{\"1\":{\"1327\":1}}],[\"因此最后我们得到的结果实际上就是一个动态代理的对象\",{\"1\":{\"1310\":1}}],[\"因此每个事务都应该与其他事务隔离开来\",{\"1\":{\"1266\":1}}],[\"因此两个类互相通过构造器注入会导致无法完成初始化\",{\"1\":{\"1181\":1}}],[\"因此官方并不推荐使用\",{\"1\":{\"1175\":1}}],[\"因此无法使用这种方式来传递数据\",{\"1\":{\"1083\":1}}],[\"因此无需多余配置\",{\"1\":{\"958\":1}}],[\"因此返回405状态码\",{\"1\":{\"1083\":1}}],[\"因此返回值也是\",{\"1\":{\"171\":1}}],[\"因此此类仅仅是用于完善一个servlet的基本操作\",{\"1\":{\"1059\":1}}],[\"因此此表中存在一个主键\",{\"1\":{\"737\":1}}],[\"因此之后我们一律使用注解进行开发\",{\"1\":{\"1054\":1}}],[\"因此有时候可以省略\",{\"1\":{\"1042\":1}}],[\"因此有对象锁和类锁区别\",{\"1\":{\"312\":1}}],[\"因此需要导入这些依赖来做兼容\",{\"1\":{\"1025\":1}}],[\"因此需要用一个命名空间来区分\",{\"1\":{\"826\":1}}],[\"因此需要用近似算法来进行替代\",{\"1\":{\"136\":1}}],[\"因此只能再加一级进行缓冲\",{\"1\":{\"1301\":1}}],[\"因此只能使用类来进行定义\",{\"1\":{\"400\":1}}],[\"因此只需在运行时包含即可\",{\"1\":{\"1016\":1}}],[\"因此lombok不需要在项目运行时也存在\",{\"1\":{\"1016\":1}}],[\"因此maven第一次导入依赖是需要联网的\",{\"1\":{\"1009\":1}}],[\"因此mos不仅与欧氏距离有关\",{\"1\":{\"13\":1}}],[\"因此moskn​​delay\",{\"1\":{\"10\":1}}],[\"因此默认值是\",{\"1\":{\"884\":1}}],[\"因此直接导入依赖后就可以使用了\",{\"1\":{\"811\":1}}],[\"因此直接实现接口即可\",{\"1\":{\"552\":1}}],[\"因此要先起一个别名\",{\"1\":{\"768\":1}}],[\"因此不同的数据库都存在自己的\",{\"1\":{\"744\":1}}],[\"因此不需要data\",{\"1\":{\"523\":1}}],[\"因此不需要进行\",{\"1\":{\"120\":1}}],[\"因此存在传递依赖的情况\",{\"1\":{\"738\":1}}],[\"因此学号和学生之间也有一种联系\",{\"1\":{\"733\":1}}],[\"因此全部被302重定向到登录页面\",{\"1\":{\"681\":1}}],[\"因此如果你不知道的话根本不清楚是什么问题\",{\"1\":{\"660\":1}}],[\"因此现在比较主流的数据传输方式则是通过json格式承载的\",{\"1\":{\"610\":1}}],[\"因此json横空出世\",{\"1\":{\"610\":1}}],[\"因此拦截器会根据注册顺序依次执行\",{\"1\":{\"600\":1}}],[\"因此既可以存放integer也能存放string\",{\"1\":{\"437\":1}}],[\"因此会读取命令行中的指令参数进行存储到\",{\"1\":{\"399\":1}}],[\"因此它会先调用父类的getsingleton\",{\"1\":{\"1300\":1}}],[\"因此它的玩法非常之高级\",{\"1\":{\"1245\":1}}],[\"因此它是在进行内部的转发\",{\"1\":{\"1083\":1}}],[\"因此它能够有效地防止sql注入攻击\",{\"1\":{\"805\":1}}],[\"因此它可以被拆分为\",{\"1\":{\"736\":1}}],[\"因此它实际上是整个三层架构中最关键的一层\",{\"1\":{\"540\":1}}],[\"因此它已经无法正常工作了\",{\"1\":{\"350\":1}}],[\"因此它只适合读纯文本的文件\",{\"1\":{\"253\":1}}],[\"因此守护线程不适合进行io操作\",{\"1\":{\"329\":1}}],[\"因此各个线程直接存放的内容互不干扰\",{\"1\":{\"319\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"313\":1}}],[\"因此并不能保证自增操作的原子性\",{\"1\":{\"312\":1}}],[\"因此为null\",{\"1\":{\"290\":1}}],[\"因此依然是装饰我们传入的输出流\",{\"1\":{\"284\":1}}],[\"因此性能还不够高\",{\"1\":{\"260\":1}}],[\"因此可以直接调用\",{\"1\":{\"431\":1,\"432\":1}}],[\"因此可以直接使用lambda表达式\",{\"1\":{\"296\":1}}],[\"因此可以直接放入\",{\"1\":{\"283\":1}}],[\"因此可以直接读取到中文字符\",{\"1\":{\"253\":1}}],[\"因此可以考虑\",{\"1\":{\"136\":1}}],[\"因此与read结合\",{\"1\":{\"248\":1}}],[\"因此这里只讲解声明式事务\",{\"1\":{\"1274\":1}}],[\"因此这里我们还需要配置一下\",{\"1\":{\"564\":1}}],[\"因此这些操作被mybatis抽象为一个接口\",{\"1\":{\"1272\":1}}],[\"因此这些日志框架仅mybatis内部做兼容需要导入使用\",{\"1\":{\"1025\":1}}],[\"因此这个时候就发生了数据的幻读现象\",{\"1\":{\"1270\":1}}],[\"因此这台主机也称为万维网服务器\",{\"1\":{\"1042\":1}}],[\"因此这样就能够保证我们插入顺序和最后的迭代顺序一致了\",{\"1\":{\"206\":1}}],[\"因此这种情况下的\",{\"1\":{\"134\":1}}],[\"因此所有的集合类都有这个方法\",{\"1\":{\"193\":1}}],[\"因此该指标可以描述为\",{\"1\":{\"150\":1}}],[\"因此左侧那个类似\",{\"1\":{\"142\":1}}],[\"因此对于常见的一些查询参数\",{\"1\":{\"831\":1}}],[\"因此对于用户kn​的在时刻t的传输速率rkn​​\",{\"1\":{\"9\":1}}],[\"因此对应的损失函数的梯度可以修改为\",{\"1\":{\"142\":1}}],[\"因此对应算法为\",{\"1\":{\"138\":1}}],[\"因此采用这种\",{\"1\":{\"134\":1}}],[\"因此我们将第一个过滤器命名进行调整\",{\"1\":{\"1103\":1}}],[\"因此我们将优化问题简化为区域分割问题\",{\"1\":{\"13\":1}}],[\"因此我们通过maven导入其他的依赖只需要填写这三个基本元素就可以了\",{\"1\":{\"1003\":1}}],[\"因此我们不需要再去进行额外的环境安装\",{\"1\":{\"1000\":1}}],[\"因此我们不需要手动指定\",{\"1\":{\"277\":1}}],[\"因此我们在默认情况下才能正常使用日志打印\",{\"1\":{\"927\":1}}],[\"因此我们打印日志就不会有任何效果\",{\"1\":{\"918\":1}}],[\"因此我们可能需要限制用户的输入来防止用户输入一些sql语句关键字\",{\"1\":{\"804\":1}}],[\"因此我们可以直接使用httpfilter来编写\",{\"1\":{\"1104\":1}}],[\"因此我们可以直接使用数组的class对象表示\",{\"1\":{\"349\":1}}],[\"因此我们可以随时随地获取我们添加的属性\",{\"1\":{\"1084\":1}}],[\"因此我们可以创建一个工具类来集中创建sqlsession\",{\"1\":{\"830\":1}}],[\"因此我们可以使用setkeepalive\",{\"1\":{\"721\":1}}],[\"因此我们可以通过\",{\"1\":{\"99\":1}}],[\"因此我们的服务端能够读取http请求\",{\"1\":{\"727\":1}}],[\"因此我们编写一个自定义的来让它支持\",{\"1\":{\"356\":1}}],[\"因此我们自己编写的同名包同名类不会被加载\",{\"1\":{\"355\":1}}],[\"因此我们需要设置一下logging\",{\"1\":{\"951\":1}}],[\"因此我们需要一种方法来区分类的不同版本\",{\"1\":{\"289\":1}}],[\"因此我们需要保证对于所有的\",{\"1\":{\"155\":1}}],[\"因此我们用\",{\"1\":{\"137\":1}}],[\"因此是一个确定的贪心策略\",{\"1\":{\"88\":1}}],[\"因此是2n\",{\"1\":{\"14\":1}}],[\"因此随着用户位置的变化\",{\"1\":{\"14\":1}}],[\"因此gak\",{\"1\":{\"13\":1}}],[\"因此\",{\"1\":{\"9\":2,\"10\":1,\"26\":1,\"42\":1,\"48\":1,\"58\":1,\"71\":1,\"94\":1,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"124\":1,\"171\":1,\"173\":1,\"204\":1,\"241\":1,\"313\":1,\"401\":1,\"412\":2,\"447\":1,\"540\":1,\"558\":1,\"589\":1,\"641\":1,\"658\":1,\"659\":1,\"681\":2,\"686\":2,\"691\":1,\"710\":1,\"779\":1,\"825\":1,\"883\":1,\"888\":1,\"901\":1,\"912\":1,\"948\":1,\"956\":2,\"963\":1,\"1009\":1,\"1017\":1,\"1025\":1,\"1036\":1,\"1042\":2,\"1055\":1,\"1095\":1,\"1116\":1,\"1118\":1,\"1126\":1,\"1148\":1,\"1188\":1,\"1242\":3,\"1244\":1,\"1267\":1,\"1270\":2,\"1271\":1,\"1297\":1,\"1310\":2,\"1328\":1}}],[\"∀\",{\"1\":{\"116\":1,\"120\":1}}],[\"∀s\",{\"1\":{\"115\":1,\"119\":1}}],[\"∀s=st​\",{\"1\":{\"112\":1}}],[\"∀s∈s​\",{\"1\":{\"55\":1}}],[\"∀s∈s=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"∀s∈s\",{\"1\":{\"45\":1,\"58\":1}}],[\"∀kn​\",{\"1\":{\"11\":3,\"13\":3}}],[\"∀t\",{\"1\":{\"11\":4,\"13\":4}}],[\"∀n\",{\"1\":{\"11\":2,\"13\":2}}],[\"从一个账号扣款\",{\"1\":{\"1266\":1}}],[\"从这里开始\",{\"1\":{\"1259\":1}}],[\"从这章开始时基于\",{\"1\":{\"147\":1}}],[\"从活跃列表中移除此链接信息\",{\"1\":{\"1246\":1}}],[\"从给定对象中获取属性出来\",{\"1\":{\"1203\":1}}],[\"从给定的\",{\"1\":{\"82\":1}}],[\"从我们开发者的角度来说\",{\"1\":{\"691\":1}}],[\"从数据库中进行查询\",{\"1\":{\"672\":1}}],[\"从数学角度来说\",{\"1\":{\"180\":4}}],[\"从spring\",{\"1\":{\"660\":1}}],[\"从现在开始\",{\"1\":{\"658\":1}}],[\"从那时起\",{\"1\":{\"643\":1}}],[\"从不法分子的角度去了解整个流程\",{\"1\":{\"641\":1}}],[\"从它的名字我们也能得知\",{\"1\":{\"569\":1}}],[\"从java8开始\",{\"1\":{\"376\":1}}],[\"从已知的一个类中派生出一个新的类\",{\"1\":{\"369\":1}}],[\"从队列中删除最后一个出现的指定元素\",{\"1\":{\"201\":1}}],[\"从队列中删除第一个出现的指定元素\",{\"1\":{\"201\":1}}],[\"从集合中移除某个元素\",{\"1\":{\"180\":1}}],[\"从\",{\"1\":{\"104\":1}}],[\"从状态\",{\"1\":{\"78\":1,\"137\":1}}],[\"从状态st​到st+1​\",{\"1\":{\"13\":1}}],[\"从指定的\",{\"1\":{\"78\":1}}],[\"从此可以发现\",{\"1\":{\"77\":1}}],[\"从而确保数据的一致性和正确性\",{\"1\":{\"1267\":1}}],[\"从而降低了解决问题的复杂度\",{\"1\":{\"1115\":1}}],[\"从而主动地按需求获取丰富的信息\",{\"1\":{\"1042\":1}}],[\"从而修改我们对应的实体类\",{\"1\":{\"897\":1}}],[\"从而满足第三范式\",{\"1\":{\"738\":1}}],[\"从而将所有的验证提前到进入controller之前\",{\"1\":{\"714\":1}}],[\"从而导致攻击者能够窃取用户的敏感信息\",{\"1\":{\"643\":1}}],[\"从而直接访问你账号的任意内容\",{\"1\":{\"642\":1}}],[\"从而其它被阻塞在这个锁的线程才可以继续执行\",{\"1\":{\"313\":1}}],[\"从而可以进行近似求解\",{\"1\":{\"155\":1}}],[\"从而可以在\",{\"1\":{\"115\":1}}],[\"从而方便计算\",{\"1\":{\"142\":1}}],[\"从而使得算法可行\",{\"1\":{\"136\":1}}],[\"从而生成经验数据的策略\",{\"1\":{\"121\":1}}],[\"从而引入\",{\"1\":{\"105\":1}}],[\"从而转换为一个\",{\"1\":{\"104\":1}}],[\"从而进行多次利用\",{\"1\":{\"81\":1}}],[\"从而选择每个状态下最大的\",{\"1\":{\"77\":1}}],[\"从而减小方差\",{\"1\":{\"25\":1}}],[\"从而最大化所有用户的总mos值\",{\"1\":{\"11\":1}}],[\"从无人机n到用户kn​的信道功率增益\",{\"1\":{\"9\":1}}],[\"是给定类型的实例\",{\"1\":{\"1219\":2}}],[\"是单例还是原型\",{\"1\":{\"1171\":1}}],[\"是现代软件的开发的设计目标\",{\"1\":{\"1117\":1}}],[\"是基于\",{\"1\":{\"1094\":1}}],[\"是基于一个给定策略\",{\"1\":{\"40\":1}}],[\"是的话进行转化\",{\"1\":{\"1059\":1}}],[\"是这样描述万维网的\",{\"1\":{\"1042\":1}}],[\"是hashmap的同步加锁版\",{\"1\":{\"937\":1}}],[\"是通过添加注解来实现的\",{\"1\":{\"811\":1}}],[\"是通过一个容器来解决生产者和消费者的强耦合问题\",{\"1\":{\"331\":1}}],[\"是从1开始的\",{\"1\":{\"799\":1}}],[\"是数据库控制语言\",{\"1\":{\"744\":1}}],[\"是用来设置或更改数据库用户或角色权限的语句\",{\"1\":{\"744\":1}}],[\"是用来与环境进行交互\",{\"1\":{\"121\":1}}],[\"是用于描述数据库中要存储的现实世界实体的语言\",{\"1\":{\"744\":1}}],[\"是开发以数据为中心的应用程序必定会使用到的指令\",{\"1\":{\"744\":1}}],[\"是由tomcat帮助我们生成的一个默认响应头\",{\"1\":{\"1058\":1}}],[\"是由\",{\"1\":{\"1055\":1}}],[\"是由一批数据构成的有序集合\",{\"1\":{\"732\":1}}],[\"是由环境决定的\",{\"1\":{\"45\":1}}],[\"是获取对应流的内容\",{\"1\":{\"720\":1}}],[\"是把东西先到对应的流里\",{\"1\":{\"720\":1}}],[\"是操作系统底层提供的一项通信技术\",{\"1\":{\"718\":1}}],[\"是sql语言中\",{\"1\":{\"744\":1}}],[\"是spring3\",{\"1\":{\"602\":1}}],[\"是string类型的\",{\"1\":{\"437\":1}}],[\"是按照顺序从前向后进行拦截的\",{\"1\":{\"600\":1}}],[\"是个容器\",{\"1\":{\"512\":1}}],[\"是final类型且继承自java\",{\"1\":{\"501\":1}}],[\"是继java\",{\"1\":{\"486\":1}}],[\"是继承于arraylist\",{\"1\":{\"613\":1}}],[\"是继承\",{\"1\":{\"421\":1}}],[\"是没办法直接进行反射操作的\",{\"1\":{\"466\":1}}],[\"是某个异常的父类\",{\"1\":{\"424\":1}}],[\"是某一类事物实际存在的每个个体\",{\"1\":{\"161\":1}}],[\"是无法访问到外部类的非静态内容的\",{\"1\":{\"409\":1}}],[\"是属于类的\",{\"1\":{\"409\":1}}],[\"是可以直接拿过来用的\",{\"1\":{\"448\":1}}],[\"是可以访问到外层的变量的\",{\"1\":{\"408\":1}}],[\"是可以的\",{\"1\":{\"395\":1}}],[\"是对现实世界数据特征的一种抽象\",{\"1\":{\"733\":1}}],[\"是对象所有的\",{\"1\":{\"408\":1}}],[\"是对一类事物的描述\",{\"1\":{\"161\":1}}],[\"是匹配所有空白符\",{\"1\":{\"403\":1}}],[\"是只在代码中\",{\"1\":{\"362\":1}}],[\"是因为我们修改了构造方法\",{\"1\":{\"1134\":1}}],[\"是因为suspend\",{\"1\":{\"313\":1}}],[\"是因为集合类的实现方案有很多\",{\"1\":{\"188\":1}}],[\"是class类实例\",{\"1\":{\"312\":1}}],[\"是根据\",{\"1\":{\"241\":1}}],[\"是根据q\",{\"1\":{\"13\":1}}],[\"是直接继承自hashmap\",{\"1\":{\"218\":1}}],[\"是直接建立一个基于策略的目标函数来进行梯度上升的优化\",{\"1\":{\"147\":1}}],[\"是以键值对的形式存在\",{\"1\":{\"212\":1}}],[\"是在springboot中还会遇到的hikaricp连接池\",{\"1\":{\"1260\":1}}],[\"是在方法执行前切入还是在方法执行后切入\",{\"1\":{\"1217\":1}}],[\"是在\",{\"1\":{\"431\":1,\"432\":1}}],[\"是在一开始就确定的\",{\"1\":{\"393\":1}}],[\"是在队尾进行插入\",{\"1\":{\"200\":1}}],[\"是在基于\",{\"1\":{\"23\":1}}],[\"是为了方便日后如果我们想要更换不同的集合类实现\",{\"1\":{\"182\":1}}],[\"是为了完成某件事情而存在的\",{\"1\":{\"162\":1}}],[\"是集合类型的一个分支\",{\"1\":{\"181\":1}}],[\"是不是终于找到熟悉的味道了\",{\"1\":{\"1244\":1}}],[\"是不是开始逐渐感受到spring为我们带来的便利了\",{\"1\":{\"1133\":1}}],[\"是不是感觉特别方便\",{\"1\":{\"664\":1}}],[\"是不是感觉特别危险\",{\"1\":{\"642\":1}}],[\"是不是感觉这种类型就是专门为这种实体类而生的\",{\"1\":{\"501\":1}}],[\"是不是感觉这个工具类好像还挺好用的\",{\"1\":{\"237\":1}}],[\"是不是感觉非常方便\",{\"1\":{\"475\":1}}],[\"是不是感觉非常简洁\",{\"1\":{\"414\":1}}],[\"是不是感觉比之前的写法更优雅\",{\"1\":{\"454\":1}}],[\"是不是有点太浪费了\",{\"1\":{\"402\":1}}],[\"是不能\",{\"1\":{\"395\":1}}],[\"是不支持自动装箱和拆箱的\",{\"1\":{\"395\":1}}],[\"是不允许的\",{\"1\":{\"165\":1}}],[\"是不同的\",{\"1\":{\"40\":1,\"123\":1}}],[\"是类的一个具体化个体\",{\"1\":{\"161\":1}}],[\"是抽象的\",{\"1\":{\"161\":1}}],[\"是未知的\",{\"1\":{\"156\":1}}],[\"是各个\",{\"1\":{\"150\":1}}],[\"是我们需要进行优化的\",{\"1\":{\"148\":1}}],[\"是我们不断进行更新的策略\",{\"1\":{\"121\":1}}],[\"是qπ​\",{\"1\":{\"116\":1}}],[\"是关于\",{\"1\":{\"112\":1}}],[\"是常数\",{\"1\":{\"110\":1}}],[\"是否自动提交\",{\"1\":{\"1273\":1}}],[\"是否所有的请求都会经过此过滤器\",{\"1\":{\"1102\":1}}],[\"是否开启自动提交\",{\"1\":{\"830\":1}}],[\"是否要满足子查询中的条件表达式\",{\"1\":{\"779\":1}}],[\"是否在集合中\",{\"1\":{\"763\":1}}],[\"是否简洁\",{\"1\":{\"528\":1}}],[\"是否允许包含\",{\"1\":{\"528\":1}}],[\"是否支持增删元素\",{\"1\":{\"528\":1}}],[\"是否可变\",{\"1\":{\"528\":1}}],[\"是否可执行\",{\"1\":{\"255\":1}}],[\"是否可写\",{\"1\":{\"255\":1}}],[\"是否可读\",{\"1\":{\"255\":1}}],[\"是否为只读事务\",{\"1\":{\"1279\":1}}],[\"是否为密封\",{\"1\":{\"504\":1}}],[\"是否为一个文件夹\",{\"1\":{\"255\":1}}],[\"是否为空\",{\"1\":{\"213\":1}}],[\"是否成立\",{\"1\":{\"104\":1}}],[\"是否是收敛的\",{\"0\":{\"72\":1}}],[\"是需要被优化的参数\",{\"1\":{\"101\":1}}],[\"是第\",{\"1\":{\"97\":2}}],[\"是最顶层的类\",{\"1\":{\"372\":1}}],[\"是最优的\",{\"1\":{\"84\":1}}],[\"是最大报文长度\",{\"1\":{\"10\":1}}],[\"是针对\",{\"1\":{\"80\":1}}],[\"是针对一条trajectory所求的\",{\"1\":{\"41\":1}}],[\"是优于\",{\"1\":{\"68\":1}}],[\"是已知的\",{\"1\":{\"63\":1}}],[\"是依赖于策略π的\",{\"1\":{\"48\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"816\":1}}],[\"是一种强大\",{\"1\":{\"1196\":1}}],[\"是一种设计模式\",{\"1\":{\"1132\":1}}],[\"是一种插件化注解api\",{\"1\":{\"811\":1}}],[\"是一种常见的网络安全漏洞\",{\"1\":{\"643\":1}}],[\"是一种针对web应用程序的安全漏洞攻击\",{\"1\":{\"642\":1}}],[\"是一种轻量级的数据交换格式\",{\"1\":{\"609\":1}}],[\"是一种自动唤醒机制\",{\"1\":{\"318\":1}}],[\"是一样的\",{\"1\":{\"219\":1}}],[\"是一起删除还是只删除一个呢\",{\"1\":{\"182\":1}}],[\"是一个项目管理工具\",{\"1\":{\"1000\":1}}],[\"是一个递归调用\",{\"1\":{\"710\":1}}],[\"是一个接口\",{\"1\":{\"708\":1}}],[\"是一个收集器的工具类\",{\"1\":{\"522\":1}}],[\"是一个非负整数\",{\"1\":{\"403\":2}}],[\"是一个新创建的线程\",{\"1\":{\"324\":1}}],[\"是一个有序的集合\",{\"1\":{\"181\":1}}],[\"是一个有关状态s的函数\",{\"1\":{\"40\":1}}],[\"是一个期望值\",{\"1\":{\"101\":1}}],[\"是一个随机变量\",{\"1\":{\"101\":1}}],[\"是一个\",{\"1\":{\"97\":1,\"522\":1}}],[\"是一个黑盒\",{\"1\":{\"97\":1}}],[\"是一个必要条件\",{\"1\":{\"84\":1}}],[\"是一个contraction\",{\"1\":{\"58\":1}}],[\"是一致的\",{\"1\":{\"41\":1,\"122\":1}}],[\"是\",{\"1\":{\"40\":1,\"49\":1,\"86\":1,\"113\":1,\"123\":2,\"124\":1,\"150\":1,\"513\":1,\"872\":1,\"1000\":1,\"1053\":1,\"1181\":1}}],[\"是网页大小\",{\"1\":{\"10\":1}}],[\"是与传输速率有关的延迟时间\",{\"1\":{\"10\":1}}],[\"rust\",{\"1\":{\"1224\":2}}],[\"rust天下第一\",{\"1\":{\"1223\":1}}],[\"ruby\",{\"1\":{\"1000\":1}}],[\"runwith注解\",{\"1\":{\"1291\":1}}],[\"runable的的匿名内部类实现\",{\"1\":{\"447\":1}}],[\"runoob\",{\"1\":{\"403\":3}}],[\"running\",{\"1\":{\"378\":5}}],[\"runnable\",{\"1\":{\"296\":3,\"322\":8,\"445\":1,\"447\":3,\"501\":1,\"1225\":4}}],[\"runtime\",{\"1\":{\"363\":1,\"364\":4,\"365\":1,\"1016\":1,\"1167\":1,\"1279\":1,\"1310\":1,\"1326\":1}}],[\"runtimeexceptionruntimeexception\",{\"1\":{\"421\":1}}],[\"runtimeexception\",{\"1\":{\"267\":1,\"331\":1,\"421\":1,\"422\":3,\"423\":2,\"424\":2,\"599\":1,\"605\":1,\"625\":1,\"720\":1,\"726\":1,\"796\":1,\"1072\":1,\"1225\":2,\"1277\":1,\"1278\":1,\"1281\":1,\"1282\":1,\"1283\":1}}],[\"run方法\",{\"1\":{\"298\":1}}],[\"run\",{\"1\":{\"135\":1,\"296\":2,\"322\":2,\"323\":1,\"324\":2,\"445\":1,\"447\":1,\"501\":1,\"1225\":1}}],[\"right\",{\"1\":{\"769\":1}}],[\"rˉπ​\",{\"1\":{\"155\":1}}],[\"rˉπ​​\",{\"1\":{\"154\":1}}],[\"rˉπ​=s∈s∑​dπ​\",{\"1\":{\"153\":1}}],[\"r1​\",{\"1\":{\"112\":1}}],[\"rk​+γv\",{\"1\":{\"110\":1}}],[\"rkn​​mss​\",{\"1\":{\"10\":1}}],[\"rkn​​\",{\"1\":{\"10\":3}}],[\"r→r\",{\"1\":{\"96\":1}}],[\"rm\",{\"0\":{\"95\":1},\"1\":{\"97\":1,\"99\":1,\"104\":3,\"110\":2}}],[\"roll\",{\"1\":{\"1246\":1}}],[\"rollbackfor和norollbackfor\",{\"1\":{\"1279\":1}}],[\"rollbackforclassname\",{\"1\":{\"1279\":1}}],[\"rollbackfor\",{\"1\":{\"1279\":1}}],[\"rollback\",{\"1\":{\"782\":3,\"806\":3,\"865\":1,\"1246\":2,\"1247\":2,\"1272\":2,\"1273\":1}}],[\"rolename=\",{\"1\":{\"1047\":2}}],[\"role\",{\"1\":{\"692\":1,\"698\":1,\"1047\":4}}],[\"roles=\",{\"1\":{\"1047\":2}}],[\"roles\",{\"1\":{\"658\":2,\"659\":2,\"664\":1,\"692\":1,\"1047\":3}}],[\"row\",{\"1\":{\"781\":2,\"852\":2}}],[\"roundingmode是舍入模式\",{\"1\":{\"386\":1}}],[\"roundingmode\",{\"1\":{\"386\":1}}],[\"robbins\",{\"0\":{\"95\":1},\"1\":{\"98\":2}}],[\"rootbeandefinition\",{\"1\":{\"1296\":1,\"1298\":3,\"1300\":1,\"1301\":1,\"1311\":2,\"1321\":1}}],[\"rootlogger\",{\"1\":{\"939\":2,\"951\":2}}],[\"rootnode\",{\"1\":{\"819\":2}}],[\"rootappcontext\",{\"1\":{\"705\":3}}],[\"rootcontext\",{\"1\":{\"625\":3}}],[\"root\",{\"1\":{\"92\":1,\"98\":1,\"104\":1,\"110\":1,\"664\":1,\"788\":1,\"796\":1,\"1255\":1,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"r+s\",{\"1\":{\"66\":2}}],[\"r+γa∈a\",{\"1\":{\"141\":1,\"142\":3}}],[\"r+γqπ​\",{\"1\":{\"115\":1}}],[\"r+γg∣s=s\",{\"1\":{\"113\":1}}],[\"r+γv\",{\"1\":{\"110\":6}}],[\"r+γ∑s\",{\"1\":{\"48\":1}}],[\"r+γs\",{\"1\":{\"45\":1,\"48\":1,\"55\":1,\"63\":1}}],[\"rπ​+γpπ​v1​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ1​​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ0​​\",{\"1\":{\"70\":2}}],[\"rπ​+γpπ​vπk​​\",{\"1\":{\"66\":1,\"70\":1,\"77\":1}}],[\"rπ​+γpπ​vk​\",{\"1\":{\"62\":1,\"63\":1,\"70\":1}}],[\"rπ​+γpπ​v\",{\"1\":{\"55\":1,\"58\":1,\"61\":1}}],[\"rπ​\",{\"1\":{\"46\":2,\"153\":4,\"154\":1}}],[\"rπ​=\",{\"1\":{\"46\":1}}],[\"r​​+mean\",{\"1\":{\"45\":1}}],[\"r​\",{\"1\":{\"43\":1}}],[\"r∑​p\",{\"1\":{\"43\":1,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"rl9\",{\"0\":{\"147\":1}}],[\"rl8\",{\"0\":{\"130\":1}}],[\"rl7\",{\"0\":{\"109\":1}}],[\"rl\",{\"1\":{\"92\":1}}],[\"rl6\",{\"0\":{\"92\":1}}],[\"rl5\",{\"0\":{\"75\":1}}],[\"rl4\",{\"0\":{\"61\":1}}],[\"rl3\",{\"0\":{\"52\":1}}],[\"rl2\",{\"0\":{\"36\":1}}],[\"rl10\",{\"0\":{\"23\":1}}],[\"rl1\",{\"0\":{\"17\":1}}],[\"r∣s\",{\"1\":{\"20\":1,\"41\":1,\"43\":1,\"45\":3,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"153\":2}}],[\"r\",{\"1\":{\"20\":3,\"110\":3,\"141\":1,\"142\":1,\"153\":3,\"403\":2,\"519\":1,\"727\":2}}],[\"raised\",{\"1\":{\"789\":1,\"1181\":1}}],[\"rawtypes\",{\"1\":{\"181\":1,\"217\":1}}],[\"rate\",{\"1\":{\"19\":1,\"39\":1,\"58\":1}}],[\"randomnumber\",{\"1\":{\"1211\":1}}],[\"random是一个随机数工具类\",{\"1\":{\"228\":1}}],[\"random支持直接生成随机数的流\",{\"1\":{\"228\":1}}],[\"randomaccess\",{\"1\":{\"182\":1}}],[\"random\",{\"1\":{\"14\":2,\"42\":1,\"228\":8,\"431\":6,\"963\":4,\"987\":1,\"990\":4,\"1205\":1,\"1211\":1}}],[\"r=1∣s1​\",{\"1\":{\"19\":1}}],[\"reentrantlock\",{\"1\":{\"1245\":1,\"1246\":1}}],[\"reraise\",{\"1\":{\"789\":1}}],[\"revoke\",{\"1\":{\"774\":1}}],[\"revoke等\",{\"1\":{\"744\":1}}],[\"recompiling\",{\"1\":{\"1181\":1}}],[\"record抽象类\",{\"1\":{\"501\":1}}],[\"record\",{\"1\":{\"501\":3,\"944\":5,\"948\":5,\"1148\":1,\"1209\":1}}],[\"receiver\",{\"1\":{\"720\":1}}],[\"req\",{\"1\":{\"708\":4,\"1059\":20,\"1064\":1,\"1069\":2,\"1072\":4,\"1074\":1,\"1075\":2,\"1076\":1,\"1083\":8,\"1084\":1,\"1091\":1,\"1093\":4,\"1096\":2,\"1104\":9}}],[\"requested\",{\"1\":{\"1181\":1}}],[\"requests\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"requestscope\",{\"1\":{\"588\":1}}],[\"requestscope或是\",{\"1\":{\"588\":1}}],[\"requestcount\",{\"1\":{\"1246\":1}}],[\"requestcontextholder\",{\"1\":{\"626\":1}}],[\"requestcacheawarefilter\",{\"1\":{\"714\":1}}],[\"requestrejectedhandler\",{\"1\":{\"709\":1}}],[\"requestline\",{\"1\":{\"708\":4,\"710\":1}}],[\"requestbindinginterceptor\",{\"1\":{\"626\":1}}],[\"requestbody\",{\"1\":{\"617\":1}}],[\"requestbody注解\",{\"1\":{\"617\":1}}],[\"requestattributes\",{\"1\":{\"626\":3}}],[\"requestheader与\",{\"1\":{\"583\":1}}],[\"requestheader详解\",{\"0\":{\"578\":1}}],[\"requestparam用法一致\",{\"1\":{\"583\":1}}],[\"requestparam也能获取到参数值\",{\"1\":{\"579\":1}}],[\"requestparam中填写参数名称\",{\"1\":{\"579\":1}}],[\"requestparam注解即可\",{\"1\":{\"579\":1}}],[\"requestparam和\",{\"0\":{\"578\":1}}],[\"requestparam\",{\"1\":{\"575\":2,\"579\":1,\"580\":2,\"581\":1,\"619\":1,\"636\":3,\"658\":1,\"666\":2}}],[\"requestmatchers\",{\"1\":{\"681\":1,\"692\":2,\"693\":1}}],[\"requestmapping添加到类名上\",{\"1\":{\"569\":1}}],[\"requestmapping即可实现\",{\"1\":{\"569\":1}}],[\"requestmapping详解\",{\"0\":{\"569\":1}}],[\"requestmapping\",{\"1\":{\"549\":1,\"554\":1,\"561\":1,\"563\":3,\"569\":4,\"571\":3,\"572\":1,\"574\":3,\"575\":2,\"576\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":1,\"586\":1,\"587\":4,\"588\":1,\"589\":6,\"599\":1,\"605\":1,\"612\":1,\"613\":1,\"615\":1,\"616\":1,\"619\":1,\"620\":1,\"697\":1,\"699\":1}}],[\"requestmethod\",{\"1\":{\"569\":1,\"572\":1,\"589\":4,\"619\":1,\"620\":1}}],[\"request\",{\"1\":{\"490\":4,\"575\":2,\"582\":1,\"588\":1,\"595\":3,\"600\":4,\"626\":20,\"641\":1,\"707\":4,\"708\":5,\"710\":3,\"711\":11,\"712\":3,\"713\":4,\"1057\":6,\"1059\":3,\"1102\":2,\"1104\":1}}],[\"requiredtype\",{\"1\":{\"1300\":3}}],[\"requiredargsconstructor\",{\"1\":{\"812\":1}}],[\"requiredargsconstructor来快速生成参数只包含final或被标记为\",{\"1\":{\"812\":1}}],[\"requiredproperties\",{\"1\":{\"625\":1}}],[\"required\",{\"1\":{\"580\":1,\"581\":1,\"585\":1,\"586\":1,\"1047\":2,\"1279\":1,\"1281\":1}}],[\"requiresauthentication\",{\"1\":{\"711\":1}}],[\"requires\",{\"1\":{\"461\":2,\"464\":1,\"465\":2,\"467\":1,\"468\":2}}],[\"requirenonnull\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1,\"509\":1}}],[\"remember\",{\"1\":{\"686\":2,\"687\":1,\"789\":1,\"1093\":2}}],[\"remembermeauthenticationfilter\",{\"1\":{\"714\":1}}],[\"remembermeservices\",{\"1\":{\"712\":1,\"713\":1}}],[\"remembermecookiename\",{\"1\":{\"686\":1}}],[\"remembermeparameter\",{\"1\":{\"686\":1,\"687\":1}}],[\"rememberme\",{\"1\":{\"686\":1,\"687\":1}}],[\"removing\",{\"1\":{\"324\":1}}],[\"removelastoccurrence\",{\"1\":{\"201\":1}}],[\"removelast\",{\"1\":{\"201\":1}}],[\"removefirstoccurrence\",{\"1\":{\"201\":1}}],[\"removefirst\",{\"1\":{\"201\":1}}],[\"removed\",{\"1\":{\"180\":3}}],[\"removeif\",{\"1\":{\"180\":1}}],[\"removeall\",{\"1\":{\"180\":1,\"204\":1}}],[\"remove\",{\"1\":{\"180\":2,\"181\":1,\"182\":4,\"189\":3,\"194\":1,\"200\":1,\"204\":1,\"205\":1,\"213\":1,\"223\":2,\"241\":2,\"350\":1,\"528\":2,\"1246\":2,\"1247\":1,\"1301\":1}}],[\"redirect\",{\"1\":{\"587\":2,\"636\":1}}],[\"reduce1\",{\"1\":{\"521\":2}}],[\"reducestreamdemo\",{\"1\":{\"521\":1}}],[\"reduce\",{\"1\":{\"228\":1,\"521\":9}}],[\"release\",{\"1\":{\"1148\":2}}],[\"release<\",{\"1\":{\"559\":1}}],[\"relayed\",{\"1\":{\"509\":1}}],[\"realconnection\",{\"1\":{\"1247\":2}}],[\"reason\",{\"1\":{\"789\":6}}],[\"reaction\",{\"1\":{\"525\":1}}],[\"readystate\",{\"1\":{\"1076\":1}}],[\"readconfiguration\",{\"1\":{\"939\":1}}],[\"readwrite\",{\"1\":{\"903\":1}}],[\"readonly\",{\"1\":{\"884\":1,\"1279\":2}}],[\"readonly=\",{\"1\":{\"884\":1}}],[\"readobject\",{\"1\":{\"288\":1,\"290\":1}}],[\"readboolean\",{\"1\":{\"286\":1}}],[\"readline\",{\"1\":{\"269\":1,\"720\":3}}],[\"readlimit\",{\"1\":{\"265\":2}}],[\"read\",{\"1\":{\"248\":5,\"251\":1,\"253\":2,\"262\":1,\"265\":8,\"269\":1,\"283\":1,\"356\":1,\"480\":1,\"490\":1,\"721\":1,\"726\":2,\"727\":1,\"782\":3,\"1267\":3}}],[\"reader\",{\"1\":{\"245\":1,\"253\":5,\"269\":6,\"270\":4,\"283\":2,\"720\":4,\"1296\":2,\"1297\":3,\"1318\":2,\"1319\":1}}],[\"region\",{\"1\":{\"1211\":1}}],[\"registerlisteners\",{\"1\":{\"1320\":1}}],[\"registerbeanpostprocessors\",{\"1\":{\"1320\":1}}],[\"registerbeandefinitions\",{\"1\":{\"1310\":1,\"1311\":1,\"1326\":1}}],[\"registerbeandefinition\",{\"1\":{\"1296\":1,\"1298\":3,\"1311\":2}}],[\"registerannotationconfigprocessors\",{\"1\":{\"1318\":1}}],[\"registeraspectjannotationautoproxycreatorifnecessary\",{\"1\":{\"1310\":1}}],[\"registeraliases\",{\"1\":{\"904\":1}}],[\"register=fri\",{\"1\":{\"852\":1}}],[\"registerdriver\",{\"1\":{\"789\":2}}],[\"registereddrivers\",{\"1\":{\"789\":3,\"1244\":1}}],[\"registered\",{\"1\":{\"788\":1}}],[\"registerfilters\",{\"1\":{\"1327\":1}}],[\"registerfilter\",{\"1\":{\"705\":1}}],[\"register\",{\"1\":{\"705\":1,\"789\":1,\"849\":1,\"850\":2,\"852\":1,\"1317\":1,\"1319\":3}}],[\"registercomponentclass\",{\"1\":{\"1319\":2}}],[\"registercallableinterceptor\",{\"1\":{\"626\":1}}],[\"registercustomeditor\",{\"1\":{\"625\":1}}],[\"registernatives\",{\"1\":{\"372\":2}}],[\"registration\",{\"1\":{\"619\":2}}],[\"registry\",{\"1\":{\"564\":2,\"596\":2,\"600\":3,\"601\":3,\"678\":2,\"1310\":4,\"1311\":4,\"1318\":6,\"1326\":1,\"1327\":2}}],[\"regardless\",{\"1\":{\"1148\":1}}],[\"regexp\",{\"1\":{\"403\":2}}],[\"regular\",{\"1\":{\"403\":1}}],[\"ref指向我们刚刚创建的切点\",{\"1\":{\"1220\":1}}],[\"ref\",{\"1\":{\"1211\":1}}],[\"refresh\",{\"1\":{\"1181\":2,\"1296\":1,\"1317\":1,\"1320\":2}}],[\"refresheventreceived\",{\"1\":{\"625\":1}}],[\"ref属性表示赋给这个属性的值来自另一个对应的bean注册对象中\",{\"1\":{\"1133\":1}}],[\"ref=\",{\"1\":{\"1133\":2,\"1134\":1,\"1137\":1,\"1172\":1,\"1220\":3,\"1224\":2,\"1225\":2,\"1231\":2}}],[\"reflectivemethodinvocation\",{\"1\":{\"1278\":2,\"1283\":2}}],[\"reflectiveoperationexception\",{\"1\":{\"349\":2,\"350\":2,\"799\":1}}],[\"reflectiveobjects\",{\"1\":{\"343\":1}}],[\"reflection\",{\"1\":{\"789\":1}}],[\"reflect\",{\"1\":{\"343\":1,\"1278\":4}}],[\"reference\",{\"1\":{\"1113\":1,\"1148\":1,\"1181\":1,\"1211\":1,\"1219\":1,\"1300\":1}}],[\"references\",{\"1\":{\"324\":1,\"662\":1,\"747\":1,\"748\":1}}],[\"referer\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"refers\",{\"1\":{\"92\":1}}],[\"re\",{\"1\":{\"324\":1}}],[\"retrieve\",{\"1\":{\"744\":1}}],[\"retry\",{\"1\":{\"264\":1}}],[\"retention和1\",{\"1\":{\"363\":1}}],[\"retention表示此注解的保留策略\",{\"1\":{\"363\":1}}],[\"retentionpolicy\",{\"1\":{\"363\":2,\"364\":4,\"365\":2,\"1167\":1,\"1279\":1,\"1310\":1,\"1326\":1}}],[\"retention\",{\"1\":{\"362\":1,\"363\":2,\"364\":4,\"365\":2,\"1167\":1,\"1279\":1,\"1310\":1,\"1326\":1}}],[\"retainall\",{\"1\":{\"180\":1,\"204\":1}}],[\"returnval\",{\"1\":{\"1236\":3}}],[\"returnvalue\",{\"1\":{\"1231\":1}}],[\"returned\",{\"1\":{\"852\":1,\"1246\":3,\"1247\":1}}],[\"returning\",{\"1\":{\"789\":1,\"1236\":1,\"1300\":2}}],[\"returns\",{\"1\":{\"41\":1,\"509\":1}}],[\"return为\",{\"1\":{\"39\":1}}],[\"return的描述\",{\"1\":{\"39\":1}}],[\"return越短视\",{\"1\":{\"19\":1}}],[\"return\",{\"0\":{\"41\":1,\"153\":1},\"1\":{\"19\":2,\"39\":1,\"41\":3,\"42\":1,\"48\":2,\"78\":1,\"82\":1,\"113\":1,\"137\":1,\"164\":1,\"165\":2,\"171\":3,\"172\":1,\"180\":4,\"182\":3,\"190\":2,\"193\":4,\"204\":1,\"216\":3,\"217\":1,\"221\":3,\"222\":3,\"224\":3,\"241\":7,\"264\":1,\"330\":1,\"340\":1,\"356\":1,\"372\":2,\"373\":3,\"377\":1,\"378\":2,\"384\":2,\"414\":2,\"415\":1,\"423\":2,\"439\":2,\"447\":3,\"448\":1,\"449\":2,\"451\":3,\"452\":1,\"464\":1,\"480\":1,\"495\":2,\"496\":1,\"499\":4,\"509\":2,\"512\":1,\"516\":1,\"522\":1,\"523\":4,\"524\":4,\"525\":5,\"531\":2,\"549\":1,\"552\":3,\"554\":1,\"560\":3,\"561\":1,\"563\":3,\"569\":2,\"572\":1,\"573\":1,\"574\":3,\"575\":2,\"576\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":1,\"586\":1,\"587\":4,\"588\":2,\"589\":6,\"595\":1,\"599\":1,\"600\":2,\"605\":2,\"612\":1,\"613\":1,\"615\":1,\"616\":1,\"617\":2,\"619\":1,\"625\":1,\"626\":4,\"636\":5,\"652\":1,\"658\":3,\"659\":2,\"664\":3,\"666\":3,\"668\":1,\"671\":1,\"672\":1,\"679\":2,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"687\":1,\"692\":1,\"695\":1,\"697\":1,\"699\":1,\"706\":1,\"708\":2,\"709\":2,\"710\":1,\"711\":1,\"789\":2,\"799\":2,\"810\":3,\"830\":2,\"902\":1,\"904\":1,\"944\":2,\"948\":1,\"972\":3,\"980\":2,\"994\":1,\"1054\":2,\"1093\":1,\"1096\":1,\"1104\":1,\"1116\":1,\"1117\":1,\"1157\":1,\"1159\":1,\"1160\":3,\"1167\":1,\"1170\":1,\"1171\":1,\"1172\":2,\"1174\":2,\"1178\":1,\"1180\":3,\"1203\":1,\"1224\":3,\"1231\":2,\"1236\":1,\"1237\":1,\"1242\":2,\"1244\":4,\"1245\":2,\"1246\":1,\"1247\":3,\"1254\":1,\"1259\":2,\"1260\":1,\"1273\":1,\"1276\":3,\"1296\":1,\"1300\":2,\"1301\":2,\"1307\":4,\"1327\":3,\"1328\":3}}],[\"reinforce\",{\"0\":{\"156\":1,\"157\":1},\"1\":{\"156\":1}}],[\"reinforcement\",{\"0\":{\"3\":1}}],[\"repository\",{\"1\":{\"687\":5,\"1010\":1}}],[\"repeatedtest\",{\"1\":{\"990\":1,\"1017\":1}}],[\"repeat\",{\"1\":{\"488\":2}}],[\"repeatable\",{\"1\":{\"362\":1,\"782\":1,\"1267\":1,\"1326\":1}}],[\"representing\",{\"1\":{\"340\":1}}],[\"representation\",{\"1\":{\"130\":2}}],[\"replaceunderscores\",{\"1\":{\"962\":1}}],[\"replace\",{\"1\":{\"223\":2}}],[\"replace方法可以快速替换某个映射的值\",{\"1\":{\"223\":1}}],[\"replaceall\",{\"1\":{\"181\":1}}],[\"replay\",{\"0\":{\"143\":1},\"1\":{\"142\":1}}],[\"restrict|cascade\",{\"1\":{\"751\":1,\"752\":1}}],[\"restcontroller表示此controller默认返回的是字符串数据\",{\"1\":{\"615\":1}}],[\"restcontrolleradvice\",{\"1\":{\"604\":1}}],[\"restcontroller\",{\"1\":{\"603\":1}}],[\"restful风格的设计允许将参数通过url拼接传到服务端\",{\"1\":{\"589\":1}}],[\"restful风格\",{\"0\":{\"589\":1}}],[\"resolver\",{\"1\":{\"560\":12}}],[\"resourcepatternresolver\",{\"1\":{\"1316\":1}}],[\"resource注解\",{\"1\":{\"1175\":1}}],[\"resource的匹配机制更加合理高效\",{\"1\":{\"1175\":1}}],[\"resource默认byname如果找不到则bytype\",{\"1\":{\"1175\":1}}],[\"resource这个注解\",{\"1\":{\"1175\":1}}],[\"resource=\",{\"1\":{\"842\":1,\"1124\":1}}],[\"resources目录\",{\"1\":{\"1001\":1}}],[\"resources\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1072\":1,\"1074\":2,\"1148\":2,\"1254\":1}}],[\"resourceeditor\",{\"1\":{\"625\":1}}],[\"resourceloader\",{\"1\":{\"625\":3}}],[\"resourcehandlerregistry\",{\"1\":{\"564\":1,\"678\":1}}],[\"resource\",{\"1\":{\"249\":1,\"547\":1,\"588\":1,\"625\":1,\"672\":1,\"824\":2,\"1175\":3,\"1181\":2,\"1277\":1,\"1281\":1,\"1297\":1}}],[\"resource语法会自动帮助我们close\",{\"1\":{\"788\":1}}],[\"resource语法现在不需要再完整的声明一个变量了\",{\"1\":{\"480\":1}}],[\"resource语法\",{\"1\":{\"247\":1}}],[\"res\",{\"1\":{\"495\":6,\"497\":3,\"708\":4,\"804\":3,\"805\":3,\"1059\":3,\"1104\":8}}],[\"resp\",{\"1\":{\"1059\":19,\"1064\":3,\"1069\":1,\"1072\":5,\"1074\":5,\"1075\":3,\"1076\":3,\"1082\":4,\"1083\":4,\"1084\":2,\"1091\":2,\"1093\":5,\"1096\":1}}],[\"responsetext\",{\"1\":{\"1076\":1}}],[\"responsebody表示方法返回\",{\"1\":{\"615\":1}}],[\"responsebody\",{\"1\":{\"549\":1,\"554\":1,\"604\":1,\"615\":1,\"616\":1,\"617\":2,\"619\":1,\"620\":1,\"636\":1,\"658\":1,\"666\":1}}],[\"response\",{\"1\":{\"490\":5,\"585\":2,\"595\":3,\"600\":4,\"620\":3,\"626\":19,\"707\":4,\"708\":4,\"710\":3,\"711\":11,\"712\":3,\"713\":3,\"1058\":3,\"1059\":3,\"1104\":1}}],[\"respect\",{\"1\":{\"19\":1}}],[\"reserve\",{\"1\":{\"452\":2}}],[\"resetcommoncaches\",{\"1\":{\"1320\":1}}],[\"reset\",{\"1\":{\"265\":5,\"708\":8,\"710\":1,\"1242\":1}}],[\"result注解时\",{\"1\":{\"901\":1}}],[\"results\",{\"1\":{\"898\":1,\"901\":1}}],[\"results注解来实现这种操作\",{\"1\":{\"898\":1}}],[\"resultset\",{\"1\":{\"788\":1,\"799\":1,\"804\":1,\"805\":1}}],[\"resultmap\",{\"1\":{\"899\":1}}],[\"resultmap>\",{\"1\":{\"835\":1,\"841\":1,\"849\":1,\"850\":1,\"851\":1,\"853\":1,\"854\":1,\"855\":2,\"898\":1}}],[\"resultmap=\",{\"1\":{\"835\":1,\"841\":1,\"849\":1,\"851\":1,\"854\":1,\"855\":2}}],[\"resulttype无需设置为list这种类型\",{\"1\":{\"836\":1}}],[\"resulttype指定为我们刚刚定义的实体类\",{\"1\":{\"826\":1}}],[\"resulttype=\",{\"1\":{\"826\":1,\"831\":1,\"833\":1,\"834\":1,\"836\":2,\"842\":3,\"843\":1,\"851\":1,\"854\":1,\"855\":1,\"873\":1,\"874\":1,\"886\":1,\"887\":1,\"895\":1,\"902\":1}}],[\"result4\",{\"1\":{\"524\":1}}],[\"result3\",{\"1\":{\"524\":1}}],[\"result2\",{\"1\":{\"523\":4}}],[\"result1\",{\"1\":{\"523\":1}}],[\"result<>\",{\"1\":{\"523\":2}}],[\"result<string>\",{\"1\":{\"523\":2,\"524\":2}}],[\"result<t>\",{\"1\":{\"523\":1}}],[\"result\",{\"1\":{\"402\":2,\"523\":3,\"524\":6,\"898\":2,\"901\":2}}],[\"resulting\",{\"1\":{\"19\":1}}],[\"resize\",{\"0\":{\"217\":1},\"1\":{\"216\":2,\"217\":2}}],[\"rewards\",{\"0\":{\"43\":1,\"44\":1},\"1\":{\"20\":1,\"45\":2,\"154\":1}}],[\"reward\",{\"1\":{\"13\":1,\"19\":2,\"20\":2,\"115\":1,\"154\":1}}],[\"rt\",{\"1\":{\"789\":1}}],[\"rt+2​\",{\"1\":{\"154\":1}}],[\"rt+2​+γrt+3​+\",{\"1\":{\"42\":1}}],[\"rt+1​+rt+2​+⋯+rt+n​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"rt+1​+γq^​\",{\"1\":{\"139\":1}}],[\"rt+1​+γqt​\",{\"1\":{\"116\":1}}],[\"rt+1​+γv^\",{\"1\":{\"138\":2}}],[\"rt+1​+γvt​\",{\"1\":{\"112\":2}}],[\"rt+1​+γa∈a\",{\"1\":{\"140\":1}}],[\"rt+1​+γa∈amax​qt​\",{\"1\":{\"120\":1}}],[\"rt+1​+γamax​q\",{\"1\":{\"119\":1}}],[\"rt+1​+γgt+1​∣st​=s\",{\"1\":{\"42\":1}}],[\"rt+1​\",{\"1\":{\"112\":2,\"116\":1,\"154\":1}}],[\"rt+1​∣st​=s\",{\"1\":{\"42\":2,\"43\":2,\"45\":1}}],[\"rt+1​∣at+1​\",{\"1\":{\"20\":1}}],[\"rt​∣st​\",{\"1\":{\"13\":1}}],[\"rtt\",{\"1\":{\"10\":1}}],[\"595\",{\"1\":{\"1283\":1}}],[\"568\",{\"1\":{\"1278\":1}}],[\"5以上\",{\"1\":{\"1253\":1}}],[\"54\",{\"1\":{\"1096\":1}}],[\"57\",{\"1\":{\"929\":2,\"1181\":1}}],[\"55\",{\"1\":{\"908\":1}}],[\"5555\",{\"1\":{\"385\":1}}],[\"512\",{\"1\":{\"884\":1,\"903\":1}}],[\"537\",{\"1\":{\"727\":2,\"1091\":2,\"1096\":2}}],[\"58bb2c14571a\",{\"1\":{\"660\":1}}],[\"5新增了泛型\",{\"1\":{\"437\":1}}],[\"5个变量连续加\",{\"1\":{\"402\":1}}],[\"501\",{\"1\":{\"1059\":1}}],[\"500\",{\"1\":{\"323\":1,\"604\":1,\"605\":2,\"662\":1,\"910\":1}}],[\"50\",{\"1\":{\"222\":1,\"299\":1,\"304\":2,\"305\":2,\"318\":1,\"662\":3,\"748\":2,\"1091\":1}}],[\"5倍\",{\"1\":{\"182\":1}}],[\"5\",{\"0\":{\"49\":1,\"127\":1,\"141\":1,\"1164\":1,\"1348\":1,\"1357\":1},\"1\":{\"10\":3,\"70\":1,\"171\":3,\"203\":5,\"235\":1,\"236\":1,\"237\":4,\"304\":1,\"329\":2,\"330\":2,\"397\":1,\"398\":1,\"431\":1,\"432\":1,\"437\":2,\"449\":2,\"451\":2,\"452\":1,\"545\":2,\"663\":1,\"680\":1,\"727\":1,\"788\":1,\"871\":1,\"876\":3,\"969\":1,\"1017\":1,\"1024\":1,\"1033\":1,\"1071\":1,\"1091\":1,\"1096\":1,\"1136\":1,\"1208\":1,\"1245\":1,\"1253\":1}}],[\"43\",{\"1\":{\"1278\":1}}],[\"4k高清无码\",{\"1\":{\"1018\":1}}],[\"4kmeinv\",{\"1\":{\"490\":1}}],[\"4606\",{\"1\":{\"727\":1}}],[\"44e3\",{\"1\":{\"660\":1}}],[\"400\",{\"1\":{\"910\":1}}],[\"4000\",{\"1\":{\"331\":1}}],[\"403这种错误时\",{\"1\":{\"660\":1}}],[\"403\",{\"0\":{\"660\":1}}],[\"404\",{\"1\":{\"524\":2,\"1331\":1}}],[\"41\",{\"1\":{\"222\":1}}],[\"4\",{\"0\":{\"33\":1,\"46\":1,\"48\":1,\"84\":1,\"99\":1,\"106\":1,\"119\":1,\"120\":1,\"121\":1,\"124\":1,\"140\":1,\"156\":1,\"210\":1,\"211\":1,\"419\":1,\"778\":1,\"1156\":1,\"1347\":1,\"1356\":1},\"1\":{\"10\":1,\"70\":1,\"171\":3,\"203\":5,\"228\":1,\"235\":1,\"236\":1,\"237\":4,\"330\":2,\"396\":3,\"397\":1,\"402\":1,\"431\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"660\":1,\"788\":1,\"796\":2,\"876\":2,\"968\":1,\"1002\":3,\"1023\":3,\"1032\":3,\"1076\":1,\"1208\":2,\"1209\":1,\"1278\":1}}],[\"可选依赖\",{\"0\":{\"1025\":1}}],[\"可见单元测试对于开发的重要性\",{\"1\":{\"956\":1}}],[\"可见\",{\"1\":{\"871\":1,\"883\":1,\"918\":1}}],[\"可见性\",{\"1\":{\"278\":1}}],[\"可重复读\",{\"1\":{\"782\":1,\"1267\":1}}],[\"可对controller进行增强处理\",{\"1\":{\"602\":1}}],[\"可变\",{\"1\":{\"528\":1}}],[\"可变长参数\",{\"0\":{\"398\":1}}],[\"可访问性的控制\",{\"1\":{\"461\":1}}],[\"可是消费者消费的产品是生产者生产的\",{\"1\":{\"331\":1}}],[\"可拆分迭代器\",{\"1\":{\"330\":1}}],[\"可运行\",{\"1\":{\"300\":1}}],[\"可写可不写\",{\"1\":{\"277\":1}}],[\"可能是配置类\",{\"1\":{\"1296\":1}}],[\"可能是链式存储\",{\"1\":{\"188\":1}}],[\"可能需要在访问对象的方法或属性之前验证它是否为空\",{\"1\":{\"1211\":1}}],[\"可能还会出现这样的信息\",{\"1\":{\"1188\":1}}],[\"可能还是得我们自己编写一个自定义的formatter才行\",{\"1\":{\"951\":1}}],[\"可能某些工厂类需要构造出对象之后才能使用\",{\"1\":{\"1159\":1}}],[\"可能我们并不希望某些依赖直接被项目连带引入\",{\"1\":{\"1025\":1}}],[\"可能我们并不想开启其中某个测试用例\",{\"1\":{\"960\":1}}],[\"可能在导入依赖时会出现卡顿等问题\",{\"1\":{\"1010\":1}}],[\"可能有许多事务会同时处理相同的数据\",{\"1\":{\"1266\":1}}],[\"可能有很多个名字为test的标签\",{\"1\":{\"819\":1}}],[\"可能有些库并不是java\",{\"1\":{\"463\":1}}],[\"可能最不理解的就是这里\",{\"1\":{\"710\":1}}],[\"可能并不是所有的类我们都希望能够被继承\",{\"1\":{\"503\":1}}],[\"可能给进来的a或是b为null\",{\"1\":{\"500\":1}}],[\"可能字符串中包含了很多需要转义的字符\",{\"1\":{\"498\":1}}],[\"可能高等数学这门课是以数字成绩进行结算\",{\"1\":{\"437\":1}}],[\"可能会一个一个地提交\",{\"1\":{\"871\":1}}],[\"可能会在\",{\"1\":{\"714\":1}}],[\"可能会根据用户当前是身份进行角色划分\",{\"1\":{\"691\":1}}],[\"可能会有小伙伴觉得\",{\"1\":{\"684\":1}}],[\"可能会有小伙伴发现\",{\"1\":{\"660\":1}}],[\"可能会发现新版本的配置方式完全不一样\",{\"1\":{\"680\":1}}],[\"可能会同时拿到同样的值\",{\"1\":{\"311\":1}}],[\"可能会创建各种各样的类\",{\"1\":{\"277\":1}}],[\"可能会出现一些莫名其妙的红标\",{\"1\":{\"902\":1}}],[\"可能会出现各自的缓存内容不同步的问题\",{\"1\":{\"888\":1}}],[\"可能会出现无法预知的错误\",{\"1\":{\"349\":1}}],[\"可能会出现\",{\"1\":{\"247\":1}}],[\"可能会是乱序的\",{\"1\":{\"214\":1}}],[\"可知\",{\"1\":{\"9\":1}}],[\"可以尝试获取一下\",{\"1\":{\"1296\":1}}],[\"可以生产什么\",{\"1\":{\"1296\":1}}],[\"可以向数据源申请\",{\"1\":{\"1242\":1}}],[\"可以快速扫描出整个包下的类定义信息\",{\"1\":{\"1327\":1}}],[\"可以快速得到传入的参数\",{\"1\":{\"1235\":1}}],[\"可以快速得到原方法的参数\",{\"1\":{\"1235\":1}}],[\"可以快速完成导入\",{\"1\":{\"1000\":1}}],[\"可以插入增强处理的连接点\",{\"1\":{\"1226\":1}}],[\"可以使得我们的代码更加清爽和优美\",{\"1\":{\"1224\":1}}],[\"可以使用简单的\",{\"1\":{\"816\":1}}],[\"可以使用官方提供的bcrypt加密工具\",{\"1\":{\"659\":1}}],[\"可以使用\",{\"1\":{\"516\":1,\"528\":1,\"1219\":1}}],[\"可以使用方括号\",{\"1\":{\"403\":1}}],[\"可以说\",{\"1\":{\"1215\":1}}],[\"可以说极大地方便了我们的编码\",{\"1\":{\"497\":1}}],[\"可以获取相应资源\",{\"1\":{\"1186\":1}}],[\"可以获取到父类的class对象\",{\"1\":{\"343\":1}}],[\"可以让我们能够插手bean\",{\"1\":{\"1306\":1}}],[\"可以让\",{\"1\":{\"1181\":1}}],[\"可以让你以一种声明的方式处理数据\",{\"1\":{\"228\":1}}],[\"可以添加在构造方法\",{\"1\":{\"1175\":1}}],[\"可以添加到set方法\",{\"1\":{\"1175\":1}}],[\"可以由ioc容器来选择一个合适的teacher对象进行赋值\",{\"1\":{\"1132\":1}}],[\"可以由我们自己指定排序规则\",{\"1\":{\"449\":1}}],[\"可以想象一下\",{\"1\":{\"1132\":1,\"1165\":1}}],[\"可以访问该cookie的域名\",{\"1\":{\"1092\":1}}],[\"可以访问所有其他模块提供的类\",{\"1\":{\"463\":1}}],[\"可以动态显示\",{\"1\":{\"1076\":1}}],[\"可以一直使用\",{\"1\":{\"1010\":1}}],[\"可以一次直接读取全部数据\",{\"1\":{\"248\":1}}],[\"可以配置idea自带的maven插件远程仓库镜像地址\",{\"1\":{\"1010\":1}}],[\"可以帮助我们做\",{\"1\":{\"1000\":1}}],[\"可以实现批量操作\",{\"1\":{\"875\":1}}],[\"可以实现各种各样的效果\",{\"1\":{\"617\":1}}],[\"可以彻底摆脱这种痛苦\",{\"1\":{\"872\":1}}],[\"可以嵌套但不能交叉嵌套\",{\"1\":{\"817\":1}}],[\"可以但不必须包含一个头部声明\",{\"1\":{\"817\":1}}],[\"可以自行搭建私服\",{\"1\":{\"1009\":1}}],[\"可以自由更换\",{\"1\":{\"812\":1}}],[\"可以自定义\",{\"1\":{\"680\":1}}],[\"可以理解在标题栏\",{\"1\":{\"797\":1}}],[\"可以理解为\",{\"1\":{\"376\":1}}],[\"可以叠着使用\",{\"1\":{\"769\":1}}],[\"可以存储任意字符串\",{\"1\":{\"746\":1}}],[\"可以存在多个视图解析器\",{\"1\":{\"560\":1}}],[\"可以存在多个case\",{\"1\":{\"497\":1}}],[\"可以发现\",{\"1\":{\"586\":1,\"658\":1,\"1158\":1}}],[\"可以用aop来实现\",{\"1\":{\"1225\":1}}],[\"可以用接口来简化\",{\"1\":{\"842\":1}}],[\"可以用java来写不同类型的可执行文件\",{\"1\":{\"787\":1}}],[\"可以用于恢复因登录而打断的请求\",{\"1\":{\"714\":1}}],[\"可以用\",{\"1\":{\"575\":1,\"1181\":2}}],[\"可以用来定义全局的异常处理\",{\"1\":{\"603\":1}}],[\"可以用来检查一个串是否含有某种子串\",{\"1\":{\"403\":1}}],[\"可以用来衡量一个状态的价值\",{\"1\":{\"40\":1}}],[\"可以执行非常复杂的查找\",{\"1\":{\"513\":1}}],[\"可以基于普通类\",{\"1\":{\"504\":1}}],[\"可以不指定版本号\",{\"1\":{\"1026\":1}}],[\"可以不用一次一次地提交\",{\"1\":{\"798\":1}}],[\"可以不用添加小括号\",{\"1\":{\"447\":1}}],[\"可以不配置\",{\"1\":{\"680\":1,\"686\":1}}],[\"可以不加分号\",{\"1\":{\"473\":1}}],[\"可以正常运行\",{\"1\":{\"468\":1}}],[\"可以将查询结果以一个map的形式表示\",{\"1\":{\"836\":1}}],[\"可以将其视为之前匿名内部类写法的一种缩短\",{\"1\":{\"446\":1}}],[\"可以将复制一个完全一样的对象出来\",{\"1\":{\"372\":1}}],[\"可以对\",{\"1\":{\"432\":1,\"1000\":1}}],[\"可以对列表中每个元素都进行处理\",{\"1\":{\"181\":1}}],[\"可以简写为\",{\"1\":{\"424\":1}}],[\"可以只跟\",{\"1\":{\"424\":1}}],[\"可以交给\",{\"1\":{\"424\":1}}],[\"可以到\",{\"1\":{\"403\":1}}],[\"可以匹配\",{\"1\":{\"403\":1,\"571\":3}}],[\"可以保存一个2字节的unicode字符\",{\"1\":{\"400\":1}}],[\"可以传入\",{\"1\":{\"398\":1}}],[\"可以有多个\",{\"1\":{\"515\":1}}],[\"可以有多个方法\",{\"1\":{\"414\":1,\"447\":1}}],[\"可以有其他方式判断类型\",{\"1\":{\"343\":1}}],[\"可以有限\",{\"1\":{\"19\":1}}],[\"可以给他传一个时间参数进去的\",{\"1\":{\"318\":1}}],[\"可以判断线程是否存在中断标志\",{\"1\":{\"301\":1}}],[\"可以节省数据空间占用以及减少序列化时间\",{\"1\":{\"290\":1}}],[\"可以返回之前标记过的位置\",{\"1\":{\"265\":1}}],[\"可以返回一个备选的返回值\",{\"1\":{\"214\":1}}],[\"可以更好地管理和操作硬盘上的文件\",{\"1\":{\"255\":1}}],[\"可以写入多个\",{\"1\":{\"251\":1}}],[\"可以写成\",{\"1\":{\"134\":1}}],[\"可以直接声明一个bean\",{\"1\":{\"1260\":1}}],[\"可以直接从容器中获取\",{\"1\":{\"1257\":1}}],[\"可以直接分配connection\",{\"1\":{\"1246\":1}}],[\"可以直接输入工厂bean的名称\",{\"1\":{\"1159\":1}}],[\"可以直接被其他项目导入使用\",{\"1\":{\"1036\":1}}],[\"可以直接转换为对象\",{\"1\":{\"610\":1}}],[\"可以直接添加形参来获取异常\",{\"1\":{\"605\":1}}],[\"可以直接添加一个类\",{\"1\":{\"550\":1}}],[\"可以直接添加final关键字\",{\"1\":{\"503\":1}}],[\"可以直接通过事件获取到事件相关的东西\",{\"1\":{\"1191\":1}}],[\"可以直接通过\",{\"1\":{\"432\":1}}],[\"可以直接使用map\",{\"1\":{\"1207\":1}}],[\"可以直接使用此注解来快速注册一个servlet\",{\"1\":{\"1060\":1}}],[\"可以直接使用其名称\",{\"1\":{\"831\":1}}],[\"可以直接使用默认值\",{\"1\":{\"581\":1}}],[\"可以直接使用\",{\"1\":{\"516\":1,\"528\":1,\"1207\":1}}],[\"可以直接使用一个\",{\"1\":{\"437\":1}}],[\"可以直接使用一个while循环来完成\",{\"1\":{\"248\":1}}],[\"可以直接使用lambda表达式\",{\"1\":{\"415\":1}}],[\"可以直接省去花括号和return关键字\",{\"1\":{\"414\":1}}],[\"可以直接写入一个字符串\",{\"1\":{\"270\":1}}],[\"可以直接写入内容\",{\"1\":{\"249\":1}}],[\"可以直接将file作为参数传入字节流或是字符流\",{\"1\":{\"255\":1}}],[\"可以跳过指定数量的字节\",{\"1\":{\"248\":1}}],[\"可以极大提高java程序员的生产力\",{\"1\":{\"228\":1}}],[\"可以在beanfactory\",{\"1\":{\"1328\":1}}],[\"可以在名称前面添加\",{\"1\":{\"1159\":1}}],[\"可以在浏览器中保存一些信息\",{\"1\":{\"1090\":1}}],[\"可以在配置文件中修改\",{\"1\":{\"1047\":1}}],[\"可以在这里进行下载\",{\"1\":{\"811\":1}}],[\"可以在方法中定义\",{\"1\":{\"410\":1}}],[\"可以在\",{\"1\":{\"203\":1,\"524\":1}}],[\"可以得到一个cursor对象\",{\"1\":{\"836\":1}}],[\"可以得到一个非常规范的结果\",{\"1\":{\"182\":1}}],[\"可以得到一个序列v0​\",{\"1\":{\"47\":1}}],[\"可以表示同样的一组元素\",{\"1\":{\"179\":1}}],[\"可以表示为\",{\"1\":{\"9\":1,\"135\":1}}],[\"可以看到能正常生产此bean的实例对象\",{\"1\":{\"1296\":1}}],[\"可以看到在我们原本的方法执行完成之后\",{\"1\":{\"1221\":1}}],[\"可以看到马上就开始执行下一行代码\",{\"1\":{\"1188\":1}}],[\"可以看到效果是完全一样的\",{\"1\":{\"1176\":1}}],[\"可以看到类的旁边出现了bean的图标\",{\"1\":{\"1125\":1}}],[\"可以看到这里一共执行了两次sql语句\",{\"1\":{\"852\":1}}],[\"可以看到这个map中确实使用的是id作为key\",{\"1\":{\"836\":1}}],[\"可以看到mybatis确实调用了我们的无参构造方法来构建对象\",{\"1\":{\"841\":1}}],[\"可以看到它本身是实现了iterable接口的\",{\"1\":{\"836\":1}}],[\"可以看到它不仅仅实现了list接口\",{\"1\":{\"199\":1}}],[\"可以看到两张表中已经自动添加好对应的数据了\",{\"1\":{\"664\":1}}],[\"可以看到p标签上添加了一段js恶意脚本\",{\"1\":{\"643\":1}}],[\"可以看到此时用户的浏览器jsessionid值为刚刚恶意网站伪造的值\",{\"1\":{\"642\":1}}],[\"可以看到有\",{\"1\":{\"631\":1}}],[\"可以看到写法非常简洁\",{\"1\":{\"549\":1}}],[\"可以看到还是非常方便的\",{\"1\":{\"473\":1}}],[\"可以看到system\",{\"1\":{\"284\":1}}],[\"可以看到跟我们之前的写法是一样的\",{\"1\":{\"215\":1}}],[\"可以看到\",{\"1\":{\"172\":1,\"181\":1,\"182\":2,\"203\":1,\"205\":1,\"215\":1,\"399\":1,\"446\":1,\"460\":1,\"465\":1,\"498\":1,\"860\":1,\"883\":1,\"1032\":1,\"1116\":2,\"1133\":1,\"1245\":1}}],[\"可以相同\",{\"1\":{\"165\":1}}],[\"可以是xml文件也可以是类\",{\"1\":{\"1291\":1}}],[\"可以是方法执行之前也可以方法执行之后\",{\"1\":{\"1226\":1}}],[\"可以是跑步\",{\"1\":{\"378\":1}}],[\"可以是相对路径\",{\"1\":{\"255\":1}}],[\"可以是\",{\"1\":{\"155\":1}}],[\"可以是标量\",{\"1\":{\"101\":1}}],[\"可以根据对各个状态的重要程度进行选择\",{\"1\":{\"152\":1}}],[\"可以最大化一个确定的常数指标\",{\"1\":{\"148\":1}}],[\"可以最开始均初始化为\",{\"1\":{\"47\":1}}],[\"可以描述为\",{\"1\":{\"148\":1}}],[\"可以提高存储效率\",{\"1\":{\"131\":1}}],[\"可以参考\",{\"1\":{\"104\":1}}],[\"可以平衡\",{\"1\":{\"87\":1}}],[\"可以拆分为多个\",{\"1\":{\"81\":1}}],[\"可以通过使用cookie来实现记住我功能\",{\"1\":{\"1093\":1}}],[\"可以通过getservletcontext\",{\"1\":{\"1084\":1}}],[\"可以通过它来判断dml语句是否执行成功\",{\"1\":{\"791\":1}}],[\"可以通过连接对象来创建一个statement用于执行sql语句\",{\"1\":{\"790\":1}}],[\"可以通过反编译字节码看看它到底是什么\",{\"1\":{\"522\":1}}],[\"可以通过这个成员内部类又创建出更多对象\",{\"1\":{\"408\":1}}],[\"可以通过class对象来创建对象\",{\"1\":{\"348\":1}}],[\"可以通过contraction\",{\"1\":{\"58\":1}}],[\"可以通过\",{\"1\":{\"66\":1,\"962\":1}}],[\"可以通过设置将episodic\",{\"1\":{\"19\":1}}],[\"可以互相转化\",{\"1\":{\"48\":1}}],[\"可以求解\",{\"1\":{\"45\":1}}],[\"可以粗步衡量一个策略的好坏\",{\"1\":{\"19\":1}}],[\"可以忽略\",{\"1\":{\"10\":1}}],[\"可以减轻无人机对用户接收到的干扰\",{\"1\":{\"9\":1}}],[\"≤c2​\",{\"1\":{\"98\":1}}],[\"≤pmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hn​\",{\"1\":{\"9\":1}}],[\"≤\",{\"1\":{\"9\":1}}],[\"ζ2​是系数\",{\"1\":{\"10\":1}}],[\"ζ1​\",{\"1\":{\"10\":1}}],[\"ζ+em\",{\"1\":{\"9\":1}}],[\"ζ是由环境决定的常数\",{\"1\":{\"9\":1}}],[\"1表示遵循w3c的rfc\",{\"1\":{\"1092\":1}}],[\"1l\",{\"1\":{\"1059\":1}}],[\"1协议了\",{\"1\":{\"1042\":1}}],[\"1=1一定是true\",{\"1\":{\"804\":1}}],[\"1=1\",{\"1\":{\"804\":2,\"805\":1}}],[\"1nf\",{\"0\":{\"736\":1}}],[\"1nf对表中每一列进行约束\",{\"1\":{\"735\":1}}],[\"1<\",{\"1\":{\"649\":2,\"1017\":1,\"1033\":2,\"1175\":1,\"1260\":1}}],[\"15s\",{\"1\":{\"948\":1}}],[\"15\",{\"1\":{\"727\":1,\"852\":4,\"908\":1,\"969\":1,\"972\":1}}],[\"15首次提出并测试了两个版本\",{\"1\":{\"503\":1}}],[\"15才正式开放使用\",{\"1\":{\"498\":1}}],[\"17<\",{\"1\":{\"1025\":1}}],[\"17下执行的测试案例\",{\"1\":{\"978\":1}}],[\"1724143033753\",{\"1\":{\"896\":1}}],[\"17之前想要实现就很麻烦\",{\"1\":{\"503\":1}}],[\"17正式推出的又一重磅类型\",{\"1\":{\"503\":1}}],[\"17作为新的lts长期维护版本\",{\"1\":{\"502\":1}}],[\"17\",{\"0\":{\"502\":1,\"1338\":1},\"1\":{\"877\":2,\"977\":1,\"978\":1,\"1278\":2,\"1283\":1}}],[\"17出现之前\",{\"1\":{\"486\":1}}],[\"14中首次出场\",{\"1\":{\"501\":1}}],[\"14或更高版本运行时\",{\"1\":{\"500\":1}}],[\"14\",{\"1\":{\"499\":1,\"969\":1,\"970\":1,\"972\":1}}],[\"14才正式开放使用\",{\"1\":{\"497\":1}}],[\"119\",{\"1\":{\"1283\":1}}],[\"1111\",{\"1\":{\"804\":2}}],[\"11为string新增一些更加方便的操作\",{\"1\":{\"488\":1}}],[\"11\",{\"0\":{\"483\":1},\"1\":{\"486\":1,\"487\":1,\"1181\":1,\"1260\":1}}],[\"196\",{\"1\":{\"1278\":1}}],[\"1962329560\",{\"1\":{\"852\":2}}],[\"1997年以前使用的是http\",{\"1\":{\"1042\":1}}],[\"19\",{\"1\":{\"431\":1,\"475\":1,\"877\":2,\"883\":2}}],[\"1打印\",{\"1\":{\"304\":1,\"305\":1}}],[\"1static\",{\"1\":{\"376\":1}}],[\"1s\",{\"1\":{\"299\":1}}],[\"16<\",{\"1\":{\"1024\":1}}],[\"16才正式开放使用\",{\"1\":{\"499\":1,\"501\":1}}],[\"16这五个版本并非长期支持版本\",{\"1\":{\"494\":1}}],[\"166\",{\"1\":{\"385\":1}}],[\"16\",{\"0\":{\"493\":1,\"494\":1},\"1\":{\"245\":1,\"852\":2}}],[\"138\",{\"1\":{\"1091\":2,\"1096\":4}}],[\"13<\",{\"1\":{\"544\":1,\"551\":1,\"663\":1,\"1253\":1}}],[\"13版本引入了一些实验性功能\",{\"1\":{\"494\":1}}],[\"13\",{\"1\":{\"234\":1}}],[\"186\",{\"1\":{\"1283\":1}}],[\"18245eb0\",{\"1\":{\"1260\":1}}],[\"18\",{\"1\":{\"162\":1,\"166\":1,\"373\":4,\"376\":1,\"377\":1,\"378\":1,\"464\":1,\"475\":1,\"610\":7,\"612\":2,\"613\":2,\"615\":1,\"616\":1,\"747\":2,\"834\":1,\"836\":1,\"843\":1,\"852\":1,\"871\":1,\"873\":1,\"874\":3,\"877\":2,\"902\":3,\"1008\":2,\"1033\":1}}],[\"180π​\",{\"1\":{\"9\":1}}],[\"10<\",{\"1\":{\"663\":1,\"1118\":1,\"1217\":1,\"1253\":1,\"1290\":1}}],[\"1024\",{\"1\":{\"490\":1,\"726\":2}}],[\"10我们认识了var关键字\",{\"1\":{\"487\":1}}],[\"10新增的一些其他改进\",{\"1\":{\"485\":1}}],[\"10主要带来的是一些内部更新\",{\"1\":{\"484\":1}}],[\"10086\",{\"1\":{\"1208\":1}}],[\"100000\",{\"1\":{\"312\":6}}],[\"10000\",{\"1\":{\"311\":2,\"312\":4}}],[\"1000ms\",{\"1\":{\"299\":1}}],[\"1000\",{\"1\":{\"299\":1,\"311\":1,\"312\":4,\"313\":2,\"318\":1,\"319\":1,\"323\":1,\"324\":1,\"329\":4,\"721\":1,\"910\":1,\"1192\":1}}],[\"100~100之间的\",{\"1\":{\"228\":1}}],[\"100\",{\"1\":{\"228\":4,\"350\":1,\"386\":2,\"424\":1,\"431\":1,\"480\":1,\"495\":2,\"747\":1,\"1136\":1,\"1211\":1}}],[\"10\",{\"1\":{\"161\":1,\"166\":1,\"172\":2,\"182\":5,\"203\":4,\"228\":1,\"234\":1,\"236\":2,\"251\":1,\"253\":1,\"305\":1,\"341\":1,\"343\":4,\"350\":4,\"384\":5,\"386\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":4,\"413\":1,\"414\":2,\"415\":2,\"424\":2,\"425\":2,\"438\":1,\"479\":2,\"490\":3,\"495\":2,\"496\":2,\"512\":1,\"727\":1,\"747\":1,\"748\":1,\"969\":1,\"972\":2,\"990\":2,\"1047\":1,\"1091\":1,\"1096\":1,\"1113\":1,\"1200\":1,\"1245\":1,\"1260\":3}}],[\"10​a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"10​a=a∗a=a∗​\",{\"1\":{\"57\":1}}],[\"1−∣a\",{\"1\":{\"87\":1}}],[\"12月\",{\"1\":{\"1278\":1}}],[\"127\",{\"1\":{\"727\":2}}],[\"12引入全新的switch语法\",{\"1\":{\"495\":1}}],[\"12\",{\"0\":{\"493\":1,\"494\":1},\"1\":{\"494\":1,\"908\":1,\"919\":2,\"929\":2,\"1181\":1,\"1260\":5}}],[\"128~127之间的值自动装箱为integer类型的对象\",{\"1\":{\"384\":1}}],[\"128~127之间的所有值\",{\"1\":{\"384\":1}}],[\"128\",{\"1\":{\"384\":4,\"531\":1}}],[\"123\",{\"1\":{\"349\":1}}],[\"1234567\",{\"1\":{\"290\":1}}],[\"123456\",{\"1\":{\"289\":1,\"501\":2,\"589\":1,\"617\":4,\"636\":1,\"664\":1,\"788\":1,\"796\":1,\"805\":1,\"904\":1,\"1017\":1,\"1255\":1,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"1234\",{\"1\":{\"33\":1,\"798\":2,\"806\":11}}],[\"120和4\",{\"1\":{\"10\":1}}],[\"1\",{\"0\":{\"19\":1,\"24\":1,\"26\":1,\"30\":1,\"38\":1,\"39\":2,\"40\":1,\"41\":1,\"43\":1,\"53\":1,\"55\":1,\"57\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"70\":1,\"76\":1,\"77\":2,\"78\":1,\"79\":1,\"81\":1,\"86\":1,\"93\":1,\"94\":2,\"96\":1,\"101\":1,\"110\":1,\"112\":1,\"116\":1,\"120\":1,\"131\":1,\"133\":1,\"148\":1,\"150\":1,\"176\":1,\"177\":1,\"264\":1,\"435\":1,\"436\":1,\"483\":1,\"493\":1,\"731\":1,\"1114\":1,\"1276\":1,\"1343\":1,\"1352\":1},\"1\":{\"10\":1,\"13\":7,\"14\":1,\"19\":1,\"66\":1,\"70\":1,\"79\":2,\"87\":1,\"98\":2,\"101\":1,\"112\":1,\"116\":1,\"171\":4,\"182\":2,\"190\":1,\"207\":2,\"214\":6,\"216\":3,\"217\":2,\"221\":4,\"228\":4,\"235\":1,\"236\":1,\"237\":3,\"248\":3,\"249\":1,\"251\":1,\"253\":1,\"265\":3,\"267\":1,\"330\":2,\"340\":1,\"396\":1,\"397\":2,\"398\":1,\"403\":5,\"423\":1,\"424\":2,\"431\":1,\"432\":1,\"449\":4,\"451\":2,\"452\":1,\"478\":2,\"479\":2,\"521\":1,\"528\":1,\"544\":1,\"545\":1,\"547\":1,\"549\":1,\"551\":1,\"559\":2,\"560\":1,\"601\":1,\"617\":4,\"636\":2,\"641\":2,\"642\":2,\"649\":2,\"710\":1,\"726\":3,\"727\":11,\"733\":4,\"788\":2,\"799\":1,\"804\":1,\"805\":2,\"817\":4,\"824\":1,\"826\":1,\"832\":1,\"833\":1,\"834\":1,\"836\":1,\"843\":1,\"852\":6,\"865\":4,\"871\":1,\"874\":1,\"876\":3,\"883\":8,\"884\":2,\"888\":1,\"963\":1,\"973\":1,\"974\":1,\"980\":1,\"987\":1,\"988\":4,\"1002\":1,\"1017\":4,\"1023\":1,\"1026\":1,\"1032\":1,\"1037\":1,\"1042\":2,\"1059\":1,\"1064\":2,\"1071\":1,\"1072\":1,\"1091\":6,\"1096\":6,\"1119\":1,\"1124\":1,\"1135\":2,\"1150\":1,\"1167\":1,\"1175\":1,\"1208\":2,\"1217\":1,\"1242\":1,\"1255\":2,\"1260\":5,\"1278\":1,\"1279\":1,\"1317\":1}}],[\"1~2\",{\"1\":{\"10\":1}}],[\"1+σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"1+ns​\",{\"1\":{\"9\":1}}],[\"且对象不能被修改\",{\"1\":{\"884\":1}}],[\"且该列的值不能为空\",{\"1\":{\"748\":1}}],[\"且不能为空且唯一\",{\"1\":{\"747\":1}}],[\"且不能是匿名内部类或是lambda的形式\",{\"1\":{\"504\":1}}],[\"且有一个管理员只在一个仓库工作\",{\"1\":{\"739\":1}}],[\"且其他的属性必须完全依赖于主键\",{\"1\":{\"737\":1}}],[\"且一旦参数较多\",{\"1\":{\"523\":1}}],[\"且此构造方法需要一个string类型的对象\",{\"1\":{\"453\":1}}],[\"且接受一个int类型参数\",{\"1\":{\"447\":1}}],[\"且没有参数\",{\"1\":{\"447\":1}}],[\"且同样不能使用\",{\"1\":{\"375\":1}}],[\"且需要被求解出来\",{\"1\":{\"96\":1}}],[\"且最终会收敛到最优策略v∗\",{\"1\":{\"68\":1}}],[\"且\",{\"1\":{\"53\":1,\"87\":1,\"98\":2,\"135\":1,\"144\":1}}],[\"且ζ1​+ζ2​=1\",{\"1\":{\"10\":1}}],[\"且传输率永远都不可能超过信道容量c\",{\"1\":{\"9\":1}}],[\"且无人机向关联用户的发射功率是恒定的\",{\"1\":{\"9\":1}}],[\"信息\",{\"1\":{\"908\":1,\"919\":1,\"929\":2,\"1260\":3,\"1278\":1}}],[\"信道容量c=b∗log\",{\"1\":{\"9\":1}}],[\"信号模型\",{\"0\":{\"9\":1}}],[\"由子类实现对beanfactory的其他后置处理\",{\"1\":{\"1320\":1}}],[\"由一系列动作组成\",{\"1\":{\"1266\":1}}],[\"由配置文件映射的对象实体\",{\"1\":{\"1242\":1}}],[\"由t\",{\"1\":{\"1205\":1}}],[\"由ioc容器自动为其赋值\",{\"1\":{\"1173\":1}}],[\"由它根据配置文件来决定到底给我们哪一个实现类\",{\"1\":{\"1117\":1}}],[\"由官方定义了一系列接口\",{\"1\":{\"1053\":1}}],[\"由客户端向服务端发送是报文称为请求报文\",{\"1\":{\"1042\":1}}],[\"由驱动程序转交给应用程序负责\",{\"1\":{\"806\":1}}],[\"由线程来响应此中断并进行相应的处理\",{\"1\":{\"301\":1}}],[\"由无人机的位置和它们在最后时隙采取的动作决定\",{\"1\":{\"14\":1}}],[\"由用户的初始位置和运动模型决定\",{\"1\":{\"14\":1}}],[\"由于每个bean只会创建一个实例\",{\"1\":{\"1301\":1}}],[\"由于每个进程都有一个自己的内存空间\",{\"1\":{\"295\":1}}],[\"由于其他事务执行插入删除操作\",{\"1\":{\"1271\":1}}],[\"由于其他事务更新数据\",{\"1\":{\"1271\":1}}],[\"由于网络问题有可能之前的连接一直被卡住\",{\"1\":{\"1246\":1}}],[\"由于工厂类被注册为bean\",{\"1\":{\"1159\":1}}],[\"由于autowire的规则为bytype\",{\"1\":{\"1140\":1}}],[\"由于该类并不是jdk内部或是扩展类\",{\"1\":{\"1109\":1}}],[\"由于过滤器的过滤顺序是按照类名的自然排序进行的\",{\"1\":{\"1103\":1}}],[\"由于我们整个应用程序可能存在多个过滤器\",{\"1\":{\"1103\":1}}],[\"由于http是无连接的\",{\"1\":{\"1094\":1}}],[\"由于此servlet不支持post请求\",{\"1\":{\"1083\":1}}],[\"由于此时抛出的是一个arithmeticexception并不是我们需要的ioexception或是其子类\",{\"1\":{\"973\":1}}],[\"由于不知道是什么\",{\"1\":{\"1047\":1}}],[\"由于不同用户对于传输速率的需求是不同的\",{\"1\":{\"10\":1}}],[\"由于不同集群的频谱不同\",{\"1\":{\"9\":1}}],[\"由于mybatis要支持多种类型的日志\",{\"1\":{\"1025\":1}}],[\"由于mybatis默认情况下直接通过无参构造来创建实体类对象\",{\"1\":{\"841\":1}}],[\"由于返回的结果是一个列表\",{\"1\":{\"836\":1}}],[\"由于这里我们需要通过一个参数来查询\",{\"1\":{\"831\":1}}],[\"由于这里只有一句打印\",{\"1\":{\"454\":1}}],[\"由于sqlsessionfactory一般只需要创建一次\",{\"1\":{\"830\":1}}],[\"由于string类的构造方法返回的肯定是一个string类型的对象\",{\"1\":{\"453\":1}}],[\"由于string的构造方法在创建对象时也会得到一个string类型的结果\",{\"1\":{\"415\":1}}],[\"由于idea默认都安装了lombok的插件\",{\"1\":{\"811\":1}}],[\"由于存在如下决定关系\",{\"1\":{\"739\":1}}],[\"由于继承了autocloseble\",{\"1\":{\"719\":1}}],[\"由于使用方式差不多\",{\"1\":{\"693\":1}}],[\"由于记住我信息是存放在内存中的\",{\"1\":{\"686\":1}}],[\"由于javascript的出现\",{\"1\":{\"643\":1}}],[\"由于java版本的更新迭代速度自java\",{\"1\":{\"494\":1}}],[\"由于没有使用java\",{\"1\":{\"463\":1}}],[\"由于仅有返回语句这一行\",{\"1\":{\"447\":1}}],[\"由于只有一个参数\",{\"1\":{\"447\":1}}],[\"由于是private访问权限\",{\"1\":{\"462\":1}}],[\"由于是\",{\"1\":{\"437\":1}}],[\"由于基本数据类型和引用类型不同\",{\"1\":{\"395\":1}}],[\"由于类本身都是继承\",{\"1\":{\"376\":1}}],[\"由于类型擦除机制\",{\"1\":{\"343\":1}}],[\"由于泛型中未定义\",{\"1\":{\"343\":1}}],[\"由于泛型机制上的一些漏洞\",{\"1\":{\"237\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"313\":1}}],[\"由于默认导入了系统自带的string类\",{\"1\":{\"277\":1}}],[\"由于外部i\",{\"1\":{\"260\":1}}],[\"由于底层采用哈希表实现\",{\"1\":{\"205\":1}}],[\"由于πk+1​是\",{\"1\":{\"63\":1}}],[\"由于\",{\"1\":{\"48\":1,\"63\":1}}],[\"由于用户在每个时隙都处于漫游状态\",{\"1\":{\"14\":1}}],[\"由于gak\",{\"1\":{\"13\":1}}],[\"由于特定用户的mos与该用户与无人机之间的距离有关\",{\"1\":{\"13\":1}}],[\"由此进行迭代\",{\"1\":{\"66\":1}}],[\"由此可以根据contraction\",{\"1\":{\"58\":1}}],[\"由此可以推导出一个多步的trajectory\",{\"1\":{\"39\":1}}],[\"由此\",{\"1\":{\"9\":1}}],[\"同款日志信息\",{\"1\":{\"1260\":1}}],[\"同步执行\",{\"1\":{\"1188\":1}}],[\"同步代码块内部\",{\"1\":{\"318\":1}}],[\"同servlet一样\",{\"1\":{\"1104\":1}}],[\"同学\",{\"1\":{\"841\":1}}],[\"同父类\",{\"1\":{\"504\":1}}],[\"同名的方法\",{\"1\":{\"376\":1}}],[\"同构造方法一样\",{\"1\":{\"349\":1}}],[\"同一消息根据不同的对象而采用各种不同的方法\",{\"1\":{\"369\":1}}],[\"同一个包下的类\",{\"1\":{\"278\":1}}],[\"同一无人机通过fdma同时为同一集群中的多个用户提供服务\",{\"1\":{\"8\":1}}],[\"同read一样\",{\"1\":{\"249\":1}}],[\"同时这里也会注册一个autowiredannotationbeanpostprocessor后置处理器到beanfactory\",{\"1\":{\"1318\":1}}],[\"同时集成了多种类型的beanfactory接口\",{\"1\":{\"1316\":1}}],[\"同时执行时\",{\"1\":{\"1267\":1}}],[\"同时我们还需要修改一下student类\",{\"1\":{\"1133\":1}}],[\"同时我们需要向其中填入参数\",{\"1\":{\"348\":1}}],[\"同时每个应用程序都有自己的依赖\",{\"1\":{\"1109\":1}}],[\"同时每次打印也是不同的线程在执行\",{\"1\":{\"330\":1}}],[\"同时还需要将依赖也一并打包到jar中\",{\"1\":{\"1037\":1}}],[\"同时还能获取到注解中填入的值\",{\"1\":{\"365\":1}}],[\"同时子项目无需指定版本\",{\"1\":{\"1033\":1}}],[\"同时下面的源代码编码格式为utf\",{\"1\":{\"1003\":1}}],[\"同时idea也会提示我们测试失败\",{\"1\":{\"963\":1}}],[\"同时idea需要安装junit插件\",{\"1\":{\"958\":1}}],[\"同时id作为操作的名称\",{\"1\":{\"826\":1}}],[\"同时\",{\"1\":{\"956\":1}}],[\"同时查询user\",{\"1\":{\"851\":1}}],[\"同时将用户的详细信息包含在内\",{\"1\":{\"849\":1}}],[\"同时如果字段名称发生改变\",{\"1\":{\"810\":1}}],[\"同时数据库能够为我们提供高效的访问性能\",{\"1\":{\"732\":1}}],[\"同时在代码编写上也比较麻烦\",{\"1\":{\"685\":1}}],[\"同时页面也是我们自定义的一个页面\",{\"1\":{\"605\":1}}],[\"同时允许你通过实现\",{\"1\":{\"553\":1}}],[\"同时告知上一级方法执行出现了问题\",{\"1\":{\"423\":1}}],[\"同时也会占用磁盘资源\",{\"1\":{\"780\":1}}],[\"同时也会生成一个tostring\",{\"1\":{\"525\":1}}],[\"同时也会生成一个class对象存放在内存\",{\"1\":{\"337\":1}}],[\"同时也需要对应的\",{\"1\":{\"671\":1}}],[\"同时也使得基本类型能够支持对象操作\",{\"1\":{\"383\":1}}],[\"同时具体实现还需要由主体来实现\",{\"1\":{\"376\":1}}],[\"同时此注解可以作用于方法或是类上\",{\"1\":{\"363\":1}}],[\"同时类名也保持一致\",{\"1\":{\"355\":1}}],[\"同时会释放当前代码块持有的锁\",{\"1\":{\"318\":1}}],[\"同时一直占用锁\",{\"1\":{\"313\":1}}],[\"同时runnable只有一个未实现方法\",{\"1\":{\"296\":1}}],[\"同时保存了插入顺序\",{\"1\":{\"218\":1}}],[\"同时得益于每一个节点都是一个双向链表\",{\"1\":{\"218\":1}}],[\"同上输入流\",{\"1\":{\"249\":1}}],[\"同上\",{\"1\":{\"180\":1,\"372\":4,\"392\":1,\"713\":1,\"962\":2,\"1058\":1}}],[\"同理\",{\"1\":{\"19\":1,\"253\":1,\"260\":1,\"582\":1,\"1056\":1,\"1119\":1,\"1301\":1}}],[\"同样也是advice的子接口\",{\"1\":{\"1231\":1}}],[\"同样内置了一个缓存机制\",{\"1\":{\"882\":1}}],[\"同样不需要break\",{\"1\":{\"497\":1}}],[\"同样不能超过最大值\",{\"1\":{\"217\":1}}],[\"同样需要使用resultmap来完成\",{\"1\":{\"841\":1}}],[\"同样需要使用\",{\"1\":{\"392\":1}}],[\"同样需要将接口中所有的抽象方法全部实现\",{\"1\":{\"376\":1}}],[\"同样需要给一个\",{\"1\":{\"203\":1}}],[\"同样可以得到输出结果\",{\"1\":{\"1260\":1}}],[\"同样可以正常使用mapper\",{\"1\":{\"1259\":1}}],[\"同样可以自己起名字\",{\"1\":{\"1177\":1}}],[\"同样可以使用\",{\"1\":{\"903\":1}}],[\"同样可以设置其他属性\",{\"1\":{\"619\":1}}],[\"同样可以作为方法引用传递\",{\"1\":{\"453\":1}}],[\"同样可以捕获到\",{\"1\":{\"424\":1}}],[\"同样可以按照上面的操作进行越权访问\",{\"1\":{\"350\":1}}],[\"同样可以用条件概率的形式进行描述\",{\"1\":{\"19\":1}}],[\"同样采用装饰者模式\",{\"1\":{\"286\":1}}],[\"同样是用于列表查询的\",{\"1\":{\"836\":1}}],[\"同样是一个comparator\",{\"1\":{\"207\":1}}],[\"同样是只能插入那些不重复的元素\",{\"1\":{\"204\":1}}],[\"同样是仅获取队首元素\",{\"1\":{\"200\":1}}],[\"同样是移除队首元素\",{\"1\":{\"200\":1}}],[\"同样是添加操作\",{\"1\":{\"200\":1}}],[\"同样是list的实现类\",{\"1\":{\"182\":1}}],[\"同样的还有\",{\"1\":{\"697\":1}}],[\"同样的还有jsonarray\",{\"1\":{\"613\":1}}],[\"同样的构建过程可以创建不同的表示\",{\"1\":{\"524\":1}}],[\"同样的键只能存在一个\",{\"1\":{\"214\":1}}],[\"同样的\",{\"1\":{\"172\":1,\"180\":1,\"216\":1,\"234\":1,\"274\":2,\"283\":1,\"313\":1,\"384\":1,\"412\":1,\"573\":1,\"586\":1,\"806\":1,\"950\":1,\"977\":1,\"994\":1,\"1047\":1,\"1178\":1,\"1204\":1,\"1224\":1,\"1234\":1,\"1237\":1,\"1298\":1}}],[\"同样的类型\",{\"1\":{\"171\":1}}],[\"同样地\",{\"1\":{\"48\":1}}],[\"同样\",{\"1\":{\"9\":1,\"99\":1}}],[\"μnlos​\",{\"1\":{\"9\":1}}],[\"μnlos​是表示los和nlos链路的衰减因子\",{\"1\":{\"9\":1}}],[\"μlos​−μnlos​\",{\"1\":{\"9\":1}}],[\"μlos​\",{\"1\":{\"9\":1}}],[\"α是表示路径损耗指数\",{\"1\":{\"9\":1}}],[\"gb\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"gbk\",{\"1\":{\"1047\":1}}],[\"gmt\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"gui\",{\"1\":{\"1047\":8}}],[\"guide\",{\"1\":{\"995\":1}}],[\"gname\",{\"1\":{\"855\":3}}],[\"goals>\",{\"1\":{\"1037\":1}}],[\"goal>\",{\"1\":{\"1037\":1}}],[\"got\",{\"1\":{\"789\":1}}],[\"google\",{\"1\":{\"403\":2,\"727\":1,\"1092\":2}}],[\"good\",{\"1\":{\"10\":1,\"779\":1,\"1246\":2}}],[\"gid\",{\"1\":{\"855\":6}}],[\"git\",{\"1\":{\"782\":1}}],[\"given\",{\"1\":{\"296\":1,\"509\":1}}],[\"gzip\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"gareth\",{\"1\":{\"643\":1}}],[\"gain\",{\"1\":{\"9\":1}}],[\"global\",{\"1\":{\"588\":1}}],[\"g∣s=s\",{\"1\":{\"113\":1}}],[\"g~​\",{\"1\":{\"104\":1,\"110\":1}}],[\"gd\",{\"1\":{\"101\":1,\"104\":1}}],[\"granted\",{\"1\":{\"1047\":1}}],[\"grant\",{\"1\":{\"744\":1,\"774\":3}}],[\"grade\",{\"1\":{\"495\":2,\"496\":1,\"779\":3}}],[\"gradient\",{\"0\":{\"100\":1,\"147\":1},\"1\":{\"101\":2,\"148\":1}}],[\"groupid\",{\"1\":{\"1003\":2}}],[\"groupid>\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"611\":1,\"616\":1,\"649\":2,\"663\":4,\"1002\":1,\"1008\":1,\"1017\":3,\"1018\":1,\"1023\":2,\"1024\":1,\"1025\":3,\"1026\":2,\"1032\":1,\"1033\":6,\"1071\":2,\"1074\":1,\"1118\":1,\"1175\":1,\"1217\":1,\"1253\":4,\"1260\":3,\"1290\":2}}],[\"groups\",{\"1\":{\"855\":4}}],[\"group\",{\"1\":{\"766\":2,\"855\":7}}],[\"grow\",{\"1\":{\"182\":1}}],[\"greedy\",{\"0\":{\"85\":1,\"87\":1,\"88\":1},\"1\":{\"53\":1,\"63\":2,\"66\":1,\"70\":2,\"79\":1,\"87\":3}}],[\"g​\",{\"1\":{\"97\":2,\"99\":2}}],[\"gpi\",{\"1\":{\"82\":1}}],[\"gecko\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"generator\",{\"1\":{\"522\":1}}],[\"generally\",{\"1\":{\"788\":1}}],[\"general\",{\"1\":{\"296\":1,\"749\":1}}],[\"generalized\",{\"1\":{\"82\":1}}],[\"genericbeandefinition\",{\"1\":{\"1326\":1}}],[\"genericapplicationcontext\",{\"1\":{\"1318\":1}}],[\"genericfilter\",{\"1\":{\"1104\":1}}],[\"generics\",{\"1\":{\"343\":1}}],[\"genericinterface\",{\"1\":{\"343\":2}}],[\"getid\",{\"1\":{\"1316\":1}}],[\"getinitparameter\",{\"1\":{\"1085\":1,\"1086\":1}}],[\"getint\",{\"1\":{\"799\":1}}],[\"getinterfaces\",{\"1\":{\"343\":1}}],[\"getinputstream\",{\"1\":{\"720\":2,\"726\":1,\"727\":1,\"1075\":1}}],[\"getinetaddress\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"getinfo\",{\"1\":{\"617\":1}}],[\"geturl\",{\"1\":{\"1246\":1}}],[\"getuser\",{\"1\":{\"1071\":1,\"1072\":1,\"1093\":1}}],[\"getusername\",{\"1\":{\"617\":2,\"1245\":1}}],[\"get请求也能传递参数\",{\"1\":{\"1076\":1}}],[\"getwriter\",{\"1\":{\"1058\":1,\"1059\":1,\"1064\":1,\"1072\":3,\"1075\":1,\"1076\":1}}],[\"getwebapplicationcontextattribute\",{\"1\":{\"705\":1}}],[\"getwebapplicationcontext\",{\"1\":{\"625\":1}}],[\"getformatterproperty\",{\"1\":{\"939\":1}}],[\"getfirewalledresponse\",{\"1\":{\"708\":1}}],[\"getfirewalledrequest\",{\"1\":{\"708\":1}}],[\"getfirstchild\",{\"1\":{\"819\":1}}],[\"getfirst\",{\"1\":{\"201\":1}}],[\"getfilterproperty\",{\"1\":{\"939\":1}}],[\"getfilters\",{\"1\":{\"708\":1}}],[\"getfilterconfig\",{\"1\":{\"706\":1}}],[\"getfiltername\",{\"1\":{\"706\":1}}],[\"getfield\",{\"1\":{\"356\":1}}],[\"getnodevalue\",{\"1\":{\"819\":1}}],[\"getnodename\",{\"1\":{\"819\":1}}],[\"getnodetype\",{\"1\":{\"819\":1}}],[\"getname\",{\"1\":{\"164\":1,\"222\":2,\"297\":1,\"323\":1,\"324\":1,\"330\":1,\"331\":2,\"341\":1,\"343\":1,\"349\":1,\"356\":1,\"372\":1,\"378\":2,\"626\":1,\"789\":3,\"810\":1,\"841\":1,\"910\":1,\"911\":1,\"918\":1,\"927\":1,\"939\":1,\"948\":1,\"950\":2,\"1091\":1,\"1093\":2,\"1188\":2,\"1203\":1,\"1247\":1}}],[\"getheader\",{\"1\":{\"1057\":1}}],[\"getheadernames\",{\"1\":{\"1057\":1}}],[\"gethostaddress\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"gethandlers\",{\"1\":{\"918\":1,\"927\":1,\"928\":1,\"946\":1}}],[\"gethandleradapter\",{\"1\":{\"626\":1}}],[\"gethandler\",{\"1\":{\"626\":4}}],[\"gethashcode\",{\"1\":{\"501\":1}}],[\"getboolean\",{\"1\":{\"1310\":2}}],[\"getbeanpostprocessorcache\",{\"1\":{\"1301\":1}}],[\"getbeanfactory就可以直接得到上面的对象了\",{\"1\":{\"1296\":1}}],[\"getbeanfactory\",{\"1\":{\"1296\":1}}],[\"getbeandefinition\",{\"1\":{\"1296\":1,\"1311\":2}}],[\"getbean有多种形式\",{\"1\":{\"1125\":1}}],[\"getbean\",{\"1\":{\"706\":1,\"1117\":1,\"1119\":2,\"1125\":1,\"1126\":2,\"1127\":1,\"1128\":1,\"1129\":4,\"1133\":1,\"1159\":2,\"1169\":1,\"1176\":1,\"1178\":2,\"1188\":1,\"1189\":1,\"1192\":1,\"1203\":1,\"1221\":1,\"1222\":1,\"1224\":1,\"1225\":1,\"1233\":1,\"1256\":1,\"1257\":1,\"1260\":1,\"1278\":1,\"1288\":1,\"1296\":3,\"1298\":4,\"1299\":1,\"1300\":1,\"1321\":3,\"1328\":2}}],[\"getbytes\",{\"1\":{\"249\":2,\"250\":1,\"267\":1,\"1203\":1}}],[\"getlevel\",{\"1\":{\"944\":1,\"948\":1}}],[\"getlevelproperty\",{\"1\":{\"939\":1}}],[\"getlength\",{\"1\":{\"819\":1}}],[\"getlocalizedname\",{\"1\":{\"944\":1}}],[\"getlocalecontext\",{\"1\":{\"626\":1}}],[\"getlog\",{\"1\":{\"1245\":1,\"1273\":1}}],[\"getlogmanager\",{\"1\":{\"939\":2}}],[\"getlogger\",{\"1\":{\"908\":1,\"910\":1,\"911\":1,\"918\":1,\"927\":2,\"930\":4,\"939\":1,\"946\":1}}],[\"getlastusedtimestamp\",{\"1\":{\"1246\":1,\"1247\":1}}],[\"getlastmodified\",{\"1\":{\"626\":1,\"1059\":2}}],[\"getlast\",{\"1\":{\"201\":1}}],[\"getobjectforbeaninstance\",{\"1\":{\"1300\":1}}],[\"getobjecttype\",{\"1\":{\"1160\":1,\"1180\":1,\"1327\":1,\"1328\":1}}],[\"getobject\",{\"1\":{\"799\":1,\"1160\":1,\"1180\":1,\"1301\":1,\"1327\":1,\"1328\":2}}],[\"getoutputstream\",{\"1\":{\"620\":1,\"720\":2,\"726\":1,\"727\":1,\"1074\":2}}],[\"getordefault\",{\"1\":{\"214\":2}}],[\"getearlybeanreference\",{\"1\":{\"1301\":2}}],[\"getelementsbytagname\",{\"1\":{\"819\":1}}],[\"getelementbyid\",{\"1\":{\"617\":2,\"636\":1,\"660\":2,\"666\":3,\"1076\":1}}],[\"getenvironment\",{\"1\":{\"625\":1,\"1242\":1,\"1297\":1}}],[\"getencoding\",{\"1\":{\"254\":1}}],[\"getrole\",{\"1\":{\"692\":1}}],[\"getrootconfigclasses\",{\"1\":{\"552\":1,\"652\":1}}],[\"getrealconnection\",{\"1\":{\"1246\":5,\"1247\":6}}],[\"getrealhashcode\",{\"1\":{\"1246\":4,\"1247\":3}}],[\"getrequesturl\",{\"1\":{\"1102\":1,\"1104\":1}}],[\"getrequestdispatcher\",{\"1\":{\"1083\":2,\"1084\":1,\"1093\":1}}],[\"getrequestattributes\",{\"1\":{\"626\":1}}],[\"getremoteaddr\",{\"1\":{\"1057\":1}}],[\"getresourceasreader\",{\"1\":{\"1254\":1}}],[\"getresourceasstream\",{\"1\":{\"824\":1,\"1017\":1,\"1072\":1,\"1074\":2,\"1084\":1}}],[\"getresultobject\",{\"1\":{\"836\":1}}],[\"getreturntype\",{\"1\":{\"349\":1}}],[\"getdisplayname\",{\"1\":{\"1316\":1}}],[\"getdeclaringclass\",{\"1\":{\"1247\":1}}],[\"getdeclaredfield\",{\"1\":{\"350\":4,\"462\":1}}],[\"getdeclaredmethod\",{\"1\":{\"349\":3}}],[\"getdeclaredconstructor\",{\"1\":{\"348\":1}}],[\"getdefaultexecutortype\",{\"1\":{\"1242\":1}}],[\"getdateheader\",{\"1\":{\"1059\":1}}],[\"getdatasource\",{\"1\":{\"1242\":2}}],[\"getdata\",{\"1\":{\"523\":1}}],[\"getproxyconnection\",{\"1\":{\"1245\":2}}],[\"getprotocol\",{\"1\":{\"1057\":1,\"1059\":1}}],[\"getproperties\",{\"1\":{\"938\":2,\"978\":1}}],[\"getprimitiveclass获取的是原始类型\",{\"1\":{\"340\":1}}],[\"getprimitiveclass\",{\"1\":{\"340\":2}}],[\"getpassword\",{\"1\":{\"617\":2,\"672\":1,\"692\":1,\"1245\":1}}],[\"getpart\",{\"1\":{\"1075\":1}}],[\"getparametertypes\",{\"1\":{\"799\":2}}],[\"getparametername\",{\"1\":{\"660\":2,\"682\":1,\"683\":1}}],[\"getparametermap\",{\"1\":{\"582\":1,\"1069\":1,\"1072\":1}}],[\"getparameter\",{\"1\":{\"575\":1,\"1072\":2}}],[\"getparameters\",{\"1\":{\"349\":1}}],[\"getparent\",{\"1\":{\"355\":3,\"625\":1,\"927\":2,\"930\":3,\"946\":1,\"1316\":1}}],[\"getmillis\",{\"1\":{\"948\":1}}],[\"getmapper\",{\"1\":{\"842\":2,\"843\":1,\"865\":3,\"871\":1,\"877\":1,\"883\":3,\"884\":2,\"888\":1,\"1017\":1,\"1072\":1,\"1093\":1,\"1256\":1,\"1328\":1}}],[\"getmapping\",{\"1\":{\"636\":1,\"658\":1,\"679\":2,\"695\":1}}],[\"getmapping可以直接指定为get请求方式\",{\"1\":{\"573\":1}}],[\"getmax\",{\"1\":{\"228\":1}}],[\"getmodel\",{\"1\":{\"563\":1}}],[\"getmodifiers\",{\"1\":{\"350\":1}}],[\"getmergedlocalbeandefinition\",{\"1\":{\"1321\":1}}],[\"getmessage\",{\"1\":{\"424\":1,\"523\":1,\"948\":1}}],[\"getmethodnotsupportedcode\",{\"1\":{\"1059\":1}}],[\"getmethod\",{\"1\":{\"349\":2,\"356\":2,\"365\":1,\"626\":1,\"1057\":1,\"1059\":1}}],[\"getgenericinterfaces\",{\"1\":{\"343\":1}}],[\"getgenericsuperclass\",{\"1\":{\"343\":5}}],[\"getsqlsession\",{\"1\":{\"1328\":1}}],[\"getsourcemethodname\",{\"1\":{\"944\":1}}],[\"getsourceclassname\",{\"1\":{\"944\":1,\"948\":1}}],[\"getsingleton\",{\"1\":{\"1300\":1,\"1301\":1}}],[\"getsid\",{\"1\":{\"810\":1}}],[\"getsimplename\",{\"1\":{\"341\":1,\"625\":1,\"710\":1}}],[\"gets\",{\"1\":{\"789\":1}}],[\"getstartupdate\",{\"1\":{\"1316\":1}}],[\"getstatus\",{\"1\":{\"378\":2}}],[\"getstudent\",{\"1\":{\"1157\":1,\"1158\":1,\"1159\":2,\"1160\":3,\"1255\":1,\"1256\":1,\"1257\":1,\"1260\":1}}],[\"getstudentbysid\",{\"1\":{\"1017\":1}}],[\"getstringproperty\",{\"1\":{\"939\":1}}],[\"getstring\",{\"1\":{\"788\":1,\"799\":2,\"804\":1,\"805\":1,\"1059\":2}}],[\"getsetinvoker\",{\"1\":{\"841\":1}}],[\"getsession\",{\"1\":{\"830\":2,\"884\":2,\"1096\":2,\"1104\":1}}],[\"getsessiontrackingmodes\",{\"1\":{\"705\":1}}],[\"getsex\",{\"1\":{\"810\":1}}],[\"getservletinfo\",{\"1\":{\"1054\":1}}],[\"getservletname\",{\"1\":{\"625\":3}}],[\"getservletcontextattributename\",{\"1\":{\"625\":1}}],[\"getservletcontext\",{\"1\":{\"625\":4,\"1084\":2,\"1086\":1}}],[\"getservletconfig\",{\"1\":{\"625\":1,\"1054\":1}}],[\"getservletconfigclasses\",{\"1\":{\"552\":1}}],[\"getservletmappings\",{\"1\":{\"552\":1}}],[\"getsuperclass\",{\"1\":{\"343\":2}}],[\"getscore\",{\"1\":{\"222\":2}}],[\"gettransaction\",{\"1\":{\"1283\":1}}],[\"gettransactionfactoryfromenvironment\",{\"1\":{\"1242\":1}}],[\"gettimeout\",{\"1\":{\"1272\":1}}],[\"getting\",{\"1\":{\"1246\":1}}],[\"getter和setter\",{\"1\":{\"949\":1}}],[\"getter和\",{\"1\":{\"812\":1}}],[\"getter\",{\"1\":{\"810\":1,\"812\":1}}],[\"gettargetbeanname\",{\"1\":{\"706\":1}}],[\"getthreadname\",{\"1\":{\"295\":1}}],[\"getthreadinfo\",{\"1\":{\"295\":1}}],[\"getthreadmxbean\",{\"1\":{\"295\":1}}],[\"gettypealiasregistry\",{\"1\":{\"904\":1}}],[\"gettypename\",{\"1\":{\"341\":1,\"343\":1}}],[\"gettype\",{\"1\":{\"222\":1}}],[\"getapplicationstartup\",{\"1\":{\"1318\":1,\"1319\":1}}],[\"getapplicationname\",{\"1\":{\"1316\":1}}],[\"getapplicationcontext\",{\"1\":{\"1191\":1}}],[\"getautowirecapablebeanfactory\",{\"1\":{\"1296\":1,\"1316\":1}}],[\"getautocommit\",{\"1\":{\"1246\":2,\"1247\":2,\"1273\":1}}],[\"getauthenticationmanager\",{\"1\":{\"666\":2}}],[\"getargs\",{\"1\":{\"1223\":1,\"1224\":1,\"1225\":1,\"1234\":1}}],[\"getasyncmanager\",{\"1\":{\"626\":2}}],[\"getattribute\",{\"1\":{\"582\":1,\"636\":2,\"708\":1,\"1083\":1,\"1084\":1,\"1096\":1,\"1104\":1}}],[\"getannotations\",{\"1\":{\"365\":2}}],[\"getactualtypearguments\",{\"1\":{\"343\":4}}],[\"getallthreadids\",{\"1\":{\"295\":1}}],[\"getabsolutepath\",{\"1\":{\"255\":1,\"619\":1}}],[\"getaverage\",{\"1\":{\"228\":1}}],[\"getcreatedtimestamp\",{\"1\":{\"1246\":1,\"1247\":1}}],[\"getcheckouttime\",{\"1\":{\"1246\":1,\"1247\":2}}],[\"getchildnodes\",{\"1\":{\"819\":1}}],[\"getcallerclass\",{\"1\":{\"789\":1}}],[\"getcookies\",{\"1\":{\"1091\":1,\"1093\":1}}],[\"getconfiglocations\",{\"1\":{\"1297\":1}}],[\"getconfigresources\",{\"1\":{\"1297\":1}}],[\"getconnectiontypecode\",{\"1\":{\"1247\":1}}],[\"getconnection\",{\"1\":{\"788\":1,\"789\":7,\"796\":1,\"798\":1,\"804\":1,\"805\":1,\"806\":4,\"1242\":3,\"1244\":3,\"1245\":2,\"1246\":1,\"1260\":2,\"1272\":1,\"1273\":1,\"1278\":1}}],[\"getcontextclassloader\",{\"1\":{\"789\":1}}],[\"getcontext\",{\"1\":{\"712\":1}}],[\"getcontextholderstrategy\",{\"1\":{\"709\":1}}],[\"getconstructors\",{\"1\":{\"799\":1}}],[\"getconstructor\",{\"1\":{\"348\":2,\"349\":1,\"799\":1}}],[\"getcode\",{\"1\":{\"523\":1}}],[\"getcount\",{\"1\":{\"228\":1}}],[\"getclassloader\",{\"1\":{\"341\":1,\"355\":4,\"789\":1}}],[\"getclass\",{\"1\":{\"241\":4,\"339\":1,\"343\":10,\"372\":2,\"485\":1,\"625\":1,\"710\":1,\"712\":1,\"789\":3,\"799\":2,\"842\":1,\"939\":1,\"1189\":1,\"1222\":1}}],[\"getkey\",{\"1\":{\"213\":1}}],[\"getvalue\",{\"1\":{\"172\":3,\"213\":1,\"1091\":1,\"1093\":2,\"1202\":2,\"1203\":4,\"1204\":2,\"1205\":1,\"1207\":2,\"1208\":2,\"1209\":2,\"1210\":1,\"1211\":2}}],[\"get\",{\"1\":{\"48\":2,\"181\":1,\"182\":1,\"213\":1,\"214\":3,\"228\":1,\"241\":1,\"267\":1,\"319\":1,\"320\":1,\"350\":1,\"454\":1,\"462\":1,\"480\":1,\"512\":2,\"589\":4,\"617\":1,\"620\":1,\"626\":1,\"710\":1,\"727\":1,\"937\":1,\"938\":2,\"1059\":3,\"1076\":1,\"1091\":1,\"1096\":1,\"1148\":1,\"1246\":3,\"1301\":5}}],[\"g\",{\"1\":{\"78\":3,\"96\":4,\"97\":2,\"98\":1,\"99\":2,\"104\":1,\"110\":2,\"113\":1,\"1047\":1}}],[\"gt\",{\"1\":{\"836\":2}}],[\"gt+1​∣st+1​=s\",{\"1\":{\"44\":2}}],[\"gt+1​∣st​=s\",{\"1\":{\"42\":2,\"44\":5,\"45\":1}}],[\"gt​−v^\",{\"1\":{\"137\":1}}],[\"gt​​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"42\":1}}],[\"gt​∣st​=s\",{\"1\":{\"40\":1,\"42\":1,\"48\":3,\"49\":2,\"75\":2,\"77\":1,\"78\":1}}],[\"gt​\",{\"1\":{\"40\":2,\"42\":1,\"78\":1,\"137\":2}}],[\"gt​也是一个随机变量\",{\"1\":{\"39\":1}}],[\"gt​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"39\":1}}],[\"gt​=e\",{\"1\":{\"13\":1}}],[\"gkn​​\",{\"1\":{\"9\":1}}],[\"c容器\",{\"0\":{\"1352\":1}}],[\"cgi\",{\"1\":{\"1047\":1}}],[\"cdata\",{\"1\":{\"818\":2}}],[\"circular\",{\"1\":{\"1181\":1,\"1300\":1}}],[\"ci\",{\"1\":{\"749\":1}}],[\"city\",{\"1\":{\"525\":1}}],[\"ck\",{\"1\":{\"748\":1}}],[\"cname\",{\"1\":{\"939\":5}}],[\"cno\",{\"1\":{\"779\":1}}],[\"cn\",{\"1\":{\"727\":1,\"824\":1,\"902\":1,\"1091\":1,\"1096\":1}}],[\"cj\",{\"1\":{\"664\":1,\"788\":1,\"805\":1,\"824\":1,\"852\":1,\"904\":1,\"936\":1,\"1017\":1,\"1255\":1,\"1259\":1,\"1260\":2,\"1276\":1}}],[\"csdn\",{\"1\":{\"1190\":1}}],[\"cst\",{\"1\":{\"852\":1}}],[\"csrffilter\",{\"1\":{\"714\":1}}],[\"csrf会针对patch\",{\"1\":{\"660\":1}}],[\"csrf\",{\"1\":{\"641\":2,\"660\":9,\"666\":4,\"682\":2,\"683\":2,\"684\":1,\"1047\":2}}],[\"csrf是我们要介绍的第一种攻击形式\",{\"1\":{\"641\":1}}],[\"csrf跨站请求伪造攻击\",{\"0\":{\"641\":1}}],[\"css\",{\"1\":{\"564\":1,\"1047\":1,\"1104\":1}}],[\"cwac\",{\"1\":{\"625\":5}}],[\"custom\",{\"1\":{\"1148\":1}}],[\"customcondition\",{\"1\":{\"980\":2}}],[\"customizeregistration\",{\"1\":{\"619\":1}}],[\"currently\",{\"1\":{\"1181\":1}}],[\"current\",{\"1\":{\"995\":1,\"1211\":1,\"1219\":1}}],[\"currentposition\",{\"1\":{\"710\":4}}],[\"currenttimemillis\",{\"1\":{\"625\":1,\"626\":1,\"1246\":6}}],[\"currentthread\",{\"1\":{\"297\":2,\"299\":1,\"301\":1,\"323\":1,\"324\":1,\"330\":1,\"331\":2,\"789\":1,\"948\":1,\"1188\":2}}],[\"cursor<user>\",{\"1\":{\"836\":1}}],[\"cursor<t>\",{\"1\":{\"836\":1}}],[\"cursor\",{\"1\":{\"190\":1,\"836\":2}}],[\"c则是控制器\",{\"1\":{\"541\":1}}],[\"c>\",{\"1\":{\"438\":1}}],[\"central\",{\"1\":{\"1008\":1}}],[\"ceiling\",{\"1\":{\"386\":1}}],[\"certain\",{\"1\":{\"148\":1}}],[\"c++实现\",{\"1\":{\"340\":1}}],[\"cpdd\",{\"1\":{\"339\":1}}],[\"cpu一般通过时间片轮转调度算法\",{\"1\":{\"295\":1}}],[\"cpu一个核心同时只能处理一件事情\",{\"1\":{\"295\":1}}],[\"cron\",{\"1\":{\"1190\":2}}],[\"cross\",{\"1\":{\"641\":1}}],[\"creation\",{\"1\":{\"1181\":1}}],[\"creating\",{\"1\":{\"1181\":3}}],[\"createannotatedbeandefreader\",{\"1\":{\"1318\":2}}],[\"createtransactionifnecessary\",{\"1\":{\"1283\":1}}],[\"created\",{\"1\":{\"852\":1,\"1246\":1}}],[\"createuser\",{\"1\":{\"664\":1,\"665\":1}}],[\"createwebapplicationcontext\",{\"1\":{\"625\":1}}],[\"create\",{\"1\":{\"296\":1,\"662\":3,\"744\":1,\"748\":1,\"749\":2,\"750\":1,\"772\":2,\"779\":2,\"780\":1,\"781\":1,\"1318\":1}}],[\"createstatement\",{\"1\":{\"788\":1,\"790\":1,\"796\":1,\"798\":1,\"804\":1,\"806\":4}}],[\"creates\",{\"1\":{\"296\":1}}],[\"credentials\",{\"1\":{\"1047\":1}}],[\"critic\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"ccc\",{\"1\":{\"171\":1,\"475\":2,\"528\":1,\"991\":1,\"1207\":1}}],[\"cleaned\",{\"1\":{\"1148\":1}}],[\"clean\",{\"1\":{\"1148\":1}}],[\"clean命令\",{\"1\":{\"1034\":1}}],[\"cleanup作用与局部变量\",{\"1\":{\"812\":1}}],[\"cleanupmultipart\",{\"1\":{\"626\":1}}],[\"cleared\",{\"1\":{\"713\":1}}],[\"clearcontext\",{\"1\":{\"708\":2,\"713\":1}}],[\"clear\",{\"1\":{\"180\":1,\"204\":1,\"213\":1,\"324\":1}}],[\"clientpreparedstatement\",{\"1\":{\"805\":1}}],[\"client\",{\"1\":{\"489\":1,\"490\":7,\"720\":2,\"726\":2,\"1148\":2}}],[\"claimed\",{\"1\":{\"1246\":1}}],[\"claimedoverdueconnectioncount\",{\"1\":{\"1246\":1}}],[\"clazz3\",{\"1\":{\"339\":1}}],[\"clazz2\",{\"1\":{\"339\":1}}],[\"clazz\",{\"1\":{\"339\":1,\"341\":6,\"348\":6,\"349\":10,\"356\":7,\"365\":4,\"799\":3,\"1209\":2}}],[\"classes\",{\"1\":{\"1181\":1,\"1291\":1,\"1319\":2}}],[\"class填写为这个类这个只是为了告诉spring我们的工厂方法在哪个位置\",{\"1\":{\"1158\":1}}],[\"class模式后\",{\"1\":{\"986\":1}}],[\"classpathmapperscanner\",{\"1\":{\"1327\":2}}],[\"classpathmapperscanner是mybatis自己实现的一个扫描器\",{\"1\":{\"1327\":1}}],[\"classpathbeandefinitionscanner\",{\"1\":{\"1318\":1}}],[\"classpathresource\",{\"1\":{\"1296\":1}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"1119\":4,\"1125\":1,\"1148\":2,\"1221\":1,\"1224\":1,\"1225\":1,\"1296\":1,\"1297\":1,\"1298\":2,\"1299\":1}}],[\"classpath\",{\"1\":{\"678\":1,\"1198\":1,\"1199\":1}}],[\"class=\",{\"1\":{\"643\":2,\"682\":4,\"683\":1,\"686\":2,\"894\":1,\"1017\":1,\"1071\":1,\"1119\":2,\"1125\":1,\"1126\":2,\"1127\":6,\"1128\":1,\"1130\":1,\"1131\":2,\"1133\":7,\"1134\":3,\"1136\":2,\"1137\":2,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1149\":3,\"1150\":2,\"1151\":2,\"1158\":1,\"1159\":1,\"1160\":1,\"1167\":1,\"1172\":2,\"1211\":1,\"1218\":2,\"1231\":2,\"1255\":1}}],[\"class>com\",{\"1\":{\"1054\":1}}],[\"class>\",{\"1\":{\"545\":1,\"548\":1,\"1054\":1}}],[\"class>org\",{\"1\":{\"545\":1,\"548\":1}}],[\"classloader\",{\"1\":{\"356\":3,\"789\":3,\"1109\":5,\"1186\":3,\"1244\":1}}],[\"class<t>\",{\"1\":{\"799\":1,\"1300\":2}}],[\"class<a>\",{\"1\":{\"504\":1}}],[\"class<student>\",{\"1\":{\"348\":3,\"365\":2}}],[\"class<string\",{\"1\":{\"341\":1}}],[\"class<string>\",{\"1\":{\"339\":1,\"462\":1}}],[\"class<integer>\",{\"1\":{\"340\":2}}],[\"class<\",{\"1\":{\"339\":2,\"340\":1,\"343\":1,\"349\":3,\"356\":2,\"372\":1,\"552\":2,\"652\":1,\"789\":1,\"799\":1,\"1160\":1,\"1180\":1,\"1247\":1,\"1279\":2,\"1317\":1,\"1319\":1,\"1327\":1,\"1328\":1}}],[\"class对象中包含我们类的一些信息\",{\"1\":{\"337\":1}}],[\"class文件\",{\"1\":{\"337\":1,\"356\":1,\"1034\":1}}],[\"classnotfoundexception\",{\"1\":{\"288\":1,\"290\":1,\"339\":1,\"349\":1,\"350\":1,\"423\":2,\"798\":1,\"805\":1,\"806\":4}}],[\"class关键字我们会在后面反射中介绍\",{\"1\":{\"237\":1}}],[\"class\",{\"0\":{\"338\":1,\"340\":1,\"341\":1,\"342\":1},\"1\":{\"92\":1,\"161\":1,\"162\":1,\"166\":4,\"171\":1,\"172\":1,\"173\":4,\"180\":1,\"182\":3,\"193\":1,\"199\":1,\"215\":2,\"218\":1,\"222\":1,\"224\":1,\"237\":1,\"241\":4,\"274\":1,\"275\":2,\"277\":3,\"278\":2,\"288\":1,\"289\":1,\"290\":1,\"312\":6,\"322\":2,\"324\":2,\"331\":1,\"339\":4,\"340\":4,\"341\":1,\"343\":13,\"348\":7,\"349\":11,\"350\":4,\"355\":6,\"356\":5,\"363\":1,\"364\":2,\"365\":2,\"372\":1,\"373\":1,\"375\":2,\"376\":2,\"377\":1,\"378\":2,\"398\":1,\"408\":7,\"409\":2,\"410\":3,\"411\":7,\"412\":4,\"422\":2,\"437\":1,\"438\":2,\"439\":6,\"461\":1,\"462\":2,\"464\":2,\"467\":1,\"468\":1,\"480\":1,\"499\":2,\"501\":1,\"503\":2,\"504\":6,\"512\":1,\"518\":1,\"519\":1,\"521\":1,\"522\":1,\"523\":2,\"524\":1,\"525\":3,\"549\":1,\"550\":3,\"552\":4,\"553\":1,\"554\":1,\"560\":1,\"561\":1,\"569\":1,\"583\":1,\"588\":2,\"589\":1,\"595\":1,\"600\":1,\"604\":1,\"605\":2,\"619\":1,\"625\":1,\"626\":1,\"631\":1,\"636\":1,\"650\":1,\"651\":1,\"652\":3,\"658\":2,\"659\":1,\"664\":1,\"666\":1,\"668\":1,\"669\":1,\"671\":1,\"672\":1,\"679\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"692\":1,\"695\":2,\"697\":1,\"706\":1,\"709\":1,\"720\":2,\"726\":2,\"727\":1,\"788\":4,\"789\":3,\"796\":1,\"799\":2,\"810\":2,\"826\":1,\"830\":1,\"835\":1,\"841\":1,\"842\":2,\"843\":1,\"849\":2,\"853\":2,\"855\":2,\"865\":3,\"871\":1,\"877\":1,\"883\":3,\"884\":2,\"888\":1,\"898\":1,\"900\":4,\"902\":2,\"904\":1,\"908\":1,\"910\":2,\"911\":1,\"918\":1,\"927\":1,\"937\":1,\"944\":1,\"950\":2,\"956\":1,\"959\":2,\"973\":1,\"980\":1,\"986\":3,\"988\":3,\"991\":1,\"993\":1,\"1008\":2,\"1017\":3,\"1023\":1,\"1032\":1,\"1035\":1,\"1054\":1,\"1059\":1,\"1064\":1,\"1069\":1,\"1071\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1093\":1,\"1102\":1,\"1103\":1,\"1104\":2,\"1105\":1,\"1116\":3,\"1117\":4,\"1119\":3,\"1125\":1,\"1126\":4,\"1129\":4,\"1132\":4,\"1133\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1149\":2,\"1157\":2,\"1159\":1,\"1160\":2,\"1166\":2,\"1167\":1,\"1168\":2,\"1169\":2,\"1172\":1,\"1173\":2,\"1174\":1,\"1175\":1,\"1176\":2,\"1177\":3,\"1178\":1,\"1179\":1,\"1180\":2,\"1181\":5,\"1186\":2,\"1188\":4,\"1189\":1,\"1190\":1,\"1191\":1,\"1192\":6,\"1198\":1,\"1199\":1,\"1200\":1,\"1203\":2,\"1207\":1,\"1209\":1,\"1211\":1,\"1218\":2,\"1221\":1,\"1222\":1,\"1223\":1,\"1224\":1,\"1225\":2,\"1231\":5,\"1232\":2,\"1233\":3,\"1244\":1,\"1245\":2,\"1247\":4,\"1254\":1,\"1255\":1,\"1256\":3,\"1257\":3,\"1259\":1,\"1260\":3,\"1273\":3,\"1276\":1,\"1277\":1,\"1278\":3,\"1281\":1,\"1288\":3,\"1291\":3,\"1296\":3,\"1298\":11,\"1299\":1,\"1300\":1,\"1307\":2,\"1308\":1,\"1310\":3,\"1311\":5,\"1319\":1,\"1326\":3,\"1327\":1,\"1328\":3}}],[\"closing\",{\"1\":{\"852\":1}}],[\"closetransaction\",{\"1\":{\"1242\":1}}],[\"close=\",{\"1\":{\"876\":1}}],[\"closeable\",{\"1\":{\"836\":1}}],[\"close\",{\"1\":{\"247\":1,\"264\":2,\"719\":1,\"720\":2,\"726\":1,\"727\":1,\"1148\":2,\"1176\":1,\"1181\":1,\"1247\":4,\"1272\":2}}],[\"closed\",{\"1\":{\"47\":1,\"1047\":1,\"1247\":1,\"1296\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"372\":1,\"377\":2,\"421\":1}}],[\"clone\",{\"1\":{\"372\":2,\"377\":6,\"421\":1,\"423\":1}}],[\"cloneable\",{\"1\":{\"182\":2,\"199\":1,\"215\":1,\"224\":1,\"377\":2}}],[\"could\",{\"1\":{\"789\":1,\"1246\":3}}],[\"countedwait\",{\"1\":{\"1246\":3}}],[\"count\",{\"1\":{\"515\":4,\"610\":2,\"765\":3}}],[\"correct\",{\"1\":{\"789\":1}}],[\"core\",{\"1\":{\"52\":1,\"811\":1,\"1113\":2,\"1118\":1,\"1211\":1,\"1219\":1}}],[\"columns\",{\"1\":{\"852\":2}}],[\"column=\",{\"1\":{\"835\":2,\"841\":2,\"850\":8,\"851\":4,\"853\":5,\"854\":4,\"855\":9,\"898\":2,\"900\":3}}],[\"column\",{\"1\":{\"751\":2,\"835\":1,\"898\":2,\"900\":3,\"901\":2}}],[\"collate\",{\"1\":{\"749\":1}}],[\"collocations\",{\"1\":{\"232\":1}}],[\"collectstreamdemo\",{\"1\":{\"522\":1}}],[\"collectors\",{\"1\":{\"228\":3,\"522\":5,\"528\":2}}],[\"collect\",{\"1\":{\"228\":3,\"522\":6,\"528\":2}}],[\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",{\"1\":{\"876\":1}}],[\"collection=\",{\"1\":{\"876\":1,\"877\":1}}],[\"collection>\",{\"1\":{\"853\":1}}],[\"collections\",{\"0\":{\"231\":1,\"232\":1},\"1\":{\"233\":2,\"234\":1,\"235\":1,\"236\":3,\"237\":2,\"550\":1}}],[\"collection\",{\"1\":{\"181\":2,\"204\":3,\"212\":1,\"516\":1,\"853\":1}}],[\"collection<v>\",{\"1\":{\"213\":1}}],[\"collection<\",{\"1\":{\"180\":4,\"181\":1,\"204\":4}}],[\"collection<e>\",{\"1\":{\"180\":1,\"181\":1,\"200\":1,\"204\":1}}],[\"copy\",{\"1\":{\"620\":1,\"1074\":1,\"1075\":1}}],[\"copyofarrays\",{\"1\":{\"432\":1}}],[\"copyof\",{\"1\":{\"171\":1,\"182\":1}}],[\"cookies\",{\"1\":{\"1093\":3}}],[\"cookie消失\",{\"1\":{\"1092\":1}}],[\"cookie使用的版本号\",{\"1\":{\"1092\":1}}],[\"cookie失效的时间\",{\"1\":{\"1092\":1}}],[\"cookie的使用路径\",{\"1\":{\"1092\":1}}],[\"cookie的值\",{\"1\":{\"1092\":1}}],[\"cookie的名称\",{\"1\":{\"1092\":1}}],[\"cookie一旦创建\",{\"1\":{\"1092\":1}}],[\"cookie头\",{\"1\":{\"642\":1}}],[\"cookie属性访问cookie\",{\"1\":{\"642\":1}}],[\"cookie等方式将会话id传递给用户\",{\"1\":{\"642\":1}}],[\"cookie\",{\"0\":{\"1089\":1,\"1090\":1},\"1\":{\"585\":1,\"642\":1,\"1090\":1,\"1091\":15,\"1092\":1,\"1093\":17,\"1094\":1,\"1096\":3}}],[\"cookievalue\",{\"1\":{\"585\":1}}],[\"cookievalue注解\",{\"1\":{\"585\":1}}],[\"cookievalue和\",{\"0\":{\"584\":1}}],[\"commondatasource\",{\"1\":{\"1242\":1}}],[\"common\",{\"1\":{\"1109\":1}}],[\"commons\",{\"1\":{\"873\":2,\"951\":1,\"1074\":1}}],[\"commonpool\",{\"1\":{\"516\":1}}],[\"committing\",{\"1\":{\"1273\":1}}],[\"committed\",{\"1\":{\"782\":1,\"1267\":1}}],[\"commit\",{\"1\":{\"782\":1,\"806\":5,\"865\":1,\"884\":1,\"1272\":2,\"1273\":3}}],[\"comment\",{\"1\":{\"324\":1,\"1092\":1}}],[\"comments\",{\"1\":{\"70\":1}}],[\"combinedprinter\",{\"1\":{\"511\":2}}],[\"com\",{\"1\":{\"277\":8,\"278\":1,\"349\":4,\"356\":3,\"378\":6,\"399\":1,\"403\":1,\"411\":4,\"412\":2,\"461\":1,\"464\":4,\"465\":2,\"466\":4,\"467\":7,\"468\":3,\"490\":5,\"549\":1,\"553\":1,\"560\":1,\"617\":2,\"636\":1,\"641\":1,\"642\":1,\"664\":1,\"671\":3,\"788\":1,\"805\":1,\"824\":1,\"826\":1,\"831\":1,\"832\":2,\"835\":1,\"836\":2,\"841\":2,\"842\":2,\"843\":1,\"849\":1,\"851\":3,\"852\":3,\"853\":2,\"854\":2,\"855\":3,\"861\":1,\"862\":1,\"886\":1,\"887\":1,\"894\":2,\"895\":1,\"897\":1,\"904\":3,\"908\":1,\"919\":1,\"929\":2,\"930\":4,\"946\":1,\"1008\":1,\"1010\":1,\"1017\":3,\"1071\":2,\"1092\":2,\"1119\":6,\"1125\":1,\"1126\":2,\"1127\":6,\"1128\":1,\"1130\":1,\"1131\":2,\"1133\":7,\"1134\":3,\"1136\":2,\"1137\":2,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1149\":3,\"1150\":2,\"1151\":2,\"1158\":1,\"1159\":1,\"1160\":1,\"1167\":1,\"1172\":2,\"1177\":2,\"1188\":1,\"1190\":1,\"1198\":1,\"1225\":1,\"1237\":1,\"1255\":1,\"1259\":1,\"1260\":5,\"1276\":1,\"1278\":1,\"1283\":2}}],[\"completed\",{\"1\":{\"1260\":2,\"1278\":1}}],[\"complete\",{\"1\":{\"1148\":1}}],[\"completablefuture\",{\"1\":{\"480\":1}}],[\"compile命令可以将项目编译为\",{\"1\":{\"1034\":1}}],[\"compile\",{\"1\":{\"1016\":1,\"1034\":1}}],[\"compiler\",{\"1\":{\"1002\":4,\"1032\":4}}],[\"compiled\",{\"1\":{\"378\":1}}],[\"compatibility\",{\"1\":{\"789\":1}}],[\"comparable<string>\",{\"1\":{\"462\":1}}],[\"comparable\",{\"1\":{\"234\":1}}],[\"comparator\",{\"1\":{\"181\":1,\"203\":1}}],[\"comparator<\",{\"1\":{\"181\":1}}],[\"comparator<integer>\",{\"1\":{\"171\":2,\"449\":1,\"451\":1}}],[\"compareto\",{\"1\":{\"451\":3,\"452\":1}}],[\"compareandset\",{\"1\":{\"264\":1}}],[\"compare方法要求返回一个int来表示两个数的大小关系\",{\"1\":{\"171\":1}}],[\"compare\",{\"1\":{\"171\":2,\"449\":3,\"451\":3}}],[\"componentclasses\",{\"1\":{\"1317\":2,\"1319\":4}}],[\"component将其注册为bean即可\",{\"1\":{\"1233\":1}}],[\"component快速注册bean\",{\"1\":{\"1232\":1}}],[\"components\",{\"1\":{\"1181\":2}}],[\"componentscan等\",{\"1\":{\"1318\":1}}],[\"componentscans\",{\"1\":{\"671\":1,\"1177\":1}}],[\"componentscan\",{\"1\":{\"553\":1,\"560\":1,\"671\":2,\"1177\":3,\"1188\":1,\"1190\":1,\"1198\":1,\"1232\":1,\"1254\":1,\"1257\":1,\"1259\":1,\"1276\":1}}],[\"component注册的bean\",{\"1\":{\"1179\":1}}],[\"component注解来将一个类进行注册\",{\"1\":{\"1177\":1}}],[\"component形式注册的bean\",{\"1\":{\"1178\":1}}],[\"component的类注册为bean\",{\"1\":{\"1177\":1}}],[\"component即可\",{\"1\":{\"1177\":1}}],[\"component声明的bean\",{\"1\":{\"1177\":1}}],[\"component\",{\"1\":{\"549\":1,\"1177\":1,\"1178\":1,\"1179\":1,\"1180\":1,\"1181\":5,\"1186\":2,\"1188\":1,\"1191\":1,\"1192\":2,\"1199\":1,\"1200\":1,\"1203\":1,\"1207\":1,\"1209\":1,\"1232\":1,\"1233\":1,\"1277\":1,\"1281\":1,\"1307\":2,\"1308\":1,\"1311\":1,\"1319\":2,\"1328\":1}}],[\"composed\",{\"1\":{\"509\":3}}],[\"computeifabsent\",{\"1\":{\"221\":2}}],[\"computeifpresent\",{\"1\":{\"221\":2}}],[\"compute\",{\"1\":{\"221\":3}}],[\"codes\",{\"1\":{\"1260\":1}}],[\"code=\",{\"1\":{\"523\":1}}],[\"coder\",{\"1\":{\"453\":2}}],[\"code>\",{\"1\":{\"296\":3}}],[\"code\",{\"0\":{\"1337\":1},\"1\":{\"340\":2,\"509\":6,\"523\":9,\"524\":5,\"1148\":1,\"1181\":2},\"2\":{\"167\":1,\"174\":1,\"183\":1,\"195\":1,\"208\":1,\"225\":1,\"229\":1,\"238\":1,\"242\":1,\"256\":1,\"271\":1,\"279\":1,\"291\":1,\"306\":1,\"314\":1,\"325\":1,\"332\":1,\"344\":1,\"351\":1,\"357\":1,\"366\":1,\"379\":1,\"387\":1,\"404\":1,\"416\":1,\"426\":1,\"433\":1,\"440\":1,\"455\":1,\"469\":1,\"481\":1,\"491\":1,\"505\":1,\"526\":1,\"529\":1,\"532\":1,\"537\":1,\"555\":1,\"565\":1,\"590\":1,\"606\":1,\"621\":1,\"627\":1,\"632\":1,\"637\":1,\"644\":1,\"653\":1,\"673\":1,\"688\":1,\"700\":1,\"715\":1,\"722\":1,\"728\":1,\"740\":1,\"757\":1,\"775\":1,\"783\":1,\"792\":1,\"800\":1,\"807\":1,\"813\":1,\"820\":1,\"827\":1,\"837\":1,\"844\":1,\"856\":1,\"866\":1,\"878\":1,\"889\":1,\"905\":1,\"913\":1,\"922\":1,\"931\":1,\"940\":1,\"952\":1,\"964\":1,\"981\":1,\"996\":1,\"1004\":1,\"1011\":1,\"1019\":1,\"1027\":1,\"1039\":1,\"1043\":1,\"1049\":1,\"1065\":1,\"1077\":1,\"1087\":1,\"1098\":1,\"1106\":1,\"1110\":1,\"1120\":1,\"1142\":1,\"1153\":1,\"1161\":1,\"1182\":1,\"1193\":1,\"1212\":1,\"1227\":1,\"1238\":1,\"1248\":1,\"1261\":1,\"1285\":1,\"1292\":1,\"1302\":1,\"1312\":1,\"1322\":1,\"1329\":1}}],[\"coefficient\",{\"1\":{\"97\":1}}],[\"conn\",{\"1\":{\"1246\":22,\"1247\":18}}],[\"connectivity\",{\"1\":{\"787\":1}}],[\"connectionimpl\",{\"1\":{\"852\":1,\"1260\":1}}],[\"connection是数据库的连接对象\",{\"1\":{\"790\":1}}],[\"connection\",{\"1\":{\"576\":1,\"727\":1,\"788\":3,\"789\":5,\"796\":3,\"798\":3,\"804\":3,\"805\":3,\"806\":23,\"852\":4,\"1091\":2,\"1096\":2,\"1242\":2,\"1244\":8,\"1245\":2,\"1246\":14,\"1247\":7,\"1260\":1,\"1272\":1,\"1273\":14}}],[\"connect\",{\"1\":{\"721\":2,\"789\":2}}],[\"connector\",{\"1\":{\"663\":1,\"1017\":1,\"1033\":1,\"1071\":1,\"1253\":1}}],[\"conditionevaluator\",{\"1\":{\"1318\":2}}],[\"condition\",{\"1\":{\"970\":1,\"1245\":2,\"1246\":2}}],[\"con\",{\"1\":{\"789\":3,\"806\":3}}],[\"concurrenthashmap\",{\"1\":{\"1244\":1}}],[\"concurrentsessionfilter\",{\"1\":{\"714\":1}}],[\"concise\",{\"1\":{\"1181\":1}}],[\"concepts\",{\"1\":{\"52\":1}}],[\"conf文件夹\",{\"1\":{\"1010\":1}}],[\"conf\",{\"1\":{\"680\":7,\"683\":4,\"684\":3,\"686\":4,\"687\":4,\"1047\":1}}],[\"configlocations\",{\"1\":{\"1297\":3}}],[\"configresources\",{\"1\":{\"1297\":3}}],[\"config>\",{\"1\":{\"1097\":2,\"1218\":2,\"1220\":2,\"1225\":2,\"1231\":2}}],[\"config\",{\"1\":{\"824\":4,\"826\":1,\"830\":1,\"910\":4,\"911\":1,\"939\":1,\"1017\":2,\"1047\":1,\"1071\":4,\"1072\":1,\"1242\":2,\"1254\":1,\"1255\":2}}],[\"config<\",{\"1\":{\"649\":1}}],[\"configuring\",{\"1\":{\"1181\":1}}],[\"configurablelistablebeanfactory\",{\"1\":{\"1296\":1,\"1311\":2,\"1320\":1,\"1321\":1}}],[\"configurablewebapplicationcontext\",{\"1\":{\"625\":3}}],[\"configuration>\",{\"1\":{\"824\":1,\"1017\":1,\"1037\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"configurationclasses\",{\"1\":{\"705\":2}}],[\"configuration\",{\"1\":{\"553\":1,\"560\":1,\"651\":1,\"658\":1,\"659\":1,\"664\":1,\"666\":1,\"671\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"695\":1,\"824\":2,\"904\":9,\"1017\":1,\"1047\":1,\"1071\":1,\"1166\":1,\"1167\":1,\"1168\":1,\"1172\":1,\"1177\":2,\"1181\":4,\"1188\":1,\"1190\":1,\"1198\":1,\"1232\":1,\"1242\":5,\"1254\":1,\"1255\":1,\"1257\":1,\"1259\":1,\"1276\":1,\"1327\":1}}],[\"configureconnection\",{\"1\":{\"1244\":1}}],[\"configured\",{\"1\":{\"1148\":1}}],[\"configuredefaultservlethandling\",{\"1\":{\"564\":1,\"678\":1}}],[\"configures\",{\"1\":{\"1148\":1}}],[\"configureandrefreshwebapplicationcontext\",{\"1\":{\"625\":1}}],[\"configuremessageconverters\",{\"1\":{\"616\":1}}],[\"configurer\",{\"1\":{\"564\":2,\"678\":2}}],[\"consequence\",{\"1\":{\"1300\":1}}],[\"consistency\",{\"1\":{\"1266\":1}}],[\"consider\",{\"1\":{\"58\":1}}],[\"considered\",{\"1\":{\"4\":1}}],[\"cons\",{\"1\":{\"1181\":1}}],[\"consolehandler会配置一个simpleformatter对象\",{\"1\":{\"921\":1}}],[\"consolehandler\",{\"1\":{\"918\":2,\"919\":2,\"929\":1,\"939\":2,\"947\":1,\"951\":2,\"1047\":1}}],[\"constraint\",{\"1\":{\"662\":1,\"748\":6}}],[\"constructorargs\",{\"1\":{\"900\":1}}],[\"constructorargs注解\",{\"1\":{\"900\":1}}],[\"constructor>\",{\"1\":{\"841\":2,\"900\":1}}],[\"constructor<t>\",{\"1\":{\"799\":1}}],[\"constructor<\",{\"1\":{\"349\":1}}],[\"constructor<student>\",{\"1\":{\"348\":2}}],[\"constructor\",{\"1\":{\"296\":1,\"348\":5,\"349\":2,\"799\":3,\"841\":1,\"1139\":1,\"1181\":2}}],[\"const\",{\"1\":{\"636\":1,\"660\":2,\"666\":3}}],[\"constantdesc\",{\"1\":{\"462\":1}}],[\"constable\",{\"1\":{\"462\":1}}],[\"consume\",{\"1\":{\"531\":1}}],[\"consumer接口还支持链式操作\",{\"1\":{\"511\":1}}],[\"consumer接口表示一个消费者\",{\"1\":{\"508\":1}}],[\"consumer是java\",{\"1\":{\"508\":1}}],[\"consumer\",{\"1\":{\"453\":1,\"487\":1,\"509\":2,\"511\":2}}],[\"consumer<t>\",{\"1\":{\"509\":2}}],[\"consumer<string>\",{\"1\":{\"487\":1,\"510\":1,\"511\":3}}],[\"consumer<\",{\"1\":{\"189\":1,\"192\":1,\"193\":1,\"509\":1}}],[\"consumes\",{\"1\":{\"324\":1,\"569\":1,\"577\":1}}],[\"convert\",{\"1\":{\"799\":2}}],[\"converters\",{\"1\":{\"616\":2}}],[\"converges\",{\"1\":{\"98\":1}}],[\"convergence\",{\"1\":{\"58\":1}}],[\"convex问题\",{\"1\":{\"11\":1}}],[\"container\",{\"1\":{\"1118\":1,\"1148\":2}}],[\"contain\",{\"1\":{\"1047\":1}}],[\"containsvalue\",{\"1\":{\"213\":1}}],[\"containskey\",{\"1\":{\"213\":1,\"1072\":2,\"1093\":1}}],[\"containsall\",{\"1\":{\"180\":1,\"204\":1}}],[\"contains\",{\"1\":{\"180\":1,\"204\":1,\"518\":1}}],[\"continuechainbeforesuccessfulauthentication\",{\"1\":{\"711\":1}}],[\"continuing\",{\"1\":{\"19\":1}}],[\"contest\",{\"1\":{\"1084\":1}}],[\"content\",{\"0\":{\"1041\":1,\"1045\":1,\"1051\":1,\"1067\":1,\"1079\":1,\"1089\":1,\"1100\":1,\"1108\":1},\"1\":{\"577\":1,\"617\":1,\"636\":1,\"643\":2,\"666\":1,\"714\":1,\"1058\":1,\"1091\":2,\"1096\":2}}],[\"contextrefresh\",{\"1\":{\"1320\":2}}],[\"contextrefreshedevent\",{\"1\":{\"1191\":1}}],[\"contextchild\",{\"1\":{\"1298\":1}}],[\"contextconfiguration注解来表示要加载哪一个配置文件\",{\"1\":{\"1291\":1}}],[\"contextconfiguration\",{\"1\":{\"1291\":1}}],[\"contextparent\",{\"1\":{\"1298\":2}}],[\"context<\",{\"1\":{\"1118\":1}}],[\"contextattribute\",{\"1\":{\"705\":3}}],[\"contextloaderlistener\",{\"1\":{\"705\":1}}],[\"context\",{\"1\":{\"549\":4,\"625\":12,\"631\":2,\"836\":2,\"1084\":3,\"1086\":3,\"1118\":1,\"1119\":5,\"1125\":2,\"1126\":2,\"1127\":1,\"1128\":1,\"1129\":4,\"1133\":1,\"1148\":2,\"1159\":2,\"1166\":2,\"1169\":2,\"1176\":3,\"1178\":2,\"1181\":3,\"1188\":2,\"1189\":1,\"1192\":3,\"1203\":1,\"1221\":2,\"1222\":1,\"1224\":2,\"1225\":2,\"1233\":2,\"1256\":2,\"1257\":2,\"1260\":2,\"1278\":2,\"1288\":2,\"1296\":2,\"1299\":2,\"1318\":1,\"1319\":1,\"1320\":2,\"1328\":3}}],[\"context=\",{\"1\":{\"549\":1}}],[\"contrast\",{\"1\":{\"1148\":1}}],[\"contract\",{\"1\":{\"296\":1}}],[\"contractive\",{\"1\":{\"58\":1}}],[\"contraction\",{\"1\":{\"53\":2,\"58\":2,\"62\":1}}],[\"control的缩写\",{\"1\":{\"1115\":1}}],[\"control\",{\"1\":{\"727\":1,\"744\":1,\"1091\":1,\"1096\":1,\"1181\":1}}],[\"controller中定义的\",{\"1\":{\"625\":1}}],[\"controlleradvice\",{\"1\":{\"602\":1,\"603\":1,\"605\":1}}],[\"controller控制器2\",{\"0\":{\"568\":1}}],[\"controller控制器1\",{\"0\":{\"558\":1}}],[\"controller注解即可\",{\"1\":{\"561\":1}}],[\"controller\",{\"1\":{\"541\":1,\"549\":1,\"553\":1,\"554\":1,\"560\":2,\"561\":1,\"569\":1,\"588\":1,\"589\":1,\"603\":1,\"636\":1,\"658\":1,\"671\":1,\"679\":1,\"695\":1,\"714\":1}}],[\"catalina\",{\"1\":{\"1109\":1}}],[\"catch代码块\",{\"1\":{\"812\":1}}],[\"catch\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"329\":2,\"331\":2,\"356\":2,\"424\":10,\"531\":1,\"620\":1,\"625\":2,\"626\":5,\"711\":2,\"719\":3,\"720\":2,\"726\":2,\"727\":2,\"788\":1,\"789\":1,\"796\":1,\"798\":1,\"799\":1,\"804\":1,\"805\":1,\"806\":4,\"819\":1,\"830\":1,\"841\":2,\"1072\":1,\"1225\":2,\"1242\":1,\"1246\":2,\"1247\":1,\"1320\":1}}],[\"cause\",{\"1\":{\"841\":1,\"843\":1,\"1242\":1}}],[\"causes\",{\"1\":{\"296\":1}}],[\"cached\",{\"1\":{\"1300\":2}}],[\"cacheenabled\",{\"1\":{\"1017\":1}}],[\"cachenamespace\",{\"1\":{\"903\":1}}],[\"cachenamespace注解直接定义在接口上即可\",{\"1\":{\"903\":1}}],[\"cache\",{\"1\":{\"384\":1,\"727\":1,\"1091\":1,\"1096\":1}}],[\"call\",{\"1\":{\"1296\":1}}],[\"callbacks\",{\"1\":{\"1148\":1}}],[\"callback\",{\"1\":{\"1148\":1}}],[\"callersensitive\",{\"1\":{\"789\":1}}],[\"callercl\",{\"1\":{\"789\":5}}],[\"caller\",{\"1\":{\"509\":1,\"789\":4}}],[\"called\",{\"1\":{\"19\":1,\"81\":1,\"86\":1,\"296\":1,\"1148\":2}}],[\"calls\",{\"1\":{\"324\":1}}],[\"cast\",{\"1\":{\"341\":1}}],[\"case后直接添加匹配值\",{\"1\":{\"497\":1}}],[\"cased\",{\"1\":{\"264\":1}}],[\"case\",{\"1\":{\"264\":1,\"495\":5,\"496\":3,\"497\":4,\"1148\":1}}],[\"cas无锁算法\",{\"1\":{\"264\":1}}],[\"capacity\",{\"1\":{\"182\":2,\"217\":5}}],[\"carlo\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"candidate设定false时\",{\"1\":{\"1140\":1}}],[\"candidate=\",{\"1\":{\"1140\":1}}],[\"cannot\",{\"1\":{\"789\":1}}],[\"cancelrefresh\",{\"1\":{\"1320\":1}}],[\"cancelling\",{\"1\":{\"1181\":1}}],[\"cancelled\",{\"1\":{\"324\":1}}],[\"cancel\",{\"1\":{\"324\":1}}],[\"canexecute\",{\"1\":{\"255\":1}}],[\"canwrite\",{\"1\":{\"255\":1}}],[\"canread\",{\"1\":{\"255\":1}}],[\"can\",{\"1\":{\"41\":1,\"48\":2,\"789\":2,\"1181\":1}}],[\"choice\",{\"1\":{\"1181\":1}}],[\"choose>\",{\"1\":{\"874\":1}}],[\"choose\",{\"1\":{\"20\":1}}],[\"child\",{\"1\":{\"819\":3,\"1298\":1}}],[\"childnodes\",{\"1\":{\"819\":3}}],[\"chiness\",{\"1\":{\"222\":3}}],[\"chrome\",{\"1\":{\"727\":2,\"1091\":1,\"1096\":1}}],[\"chromium\",{\"1\":{\"727\":1,\"1096\":1}}],[\"ch\",{\"1\":{\"727\":3,\"1096\":1}}],[\"checkfailfast\",{\"1\":{\"1260\":1}}],[\"checkconnection\",{\"1\":{\"1247\":1}}],[\"check\",{\"1\":{\"747\":2,\"748\":1,\"779\":2,\"789\":1,\"1327\":1}}],[\"checkbox\",{\"1\":{\"686\":3,\"1093\":1}}],[\"checknotmodified\",{\"1\":{\"626\":1}}],[\"checkmultipart\",{\"1\":{\"626\":1}}],[\"checked\",{\"1\":{\"1246\":1}}],[\"checkedxxx可以将给定集合类进行包装\",{\"1\":{\"237\":1}}],[\"checkedlist\",{\"1\":{\"237\":1}}],[\"chat\",{\"1\":{\"691\":3}}],[\"changed\",{\"1\":{\"1047\":2}}],[\"change\",{\"1\":{\"666\":4}}],[\"changepassword\",{\"1\":{\"665\":1,\"666\":2}}],[\"channel\",{\"1\":{\"9\":1}}],[\"charlie\",{\"1\":{\"528\":1}}],[\"charset\",{\"1\":{\"749\":1}}],[\"charset=utf\",{\"1\":{\"1058\":1,\"1059\":1,\"1064\":1,\"1072\":1,\"1075\":1,\"1076\":1,\"1091\":1,\"1096\":1}}],[\"charset=\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"charsequence\",{\"1\":{\"462\":1}}],[\"chars\",{\"1\":{\"401\":2}}],[\"character>\",{\"1\":{\"438\":1}}],[\"character\",{\"1\":{\"384\":1}}],[\"charat\",{\"1\":{\"228\":2}}],[\"char\",{\"1\":{\"248\":2,\"253\":3,\"262\":1,\"265\":8,\"269\":1,\"283\":1,\"384\":1,\"400\":1,\"401\":1,\"480\":1,\"727\":1,\"746\":1,\"991\":1}}],[\"chapter\",{\"1\":{\"62\":1,\"68\":1}}],[\"chain\",{\"1\":{\"19\":1,\"708\":7,\"711\":6,\"712\":1,\"1104\":6}}],[\"cmax​\",{\"1\":{\"14\":1}}],[\"c\",{\"1\":{\"11\":1,\"13\":1,\"180\":4,\"181\":3,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"204\":4,\"228\":1,\"249\":1,\"438\":3,\"476\":1,\"488\":1,\"528\":1,\"806\":3,\"969\":3,\"970\":1,\"972\":6,\"1000\":1,\"1047\":1,\"1116\":2,\"1298\":5}}],[\"cycles\",{\"1\":{\"10\":1}}],[\"c1​和c2​是通过分析web浏览应用程序的实验结果确定的常数\",{\"1\":{\"10\":1}}],[\"c是光速\",{\"1\":{\"9\":1}}],[\"c4πfc​​\",{\"1\":{\"9\":1}}],[\"为给定的beanfactory创建xmlbeandefinitionreader便于读取xml中的bean配置\",{\"1\":{\"1297\":1}}],[\"为我们提供了sqlsessiontemplate类\",{\"1\":{\"1254\":1}}],[\"为网站中上传的内容\",{\"1\":{\"1075\":1}}],[\"为例\",{\"1\":{\"1059\":1}}],[\"为其添加一个authenticationmanager用于原密码的校验\",{\"1\":{\"666\":1}}],[\"为子线程的\",{\"1\":{\"320\":1}}],[\"为单位进行读写操作\",{\"1\":{\"245\":2}}],[\"为一个函数方程\",{\"1\":{\"96\":1}}],[\"为状态\",{\"1\":{\"87\":1}}],[\"为什么它直接就被加载了呢\",{\"1\":{\"1310\":1}}],[\"为什么会有这种正在创建的状态呢\",{\"1\":{\"1301\":1}}],[\"为什么会有这种状态呢\",{\"1\":{\"1300\":1}}],[\"为什么会找不到此方法呢\",{\"1\":{\"355\":1}}],[\"为什么能够直接实现异步\",{\"1\":{\"1222\":1}}],[\"为什么不去求\",{\"1\":{\"79\":1}}],[\"为什么考虑\",{\"1\":{\"75\":1}}],[\"为什么这个迭代算法最终可以找到最优策略\",{\"1\":{\"68\":1}}],[\"为discounted\",{\"1\":{\"39\":1}}],[\"为t时刻的mos评分\",{\"1\":{\"10\":1}}],[\"为了解决这些问题\",{\"1\":{\"1267\":1}}],[\"为了解决以上问题\",{\"1\":{\"437\":1}}],[\"为了更方便\",{\"1\":{\"1235\":1}}],[\"为了更加快速地编写io代码\",{\"1\":{\"1074\":1}}],[\"为了避免这种情况\",{\"1\":{\"1211\":1}}],[\"为了避免上面的这个现象\",{\"1\":{\"312\":1}}],[\"为了执行某些任务\",{\"1\":{\"1187\":1}}],[\"为了保证完整性\",{\"1\":{\"1024\":1}}],[\"为了保证所有用户都能连接到网络\",{\"1\":{\"9\":1}}],[\"为了能够支持中文\",{\"1\":{\"749\":1}}],[\"为了彻底杜绝这个问题\",{\"1\":{\"642\":1}}],[\"为了测试我们之前的网站安全性\",{\"1\":{\"636\":1}}],[\"为了方便\",{\"1\":{\"511\":1}}],[\"为了提高性能\",{\"1\":{\"462\":1}}],[\"为了统计学生成绩\",{\"1\":{\"437\":1}}],[\"为了在创建匿名对象时进行属性初始化\",{\"1\":{\"412\":1}}],[\"为了在los信道概率和路径损耗之间取得平衡\",{\"1\":{\"9\":1}}],[\"为了优化效率\",{\"1\":{\"401\":1}}],[\"为了使得线程资源分配更加合理\",{\"1\":{\"302\":1}}],[\"为了防止意外将之前的键值对覆盖掉\",{\"1\":{\"214\":1}}],[\"为了简便\",{\"1\":{\"191\":1,\"563\":1}}],[\"为了兼容之前的java版本\",{\"1\":{\"173\":1}}],[\"为了支持小数加法\",{\"1\":{\"165\":1}}],[\"为了让右边取到最大值的情况\",{\"1\":{\"57\":1}}],[\"为了进行\",{\"1\":{\"47\":1}}],[\"为了应对具有无限步的trajectory的return=∞的情况\",{\"1\":{\"19\":1}}],[\"为了满足不同用户传输速率要求\",{\"1\":{\"9\":1}}],[\"为\",{\"1\":{\"9\":1,\"42\":2,\"46\":1,\"78\":1,\"148\":1,\"519\":1}}],[\"为指标\",{\"1\":{\"5\":1}}],[\"​≐a∈a∑​π\",{\"1\":{\"153\":1}}],[\"​≐g\",{\"1\":{\"99\":1}}],[\"​q^​\",{\"1\":{\"142\":3}}],[\"​tderrorδt​​\",{\"1\":{\"112\":1}}],[\"​forthegreedyaction\",{\"1\":{\"87\":1}}],[\"​vu​u2​pu​\",{\"1\":{\"70\":1}}],[\"​vu​u1​pu​π2\",{\"1\":{\"70\":1}}],[\"​p\",{\"1\":{\"48\":1}}],[\"​​−αt​\",{\"1\":{\"112\":1}}],[\"​​=currentestimatevt​\",{\"1\":{\"112\":1}}],[\"​​=a∑​qπ​\",{\"1\":{\"48\":1}}],[\"​​+η∇w​f\",{\"1\":{\"104\":1}}],[\"​​π\",{\"1\":{\"48\":1}}],[\"​​\",{\"1\":{\"45\":1,\"66\":1,\"104\":2,\"112\":1}}],[\"​=π\",{\"1\":{\"155\":1}}],[\"​=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"​=▽w​e\",{\"1\":{\"136\":1}}],[\"​=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"​=vt​\",{\"1\":{\"112\":1}}],[\"​=∇w​f\",{\"1\":{\"104\":1}}],[\"​=w−e\",{\"1\":{\"110\":1}}],[\"​=w−x​=w−x+e\",{\"1\":{\"99\":1}}],[\"​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"​=a∑​π\",{\"1\":{\"43\":1,\"44\":1}}],[\"​=rπk​​+γpπk​​vπk​\",{\"1\":{\"68\":1}}],[\"​=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"​=s∈s∑​η\",{\"1\":{\"155\":1}}],[\"​=s\",{\"1\":{\"44\":1}}],[\"​=e\",{\"1\":{\"42\":1,\"45\":1}}],[\"​=es∼η\",{\"1\":{\"26\":1}}],[\"​=ϕ\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"​ifmosnew​>mosold​ifmosnew​=mosold​ifmosnew​<mosold​​\",{\"1\":{\"13\":1}}],[\"​≥0\",{\"1\":{\"11\":1,\"13\":1}}],[\"​≥γkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"​−μlos​−μnlos​μnlos​​​s\",{\"1\":{\"9\":1}}],[\"​\",{\"1\":{\"9\":3,\"10\":1,\"11\":1,\"13\":1,\"26\":1,\"42\":1,\"44\":2,\"45\":1,\"46\":1,\"48\":2,\"55\":1,\"63\":1,\"66\":5,\"68\":1,\"77\":1,\"81\":2,\"87\":1,\"94\":1,\"104\":2,\"112\":1,\"116\":1,\"120\":1,\"136\":1,\"142\":1,\"153\":1,\"155\":2,\"156\":1}}],[\"​hn​\",{\"1\":{\"9\":1}}],[\"bd\",{\"1\":{\"1321\":4}}],[\"bp\",{\"1\":{\"1301\":2}}],[\"b又等着a\",{\"1\":{\"1301\":1}}],[\"blog\",{\"1\":{\"1190\":1}}],[\"bservice\",{\"1\":{\"1119\":1}}],[\"b依然是具体实现类\",{\"1\":{\"1117\":1}}],[\"bb\",{\"1\":{\"991\":1}}],[\"bbb\",{\"1\":{\"171\":1,\"200\":1,\"201\":1,\"402\":1,\"475\":4,\"497\":1,\"528\":1,\"995\":2,\"1207\":1}}],[\"btree\",{\"1\":{\"780\":1}}],[\"btn\",{\"1\":{\"682\":2}}],[\"bcnf作为第三范式的补充\",{\"1\":{\"739\":1}}],[\"bcnf\",{\"0\":{\"739\":1}}],[\"bcnf则是对主键的选取进行唯一确定\",{\"1\":{\"735\":1}}],[\"bcryptpasswordencoder\",{\"1\":{\"659\":1,\"664\":1}}],[\"b84b\",{\"1\":{\"660\":1}}],[\"bw\",{\"1\":{\"625\":4}}],[\"b站\",{\"1\":{\"540\":1}}],[\"bytype\",{\"1\":{\"1137\":1,\"1140\":1,\"1141\":1}}],[\"byte类型的包装类也有类似的机制\",{\"1\":{\"384\":1}}],[\"bytes\",{\"1\":{\"248\":4,\"251\":3,\"356\":3,\"726\":6,\"1203\":4}}],[\"byte\",{\"1\":{\"248\":3,\"251\":2,\"264\":1,\"356\":3,\"384\":2,\"462\":1,\"490\":2,\"726\":4,\"991\":1}}],[\"by子句\",{\"1\":{\"779\":1}}],[\"by来对查询结果进行分组\",{\"1\":{\"766\":1}}],[\"by来将查询结果进行排序\",{\"1\":{\"764\":1}}],[\"by\",{\"1\":{\"509\":2,\"764\":2,\"766\":2,\"772\":1,\"1148\":1,\"1181\":1}}],[\"b中需要注入a\",{\"1\":{\"1301\":1}}],[\"b中\",{\"1\":{\"465\":1}}],[\"but\",{\"1\":{\"1047\":1,\"1119\":1}}],[\"button>\",{\"1\":{\"617\":1,\"636\":2,\"641\":1,\"666\":1,\"682\":1,\"683\":1,\"1069\":1,\"1075\":1,\"1076\":1}}],[\"budgetpositive\",{\"1\":{\"748\":1}}],[\"budget\",{\"1\":{\"748\":2}}],[\"build>\",{\"1\":{\"1037\":1}}],[\"buildgetuserbyid\",{\"1\":{\"902\":2}}],[\"buildrequestattributes\",{\"1\":{\"626\":1}}],[\"buildlocalecontext\",{\"1\":{\"626\":1}}],[\"build\",{\"1\":{\"490\":3,\"524\":4,\"525\":2,\"658\":2,\"659\":2,\"664\":1,\"672\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"692\":1,\"824\":1,\"826\":1,\"830\":1,\"904\":1,\"1002\":2,\"1017\":1,\"1072\":1,\"1254\":1}}],[\"builders\",{\"1\":{\"902\":1}}],[\"builder来快速生成建造者模式\",{\"1\":{\"812\":1}}],[\"builder注释的方法具体实现了\",{\"1\":{\"525\":1}}],[\"builder最容易用放在方法的用例来解释\",{\"1\":{\"525\":1}}],[\"builder可以放在类\",{\"1\":{\"525\":1}}],[\"builder可以让你以下面显示的那样调用你的代码\",{\"1\":{\"525\":1}}],[\"builder<>\",{\"1\":{\"524\":1}}],[\"builder<t>\",{\"1\":{\"524\":1}}],[\"builder\",{\"1\":{\"402\":8,\"524\":7,\"525\":4,\"812\":2,\"819\":2,\"948\":8,\"1326\":2}}],[\"bufupdater\",{\"1\":{\"264\":1}}],[\"buf\",{\"1\":{\"264\":2}}],[\"bufferedwriter\",{\"1\":{\"268\":1,\"270\":2}}],[\"bufferedreader\",{\"1\":{\"268\":1,\"269\":6,\"283\":1,\"720\":4}}],[\"bufferedoutputstream\",{\"1\":{\"267\":2}}],[\"bufferedinputstream\",{\"1\":{\"262\":4,\"265\":18,\"266\":3}}],[\"buffer\",{\"0\":{\"143\":1},\"1\":{\"142\":1,\"264\":3}}],[\"b是当前要计算的参数\",{\"1\":{\"228\":1}}],[\"browser\",{\"1\":{\"1047\":2}}],[\"broad\",{\"1\":{\"92\":1}}],[\"br\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"brand\",{\"1\":{\"727\":1,\"1096\":1}}],[\"break\",{\"1\":{\"216\":2,\"301\":1,\"324\":1,\"495\":4,\"727\":1,\"1246\":1}}],[\"bid\",{\"1\":{\"853\":3}}],[\"bigint用于存储大型整数\",{\"1\":{\"746\":1}}],[\"biginteger\",{\"1\":{\"386\":10}}],[\"bigdecimal\",{\"1\":{\"386\":6}}],[\"bindingexception\",{\"1\":{\"843\":1}}],[\"binding\",{\"1\":{\"603\":1,\"843\":1}}],[\"binaryoperator<t>\",{\"1\":{\"521\":2}}],[\"binarysearch\",{\"1\":{\"234\":1}}],[\"bincount\",{\"1\":{\"216\":2}}],[\"bit\",{\"1\":{\"10\":2,\"1047\":1}}],[\"bgd\",{\"0\":{\"106\":1},\"1\":{\"101\":1}}],[\"back\",{\"1\":{\"1246\":1}}],[\"badconnectioncount\",{\"1\":{\"1246\":1,\"1247\":1}}],[\"bad\",{\"1\":{\"1246\":2,\"1247\":1}}],[\"banana\",{\"1\":{\"994\":1}}],[\"baidu\",{\"1\":{\"277\":3,\"490\":1,\"852\":2}}],[\"batch\",{\"1\":{\"101\":1,\"142\":2,\"871\":1}}],[\"basepackage\",{\"1\":{\"1327\":2}}],[\"basepackages\",{\"1\":{\"1326\":1,\"1327\":3}}],[\"base\",{\"1\":{\"549\":1,\"787\":1,\"1278\":4}}],[\"based\",{\"0\":{\"88\":1},\"1\":{\"77\":1,\"82\":1,\"147\":2,\"156\":1,\"643\":1,\"1181\":1}}],[\"baseline\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"25\":1,\"26\":2,\"27\":1}}],[\"basic\",{\"0\":{\"76\":1},\"1\":{\"80\":1,\"81\":1,\"88\":1}}],[\"both\",{\"1\":{\"1181\":1}}],[\"body>\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"1069\":1}}],[\"body\",{\"1\":{\"490\":4}}],[\"bodyhandlers\",{\"1\":{\"490\":3}}],[\"bob\",{\"1\":{\"403\":2,\"528\":1}}],[\"books\",{\"1\":{\"853\":2,\"854\":1}}],[\"book\",{\"1\":{\"853\":4,\"854\":3}}],[\"boot\",{\"1\":{\"553\":1}}],[\"bootstarpclassloader用于加载jdk提供的类\",{\"1\":{\"355\":1}}],[\"bootstrapping\",{\"1\":{\"45\":1}}],[\"boolean\",{\"1\":{\"180\":11,\"181\":1,\"182\":2,\"189\":1,\"193\":1,\"194\":2,\"200\":2,\"201\":4,\"204\":9,\"213\":4,\"216\":2,\"224\":1,\"241\":2,\"324\":1,\"372\":1,\"373\":1,\"384\":2,\"499\":2,\"595\":1,\"600\":2,\"617\":2,\"626\":2,\"662\":1,\"665\":1,\"708\":1,\"830\":1,\"980\":2,\"991\":1,\"1167\":1,\"1180\":1,\"1242\":2,\"1244\":1,\"1245\":1,\"1246\":1,\"1273\":2,\"1279\":1,\"1300\":2,\"1301\":1,\"1310\":2,\"1327\":2}}],[\"boe\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"58\":1}}],[\"b\",{\"1\":{\"26\":1,\"165\":4,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"203\":2,\"207\":2,\"221\":2,\"228\":5,\"356\":3,\"384\":6,\"398\":1,\"408\":2,\"415\":5,\"423\":3,\"438\":4,\"439\":1,\"452\":2,\"464\":3,\"465\":2,\"466\":3,\"467\":2,\"476\":3,\"488\":1,\"500\":2,\"503\":1,\"504\":3,\"512\":5,\"521\":4,\"528\":1,\"806\":3,\"969\":2,\"1116\":6,\"1117\":2,\"1127\":1,\"1174\":1,\"1298\":5}}],[\"bkn​​=bn​\",{\"1\":{\"9\":1}}],[\"b2​\",{\"1\":{\"9\":1}}],[\"b2​pnlos​=1−plos​\",{\"1\":{\"9\":1}}],[\"b1​\",{\"1\":{\"9\":2}}],[\"better\",{\"1\":{\"1181\":3}}],[\"been\",{\"1\":{\"789\":1}}],[\"begin\",{\"1\":{\"782\":1}}],[\"be47\",{\"1\":{\"660\":1}}],[\"becomes\",{\"1\":{\"1181\":1}}],[\"become\",{\"1\":{\"324\":1}}],[\"behave\",{\"1\":{\"324\":1}}],[\"behavior\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"135\":1}}],[\"bean本身\",{\"1\":{\"1328\":1}}],[\"bean不能是抽象类\",{\"1\":{\"1321\":1}}],[\"beanpostprocess\",{\"1\":{\"1320\":2}}],[\"beanpostprocessor的初始化之前后方法\",{\"1\":{\"1311\":1}}],[\"beanpostprocessor的初始化之前方法\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"beanpostprocessor的初始化之后方法\",{\"1\":{\"1309\":1}}],[\"beanpostprocessor\",{\"1\":{\"1307\":3,\"1320\":1}}],[\"bean初始化方法\",{\"1\":{\"1309\":1,\"1311\":1}}],[\"bean定义和bean工厂后置处理\",{\"1\":{\"1311\":1}}],[\"bean定义\",{\"1\":{\"1309\":1,\"1311\":2}}],[\"bean定义等\",{\"1\":{\"1306\":1}}],[\"beaninstance\",{\"1\":{\"1300\":3}}],[\"beannames\",{\"1\":{\"1321\":2}}],[\"beanname\",{\"1\":{\"1300\":6,\"1301\":11,\"1307\":6,\"1321\":6,\"1326\":1,\"1328\":2}}],[\"beannameaware\",{\"1\":{\"1186\":1,\"1327\":1}}],[\"bean实际上是一开始通过beandefinitionreader进行扫描\",{\"1\":{\"1297\":1}}],[\"beandefinitions\",{\"1\":{\"1327\":4}}],[\"beandefinitionnames\",{\"1\":{\"1321\":1}}],[\"beandefinitionregistrypostprocessor\",{\"1\":{\"1311\":1,\"1327\":1}}],[\"beandefinitionregistrypostprocessor直接继承自beanfactorypostprocessor\",{\"1\":{\"1311\":1}}],[\"beandefinitionregistry\",{\"1\":{\"1310\":1,\"1311\":2,\"1318\":2,\"1326\":1,\"1327\":1}}],[\"beandefinitionreader\",{\"1\":{\"1297\":3}}],[\"beandefinition的创建过程\",{\"1\":{\"1306\":1}}],[\"beandefinitionbuilder\",{\"1\":{\"1296\":1,\"1311\":2,\"1326\":2}}],[\"beandefinition\",{\"1\":{\"1296\":1,\"1311\":2}}],[\"beanfactory是个factory\",{\"1\":{\"1328\":1}}],[\"beanfactorypostprocessor\",{\"1\":{\"1320\":1}}],[\"beanfactory还提供了很多其他的管理bean定义的方法\",{\"1\":{\"1298\":1}}],[\"beanfactory还可以具有父子关系\",{\"1\":{\"1298\":1}}],[\"beanfactory\",{\"1\":{\"1296\":7,\"1297\":2,\"1306\":1,\"1318\":2,\"1320\":6,\"1321\":2,\"1328\":1}}],[\"beanfactoryutils\",{\"1\":{\"631\":2}}],[\"bean工厂与bean定义\",{\"0\":{\"1295\":1}}],[\"bean相关分析\",{\"0\":{\"1294\":1}}],[\"beanclassloaderaware\",{\"1\":{\"1186\":1}}],[\"bean在加载的时候\",{\"1\":{\"1186\":1}}],[\"bean有循环依赖\",{\"1\":{\"1181\":1}}],[\"bean还是\",{\"1\":{\"1178\":1}}],[\"bean来注册bean\",{\"1\":{\"1177\":1}}],[\"bean来指定bean的工厂bean\",{\"1\":{\"1159\":1}}],[\"bean注册的\",{\"1\":{\"1178\":1}}],[\"bean注册与配置\",{\"0\":{\"1122\":1,\"1124\":1}}],[\"bean注解中进行配置\",{\"1\":{\"1170\":1}}],[\"bean之后\",{\"1\":{\"1159\":1}}],[\"bean之间也是具备继承关系的\",{\"1\":{\"1149\":1}}],[\"bean=\",{\"1\":{\"1159\":1}}],[\"bean中配置的属性\",{\"1\":{\"1149\":1}}],[\"bean生命周期与继承\",{\"0\":{\"1144\":1,\"1146\":1}}],[\"bean>\",{\"1\":{\"1133\":3,\"1134\":1,\"1136\":2,\"1137\":1,\"1149\":2,\"1150\":2,\"1151\":1,\"1172\":1,\"1211\":1}}],[\"bean会被ioc容器存储\",{\"1\":{\"1129\":1}}],[\"bean的时候\",{\"1\":{\"1328\":1}}],[\"bean的类型\",{\"1\":{\"1296\":1}}],[\"bean的值\",{\"1\":{\"1159\":1}}],[\"bean的获取可能会出现歧义\",{\"1\":{\"1126\":1}}],[\"bean的web作用域\",{\"0\":{\"588\":1}}],[\"beanwrapper\",{\"1\":{\"625\":1}}],[\"bean分别会以单例和多例模式进行创建\",{\"1\":{\"588\":1}}],[\"beansoftypeincludingancestors\",{\"1\":{\"631\":2}}],[\"beansexception\",{\"1\":{\"625\":1,\"1297\":2,\"1300\":3,\"1307\":4,\"1311\":2,\"1320\":2,\"1321\":1}}],[\"beans>\",{\"1\":{\"547\":1,\"549\":1,\"1119\":1,\"1124\":1,\"1167\":1,\"1217\":1}}],[\"beans\",{\"1\":{\"547\":4,\"549\":4,\"1119\":5,\"1148\":3,\"1167\":4,\"1181\":1,\"1217\":4,\"1296\":1,\"1320\":1}}],[\"bean\",{\"0\":{\"1186\":1},\"1\":{\"295\":3,\"534\":1,\"553\":1,\"560\":4,\"588\":3,\"625\":1,\"631\":1,\"658\":1,\"659\":2,\"664\":3,\"666\":1,\"668\":1,\"671\":4,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"687\":1,\"706\":1,\"1119\":6,\"1125\":1,\"1126\":2,\"1127\":6,\"1128\":1,\"1130\":1,\"1131\":2,\"1133\":1,\"1136\":2,\"1137\":2,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1148\":2,\"1149\":4,\"1150\":2,\"1151\":2,\"1158\":1,\"1159\":3,\"1167\":4,\"1170\":1,\"1171\":1,\"1172\":4,\"1174\":2,\"1177\":2,\"1178\":1,\"1181\":10,\"1188\":1,\"1190\":1,\"1196\":1,\"1198\":1,\"1221\":2,\"1222\":2,\"1224\":1,\"1233\":2,\"1237\":1,\"1254\":1,\"1259\":5,\"1260\":1,\"1276\":6,\"1300\":2,\"1301\":4,\"1307\":8,\"1318\":2,\"1320\":1,\"1321\":3,\"1328\":1}}],[\"before注解即可\",{\"1\":{\"1233\":1}}],[\"before被废弃\",{\"1\":{\"1017\":1}}],[\"beforeeach和\",{\"1\":{\"986\":1}}],[\"beforeeach\",{\"1\":{\"985\":2,\"988\":1,\"1017\":1}}],[\"beforeall这种注解时\",{\"1\":{\"988\":1}}],[\"beforeall表示此准备工作在所有测试用例执行之前执行\",{\"1\":{\"985\":1}}],[\"beforeall\",{\"1\":{\"985\":3,\"1017\":1}}],[\"before|after\",{\"1\":{\"781\":1}}],[\"beforespringsecurityfilterchain\",{\"1\":{\"705\":1}}],[\"before\",{\"1\":{\"218\":1,\"1017\":1,\"1231\":2,\"1233\":2,\"1234\":2,\"1235\":2,\"1236\":1,\"1296\":1}}],[\"bellman\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"46\":2,\"47\":1,\"49\":2,\"52\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"be\",{\"1\":{\"4\":1,\"41\":1,\"296\":1,\"509\":1,\"789\":2,\"1047\":2,\"1148\":1,\"1181\":1,\"1318\":2,\"1319\":1}}],[\"pcd\",{\"1\":{\"1219\":1}}],[\"phase>\",{\"1\":{\"1037\":1}}],[\"pwd=\",{\"1\":{\"804\":2,\"805\":2}}],[\"pk\",{\"1\":{\"748\":2}}],[\"pkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"pkn​​=pmax​\",{\"1\":{\"9\":1}}],[\"please\",{\"1\":{\"1047\":2,\"1327\":1}}],[\"plugin>\",{\"1\":{\"1037\":1}}],[\"plugin<\",{\"1\":{\"1037\":1}}],[\"plugins>\",{\"1\":{\"1037\":1}}],[\"plugins\",{\"1\":{\"1010\":1}}],[\"plain\",{\"1\":{\"816\":1}}],[\"platform\",{\"1\":{\"727\":1}}],[\"placeholder=\",{\"1\":{\"666\":2,\"682\":2,\"1069\":2,\"1093\":1}}],[\"plos​μlos​+pnlos​μnlos​\",{\"1\":{\"9\":1}}],[\"plos​\",{\"1\":{\"9\":1}}],[\"pvs\",{\"1\":{\"625\":3}}],[\"png放入到resource文件夹中\",{\"1\":{\"1074\":1}}],[\"png\",{\"1\":{\"619\":1,\"620\":2,\"1074\":5,\"1104\":1}}],[\"p>\",{\"1\":{\"562\":1,\"564\":1,\"617\":4,\"643\":4}}],[\"python等等都是支持正则表达式的\",{\"1\":{\"403\":1}}],[\"pppp\",{\"1\":{\"1218\":1,\"1225\":1}}],[\"ppp\",{\"1\":{\"412\":1,\"564\":1}}],[\"pp\",{\"1\":{\"412\":2,\"413\":2,\"575\":4}}],[\"ppenguin\",{\"1\":{\"364\":1}}],[\"ppolicy\",{\"1\":{\"124\":1}}],[\"packing默认是jar类型\",{\"1\":{\"1038\":1}}],[\"packaging>\",{\"1\":{\"1038\":1}}],[\"package等\",{\"1\":{\"1034\":1}}],[\"package=\",{\"1\":{\"549\":1}}],[\"package属性就可以了\",{\"1\":{\"549\":1}}],[\"package\",{\"1\":{\"277\":3,\"349\":1,\"355\":1,\"356\":1,\"377\":1,\"411\":3,\"412\":2,\"461\":1,\"464\":1,\"467\":2,\"468\":1,\"1036\":1,\"1119\":1,\"1327\":1}}],[\"pages\",{\"1\":{\"1047\":4}}],[\"page\",{\"1\":{\"693\":1,\"1047\":1}}],[\"pay\",{\"1\":{\"636\":5,\"641\":1,\"658\":2,\"660\":2}}],[\"part\",{\"1\":{\"1075\":4}}],[\"parent=\",{\"1\":{\"1149\":1,\"1150\":1,\"1151\":1}}],[\"parent>\",{\"1\":{\"1032\":1}}],[\"parent\",{\"1\":{\"927\":2,\"928\":1,\"1298\":1}}],[\"parseexpression\",{\"1\":{\"1202\":2,\"1203\":5,\"1204\":3,\"1205\":2,\"1207\":2,\"1208\":3,\"1209\":2,\"1210\":1,\"1211\":2}}],[\"parser\",{\"1\":{\"1202\":3,\"1203\":6,\"1204\":3,\"1205\":2,\"1207\":2,\"1208\":3,\"1209\":2,\"1210\":1,\"1211\":2}}],[\"parse\",{\"1\":{\"610\":1,\"819\":1}}],[\"param来指定参数名称\",{\"1\":{\"902\":1}}],[\"param注解来指定某个参数的名称\",{\"1\":{\"843\":1}}],[\"param2\",{\"1\":{\"843\":4}}],[\"param1\",{\"1\":{\"843\":4}}],[\"params\",{\"1\":{\"569\":1,\"574\":3,\"575\":2,\"841\":2}}],[\"param>\",{\"1\":{\"548\":2,\"1086\":2}}],[\"param\",{\"1\":{\"495\":1,\"509\":2,\"548\":2,\"799\":4,\"830\":1,\"843\":4,\"863\":2,\"1071\":2,\"1086\":2}}],[\"parametermap存储了我们发送的post请求所携带的表单数据\",{\"1\":{\"1069\":1}}],[\"parameterized\",{\"1\":{\"995\":1}}],[\"parameterizedtest\",{\"1\":{\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"995\":2}}],[\"parameterizedtest或\",{\"1\":{\"980\":1}}],[\"parameterizedtype\",{\"1\":{\"343\":7}}],[\"parameters\",{\"1\":{\"843\":1,\"852\":2}}],[\"parametertype=\",{\"1\":{\"831\":3,\"842\":1,\"854\":1,\"861\":1,\"862\":1,\"897\":1}}],[\"parameter\",{\"1\":{\"349\":3,\"843\":1,\"860\":3,\"1181\":2}}],[\"parallelsort\",{\"1\":{\"330\":1}}],[\"parallelstream就是利用了可拆分迭代器进行多线程操作\",{\"1\":{\"330\":1}}],[\"parallelstream\",{\"1\":{\"180\":1,\"330\":3,\"516\":1}}],[\"passwordparameter\",{\"1\":{\"680\":1}}],[\"passwordencoder\",{\"1\":{\"659\":3,\"664\":3,\"666\":2}}],[\"password=123456\",{\"1\":{\"936\":1}}],[\"password=123\",{\"1\":{\"574\":1}}],[\"password=\",{\"1\":{\"525\":1,\"1047\":2}}],[\"password\",{\"1\":{\"501\":3,\"525\":12,\"574\":2,\"583\":1,\"617\":6,\"636\":4,\"658\":4,\"659\":5,\"662\":1,\"664\":2,\"666\":2,\"669\":1,\"672\":1,\"680\":1,\"682\":3,\"692\":2,\"789\":4,\"824\":1,\"1017\":1,\"1047\":1,\"1069\":2,\"1071\":6,\"1072\":4,\"1093\":10,\"1242\":2,\"1244\":8,\"1245\":2,\"1246\":2,\"1255\":1}}],[\"patch\",{\"1\":{\"1059\":1}}],[\"path=\",{\"1\":{\"642\":1,\"1096\":1}}],[\"pathvariable注解指定为占位符名称\",{\"1\":{\"589\":1}}],[\"pathvariable注解的参数\",{\"1\":{\"589\":1}}],[\"pathvariable\",{\"1\":{\"589\":4}}],[\"path\",{\"1\":{\"569\":2,\"1092\":1}}],[\"paths\",{\"1\":{\"267\":1,\"480\":1}}],[\"pattern>\",{\"1\":{\"545\":2,\"1054\":8}}],[\"pattern需要写为\",{\"1\":{\"545\":1}}],[\"pattern\",{\"1\":{\"403\":1}}],[\"pair\",{\"1\":{\"79\":1,\"81\":6,\"82\":1,\"84\":2,\"86\":1}}],[\"preinstantiatesingletons\",{\"1\":{\"1321\":2}}],[\"prefer\",{\"1\":{\"1181\":1}}],[\"prefilter类似的\",{\"1\":{\"699\":1}}],[\"prefilter\",{\"1\":{\"699\":2}}],[\"prefilter和\",{\"1\":{\"699\":1}}],[\"prefix\",{\"1\":{\"490\":3,\"1321\":1}}],[\"predestroy\",{\"1\":{\"1176\":2}}],[\"predicate<\",{\"1\":{\"180\":1}}],[\"preparing\",{\"1\":{\"852\":2}}],[\"preparebeanfactory\",{\"1\":{\"1320\":1}}],[\"preparerefresh\",{\"1\":{\"1320\":1}}],[\"preparestatement\",{\"1\":{\"790\":1,\"805\":1}}],[\"preparedstatement\",{\"1\":{\"790\":1,\"805\":1}}],[\"preauthorize注解\",{\"1\":{\"696\":1}}],[\"preauthorize\",{\"1\":{\"695\":1,\"697\":1}}],[\"prehandle\",{\"1\":{\"595\":1,\"600\":2}}],[\"present\",{\"1\":{\"224\":1}}],[\"previousattributes\",{\"1\":{\"626\":2}}],[\"previouslocalecontext\",{\"1\":{\"626\":1}}],[\"previousindex\",{\"1\":{\"194\":1}}],[\"previous\",{\"1\":{\"194\":1}}],[\"prev\",{\"1\":{\"182\":4}}],[\"primary=\",{\"1\":{\"1141\":1}}],[\"primary\",{\"1\":{\"662\":1,\"747\":2,\"748\":3}}],[\"primitive\",{\"1\":{\"340\":2}}],[\"priority\",{\"1\":{\"302\":4}}],[\"priorityqueue<>\",{\"1\":{\"202\":1,\"203\":2}}],[\"printwriter\",{\"1\":{\"789\":1,\"796\":1}}],[\"printer\",{\"1\":{\"510\":2}}],[\"print\",{\"1\":{\"394\":2,\"431\":1,\"480\":1,\"498\":1,\"720\":1,\"727\":1}}],[\"printstream也永远不会抛出异常\",{\"1\":{\"284\":1}}],[\"printstream也继承自filteroutputstream类\",{\"1\":{\"284\":1}}],[\"printstream\",{\"1\":{\"284\":3}}],[\"printstacktrace\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"329\":2,\"331\":1,\"356\":2,\"424\":1,\"605\":1,\"620\":1,\"719\":3,\"720\":1,\"726\":1,\"727\":2,\"788\":1,\"798\":1,\"799\":1,\"804\":1,\"805\":1,\"806\":4,\"819\":1,\"830\":1}}],[\"println也是接受一个string参数\",{\"1\":{\"454\":1}}],[\"println\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"348\":2,\"349\":5,\"350\":4,\"355\":5,\"356\":2,\"365\":6,\"373\":2,\"375\":1,\"376\":2,\"377\":4,\"378\":1,\"384\":3,\"385\":1,\"386\":2,\"393\":1,\"397\":1,\"398\":1,\"399\":1,\"401\":6,\"402\":3,\"403\":2,\"408\":5,\"409\":1,\"410\":1,\"411\":7,\"412\":3,\"413\":1,\"414\":3,\"415\":2,\"424\":3,\"431\":1,\"432\":1,\"438\":1,\"445\":1,\"446\":1,\"449\":2,\"451\":2,\"452\":1,\"454\":6,\"461\":1,\"462\":1,\"464\":1,\"474\":3,\"475\":2,\"476\":1,\"477\":2,\"478\":2,\"479\":2,\"480\":6,\"485\":1,\"488\":6,\"490\":3,\"497\":1,\"500\":1,\"501\":1,\"504\":1,\"510\":1,\"511\":2,\"512\":3,\"515\":1,\"518\":1,\"519\":1,\"521\":4,\"522\":5,\"531\":2,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":1,\"586\":1,\"588\":1,\"589\":6,\"595\":3,\"599\":1,\"600\":4,\"605\":1,\"612\":1,\"613\":1,\"619\":1,\"636\":2,\"658\":1,\"659\":1,\"697\":2,\"699\":2,\"719\":6,\"720\":8,\"726\":1,\"727\":5,\"788\":1,\"789\":7,\"796\":1,\"799\":1,\"804\":1,\"805\":2,\"819\":1,\"826\":1,\"830\":1,\"832\":1,\"833\":1,\"834\":1,\"836\":3,\"841\":1,\"842\":2,\"843\":1,\"865\":2,\"883\":6,\"884\":2,\"888\":1,\"897\":1,\"918\":1,\"927\":2,\"930\":3,\"937\":1,\"938\":2,\"944\":3,\"950\":2,\"956\":4,\"973\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":2,\"980\":1,\"985\":3,\"986\":3,\"987\":3,\"988\":5,\"993\":2,\"994\":1,\"995\":2,\"1008\":1,\"1017\":2,\"1023\":1,\"1035\":1,\"1057\":4,\"1069\":1,\"1072\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1086\":1,\"1091\":1,\"1102\":1,\"1103\":5,\"1105\":1,\"1119\":2,\"1126\":2,\"1129\":2,\"1132\":2,\"1135\":2,\"1157\":2,\"1159\":1,\"1160\":1,\"1169\":1,\"1176\":2,\"1178\":2,\"1186\":2,\"1188\":4,\"1189\":1,\"1190\":1,\"1191\":1,\"1192\":1,\"1199\":1,\"1200\":1,\"1202\":2,\"1203\":4,\"1204\":2,\"1205\":1,\"1207\":2,\"1208\":2,\"1209\":2,\"1210\":1,\"1211\":5,\"1218\":2,\"1222\":1,\"1223\":2,\"1224\":7,\"1225\":2,\"1231\":5,\"1232\":1,\"1233\":1,\"1234\":2,\"1235\":3,\"1236\":2,\"1237\":2,\"1256\":1,\"1257\":1,\"1296\":4,\"1298\":4,\"1299\":1,\"1307\":3,\"1308\":3,\"1311\":3,\"1328\":3}}],[\"private\",{\"1\":{\"171\":2,\"172\":3,\"182\":5,\"222\":3,\"224\":2,\"278\":2,\"289\":1,\"290\":1,\"311\":1,\"312\":7,\"324\":3,\"331\":3,\"372\":1,\"373\":1,\"375\":2,\"378\":2,\"408\":2,\"409\":1,\"410\":1,\"414\":1,\"423\":2,\"424\":2,\"462\":1,\"474\":1,\"499\":2,\"523\":3,\"524\":4,\"525\":6,\"631\":1,\"666\":1,\"705\":1,\"708\":1,\"709\":1,\"711\":1,\"789\":1,\"799\":1,\"810\":6,\"830\":1,\"841\":1,\"904\":1,\"956\":3,\"1017\":1,\"1104\":1,\"1116\":1,\"1117\":1,\"1132\":2,\"1133\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1149\":2,\"1173\":2,\"1174\":1,\"1175\":1,\"1181\":5,\"1199\":1,\"1200\":2,\"1203\":1,\"1211\":1,\"1219\":1,\"1242\":1,\"1244\":12,\"1245\":6,\"1246\":1,\"1247\":6,\"1255\":3,\"1273\":1,\"1296\":1,\"1327\":1}}],[\"proceed\",{\"1\":{\"1224\":2,\"1225\":1,\"1231\":1,\"1237\":1,\"1283\":1}}],[\"proceedingjoinpoint\",{\"1\":{\"1224\":2,\"1225\":1,\"1237\":1}}],[\"processbeandefinitions\",{\"1\":{\"1327\":1}}],[\"processpropertyplaceholders\",{\"1\":{\"1326\":1,\"1327\":2}}],[\"processor\",{\"1\":{\"1148\":1}}],[\"processing\",{\"1\":{\"626\":1}}],[\"processdispatchresult\",{\"1\":{\"626\":1}}],[\"processedrequest\",{\"1\":{\"626\":14}}],[\"processrequest\",{\"1\":{\"626\":3}}],[\"process\",{\"0\":{\"20\":1},\"1\":{\"20\":1,\"135\":1,\"713\":1,\"1320\":1}}],[\"pros\",{\"1\":{\"1181\":1}}],[\"prototypes\",{\"1\":{\"1148\":1}}],[\"prototype\",{\"1\":{\"1148\":6,\"1171\":1,\"1296\":1}}],[\"protocol\",{\"1\":{\"1059\":2}}],[\"protection\",{\"1\":{\"714\":1,\"1047\":1}}],[\"protected\",{\"1\":{\"278\":2,\"372\":2,\"375\":7,\"412\":1,\"421\":1,\"423\":1,\"552\":3,\"619\":1,\"625\":4,\"626\":5,\"652\":1,\"706\":2,\"707\":1,\"712\":1,\"713\":1,\"1047\":1,\"1059\":3,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1104\":2,\"1219\":1,\"1245\":8,\"1247\":1,\"1273\":4,\"1297\":2,\"1300\":2,\"1301\":2,\"1321\":1}}],[\"proxytargetclass\",{\"1\":{\"1310\":2}}],[\"proxyconnection\",{\"1\":{\"1247\":1}}],[\"proxy\",{\"1\":{\"1047\":1,\"1247\":1,\"1283\":1}}],[\"proxy2\",{\"1\":{\"842\":1}}],[\"programming\",{\"1\":{\"1215\":1}}],[\"programteacher都没出现\",{\"1\":{\"1133\":1}}],[\"programteacher\",{\"1\":{\"1132\":2,\"1140\":1,\"1141\":1,\"1172\":1}}],[\"program\",{\"1\":{\"1047\":1}}],[\"project>\",{\"1\":{\"1002\":1,\"1023\":1,\"1032\":1}}],[\"project\",{\"1\":{\"1002\":1}}],[\"projectlombok<\",{\"1\":{\"1008\":1,\"1033\":2}}],[\"projectlombok\",{\"1\":{\"811\":1}}],[\"provide\",{\"1\":{\"1181\":1}}],[\"provided\",{\"1\":{\"1016\":1}}],[\"providers\",{\"1\":{\"1260\":1}}],[\"providermanager\",{\"1\":{\"666\":1}}],[\"provider\",{\"1\":{\"666\":4}}],[\"provides\",{\"1\":{\"467\":1}}],[\"prompt\",{\"1\":{\"531\":1}}],[\"profession\",{\"1\":{\"375\":4}}],[\"produces\",{\"1\":{\"324\":1,\"569\":1,\"577\":1,\"615\":1,\"616\":1,\"617\":2}}],[\"problems\",{\"1\":{\"92\":1}}],[\"probability\",{\"1\":{\"19\":1,\"20\":4,\"86\":1,\"98\":1,\"133\":1}}],[\"propagation\",{\"1\":{\"1279\":4,\"1282\":2,\"1283\":3}}],[\"props\",{\"1\":{\"1244\":5}}],[\"prop\",{\"1\":{\"841\":2}}],[\"prop是要设置的值的字段信息\",{\"1\":{\"841\":1}}],[\"properties结尾的配置文件\",{\"1\":{\"1197\":1}}],[\"properties中一般都是一些变量和选项的配置\",{\"1\":{\"1003\":1}}],[\"properties>\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"properties默认的日志级别\",{\"1\":{\"951\":1}}],[\"properties文件\",{\"1\":{\"938\":1,\"1047\":1,\"1197\":1}}],[\"properties格式的文件是java的一种配置文件\",{\"1\":{\"936\":1}}],[\"properties\",{\"1\":{\"625\":1,\"789\":3,\"937\":8,\"938\":8,\"939\":1,\"1196\":1,\"1198\":1,\"1199\":2,\"1244\":6}}],[\"propertysource\",{\"1\":{\"1198\":1,\"1199\":1}}],[\"propertysource注解中添加属性\",{\"1\":{\"1199\":1}}],[\"propertysource注解\",{\"1\":{\"1198\":1}}],[\"property>\",{\"1\":{\"1136\":2}}],[\"propertytokenizer\",{\"1\":{\"841\":1}}],[\"property=\",{\"1\":{\"835\":2,\"850\":8,\"851\":4,\"853\":6,\"854\":4,\"855\":10,\"898\":2}}],[\"propertyaccessorfactory\",{\"1\":{\"625\":1}}],[\"propertyvalues\",{\"1\":{\"625\":1}}],[\"property\",{\"1\":{\"20\":1,\"835\":1,\"898\":2,\"901\":2}}],[\"proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件\",{\"1\":{\"9\":1}}],[\"proposition1\",{\"1\":{\"9\":1}}],[\"proposed\",{\"1\":{\"4\":1}}],[\"p2\",{\"1\":{\"161\":1,\"373\":3}}],[\"p1\",{\"1\":{\"161\":2,\"373\":3}}],[\"publisher\",{\"1\":{\"1192\":5}}],[\"publishevent\",{\"1\":{\"712\":1,\"1192\":2}}],[\"publishcontext\",{\"1\":{\"625\":1}}],[\"public<\",{\"1\":{\"1010\":1}}],[\"public\",{\"1\":{\"161\":4,\"162\":2,\"166\":4,\"171\":8,\"172\":6,\"173\":5,\"180\":3,\"181\":1,\"182\":15,\"187\":2,\"189\":1,\"190\":2,\"191\":2,\"192\":1,\"193\":5,\"194\":1,\"199\":1,\"200\":2,\"201\":2,\"202\":1,\"203\":2,\"204\":1,\"205\":3,\"206\":1,\"207\":2,\"213\":1,\"214\":4,\"215\":2,\"216\":1,\"221\":1,\"222\":5,\"223\":3,\"224\":5,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":9,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":2,\"277\":5,\"278\":6,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":2,\"289\":1,\"290\":2,\"295\":1,\"296\":3,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":6,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":6,\"323\":2,\"324\":5,\"329\":2,\"330\":2,\"331\":2,\"339\":1,\"340\":2,\"341\":1,\"343\":11,\"348\":7,\"349\":8,\"350\":3,\"355\":5,\"356\":5,\"363\":4,\"364\":9,\"365\":3,\"372\":10,\"373\":3,\"375\":8,\"376\":9,\"377\":6,\"378\":13,\"384\":5,\"385\":1,\"386\":2,\"392\":1,\"393\":1,\"394\":1,\"395\":2,\"396\":1,\"397\":1,\"398\":5,\"399\":1,\"401\":3,\"402\":3,\"403\":2,\"408\":15,\"409\":5,\"410\":5,\"411\":9,\"412\":12,\"413\":2,\"414\":3,\"415\":8,\"422\":4,\"423\":1,\"424\":4,\"425\":1,\"431\":2,\"432\":1,\"437\":3,\"438\":9,\"439\":7,\"445\":2,\"446\":1,\"447\":5,\"448\":2,\"449\":4,\"451\":4,\"452\":2,\"453\":3,\"454\":4,\"461\":2,\"462\":2,\"464\":5,\"467\":2,\"468\":2,\"474\":3,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":11,\"485\":2,\"487\":1,\"488\":3,\"490\":4,\"495\":2,\"496\":1,\"499\":6,\"500\":1,\"501\":5,\"503\":2,\"504\":6,\"509\":1,\"512\":3,\"516\":1,\"518\":2,\"519\":2,\"521\":2,\"522\":2,\"523\":12,\"524\":5,\"525\":8,\"549\":2,\"550\":2,\"552\":1,\"553\":1,\"554\":2,\"560\":4,\"561\":2,\"563\":3,\"564\":2,\"569\":4,\"572\":1,\"573\":1,\"574\":3,\"575\":2,\"576\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":2,\"585\":1,\"586\":1,\"587\":4,\"588\":4,\"589\":7,\"595\":4,\"596\":1,\"599\":1,\"600\":6,\"601\":1,\"605\":3,\"612\":1,\"613\":1,\"615\":1,\"616\":2,\"617\":2,\"619\":2,\"620\":1,\"625\":1,\"636\":4,\"650\":1,\"651\":1,\"658\":5,\"659\":3,\"664\":3,\"665\":1,\"666\":3,\"668\":3,\"669\":1,\"670\":1,\"671\":2,\"672\":2,\"678\":2,\"679\":3,\"680\":2,\"683\":2,\"684\":2,\"686\":2,\"687\":1,\"692\":2,\"695\":3,\"697\":3,\"699\":3,\"705\":1,\"707\":1,\"708\":2,\"709\":4,\"710\":1,\"711\":1,\"719\":3,\"720\":4,\"726\":4,\"727\":3,\"789\":2,\"796\":2,\"798\":1,\"799\":3,\"805\":1,\"806\":4,\"810\":9,\"824\":2,\"826\":3,\"830\":3,\"835\":1,\"836\":1,\"841\":6,\"842\":1,\"849\":2,\"853\":2,\"855\":2,\"861\":1,\"895\":1,\"896\":1,\"898\":1,\"900\":2,\"902\":2,\"903\":1,\"908\":2,\"910\":9,\"912\":2,\"937\":1,\"944\":3,\"948\":1,\"950\":4,\"956\":2,\"959\":6,\"960\":1,\"961\":1,\"963\":1,\"969\":1,\"974\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":2,\"980\":2,\"985\":3,\"986\":5,\"987\":3,\"988\":6,\"990\":1,\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"995\":2,\"1008\":3,\"1017\":6,\"1023\":3,\"1032\":2,\"1035\":2,\"1054\":6,\"1057\":1,\"1059\":2,\"1064\":2,\"1069\":1,\"1071\":3,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1102\":2,\"1103\":4,\"1104\":4,\"1105\":2,\"1116\":2,\"1117\":2,\"1119\":6,\"1125\":1,\"1126\":4,\"1132\":8,\"1133\":2,\"1134\":2,\"1135\":3,\"1136\":2,\"1149\":4,\"1157\":3,\"1159\":2,\"1160\":4,\"1166\":1,\"1167\":3,\"1168\":1,\"1170\":1,\"1171\":1,\"1172\":3,\"1173\":3,\"1174\":3,\"1175\":1,\"1176\":2,\"1177\":3,\"1178\":2,\"1179\":2,\"1180\":4,\"1181\":6,\"1186\":4,\"1188\":5,\"1190\":2,\"1191\":2,\"1192\":9,\"1198\":1,\"1199\":2,\"1200\":4,\"1203\":3,\"1207\":3,\"1209\":3,\"1211\":1,\"1218\":4,\"1219\":1,\"1221\":1,\"1223\":3,\"1224\":4,\"1225\":4,\"1231\":11,\"1232\":3,\"1233\":3,\"1234\":1,\"1235\":2,\"1236\":2,\"1237\":1,\"1242\":3,\"1244\":3,\"1245\":3,\"1247\":1,\"1254\":2,\"1255\":3,\"1256\":1,\"1257\":2,\"1259\":3,\"1260\":3,\"1272\":1,\"1273\":8,\"1276\":4,\"1277\":4,\"1278\":2,\"1279\":1,\"1281\":3,\"1282\":2,\"1283\":2,\"1288\":2,\"1291\":2,\"1296\":5,\"1298\":3,\"1300\":1,\"1307\":6,\"1308\":4,\"1310\":2,\"1311\":6,\"1316\":1,\"1317\":1,\"1318\":3,\"1319\":1,\"1320\":1,\"1321\":1,\"1326\":1,\"1327\":4,\"1328\":5}}],[\"put和delete请求一定会被拒绝\",{\"1\":{\"660\":1}}],[\"put和delete方法的请求\",{\"1\":{\"660\":1}}],[\"puttreeval\",{\"1\":{\"216\":1}}],[\"putval\",{\"1\":{\"216\":2}}],[\"putifabsent\",{\"1\":{\"214\":2}}],[\"putall\",{\"1\":{\"213\":1,\"1244\":1}}],[\"put\",{\"0\":{\"216\":1},\"1\":{\"213\":1,\"214\":5,\"216\":1,\"221\":4,\"223\":3,\"241\":1,\"331\":1,\"475\":2,\"563\":1,\"589\":4,\"612\":2,\"613\":2,\"617\":2,\"636\":2,\"658\":1,\"666\":1,\"789\":2,\"1059\":2,\"1301\":1}}],[\"pushconnection\",{\"1\":{\"1247\":2}}],[\"push\",{\"1\":{\"201\":3}}],[\"pu\",{\"1\":{\"70\":1}}],[\"ping\",{\"1\":{\"1245\":1}}],[\"pic=\",{\"1\":{\"490\":1}}],[\"pic\",{\"1\":{\"490\":4}}],[\"pig\",{\"1\":{\"319\":1}}],[\"pid\",{\"1\":{\"313\":1}}],[\"pi\",{\"1\":{\"66\":1,\"68\":1,\"70\":1}}],[\"people\",{\"1\":{\"288\":9,\"289\":2,\"290\":9}}],[\"penguin\",{\"1\":{\"267\":1,\"284\":1,\"288\":1,\"319\":1,\"348\":1,\"349\":4,\"376\":1,\"411\":1,\"412\":4,\"464\":1,\"619\":2,\"727\":1,\"1177\":1,\"1218\":1,\"1225\":2}}],[\"peeklast\",{\"1\":{\"201\":1}}],[\"peekfirst\",{\"1\":{\"201\":1}}],[\"peek\",{\"1\":{\"200\":1}}],[\"per\",{\"1\":{\"986\":1}}],[\"permission\",{\"1\":{\"789\":1}}],[\"permitall\",{\"1\":{\"680\":1,\"681\":1,\"683\":1,\"692\":1,\"693\":1}}],[\"permits后面跟上允许继承的类型\",{\"1\":{\"503\":1}}],[\"permits\",{\"1\":{\"503\":1,\"504\":2}}],[\"persistenceexception\",{\"1\":{\"841\":1}}],[\"persistenttokenrepository\",{\"1\":{\"687\":1}}],[\"person\",{\"1\":{\"161\":8,\"162\":3,\"166\":8,\"274\":3,\"277\":1,\"278\":2,\"373\":10,\"375\":3,\"376\":1,\"377\":1,\"398\":5,\"525\":1}}],[\"perform\",{\"1\":{\"509\":1,\"987\":1}}],[\"performed\",{\"1\":{\"509\":1}}],[\"performing\",{\"1\":{\"509\":2}}],[\"performs\",{\"1\":{\"509\":3}}],[\"periods\",{\"1\":{\"10\":1}}],[\"pe\",{\"1\":{\"66\":2,\"68\":1,\"70\":1,\"77\":1}}],[\"pπ​\",{\"1\":{\"46\":1}}],[\"pπ​∈rn×n\",{\"1\":{\"46\":1}}],[\"p\",{\"1\":{\"19\":1,\"20\":3,\"41\":2,\"44\":1,\"45\":2,\"63\":2,\"75\":1,\"77\":4,\"98\":1,\"161\":4,\"162\":4,\"216\":10,\"773\":1}}],[\"pojos\",{\"1\":{\"816\":1,\"1181\":1}}],[\"poolpingconnectionsnotusedfor\",{\"1\":{\"1245\":1}}],[\"poolpingenabled\",{\"1\":{\"1245\":1}}],[\"poolpingquery\",{\"1\":{\"1245\":1}}],[\"pooltimetowait\",{\"1\":{\"1245\":1,\"1246\":2}}],[\"poolmaximumlocalbadconnectiontolerance\",{\"1\":{\"1245\":1,\"1246\":1}}],[\"poolmaximumcheckouttime\",{\"1\":{\"1245\":1,\"1246\":1}}],[\"poolmaximumidleconnections\",{\"1\":{\"1245\":1,\"1246\":1,\"1247\":1}}],[\"poolmaximumactiveconnections\",{\"1\":{\"1245\":1,\"1246\":1}}],[\"poolstate存了两个list\",{\"1\":{\"1246\":1}}],[\"poolstate\",{\"1\":{\"1245\":2,\"1246\":1,\"1247\":1}}],[\"pool\",{\"1\":{\"852\":1,\"1246\":4,\"1247\":2,\"1260\":1}}],[\"pooledconnection\",{\"1\":{\"1246\":7,\"1247\":4}}],[\"pooled\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":2,\"1255\":1}}],[\"pooleddatasource\",{\"1\":{\"664\":1,\"904\":2,\"1245\":2,\"1246\":4,\"1247\":1,\"1259\":1}}],[\"poor\",{\"1\":{\"10\":1}}],[\"pom\",{\"1\":{\"480\":1,\"1000\":1,\"1002\":2,\"1023\":2,\"1032\":2,\"1071\":1}}],[\"pow\",{\"1\":{\"431\":1}}],[\"power\",{\"1\":{\"9\":1}}],[\"popconnection\",{\"1\":{\"1245\":2,\"1246\":1}}],[\"pop\",{\"1\":{\"201\":3}}],[\"polllast\",{\"1\":{\"201\":1}}],[\"pollfirst\",{\"1\":{\"201\":1}}],[\"poll\",{\"1\":{\"200\":3,\"203\":6,\"331\":1}}],[\"policies\",{\"1\":{\"85\":1,\"87\":2}}],[\"policy版本\",{\"1\":{\"140\":1}}],[\"policyevaluation\",{\"1\":{\"77\":1}}],[\"policy\",{\"0\":{\"29\":1,\"31\":1,\"53\":1,\"65\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"86\":1,\"87\":1,\"88\":1,\"121\":2,\"122\":1,\"123\":1,\"126\":1,\"147\":1},\"1\":{\"19\":2,\"20\":1,\"23\":2,\"45\":1,\"47\":1,\"52\":1,\"53\":2,\"63\":3,\"66\":2,\"68\":1,\"69\":1,\"70\":11,\"71\":2,\"76\":1,\"77\":1,\"79\":4,\"82\":3,\"86\":2,\"87\":2,\"88\":1,\"111\":1,\"115\":1,\"120\":1,\"121\":2,\"122\":2,\"123\":4,\"124\":3,\"125\":2,\"144\":1,\"147\":2,\"148\":1}}],[\"poicy\",{\"0\":{\"125\":1}}],[\"pointcuts\",{\"1\":{\"1219\":1}}],[\"pointcut\",{\"1\":{\"1219\":2,\"1220\":3,\"1223\":1,\"1224\":2,\"1225\":2,\"1226\":1,\"1231\":2}}],[\"pointing\",{\"1\":{\"1181\":1}}],[\"point\",{\"1\":{\"58\":1,\"1223\":1,\"1226\":1,\"1234\":2,\"1237\":2}}],[\"postprocessbeanfactory\",{\"1\":{\"1311\":1,\"1320\":1}}],[\"postprocessbeandefinitionregistry\",{\"1\":{\"1311\":1,\"1327\":1}}],[\"postprocessbeforeinitialization\",{\"1\":{\"1307\":3}}],[\"postprocessafterinitialization\",{\"1\":{\"1307\":2}}],[\"postconstruct\",{\"1\":{\"1176\":1,\"1308\":1,\"1309\":1,\"1311\":1}}],[\"postconstruct和\",{\"1\":{\"1176\":1}}],[\"postgresql\",{\"1\":{\"862\":1}}],[\"postfilter这里就不做演示了\",{\"1\":{\"699\":1}}],[\"postfilter对集合类型的参数或返回值进行过滤\",{\"1\":{\"699\":1}}],[\"postauthorize\",{\"1\":{\"697\":1}}],[\"postauthorize注解\",{\"1\":{\"697\":1}}],[\"posthandle\",{\"1\":{\"595\":1,\"600\":1}}],[\"postmapping直接指定为post请求类型的请求映射\",{\"1\":{\"573\":1}}],[\"postmapping\",{\"1\":{\"573\":1,\"617\":2,\"636\":2,\"658\":1,\"666\":1}}],[\"post\",{\"1\":{\"572\":1,\"589\":4,\"617\":2,\"619\":2,\"636\":2,\"641\":1,\"660\":4,\"666\":1,\"682\":1,\"683\":1,\"1059\":2,\"1069\":2,\"1075\":1,\"1148\":1,\"1320\":1}}],[\"positive\",{\"1\":{\"86\":1,\"97\":1}}],[\"possible\",{\"1\":{\"41\":1}}],[\"pm​ax​\",{\"1\":{\"9\":1}}],[\"pmax​≥γσ2k0​dkn​​α\",{\"1\":{\"9\":1}}],[\"−2\",{\"1\":{\"142\":2}}],[\"−q^​\",{\"1\":{\"139\":1,\"140\":1,\"141\":1,\"142\":3}}],[\"−v^\",{\"1\":{\"133\":1,\"134\":2,\"135\":2,\"136\":4,\"138\":1}}],[\"−vπk​\",{\"1\":{\"66\":1}}],[\"−tdtargetvt​ˉ​\",{\"1\":{\"112\":1}}],[\"−αt​\",{\"1\":{\"112\":1,\"116\":1,\"120\":1}}],[\"−\",{\"1\":{\"110\":1,\"112\":1,\"116\":1,\"120\":1}}],[\"−x\",{\"1\":{\"99\":1}}],[\"−xkn​​\",{\"1\":{\"8\":1}}],[\"−e\",{\"1\":{\"99\":1,\"104\":2}}],[\"−f\",{\"1\":{\"58\":1}}],[\"−b\",{\"1\":{\"26\":1}}],[\"−0\",{\"1\":{\"13\":1}}],[\"−1rπk​​\",{\"1\":{\"68\":1}}],[\"−1rπ​\",{\"1\":{\"47\":1}}],[\"−1rπ​​\",{\"1\":{\"47\":1}}],[\"−1\",{\"1\":{\"9\":1,\"10\":2,\"13\":4}}],[\"−ykn​​\",{\"1\":{\"8\":1}}],[\"+factory\",{\"1\":{\"1296\":1}}],[\"+fileobj\",{\"1\":{\"619\":1}}],[\"+beanname\",{\"1\":{\"1307\":2}}],[\"+bean\",{\"1\":{\"1224\":1}}],[\"+value\",{\"1\":{\"1224\":1}}],[\"+point\",{\"1\":{\"1223\":1}}],[\"+param\",{\"1\":{\"799\":1}}],[\"+new\",{\"1\":{\"1190\":1}}],[\"+name\",{\"1\":{\"408\":2,\"1186\":1,\"1199\":1,\"1200\":1}}],[\"+name+\",{\"1\":{\"162\":1,\"799\":1}}],[\"+log\",{\"1\":{\"950\":2}}],[\"+list\",{\"1\":{\"699\":2}}],[\"+child\",{\"1\":{\"819\":1}}],[\"+c2​\",{\"1\":{\"10\":1}}],[\"+object\",{\"1\":{\"799\":1}}],[\"+user\",{\"1\":{\"583\":1}}],[\"+username\",{\"1\":{\"579\":1,\"580\":1,\"581\":1,\"589\":2}}],[\"+returnval\",{\"1\":{\"1236\":1}}],[\"+returnvalue\",{\"1\":{\"1231\":1}}],[\"+reader\",{\"1\":{\"720\":1}}],[\"+request\",{\"1\":{\"582\":1}}],[\"+rtt−rkn​​\",{\"1\":{\"10\":1}}],[\"+127\",{\"1\":{\"531\":1}}],[\"+html\",{\"1\":{\"490\":1}}],[\"+scanner\",{\"1\":{\"804\":2}}],[\"+sex\",{\"1\":{\"799\":1}}],[\"+sid+\",{\"1\":{\"799\":1}}],[\"+socket\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"+s\",{\"1\":{\"480\":1}}],[\"+str\",{\"1\":{\"349\":1,\"356\":1,\"1223\":1}}],[\"+e\",{\"1\":{\"424\":1}}],[\"+text\",{\"1\":{\"589\":2,\"720\":1}}],[\"+test\",{\"1\":{\"408\":1,\"585\":1}}],[\"+this\",{\"1\":{\"408\":1}}],[\"+表示对前面这个字符匹配一次或多次\",{\"1\":{\"403\":1}}],[\"+=\",{\"1\":{\"402\":1,\"1246\":4,\"1247\":2}}],[\"+account+\",{\"1\":{\"636\":2,\"658\":1}}],[\"+a\",{\"1\":{\"414\":5}}],[\"+array\",{\"1\":{\"393\":1}}],[\"+age+\",{\"1\":{\"162\":1,\"464\":1}}],[\"+i+\",{\"1\":{\"490\":1,\"796\":1}}],[\"+i\",{\"1\":{\"299\":1,\"304\":2,\"305\":2,\"330\":1,\"448\":1}}],[\"++localbadconnectioncount\",{\"1\":{\"1246\":1}}],[\"++this\",{\"1\":{\"710\":1,\"1246\":4,\"1247\":1}}],[\"++size\",{\"1\":{\"216\":1}}],[\"++modcount\",{\"1\":{\"216\":1}}],[\"++bincount\",{\"1\":{\"216\":1}}],[\"+η▽w​f\",{\"1\":{\"104\":1}}],[\"+η​\",{\"1\":{\"99\":1,\"110\":1}}],[\"+ηk​\",{\"1\":{\"97\":1}}],[\"+γs\",{\"1\":{\"46\":1,\"77\":1}}],[\"+γe\",{\"1\":{\"42\":1,\"45\":1}}],[\"+ζ2​moskn​​rate\",{\"1\":{\"10\":1}}],[\"+\",{\"0\":{\"467\":1,\"479\":1,\"503\":1,\"680\":1,\"687\":1,\"991\":1,\"1029\":1,\"1030\":1,\"1089\":1,\"1100\":1,\"1122\":1,\"1138\":1,\"1291\":1},\"1\":{\"8\":1,\"99\":1,\"110\":1,\"165\":2,\"182\":3,\"190\":1,\"205\":1,\"206\":1,\"222\":4,\"228\":1,\"296\":1,\"330\":1,\"331\":6,\"349\":1,\"372\":2,\"384\":1,\"394\":1,\"402\":5,\"403\":2,\"411\":1,\"415\":1,\"431\":1,\"478\":2,\"479\":2,\"490\":4,\"500\":1,\"512\":3,\"521\":2,\"523\":8,\"525\":4,\"534\":1,\"625\":8,\"708\":4,\"710\":1,\"789\":9,\"799\":1,\"804\":2,\"819\":1,\"841\":2,\"871\":2,\"900\":1,\"939\":4,\"944\":3,\"969\":1,\"1057\":2,\"1069\":2,\"1082\":1,\"1091\":2,\"1188\":2,\"1204\":1,\"1223\":1,\"1224\":1,\"1234\":1,\"1242\":1,\"1246\":11,\"1247\":6,\"1273\":2,\"1296\":1,\"1300\":4,\"1321\":1,\"1327\":2}}],[\"yet\",{\"1\":{\"1300\":1}}],[\"year存储年份\",{\"1\":{\"746\":1}}],[\"yyyy年mm月dd日\",{\"1\":{\"1076\":1}}],[\"yyyy\",{\"1\":{\"948\":1}}],[\"yyds等\",{\"1\":{\"571\":1}}],[\"yyds\",{\"1\":{\"563\":1,\"569\":3,\"699\":1,\"1091\":1,\"1093\":1}}],[\"your\",{\"1\":{\"1047\":1,\"1327\":1}}],[\"you\",{\"1\":{\"498\":3,\"1047\":5}}],[\"yoni\",{\"1\":{\"222\":3}}],[\"y\",{\"1\":{\"449\":3}}],[\"yield\",{\"1\":{\"304\":1,\"497\":3}}],[\"yt​\",{\"1\":{\"142\":1}}],[\"yt​≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yt​−q^​\",{\"1\":{\"142\":2}}],[\"y≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yuser​\",{\"1\":{\"14\":2}}],[\"yuav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"yd​+1\",{\"1\":{\"13\":1}}],[\"yd​\",{\"1\":{\"13\":1}}],[\"yn​\",{\"1\":{\"8\":2}}],[\"ykn​​\",{\"1\":{\"8\":1}}],[\"x64\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"xhr\",{\"1\":{\"1076\":7}}],[\"xhtml+xml\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"x版本\",{\"1\":{\"680\":1}}],[\"xb等等\",{\"1\":{\"571\":1}}],[\"xa\",{\"1\":{\"571\":1}}],[\"xsd\",{\"1\":{\"545\":1,\"547\":1,\"549\":2,\"1002\":2,\"1023\":2,\"1032\":2,\"1119\":1,\"1167\":1,\"1217\":2}}],[\"xsi\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"xsi=\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"xss漏洞便成为了web应用程序中的一种常见安全漏洞\",{\"1\":{\"643\":1}}],[\"xss漏洞最早被发现是在1996年\",{\"1\":{\"643\":1}}],[\"xss之父\",{\"1\":{\"643\":1}}],[\"xss攻击\",{\"1\":{\"643\":1}}],[\"xss攻击常见的方式有三种\",{\"1\":{\"643\":1}}],[\"xss跨站脚本攻击\",{\"0\":{\"643\":1}}],[\"xss\",{\"1\":{\"228\":1,\"643\":2,\"714\":1}}],[\"x$0\",{\"1\":{\"522\":2}}],[\"xmlbeandefinitionreader\",{\"1\":{\"1296\":2,\"1297\":3}}],[\"xml不需要配置\",{\"1\":{\"1231\":1}}],[\"xml只需要\",{\"1\":{\"1160\":1}}],[\"xml编写即可\",{\"1\":{\"1086\":1}}],[\"xmlhttprequest\",{\"1\":{\"1076\":1}}],[\"xml填写对应mapper的配置\",{\"1\":{\"1071\":1}}],[\"xml中\",{\"1\":{\"1054\":1}}],[\"xml中进行注册\",{\"1\":{\"1054\":1}}],[\"xml中参数名改为\",{\"1\":{\"843\":1}}],[\"xml则是maven的核心配置\",{\"1\":{\"1002\":1}}],[\"xml文件进行编辑\",{\"1\":{\"1119\":1}}],[\"xml文件\",{\"1\":{\"1010\":1}}],[\"xml文件了\",{\"1\":{\"893\":1,\"894\":1}}],[\"xml文件也可以使用注释\",{\"1\":{\"817\":1}}],[\"xml配置sql操作\",{\"1\":{\"831\":1}}],[\"xml的文件作为我们的映射器\",{\"1\":{\"826\":1}}],[\"xml的文件\",{\"1\":{\"824\":1}}],[\"xml语言发明最初是用于数据的存储和传输\",{\"1\":{\"817\":1}}],[\"xml语言\",{\"0\":{\"817\":1}}],[\"xml下的包扫描需要这样开启\",{\"1\":{\"549\":1}}],[\"xml<\",{\"1\":{\"548\":1}}],[\"xmlschema\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"xmlns\",{\"1\":{\"545\":1,\"547\":1,\"549\":2,\"563\":1,\"564\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":2}}],[\"xmlns=\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"xml\",{\"1\":{\"480\":1,\"545\":4,\"547\":2,\"549\":1,\"727\":1,\"816\":1,\"817\":2,\"819\":1,\"824\":2,\"826\":3,\"830\":1,\"841\":1,\"842\":1,\"1002\":1,\"1017\":2,\"1023\":1,\"1032\":1,\"1047\":1,\"1071\":3,\"1072\":1,\"1091\":1,\"1096\":1,\"1097\":1,\"1119\":5,\"1124\":2,\"1125\":1,\"1148\":1,\"1167\":1,\"1181\":3,\"1217\":1,\"1221\":1,\"1224\":1,\"1225\":1,\"1242\":1,\"1254\":1,\"1255\":1,\"1296\":2,\"1298\":2,\"1299\":1}}],[\"x之内的随机数\",{\"1\":{\"431\":1}}],[\"xxxinputstream\",{\"1\":{\"726\":1}}],[\"xxxoutputstream\",{\"1\":{\"726\":1}}],[\"xxx\",{\"1\":{\"684\":1,\"767\":1,\"769\":3,\"831\":4,\"937\":1,\"1205\":1}}],[\"xxxx\",{\"1\":{\"586\":1,\"660\":1,\"686\":1,\"750\":1,\"1075\":1,\"1082\":1}}],[\"xxxxx\",{\"1\":{\"399\":1,\"818\":1}}],[\"xxx等\",{\"1\":{\"571\":1}}],[\"xxxexception\",{\"1\":{\"424\":2}}],[\"xx\",{\"1\":{\"228\":1,\"843\":1}}],[\"xi​\",{\"1\":{\"101\":2}}],[\"xk+1​=f\",{\"1\":{\"58\":1}}],[\"xk​→x∗\",{\"1\":{\"58\":1}}],[\"xk​\",{\"1\":{\"58\":2,\"101\":1,\"104\":1,\"110\":1}}],[\"xkn​​\",{\"1\":{\"8\":1}}],[\"x∗\",{\"1\":{\"58\":1}}],[\"x=f\",{\"1\":{\"58\":1}}],[\"x2​\",{\"1\":{\"58\":1,\"75\":1}}],[\"x1​\",{\"1\":{\"58\":1}}],[\"x\",{\"1\":{\"58\":2,\"75\":1,\"94\":1,\"99\":10,\"101\":6,\"104\":17,\"110\":9,\"449\":3,\"571\":1,\"617\":1,\"636\":1,\"666\":1,\"714\":3,\"727\":1}}],[\"xuser​\",{\"1\":{\"14\":2}}],[\"xuav​\",{\"1\":{\"13\":1,\"14\":2}}],[\"xt​=⎩⎨⎧​1\",{\"1\":{\"13\":1}}],[\"xd​+1\",{\"1\":{\"13\":1}}],[\"xd​\",{\"1\":{\"13\":1}}],[\"xn​\",{\"1\":{\"8\":2,\"75\":1}}],[\"=等\",{\"1\":{\"763\":1}}],[\"=>\",{\"1\":{\"617\":3,\"636\":1,\"666\":1}}],[\"=test\",{\"1\":{\"574\":1}}],[\"===\",{\"1\":{\"1076\":2}}],[\"====>\",{\"1\":{\"852\":2}}],[\"=========================\",{\"1\":{\"415\":1}}],[\"====================================\",{\"1\":{\"414\":2}}],[\"=================\",{\"1\":{\"415\":1}}],[\"====​n→∞lim​n1​e\",{\"1\":{\"154\":1}}],[\"==>向右的箭头就是发送给mysql服务器的sql语句以及其参数列表\",{\"1\":{\"852\":1}}],[\"==>\",{\"1\":{\"852\":2}}],[\"==\",{\"1\":{\"182\":2,\"216\":9,\"217\":1,\"241\":6,\"299\":1,\"304\":1,\"305\":1,\"340\":1,\"343\":1,\"372\":1,\"373\":2,\"377\":1,\"384\":3,\"401\":3,\"423\":2,\"449\":1,\"625\":3,\"626\":1,\"672\":1,\"692\":1,\"706\":2,\"707\":1,\"708\":1,\"710\":1,\"711\":1,\"727\":1,\"789\":3,\"819\":1,\"874\":2,\"930\":3,\"939\":1,\"970\":1,\"972\":2,\"974\":1,\"990\":1,\"991\":1,\"1059\":1,\"1096\":1,\"1104\":1,\"1129\":2,\"1209\":1,\"1246\":2,\"1247\":1,\"1273\":1,\"1296\":1,\"1300\":2,\"1301\":4}}],[\"=θt​+αe\",{\"1\":{\"156\":1}}],[\"=dtvπ​\",{\"1\":{\"150\":1}}],[\"=i=1∑n​yt​−q^​\",{\"1\":{\"142\":1}}],[\"=−2e\",{\"1\":{\"136\":1}}],[\"=−c1​ln\",{\"1\":{\"10\":1}}],[\"=∣s∣1​s∈s∑​\",{\"1\":{\"134\":1}}],[\"=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"=vt​\",{\"1\":{\"112\":1}}],[\"=vπ0​​\",{\"1\":{\"70\":1}}],[\"=w−\",{\"1\":{\"110\":1}}],[\"=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"=wk​−αk​e\",{\"1\":{\"101\":1}}],[\"=wk​−αk​\",{\"1\":{\"99\":1,\"110\":1}}],[\"=▽w​j\",{\"1\":{\"104\":1}}],[\"=g\",{\"1\":{\"97\":1,\"104\":1}}],[\"=k1​\",{\"1\":{\"94\":1}}],[\"=k0​−1dkn​​−α\",{\"1\":{\"9\":1}}],[\"=n1​∑i=1n​xi​\",{\"1\":{\"94\":1}}],[\"=1\",{\"1\":{\"79\":1,\"135\":1,\"150\":1}}],[\"=argmaxπ​∑a​π\",{\"1\":{\"79\":1}}],[\"=argmaxa​qπk​​\",{\"1\":{\"66\":1}}],[\"=argmaxa​qk​\",{\"1\":{\"63\":1}}],[\"=a∑​πk​\",{\"1\":{\"66\":1}}],[\"=a∑​π\",{\"1\":{\"43\":1,\"44\":3,\"45\":1,\"48\":1,\"113\":1}}],[\"=πargmax​a∑​πk​\",{\"1\":{\"66\":1}}],[\"=πargmax​a∑​π\",{\"1\":{\"63\":1}}],[\"=πmax​\",{\"1\":{\"61\":1,\"62\":1}}],[\"=x∗\",{\"1\":{\"58\":1}}],[\"=x\",{\"1\":{\"58\":1}}],[\"=maxa​qk​\",{\"1\":{\"63\":1}}],[\"=maxπ​\",{\"1\":{\"58\":1}}],[\"=maxπ​∑a​π\",{\"1\":{\"57\":1}}],[\"=mean\",{\"1\":{\"45\":1}}],[\"=∑a​π\",{\"1\":{\"49\":1}}],[\"=∑a​qπ​\",{\"1\":{\"48\":1}}],[\"=∑r​p\",{\"1\":{\"48\":1}}],[\"=r∑​rp\",{\"1\":{\"153\":1}}],[\"=r∑​p\",{\"1\":{\"77\":1}}],[\"=rπ​\",{\"1\":{\"46\":1}}],[\"=rt+1​+γgt+1​​\",{\"1\":{\"42\":1}}],[\"=rt+1​+γ\",{\"1\":{\"42\":1}}],[\"=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"=s∈s∑​dπ​\",{\"1\":{\"135\":1}}],[\"=s\",{\"1\":{\"44\":3}}],[\"=sin−1\",{\"1\":{\"9\":1}}],[\"=es∼d\",{\"1\":{\"155\":1}}],[\"=es∼d​\",{\"1\":{\"153\":1,\"155\":1}}],[\"=es∼η\",{\"1\":{\"26\":1}}],[\"=e\",{\"1\":{\"40\":1,\"42\":2,\"48\":1,\"49\":2,\"75\":2,\"77\":1,\"78\":1,\"101\":1,\"104\":4,\"113\":3,\"115\":1,\"119\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"151\":1,\"153\":1,\"155\":1}}],[\"=0\",{\"1\":{\"26\":1,\"96\":1,\"98\":2,\"99\":1,\"104\":2,\"110\":1}}],[\"=p\",{\"1\":{\"20\":2}}],[\"=3rtt+rkn​​\",{\"1\":{\"10\":1}}],[\"=ζ1​moskn​​delay\",{\"1\":{\"10\":1}}],[\"=γk0​σ2dkn​​α\",{\"1\":{\"9\":1}}],[\"=b2​ln\",{\"1\":{\"9\":1}}],[\"=bkn​​log2​\",{\"1\":{\"9\":1}}],[\"=b1​\",{\"1\":{\"9\":1}}],[\"=σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"=\",{\"1\":{\"8\":1,\"19\":1,\"57\":1,\"63\":1,\"66\":1,\"87\":1,\"99\":1,\"110\":1,\"155\":1,\"161\":6,\"162\":3,\"164\":2,\"166\":16,\"171\":9,\"172\":8,\"173\":1,\"180\":4,\"181\":3,\"182\":26,\"187\":4,\"190\":3,\"191\":3,\"192\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"215\":1,\"216\":20,\"217\":14,\"221\":1,\"222\":5,\"223\":3,\"224\":2,\"228\":12,\"233\":1,\"234\":1,\"235\":1,\"236\":3,\"237\":4,\"241\":12,\"247\":4,\"248\":6,\"249\":2,\"250\":1,\"251\":5,\"253\":3,\"254\":1,\"255\":4,\"262\":1,\"264\":5,\"265\":2,\"266\":1,\"267\":1,\"269\":3,\"270\":1,\"274\":1,\"277\":1,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":5,\"289\":2,\"290\":6,\"295\":3,\"297\":2,\"299\":4,\"301\":1,\"302\":1,\"304\":4,\"305\":4,\"311\":5,\"312\":19,\"313\":4,\"318\":4,\"319\":3,\"320\":2,\"322\":4,\"323\":1,\"324\":4,\"329\":5,\"330\":2,\"331\":3,\"339\":3,\"340\":1,\"341\":1,\"343\":14,\"348\":9,\"349\":12,\"350\":7,\"356\":9,\"364\":1,\"365\":4,\"373\":5,\"375\":4,\"376\":4,\"377\":2,\"378\":3,\"384\":10,\"385\":3,\"386\":6,\"392\":6,\"393\":1,\"394\":2,\"395\":8,\"396\":3,\"397\":1,\"398\":1,\"401\":10,\"402\":13,\"403\":2,\"408\":11,\"409\":2,\"410\":2,\"411\":1,\"412\":4,\"413\":3,\"414\":5,\"415\":6,\"424\":3,\"425\":1,\"431\":2,\"432\":1,\"437\":5,\"438\":13,\"439\":4,\"445\":1,\"446\":2,\"447\":5,\"448\":1,\"449\":2,\"451\":2,\"452\":2,\"453\":4,\"454\":1,\"462\":2,\"464\":3,\"475\":4,\"478\":1,\"480\":6,\"485\":3,\"487\":1,\"488\":3,\"490\":22,\"495\":6,\"496\":1,\"497\":3,\"498\":1,\"499\":3,\"500\":1,\"501\":2,\"504\":1,\"510\":1,\"511\":3,\"512\":7,\"515\":2,\"518\":2,\"519\":2,\"521\":6,\"522\":7,\"523\":8,\"524\":5,\"525\":4,\"528\":3,\"531\":1,\"550\":1,\"560\":3,\"563\":4,\"572\":2,\"573\":1,\"574\":6,\"575\":5,\"576\":2,\"579\":1,\"580\":3,\"581\":4,\"582\":2,\"583\":1,\"585\":3,\"586\":3,\"588\":1,\"589\":8,\"610\":1,\"612\":2,\"613\":3,\"615\":3,\"616\":3,\"617\":10,\"619\":3,\"620\":4,\"625\":13,\"626\":25,\"631\":3,\"636\":4,\"642\":2,\"658\":3,\"659\":2,\"660\":2,\"664\":1,\"666\":6,\"670\":1,\"671\":1,\"672\":1,\"687\":1,\"692\":1,\"699\":3,\"705\":6,\"706\":8,\"707\":1,\"708\":9,\"709\":6,\"710\":1,\"711\":1,\"712\":1,\"719\":5,\"720\":11,\"721\":2,\"726\":13,\"727\":7,\"769\":2,\"770\":1,\"781\":1,\"788\":3,\"789\":12,\"796\":6,\"798\":2,\"799\":12,\"804\":5,\"805\":5,\"806\":9,\"810\":6,\"819\":8,\"824\":4,\"826\":3,\"830\":3,\"831\":2,\"832\":1,\"833\":2,\"834\":3,\"835\":2,\"836\":4,\"841\":11,\"842\":5,\"843\":5,\"850\":2,\"851\":2,\"852\":2,\"853\":2,\"854\":2,\"855\":3,\"863\":2,\"864\":1,\"865\":5,\"871\":3,\"873\":1,\"874\":3,\"876\":1,\"877\":2,\"883\":5,\"884\":4,\"886\":1,\"887\":1,\"888\":1,\"897\":4,\"898\":5,\"900\":10,\"901\":9,\"902\":5,\"903\":5,\"904\":4,\"908\":1,\"910\":8,\"911\":1,\"912\":2,\"918\":1,\"919\":1,\"920\":1,\"921\":1,\"927\":3,\"930\":4,\"937\":1,\"938\":2,\"939\":8,\"946\":1,\"948\":3,\"950\":1,\"963\":2,\"969\":3,\"978\":2,\"979\":5,\"990\":1,\"991\":1,\"993\":2,\"995\":2,\"1008\":1,\"1017\":3,\"1047\":1,\"1057\":3,\"1058\":1,\"1059\":12,\"1064\":2,\"1071\":2,\"1072\":10,\"1074\":4,\"1075\":2,\"1076\":5,\"1084\":1,\"1085\":4,\"1086\":1,\"1091\":1,\"1093\":14,\"1096\":3,\"1102\":1,\"1104\":4,\"1117\":1,\"1119\":5,\"1125\":2,\"1126\":2,\"1127\":1,\"1128\":1,\"1129\":4,\"1132\":2,\"1133\":2,\"1134\":1,\"1135\":2,\"1136\":1,\"1148\":1,\"1149\":2,\"1159\":2,\"1166\":2,\"1167\":1,\"1169\":2,\"1170\":4,\"1173\":1,\"1176\":2,\"1178\":2,\"1179\":1,\"1181\":1,\"1188\":2,\"1189\":1,\"1190\":1,\"1192\":3,\"1199\":1,\"1200\":2,\"1202\":3,\"1203\":8,\"1204\":3,\"1205\":2,\"1207\":4,\"1208\":4,\"1209\":3,\"1210\":1,\"1211\":3,\"1221\":2,\"1222\":1,\"1224\":7,\"1225\":2,\"1231\":1,\"1233\":2,\"1235\":2,\"1236\":3,\"1237\":1,\"1242\":6,\"1244\":6,\"1245\":9,\"1246\":17,\"1247\":6,\"1254\":1,\"1255\":1,\"1256\":3,\"1257\":2,\"1259\":1,\"1260\":3,\"1273\":6,\"1276\":2,\"1278\":2,\"1282\":1,\"1283\":1,\"1288\":2,\"1291\":1,\"1296\":7,\"1297\":5,\"1298\":4,\"1299\":1,\"1300\":5,\"1301\":9,\"1308\":1,\"1310\":2,\"1311\":2,\"1318\":6,\"1319\":1,\"1320\":3,\"1321\":3,\"1326\":1,\"1327\":3,\"1328\":1}}],[\"h1>\",{\"1\":{\"1059\":1,\"1064\":1,\"1069\":1}}],[\"hh\",{\"1\":{\"948\":1,\"1076\":1}}],[\"holds\",{\"1\":{\"1148\":1}}],[\"hold\",{\"1\":{\"1148\":1}}],[\"however\",{\"1\":{\"1181\":1}}],[\"how\",{\"1\":{\"1047\":1}}],[\"host\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"home\",{\"1\":{\"587\":8,\"596\":1,\"600\":1,\"1047\":1}}],[\"href\",{\"1\":{\"642\":1}}],[\"href=\",{\"1\":{\"490\":1,\"620\":1,\"1074\":1}}],[\"held\",{\"1\":{\"1148\":1}}],[\"helloworld\",{\"1\":{\"549\":1,\"554\":1,\"563\":1}}],[\"hellocontroller\",{\"1\":{\"549\":1,\"561\":1,\"636\":1,\"658\":1,\"679\":1,\"695\":1}}],[\"hello\",{\"1\":{\"162\":2,\"171\":2,\"267\":1,\"401\":6,\"410\":1,\"445\":1,\"446\":1,\"454\":4,\"461\":1,\"468\":1,\"485\":3,\"510\":1,\"511\":1,\"549\":1,\"554\":1,\"617\":2,\"912\":1,\"919\":2,\"939\":1,\"956\":1,\"1119\":3,\"1125\":1,\"1126\":1,\"1127\":1,\"1128\":1,\"1199\":1,\"1200\":1,\"1202\":3,\"1203\":3}}],[\"here\",{\"1\":{\"789\":2}}],[\"headquarters\",{\"1\":{\"748\":1}}],[\"head\",{\"1\":{\"626\":1,\"1059\":1}}],[\"headerwriterfilter\",{\"1\":{\"714\":1}}],[\"header属性用法与params一致\",{\"1\":{\"576\":1}}],[\"headers\",{\"1\":{\"569\":1,\"576\":1,\"617\":1,\"636\":1,\"666\":1}}],[\"head>\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"hierarchicalbeanfactory\",{\"1\":{\"1316\":1}}],[\"hikaripool\",{\"1\":{\"1260\":4,\"1278\":1}}],[\"hikari\",{\"1\":{\"1260\":3,\"1278\":1}}],[\"hikaridatasource\",{\"1\":{\"1260\":4,\"1276\":2,\"1278\":1}}],[\"hikaricp数据源的启动日志就可以正常打印出来了\",{\"1\":{\"1260\":1}}],[\"hikaricp的速度是现在常用的c3p0数据库连接池的数百倍\",{\"1\":{\"1260\":1}}],[\"hikaricp是由日本程序员开源的一个数据库连接池组件\",{\"1\":{\"1260\":1}}],[\"hikaricp连接池\",{\"0\":{\"1260\":1}}],[\"hidden>\",{\"1\":{\"641\":1,\"660\":2,\"682\":1,\"683\":1}}],[\"hidden><\",{\"1\":{\"641\":1}}],[\"hiddeniframe\",{\"1\":{\"641\":2}}],[\"hint2\",{\"0\":{\"531\":1}}],[\"hint\",{\"0\":{\"528\":1,\"534\":1,\"1339\":1},\"2\":{\"530\":1,\"533\":1,\"538\":1}}],[\"high\",{\"1\":{\"384\":1}}],[\"httpfilter\",{\"1\":{\"1104\":3}}],[\"http请求报文中的所有内容\",{\"1\":{\"1056\":1}}],[\"http请求是基于tcp协议\",{\"1\":{\"727\":1}}],[\"http协议首先要和服务器建立tcp连接\",{\"1\":{\"1042\":1}}],[\"http协议默认使用80端口\",{\"1\":{\"1042\":1}}],[\"http使用tcp协议是为了使得数据传输更加可靠\",{\"1\":{\"1042\":1}}],[\"http使用了面向连接的tcp作为运输层协议\",{\"1\":{\"1042\":1}}],[\"http虽然使用了tcp连接\",{\"1\":{\"1042\":1}}],[\"http不必考虑数据在传输过程中被丢弃后又怎样被重传\",{\"1\":{\"1042\":1}}],[\"http不仅传送完成超文本跳转所需的必须信息\",{\"1\":{\"1042\":1}}],[\"http的传输原理\",{\"1\":{\"1042\":1}}],[\"http是基于tcp进行通信的\",{\"1\":{\"1042\":1}}],[\"http是面向事务的应用层协议\",{\"1\":{\"1042\":1}}],[\"http是一种应用层协议\",{\"1\":{\"727\":1}}],[\"httponly\",{\"1\":{\"1096\":1}}],[\"httponly的应用仍存在局限性\",{\"1\":{\"642\":1}}],[\"httponly是cookie中一个属性\",{\"1\":{\"642\":1}}],[\"httpmethod\",{\"1\":{\"626\":2}}],[\"http\",{\"1\":{\"545\":1,\"547\":3,\"549\":5,\"563\":1,\"564\":1,\"589\":5,\"641\":1,\"642\":1,\"658\":1,\"680\":2,\"683\":2,\"684\":2,\"686\":2,\"714\":1,\"727\":5,\"824\":1,\"826\":1,\"1002\":4,\"1017\":1,\"1023\":4,\"1032\":4,\"1047\":5,\"1053\":1,\"1059\":3,\"1071\":1,\"1091\":3,\"1096\":3,\"1104\":1,\"1119\":3,\"1167\":3,\"1217\":7,\"1242\":1,\"1255\":1,\"1260\":1}}],[\"httpresponse<inputstream>\",{\"1\":{\"490\":1}}],[\"httpresponse<string>\",{\"1\":{\"490\":2}}],[\"httpresponse\",{\"1\":{\"490\":3}}],[\"httprequest\",{\"1\":{\"490\":6}}],[\"httpclient\",{\"1\":{\"490\":8}}],[\"httpstatusrequestrejectedhandler\",{\"1\":{\"709\":1}}],[\"httpsecurity\",{\"1\":{\"680\":1,\"683\":1,\"684\":1,\"686\":1}}],[\"httpservlet\",{\"1\":{\"1059\":3,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1}}],[\"httpservletbean\",{\"1\":{\"625\":1}}],[\"httpservletresponse\",{\"1\":{\"585\":1,\"595\":3,\"600\":4,\"620\":1,\"626\":5,\"708\":2,\"711\":2,\"712\":1,\"713\":1,\"714\":1,\"1058\":2,\"1059\":7,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1104\":4}}],[\"httpservletrequest\",{\"1\":{\"575\":2,\"582\":1,\"595\":3,\"600\":4,\"626\":6,\"708\":2,\"711\":2,\"712\":1,\"713\":1,\"1057\":2,\"1059\":7,\"1064\":1,\"1069\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":2,\"1104\":4}}],[\"httpsessionevent\",{\"1\":{\"1105\":1}}],[\"httpsessioneventpublisher\",{\"1\":{\"705\":1}}],[\"httpsessionlistener\",{\"1\":{\"1105\":1}}],[\"httpsession\",{\"1\":{\"582\":1,\"586\":1,\"636\":3,\"1096\":2,\"1104\":1}}],[\"https\",{\"1\":{\"403\":1,\"490\":5,\"545\":3,\"547\":1,\"549\":2,\"617\":2,\"636\":1,\"641\":1,\"642\":1,\"811\":1,\"824\":1,\"852\":1,\"873\":1,\"902\":1,\"995\":1,\"1008\":1,\"1047\":1,\"1113\":1,\"1119\":1,\"1167\":1,\"1190\":1,\"1211\":1,\"1219\":1}}],[\"html文件\",{\"1\":{\"1053\":1}}],[\"html主要用于通过编排来展示数据\",{\"1\":{\"817\":1}}],[\"html>\",{\"1\":{\"562\":2,\"563\":2,\"564\":2,\"605\":2,\"617\":4,\"636\":6,\"641\":2,\"642\":2}}],[\"html\",{\"1\":{\"403\":1,\"490\":10,\"560\":1,\"577\":1,\"727\":1,\"824\":1,\"902\":1,\"1047\":2,\"1058\":2,\"1059\":1,\"1064\":1,\"1072\":1,\"1075\":1,\"1076\":1,\"1091\":2,\"1096\":2,\"1113\":2,\"1211\":2,\"1219\":2,\"1260\":1}}],[\"h\",{\"1\":{\"386\":2}}],[\"humans\",{\"1\":{\"1047\":1}}],[\"hugecapacity\",{\"1\":{\"182\":1}}],[\"huav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"hadtowaitcount\",{\"1\":{\"1246\":1}}],[\"hands\",{\"1\":{\"1148\":1}}],[\"handling\",{\"1\":{\"603\":1,\"713\":1}}],[\"handlemapping\",{\"0\":{\"631\":1},\"1\":{\"631\":1}}],[\"handle\",{\"1\":{\"626\":1}}],[\"handlers=java\",{\"1\":{\"939\":1,\"951\":1}}],[\"handler是属于对应的logger的\",{\"1\":{\"928\":1}}],[\"handlerexecutionchain\",{\"1\":{\"626\":1}}],[\"handler\",{\"1\":{\"595\":3,\"600\":4,\"626\":2,\"912\":1,\"918\":1,\"919\":2,\"920\":2,\"921\":3,\"939\":1}}],[\"handlerinterceptor\",{\"1\":{\"595\":1,\"600\":1}}],[\"handleradapter会帮助我们将请求的数据进行处理\",{\"1\":{\"626\":1}}],[\"handleradapter\",{\"1\":{\"553\":1,\"626\":1}}],[\"handlermapping>\",{\"1\":{\"631\":1}}],[\"handlermappings\",{\"1\":{\"631\":3}}],[\"handlermapping保存了所有的请求映射信息\",{\"1\":{\"625\":1}}],[\"handlermapping\",{\"1\":{\"553\":1,\"631\":1}}],[\"handlestypes\",{\"1\":{\"550\":2}}],[\"have\",{\"1\":{\"789\":1,\"1047\":1}}],[\"having\",{\"1\":{\"766\":1,\"1181\":1}}],[\"ha\",{\"1\":{\"626\":3}}],[\"hastext\",{\"1\":{\"1327\":2}}],[\"hasinstantiationawarebeanpostprocessors\",{\"1\":{\"1301\":1}}],[\"hasmoreelements\",{\"1\":{\"1057\":1}}],[\"hasanyauthority\",{\"1\":{\"693\":1}}],[\"hasanyrole\",{\"1\":{\"692\":1,\"697\":1}}],[\"hasrole\",{\"1\":{\"692\":1,\"695\":1,\"697\":1}}],[\"hashtable<object\",{\"1\":{\"937\":1}}],[\"hash\",{\"1\":{\"215\":1,\"216\":13,\"218\":2,\"241\":1,\"453\":2,\"780\":1}}],[\"hashmap的一个链表长度过大时\",{\"1\":{\"217\":1}}],[\"hashmap并不是只使用简单的链地址法\",{\"1\":{\"215\":1}}],[\"hashmap支持自动扩容\",{\"1\":{\"215\":1}}],[\"hashmap<e\",{\"1\":{\"224\":1}}],[\"hashmap<k\",{\"1\":{\"215\":1}}],[\"hashmap<>\",{\"1\":{\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"224\":1,\"241\":1,\"475\":1}}],[\"hashmap\",{\"0\":{\"214\":1,\"215\":1,\"833\":1},\"1\":{\"205\":1,\"206\":1,\"214\":1,\"215\":2,\"218\":3,\"224\":3,\"833\":1,\"834\":1}}],[\"hashset<e>\",{\"1\":{\"224\":1}}],[\"hashset<>\",{\"1\":{\"205\":3}}],[\"hashset\",{\"0\":{\"205\":1,\"224\":1},\"1\":{\"205\":1,\"224\":5}}],[\"hashcode\",{\"1\":{\"180\":1,\"204\":1,\"213\":1,\"241\":7,\"372\":3,\"1247\":1}}],[\"hasprevious\",{\"1\":{\"194\":1}}],[\"hasnext\",{\"1\":{\"180\":1,\"181\":1,\"187\":1,\"189\":3,\"191\":1,\"193\":1,\"194\":1}}],[\"has\",{\"1\":{\"58\":1,\"789\":1,\"1181\":1}}],[\"harder\",{\"1\":{\"1181\":1}}],[\"hard问题\",{\"1\":{\"13\":1}}],[\"hard\",{\"1\":{\"5\":1}}],[\"hybrid\",{\"1\":{\"14\":1}}],[\"hmax​−hmin​+1\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​moskn​​\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​∑t=0ts​​moskn​​\",{\"1\":{\"11\":1}}],[\"hmax​\",{\"1\":{\"8\":1,\"13\":1}}],[\"hmin​≤hn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"hmin​\",{\"1\":{\"8\":1,\"13\":1}}],[\"∈\",{\"1\":{\"8\":1}}],[\"飞行速度恒定\",{\"1\":{\"8\":1}}],[\"其余类型适用于同时操作多数据源情况下的分布式事务管理\",{\"1\":{\"1284\":1}}],[\"其次\",{\"1\":{\"1171\":1,\"1301\":1}}],[\"其默认值为jar\",{\"1\":{\"1015\":1}}],[\"其它\",{\"0\":{\"698\":1}}],[\"其核心功能包括\",{\"1\":{\"635\":1}}],[\"其核心思想是\",{\"1\":{\"75\":1}}],[\"其在代码中频繁被使用\",{\"1\":{\"523\":1}}],[\"其子类的对应的方法的访问权限需要高于抽象类中的方法\",{\"1\":{\"375\":1}}],[\"其返回值定义了该成员变量的类型\",{\"1\":{\"364\":1}}],[\"其方法名定义了该成员变量的名字\",{\"1\":{\"364\":1}}],[\"其实看名字就知道\",{\"1\":{\"1318\":1}}],[\"其实逻辑非常简单\",{\"1\":{\"1300\":1}}],[\"其实创建connection还是依靠数据库驱动创建\",{\"1\":{\"1245\":1}}],[\"其实\",{\"1\":{\"1175\":1}}],[\"其实现的主要功能是\",{\"1\":{\"1132\":1}}],[\"其实我们可以在main里面直接发布事件\",{\"1\":{\"1192\":1}}],[\"其实我们可以看到\",{\"1\":{\"290\":1}}],[\"其实我们只需要继承httpservlet来编写我们的servlet就可以了\",{\"1\":{\"1059\":1}}],[\"其实缓存机制我们在之前学习io流的时候已经提及过了\",{\"1\":{\"882\":1}}],[\"其实idea本质也是使用的jdbc\",{\"1\":{\"788\":1}}],[\"其实自身连接查询和前面的是一样的\",{\"1\":{\"768\":1}}],[\"其实本质上都差不多\",{\"1\":{\"726\":1}}],[\"其实本质上是定义在对应的包装类中的\",{\"1\":{\"340\":1}}],[\"其实其它的过滤器是如何实现的也就很容易联想到了\",{\"1\":{\"714\":1}}],[\"其实整个过程与我们之前所认识的filter类似\",{\"1\":{\"597\":1}}],[\"其实也是一样的\",{\"1\":{\"587\":1}}],[\"其实也就是基本类型的class\",{\"1\":{\"340\":1}}],[\"其实是一种设计模式\",{\"1\":{\"524\":1}}],[\"其实这就是一种方法引用\",{\"1\":{\"448\":1}}],[\"其实枚举类型的本质就是一个普通的类\",{\"1\":{\"378\":1}}],[\"其实不是\",{\"1\":{\"365\":1}}],[\"其实就是简单的创建对象实例并返回即可\",{\"1\":{\"1300\":1}}],[\"其实就是利用了aop机制实现的方法增强\",{\"1\":{\"1222\":1}}],[\"其实就是一个多线程执行的流\",{\"1\":{\"330\":1}}],[\"其实就是编写要在另一个线程执行的内容逻辑\",{\"1\":{\"296\":1}}],[\"其实system\",{\"1\":{\"284\":1}}],[\"其实和bufferedinputstream原理差不多\",{\"1\":{\"267\":1}}],[\"其实mark\",{\"1\":{\"265\":1}}],[\"其实功能和write一样\",{\"1\":{\"254\":1}}],[\"其他级别\",{\"0\":{\"1284\":1}}],[\"其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改\",{\"1\":{\"1267\":1}}],[\"其他事务会读取当前事务已经提交的数据\",{\"1\":{\"1267\":1}}],[\"其他事务会读取当前事务尚未更改的提交\",{\"1\":{\"1267\":1}}],[\"其他注解\",{\"0\":{\"1236\":1}}],[\"其他注解设置的配置\",{\"0\":{\"1171\":1}}],[\"其他\",{\"0\":{\"1179\":1}}],[\"其他就很好找的\",{\"1\":{\"1071\":1}}],[\"其他人使用我们的项目作为依赖时\",{\"1\":{\"1003\":1}}],[\"其他情况的必须满足大于18岁\",{\"1\":{\"874\":1}}],[\"其他情况e都是null\",{\"1\":{\"216\":1}}],[\"其他过滤器\",{\"0\":{\"714\":1}}],[\"其他所有路径必须角色为admin才能访问\",{\"1\":{\"692\":1}}],[\"其他配置\",{\"0\":{\"676\":1,\"1255\":1}}],[\"其他两个属性\",{\"1\":{\"577\":1}}],[\"其他小型变动\",{\"0\":{\"480\":1}}],[\"其他很多语言比如javascript\",{\"1\":{\"403\":1}}],[\"其他定义方法\",{\"1\":{\"392\":1}}],[\"其他地方不能修改\",{\"1\":{\"374\":1}}],[\"其他线程都无法访问被它占用的锁\",{\"1\":{\"313\":1}}],[\"其他的都不行\",{\"1\":{\"692\":1}}],[\"其他的内容其实已经给大家讲解过了\",{\"1\":{\"1280\":1}}],[\"其他的内容\",{\"1\":{\"625\":1}}],[\"其他的集合类都有相应的of方法\",{\"1\":{\"475\":1}}],[\"其他的情况会在讲到反射时介绍\",{\"1\":{\"275\":1}}],[\"其他的算法\",{\"1\":{\"156\":1}}],[\"其他视图操作\",{\"1\":{\"213\":1}}],[\"其他集合类实现\",{\"0\":{\"202\":1}}],[\"其他遍历\",{\"0\":{\"192\":1}}],[\"其他元素一律移除\",{\"1\":{\"180\":1}}],[\"其变量名存储的是对象的引用\",{\"1\":{\"161\":1}}],[\"其求解梯度比较难求\",{\"1\":{\"142\":1}}],[\"其定义都是一个均值\",{\"1\":{\"92\":1}}],[\"其探索性就很强\",{\"1\":{\"87\":1}}],[\"其属于\",{\"1\":{\"87\":1}}],[\"其原始定义都是从期望出发的\",{\"1\":{\"75\":1}}],[\"其对应的\",{\"1\":{\"63\":1,\"343\":1}}],[\"其策略π表示的是最优策略\",{\"1\":{\"55\":1}}],[\"其目标也应该不一样\",{\"1\":{\"13\":1}}],[\"其状态为其3d坐标\",{\"1\":{\"13\":1}}],[\"其高度的下界是距离dkn​​\",{\"1\":{\"9\":1}}],[\"其每个用户带宽表示为\",{\"1\":{\"9\":1}}],[\"其可用带宽为bn​\",{\"1\":{\"9\":1}}],[\"其水平坐标表示为qn​\",{\"1\":{\"8\":1}}],[\"其垂直高度表示为hn​\",{\"1\":{\"8\":1}}],[\"其坐标表示为wkn​​=\",{\"1\":{\"8\":1}}],[\"其中常用的有\",{\"1\":{\"1297\":1}}],[\"其中传递的实际参数的运行时类型具有给定类型的注释\",{\"1\":{\"1219\":1}}],[\"其中执行对象的类具有给定类型的注释\",{\"1\":{\"1219\":1}}],[\"其中参数是给定类型的实例\",{\"1\":{\"1219\":1}}],[\"其中参数为logrecord\",{\"1\":{\"944\":1}}],[\"其中目标对象\",{\"1\":{\"1219\":1}}],[\"其中bean引用\",{\"1\":{\"1219\":1}}],[\"其中book表设计如下\",{\"1\":{\"853\":1}}],[\"其中有一个非常重要的注解\",{\"1\":{\"1175\":1}}],[\"其中第一种就是根据类型获取对应的bean\",{\"1\":{\"1125\":1}}],[\"其中一个是之前的正常打包得到的jar文件\",{\"1\":{\"1037\":1}}],[\"其中一些字符被用作标签表示\",{\"1\":{\"836\":1}}],[\"其中src目录下存放我们的源代码和测试代码\",{\"1\":{\"1001\":1}}],[\"其中st​是随机变量s的一个样本\",{\"1\":{\"136\":1}}],[\"其中matches参数支持正则表达式\",{\"1\":{\"979\":1}}],[\"其中test属性就是我们需要填写的判断条件\",{\"1\":{\"873\":1}}],[\"其中uid作为用户id的逻辑外键\",{\"1\":{\"853\":1}}],[\"其中property就是需要进行一对一处理的对象\",{\"1\":{\"850\":1}}],[\"其中public和abstract关键字可以省略\",{\"1\":{\"376\":1}}],[\"其中namespace就是命名空间\",{\"1\":{\"826\":1}}],[\"其中restrict和cascade上面的效果一致\",{\"1\":{\"752\":1}}],[\"其中群主具有最高权限\",{\"1\":{\"691\":1}}],[\"其中包含用户的用户名和密码以及角色\",{\"1\":{\"658\":1}}],[\"其中最简单的就是判断结果是否等于某个值\",{\"1\":{\"969\":1}}],[\"其中最关键的是它对于循环依赖的处理\",{\"1\":{\"1301\":1}}],[\"其中最关键的是path属性\",{\"1\":{\"569\":1}}],[\"其中最关键的作用就是继承父容器中所有的bean定义\",{\"1\":{\"1298\":1}}],[\"其中最关键的当属表示层\",{\"1\":{\"540\":1}}],[\"其中最突出的就是直接根据下标位置进行的增删改查操作\",{\"1\":{\"181\":1}}],[\"其中比较关键的是用于lambda的形参局部变量语法\",{\"1\":{\"486\":1}}],[\"其中比较突出的就是局部变量类型推断了\",{\"1\":{\"484\":1}}],[\"其中o1和o2都是integer类型的\",{\"1\":{\"451\":1}}],[\"其中存放的每一个数据称为数组的一个元素\",{\"1\":{\"391\":1}}],[\"其中能够表示数字的基本类型包装类\",{\"1\":{\"384\":1}}],[\"其中的值为对应对象的某个函数\",{\"1\":{\"1147\":1}}],[\"其中的\",{\"1\":{\"277\":1}}],[\"其中很多地方重新定义了一次\",{\"1\":{\"181\":1}}],[\"其中w∈rm是参数向量\",{\"1\":{\"131\":1}}],[\"其中hk​=wk​\",{\"1\":{\"98\":1}}],[\"其中args代表的是方法执行前得到的实参列表\",{\"1\":{\"1231\":1}}],[\"其中around方法为环绕方法\",{\"1\":{\"1220\":1}}],[\"其中all代表授予所有权限\",{\"1\":{\"774\":1}}],[\"其中ak∗​=argmaxa​qπk​​\",{\"1\":{\"79\":1}}],[\"其中ak∗​\",{\"1\":{\"63\":1}}],[\"其中a∗表示在该状态下计算出来的最大\",{\"1\":{\"57\":1}}],[\"其中vk​是给定的\",{\"1\":{\"63\":1}}],[\"其中f\",{\"1\":{\"58\":1}}],[\"其中cmax​表示用户的最大速度\",{\"1\":{\"14\":1}}],[\"其中\",{\"1\":{\"9\":1,\"10\":2,\"46\":1,\"66\":1,\"87\":1,\"96\":1,\"97\":1,\"101\":1,\"110\":1,\"112\":1,\"113\":1,\"116\":1,\"135\":1,\"141\":1,\"148\":1,\"153\":1,\"155\":1,\"199\":1,\"403\":1,\"734\":1,\"788\":1,\"876\":1,\"884\":1,\"985\":2,\"987\":1,\"1058\":1,\"1071\":1,\"1219\":1}}],[\"其中σ2=bkn​​n0​\",{\"1\":{\"9\":1}}],[\"其中k就是键的类型\",{\"1\":{\"213\":1}}],[\"其中k0​=\",{\"1\":{\"9\":1}}],[\"其中kn​表示划分到集群n的用户\",{\"1\":{\"8\":1}}],[\"其中θkn​​\",{\"1\":{\"9\":1}}],[\"其中用户表示为k=k1​\",{\"1\":{\"8\":1}}],[\"在了解完了spring的底层原理之后\",{\"1\":{\"1328\":1}}],[\"在单例模式下\",{\"1\":{\"1301\":1}}],[\"在正常情况下\",{\"1\":{\"1300\":1}}],[\"在父工厂中注册a\",{\"1\":{\"1298\":1}}],[\"在父类加载器没有找到所请求的类的情况下\",{\"1\":{\"1109\":1}}],[\"在调用此方法时\",{\"1\":{\"1277\":1}}],[\"在调用tolowercase方法时岂不是直接空指针异常了\",{\"1\":{\"454\":1}}],[\"在进行事务操作\",{\"1\":{\"1273\":1}}],[\"在进行反射操作时\",{\"1\":{\"350\":1}}],[\"在现实中的数据不应该被破坏\",{\"1\":{\"1266\":1}}],[\"在酷睿i7开启32个线程32个连接的情况下\",{\"1\":{\"1260\":1}}],[\"在mybatis\",{\"1\":{\"1254\":1}}],[\"在通过sqlsessionfactory调用opensession方法之后\",{\"1\":{\"1242\":1}}],[\"在通过经验来更新这个策略\",{\"1\":{\"122\":1}}],[\"在开始之前\",{\"1\":{\"1217\":1}}],[\"在开始介绍mybatis之前\",{\"1\":{\"817\":1}}],[\"在不修改原有代码的情况下\",{\"1\":{\"1218\":1}}],[\"在不修改源代码的情况下\",{\"1\":{\"1218\":1}}],[\"在不改变源代码的基础上进行了增强处理\",{\"1\":{\"1215\":1}}],[\"在不同的场景下合理使用\",{\"1\":{\"1181\":1}}],[\"在不同包下的类\",{\"1\":{\"277\":1}}],[\"在上面的代码中\",{\"1\":{\"1301\":1}}],[\"在上一次定时任务执行完之后\",{\"1\":{\"1190\":1}}],[\"在上述中有写到\",{\"1\":{\"363\":1}}],[\"在讲解到spring原理时\",{\"1\":{\"1168\":1}}],[\"在子工厂中注册b\",{\"1\":{\"1298\":1}}],[\"在子bean中必须也要存在\",{\"1\":{\"1149\":1}}],[\"在子类final\",{\"1\":{\"504\":1}}],[\"在以前\",{\"1\":{\"1132\":1}}],[\"在以往编写项目时\",{\"1\":{\"810\":1}}],[\"在resource中创建的文件\",{\"1\":{\"1119\":1}}],[\"在应用程序加载的时候\",{\"1\":{\"1105\":1}}],[\"在经过第一个过滤器之后\",{\"1\":{\"1103\":1}}],[\"在主页界面\",{\"1\":{\"1096\":1}}],[\"在主键列中\",{\"1\":{\"747\":1}}],[\"在网络上传输数据之前先将数据加密\",{\"1\":{\"1092\":1}}],[\"在本地\",{\"1\":{\"1091\":1}}],[\"在本文中\",{\"1\":{\"14\":1}}],[\"在本文中不考虑用户移动到其他集群的情况\",{\"1\":{\"14\":1}}],[\"在服务器端发送\",{\"1\":{\"1091\":1}}],[\"在请求转发后\",{\"1\":{\"1083\":1}}],[\"在登录界面\",{\"1\":{\"1096\":1}}],[\"在登录之后\",{\"1\":{\"658\":1}}],[\"在登陆成功的时候\",{\"1\":{\"1083\":1}}],[\"在点击按钮后\",{\"1\":{\"1069\":1}}],[\"在阅读了httpservlet源码之后\",{\"1\":{\"1059\":1}}],[\"在浏览器中访问\",{\"1\":{\"1047\":1}}],[\"在build父级项目时\",{\"1\":{\"1038\":1}}],[\"在之后的学习中\",{\"1\":{\"1237\":1}}],[\"在之后的springmvc学习中\",{\"1\":{\"1221\":1}}],[\"在之后编写springboot项目时可以解决一些缓存没更新的问题\",{\"1\":{\"1034\":1}}],[\"在之前的学习中\",{\"1\":{\"893\":1}}],[\"在之前的我们的项目是这样的\",{\"1\":{\"460\":1}}],[\"在之前jdbc讲解的时候\",{\"1\":{\"871\":1}}],[\"在之前我们一直都是采用这种先判断类型\",{\"1\":{\"499\":1}}],[\"在之前\",{\"1\":{\"475\":1,\"1137\":1,\"1242\":1}}],[\"在之前关于使用\",{\"1\":{\"105\":1}}],[\"在某些情况下\",{\"1\":{\"1025\":1,\"1223\":1}}],[\"在某种条件下会自动触发\",{\"1\":{\"781\":1}}],[\"在运行\",{\"1\":{\"1016\":1}}],[\"在运行时\",{\"1\":{\"1215\":1}}],[\"在运行时动态创建\",{\"1\":{\"392\":1}}],[\"在运行时同样会进行类型检查\",{\"1\":{\"237\":1}}],[\"在下次导入依赖时\",{\"1\":{\"1009\":1}}],[\"在下次读取时\",{\"1\":{\"260\":1}}],[\"在每个测试用例执行之前\",{\"1\":{\"985\":1}}],[\"在每一次迭代时\",{\"1\":{\"142\":1}}],[\"在几种情况下\",{\"1\":{\"980\":1}}],[\"在很多情况下\",{\"1\":{\"956\":1,\"1134\":1}}],[\"在多次处理相同sql时会尽可能转换为一次执行\",{\"1\":{\"871\":1}}],[\"在关闭自动提交后\",{\"1\":{\"865\":1}}],[\"在此方法返回之后\",{\"1\":{\"1247\":1}}],[\"在此标签内部填写需要进行一对一映射的对象属性\",{\"1\":{\"850\":1}}],[\"在此情况下\",{\"1\":{\"14\":1}}],[\"在根目录下重新创建一个mapper文件夹\",{\"1\":{\"826\":1}}],[\"在查询语句返回结果后\",{\"1\":{\"826\":1}}],[\"在最后\",{\"1\":{\"1181\":1}}],[\"在最后自动调用其close\",{\"1\":{\"812\":1}}],[\"在最上方还引入了一个叫做dtd\",{\"1\":{\"824\":1}}],[\"在项目根目录下新建名为mybatis\",{\"1\":{\"824\":1}}],[\"在前面jdbc的学习中\",{\"1\":{\"816\":1}}],[\"在前端页面中添加一个下载点\",{\"1\":{\"620\":1}}],[\"在刚启动时\",{\"1\":{\"789\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"782\":1}}],[\"在update操作时\",{\"1\":{\"781\":1}}],[\"在username之前添加一个感叹号表示请求的不允许携带此参数\",{\"1\":{\"574\":1}}],[\"在delete操作时\",{\"1\":{\"781\":1}}],[\"在dispatcherservlet完全处理完请求后被调用\",{\"1\":{\"595\":1}}],[\"在数据量变得非常庞大时\",{\"1\":{\"780\":1}}],[\"在数组的对象头中有一个\",{\"1\":{\"182\":1}}],[\"在默认情况下如果我们需要修改日志打印等级\",{\"1\":{\"928\":1}}],[\"在默认状态下\",{\"1\":{\"744\":1}}],[\"在默认配置下\",{\"1\":{\"660\":1}}],[\"在满足第二范式的情况下\",{\"1\":{\"738\":1}}],[\"在得到我们响应的数据后会立即关闭tcp连接\",{\"1\":{\"727\":1}}],[\"在得到field之后\",{\"1\":{\"350\":1}}],[\"在收到响应的数据后会立即关闭tcp连接\",{\"1\":{\"727\":1}}],[\"在收集到了足够多的\",{\"1\":{\"82\":1}}],[\"在artstudent\",{\"1\":{\"1149\":1}}],[\"在arrays数组工具类中\",{\"1\":{\"330\":1}}],[\"在afterpropertiesset方法中被调用\",{\"1\":{\"706\":1}}],[\"在后续的学习中\",{\"1\":{\"908\":1}}],[\"在后续各位小伙伴跟我们的实战项目时\",{\"1\":{\"660\":1}}],[\"在后面\",{\"1\":{\"888\":1}}],[\"在后面我们会学习mybatis框架\",{\"1\":{\"799\":1}}],[\"在后面我们会详细介绍preparedstatement的使用\",{\"1\":{\"790\":1}}],[\"在后面的springboot阶段\",{\"1\":{\"699\":1}}],[\"在启动时自动在数据库中创建存储记住我信息的表\",{\"1\":{\"687\":1}}],[\"在有了springsecurity之后\",{\"1\":{\"658\":1}}],[\"在他的博客中描述了一种称为\",{\"1\":{\"643\":1}}],[\"在1997年\",{\"1\":{\"643\":1}}],[\"在外部无法干涉的情况下\",{\"1\":{\"643\":1}}],[\"在外面花钱请别人帮你写公司的业务\",{\"1\":{\"224\":1}}],[\"在handlermapping集合中寻找可以处理当前请求的handlermapping\",{\"1\":{\"626\":1}}],[\"在容器中查找所有的handleradapter\",{\"1\":{\"625\":1}}],[\"在容器中查找所有的handlermapping\",{\"1\":{\"625\":1}}],[\"在等待响应的同时\",{\"1\":{\"617\":1}}],[\"在传统的同步请求中\",{\"1\":{\"617\":1}}],[\"在处理之前\",{\"1\":{\"600\":1}}],[\"在整个流程结束后还执行了一次aftercompletion方法\",{\"1\":{\"597\":1}}],[\"在springboot阶段\",{\"1\":{\"1260\":1}}],[\"在springboot\",{\"1\":{\"1260\":1}}],[\"在spring\",{\"1\":{\"1219\":1}}],[\"在spring中提供了一些以aware结尾的接口\",{\"1\":{\"1186\":1}}],[\"在springmvc中\",{\"1\":{\"588\":1}}],[\"在servlet处理完成之后\",{\"1\":{\"1103\":1}}],[\"在select\",{\"1\":{\"781\":1}}],[\"在sleep代码中可以发现\",{\"1\":{\"300\":1}}],[\"在学习spring时我们讲解了bean的作用域\",{\"1\":{\"588\":1}}],[\"在代码编译或者运行时可以通过一些手段找到对应标记的东西\",{\"1\":{\"534\":1}}],[\"在构建器中\",{\"1\":{\"525\":5}}],[\"在构造时自动启动\",{\"1\":{\"324\":1}}],[\"在比较完成的屁股后面\",{\"1\":{\"499\":1}}],[\"在低版本这样写是会直接报错的\",{\"1\":{\"480\":1}}],[\"在模块module\",{\"1\":{\"465\":1}}],[\"在程序运行之后\",{\"1\":{\"462\":1}}],[\"在创建sqlsession的时候不填写参数默认使用的就是事务模式\",{\"1\":{\"865\":1}}],[\"在创建表之前\",{\"1\":{\"750\":1}}],[\"在创建thread时\",{\"1\":{\"445\":1}}],[\"在创建了对象之后\",{\"1\":{\"161\":1}}],[\"在编写sql时\",{\"1\":{\"873\":1}}],[\"在编写代码的时候就能明确泛型的类型\",{\"1\":{\"438\":1}}],[\"在编译阶段就需要进行处理\",{\"1\":{\"421\":1}}],[\"在编译阶段无法感知代码是否会出现问题\",{\"1\":{\"421\":1}}],[\"在new的时候\",{\"1\":{\"412\":1}}],[\"在内部类中使用this关键字\",{\"1\":{\"408\":1}}],[\"在成员内部类中\",{\"1\":{\"408\":1}}],[\"在成员变量初始化之后执行\",{\"1\":{\"166\":1}}],[\"在chrome浏览器中\",{\"1\":{\"641\":1}}],[\"在class关键字前添加sealed关键字\",{\"1\":{\"503\":1}}],[\"在c中就是一个字符数组\",{\"1\":{\"400\":1}}],[\"在collection接口中重复定义了一次\",{\"1\":{\"193\":1}}],[\"在修改后\",{\"1\":{\"373\":1}}],[\"在修改访问权限之后\",{\"1\":{\"348\":1}}],[\"在回收之前\",{\"1\":{\"372\":1}}],[\"在接触到spring和springboot等大型框架后\",{\"1\":{\"365\":1}}],[\"在类加载时就进行创建\",{\"1\":{\"830\":1}}],[\"在类加载过程的同时\",{\"1\":{\"338\":1}}],[\"在类\",{\"1\":{\"355\":1}}],[\"在没有了解别人代码的整个过程就强行越权访问\",{\"1\":{\"349\":1}}],[\"在一个客户程序主窗口上显示出的万维网文档称为页面\",{\"1\":{\"1042\":1}}],[\"在一个项目内部在创建一个项目就行\",{\"1\":{\"1032\":1}}],[\"在一个对象从构造到方法调用\",{\"1\":{\"349\":1}}],[\"在一些社交网站上\",{\"1\":{\"643\":1}}],[\"在一些jdk内部的源码中\",{\"1\":{\"290\":1}}],[\"在一开始的时候\",{\"1\":{\"641\":1}}],[\"在这个方法结束之后\",{\"1\":{\"1320\":1}}],[\"在这种情况下\",{\"1\":{\"343\":1,\"980\":1}}],[\"在这里注册bean定义其实和之前那种方法效果一样\",{\"1\":{\"1311\":1}}],[\"在这里的定义就比非池化的实现复杂得多了\",{\"1\":{\"1245\":1}}],[\"在这里直接继承的httpservlet\",{\"1\":{\"625\":1}}],[\"在这里\",{\"1\":{\"87\":1}}],[\"在加载过程中\",{\"1\":{\"337\":1}}],[\"在集合跟接口collection中提供了一个spliterator\",{\"1\":{\"330\":1}}],[\"在守护线程中产生的新线程也是守护的\",{\"1\":{\"329\":1}}],[\"在指定时间内\",{\"1\":{\"318\":1}}],[\"在指定位置上插入元素\",{\"1\":{\"181\":1}}],[\"在使用时\",{\"1\":{\"1188\":1}}],[\"在使用时同样需要跟上<>并在其中填写明确要使用的类型\",{\"1\":{\"438\":1}}],[\"在使用package命令打包之前也会自动执行一次test命令\",{\"1\":{\"1036\":1}}],[\"在使用opensession时直接配置executortype为batch即可\",{\"1\":{\"871\":1}}],[\"在使用之前\",{\"1\":{\"804\":1}}],[\"在使用instanceof判断类型成立后\",{\"1\":{\"499\":1}}],[\"在使用完成一个流之后\",{\"1\":{\"247\":1}}],[\"在使线程暂停的同时\",{\"1\":{\"313\":1}}],[\"在执行之前判断判断权限\",{\"1\":{\"696\":1}}],[\"在执行完毕后会自动释放这把锁\",{\"1\":{\"312\":1}}],[\"在执行一个动作后获得的一个常数\",{\"1\":{\"19\":1}}],[\"在写回主内存时就会发生冲突\",{\"1\":{\"311\":1}}],[\"在继续当前内容\",{\"1\":{\"305\":1}}],[\"在i==10时\",{\"1\":{\"305\":1}}],[\"在让位之后\",{\"1\":{\"304\":1}}],[\"在junit5中\",{\"1\":{\"1017\":1}}],[\"在jdk9之后\",{\"1\":{\"348\":1}}],[\"在jdk11版本以后\",{\"1\":{\"1175\":1}}],[\"在jdk1\",{\"1\":{\"247\":1}}],[\"在javase阶段使用过timertask来执行定时任务\",{\"1\":{\"1190\":1}}],[\"在javase中我们就给大家介绍过\",{\"1\":{\"1036\":1}}],[\"在java\",{\"1\":{\"445\":1,\"446\":1,\"474\":1,\"476\":1,\"480\":4,\"486\":1,\"487\":1,\"488\":1,\"489\":1,\"495\":1,\"499\":1,\"501\":1,\"503\":1}}],[\"在java程序启动时\",{\"1\":{\"337\":1}}],[\"在java中\",{\"1\":{\"295\":1,\"485\":1,\"503\":1}}],[\"在早期的计算机中\",{\"1\":{\"295\":1}}],[\"在序列化时\",{\"1\":{\"289\":1}}],[\"在我们之后的学习中\",{\"1\":{\"1259\":1}}],[\"在我们之前的图书管理系统web应用程序中\",{\"1\":{\"1116\":1}}],[\"在我们后续的springboot学习阶段\",{\"1\":{\"1257\":1}}],[\"在我们后续的操作中\",{\"1\":{\"289\":1}}],[\"在我们旧版本的ssm教程中讲解了\",{\"1\":{\"1175\":1}}],[\"在我们学习到springboot或是springcloud开发时\",{\"1\":{\"1032\":1}}],[\"在我们项目的维护过程中\",{\"1\":{\"956\":1}}],[\"在我们自己定义一个构造方法之后\",{\"1\":{\"166\":1}}],[\"在当前包以外的其他包中无法访问\",{\"1\":{\"278\":1}}],[\"在当前状态s下\",{\"1\":{\"48\":1}}],[\"在当前状态s下采取动作\",{\"1\":{\"48\":1}}],[\"在放入包中\",{\"1\":{\"277\":1}}],[\"在静态方法中\",{\"1\":{\"274\":1}}],[\"在重写\",{\"1\":{\"241\":1}}],[\"在插入键值对时\",{\"1\":{\"218\":1}}],[\"在红黑树中插入新的结点\",{\"1\":{\"216\":1}}],[\"在实体类中\",{\"1\":{\"525\":1}}],[\"在实现接口或是继承父类时\",{\"1\":{\"439\":1}}],[\"在实现\",{\"1\":{\"205\":1}}],[\"在实际开发场景中\",{\"1\":{\"676\":1}}],[\"在实际开发中\",{\"1\":{\"501\":1}}],[\"在实际运行时\",{\"1\":{\"237\":1}}],[\"在实际情况中\",{\"1\":{\"27\":1}}],[\"在实际应用中\",{\"1\":{\"9\":1}}],[\"在队尾进行移除操作\",{\"1\":{\"201\":1}}],[\"在队尾进行插入操作\",{\"1\":{\"201\":1}}],[\"在队首进行移除操作\",{\"1\":{\"201\":1}}],[\"在队首进行插入操作\",{\"1\":{\"201\":1}}],[\"在双端队列中\",{\"1\":{\"201\":1}}],[\"在遍历过程中\",{\"1\":{\"194\":1}}],[\"在什么使用使用arraylist和linkedlist\",{\"1\":{\"182\":1}}],[\"在list接口中\",{\"1\":{\"181\":1}}],[\"在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法\",{\"1\":{\"171\":1}}],[\"在赋值之前看看是否有初始值\",{\"1\":{\"166\":1}}],[\"在状态s采用动作a\",{\"1\":{\"153\":1}}],[\"在该策略下的所有\",{\"1\":{\"148\":1}}],[\"在该文中考虑的是网页浏览应用传输情况\",{\"1\":{\"10\":1}}],[\"在该文中\",{\"1\":{\"10\":1}}],[\"在原文是\",{\"1\":{\"144\":1}}],[\"在训练求解梯度时\",{\"1\":{\"142\":1}}],[\"在初始创建bean对象时都会生成一个对应的单例工厂用于获取早期对象\",{\"1\":{\"1301\":1}}],[\"在初始化时会调用一次\",{\"1\":{\"217\":1}}],[\"在初始化的时候是设为相同的\",{\"1\":{\"142\":1}}],[\"在初始时间假设用户处于静止下不断调整\",{\"1\":{\"5\":1}}],[\"在将\",{\"1\":{\"142\":1}}],[\"在计算机网络\",{\"1\":{\"1042\":1}}],[\"在计算\",{\"1\":{\"142\":1}}],[\"在求解\",{\"1\":{\"71\":1}}],[\"在策略更新上\",{\"1\":{\"70\":1}}],[\"在策略梯度算法中引入一个\",{\"1\":{\"26\":1}}],[\"在\",{\"1\":{\"25\":1,\"68\":2,\"86\":1,\"138\":1,\"142\":1,\"182\":2,\"192\":1,\"205\":1,\"213\":1,\"374\":1,\"412\":1,\"423\":1,\"547\":1,\"553\":2,\"709\":1,\"1056\":1,\"1059\":2,\"1071\":2,\"1072\":1,\"1103\":1,\"1181\":1}}],[\"在policy是确定的情况下\",{\"1\":{\"20\":1}}],[\"在设计无人机的移动之前\",{\"1\":{\"14\":1}}],[\"在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为\",{\"1\":{\"9\":1}}],[\"在时间t\",{\"1\":{\"9\":1}}],[\"在任意时刻t\",{\"1\":{\"8\":1}}],[\"25<\",{\"1\":{\"1260\":2}}],[\"255\",{\"1\":{\"747\":1}}],[\"25565\",{\"1\":{\"721\":2}}],[\"24\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"24d46ca6\",{\"1\":{\"927\":1}}],[\"28\",{\"1\":{\"919\":1,\"929\":2}}],[\"2nf\",{\"0\":{\"737\":1}}],[\"2nf对主属性和其他属性的依赖关系产生约束\",{\"1\":{\"735\":1}}],[\"2<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"2版本\",{\"1\":{\"611\":1}}],[\"2提供的新注解\",{\"1\":{\"602\":1}}],[\"22<\",{\"1\":{\"1033\":1}}],[\"223\",{\"1\":{\"746\":2}}],[\"22\",{\"1\":{\"528\":1}}],[\"215\",{\"1\":{\"1283\":1}}],[\"2109规范\",{\"1\":{\"1092\":1}}],[\"2147483647\",{\"1\":{\"746\":1}}],[\"2147483648\",{\"1\":{\"746\":1}}],[\"21\",{\"1\":{\"528\":1,\"1260\":3}}],[\"29327\",{\"1\":{\"490\":1}}],[\"23\",{\"1\":{\"475\":1}}],[\"27<\",{\"1\":{\"1017\":1,\"1033\":1,\"1071\":1}}],[\"27\",{\"1\":{\"376\":1}}],[\"2打印\",{\"1\":{\"304\":1,\"305\":1}}],[\"2种方法\",{\"1\":{\"49\":1}}],[\"20秒内访问都会携带此cookie\",{\"1\":{\"1092\":1}}],[\"2001\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"200\",{\"1\":{\"523\":2,\"727\":2,\"1076\":1}}],[\"20000\",{\"1\":{\"1245\":2}}],[\"2000\",{\"1\":{\"319\":1,\"1190\":1}}],[\"20\",{\"1\":{\"299\":1,\"350\":1,\"413\":1,\"415\":2,\"431\":1,\"475\":1,\"478\":3,\"479\":2,\"528\":1,\"841\":1,\"900\":1,\"972\":2,\"1092\":1}}],[\"2022\",{\"1\":{\"1278\":1}}],[\"20221125164854022\",{\"1\":{\"1199\":1}}],[\"2025\",{\"1\":{\"1091\":1,\"1096\":1,\"1181\":1,\"1260\":3}}],[\"20250319235934\",{\"1\":{\"719\":1}}],[\"20250312005934\",{\"1\":{\"355\":1}}],[\"20250312002044\",{\"1\":{\"349\":1}}],[\"20250310170551\",{\"1\":{\"343\":1}}],[\"20250310170039\",{\"1\":{\"343\":1}}],[\"20250310165216\",{\"1\":{\"343\":1}}],[\"20250310160214\",{\"1\":{\"337\":1}}],[\"20250309155822\",{\"1\":{\"319\":1}}],[\"20250226231025\",{\"1\":{\"313\":1}}],[\"20250226223324\",{\"1\":{\"311\":1}}],[\"20250226175843\",{\"1\":{\"297\":1,\"300\":1}}],[\"20250226173747\",{\"1\":{\"295\":1}}],[\"20250225192918\",{\"1\":{\"284\":1}}],[\"20250225181159\",{\"1\":{\"260\":1}}],[\"2021\",{\"1\":{\"908\":1}}],[\"20230306164008613\",{\"1\":{\"1042\":1}}],[\"20230306163528771\",{\"1\":{\"816\":1,\"818\":1}}],[\"20230703182321093\",{\"1\":{\"692\":1}}],[\"20230704223503682\",{\"1\":{\"692\":1}}],[\"20230704223248124\",{\"1\":{\"692\":1}}],[\"20230704222733082\",{\"1\":{\"692\":1}}],[\"20230704220701000\",{\"1\":{\"687\":1}}],[\"20230702183040922\",{\"1\":{\"660\":1}}],[\"2024\",{\"1\":{\"852\":2,\"919\":1,\"929\":2}}],[\"20241029001425\",{\"1\":{\"421\":1}}],[\"20241027015718\",{\"1\":{\"411\":1}}],[\"20241027015244\",{\"1\":{\"411\":1}}],[\"20241027012950\",{\"1\":{\"408\":1}}],[\"20241017002218\",{\"1\":{\"384\":1}}],[\"20241130012855\",{\"1\":{\"241\":1}}],[\"20241130005736\",{\"1\":{\"237\":1}}],[\"20241130004116\",{\"1\":{\"228\":1}}],[\"20241130001811\",{\"1\":{\"217\":1}}],[\"20241130000528\",{\"1\":{\"215\":1}}],[\"20241127001435\",{\"1\":{\"200\":1}}],[\"20241126232128\",{\"1\":{\"188\":1}}],[\"20241126232114\",{\"1\":{\"188\":1}}],[\"20241120130452\",{\"1\":{\"180\":1,\"193\":1}}],[\"20241106133211\",{\"1\":{\"172\":1}}],[\"20241106133159\",{\"1\":{\"172\":1}}],[\"20241106133117\",{\"1\":{\"172\":1}}],[\"20240826181712\",{\"1\":{\"157\":1}}],[\"20240826181638\",{\"1\":{\"156\":1}}],[\"20240826181538\",{\"1\":{\"156\":1}}],[\"20240826181340\",{\"1\":{\"156\":1}}],[\"20240826180244\",{\"1\":{\"155\":1}}],[\"20240826173749\",{\"1\":{\"151\":1}}],[\"20240820231205\",{\"1\":{\"144\":1}}],[\"20240820231024\",{\"1\":{\"144\":1}}],[\"20240820230944\",{\"1\":{\"143\":1}}],[\"20240820230920\",{\"1\":{\"143\":1}}],[\"20240820230827\",{\"1\":{\"143\":1}}],[\"20240820184405\",{\"1\":{\"140\":1}}],[\"20240820184127\",{\"1\":{\"139\":1}}],[\"20240820181718\",{\"1\":{\"135\":1}}],[\"20240820181406\",{\"1\":{\"135\":1}}],[\"20240815234719\",{\"1\":{\"277\":1}}],[\"20240818182231\",{\"1\":{\"127\":1}}],[\"20240818182301\",{\"1\":{\"127\":1}}],[\"20240818182057\",{\"1\":{\"125\":1}}],[\"20240818181917\",{\"1\":{\"126\":1}}],[\"20240817000409\",{\"1\":{\"118\":1}}],[\"20240817000331\",{\"1\":{\"118\":1}}],[\"20240817000642\",{\"1\":{\"117\":1}}],[\"20240817000601\",{\"1\":{\"117\":1}}],[\"20240817000500\",{\"1\":{\"117\":1}}],[\"20240817000230\",{\"1\":{\"116\":1}}],[\"20240817000134\",{\"1\":{\"116\":1}}],[\"20240817000114\",{\"1\":{\"116\":1}}],[\"20240814230747\",{\"1\":{\"106\":1}}],[\"20240814014058\",{\"1\":{\"103\":1}}],[\"20240812010538\",{\"1\":{\"89\":1}}],[\"20240812011140\",{\"1\":{\"88\":1}}],[\"20240812004534\",{\"1\":{\"83\":1}}],[\"20240811233346\",{\"1\":{\"79\":1}}],[\"20240811011334\",{\"1\":{\"72\":1}}],[\"20240811010933\",{\"1\":{\"71\":1}}],[\"20240811002219\",{\"1\":{\"67\":1}}],[\"20240810190018\",{\"1\":{\"64\":1}}],[\"20240830200624\",{\"1\":{\"33\":1}}],[\"20240830200608\",{\"1\":{\"33\":1}}],[\"20240830200406\",{\"1\":{\"32\":1}}],[\"20240830200343\",{\"1\":{\"31\":1}}],[\"20240830200320\",{\"1\":{\"31\":1}}],[\"20240830200305\",{\"1\":{\"31\":1}}],[\"20240830200248\",{\"1\":{\"31\":1}}],[\"20240830200138\",{\"1\":{\"30\":1}}],[\"20240830200118\",{\"1\":{\"30\":1}}],[\"20240830200056\",{\"1\":{\"30\":1}}],[\"20240830185629\",{\"1\":{\"28\":1}}],[\"20240830185556\",{\"1\":{\"28\":1}}],[\"20240830185537\",{\"1\":{\"28\":1}}],[\"20240830185324\",{\"1\":{\"27\":1}}],[\"20240830185127\",{\"1\":{\"26\":1}}],[\"20240830184424\",{\"1\":{\"24\":1}}],[\"20240830184330\",{\"1\":{\"24\":1}}],[\"20240830184312\",{\"1\":{\"23\":1}}],[\"20240830184236\",{\"1\":{\"23\":1}}],[\"2019\",{\"1\":{\"3\":1}}],[\"2l−1\",{\"1\":{\"10\":1}}],[\"2mssfs​+1\",{\"1\":{\"10\":1}}],[\"2mss\",{\"1\":{\"10\":1}}],[\"2~3\",{\"1\":{\"10\":1}}],[\"2​\",{\"1\":{\"8\":1}}],[\"2+\",{\"1\":{\"8\":1}}],[\"2\",{\"0\":{\"20\":1,\"25\":1,\"26\":1,\"27\":2,\"28\":1,\"31\":1,\"40\":1,\"42\":1,\"43\":1,\"44\":2,\"45\":1,\"46\":1,\"54\":1,\"55\":1,\"56\":2,\"57\":2,\"58\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":2,\"68\":1,\"71\":1,\"78\":1,\"80\":1,\"81\":1,\"82\":2,\"83\":1,\"84\":1,\"87\":1,\"95\":1,\"96\":1,\"97\":2,\"98\":1,\"99\":1,\"102\":1,\"111\":1,\"112\":1,\"113\":2,\"114\":1,\"117\":1,\"121\":1,\"132\":1,\"133\":1,\"136\":2,\"149\":1,\"150\":1,\"153\":2,\"169\":1,\"170\":1,\"185\":1,\"186\":1,\"265\":1,\"390\":1,\"471\":1,\"743\":1,\"1123\":1,\"1277\":1,\"1345\":1,\"1354\":1},\"1\":{\"8\":1,\"9\":1,\"13\":1,\"14\":1,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"70\":1,\"79\":2,\"94\":1,\"97\":1,\"101\":1,\"112\":1,\"116\":1,\"133\":1,\"134\":2,\"135\":2,\"136\":2,\"141\":1,\"142\":2,\"171\":3,\"207\":2,\"214\":2,\"221\":2,\"228\":4,\"234\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":1,\"248\":1,\"269\":1,\"330\":2,\"396\":2,\"397\":2,\"402\":1,\"403\":2,\"431\":1,\"432\":1,\"449\":2,\"451\":2,\"452\":1,\"488\":1,\"521\":1,\"528\":1,\"601\":1,\"610\":2,\"617\":2,\"636\":1,\"641\":1,\"642\":1,\"748\":1,\"788\":1,\"799\":1,\"805\":1,\"874\":1,\"876\":2,\"963\":1,\"988\":4,\"1017\":2,\"1025\":1,\"1119\":1,\"1150\":1,\"1207\":1,\"1208\":2,\"1317\":1}}],[\"即只有别的事务调用该方法\",{\"1\":{\"1282\":1}}],[\"即利用对应数据库的驱动生成的connection对象完成对事务的提交\",{\"1\":{\"1272\":1}}],[\"即这种表达式如果只是简单字符串\",{\"1\":{\"1205\":1}}],[\"即对应的类或者其子类\",{\"1\":{\"1138\":1}}],[\"即对于\",{\"1\":{\"192\":1}}],[\"即对于损失函数中的\",{\"1\":{\"133\":1}}],[\"即对于数据\",{\"1\":{\"80\":1}}],[\"即对于每个状态\",{\"1\":{\"79\":1}}],[\"即对于给定策略\",{\"1\":{\"47\":1}}],[\"即根据所给的接口确定类\",{\"1\":{\"1117\":1}}],[\"即每当一个类加载器接收到加载请求时\",{\"1\":{\"1109\":1}}],[\"即经过了一个rtt时间后\",{\"1\":{\"1042\":1}}],[\"即继承的子logger不能直接修改父logger的handler\",{\"1\":{\"928\":1}}],[\"即我们在java中所传给他的值\",{\"1\":{\"876\":1}}],[\"即我通过一个策略与环境进行交互生成一系列经验\",{\"1\":{\"123\":1}}],[\"即我通过这个策略与环境进行交互生成一系列经验\",{\"1\":{\"122\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"782\":1}}],[\"即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值\",{\"1\":{\"747\":1}}],[\"即存在关键字段决定关键字段的情况\",{\"1\":{\"739\":1}}],[\"即用参数1调用方法\",{\"1\":{\"452\":1}}],[\"即之后不能修改\",{\"1\":{\"413\":1}}],[\"即通过\",{\"1\":{\"265\":1,\"349\":1}}],[\"即使关机重启\",{\"1\":{\"1266\":1}}],[\"即使bean没有配置某项属性\",{\"1\":{\"1152\":1}}],[\"即使你contest\",{\"1\":{\"1148\":1}}],[\"即使我们的底层实现类发生了修改\",{\"1\":{\"1117\":1}}],[\"即使我们什么都不编写\",{\"1\":{\"1054\":1}}],[\"即使我们重启服务器也不会导致数据丢失\",{\"1\":{\"687\":1}}],[\"即使用指定的枚举常量进行测试\",{\"1\":{\"993\":1}}],[\"即使用初始化块\",{\"1\":{\"412\":1}}],[\"即使会话2已经修改了数据\",{\"1\":{\"883\":1}}],[\"即使这里不指定具体类型\",{\"1\":{\"861\":1}}],[\"即使这样\",{\"1\":{\"531\":1}}],[\"即使不添加\",{\"1\":{\"579\":1}}],[\"即使模块不同\",{\"1\":{\"461\":1}}],[\"即使是基本类型的数组\",{\"1\":{\"392\":1}}],[\"即使是最大的long类型\",{\"1\":{\"386\":1}}],[\"即使是两个不同的对象\",{\"1\":{\"373\":1}}],[\"即使强制类型转换\",{\"1\":{\"373\":1}}],[\"即使类名相同\",{\"1\":{\"277\":1}}],[\"即使值不同\",{\"1\":{\"214\":1}}],[\"即使先估计了\",{\"1\":{\"79\":1}}],[\"即空指针异常\",{\"1\":{\"161\":1}}],[\"即在运行状态中\",{\"1\":{\"336\":1}}],[\"即在策略\",{\"1\":{\"152\":1}}],[\"即在状态s1​下采用动作a1​获得的奖励r=1的概率\",{\"1\":{\"19\":1}}],[\"即此时策略\",{\"1\":{\"148\":1}}],[\"即此时的discounted\",{\"1\":{\"19\":1}}],[\"即基于一个策略\",{\"1\":{\"135\":1}}],[\"即各个状态的可能性为∣s∣1​\",{\"1\":{\"134\":1}}],[\"即函数\",{\"1\":{\"97\":1}}],[\"即不需要使用\",{\"1\":{\"788\":1}}],[\"即不需要完全精确地求出\",{\"1\":{\"82\":1}}],[\"即不具备terminal\",{\"1\":{\"19\":1}}],[\"即p\",{\"1\":{\"75\":1}}],[\"即j→∞\",{\"1\":{\"66\":1}}],[\"即求解右边的式子\",{\"1\":{\"63\":1}}],[\"即f\",{\"1\":{\"58\":1}}],[\"即a∗=argmaxa​q\",{\"1\":{\"57\":1}}],[\"即可表示此方法执行的是一个事务操作\",{\"1\":{\"1277\":1}}],[\"即可直接通过该接口执行我们的sql语句\",{\"1\":{\"893\":1}}],[\"即可在配置中直接解析其属性到insert语句中\",{\"1\":{\"861\":1}}],[\"即可开启记住我功能\",{\"1\":{\"686\":1}}],[\"即可完成替换\",{\"1\":{\"545\":1}}],[\"即可创建对应的对象实例\",{\"1\":{\"348\":1}}],[\"即可以进行套娃\",{\"1\":{\"266\":1}}],[\"即可以通过梯度下降\",{\"1\":{\"142\":1}}],[\"即可\",{\"1\":{\"57\":1,\"77\":1,\"162\":1,\"313\":1,\"461\":1,\"668\":1}}],[\"即vπ​\",{\"1\":{\"49\":1}}],[\"即一个trajectory下的discounted\",{\"1\":{\"39\":1}}],[\"即\",{\"1\":{\"26\":1,\"63\":2,\"66\":2,\"68\":1,\"77\":1,\"78\":2,\"94\":1,\"99\":1,\"137\":1,\"161\":1,\"375\":1,\"376\":1,\"395\":1,\"446\":1,\"452\":1,\"461\":1,\"884\":1,\"1103\":1}}],[\"即无记忆的特性\",{\"1\":{\"20\":1}}],[\"即无人机作为空中基站\",{\"1\":{\"8\":1}}],[\"即表示具有终止状态terminal\",{\"1\":{\"19\":1}}],[\"即状态s1​采用动作a1​转到状态s2​的概率\",{\"1\":{\"19\":1}}],[\"即ξ=\",{\"1\":{\"14\":1}}],[\"即xuav​\",{\"1\":{\"13\":1}}],[\"即γ≥γkn​​\",{\"1\":{\"9\":1}}],[\"即需要考虑地面不同用户的具体需求\",{\"1\":{\"4\":1}}],[\"lstrings\",{\"1\":{\"1059\":2}}],[\"lru\",{\"1\":{\"884\":1}}],[\"lt\",{\"1\":{\"836\":1,\"874\":1}}],[\"lbwconfiguration\",{\"1\":{\"1168\":1}}],[\"lbw\",{\"1\":{\"290\":1}}],[\"lbwnb\",{\"1\":{\"249\":2,\"283\":1,\"320\":1,\"399\":1,\"415\":2,\"438\":1,\"571\":1,\"585\":1,\"699\":3,\"1086\":1,\"1231\":1,\"1236\":1,\"1296\":3,\"1311\":2}}],[\"lb\",{\"1\":{\"250\":1}}],[\"least\",{\"1\":{\"1319\":1}}],[\"leading\",{\"1\":{\"1181\":1}}],[\"learning是优化长期目标\",{\"1\":{\"13\":1}}],[\"learning的部署算法不同的是\",{\"1\":{\"14\":1}}],[\"learning的移动算法\",{\"1\":{\"14\":1}}],[\"learning的优化目标是最大化长期收益\",{\"1\":{\"13\":1}}],[\"learning的方案来解决无人机的np\",{\"1\":{\"5\":1}}],[\"learning算法\",{\"1\":{\"13\":1}}],[\"learning\",{\"0\":{\"3\":1,\"109\":1,\"111\":1,\"115\":1,\"119\":1,\"120\":1,\"124\":1,\"137\":1,\"138\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"119\":1,\"120\":1,\"123\":1,\"124\":1,\"141\":1}}],[\"level=all\",{\"1\":{\"939\":2,\"951\":2}}],[\"level\",{\"1\":{\"910\":15,\"911\":4,\"912\":6,\"928\":2,\"939\":4,\"1242\":2,\"1273\":2}}],[\"left\",{\"1\":{\"769\":1,\"850\":1,\"853\":1,\"855\":2}}],[\"lets\",{\"1\":{\"1181\":1}}],[\"let\",{\"1\":{\"610\":1,\"1047\":1,\"1076\":1}}],[\"length方法可以求字符串长度\",{\"1\":{\"401\":1}}],[\"length属性是int类型的值\",{\"1\":{\"393\":1}}],[\"length\",{\"1\":{\"182\":1,\"216\":2,\"217\":1,\"228\":1,\"255\":1,\"356\":1,\"393\":2,\"394\":1,\"401\":2,\"490\":1,\"497\":1,\"500\":4,\"519\":2,\"522\":3,\"799\":2,\"991\":1,\"1091\":1,\"1096\":1,\"1203\":2}}],[\"length字段\",{\"1\":{\"182\":2}}],[\"lnπ\",{\"1\":{\"155\":1}}],[\"lock\",{\"1\":{\"1245\":2,\"1246\":2}}],[\"location\",{\"1\":{\"642\":1,\"748\":3,\"1082\":2,\"1091\":1,\"1096\":1}}],[\"localbadconnectioncount\",{\"1\":{\"1246\":2}}],[\"localecontextholder\",{\"1\":{\"626\":1}}],[\"localecontext\",{\"1\":{\"626\":4}}],[\"localhost\",{\"1\":{\"589\":5,\"641\":1,\"642\":1,\"658\":1,\"664\":1,\"719\":1,\"720\":1,\"721\":1,\"726\":1,\"727\":1,\"788\":1,\"796\":1,\"904\":1,\"936\":1,\"1017\":1,\"1047\":5,\"1091\":2,\"1093\":1,\"1096\":2,\"1255\":1,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"local\",{\"1\":{\"319\":4,\"320\":4}}],[\"lot\",{\"1\":{\"1181\":1}}],[\"logfactory\",{\"1\":{\"1245\":1,\"1273\":1}}],[\"logs目录\",{\"1\":{\"1047\":1}}],[\"log4j12<\",{\"1\":{\"1025\":1}}],[\"log4j2\",{\"1\":{\"951\":1}}],[\"log4j\",{\"1\":{\"951\":1}}],[\"log注解即可\",{\"1\":{\"950\":1}}],[\"logrecord\",{\"1\":{\"944\":2,\"948\":1}}],[\"logmanager\",{\"1\":{\"939\":4}}],[\"logmanager$rootlogger\",{\"1\":{\"927\":1}}],[\"logmessage\",{\"1\":{\"708\":4,\"710\":2,\"712\":1}}],[\"log这种格式\",{\"1\":{\"918\":1}}],[\"logimpl包括很多种配置项\",{\"1\":{\"951\":1}}],[\"logimpl\",{\"1\":{\"852\":1,\"951\":2,\"1017\":1}}],[\"login进行登陆\",{\"1\":{\"1093\":1}}],[\"loginservlet\",{\"1\":{\"1069\":1,\"1072\":1}}],[\"loginsuccess\",{\"1\":{\"712\":1}}],[\"loginfail\",{\"1\":{\"713\":1}}],[\"login接口\",{\"1\":{\"691\":1}}],[\"loginprocessingurl\",{\"1\":{\"680\":1}}],[\"loginpage\",{\"1\":{\"680\":1}}],[\"login\",{\"1\":{\"617\":3,\"636\":8,\"679\":3,\"680\":2,\"682\":1,\"683\":1,\"691\":3,\"773\":1,\"1069\":3,\"1072\":1,\"1085\":1,\"1096\":2,\"1104\":2}}],[\"logoutfilter\",{\"1\":{\"714\":1}}],[\"logout接口\",{\"1\":{\"691\":1}}],[\"logoutsuccessurl\",{\"1\":{\"683\":1}}],[\"logouturl\",{\"1\":{\"683\":1}}],[\"logout\",{\"1\":{\"658\":1,\"683\":2,\"691\":3}}],[\"logger也是可以使用lombok快速生成的\",{\"1\":{\"950\":1}}],[\"logger4\",{\"1\":{\"930\":2}}],[\"logger3\",{\"1\":{\"930\":2}}],[\"logger2\",{\"1\":{\"930\":4}}],[\"logger1\",{\"1\":{\"930\":2}}],[\"logger类还为我们提供了两个比较特殊的日志级别\",{\"1\":{\"912\":1}}],[\"logger默认情况下只会打印info级别以上的日志\",{\"1\":{\"911\":1}}],[\"logger\",{\"1\":{\"625\":4,\"708\":8,\"710\":4,\"711\":1,\"712\":2,\"713\":3,\"908\":4,\"910\":10,\"911\":7,\"912\":2,\"918\":5,\"919\":2,\"920\":1,\"927\":9,\"928\":2,\"929\":2,\"930\":8,\"939\":4,\"946\":4,\"1260\":3,\"1300\":3,\"1327\":1}}],[\"logging表示使用jul进行日志打印\",{\"1\":{\"951\":1}}],[\"logging表示直接使用标准输出将日志信息打印到控制台\",{\"1\":{\"951\":1}}],[\"logging包下\",{\"1\":{\"908\":1}}],[\"logging相关模块后\",{\"1\":{\"461\":1}}],[\"logging\",{\"1\":{\"461\":1,\"465\":2,\"468\":1,\"852\":1,\"927\":1,\"939\":2,\"947\":1,\"951\":8,\"1017\":1,\"1047\":1}}],[\"loggin\",{\"1\":{\"461\":1}}],[\"log\",{\"1\":{\"468\":3,\"625\":1,\"911\":4,\"920\":1,\"921\":1,\"950\":4,\"1032\":3,\"1059\":1,\"1064\":2,\"1245\":2,\"1246\":15,\"1247\":6,\"1260\":5,\"1273\":4,\"1278\":1,\"1328\":1}}],[\"lombok肯定也是支持这个日志框架快速注解的\",{\"1\":{\"1260\":1}}],[\"lombok依赖\",{\"1\":{\"1008\":1}}],[\"lombok1\",{\"0\":{\"809\":1,\"810\":1}}],[\"lombok可以说是简化代码的神器了\",{\"1\":{\"501\":1}}],[\"lombok的噩梦来了\",{\"1\":{\"501\":1}}],[\"lombok模块\",{\"1\":{\"468\":1}}],[\"lombok\",{\"0\":{\"1346\":1},\"1\":{\"468\":2,\"525\":1,\"534\":1,\"810\":1,\"811\":2,\"826\":1,\"1032\":1},\"2\":{\"814\":1}}],[\"lowercaseprinter\",{\"1\":{\"511\":2}}],[\"lowercase\",{\"1\":{\"480\":1}}],[\"low\",{\"1\":{\"384\":2}}],[\"loop\",{\"1\":{\"324\":1}}],[\"looptime\",{\"1\":{\"322\":5}}],[\"lol\",{\"1\":{\"295\":1}}],[\"loadbeandefinitions\",{\"1\":{\"1296\":1,\"1297\":5}}],[\"loadonstartup\",{\"1\":{\"1064\":1,\"1072\":1}}],[\"loaded\",{\"1\":{\"789\":2}}],[\"loading\",{\"1\":{\"788\":2,\"789\":1}}],[\"loaduserbyusername\",{\"1\":{\"668\":2,\"672\":1,\"692\":1}}],[\"load\",{\"1\":{\"215\":1,\"217\":1,\"789\":1,\"937\":1}}],[\"loadfactor\",{\"1\":{\"215\":2}}],[\"loss\",{\"1\":{\"141\":1}}],[\"longestcheckouttime\",{\"1\":{\"1246\":4}}],[\"longer\",{\"1\":{\"1181\":1}}],[\"long\",{\"1\":{\"135\":1,\"289\":1,\"290\":1,\"295\":1,\"300\":1,\"322\":4,\"372\":2,\"384\":3,\"386\":1,\"515\":1,\"625\":1,\"626\":2,\"831\":1,\"991\":1,\"1059\":3,\"1104\":1,\"1181\":1,\"1246\":6,\"1316\":1}}],[\"lib目录\",{\"1\":{\"1047\":1}}],[\"lib\",{\"1\":{\"1010\":1}}],[\"lifecycle\",{\"1\":{\"986\":1,\"1148\":3}}],[\"like\",{\"1\":{\"727\":1,\"763\":2,\"1091\":1,\"1096\":1}}],[\"li>\",{\"1\":{\"683\":1}}],[\"line\",{\"1\":{\"498\":2}}],[\"lines\",{\"1\":{\"269\":1,\"488\":2}}],[\"linkedmap\",{\"1\":{\"224\":1}}],[\"linkedset\",{\"1\":{\"224\":1}}],[\"linkedhashmap中的结点实现\",{\"1\":{\"218\":1}}],[\"linkedhashmap\",{\"0\":{\"218\":1},\"1\":{\"206\":1,\"214\":1,\"218\":2}}],[\"linkedhashset<>\",{\"1\":{\"206\":1}}],[\"linkedhashset\",{\"0\":{\"206\":1},\"1\":{\"206\":2}}],[\"linkedlist<e>\",{\"1\":{\"182\":1,\"199\":1}}],[\"linkedlist<>\",{\"1\":{\"182\":2,\"200\":1,\"201\":1,\"331\":1,\"699\":1}}],[\"linkedlist\",{\"1\":{\"182\":3,\"190\":1,\"199\":1,\"200\":1}}],[\"link\",{\"1\":{\"8\":1}}],[\"limit\",{\"1\":{\"228\":3,\"269\":1,\"478\":1,\"479\":2,\"515\":1,\"766\":2}}],[\"limiting\",{\"1\":{\"135\":1}}],[\"li\",{\"1\":{\"181\":4}}],[\"listablebeanfactory\",{\"1\":{\"1316\":1}}],[\"list>\",{\"1\":{\"1136\":1}}],[\"listener\",{\"0\":{\"1100\":1,\"1105\":1}}],[\"listed\",{\"1\":{\"1047\":1}}],[\"listn\",{\"1\":{\"528\":1}}],[\"list初始化\",{\"0\":{\"528\":1}}],[\"list2\",{\"1\":{\"522\":2,\"699\":2}}],[\"list1\",{\"1\":{\"522\":3,\"528\":1}}],[\"listfiles\",{\"1\":{\"255\":1}}],[\"list<clazz>\",{\"1\":{\"1209\":1}}],[\"list<service>\",{\"1\":{\"1117\":1}}],[\"list<student>\",{\"1\":{\"222\":1,\"528\":1,\"826\":1,\"830\":1,\"842\":2}}],[\"list<string>\",{\"1\":{\"182\":6,\"187\":2,\"191\":2,\"192\":1,\"228\":2,\"343\":1,\"350\":1,\"475\":1,\"515\":1,\"518\":1,\"519\":1,\"522\":2,\"528\":2,\"699\":4,\"871\":1,\"994\":1,\"995\":1,\"1136\":2,\"1207\":1,\"1321\":1}}],[\"list<b>\",{\"1\":{\"1116\":1}}],[\"list<book>\",{\"1\":{\"853\":1}}],[\"list<user>\",{\"1\":{\"836\":2,\"877\":1,\"895\":1,\"896\":1,\"898\":1,\"899\":1,\"900\":1}}],[\"list<filter>\",{\"1\":{\"708\":2,\"709\":1}}],[\"list<httpmessageconverter<\",{\"1\":{\"616\":1}}],[\"list<webapplicationinitializer>\",{\"1\":{\"550\":1}}],[\"list<test>\",{\"1\":{\"241\":1}}],[\"list<list<string>>\",{\"1\":{\"182\":1}}],[\"list<integer>\",{\"1\":{\"182\":2,\"228\":3,\"233\":1,\"234\":1,\"235\":1,\"236\":3,\"237\":1,\"330\":1,\"521\":1,\"522\":2}}],[\"list<e>\",{\"1\":{\"181\":2,\"182\":2,\"199\":1}}],[\"listiterator\",{\"1\":{\"181\":4}}],[\"listiterator<e>\",{\"1\":{\"181\":4,\"194\":1}}],[\"list中可插入重复元素\",{\"1\":{\"181\":1}}],[\"list是一个有序的集合类\",{\"1\":{\"181\":1}}],[\"list\",{\"0\":{\"181\":1},\"1\":{\"180\":2,\"181\":3,\"182\":30,\"187\":4,\"191\":4,\"192\":2,\"228\":31,\"233\":3,\"234\":2,\"235\":3,\"236\":4,\"237\":12,\"241\":4,\"255\":1,\"330\":2,\"343\":2,\"463\":1,\"475\":2,\"515\":6,\"518\":6,\"519\":6,\"521\":5,\"522\":12,\"528\":7,\"699\":6,\"789\":1,\"871\":1,\"876\":2,\"877\":2,\"994\":1,\"995\":6,\"1116\":1,\"1117\":1,\"1136\":5,\"1207\":3,\"1208\":2,\"1209\":4,\"1210\":1}}],[\"label\",{\"1\":{\"1279\":1}}],[\"label>\",{\"1\":{\"636\":3,\"666\":1,\"686\":1,\"1069\":2,\"1093\":1}}],[\"lazyinitialization\",{\"1\":{\"1327\":2}}],[\"lazy\",{\"0\":{\"1171\":1},\"1\":{\"1130\":1,\"1171\":1,\"1181\":2}}],[\"language\",{\"1\":{\"727\":1,\"744\":5,\"1091\":1,\"1096\":1,\"1211\":1}}],[\"lang=\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"lang包下的类\",{\"1\":{\"431\":1}}],[\"lang包下的\",{\"1\":{\"277\":1}}],[\"lang\",{\"1\":{\"277\":1,\"296\":1,\"339\":1,\"355\":2,\"365\":4,\"377\":1,\"378\":2,\"501\":1,\"841\":3,\"991\":2,\"1205\":1,\"1211\":1,\"1278\":2}}],[\"lang这个包下的所有类\",{\"1\":{\"277\":1}}],[\"lambda仅支持接口\",{\"1\":{\"447\":1}}],[\"lambda表达式简化\",{\"1\":{\"510\":1}}],[\"lambda表达式的具体规范\",{\"1\":{\"414\":1,\"447\":1}}],[\"lambda表达式\",{\"0\":{\"414\":1}}],[\"lambda\",{\"0\":{\"444\":1,\"446\":1,\"447\":1},\"1\":{\"192\":1,\"413\":1,\"414\":1,\"448\":1,\"451\":1}}],[\"lastmodified\",{\"1\":{\"626\":2,\"1059\":6}}],[\"lastreturned\",{\"1\":{\"190\":1}}],[\"lastret\",{\"1\":{\"190\":1}}],[\"last\",{\"1\":{\"182\":1}}],[\"lastindexof\",{\"1\":{\"181\":1}}],[\"large\",{\"1\":{\"75\":1,\"993\":2}}],[\"law\",{\"1\":{\"75\":1}}],[\"l2​=log2​\",{\"1\":{\"10\":1}}],[\"l2​\",{\"1\":{\"10\":1}}],[\"l1​=log2​\",{\"1\":{\"10\":1}}],[\"l1​\",{\"1\":{\"10\":1}}],[\"l=min\",{\"1\":{\"10\":1}}],[\"考虑能否仅用一次\",{\"1\":{\"101\":1}}],[\"考虑一个复杂的均值估计问题\",{\"1\":{\"110\":1}}],[\"考虑一个\",{\"1\":{\"81\":1}}],[\"考虑\",{\"1\":{\"70\":2}}],[\"考虑用户在每个时隙移动的情况\",{\"1\":{\"14\":1}}],[\"考虑以下场景\",{\"1\":{\"13\":1}}],[\"考虑无人机辅助无线网络的下行链路传输\",{\"1\":{\"8\":1}}],[\"考虑qoe\",{\"1\":{\"4\":1}}],[\"的传播级别设定为supports\",{\"1\":{\"1282\":1}}],[\"的功能还远不止这些\",{\"1\":{\"1200\":1}}],[\"的功率谱密度\",{\"1\":{\"9\":1}}],[\"的其中一个\",{\"1\":{\"1190\":1}}],[\"的确\",{\"1\":{\"1189\":1}}],[\"的循环依赖\",{\"1\":{\"1181\":2}}],[\"的程序可以访问该cookie\",{\"1\":{\"1092\":1}}],[\"的请求头\",{\"1\":{\"1091\":1}}],[\"的位置即可\",{\"1\":{\"1082\":1}}],[\"的垃圾回收器进行垃圾回收的\",{\"1\":{\"1055\":1}}],[\"的生命周期\",{\"0\":{\"1055\":1}}],[\"的默认的日志级别\",{\"1\":{\"939\":1,\"951\":1}}],[\"的默认处理器为\",{\"1\":{\"939\":1,\"951\":1}}],[\"的强大特性之一\",{\"1\":{\"872\":1}}],[\"的实例\",{\"1\":{\"1188\":1}}],[\"的实例为核心的\",{\"1\":{\"825\":1}}],[\"的实现\",{\"1\":{\"203\":1}}],[\"的应用都是以一个\",{\"1\":{\"825\":1}}],[\"的东西\",{\"1\":{\"824\":1}}],[\"的操作\",{\"1\":{\"782\":1}}],[\"的操作是从对应的xxx流内获取一些东西\",{\"1\":{\"726\":1}}],[\"的操作是往对应的xxx流内写入一些东西\",{\"1\":{\"726\":1}}],[\"的用法\",{\"1\":{\"726\":1}}],[\"的父类\",{\"1\":{\"705\":1}}],[\"的攻击技术\",{\"1\":{\"643\":1}}],[\"的结果不是视图名称而是直接需要返回一个字符串作为页面数据\",{\"1\":{\"615\":1}}],[\"的控制器请求\",{\"1\":{\"603\":1}}],[\"的viewresolver接口\",{\"1\":{\"560\":1}}],[\"的本质是导入\",{\"1\":{\"553\":1}}],[\"的类\",{\"1\":{\"550\":1,\"552\":1,\"1109\":1}}],[\"的到的就是这里返回的字符串\",{\"1\":{\"549\":1}}],[\"的问题\",{\"1\":{\"531\":1}}],[\"的行为\",{\"1\":{\"531\":1}}],[\"的流\",{\"1\":{\"519\":1}}],[\"的流转成一个\",{\"1\":{\"519\":1}}],[\"的变量\",{\"1\":{\"413\":1}}],[\"的匿名类\",{\"1\":{\"412\":1}}],[\"的构造方法中我们可以写入原因\",{\"1\":{\"423\":1}}],[\"的构造方法\",{\"1\":{\"348\":1}}],[\"的概念\",{\"1\":{\"312\":1}}],[\"的概率\",{\"1\":{\"20\":2}}],[\"的会保留\",{\"1\":{\"228\":1}}],[\"的处理\",{\"1\":{\"228\":1}}],[\"的源码发现\",{\"1\":{\"224\":1}}],[\"的全部性质\",{\"1\":{\"218\":1}}],[\"的容量\",{\"1\":{\"217\":1}}],[\"的关系存在\",{\"1\":{\"735\":1}}],[\"的关系\",{\"1\":{\"212\":1}}],[\"的性质\",{\"1\":{\"207\":1}}],[\"的底层实现是由\",{\"1\":{\"215\":1}}],[\"的底层实现\",{\"1\":{\"207\":1}}],[\"的方式去创建一个抽象类或是接口对象\",{\"1\":{\"412\":1}}],[\"的方式使用静态内容\",{\"1\":{\"376\":1}}],[\"的方式\",{\"0\":{\"192\":1},\"1\":{\"1196\":1}}],[\"的方法支持添加default关键字来添加默认实现\",{\"1\":{\"474\":1}}],[\"的方法进行解决\",{\"1\":{\"142\":1}}],[\"的方法\",{\"1\":{\"29\":1,\"68\":1,\"85\":1,\"147\":2,\"192\":1}}],[\"的排序方法\",{\"1\":{\"171\":1}}],[\"的使用几乎相同\",{\"1\":{\"182\":1}}],[\"的使用和\",{\"1\":{\"182\":1}}],[\"的使用\",{\"0\":{\"164\":1}}],[\"的算法\",{\"1\":{\"156\":1}}],[\"的选择\",{\"0\":{\"152\":1}}],[\"的权重或者分布\",{\"1\":{\"155\":1}}],[\"的权重\",{\"1\":{\"150\":1}}],[\"的加权平均\",{\"1\":{\"150\":1}}],[\"的加权均值\",{\"1\":{\"48\":1}}],[\"的基本步骤\",{\"1\":{\"148\":1}}],[\"的基础上来引入偏置量\",{\"1\":{\"25\":1}}],[\"的文章中\",{\"1\":{\"144\":1}}],[\"的输出是不一样的\",{\"1\":{\"144\":1}}],[\"的输出\",{\"1\":{\"142\":1}}],[\"的参数\",{\"1\":{\"142\":1}}],[\"的就不是有关\",{\"1\":{\"142\":1}}],[\"的梯度时\",{\"1\":{\"142\":1}}],[\"的分布\",{\"1\":{\"135\":1}}],[\"的新形式\",{\"1\":{\"113\":1}}],[\"的定义\",{\"1\":{\"113\":1}}],[\"的定义出发\",{\"1\":{\"77\":1}}],[\"的估计从\",{\"1\":{\"130\":1}}],[\"的估计\",{\"1\":{\"112\":1,\"116\":1}}],[\"的采样\",{\"1\":{\"110\":1}}],[\"的思想\",{\"1\":{\"101\":1}}],[\"的值进行重新计算\",{\"1\":{\"221\":1}}],[\"的值\",{\"1\":{\"99\":1}}],[\"的动作数量\",{\"1\":{\"87\":1}}],[\"的高效利用\",{\"0\":{\"81\":1}}],[\"的一些方法\",{\"0\":{\"220\":1}}],[\"的一些改进\",{\"1\":{\"80\":1}}],[\"的一个观测值\",{\"1\":{\"104\":1}}],[\"的一个\",{\"1\":{\"78\":1}}],[\"的情况下\",{\"1\":{\"1181\":1}}],[\"的情况下使用\",{\"1\":{\"318\":1}}],[\"的情况下进行估计\",{\"1\":{\"75\":1}}],[\"的情况\",{\"1\":{\"76\":1,\"77\":2,\"104\":1,\"451\":1}}],[\"的原理\",{\"1\":{\"76\":1}}],[\"的\",{\"1\":{\"63\":1,\"66\":1,\"77\":1,\"78\":2,\"81\":1,\"84\":1,\"86\":1,\"87\":1,\"111\":1,\"113\":2,\"123\":2,\"124\":2,\"133\":1,\"155\":1,\"187\":1,\"241\":1,\"343\":1,\"376\":1,\"393\":1,\"462\":1,\"531\":1,\"553\":1,\"619\":1,\"707\":1,\"816\":1,\"884\":1,\"1260\":1}}],[\"的策略来进行选择\",{\"1\":{\"66\":1}}],[\"的策略πk+1​\",{\"1\":{\"63\":1}}],[\"的策略所采集的数据来\",{\"1\":{\"29\":1}}],[\"的形式来直接引用一个已有的方法作为实现\",{\"1\":{\"448\":1}}],[\"的形式进行替换即可\",{\"1\":{\"446\":1}}],[\"的形式\",{\"1\":{\"58\":1,\"99\":1,\"187\":1,\"415\":2}}],[\"的根据策略π加权平均\",{\"1\":{\"49\":1}}],[\"的转到下一个状态的\",{\"1\":{\"48\":1}}],[\"的过程\",{\"1\":{\"47\":1}}],[\"的计算即可\",{\"1\":{\"42\":1}}],[\"的区别\",{\"0\":{\"41\":1},\"1\":{\"241\":1}}],[\"的期望\",{\"1\":{\"40\":1}}],[\"的s是有范围的\",{\"1\":{\"13\":1}}],[\"的函数\",{\"1\":{\"9\":1,\"142\":1}}],[\"的无人机3d动态运动设计算法\",{\"1\":{\"5\":1}}],[\"的部署方法\",{\"1\":{\"5\":1}}],[\"以我们常用的annotationconfigapplicationcontext为例\",{\"1\":{\"1317\":1}}],[\"以便在对象创建和被销毁时执行一些其他的任务\",{\"1\":{\"1147\":1}}],[\"以前耦合情况\",{\"0\":{\"1116\":1}}],[\"以前的源码是直接创建虚拟队列\",{\"1\":{\"708\":1}}],[\"以前的是直接用\",{\"1\":{\"708\":1}}],[\"以上条件都不满足\",{\"1\":{\"1246\":1}}],[\"以上方式存在一定的问题\",{\"1\":{\"1037\":1}}],[\"以上的方法虽然很好地解决了多种类型存储问题\",{\"1\":{\"437\":1}}],[\"以供其他项目作为依赖引入\",{\"1\":{\"1036\":1}}],[\"以供其他项目导入作为依赖使用\",{\"1\":{\"1034\":1}}],[\"以致于如此便捷的导入依赖\",{\"1\":{\"1009\":1}}],[\"以灵活地应对需要解决的问题\",{\"1\":{\"816\":1}}],[\"以insert\",{\"1\":{\"744\":1}}],[\"以防止在\",{\"1\":{\"714\":1}}],[\"以防止csrf攻击应用程序\",{\"1\":{\"660\":1}}],[\"以下示例显示了如何使用安全导航运算符\",{\"1\":{\"1211\":1}}],[\"以下日志级别依次降低\",{\"1\":{\"910\":1}}],[\"以下数据类型用于存储时间\",{\"1\":{\"746\":1}}],[\"以下数据类型用于存储数字\",{\"1\":{\"746\":1}}],[\"以下的数据类型用于字符串存储\",{\"1\":{\"746\":1}}],[\"以下是csrf相关配置\",{\"1\":{\"684\":1}}],[\"以下是退出登录相关配置\",{\"1\":{\"683\":1}}],[\"以下是表单登录相关配置\",{\"1\":{\"680\":1}}],[\"以下是验证请求拦截和放行配置\",{\"1\":{\"680\":1}}],[\"以下内容全是打印日志\",{\"1\":{\"625\":1}}],[\"以json格式输出jsonobject字符串\",{\"1\":{\"612\":1}}],[\"以对象的形式进行操作和内容的读取\",{\"1\":{\"610\":1}}],[\"以学生对象为例\",{\"1\":{\"610\":1}}],[\"以内的int值都是自动包装好\",{\"1\":{\"531\":1}}],[\"以毫秒为单位\",{\"1\":{\"299\":1}}],[\"以某种格式保存对象\",{\"1\":{\"287\":1}}],[\"以操作writer的样子写入outputstream\",{\"1\":{\"283\":1}}],[\"以字母数字排序\",{\"1\":{\"987\":1}}],[\"以字符\",{\"1\":{\"245\":1}}],[\"以字节\",{\"1\":{\"245\":1}}],[\"以set形式返回\",{\"1\":{\"213\":1}}],[\"以及conf目录\",{\"1\":{\"1047\":1}}],[\"以及各种配置的集合\",{\"1\":{\"1002\":1}}],[\"以及如何使用xml来作为mybatis的配置文件\",{\"1\":{\"819\":1}}],[\"以及标签内部的文本\",{\"1\":{\"819\":1}}],[\"以及目前最常用的axios框架等\",{\"1\":{\"617\":1}}],[\"以及使用jquery库中的ajax方法\",{\"1\":{\"617\":1}}],[\"以及几个很基本的页面\",{\"1\":{\"540\":1}}],[\"以及模块内的包名也得是唯一的\",{\"1\":{\"461\":1}}],[\"以及object的方法\",{\"1\":{\"376\":1}}],[\"以及notifyall\",{\"1\":{\"318\":1}}],[\"以及是否可以到最后优化的成果\",{\"1\":{\"101\":1}}],[\"以及\",{\"1\":{\"69\":1,\"88\":1,\"155\":1,\"241\":1,\"403\":2,\"1059\":1,\"1071\":1}}],[\"以向用户提供可靠的服务\",{\"1\":{\"9\":1}}],[\"以\",{\"1\":{\"5\":1,\"1059\":1}}],[\"该容器不会返回factory\",{\"1\":{\"1328\":1}}],[\"该如何进行合理分配\",{\"1\":{\"1245\":1}}],[\"该怎么做呢\",{\"1\":{\"1218\":1}}],[\"该怎么处理\",{\"1\":{\"386\":1}}],[\"该类加载器才会尝试去加载\",{\"1\":{\"1109\":1}}],[\"该类就能拦截所有带有\",{\"1\":{\"603\":1}}],[\"该加载路径中的class只对当前web应用程序可见\",{\"1\":{\"1109\":1}}],[\"该加载路径中的class对于所有web应用程序可见\",{\"1\":{\"1109\":1}}],[\"该加载路径中的class对于web应用程序不可见\",{\"1\":{\"1109\":1}}],[\"该加载路径中的class可以被tomcat容器本身以及各个web应用程序访问\",{\"1\":{\"1109\":1}}],[\"该cookie的用处说明\",{\"1\":{\"1092\":1}}],[\"该cookie是否仅被使用安全协议传输\",{\"1\":{\"1092\":1}}],[\"该cookie为临时cookie\",{\"1\":{\"1092\":1}}],[\"该请求包括请求参数也一起被传递了\",{\"1\":{\"1083\":1}}],[\"该元素不必声明\",{\"1\":{\"1015\":1}}],[\"该走其他过滤器就走其他地方配置的过滤器\",{\"1\":{\"710\":1}}],[\"该咋写咋写\",{\"1\":{\"414\":1}}],[\"该注解由\",{\"1\":{\"363\":1}}],[\"该方法允许将两个consumer连接在一起\",{\"1\":{\"511\":1}}],[\"该方法接受一个参数\",{\"1\":{\"510\":1}}],[\"该方法接受一个参数并且不返回任何结果\",{\"1\":{\"508\":1}}],[\"该方法参数为参数2\",{\"1\":{\"452\":1}}],[\"该方法是否是重写方法\",{\"1\":{\"361\":1}}],[\"该方法成立的数学依据是\",{\"1\":{\"75\":1}}],[\"该算法中\",{\"1\":{\"122\":1,\"123\":1}}],[\"该算法是\",{\"1\":{\"69\":1}}],[\"该步骤是根据\",{\"1\":{\"66\":1}}],[\"该步骤是用来计算当前策略\",{\"1\":{\"66\":1}}],[\"该式子针对状态空间中的所有状态均成立\",{\"1\":{\"45\":1}}],[\"该论文中在精度和模型复杂型上作出平衡\",{\"1\":{\"13\":1}}],[\"该问题依然是np\",{\"1\":{\"13\":1}}],[\"该优化问题是一个non\",{\"1\":{\"11\":1}}],[\"该文件配置很简单\",{\"1\":{\"936\":1}}],[\"该文中不同集群所利用的频谱是不同的\",{\"1\":{\"9\":1}}],[\"该文中表示为\",{\"1\":{\"9\":1}}],[\"该文提出的算法具较快的收敛性\",{\"1\":{\"5\":1}}],[\"该文基于q\",{\"1\":{\"5\":1}}],[\"该文设计的是3d部署\",{\"1\":{\"4\":1}}],[\"该框架将无人机部署在三维空间内\",{\"1\":{\"5\":1}}],[\"smartfactorybean\",{\"1\":{\"1321\":2}}],[\"smartfactorybean<\",{\"1\":{\"1321\":1}}],[\"smartinstantiationaware\",{\"1\":{\"1301\":1}}],[\"smartinstantiationawarebeanpostprocessor\",{\"1\":{\"1301\":1}}],[\"small\",{\"1\":{\"993\":2}}],[\"smallint用于存储小的整数\",{\"1\":{\"746\":1}}],[\"s3cret\",{\"1\":{\"1047\":2}}],[\"s2\",{\"1\":{\"883\":2}}],[\"s2​\",{\"1\":{\"81\":4}}],[\"s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​∣s1​\",{\"1\":{\"19\":1}}],[\"s1\",{\"1\":{\"883\":2}}],[\"s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":2}}],[\"s1​\",{\"1\":{\"46\":2,\"81\":4,\"112\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​→a1​s2​\",{\"1\":{\"19\":1}}],[\"sneakythrows\",{\"1\":{\"1017\":1}}],[\"sneakythrows来自动生成try\",{\"1\":{\"812\":1}}],[\"snapshot<\",{\"1\":{\"1002\":1,\"1023\":2,\"1026\":1,\"1032\":1}}],[\"sno\",{\"1\":{\"779\":1,\"781\":2}}],[\"sn​\",{\"1\":{\"46\":2}}],[\"sfa会话固定攻击\",{\"0\":{\"642\":1}}],[\"switch表达式在java\",{\"1\":{\"497\":1}}],[\"switch\",{\"1\":{\"495\":1,\"496\":1,\"497\":3}}],[\"sqrt\",{\"1\":{\"431\":1}}],[\"sql定义的一个接口\",{\"1\":{\"1242\":1}}],[\"sql类中提供了常见的select\",{\"1\":{\"902\":1}}],[\"sqlsessiontemplatebeanname\",{\"1\":{\"1327\":1}}],[\"sqlsessiontemplate\",{\"1\":{\"1254\":3,\"1256\":2,\"1327\":1}}],[\"sqlsession接口中为我们提供了事务操作相关的方法\",{\"1\":{\"865\":1}}],[\"sqlsession对象\",{\"1\":{\"825\":1,\"830\":1}}],[\"sqlsession\",{\"1\":{\"824\":1,\"826\":3,\"830\":4,\"842\":4,\"865\":2,\"883\":2,\"884\":3,\"1017\":3,\"1072\":3,\"1093\":3,\"1242\":2}}],[\"sqlsessionfactory对象是什么东西\",{\"1\":{\"825\":1}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"824\":1,\"826\":1,\"830\":1,\"904\":1,\"1017\":1,\"1072\":1,\"1254\":1}}],[\"sqlsessionfactorybeanname\",{\"1\":{\"1327\":1}}],[\"sqlsessionfactorybean\",{\"1\":{\"671\":4,\"1259\":4,\"1276\":4}}],[\"sqlsessionfactory\",{\"1\":{\"671\":1,\"824\":3,\"825\":1,\"826\":3,\"830\":4,\"865\":1,\"904\":1,\"1017\":1,\"1072\":1,\"1254\":1,\"1327\":1}}],[\"sqlexception\",{\"1\":{\"788\":1,\"789\":7,\"790\":2,\"796\":1,\"798\":1,\"799\":2,\"804\":1,\"805\":1,\"806\":4,\"1242\":2,\"1244\":4,\"1245\":2,\"1246\":4,\"1247\":1,\"1272\":5,\"1273\":4}}],[\"sql包\",{\"1\":{\"787\":1}}],[\"sql语句映射配置我们就编写好了\",{\"1\":{\"832\":1}}],[\"sql语句\",{\"1\":{\"806\":3}}],[\"sql语句中的等于判断是=\",{\"1\":{\"755\":1}}],[\"sql语句不区分大小写\",{\"1\":{\"744\":1}}],[\"sql数据类型\",{\"0\":{\"746\":1}}],[\"sql也支持注释\",{\"1\":{\"744\":1}}],[\"sql\",{\"0\":{\"744\":1},\"1\":{\"228\":1,\"513\":1,\"732\":1,\"789\":1,\"790\":1,\"796\":1,\"816\":1,\"849\":1,\"872\":3,\"902\":1}}],[\"ssm中的其中一个s\",{\"1\":{\"1291\":1}}],[\"ssm\",{\"0\":{\"1341\":1},\"1\":{\"1112\":1}}],[\"ssl等\",{\"1\":{\"1092\":1}}],[\"sss\",{\"1\":{\"948\":1}}],[\"ss\",{\"1\":{\"412\":2,\"948\":1,\"1076\":1}}],[\"sh拖入窗口按回车运行\",{\"1\":{\"1047\":1}}],[\"should\",{\"1\":{\"789\":1,\"1047\":1}}],[\"show\",{\"1\":{\"773\":1,\"780\":1,\"781\":1,\"782\":1}}],[\"shorter\",{\"1\":{\"1181\":1}}],[\"short\",{\"1\":{\"384\":3,\"991\":1,\"1181\":1}}],[\"shutdowninput\",{\"1\":{\"721\":1}}],[\"shutdownoutput\",{\"1\":{\"721\":1}}],[\"sharedinstance\",{\"1\":{\"1300\":4}}],[\"shared\",{\"1\":{\"324\":1,\"1109\":1}}],[\"synctest\",{\"1\":{\"1188\":2}}],[\"synchronize\",{\"1\":{\"789\":1}}],[\"synchronized关键字也可以作用于方法上\",{\"1\":{\"312\":1}}],[\"synchronized需要在括号中填入一个内容\",{\"1\":{\"312\":1}}],[\"synchronized\",{\"1\":{\"312\":8,\"313\":4,\"318\":2,\"324\":2,\"331\":2,\"625\":1,\"706\":1,\"789\":2,\"1246\":1,\"1247\":1,\"1301\":1,\"1320\":1}}],[\"syntax\",{\"1\":{\"403\":1}}],[\"systemproperties\",{\"1\":{\"1211\":1}}],[\"systempath>\",{\"1\":{\"1018\":1}}],[\"system类中有一个getproperties方法用于存储所有系统相关的属性值\",{\"1\":{\"938\":1}}],[\"system\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"285\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"348\":2,\"349\":5,\"350\":4,\"355\":5,\"356\":2,\"365\":6,\"373\":2,\"375\":1,\"376\":2,\"377\":4,\"378\":1,\"384\":3,\"385\":1,\"386\":2,\"393\":1,\"394\":2,\"397\":1,\"398\":1,\"399\":1,\"401\":6,\"402\":3,\"403\":2,\"408\":5,\"409\":1,\"410\":1,\"411\":7,\"412\":3,\"413\":1,\"414\":3,\"415\":2,\"424\":3,\"431\":2,\"432\":1,\"438\":1,\"445\":1,\"446\":1,\"449\":2,\"451\":2,\"452\":1,\"454\":6,\"461\":1,\"462\":1,\"464\":1,\"474\":3,\"475\":2,\"476\":1,\"477\":2,\"478\":2,\"479\":2,\"480\":6,\"485\":1,\"488\":6,\"490\":3,\"497\":1,\"500\":1,\"501\":1,\"504\":1,\"510\":1,\"511\":2,\"512\":3,\"515\":1,\"518\":1,\"519\":1,\"521\":4,\"522\":5,\"531\":3,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":1,\"586\":1,\"588\":1,\"589\":6,\"595\":3,\"599\":1,\"600\":4,\"605\":1,\"612\":1,\"613\":1,\"619\":1,\"625\":1,\"626\":1,\"636\":2,\"658\":1,\"659\":1,\"697\":2,\"699\":2,\"719\":6,\"720\":10,\"721\":1,\"726\":1,\"727\":6,\"788\":1,\"789\":1,\"796\":1,\"799\":1,\"804\":2,\"805\":3,\"819\":1,\"826\":1,\"830\":1,\"832\":1,\"833\":1,\"834\":1,\"836\":3,\"841\":1,\"842\":2,\"843\":1,\"865\":2,\"883\":6,\"884\":2,\"888\":1,\"897\":1,\"918\":1,\"927\":2,\"930\":3,\"937\":1,\"938\":5,\"944\":3,\"950\":2,\"956\":4,\"973\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":2,\"980\":1,\"985\":3,\"986\":3,\"987\":3,\"988\":5,\"993\":2,\"994\":1,\"995\":2,\"1008\":1,\"1017\":2,\"1018\":1,\"1023\":1,\"1035\":1,\"1057\":4,\"1069\":1,\"1072\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1086\":1,\"1091\":1,\"1102\":1,\"1103\":5,\"1105\":1,\"1119\":2,\"1126\":2,\"1129\":2,\"1132\":2,\"1135\":2,\"1157\":2,\"1159\":1,\"1160\":1,\"1169\":1,\"1176\":2,\"1178\":2,\"1186\":2,\"1188\":4,\"1189\":1,\"1190\":1,\"1191\":1,\"1192\":1,\"1199\":1,\"1200\":1,\"1202\":2,\"1203\":4,\"1204\":2,\"1205\":2,\"1207\":2,\"1208\":2,\"1209\":2,\"1210\":1,\"1211\":4,\"1218\":2,\"1222\":1,\"1223\":2,\"1224\":7,\"1225\":2,\"1231\":5,\"1232\":1,\"1233\":1,\"1234\":2,\"1235\":3,\"1236\":2,\"1237\":2,\"1246\":6,\"1256\":1,\"1257\":1,\"1296\":4,\"1298\":4,\"1299\":1,\"1307\":3,\"1308\":3,\"1311\":3,\"1328\":3}}],[\"slf4j只是一个api标准\",{\"1\":{\"1260\":1}}],[\"slf4j<\",{\"1\":{\"1025\":2,\"1260\":2}}],[\"slf4j\",{\"1\":{\"951\":1,\"1260\":7,\"1278\":1}}],[\"sleep\",{\"1\":{\"299\":1,\"300\":1,\"301\":1,\"311\":1,\"312\":4,\"313\":2,\"318\":1,\"319\":2,\"322\":2,\"329\":4,\"331\":2,\"378\":4,\"888\":1,\"1188\":2,\"1225\":1}}],[\"slove\",{\"0\":{\"47\":1}}],[\"slow\",{\"1\":{\"10\":1}}],[\"src=\",{\"1\":{\"490\":1,\"563\":1,\"564\":1,\"617\":2,\"636\":1,\"641\":1,\"642\":1}}],[\"src\",{\"1\":{\"267\":1,\"356\":1}}],[\"skip=true来以跳过测试的方式进行打包\",{\"1\":{\"1036\":1}}],[\"skipping\",{\"1\":{\"789\":1}}],[\"skip\",{\"1\":{\"248\":2,\"253\":1,\"789\":1}}],[\"sdawers\",{\"1\":{\"228\":1}}],[\"sport\",{\"1\":{\"1126\":1,\"1127\":1}}],[\"sportstudent\",{\"1\":{\"1126\":2,\"1127\":1,\"1149\":3,\"1150\":1,\"1151\":1}}],[\"specified\",{\"1\":{\"1319\":1}}],[\"specifiedformatter\",{\"1\":{\"939\":3}}],[\"spel也支持这种写法\",{\"1\":{\"1211\":1}}],[\"spel是具有运算能力的\",{\"1\":{\"1202\":1}}],[\"spelexpressionparser\",{\"1\":{\"1202\":1,\"1203\":1}}],[\"spel表达式\",{\"0\":{\"1201\":1}}],[\"spel\",{\"1\":{\"1196\":1}}],[\"spel以及非常关键的aop框架\",{\"1\":{\"1118\":1}}],[\"spi\",{\"1\":{\"788\":1}}],[\"spatial\",{\"1\":{\"780\":1}}],[\"span>\",{\"1\":{\"686\":1}}],[\"span><\",{\"1\":{\"617\":2}}],[\"space\",{\"1\":{\"13\":2,\"19\":3}}],[\"spring完全有机会解决单例对象循环依赖的问题\",{\"1\":{\"1301\":1}}],[\"springextension\",{\"1\":{\"1291\":1}}],[\"springel\",{\"2\":{\"1213\":1,\"1228\":1,\"1239\":1,\"1249\":1,\"1262\":1,\"1286\":1,\"1293\":1}}],[\"springel表达式\",{\"0\":{\"1196\":1}}],[\"springel表达式1\",{\"0\":{\"1195\":1}}],[\"spring为我们提供了一个test模块\",{\"1\":{\"1290\":1}}],[\"spring为我们提供了一个ioc容器\",{\"1\":{\"1119\":1}}],[\"springtest模块\",{\"0\":{\"1289\":1}}],[\"springtemplateengine\",{\"1\":{\"560\":7}}],[\"spring默认的传播级别是propagation\",{\"1\":{\"1281\":1}}],[\"spring会通过aop机制为其进行增强\",{\"1\":{\"1277\":1}}],[\"spring会给我们提供ioc容器用于管理bean\",{\"1\":{\"1119\":1}}],[\"spring事务管理分为编程式事务和声明式事务\",{\"1\":{\"1274\":1}}],[\"spring事务管理\",{\"0\":{\"1274\":1}}],[\"spring依赖中\",{\"1\":{\"1254\":1}}],[\"spring的jdbc支持框架\",{\"1\":{\"1253\":1}}],[\"spring是支持aop编程的框架之一\",{\"1\":{\"1217\":1}}],[\"spring是一个非入侵式的框架\",{\"1\":{\"1118\":1}}],[\"spring是一个框架\",{\"1\":{\"1113\":1}}],[\"spring官方为我们提供了一套非常高级spel表达式\",{\"1\":{\"1201\":1}}],[\"spring内部有各种各样的事件\",{\"1\":{\"1192\":1}}],[\"spring中的定时任务是全局性质的\",{\"1\":{\"1190\":1}}],[\"spring容器会在bean被加载时\",{\"1\":{\"1186\":1}}],[\"spring高级特性1\",{\"0\":{\"1185\":1}}],[\"spring高级特性\",{\"0\":{\"1184\":1,\"1354\":1}}],[\"spring又会怎么处理呢\",{\"1\":{\"1181\":1}}],[\"spring也提供了接口\",{\"1\":{\"1180\":1}}],[\"spring都会为其添加一个默认的name属性\",{\"1\":{\"1178\":1}}],[\"spring在扫描对应包下所有的类时\",{\"1\":{\"1177\":1}}],[\"spring5\",{\"0\":{\"1163\":1}}],[\"spring4\",{\"0\":{\"1155\":1}}],[\"spring能够从bean对象的创建一直管理到对象的销毁\",{\"1\":{\"1148\":1}}],[\"spring无法顾及其完整生命周期\",{\"1\":{\"1148\":1}}],[\"spring无法得知我们要配置的bean到底是哪一个类\",{\"1\":{\"1125\":1}}],[\"spring3\",{\"0\":{\"1144\":1}}],[\"spring2\",{\"0\":{\"1122\":1}}],[\"spring核心框架的maven依赖坐标\",{\"1\":{\"1118\":1}}],[\"spring并不是一个独立的框架\",{\"1\":{\"1118\":1}}],[\"spring框架最核心的其实它的ioc容器\",{\"1\":{\"1114\":1}}],[\"spring+springmvc+mybatis\",{\"1\":{\"1112\":1}}],[\"spring1\",{\"0\":{\"1112\":1}}],[\"spring<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"springsecurityfilterchain\",{\"1\":{\"705\":4}}],[\"springsecurity的过滤器从某种意义上来说\",{\"1\":{\"714\":1}}],[\"springsecurity的过滤操作已经结束\",{\"1\":{\"710\":1}}],[\"springsecurity的实现原理本质上是依靠n个filter实现的\",{\"1\":{\"704\":1}}],[\"springsecurity的配置就完成了\",{\"1\":{\"652\":1}}],[\"springsecurity7\",{\"0\":{\"702\":1}}],[\"springsecurity为我们提供了两种授权方式\",{\"1\":{\"691\":1}}],[\"springsecurity为我们提供了一种优秀的实现\",{\"1\":{\"686\":1}}],[\"springsecurity6\",{\"0\":{\"690\":1}}],[\"springsecurity5\",{\"0\":{\"675\":1}}],[\"springsecurity4\",{\"0\":{\"655\":1}}],[\"springsecurity底层就是依靠n个过滤器实现的\",{\"1\":{\"650\":1}}],[\"springsecurity3\",{\"0\":{\"646\":1,\"647\":1}}],[\"springsecurity2\",{\"0\":{\"639\":1,\"640\":1}}],[\"springsecurity是一个基于spring开发的非常强大的权限验证框架\",{\"1\":{\"635\":1}}],[\"springsecurity\",{\"0\":{\"635\":1,\"648\":1}}],[\"springsecurity1\",{\"0\":{\"634\":1}}],[\"springservletcontainerinitializer\",{\"1\":{\"550\":2}}],[\"springresourcetemplateresolver\",{\"1\":{\"560\":3}}],[\"spring6<\",{\"1\":{\"559\":1,\"616\":1}}],[\"spring6之后要求必须使用tomcat10或更高版本\",{\"1\":{\"542\":1}}],[\"springmv\",{\"1\":{\"553\":1}}],[\"springmvc7\",{\"0\":{\"629\":1}}],[\"springmvc6\",{\"0\":{\"623\":1}}],[\"springmvc非常智能\",{\"1\":{\"616\":1}}],[\"springmvc5\",{\"0\":{\"608\":1}}],[\"springmvc4\",{\"0\":{\"592\":1}}],[\"springmvc才能大显身手\",{\"1\":{\"586\":1}}],[\"springmvc会自动传递该请求原本的httpservletrequest对象\",{\"1\":{\"582\":1}}],[\"springmvc会将其自动包装为modelandview对象\",{\"1\":{\"563\":1}}],[\"springmvc3\",{\"0\":{\"567\":1}}],[\"springmvc通过依赖注入会自动帮助我们传递实例对象\",{\"1\":{\"563\":1}}],[\"springmvc自带了一些视图解析器\",{\"1\":{\"558\":1}}],[\"springmvc2\",{\"0\":{\"557\":1}}],[\"springmvc项目依然支持多种配置形式\",{\"1\":{\"543\":1}}],[\"springmvc正是希望这三者之间进行解耦\",{\"1\":{\"541\":1}}],[\"springmvc正是为了解决这种问题而生的\",{\"1\":{\"540\":1}}],[\"springmvc\",{\"1\":{\"540\":1,\"558\":1,\"560\":1}}],[\"springmvc1\",{\"0\":{\"539\":1}}],[\"spring提供了这个接口的实现类\",{\"1\":{\"550\":1}}],[\"springframework\",{\"1\":{\"545\":1,\"547\":3,\"548\":1,\"549\":6,\"649\":2,\"705\":1,\"1119\":4,\"1167\":3,\"1181\":2,\"1217\":6,\"1278\":2,\"1283\":7}}],[\"springframework<\",{\"1\":{\"544\":1,\"551\":1,\"663\":1,\"1118\":1,\"1217\":1,\"1253\":1,\"1290\":1}}],[\"spring\",{\"0\":{\"1113\":1,\"1340\":1,\"1342\":1,\"1353\":1},\"1\":{\"534\":1,\"547\":2,\"548\":1,\"549\":2,\"553\":3,\"560\":2,\"603\":1,\"604\":1,\"619\":1,\"625\":1,\"631\":1,\"660\":1,\"1113\":3,\"1118\":1,\"1119\":1,\"1148\":2,\"1157\":1,\"1167\":1,\"1181\":12,\"1211\":3,\"1217\":2,\"1219\":4,\"1291\":1,\"1318\":1,\"1319\":1,\"1320\":2},\"2\":{\"556\":1,\"566\":1,\"591\":1,\"607\":1,\"622\":1,\"628\":1,\"633\":1,\"638\":1,\"645\":1,\"654\":1,\"674\":1,\"689\":1,\"701\":1,\"716\":1,\"1121\":1,\"1143\":1,\"1154\":1,\"1162\":1,\"1183\":1,\"1194\":1,\"1213\":1,\"1228\":1,\"1239\":1,\"1249\":1,\"1262\":1,\"1286\":1,\"1293\":1,\"1303\":1,\"1313\":1,\"1323\":1,\"1330\":1}}],[\"splitable\",{\"1\":{\"330\":1}}],[\"split\",{\"1\":{\"228\":1,\"401\":2}}],[\"spliterator也用于遍历数据源中的元素\",{\"1\":{\"330\":1}}],[\"spliteratorunknownsize\",{\"1\":{\"193\":1}}],[\"spliterator<t>\",{\"1\":{\"193\":1}}],[\"spliterator<e>\",{\"1\":{\"180\":1,\"204\":1}}],[\"spliterators\",{\"1\":{\"180\":1,\"193\":1,\"204\":1}}],[\"spliterator\",{\"1\":{\"180\":4,\"193\":1,\"204\":3,\"330\":1}}],[\"suits\",{\"1\":{\"1181\":1}}],[\"suitable\",{\"1\":{\"789\":2}}],[\"successhandler\",{\"1\":{\"712\":1}}],[\"successfulauthentication\",{\"1\":{\"711\":1,\"712\":1}}],[\"success\",{\"1\":{\"523\":2,\"617\":8,\"636\":3,\"658\":1,\"666\":2,\"789\":1,\"1034\":1}}],[\"suffix\",{\"1\":{\"490\":2}}],[\"submit\",{\"1\":{\"619\":1,\"636\":1,\"641\":1,\"682\":1,\"683\":1}}],[\"subinterceptor\",{\"1\":{\"600\":2}}],[\"sub\",{\"1\":{\"401\":2}}],[\"substring\",{\"1\":{\"401\":2,\"490\":2}}],[\"sublist\",{\"1\":{\"181\":1}}],[\"sunnyzyq\",{\"1\":{\"1190\":1}}],[\"sun\",{\"1\":{\"343\":1,\"1283\":1}}],[\"suspend\",{\"1\":{\"313\":1}}],[\"supports\",{\"1\":{\"1282\":1}}],[\"support\",{\"1\":{\"1181\":1,\"1278\":1,\"1283\":1}}],[\"supported\",{\"1\":{\"1059\":1,\"1181\":1}}],[\"supposed\",{\"1\":{\"4\":1}}],[\"supplier<list<string>>\",{\"1\":{\"995\":1}}],[\"supplier等\",{\"1\":{\"453\":1}}],[\"suppresswarnings\",{\"1\":{\"181\":1,\"217\":1,\"340\":1,\"361\":1}}],[\"super\",{\"1\":{\"172\":2,\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1,\"218\":1,\"371\":1,\"373\":3,\"375\":1,\"376\":1,\"377\":2,\"408\":2,\"422\":2,\"509\":1,\"1064\":1,\"1192\":1,\"1307\":1,\"1327\":1}}],[\"summarystatistics\",{\"1\":{\"228\":2}}],[\"sum\",{\"1\":{\"165\":2,\"222\":1,\"228\":2,\"415\":5,\"512\":2,\"521\":2,\"765\":1,\"766\":2}}],[\"s∣s\",{\"1\":{\"155\":1}}],[\"s∣a\",{\"1\":{\"57\":1,\"58\":1}}],[\"s∑​dπ​\",{\"1\":{\"154\":1}}],[\"scoped\",{\"1\":{\"1148\":2}}],[\"scopes\",{\"1\":{\"1148\":1}}],[\"scope>\",{\"1\":{\"1017\":1,\"1018\":1,\"1033\":4,\"1290\":1}}],[\"scope\",{\"0\":{\"1171\":1},\"1\":{\"1015\":1,\"1148\":1,\"1171\":1}}],[\"scoremap\",{\"1\":{\"222\":3}}],[\"score<string>\",{\"1\":{\"438\":3}}],[\"score<>\",{\"1\":{\"172\":3,\"438\":1}}],[\"score<\",{\"1\":{\"172\":3}}],[\"score<t>\",{\"1\":{\"438\":1}}],[\"score<t\",{\"1\":{\"172\":1}}],[\"score\",{\"1\":{\"5\":1,\"172\":6,\"222\":5,\"437\":9,\"438\":4,\"495\":5,\"496\":3,\"1209\":2}}],[\"sc是不允许更新的\",{\"1\":{\"779\":1}}],[\"sc的基本表是sc\",{\"1\":{\"779\":1}}],[\"sc\",{\"1\":{\"779\":4}}],[\"script\",{\"1\":{\"643\":1,\"1047\":2}}],[\"script>\",{\"1\":{\"563\":1,\"564\":1,\"617\":5,\"636\":2,\"641\":1,\"642\":2,\"902\":1,\"1076\":1}}],[\"schema\",{\"1\":{\"547\":3,\"549\":6,\"1119\":3,\"1167\":3,\"1217\":6}}],[\"schemalocation=\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1167\":1,\"1217\":1}}],[\"scheduled中有很多参数\",{\"1\":{\"1190\":1}}],[\"scheduled\",{\"1\":{\"1190\":1,\"1192\":1}}],[\"scheduled注解\",{\"1\":{\"1190\":1}}],[\"schedule\",{\"1\":{\"323\":1,\"324\":2}}],[\"scala\",{\"1\":{\"1000\":1}}],[\"scalar\",{\"1\":{\"148\":1}}],[\"scan\",{\"1\":{\"549\":1,\"1327\":1}}],[\"scanner\",{\"1\":{\"285\":6,\"531\":6,\"720\":4,\"721\":3,\"804\":3,\"805\":5,\"1318\":1,\"1327\":15}}],[\"sgdw\",{\"0\":{\"106\":1}}],[\"sgd的目标是\",{\"1\":{\"104\":1}}],[\"sgd\",{\"0\":{\"102\":1,\"104\":1,\"105\":1},\"1\":{\"101\":1,\"104\":3,\"105\":2,\"136\":1,\"155\":1}}],[\"s5​\",{\"1\":{\"81\":1}}],[\"s5​a1​​\",{\"1\":{\"81\":1}}],[\"sevice\",{\"1\":{\"1056\":1}}],[\"severe\",{\"1\":{\"910\":4,\"911\":1,\"1246\":2}}],[\"separator用于控制分隔符\",{\"1\":{\"876\":1}}],[\"separator=\",{\"1\":{\"876\":1,\"877\":1}}],[\"separately\",{\"1\":{\"296\":1}}],[\"select中编写一个xml配置动态sql\",{\"1\":{\"902\":1}}],[\"selectprovider\",{\"1\":{\"902\":1}}],[\"selectprovider来引用这边编写好的动态sql操作\",{\"1\":{\"902\":1}}],[\"selectdetailbyid\",{\"1\":{\"901\":2}}],[\"select代表的就是select标签\",{\"1\":{\"896\":1}}],[\"selectgroup\",{\"1\":{\"855\":2}}],[\"selectalluser\",{\"1\":{\"855\":1,\"895\":2,\"896\":1,\"898\":1,\"899\":1,\"900\":1}}],[\"selectbookbysid\",{\"1\":{\"854\":2}}],[\"select=\",{\"1\":{\"851\":1,\"854\":1,\"855\":1}}],[\"selectstusbysex\",{\"1\":{\"842\":2}}],[\"selectstubyid\",{\"1\":{\"842\":2,\"854\":1,\"884\":2}}],[\"selectstudent\",{\"1\":{\"826\":2,\"830\":1,\"842\":3,\"855\":1}}],[\"selectcursor\",{\"1\":{\"836\":1}}],[\"selectmap\",{\"1\":{\"836\":1}}],[\"selectuserdetailbyid\",{\"1\":{\"851\":2}}],[\"selectusersbyage\",{\"1\":{\"836\":2}}],[\"selectusers\",{\"1\":{\"836\":4}}],[\"selectuserbyidandage\",{\"1\":{\"833\":1,\"834\":2,\"835\":1,\"843\":5}}],[\"selectuserbyid\",{\"1\":{\"831\":4,\"832\":1,\"833\":1,\"836\":1,\"841\":1,\"849\":1,\"851\":1,\"865\":2,\"873\":1,\"874\":1,\"883\":6,\"886\":1,\"887\":1,\"888\":1,\"901\":1,\"902\":3,\"903\":1}}],[\"selectone\",{\"1\":{\"832\":1,\"833\":1,\"834\":1}}],[\"selectlist\",{\"1\":{\"826\":1,\"830\":1,\"836\":2}}],[\"select>\",{\"1\":{\"826\":1,\"831\":4,\"833\":1,\"834\":1,\"835\":1,\"836\":2,\"841\":1,\"842\":3,\"843\":1,\"849\":1,\"851\":2,\"854\":2,\"855\":3,\"873\":1,\"874\":1,\"886\":1,\"887\":1,\"895\":1,\"902\":1}}],[\"select返回的数据类似于一个excel表格\",{\"1\":{\"797\":1}}],[\"select\",{\"0\":{\"851\":1},\"1\":{\"670\":2,\"762\":5,\"764\":2,\"765\":1,\"766\":4,\"767\":3,\"768\":1,\"769\":2,\"770\":2,\"779\":2,\"788\":1,\"804\":2,\"805\":2,\"826\":1,\"831\":2,\"833\":1,\"834\":1,\"835\":1,\"836\":3,\"841\":1,\"842\":3,\"843\":2,\"849\":1,\"850\":1,\"851\":2,\"852\":2,\"853\":1,\"854\":3,\"855\":4,\"873\":1,\"874\":1,\"886\":1,\"887\":1,\"895\":1,\"896\":2,\"898\":2,\"899\":2,\"900\":2,\"901\":5,\"902\":4,\"903\":2,\"1071\":2,\"1255\":2}}],[\"sec\",{\"1\":{\"727\":7,\"1091\":4,\"1096\":5}}],[\"secure\",{\"1\":{\"1092\":1}}],[\"secured\",{\"1\":{\"708\":2,\"710\":1}}],[\"secured但是它不支持spel表达式的权限表示形式\",{\"1\":{\"698\":1}}],[\"securing\",{\"1\":{\"708\":1}}],[\"securityadmin等人员才有权力执行dcl\",{\"1\":{\"744\":1}}],[\"securitycontextholderawarerequestfilter\",{\"1\":{\"714\":1}}],[\"securitycontextholderfilter\",{\"1\":{\"714\":1}}],[\"securitycontextholder\",{\"1\":{\"709\":1,\"712\":2,\"713\":2}}],[\"securitycontextholderstrategy\",{\"1\":{\"709\":1}}],[\"securityconfiguration\",{\"1\":{\"651\":1,\"652\":1,\"658\":1,\"659\":1,\"664\":1,\"666\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"695\":1}}],[\"securityfilterchain\",{\"1\":{\"680\":1,\"683\":1,\"684\":1,\"686\":1}}],[\"security会自动进行选择\",{\"1\":{\"659\":1}}],[\"securityinitializer\",{\"1\":{\"650\":1,\"705\":1}}],[\"security\",{\"0\":{\"1342\":1},\"1\":{\"649\":2,\"660\":2,\"705\":1,\"708\":1}}],[\"security<\",{\"1\":{\"649\":2}}],[\"secondinterceptor\",{\"1\":{\"601\":1}}],[\"sessioncreated\",{\"1\":{\"1105\":1}}],[\"session将丢失\",{\"1\":{\"1097\":1}}],[\"session并不是永远都存在的\",{\"1\":{\"1097\":1}}],[\"session实际上是基于cookie实现的\",{\"1\":{\"1095\":1}}],[\"sessionweb\",{\"1\":{\"1092\":2}}],[\"session2\",{\"1\":{\"884\":3}}],[\"session管理相关\",{\"1\":{\"714\":1}}],[\"sessionmanagementfilter\",{\"1\":{\"714\":1}}],[\"sessionstrategy\",{\"1\":{\"711\":1}}],[\"sessionscope\",{\"1\":{\"588\":1}}],[\"sessionscope表示此bean的web作用域\",{\"1\":{\"588\":1}}],[\"sessionattribute\",{\"1\":{\"586\":1}}],[\"sessionattrbutie\",{\"0\":{\"584\":1}}],[\"session也能使用注解快速获取\",{\"1\":{\"586\":1}}],[\"session\",{\"0\":{\"1089\":1,\"1094\":1},\"1\":{\"582\":3,\"586\":2,\"588\":2,\"636\":6,\"642\":1,\"705\":1,\"714\":1,\"832\":1,\"833\":1,\"834\":1,\"836\":5,\"843\":1,\"865\":7,\"871\":2,\"876\":1,\"877\":1,\"883\":1,\"884\":2,\"888\":1,\"1047\":1,\"1094\":2,\"1095\":1,\"1096\":6,\"1097\":3,\"1104\":2,\"1242\":1}}],[\"server\",{\"1\":{\"719\":4,\"720\":5,\"726\":4,\"727\":5,\"732\":2}}],[\"serversocket\",{\"1\":{\"719\":4,\"720\":2,\"726\":2,\"727\":4}}],[\"service的实现类\",{\"1\":{\"1116\":1}}],[\"service\",{\"1\":{\"668\":1,\"671\":1,\"672\":1,\"697\":1,\"699\":1,\"1054\":1,\"1055\":1,\"1056\":1,\"1057\":1,\"1059\":5,\"1117\":7,\"1119\":10,\"1278\":3,\"1288\":2,\"1291\":2}}],[\"servlet3\",{\"0\":{\"1079\":1,\"1080\":1}}],[\"servlet2\",{\"0\":{\"1067\":1,\"1068\":1}}],[\"servlet只有在被访问时才会加载\",{\"1\":{\"1064\":1}}],[\"servlet并不是专用于http协议通信\",{\"1\":{\"1053\":1}}],[\"servlet1\",{\"0\":{\"1051\":1}}],[\"servletwebrequest\",{\"1\":{\"626\":1}}],[\"servletresponse就是我们需要返回给浏览器的http响应报文实体类封装\",{\"1\":{\"1056\":1}}],[\"servletresponse\",{\"1\":{\"707\":2,\"708\":3,\"710\":1,\"711\":1,\"1054\":2,\"1057\":2,\"1058\":1,\"1059\":1,\"1102\":2,\"1103\":10,\"1104\":1}}],[\"servletrequest和servletresponse\",{\"1\":{\"1056\":1}}],[\"servletrequest\",{\"1\":{\"707\":2,\"708\":3,\"710\":1,\"711\":1,\"1054\":2,\"1056\":1,\"1057\":3,\"1059\":1,\"1102\":3,\"1103\":10,\"1104\":1}}],[\"servletrequestattributes\",{\"1\":{\"626\":1}}],[\"servletregistration\",{\"1\":{\"619\":1}}],[\"servletconfig\",{\"1\":{\"1054\":3}}],[\"servletconfigpropertyvalues\",{\"1\":{\"625\":1}}],[\"servletcontext全局唯一\",{\"1\":{\"1084\":1}}],[\"servletcontext对象\",{\"0\":{\"1084\":1}}],[\"servletcontextresourceloader\",{\"1\":{\"625\":1}}],[\"servletcontext\",{\"1\":{\"550\":2,\"705\":11,\"1084\":1,\"1086\":1}}],[\"servletcontainerinitializer\",{\"1\":{\"550\":2}}],[\"servletexception\",{\"1\":{\"550\":1,\"625\":3,\"626\":4,\"706\":2,\"707\":2,\"708\":3,\"710\":1,\"711\":2,\"712\":1,\"713\":1,\"1054\":2,\"1057\":1,\"1059\":5,\"1064\":2,\"1069\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":1,\"1103\":3,\"1104\":4}}],[\"servlet>\",{\"1\":{\"545\":1,\"548\":1,\"1054\":1}}],[\"servlet\",{\"0\":{\"1053\":1,\"1055\":1},\"1\":{\"545\":5,\"548\":3,\"619\":1,\"625\":2,\"787\":1,\"1053\":3,\"1054\":11,\"1055\":5,\"1058\":1,\"1059\":1}}],[\"serialversionuid\",{\"1\":{\"289\":1,\"290\":1,\"1104\":1}}],[\"serializable\",{\"1\":{\"182\":2,\"199\":1,\"215\":1,\"224\":1,\"288\":1,\"289\":1,\"290\":1,\"462\":1,\"782\":1,\"910\":1,\"1267\":1}}],[\"sealed主动放弃了密封特性\",{\"1\":{\"504\":1}}],[\"sealed类型\",{\"1\":{\"504\":4}}],[\"sealed或是non\",{\"1\":{\"504\":1}}],[\"sealed关键字同时出现\",{\"1\":{\"504\":1}}],[\"sealed写在原来final的位置\",{\"1\":{\"504\":1}}],[\"sealed\",{\"1\":{\"503\":1,\"504\":5}}],[\"sendredircet\",{\"1\":{\"1082\":1}}],[\"sendredirect\",{\"1\":{\"1082\":1,\"1084\":1,\"1091\":1,\"1093\":1,\"1096\":1,\"1104\":1}}],[\"senderror\",{\"1\":{\"1059\":2}}],[\"send\",{\"1\":{\"490\":3,\"1076\":1}}],[\"se\",{\"1\":{\"461\":1,\"1105\":1}}],[\"see\",{\"1\":{\"296\":1,\"324\":1,\"1047\":1,\"1260\":1}}],[\"seely\",{\"1\":{\"222\":3}}],[\"sex=男\",{\"1\":{\"1260\":1}}],[\"sex>\",{\"1\":{\"817\":1}}],[\"sex\",{\"1\":{\"161\":1,\"162\":1,\"166\":14,\"274\":1,\"278\":1,\"373\":2,\"375\":6,\"376\":2,\"377\":2,\"398\":1,\"799\":4,\"810\":9,\"826\":1,\"842\":3,\"854\":2,\"855\":2,\"1255\":1,\"1277\":1}}],[\"sequence\",{\"1\":{\"58\":1,\"509\":2}}],[\"setresourceloader\",{\"1\":{\"1327\":1}}],[\"setreceivebuffersize\",{\"1\":{\"721\":1}}],[\"setdefaultscope\",{\"1\":{\"1327\":1}}],[\"setdriverclassname\",{\"1\":{\"1260\":1,\"1276\":1}}],[\"setdatasource\",{\"1\":{\"671\":1,\"687\":1,\"1259\":1,\"1276\":1}}],[\"setdata\",{\"1\":{\"523\":2}}],[\"setdaemon\",{\"1\":{\"329\":3}}],[\"setjdbcurl\",{\"1\":{\"1260\":1,\"1276\":1}}],[\"setbeanclassloader\",{\"1\":{\"1186\":1}}],[\"setbeannamegenerator\",{\"1\":{\"1327\":1}}],[\"setbeanname\",{\"1\":{\"1186\":1}}],[\"setbeanproperty\",{\"1\":{\"841\":1}}],[\"set这类常用集合类包括数组在内\",{\"1\":{\"1136\":1}}],[\"setheader\",{\"1\":{\"1058\":1,\"1082\":1}}],[\"setformatter\",{\"1\":{\"921\":1,\"946\":1}}],[\"setuseparenthandlers\",{\"1\":{\"918\":1}}],[\"setusername\",{\"1\":{\"1260\":1,\"1276\":1}}],[\"setuseragebyid\",{\"1\":{\"863\":3}}],[\"setuserdetailsservice\",{\"1\":{\"666\":1}}],[\"setlazyinitialization\",{\"1\":{\"1327\":1}}],[\"setlastusedtimestamp\",{\"1\":{\"1246\":2,\"1247\":1}}],[\"setlist\",{\"1\":{\"1136\":1}}],[\"setlevel\",{\"1\":{\"912\":2,\"928\":2}}],[\"setlogimpl\",{\"1\":{\"904\":1}}],[\"setlogwriter\",{\"1\":{\"789\":1}}],[\"setenvironment\",{\"1\":{\"904\":1,\"1297\":1}}],[\"settings\",{\"1\":{\"1199\":1}}],[\"settings>\",{\"1\":{\"852\":1,\"1017\":1}}],[\"setteacher\",{\"1\":{\"1133\":1,\"1173\":1}}],[\"settemplateresolver\",{\"1\":{\"560\":1}}],[\"settemplateengine\",{\"1\":{\"560\":1}}],[\"setter注入\",{\"1\":{\"1181\":1}}],[\"setter依赖注入\",{\"1\":{\"1136\":1}}],[\"setter来为当前类的所有字段生成get\",{\"1\":{\"812\":1}}],[\"setter冗长\",{\"1\":{\"523\":1}}],[\"setter\",{\"1\":{\"523\":1,\"810\":1,\"812\":1,\"1175\":1,\"1181\":2}}],[\"set方法\",{\"1\":{\"810\":1,\"812\":1,\"1175\":1}}],[\"setkeepalive\",{\"1\":{\"721\":1}}],[\"setpassword\",{\"1\":{\"1260\":1,\"1276\":1}}],[\"setpasswordencoder\",{\"1\":{\"666\":1}}],[\"setparentbeanfactory\",{\"1\":{\"1298\":1}}],[\"setparent\",{\"1\":{\"625\":1}}],[\"setproperty\",{\"1\":{\"1244\":2}}],[\"setpropertyvalues\",{\"1\":{\"625\":1}}],[\"setprefix\",{\"1\":{\"560\":1}}],[\"setpriority\",{\"1\":{\"302\":1}}],[\"setmarkerinterface\",{\"1\":{\"1327\":1}}],[\"setmapperfactorybeanclass\",{\"1\":{\"1327\":1}}],[\"setmapper\",{\"1\":{\"1308\":1}}],[\"setmaxage\",{\"1\":{\"1092\":1,\"1093\":2}}],[\"setmultipartconfig\",{\"1\":{\"619\":1}}],[\"setmessage\",{\"1\":{\"523\":2}}],[\"setannotationclass\",{\"1\":{\"1327\":1}}],[\"setaddtoconfig\",{\"1\":{\"1327\":1}}],[\"setapplicationeventpublisher\",{\"1\":{\"1192\":1}}],[\"setautocommit\",{\"1\":{\"806\":6}}],[\"setauthentication\",{\"1\":{\"712\":1}}],[\"setauthenticationmanager\",{\"1\":{\"666\":1}}],[\"setage\",{\"1\":{\"615\":1,\"616\":1}}],[\"setattribute\",{\"1\":{\"582\":1,\"586\":1,\"625\":1,\"636\":1,\"1083\":1,\"1084\":1,\"1096\":1}}],[\"setaccessible\",{\"1\":{\"348\":1,\"349\":2,\"350\":4,\"462\":1}}],[\"setcheckouttimestamp\",{\"1\":{\"1246\":1}}],[\"setcharacterencoding\",{\"1\":{\"560\":2}}],[\"setcreatedtimestamp\",{\"1\":{\"1246\":1,\"1247\":1}}],[\"setcreatetableonstartup\",{\"1\":{\"687\":1}}],[\"setconnectiontypecode\",{\"1\":{\"1246\":1}}],[\"setcontextattribute\",{\"1\":{\"705\":1}}],[\"setcontenttype\",{\"1\":{\"620\":1,\"1059\":1,\"1064\":1,\"1072\":1,\"1074\":2,\"1075\":1,\"1076\":1}}],[\"setcode\",{\"1\":{\"523\":2}}],[\"setorder\",{\"1\":{\"560\":1}}],[\"setint\",{\"1\":{\"350\":1}}],[\"setvalue\",{\"1\":{\"213\":1,\"1204\":1}}],[\"set<beandefinitionholder>\",{\"1\":{\"1327\":2}}],[\"set<class<\",{\"1\":{\"550\":1}}],[\"set<map\",{\"1\":{\"213\":1}}],[\"set<k>\",{\"1\":{\"213\":1}}],[\"set<string>\",{\"1\":{\"205\":3,\"206\":1,\"475\":1}}],[\"set<e>\",{\"1\":{\"204\":1,\"224\":1}}],[\"set支持的功能其实也就和\",{\"1\":{\"204\":1}}],[\"set集合\",{\"1\":{\"204\":1}}],[\"setname\",{\"1\":{\"164\":2,\"324\":1,\"615\":1,\"616\":1,\"810\":1,\"897\":1,\"1149\":2}}],[\"set\",{\"0\":{\"204\":1},\"1\":{\"20\":3,\"181\":3,\"194\":1,\"204\":2,\"205\":13,\"206\":3,\"207\":13,\"224\":3,\"241\":1,\"319\":2,\"320\":1,\"350\":3,\"356\":1,\"475\":2,\"625\":1,\"706\":1,\"712\":1,\"755\":1,\"788\":3,\"796\":1,\"797\":1,\"799\":8,\"863\":1,\"1091\":2,\"1096\":2,\"1245\":1}}],[\"setsqlsessiontemplatebeanname\",{\"1\":{\"1327\":1}}],[\"setsqlsessiontemplate\",{\"1\":{\"1327\":1}}],[\"setsqlsessionfactorybeanname\",{\"1\":{\"1327\":1}}],[\"setsqlsessionfactory\",{\"1\":{\"1327\":1}}],[\"setscope\",{\"1\":{\"1296\":1}}],[\"setsid\",{\"1\":{\"810\":1}}],[\"setsavepoint\",{\"1\":{\"806\":1}}],[\"setstring\",{\"1\":{\"805\":2}}],[\"setstatus\",{\"1\":{\"378\":2,\"1059\":1,\"1082\":1}}],[\"setsex\",{\"1\":{\"810\":1,\"897\":1}}],[\"setsendbuffersize\",{\"1\":{\"721\":1}}],[\"setsessiontrackingmodes\",{\"1\":{\"705\":1}}],[\"setsotimeout\",{\"1\":{\"721\":1}}],[\"setsuffix\",{\"1\":{\"560\":1}}],[\"sets\",{\"1\":{\"20\":1}}],[\"s​=maxπ​∑a​π\",{\"1\":{\"58\":1}}],[\"sonatype\",{\"1\":{\"1008\":1}}],[\"so\",{\"1\":{\"789\":2}}],[\"sockethandler\",{\"1\":{\"918\":2}}],[\"socket2\",{\"0\":{\"724\":1,\"725\":1}}],[\"sockettimeoutexception\",{\"1\":{\"721\":1}}],[\"socket也被翻译为套接字\",{\"1\":{\"718\":1}}],[\"socket\",{\"0\":{\"718\":1,\"719\":1,\"726\":1,\"1343\":1},\"1\":{\"719\":8,\"720\":13,\"721\":10,\"726\":9,\"727\":7}}],[\"socket1\",{\"0\":{\"717\":1}}],[\"sourceencoding>\",{\"1\":{\"1002\":1}}],[\"sourceencoding>utf\",{\"1\":{\"1002\":1}}],[\"source>\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"source>17<\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"sources\",{\"1\":{\"995\":1}}],[\"source\",{\"1\":{\"363\":1,\"1181\":3,\"1192\":2,\"1283\":1}}],[\"sorted\",{\"1\":{\"228\":2,\"269\":1}}],[\"sort\",{\"1\":{\"171\":3,\"181\":2,\"432\":1,\"449\":3,\"451\":2,\"452\":1,\"631\":1}}],[\"soloving\",{\"1\":{\"92\":1}}],[\"solution\",{\"1\":{\"47\":2}}],[\"soft\",{\"0\":{\"86\":1},\"1\":{\"85\":1,\"86\":2,\"87\":1,\"884\":1}}],[\"someone\",{\"1\":{\"324\":1}}],[\"some\",{\"1\":{\"19\":1,\"116\":1,\"1181\":1}}],[\"sj​∣si​\",{\"1\":{\"46\":1}}],[\"say\",{\"1\":{\"799\":3}}],[\"savepoint\",{\"1\":{\"782\":1,\"806\":3}}],[\"savage\",{\"1\":{\"525\":1}}],[\"safari\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"safevarargs\",{\"1\":{\"361\":1}}],[\"same\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"samesite默认为lax\",{\"1\":{\"641\":1}}],[\"samesite是一种安全机制\",{\"1\":{\"641\":1}}],[\"samples\",{\"1\":{\"101\":1,\"142\":1,\"1211\":1}}],[\"sample\",{\"1\":{\"78\":1,\"99\":1,\"101\":1}}],[\"sampling\",{\"0\":{\"30\":1}}],[\"san\",{\"1\":{\"525\":1}}],[\"satic\",{\"1\":{\"373\":1}}],[\"satisfying\",{\"1\":{\"98\":1}}],[\"satisfaction\",{\"1\":{\"4\":1}}],[\"sa​\",{\"1\":{\"116\":2}}],[\"sarsa\",{\"0\":{\"116\":1,\"117\":1,\"118\":1,\"139\":1},\"1\":{\"115\":3,\"116\":1,\"123\":1}}],[\"sa\",{\"1\":{\"92\":2}}],[\"s0​\",{\"1\":{\"20\":2,\"112\":1}}],[\"s∈s​\",{\"1\":{\"135\":1}}],[\"s∈s\",{\"1\":{\"20\":1,\"63\":1,\"66\":2,\"113\":2}}],[\"sid=1\",{\"1\":{\"1260\":1}}],[\"sid=3\",{\"1\":{\"796\":1}}],[\"sid\",{\"1\":{\"769\":4,\"796\":1,\"799\":4,\"810\":9,\"826\":1,\"842\":2,\"854\":6,\"855\":2,\"1255\":2}}],[\"signed\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"sign\",{\"1\":{\"683\":1}}],[\"site\",{\"1\":{\"641\":1,\"727\":1,\"1091\":1,\"1096\":1}}],[\"simpleasynctaskexecutor\",{\"1\":{\"1188\":1}}],[\"simple\",{\"1\":{\"962\":1}}],[\"simpledateformat\",{\"1\":{\"948\":2,\"1076\":2}}],[\"simpleformatter\",{\"1\":{\"921\":1}}],[\"simplecontrollerhandleradapter和annotationmethodhandleradapter\",{\"1\":{\"625\":1}}],[\"simplest\",{\"0\":{\"24\":1}}],[\"size表示最大的缓存对象数量\",{\"1\":{\"884\":1}}],[\"size=\",{\"1\":{\"884\":1}}],[\"size++\",{\"1\":{\"182\":1}}],[\"size\",{\"1\":{\"180\":1,\"182\":6,\"204\":1,\"213\":1,\"224\":2,\"350\":2,\"490\":3,\"708\":1,\"710\":2,\"903\":1,\"1246\":1,\"1247\":1}}],[\"si​\",{\"1\":{\"19\":2,\"142\":2}}],[\"since\",{\"1\":{\"340\":1,\"1047\":1,\"1059\":1}}],[\"singletonfactories\",{\"1\":{\"1301\":3}}],[\"singletonfactory\",{\"1\":{\"1301\":3}}],[\"singletonobjects\",{\"1\":{\"1301\":4}}],[\"singletonobject\",{\"1\":{\"1301\":11}}],[\"singleton\",{\"1\":{\"1300\":2}}],[\"singletonlist\",{\"1\":{\"236\":1}}],[\"single\",{\"1\":{\"82\":1,\"154\":1,\"1047\":1,\"1119\":1}}],[\"sin\",{\"1\":{\"9\":1}}],[\"s=\",{\"1\":{\"19\":1}}],[\"styles\",{\"1\":{\"1181\":2}}],[\"stdoutimpl\",{\"1\":{\"904\":1}}],[\"stdout\",{\"1\":{\"852\":1,\"951\":2}}],[\"study<integer>\",{\"1\":{\"439\":1}}],[\"study<t>\",{\"1\":{\"439\":2}}],[\"study\",{\"1\":{\"376\":15,\"377\":2,\"378\":4,\"412\":6,\"413\":3,\"414\":18,\"415\":15,\"788\":1,\"796\":1,\"904\":1,\"1017\":1,\"1132\":1,\"1133\":1,\"1218\":1,\"1219\":1,\"1220\":1,\"1221\":1,\"1223\":2,\"1224\":3,\"1231\":3,\"1232\":1,\"1233\":2,\"1234\":1,\"1235\":2,\"1236\":2,\"1255\":1,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"studentaop\",{\"1\":{\"1218\":3,\"1220\":2,\"1224\":1,\"1231\":6,\"1233\":1}}],[\"studentfactory\",{\"1\":{\"1157\":1,\"1158\":1,\"1159\":8,\"1160\":2,\"1180\":1}}],[\"student类中的得到的就是这个bean的对象了\",{\"1\":{\"1133\":1}}],[\"student中的teacher成员变量\",{\"1\":{\"1132\":1}}],[\"student2\",{\"1\":{\"1129\":4}}],[\"student1\",{\"1\":{\"1129\":4}}],[\"studentlist\",{\"1\":{\"610\":3}}],[\"student\",{\"1\":{\"222\":14,\"343\":3,\"348\":15,\"349\":8,\"365\":2,\"373\":4,\"376\":2,\"377\":10,\"378\":6,\"412\":5,\"499\":12,\"528\":6,\"615\":6,\"616\":7,\"769\":4,\"780\":1,\"781\":2,\"788\":1,\"796\":3,\"799\":11,\"810\":3,\"826\":5,\"830\":2,\"842\":7,\"854\":2,\"855\":2,\"897\":5,\"1008\":5,\"1119\":8,\"1125\":5,\"1126\":8,\"1127\":8,\"1128\":5,\"1129\":8,\"1130\":1,\"1131\":2,\"1132\":2,\"1133\":9,\"1134\":3,\"1135\":3,\"1136\":5,\"1137\":4,\"1139\":2,\"1140\":2,\"1141\":2,\"1147\":2,\"1157\":4,\"1159\":4,\"1160\":4,\"1167\":6,\"1169\":4,\"1170\":3,\"1171\":3,\"1172\":5,\"1173\":2,\"1174\":1,\"1175\":1,\"1176\":3,\"1177\":1,\"1178\":12,\"1179\":2,\"1180\":3,\"1181\":11,\"1186\":2,\"1188\":6,\"1189\":4,\"1192\":1,\"1199\":1,\"1200\":3,\"1203\":6,\"1204\":1,\"1207\":3,\"1209\":3,\"1210\":1,\"1211\":6,\"1218\":2,\"1219\":1,\"1220\":1,\"1221\":2,\"1222\":2,\"1223\":2,\"1224\":3,\"1225\":7,\"1231\":5,\"1232\":1,\"1233\":3,\"1234\":1,\"1235\":1,\"1236\":1,\"1237\":1,\"1255\":3,\"1260\":1,\"1277\":1,\"1296\":2,\"1299\":1,\"1311\":1,\"1328\":3}}],[\"students\",{\"1\":{\"222\":2}}],[\"strategy\",{\"1\":{\"1181\":1}}],[\"strarray\",{\"1\":{\"522\":4}}],[\"strong>\",{\"1\":{\"643\":2}}],[\"stricthttpfirewall\",{\"1\":{\"709\":1}}],[\"striptrailing\",{\"1\":{\"488\":1}}],[\"stripleading\",{\"1\":{\"488\":1}}],[\"strip\",{\"1\":{\"488\":1}}],[\"stringutils\",{\"1\":{\"1327\":3}}],[\"string会被自动赋值为配置文件中对应属性的值\",{\"1\":{\"1199\":1}}],[\"stringprovider\",{\"1\":{\"994\":2}}],[\"stringify\",{\"1\":{\"610\":1}}],[\"stringclass\",{\"1\":{\"462\":2}}],[\"string底层数据存放的是byte\",{\"1\":{\"462\":1}}],[\"string的拼接会在编译时进行各种优化\",{\"1\":{\"402\":1}}],[\"stringbuilder\",{\"0\":{\"402\":1},\"1\":{\"402\":5,\"948\":2}}],[\"string类中刚好有一个\",{\"1\":{\"453\":1}}],[\"string类重载了equals方法用于判断和比较内容是否相同\",{\"1\":{\"401\":1}}],[\"string类的加载器\",{\"1\":{\"355\":1}}],[\"string本身也是一个类\",{\"1\":{\"401\":1}}],[\"string>\",{\"1\":{\"214\":4,\"221\":1,\"223\":3,\"1207\":1}}],[\"strings这个变量就是一个string\",{\"1\":{\"398\":1}}],[\"strings\",{\"1\":{\"171\":3,\"398\":3,\"401\":2,\"991\":1}}],[\"string\",{\"0\":{\"401\":1},\"1\":{\"161\":5,\"162\":3,\"164\":3,\"166\":14,\"171\":12,\"172\":8,\"173\":1,\"180\":1,\"182\":11,\"187\":5,\"191\":3,\"192\":1,\"193\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":7,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":6,\"247\":2,\"248\":4,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":4,\"277\":6,\"278\":3,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":3,\"289\":2,\"290\":3,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":2,\"329\":2,\"330\":2,\"331\":3,\"339\":4,\"340\":2,\"341\":2,\"343\":14,\"348\":6,\"349\":12,\"350\":3,\"355\":6,\"356\":9,\"363\":1,\"364\":7,\"365\":3,\"372\":1,\"375\":8,\"376\":4,\"377\":3,\"378\":5,\"384\":4,\"385\":1,\"386\":2,\"392\":1,\"393\":1,\"394\":1,\"395\":6,\"396\":1,\"397\":1,\"398\":8,\"399\":2,\"401\":18,\"402\":14,\"403\":4,\"408\":10,\"409\":3,\"410\":2,\"411\":2,\"412\":4,\"413\":1,\"414\":3,\"415\":8,\"422\":2,\"424\":4,\"425\":1,\"431\":2,\"432\":1,\"437\":6,\"438\":8,\"439\":3,\"445\":1,\"446\":1,\"447\":1,\"448\":3,\"449\":2,\"451\":1,\"452\":1,\"453\":6,\"454\":4,\"461\":1,\"462\":3,\"464\":4,\"468\":1,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":10,\"485\":3,\"487\":1,\"488\":5,\"490\":7,\"495\":3,\"496\":1,\"499\":4,\"500\":2,\"501\":6,\"504\":1,\"512\":1,\"518\":1,\"519\":3,\"521\":1,\"522\":11,\"523\":6,\"524\":2,\"525\":11,\"549\":1,\"552\":2,\"554\":1,\"560\":1,\"563\":2,\"569\":7,\"575\":4,\"579\":1,\"580\":1,\"581\":1,\"583\":2,\"585\":1,\"586\":1,\"587\":4,\"589\":12,\"599\":1,\"605\":2,\"612\":1,\"613\":1,\"615\":1,\"617\":4,\"619\":1,\"625\":1,\"626\":1,\"636\":5,\"658\":2,\"665\":4,\"666\":2,\"668\":2,\"669\":2,\"670\":1,\"672\":1,\"679\":2,\"692\":4,\"695\":1,\"697\":1,\"699\":1,\"705\":2,\"706\":1,\"719\":3,\"720\":3,\"726\":2,\"727\":2,\"789\":4,\"790\":1,\"796\":1,\"798\":1,\"799\":4,\"804\":1,\"805\":2,\"806\":4,\"810\":10,\"824\":2,\"826\":3,\"830\":1,\"835\":1,\"841\":5,\"842\":1,\"849\":3,\"853\":2,\"855\":2,\"860\":6,\"871\":1,\"898\":1,\"900\":4,\"902\":1,\"908\":1,\"910\":1,\"939\":2,\"944\":2,\"948\":2,\"950\":2,\"956\":1,\"991\":2,\"992\":1,\"994\":1,\"995\":2,\"1008\":2,\"1023\":1,\"1032\":1,\"1054\":1,\"1057\":1,\"1059\":4,\"1071\":4,\"1072\":3,\"1076\":1,\"1093\":2,\"1104\":1,\"1117\":1,\"1119\":3,\"1125\":1,\"1135\":3,\"1149\":4,\"1167\":4,\"1186\":1,\"1188\":1,\"1190\":2,\"1192\":1,\"1199\":1,\"1200\":4,\"1203\":5,\"1209\":1,\"1211\":1,\"1219\":2,\"1221\":1,\"1223\":2,\"1224\":5,\"1225\":1,\"1231\":1,\"1233\":1,\"1235\":2,\"1236\":1,\"1242\":2,\"1244\":8,\"1245\":3,\"1246\":2,\"1247\":2,\"1255\":2,\"1256\":1,\"1257\":1,\"1260\":1,\"1278\":1,\"1279\":6,\"1296\":3,\"1297\":1,\"1298\":3,\"1300\":4,\"1301\":2,\"1307\":4,\"1316\":3,\"1321\":1,\"1326\":3,\"1327\":3,\"1328\":3}}],[\"str5\",{\"1\":{\"402\":4}}],[\"str4\",{\"1\":{\"401\":2,\"402\":4}}],[\"str3\",{\"1\":{\"401\":2,\"402\":4}}],[\"str2\",{\"1\":{\"401\":3,\"402\":4}}],[\"str1\",{\"1\":{\"401\":3,\"402\":4}}],[\"structured\",{\"1\":{\"744\":1}}],[\"structure\",{\"1\":{\"324\":1}}],[\"stream等\",{\"1\":{\"994\":1}}],[\"stream可以由数组或集合创建\",{\"1\":{\"515\":1}}],[\"stream<integer>\",{\"1\":{\"519\":2}}],[\"stream<t>\",{\"1\":{\"516\":1}}],[\"stream<string>\",{\"1\":{\"488\":1,\"518\":1,\"519\":1}}],[\"stream<e>\",{\"1\":{\"180\":2,\"330\":1}}],[\"stream还新增了对数据的截断操作\",{\"1\":{\"479\":1}}],[\"stream流\",{\"0\":{\"227\":1,\"228\":1}}],[\"streamsupport\",{\"1\":{\"180\":2,\"330\":1}}],[\"stream\",{\"0\":{\"476\":1},\"1\":{\"180\":3,\"228\":11,\"266\":1,\"267\":2,\"284\":2,\"330\":1,\"356\":3,\"476\":1,\"477\":2,\"478\":2,\"479\":2,\"490\":3,\"513\":2,\"515\":1,\"516\":6,\"518\":3,\"519\":3,\"520\":1,\"521\":5,\"522\":7,\"528\":3,\"620\":2,\"720\":2,\"726\":3,\"1075\":2}}],[\"str\",{\"1\":{\"171\":1,\"182\":7,\"228\":5,\"253\":3,\"343\":4,\"349\":1,\"356\":3,\"401\":8,\"403\":5,\"453\":1,\"454\":11,\"480\":9,\"487\":1,\"488\":12,\"522\":2,\"589\":5,\"979\":2,\"991\":2,\"992\":1,\"994\":2,\"995\":4,\"1223\":1,\"1224\":4,\"1235\":5}}],[\"steady\",{\"1\":{\"135\":1}}],[\"step\",{\"0\":{\"117\":1},\"1\":{\"66\":2,\"79\":2,\"154\":1}}],[\"st+2​→at+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+2​→at+2​rt+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​=s\",{\"1\":{\"44\":2}}],[\"st+1​→at+1​rt+2​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​∣at+1​\",{\"1\":{\"20\":3}}],[\"st+1​\",{\"1\":{\"13\":1,\"112\":4,\"116\":2,\"119\":1,\"120\":1,\"138\":2,\"139\":1,\"140\":2}}],[\"st​→at​rt+1​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st​\",{\"1\":{\"20\":4,\"112\":12,\"116\":6,\"120\":5,\"136\":4,\"137\":4,\"138\":3,\"139\":2,\"140\":2,\"156\":1}}],[\"store\",{\"1\":{\"938\":1}}],[\"stochastic\",{\"0\":{\"100\":1},\"1\":{\"19\":1,\"53\":1,\"86\":1,\"92\":2}}],[\"stop\",{\"1\":{\"19\":1,\"299\":1,\"300\":1}}],[\"standard\",{\"1\":{\"962\":1}}],[\"stable\",{\"1\":{\"462\":1}}],[\"statistics\",{\"1\":{\"228\":4}}],[\"static等等\",{\"1\":{\"1219\":1}}],[\"static<t>\",{\"1\":{\"516\":1}}],[\"static\",{\"1\":{\"161\":3,\"162\":1,\"171\":6,\"172\":3,\"173\":1,\"180\":1,\"182\":12,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"215\":1,\"218\":1,\"221\":1,\"222\":2,\"223\":3,\"224\":1,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":4,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":5,\"277\":2,\"278\":3,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":2,\"289\":2,\"290\":3,\"295\":1,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":2,\"312\":10,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":4,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":4,\"339\":1,\"340\":3,\"341\":1,\"343\":9,\"348\":3,\"349\":3,\"350\":3,\"355\":3,\"356\":2,\"363\":1,\"364\":3,\"365\":2,\"372\":2,\"376\":3,\"377\":1,\"378\":8,\"384\":5,\"385\":1,\"386\":2,\"392\":1,\"393\":1,\"394\":1,\"395\":2,\"396\":1,\"397\":1,\"398\":1,\"399\":1,\"401\":3,\"402\":3,\"403\":2,\"408\":2,\"409\":2,\"411\":10,\"412\":3,\"413\":1,\"414\":4,\"415\":5,\"423\":3,\"424\":6,\"425\":1,\"431\":2,\"432\":1,\"437\":1,\"438\":3,\"439\":6,\"445\":1,\"446\":1,\"447\":1,\"448\":2,\"449\":3,\"451\":1,\"452\":1,\"453\":1,\"454\":4,\"461\":1,\"462\":1,\"464\":1,\"468\":1,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":6,\"485\":2,\"487\":1,\"488\":3,\"490\":4,\"495\":2,\"496\":1,\"500\":1,\"504\":1,\"512\":1,\"518\":1,\"519\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"525\":2,\"563\":1,\"564\":3,\"678\":2,\"681\":1,\"692\":1,\"693\":1,\"709\":1,\"719\":3,\"720\":2,\"726\":2,\"727\":2,\"789\":4,\"796\":1,\"798\":1,\"799\":1,\"805\":1,\"806\":4,\"824\":1,\"826\":1,\"830\":4,\"902\":1,\"904\":1,\"908\":1,\"910\":8,\"912\":2,\"950\":2,\"956\":4,\"980\":1,\"985\":1,\"994\":1,\"995\":2,\"1008\":1,\"1017\":2,\"1023\":2,\"1032\":1,\"1104\":1,\"1117\":1,\"1119\":3,\"1125\":1,\"1157\":1,\"1188\":1,\"1192\":1,\"1221\":1,\"1224\":1,\"1225\":1,\"1233\":1,\"1244\":1,\"1245\":1,\"1247\":2,\"1256\":1,\"1257\":1,\"1260\":1,\"1273\":1,\"1278\":1,\"1296\":3,\"1298\":5,\"1328\":1}}],[\"stationary\",{\"0\":{\"135\":1},\"1\":{\"135\":2,\"152\":1}}],[\"statrts的解释\",{\"0\":{\"84\":1}}],[\"status>\",{\"1\":{\"378\":1}}],[\"status\",{\"1\":{\"19\":1,\"378\":22,\"636\":2,\"747\":2,\"1047\":5,\"1076\":1}}],[\"statement除了执行这样的dql语句外\",{\"1\":{\"791\":1}}],[\"statement\",{\"1\":{\"788\":3,\"790\":1,\"796\":5,\"798\":5,\"804\":3,\"805\":5,\"806\":19,\"860\":6,\"871\":1,\"902\":1}}],[\"statevalue\",{\"1\":{\"136\":1}}],[\"states中\",{\"1\":{\"19\":1}}],[\"states中限制action\",{\"1\":{\"19\":1}}],[\"states的任务\",{\"1\":{\"19\":1}}],[\"states的trajectory\",{\"1\":{\"19\":1}}],[\"states\",{\"1\":{\"19\":1,\"20\":1}}],[\"state\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"58\":1,\"111\":1,\"132\":1,\"150\":1},\"1\":{\"13\":2,\"19\":6,\"20\":4,\"37\":1,\"40\":4,\"41\":4,\"42\":1,\"45\":1,\"47\":1,\"48\":6,\"49\":2,\"52\":1,\"55\":1,\"56\":1,\"63\":1,\"66\":2,\"68\":1,\"70\":2,\"71\":1,\"75\":1,\"77\":3,\"79\":3,\"81\":6,\"82\":1,\"84\":2,\"86\":1,\"92\":1,\"111\":1,\"113\":2,\"115\":2,\"131\":1,\"135\":1,\"148\":1,\"150\":2,\"155\":1,\"706\":1,\"1245\":1,\"1246\":17,\"1247\":8}}],[\"startupshutdownmonitor\",{\"1\":{\"1320\":1}}],[\"startupstep\",{\"1\":{\"1318\":1,\"1319\":1,\"1320\":2}}],[\"starttime\",{\"1\":{\"625\":1,\"626\":1}}],[\"starts\",{\"0\":{\"80\":1,\"83\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1}}],[\"starting\",{\"1\":{\"41\":1,\"48\":2,\"296\":1,\"1260\":2}}],[\"start\",{\"1\":{\"10\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"313\":2,\"318\":2,\"319\":2,\"320\":2,\"322\":6,\"324\":1,\"329\":3,\"331\":5,\"445\":1,\"446\":2,\"985\":2,\"1225\":1,\"1260\":2,\"1278\":1,\"1318\":1,\"1319\":1,\"1320\":2}}],[\"s\",{\"0\":{\"152\":1},\"1\":{\"9\":1,\"10\":1,\"11\":1,\"13\":5,\"20\":5,\"26\":4,\"27\":1,\"40\":2,\"41\":1,\"42\":1,\"44\":10,\"45\":7,\"46\":4,\"48\":13,\"49\":4,\"53\":3,\"55\":4,\"57\":2,\"63\":11,\"66\":13,\"75\":3,\"77\":9,\"78\":8,\"79\":4,\"82\":1,\"84\":6,\"87\":6,\"112\":2,\"113\":7,\"115\":2,\"116\":3,\"119\":1,\"120\":3,\"131\":2,\"132\":2,\"133\":3,\"134\":4,\"135\":8,\"136\":7,\"141\":5,\"142\":28,\"150\":6,\"152\":1,\"153\":8,\"154\":2,\"155\":12,\"156\":4,\"187\":4,\"191\":2,\"296\":1,\"340\":1,\"348\":1,\"349\":2,\"403\":4,\"454\":2,\"476\":2,\"480\":3,\"510\":2,\"511\":4,\"710\":1,\"712\":1,\"789\":1,\"824\":1,\"1047\":1}}],[\"q=0\",{\"1\":{\"727\":6,\"1091\":7,\"1096\":7}}],[\"ql\",{\"1\":{\"643\":2}}],[\"qq\",{\"1\":{\"349\":1,\"896\":1}}],[\"qualifier\",{\"1\":{\"1174\":1}}],[\"qualifier进行名称匹配\",{\"1\":{\"1174\":1}}],[\"qualifying\",{\"1\":{\"1119\":1}}],[\"quality\",{\"0\":{\"10\":1},\"1\":{\"4\":1}}],[\"question\",{\"1\":{\"1181\":1}}],[\"querying\",{\"1\":{\"841\":1}}],[\"query\",{\"1\":{\"744\":2,\"1245\":1}}],[\"queue\",{\"1\":{\"200\":5,\"202\":1,\"203\":14,\"324\":11,\"331\":8}}],[\"queue<object>\",{\"1\":{\"331\":1}}],[\"queue<integer>\",{\"1\":{\"203\":2}}],[\"queue<string>\",{\"1\":{\"200\":1,\"202\":1}}],[\"queue<e>\",{\"1\":{\"200\":1,\"201\":1}}],[\"quene\",{\"0\":{\"199\":1,\"200\":1}}],[\"q^​\",{\"1\":{\"142\":5}}],[\"qt​\",{\"1\":{\"116\":2,\"120\":1,\"156\":1}}],[\"qt+1​\",{\"1\":{\"116\":2,\"120\":2}}],[\"qπk​​\",{\"1\":{\"66\":1,\"77\":2,\"78\":2,\"79\":1}}],[\"qπ​\",{\"1\":{\"26\":2,\"48\":3,\"49\":1,\"75\":1,\"115\":1,\"155\":8,\"156\":4}}],[\"qac\",{\"0\":{\"24\":1},\"1\":{\"25\":1}}],[\"q\",{\"0\":{\"120\":1,\"124\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"11\":1,\"13\":2,\"14\":1,\"23\":1,\"49\":1,\"55\":1,\"57\":1,\"58\":1,\"77\":1,\"79\":1,\"81\":2,\"119\":2,\"120\":1,\"123\":1,\"124\":1,\"130\":1,\"141\":1}}],[\"qoe\",{\"1\":{\"4\":1}}],[\"usually\",{\"1\":{\"1181\":1}}],[\"using\",{\"1\":{\"1148\":1}}],[\"us\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"usecache\",{\"1\":{\"903\":1}}],[\"usecache=\",{\"1\":{\"886\":1}}],[\"usegeneratedkeys\",{\"1\":{\"897\":1}}],[\"usegeneratedkeys=\",{\"1\":{\"862\":1,\"897\":1}}],[\"use\",{\"1\":{\"750\":1,\"1047\":2}}],[\"userdetail\",{\"1\":{\"849\":2,\"850\":1,\"851\":2,\"901\":1}}],[\"userdetailsmanager\",{\"1\":{\"664\":1,\"665\":1,\"666\":2}}],[\"userdetails\",{\"1\":{\"658\":2,\"659\":2,\"665\":2,\"668\":2,\"672\":1,\"692\":1}}],[\"userdetailsservice\",{\"1\":{\"658\":2,\"659\":2,\"664\":1,\"665\":1,\"666\":1,\"668\":2,\"672\":1}}],[\"userdetailsservice就是获取用户信息的服务\",{\"1\":{\"658\":1}}],[\"user>\",{\"1\":{\"836\":1}}],[\"user类型或是map类型\",{\"1\":{\"836\":1}}],[\"user来创建用户\",{\"1\":{\"772\":1}}],[\"usermapper\",{\"1\":{\"670\":1,\"672\":1,\"1071\":2,\"1072\":2,\"1093\":2}}],[\"userexists\",{\"1\":{\"665\":1}}],[\"userbuilder\",{\"1\":{\"525\":7}}],[\"username+\",{\"1\":{\"804\":1,\"805\":1}}],[\"usernamepasswordauthenticationfilter\",{\"1\":{\"714\":1}}],[\"usernameparameter\",{\"1\":{\"680\":1}}],[\"usernamenotfoundexception\",{\"1\":{\"668\":2,\"672\":2,\"692\":2}}],[\"username=test\",{\"1\":{\"936\":1}}],[\"username=\",{\"1\":{\"525\":1,\"804\":2,\"805\":2,\"1047\":2}}],[\"username\",{\"1\":{\"501\":3,\"525\":12,\"574\":3,\"579\":2,\"580\":2,\"581\":2,\"583\":1,\"589\":2,\"617\":6,\"636\":3,\"658\":2,\"662\":6,\"665\":2,\"668\":2,\"669\":1,\"670\":3,\"672\":3,\"680\":1,\"682\":1,\"692\":4,\"804\":1,\"805\":1,\"824\":1,\"835\":2,\"898\":3,\"1017\":1,\"1069\":1,\"1071\":6,\"1072\":4,\"1093\":10,\"1242\":2,\"1244\":7,\"1245\":2,\"1246\":2,\"1255\":1}}],[\"user\",{\"1\":{\"464\":7,\"525\":10,\"583\":3,\"617\":6,\"658\":7,\"659\":7,\"664\":3,\"665\":2,\"670\":1,\"672\":1,\"692\":2,\"695\":1,\"697\":2,\"711\":1,\"727\":2,\"772\":2,\"789\":4,\"798\":2,\"804\":2,\"805\":2,\"806\":11,\"831\":3,\"832\":5,\"833\":3,\"834\":4,\"835\":5,\"836\":11,\"841\":9,\"843\":6,\"849\":2,\"850\":6,\"851\":3,\"852\":3,\"853\":5,\"855\":6,\"861\":4,\"862\":2,\"863\":3,\"864\":1,\"871\":3,\"873\":2,\"874\":2,\"876\":1,\"877\":8,\"886\":2,\"887\":2,\"895\":2,\"896\":4,\"897\":5,\"898\":3,\"899\":1,\"900\":3,\"901\":3,\"902\":6,\"903\":2,\"995\":1,\"1047\":1,\"1071\":2,\"1072\":4,\"1091\":2,\"1093\":3,\"1096\":9,\"1104\":5,\"1211\":1,\"1244\":1}}],[\"userservice\",{\"1\":{\"697\":1}}],[\"users\",{\"1\":{\"4\":2,\"619\":1,\"662\":3,\"871\":2,\"876\":1,\"877\":2,\"1047\":2,\"1071\":1}}],[\"used\",{\"1\":{\"296\":1,\"1181\":1}}],[\"uses\",{\"1\":{\"82\":1,\"467\":1}}],[\"uid\",{\"1\":{\"835\":2,\"853\":1,\"854\":1,\"898\":3}}],[\"uc\",{\"1\":{\"748\":1}}],[\"ua\",{\"1\":{\"727\":3,\"1096\":1}}],[\"uavn\",{\"1\":{\"13\":1}}],[\"uavs\",{\"1\":{\"4\":1,\"5\":1}}],[\"uav\",{\"0\":{\"3\":1,\"1333\":1},\"1\":{\"4\":1},\"2\":{\"16\":1}}],[\"url的格式为\",{\"1\":{\"1042\":1}}],[\"url>\",{\"1\":{\"1010\":1}}],[\"url=jdbc\",{\"1\":{\"936\":1}}],[\"url=\",{\"1\":{\"826\":1}}],[\"urlencoded\",{\"1\":{\"617\":1,\"636\":1,\"666\":1}}],[\"url\",{\"1\":{\"545\":1,\"714\":4,\"789\":9,\"804\":1,\"805\":1,\"806\":4,\"824\":1,\"1017\":1,\"1054\":4,\"1056\":1,\"1071\":1,\"1104\":5,\"1242\":1,\"1244\":2,\"1255\":1}}],[\"uri\",{\"1\":{\"490\":6}}],[\"urisyntaxexception\",{\"1\":{\"490\":4}}],[\"utf8\",{\"1\":{\"749\":2}}],[\"utf\",{\"1\":{\"545\":1,\"547\":1,\"549\":1,\"560\":2,\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"817\":2,\"824\":1,\"826\":1,\"1002\":1,\"1017\":1,\"1023\":1,\"1032\":1,\"1071\":1,\"1119\":1,\"1124\":1,\"1167\":1,\"1199\":1,\"1217\":1,\"1242\":1,\"1255\":1}}],[\"util包下定义的\",{\"1\":{\"180\":1}}],[\"util\",{\"1\":{\"180\":1,\"431\":2,\"432\":1,\"461\":1,\"508\":1,\"512\":1,\"522\":2,\"789\":3,\"908\":1,\"927\":1,\"939\":2,\"947\":1,\"951\":2,\"1047\":1}}],[\"u\",{\"1\":{\"403\":2,\"773\":1}}],[\"upgrade\",{\"1\":{\"691\":1,\"727\":1,\"1091\":1,\"1096\":1}}],[\"upload\",{\"1\":{\"619\":3}}],[\"uppercaseprinter\",{\"1\":{\"511\":2}}],[\"up\",{\"1\":{\"348\":1,\"349\":1,\"1148\":2,\"1181\":2}}],[\"updatetime\",{\"1\":{\"1076\":3}}],[\"updateagebyid\",{\"1\":{\"883\":2}}],[\"update>\",{\"1\":{\"863\":1}}],[\"updateuser\",{\"1\":{\"665\":1}}],[\"update\",{\"1\":{\"23\":1,\"63\":3,\"70\":2,\"744\":2,\"755\":1,\"781\":2,\"796\":1,\"860\":2,\"863\":1,\"884\":1}}],[\"u0​pu​π1\",{\"1\":{\"70\":1}}],[\"unknown\",{\"1\":{\"1246\":2,\"1283\":1}}],[\"unpooleddatasource\",{\"1\":{\"1244\":1,\"1245\":1}}],[\"unpooled\",{\"1\":{\"1242\":1}}],[\"unpkg\",{\"1\":{\"617\":2,\"636\":1,\"641\":1,\"642\":1}}],[\"unresolvable\",{\"1\":{\"1181\":1}}],[\"unsatisfied\",{\"1\":{\"1181\":2}}],[\"unsatisfieddependencyexception\",{\"1\":{\"1181\":1}}],[\"unsuccessfulauthentication\",{\"1\":{\"711\":2,\"713\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"182\":1,\"189\":1,\"446\":1,\"528\":2}}],[\"unwrapthrowable\",{\"1\":{\"841\":1,\"1247\":1}}],[\"unnecessary\",{\"1\":{\"788\":1}}],[\"uncommitted\",{\"1\":{\"782\":1,\"1267\":1}}],[\"unchained\",{\"1\":{\"525\":1}}],[\"unchecked\",{\"1\":{\"181\":1,\"217\":1,\"340\":1}}],[\"und\",{\"1\":{\"727\":1}}],[\"unmodifiablelist\",{\"1\":{\"236\":1}}],[\"unmanned\",{\"1\":{\"4\":1}}],[\"unaryoperator<e>\",{\"1\":{\"181\":1}}],[\"unique\",{\"1\":{\"662\":1,\"747\":2,\"748\":1,\"780\":1}}],[\"uniqueness\",{\"1\":{\"58\":1}}],[\"uniform\",{\"0\":{\"134\":1}}],[\"overdue\",{\"1\":{\"1246\":1}}],[\"override表示重写父类方法\",{\"1\":{\"360\":1}}],[\"override\",{\"1\":{\"171\":2,\"180\":1,\"193\":3,\"204\":1,\"241\":3,\"323\":1,\"324\":1,\"361\":1,\"363\":1,\"373\":3,\"375\":1,\"376\":1,\"377\":2,\"412\":2,\"413\":1,\"423\":1,\"439\":2,\"445\":1,\"449\":1,\"451\":1,\"464\":1,\"480\":1,\"499\":2,\"501\":1,\"523\":1,\"552\":3,\"564\":2,\"595\":3,\"596\":1,\"600\":5,\"601\":1,\"616\":1,\"619\":1,\"625\":1,\"652\":1,\"668\":1,\"672\":1,\"678\":2,\"692\":1,\"944\":2,\"1054\":5,\"1057\":1,\"1059\":1,\"1064\":2,\"1069\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":1,\"1103\":3,\"1104\":1,\"1105\":1,\"1132\":2,\"1160\":2,\"1180\":3,\"1186\":2,\"1191\":1,\"1192\":2,\"1231\":4,\"1296\":1,\"1297\":1,\"1307\":4,\"1311\":3,\"1319\":1,\"1320\":1,\"1321\":1,\"1328\":2}}],[\"ognl\",{\"1\":{\"873\":1}}],[\"our\",{\"1\":{\"789\":1}}],[\"outer>\",{\"1\":{\"817\":1}}],[\"outside\",{\"1\":{\"789\":1}}],[\"outofmemoryerror\",{\"1\":{\"421\":1}}],[\"out也是printstream\",{\"1\":{\"284\":1}}],[\"out就是一个printstream\",{\"1\":{\"284\":2}}],[\"output\",{\"1\":{\"249\":2,\"250\":1,\"251\":1,\"254\":1,\"270\":1,\"286\":1,\"288\":2,\"290\":2}}],[\"outputstreamwriter\",{\"1\":{\"283\":3,\"720\":4,\"727\":2}}],[\"outputstream\",{\"1\":{\"245\":1,\"249\":6,\"250\":3,\"251\":2,\"288\":3,\"290\":3,\"620\":1,\"720\":2,\"726\":1,\"1074\":5}}],[\"out\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"348\":2,\"349\":5,\"350\":4,\"355\":5,\"356\":2,\"365\":6,\"373\":2,\"375\":1,\"376\":2,\"377\":4,\"378\":1,\"384\":3,\"385\":1,\"386\":2,\"393\":1,\"394\":2,\"397\":1,\"398\":1,\"399\":1,\"401\":6,\"402\":3,\"403\":2,\"408\":5,\"409\":1,\"410\":1,\"411\":7,\"412\":3,\"413\":1,\"414\":3,\"415\":2,\"424\":3,\"431\":2,\"432\":1,\"438\":1,\"445\":1,\"446\":1,\"449\":2,\"451\":2,\"452\":1,\"454\":6,\"461\":1,\"462\":1,\"464\":1,\"474\":3,\"475\":2,\"476\":1,\"477\":2,\"478\":2,\"479\":2,\"480\":6,\"485\":1,\"488\":6,\"490\":3,\"497\":1,\"500\":1,\"501\":1,\"504\":1,\"510\":1,\"511\":2,\"512\":3,\"515\":1,\"518\":1,\"519\":1,\"521\":4,\"522\":5,\"531\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":1,\"586\":1,\"588\":1,\"589\":6,\"595\":3,\"599\":1,\"600\":4,\"605\":1,\"612\":1,\"613\":1,\"619\":1,\"636\":2,\"658\":1,\"659\":1,\"683\":1,\"697\":2,\"699\":2,\"719\":6,\"720\":9,\"721\":1,\"726\":1,\"727\":6,\"788\":1,\"789\":1,\"796\":1,\"799\":1,\"804\":1,\"805\":2,\"819\":1,\"826\":1,\"830\":1,\"832\":1,\"833\":1,\"834\":1,\"836\":3,\"841\":1,\"842\":2,\"843\":1,\"865\":2,\"883\":6,\"884\":2,\"888\":1,\"897\":1,\"918\":1,\"927\":2,\"930\":3,\"937\":1,\"938\":2,\"944\":3,\"950\":2,\"956\":4,\"973\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":2,\"980\":1,\"985\":3,\"986\":3,\"987\":3,\"988\":5,\"993\":2,\"994\":1,\"995\":2,\"1008\":1,\"1017\":2,\"1023\":1,\"1035\":1,\"1057\":4,\"1069\":1,\"1072\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1086\":1,\"1091\":1,\"1102\":1,\"1103\":5,\"1105\":1,\"1119\":2,\"1126\":2,\"1129\":2,\"1132\":2,\"1135\":2,\"1157\":2,\"1159\":1,\"1160\":1,\"1169\":1,\"1176\":2,\"1178\":2,\"1181\":1,\"1186\":2,\"1188\":4,\"1189\":1,\"1190\":1,\"1191\":1,\"1192\":1,\"1199\":1,\"1200\":1,\"1202\":2,\"1203\":4,\"1204\":2,\"1205\":1,\"1207\":2,\"1208\":2,\"1209\":2,\"1210\":1,\"1211\":4,\"1218\":2,\"1222\":1,\"1223\":2,\"1224\":7,\"1225\":2,\"1231\":5,\"1232\":1,\"1233\":1,\"1234\":2,\"1235\":3,\"1236\":2,\"1237\":2,\"1246\":1,\"1256\":1,\"1257\":1,\"1296\":4,\"1298\":4,\"1299\":1,\"1307\":3,\"1308\":3,\"1311\":3,\"1328\":3}}],[\"owner或db\",{\"1\":{\"744\":1}}],[\"owen\",{\"1\":{\"643\":1}}],[\"os\",{\"1\":{\"727\":1,\"938\":2,\"976\":3,\"979\":1}}],[\"o流进行网络数据传输\",{\"1\":{\"720\":1}}],[\"occurred\",{\"1\":{\"711\":1}}],[\"o+\",{\"1\":{\"403\":2}}],[\"oooo\",{\"1\":{\"403\":1}}],[\"o操作一般不能重复读取内容\",{\"1\":{\"265\":1}}],[\"o操作的并不是bufferedinputstream\",{\"1\":{\"264\":1}}],[\"o操作时\",{\"1\":{\"248\":1}}],[\"o设备的速度一般都达不到内存的读取速度\",{\"1\":{\"260\":1}}],[\"o设备去获取数据\",{\"1\":{\"260\":1}}],[\"oject类中的\",{\"1\":{\"241\":1}}],[\"oldestactiveconnection\",{\"1\":{\"1246\":9}}],[\"oldpassword\",{\"1\":{\"665\":1,\"666\":7}}],[\"oldthr\",{\"1\":{\"217\":4}}],[\"oldtab\",{\"1\":{\"217\":5}}],[\"oldcap\",{\"1\":{\"217\":5}}],[\"oldcapacity\",{\"1\":{\"182\":3}}],[\"oldvalue\",{\"1\":{\"216\":3}}],[\"o中介绍用途\",{\"1\":{\"182\":1}}],[\"o\",{\"1\":{\"172\":2,\"180\":3,\"181\":2,\"182\":3,\"201\":2,\"204\":3,\"213\":1,\"241\":10,\"403\":15,\"438\":1}}],[\"o2作为参数\",{\"1\":{\"451\":1}}],[\"o2\",{\"1\":{\"171\":5,\"313\":3,\"449\":2,\"451\":4}}],[\"o1作为目标对象\",{\"1\":{\"451\":1}}],[\"o1就行\",{\"1\":{\"171\":1}}],[\"o1\",{\"1\":{\"171\":5,\"313\":3,\"318\":5,\"449\":2,\"451\":4}}],[\"obtainfreshbeanfactory\",{\"1\":{\"1320\":1}}],[\"obtainvia来指定默认值的获取方式\",{\"1\":{\"812\":1}}],[\"obtained\",{\"1\":{\"41\":1}}],[\"obj\",{\"1\":{\"356\":5,\"372\":2,\"373\":4,\"392\":1,\"497\":2,\"499\":5,\"610\":3}}],[\"objectfactory\",{\"1\":{\"1301\":1}}],[\"objectfactory<\",{\"1\":{\"1301\":1}}],[\"object类中的\",{\"0\":{\"377\":1}}],[\"objectinputstream\",{\"1\":{\"288\":2,\"290\":2}}],[\"objective\",{\"1\":{\"134\":2,\"135\":1,\"141\":1,\"142\":1,\"148\":1}}],[\"objectoutputstream\",{\"1\":{\"288\":2,\"290\":2}}],[\"objectoutputstream不仅支持基本数据类型\",{\"1\":{\"287\":1}}],[\"object>\",{\"1\":{\"224\":1,\"833\":1,\"843\":1,\"937\":1}}],[\"objects\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1,\"241\":3,\"509\":1,\"1148\":2}}],[\"object\",{\"0\":{\"372\":1},\"1\":{\"172\":2,\"173\":2,\"180\":4,\"181\":4,\"182\":3,\"201\":2,\"204\":4,\"213\":5,\"224\":2,\"241\":4,\"296\":2,\"313\":4,\"318\":3,\"331\":1,\"340\":1,\"349\":3,\"356\":2,\"372\":4,\"373\":3,\"376\":2,\"377\":1,\"392\":1,\"393\":1,\"395\":5,\"421\":1,\"423\":2,\"424\":3,\"437\":4,\"438\":5,\"499\":2,\"595\":3,\"600\":4,\"609\":1,\"612\":4,\"613\":4,\"617\":6,\"626\":1,\"636\":4,\"658\":3,\"666\":3,\"799\":6,\"816\":1,\"841\":5,\"860\":3,\"1059\":2,\"1148\":1,\"1192\":1,\"1224\":7,\"1231\":9,\"1236\":1,\"1237\":2,\"1247\":4,\"1300\":6,\"1301\":5,\"1307\":8,\"1321\":1,\"1327\":1}}],[\"obsolete\",{\"1\":{\"324\":2}}],[\"obejctive\",{\"0\":{\"133\":1},\"1\":{\"136\":1}}],[\"others\",{\"1\":{\"1181\":1}}],[\"otherwise\",{\"1\":{\"1148\":1}}],[\"otherwise>\",{\"1\":{\"874\":1}}],[\"other\",{\"1\":{\"53\":1,\"1148\":1}}],[\"openconnection\",{\"1\":{\"1273\":1}}],[\"open和close用于控制起始和结束位置添加的符号\",{\"1\":{\"876\":1}}],[\"open=\",{\"1\":{\"876\":1}}],[\"opening\",{\"1\":{\"852\":1,\"1242\":1}}],[\"opensessionfromdatasource\",{\"1\":{\"1242\":2}}],[\"opensession\",{\"1\":{\"824\":1,\"826\":1,\"830\":1,\"842\":1,\"865\":2,\"871\":1,\"883\":2,\"1017\":1,\"1072\":1,\"1093\":1,\"1242\":1}}],[\"opens\",{\"1\":{\"466\":2}}],[\"open\",{\"1\":{\"466\":1,\"467\":1,\"1076\":1}}],[\"operation\",{\"1\":{\"228\":2,\"509\":11,\"1260\":1}}],[\"operator\",{\"1\":{\"181\":3}}],[\"option来进行配置\",{\"1\":{\"903\":1}}],[\"option是指当创建后\",{\"1\":{\"779\":1}}],[\"option\",{\"1\":{\"774\":2,\"779\":1,\"1181\":1}}],[\"options来控制单个操作的缓存启用\",{\"1\":{\"903\":1}}],[\"options注解\",{\"1\":{\"897\":1}}],[\"options等\",{\"1\":{\"714\":1}}],[\"options\",{\"1\":{\"714\":1,\"897\":1,\"903\":2,\"1059\":1}}],[\"optional>\",{\"1\":{\"1025\":4}}],[\"optional1\",{\"1\":{\"521\":2}}],[\"optional<t>\",{\"1\":{\"521\":1}}],[\"optional<integer>\",{\"1\":{\"512\":4,\"521\":2}}],[\"optional提供很多有用的方法\",{\"1\":{\"512\":1}}],[\"optional\",{\"1\":{\"454\":4,\"480\":4,\"512\":11,\"521\":3,\"1015\":1,\"1211\":1}}],[\"optional来了\",{\"1\":{\"454\":1}}],[\"optional类\",{\"0\":{\"454\":1}}],[\"optimization\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"optimality\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"119\":1}}],[\"optimal\",{\"0\":{\"53\":1,\"119\":1},\"1\":{\"52\":2,\"53\":1,\"120\":1}}],[\"opinion\",{\"1\":{\"5\":1}}],[\"oriented\",{\"1\":{\"1215\":1}}],[\"origin\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"originalchain\",{\"1\":{\"710\":1}}],[\"original\",{\"1\":{\"453\":4,\"709\":4,\"789\":1}}],[\"originalepisode\",{\"1\":{\"81\":1}}],[\"ordinary\",{\"1\":{\"816\":1}}],[\"order注释指定的值对测试方法进行数值排序\",{\"1\":{\"987\":1}}],[\"orderannotation\",{\"1\":{\"987\":1}}],[\"order越小\",{\"1\":{\"601\":1}}],[\"order\",{\"1\":{\"601\":3,\"764\":2,\"987\":1}}],[\"oracle\",{\"1\":{\"732\":1}}],[\"org\",{\"1\":{\"545\":1,\"547\":4,\"549\":7,\"563\":1,\"564\":1,\"705\":1,\"811\":1,\"824\":3,\"826\":2,\"841\":2,\"843\":2,\"873\":1,\"902\":1,\"995\":1,\"1002\":4,\"1017\":2,\"1023\":4,\"1032\":4,\"1047\":1,\"1071\":2,\"1119\":5,\"1167\":4,\"1181\":2,\"1211\":1,\"1217\":7,\"1218\":2,\"1219\":1,\"1220\":1,\"1223\":1,\"1224\":1,\"1231\":3,\"1232\":1,\"1233\":1,\"1234\":1,\"1235\":1,\"1236\":1,\"1242\":2,\"1254\":1,\"1255\":3,\"1257\":2,\"1259\":2,\"1260\":2,\"1276\":2,\"1278\":3,\"1283\":7}}],[\"orelse表示如果为空就返回里面的内容\",{\"1\":{\"454\":1}}],[\"orelse\",{\"1\":{\"454\":1,\"512\":2,\"521\":2}}],[\"or\",{\"1\":{\"19\":1,\"40\":1,\"92\":1,\"112\":1,\"135\":1,\"480\":1,\"763\":1,\"804\":2,\"805\":1,\"1047\":2,\"1059\":1,\"1104\":1,\"1181\":1,\"1190\":1,\"1296\":1}}],[\"oftype=\",{\"1\":{\"853\":1,\"854\":1}}],[\"of是java9的特性\",{\"1\":{\"834\":1}}],[\"ofinputstream\",{\"1\":{\"490\":1}}],[\"ofstring\",{\"1\":{\"490\":2}}],[\"of方法还被重载了很多次\",{\"1\":{\"475\":1}}],[\"ofnullable\",{\"1\":{\"454\":4,\"477\":1,\"480\":3,\"512\":2,\"1211\":1}}],[\"offerlast\",{\"1\":{\"201\":1}}],[\"offerfirst\",{\"1\":{\"201\":1}}],[\"offer\",{\"1\":{\"200\":3,\"203\":6,\"331\":1}}],[\"off\",{\"0\":{\"29\":1,\"31\":1,\"121\":1,\"123\":1,\"125\":1},\"1\":{\"123\":1,\"124\":1,\"912\":2}}],[\"of\",{\"0\":{\"10\":1,\"43\":1,\"44\":1,\"111\":1,\"115\":1,\"119\":1,\"132\":1},\"1\":{\"4\":3,\"10\":1,\"19\":4,\"20\":3,\"40\":1,\"41\":1,\"45\":2,\"58\":1,\"75\":1,\"81\":1,\"82\":1,\"92\":1,\"99\":1,\"119\":1,\"135\":1,\"142\":1,\"296\":1,\"475\":3,\"476\":1,\"477\":1,\"480\":1,\"509\":1,\"512\":2,\"516\":3,\"528\":6,\"708\":4,\"710\":1,\"788\":1,\"789\":1,\"834\":1,\"843\":1,\"871\":1,\"876\":1,\"877\":1,\"994\":1,\"995\":2,\"1047\":1,\"1115\":1,\"1119\":1,\"1148\":4,\"1181\":4,\"1207\":2,\"1209\":1,\"1300\":3}}],[\"onapplicationevent\",{\"1\":{\"1191\":1,\"1192\":1}}],[\"onauthenticationfailure\",{\"1\":{\"713\":1}}],[\"onauthenticationsuccess\",{\"1\":{\"712\":1}}],[\"onauthentication\",{\"1\":{\"711\":1}}],[\"on属性\",{\"1\":{\"1171\":1}}],[\"on=\",{\"1\":{\"1131\":1}}],[\"on来设定前置加载bean\",{\"1\":{\"1131\":1}}],[\"onreadystatechange\",{\"1\":{\"1076\":1}}],[\"onrefresh\",{\"1\":{\"625\":2,\"1320\":1}}],[\"onrefreshmonitor\",{\"1\":{\"625\":1}}],[\"only\",{\"1\":{\"1047\":1}}],[\"onlyifabsent\",{\"1\":{\"216\":2}}],[\"onwards\",{\"1\":{\"1047\":1}}],[\"one和\",{\"1\":{\"901\":1}}],[\"one\",{\"1\":{\"901\":2,\"1319\":1}}],[\"on进行左连接\",{\"1\":{\"769\":1}}],[\"on进行内连接\",{\"1\":{\"769\":1}}],[\"onclick=\",{\"1\":{\"617\":1,\"636\":1,\"666\":1,\"1076\":1}}],[\"onstartup\",{\"1\":{\"550\":1,\"705\":1}}],[\"on\",{\"0\":{\"121\":1,\"122\":1,\"126\":1},\"1\":{\"3\":1,\"123\":1,\"124\":1,\"140\":1,\"144\":1,\"509\":1,\"625\":1,\"662\":1,\"769\":3,\"774\":2,\"780\":2,\"781\":1,\"850\":1,\"853\":1,\"855\":2,\"1148\":1},\"2\":{\"16\":1}}],[\"fk\",{\"1\":{\"662\":1,\"748\":1}}],[\"fetch\",{\"1\":{\"617\":1,\"727\":4,\"1091\":4,\"1096\":4}}],[\"flushcachepolicy\",{\"1\":{\"903\":1}}],[\"flushcache\",{\"1\":{\"903\":1}}],[\"flushcache=\",{\"1\":{\"887\":1}}],[\"flushcache=true\",{\"1\":{\"884\":1}}],[\"flushinterval用于控制缓存刷新时间\",{\"1\":{\"884\":1}}],[\"flushinterval=\",{\"1\":{\"884\":1}}],[\"flushstatements\",{\"1\":{\"871\":1}}],[\"flush\",{\"1\":{\"249\":1,\"250\":1,\"254\":1,\"270\":1,\"288\":1,\"290\":1,\"720\":2,\"726\":2,\"727\":1}}],[\"flatmap\",{\"1\":{\"228\":1}}],[\"float用于存储单精度小数\",{\"1\":{\"746\":1}}],[\"float\",{\"1\":{\"215\":1,\"384\":2,\"991\":1}}],[\"fifo\",{\"1\":{\"884\":2}}],[\"firewallresponse\",{\"1\":{\"708\":5}}],[\"firewallrequest\",{\"1\":{\"708\":14}}],[\"firewall\",{\"1\":{\"708\":2,\"709\":1}}],[\"firewalledrequest\",{\"1\":{\"708\":1,\"710\":2}}],[\"firstinterceptor\",{\"1\":{\"601\":1}}],[\"first\",{\"1\":{\"81\":1,\"182\":1,\"789\":1}}],[\"fieldvaluetestbean\",{\"1\":{\"1211\":1}}],[\"fieldsource\",{\"1\":{\"995\":2}}],[\"field\",{\"1\":{\"350\":13,\"356\":3,\"462\":4}}],[\"filehandler\",{\"1\":{\"918\":2,\"920\":2,\"921\":1}}],[\"fileobj\",{\"1\":{\"619\":2}}],[\"fileoutputstream\",{\"1\":{\"245\":1,\"249\":4,\"250\":2,\"251\":2,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1,\"490\":2,\"726\":5,\"1075\":2}}],[\"filesystemxmlapplicationcontext\",{\"1\":{\"1297\":1}}],[\"fileservlet\",{\"1\":{\"1074\":1,\"1075\":1}}],[\"filesizethreshold\",{\"1\":{\"619\":1}}],[\"files\",{\"1\":{\"267\":1,\"480\":1,\"1047\":2,\"1199\":1}}],[\"file\",{\"1\":{\"255\":19,\"619\":5,\"819\":1,\"826\":1,\"841\":1,\"1047\":3,\"1074\":2,\"1075\":5,\"1181\":2}}],[\"filenotfoundexception\",{\"1\":{\"247\":1,\"285\":1,\"423\":2,\"824\":1,\"826\":1,\"830\":1}}],[\"filewriter\",{\"1\":{\"245\":1,\"252\":1,\"254\":2,\"270\":1,\"938\":1}}],[\"filereader\",{\"1\":{\"245\":1,\"252\":1,\"253\":4,\"269\":3,\"937\":1}}],[\"fileinputstream\",{\"1\":{\"245\":1,\"247\":4,\"248\":6,\"251\":2,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"283\":1,\"285\":1,\"286\":1,\"288\":1,\"290\":1,\"356\":2,\"620\":1,\"726\":4,\"826\":1,\"830\":1,\"939\":1}}],[\"fill\",{\"1\":{\"235\":1,\"264\":1,\"432\":1}}],[\"filter也有对应的httpfilter专用类\",{\"1\":{\"1104\":1}}],[\"filters\",{\"1\":{\"708\":7,\"709\":2}}],[\"filterstreamdemo\",{\"1\":{\"518\":1}}],[\"filtername\",{\"1\":{\"705\":3}}],[\"filtertarget\",{\"1\":{\"699\":1}}],[\"filterobject代表集合中每个元素\",{\"1\":{\"699\":1}}],[\"filterobject\",{\"1\":{\"699\":2}}],[\"filterchainvalidator\",{\"1\":{\"709\":1}}],[\"filterchaindecorator\",{\"1\":{\"708\":3,\"709\":4}}],[\"filterchainproxy的dofilter方法又在干什么\",{\"1\":{\"708\":1}}],[\"filterchainproxy\",{\"1\":{\"707\":1,\"708\":3,\"709\":3,\"710\":5}}],[\"filterchain\",{\"1\":{\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"707\":6,\"708\":6,\"709\":4,\"711\":2,\"712\":1,\"1102\":2,\"1103\":11,\"1104\":3}}],[\"filter\",{\"0\":{\"1100\":1,\"1101\":1},\"1\":{\"180\":3,\"228\":4,\"476\":1,\"518\":1,\"706\":4,\"707\":2,\"708\":1,\"710\":2,\"939\":3,\"1102\":1,\"1103\":1}}],[\"finishrefresh\",{\"1\":{\"1320\":1}}],[\"finishbeanfactoryinitialization\",{\"1\":{\"1320\":1,\"1321\":1}}],[\"finest\",{\"1\":{\"910\":4,\"912\":2,\"928\":1}}],[\"finer\",{\"1\":{\"910\":4}}],[\"fine\",{\"1\":{\"910\":4,\"912\":1}}],[\"finduserbyname\",{\"1\":{\"670\":1,\"672\":1,\"692\":1}}],[\"findwebapplicationcontext\",{\"1\":{\"625\":1,\"706\":1}}],[\"finding\",{\"1\":{\"92\":1,\"104\":1,\"110\":1}}],[\"final字段无法生成set方法\",{\"1\":{\"812\":1}}],[\"final类型\",{\"1\":{\"393\":1,\"504\":1}}],[\"final的status类型成员变量\",{\"1\":{\"378\":1}}],[\"final的\",{\"1\":{\"376\":1}}],[\"finalize\",{\"1\":{\"372\":1}}],[\"finally\",{\"1\":{\"247\":1,\"324\":1,\"424\":1,\"531\":4,\"626\":2,\"1242\":1,\"1320\":1}}],[\"final\",{\"1\":{\"172\":3,\"180\":1,\"181\":1,\"182\":2,\"215\":3,\"216\":1,\"217\":1,\"222\":3,\"224\":1,\"284\":1,\"289\":1,\"290\":1,\"324\":2,\"331\":1,\"340\":1,\"350\":1,\"372\":6,\"374\":2,\"378\":5,\"396\":1,\"408\":2,\"409\":1,\"410\":1,\"413\":3,\"447\":1,\"462\":2,\"499\":2,\"503\":1,\"504\":2,\"524\":1,\"625\":2,\"626\":3,\"705\":1,\"709\":1,\"910\":7,\"912\":2,\"939\":4,\"1104\":1,\"1134\":1,\"1135\":1,\"1181\":1,\"1200\":2,\"1203\":1,\"1245\":5,\"1247\":6,\"1273\":1,\"1296\":1}}],[\"fixeddelay\",{\"1\":{\"1190\":2}}],[\"fixedrate\",{\"1\":{\"1190\":3,\"1192\":1}}],[\"fixation\",{\"1\":{\"642\":1}}],[\"fix\",{\"1\":{\"58\":1}}],[\"fa\",{\"1\":{\"683\":1}}],[\"fas\",{\"1\":{\"683\":1}}],[\"fastjsonhttpmessageconverter\",{\"1\":{\"616\":1}}],[\"fastjson2<\",{\"1\":{\"611\":1,\"616\":1}}],[\"fastremove\",{\"1\":{\"182\":1}}],[\"fast\",{\"1\":{\"58\":1}}],[\"failed\",{\"1\":{\"625\":1,\"626\":2,\"713\":4,\"789\":1}}],[\"failurehandler\",{\"1\":{\"713\":1}}],[\"failurecause\",{\"1\":{\"626\":1}}],[\"failure\",{\"1\":{\"524\":2,\"713\":1}}],[\"fair\",{\"1\":{\"10\":1}}],[\"factorybean是一个能生产或者修饰生成对象的工厂bean\",{\"1\":{\"1328\":1}}],[\"factorybeanobjecttype\",{\"1\":{\"1327\":1}}],[\"factorybean<t>\",{\"1\":{\"1327\":1}}],[\"factorybean<student>\",{\"1\":{\"1160\":1,\"1180\":1,\"1328\":1}}],[\"factorybean相当于为普通的bean添加了一层外壳\",{\"1\":{\"1327\":1}}],[\"factorychild\",{\"1\":{\"1298\":7}}],[\"factoryparent\",{\"1\":{\"1298\":4}}],[\"factory\",{\"1\":{\"819\":2,\"871\":1,\"1017\":3,\"1072\":3,\"1093\":1,\"1119\":1,\"1158\":1,\"1159\":2,\"1181\":1,\"1254\":2,\"1296\":7,\"1321\":1}}],[\"factor\",{\"1\":{\"215\":1,\"217\":1}}],[\"false\",{\"1\":{\"180\":2,\"182\":1,\"216\":1,\"241\":2,\"286\":1,\"296\":1,\"324\":1,\"373\":2,\"425\":1,\"499\":2,\"520\":2,\"580\":1,\"581\":1,\"585\":1,\"586\":1,\"600\":1,\"626\":1,\"631\":1,\"636\":1,\"686\":1,\"806\":5,\"865\":2,\"884\":2,\"886\":1,\"903\":2,\"918\":1,\"972\":1,\"1140\":1,\"1170\":1,\"1180\":1,\"1246\":1,\"1279\":1,\"1300\":1,\"1310\":2}}],[\"f\",{\"1\":{\"58\":4,\"101\":3,\"104\":1,\"228\":1,\"255\":2,\"798\":1}}],[\"fully\",{\"1\":{\"1300\":1}}],[\"fulltest\",{\"1\":{\"780\":1}}],[\"furthermore\",{\"1\":{\"1181\":1}}],[\"further\",{\"1\":{\"1148\":1,\"1260\":1}}],[\"func3\",{\"1\":{\"956\":2,\"959\":1}}],[\"func2\",{\"1\":{\"956\":2,\"959\":1}}],[\"func1\",{\"1\":{\"956\":2,\"959\":2}}],[\"functionality\",{\"1\":{\"1047\":1}}],[\"functionalinterface\",{\"1\":{\"296\":1,\"361\":1,\"447\":2}}],[\"function包中\",{\"1\":{\"508\":1}}],[\"function\",{\"0\":{\"130\":1,\"133\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"40\":1,\"58\":1,\"130\":1,\"134\":2,\"135\":1,\"136\":1,\"141\":1,\"142\":1,\"147\":1,\"148\":1,\"398\":1,\"453\":1,\"519\":1,\"617\":3,\"636\":1,\"660\":1,\"666\":1,\"1076\":2}}],[\"fun\",{\"1\":{\"480\":2}}],[\"fundamental\",{\"1\":{\"52\":1}}],[\"future\",{\"0\":{\"44\":1},\"1\":{\"45\":1}}],[\"frame\",{\"1\":{\"714\":1}}],[\"frameworkservlet\",{\"1\":{\"626\":2}}],[\"framework\",{\"1\":{\"4\":1,\"1113\":1,\"1211\":1,\"1219\":1,\"1278\":1,\"1283\":2}}],[\"francisco\",{\"1\":{\"525\":1}}],[\"free\",{\"0\":{\"75\":1},\"1\":{\"45\":1,\"76\":1,\"77\":1}}],[\"from子句\",{\"1\":{\"744\":1}}],[\"fromindex\",{\"1\":{\"181\":1}}],[\"from\",{\"1\":{\"41\":1,\"48\":2,\"324\":1,\"378\":1,\"670\":1,\"756\":2,\"762\":5,\"764\":2,\"765\":1,\"766\":4,\"767\":3,\"768\":1,\"769\":2,\"770\":2,\"774\":1,\"779\":2,\"780\":1,\"781\":1,\"788\":1,\"789\":1,\"796\":1,\"804\":2,\"805\":2,\"826\":1,\"831\":2,\"833\":1,\"834\":1,\"835\":1,\"836\":2,\"841\":1,\"842\":3,\"843\":2,\"850\":1,\"851\":2,\"852\":2,\"853\":1,\"854\":2,\"855\":4,\"864\":1,\"873\":1,\"874\":1,\"876\":2,\"886\":1,\"887\":1,\"895\":1,\"896\":1,\"898\":1,\"899\":1,\"900\":1,\"901\":2,\"902\":3,\"903\":1,\"1047\":1,\"1071\":1,\"1246\":2,\"1255\":1}}],[\"four\",{\"1\":{\"1047\":1}}],[\"found\",{\"1\":{\"789\":2,\"841\":1,\"843\":1,\"1119\":1,\"1260\":1,\"1283\":1,\"1327\":1,\"1331\":1}}],[\"followed\",{\"1\":{\"509\":2}}],[\"following\",{\"1\":{\"19\":1,\"1047\":2}}],[\"fooooood\",{\"1\":{\"403\":1}}],[\"foooood\",{\"1\":{\"403\":1}}],[\"food\",{\"1\":{\"403\":1}}],[\"foem\",{\"1\":{\"55\":1}}],[\"forceautoproxycreatortoexposeproxy\",{\"1\":{\"1310\":1}}],[\"forceautoproxycreatortouseclassproxying\",{\"1\":{\"1310\":1}}],[\"foreign\",{\"1\":{\"662\":1,\"747\":2,\"748\":1}}],[\"foreach>\",{\"1\":{\"876\":1,\"877\":1}}],[\"foreach操作\",{\"1\":{\"875\":1}}],[\"foreach操作的顺序\",{\"1\":{\"330\":1}}],[\"foreach语法遍历每一个元素\",{\"1\":{\"192\":1}}],[\"foreach\",{\"1\":{\"192\":5,\"193\":2,\"222\":2,\"228\":1,\"269\":1,\"330\":1,\"394\":1,\"476\":1,\"477\":2,\"478\":2,\"479\":2,\"488\":1,\"518\":1,\"519\":1,\"826\":1,\"830\":1,\"842\":1,\"1069\":1,\"1208\":1}}],[\"foreachremaining\",{\"1\":{\"189\":1}}],[\"forgery\",{\"1\":{\"641\":1}}],[\"forbeanpropertyaccess\",{\"1\":{\"625\":1}}],[\"forward\",{\"1\":{\"587\":1,\"1083\":2,\"1084\":1,\"1093\":1}}],[\"forkjoinpool\",{\"1\":{\"516\":1}}],[\"forname\",{\"1\":{\"339\":1,\"349\":3,\"788\":1}}],[\"forallw\",{\"1\":{\"98\":1}}],[\"foralls∈s\",{\"1\":{\"79\":1}}],[\"fortheother∣a\",{\"1\":{\"87\":1}}],[\"formatter=com\",{\"1\":{\"947\":1}}],[\"formatter\",{\"1\":{\"939\":5,\"944\":1}}],[\"format\",{\"1\":{\"710\":1,\"712\":1,\"944\":2,\"948\":3,\"1059\":1,\"1076\":1}}],[\"formlogin\",{\"1\":{\"680\":1}}],[\"form>\",{\"1\":{\"619\":1,\"636\":1,\"641\":1,\"660\":1,\"682\":1,\"683\":1,\"1069\":1,\"1075\":1}}],[\"formulation\",{\"0\":{\"105\":1}}],[\"form\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"47\":1,\"49\":2,\"55\":1,\"58\":1,\"63\":1,\"66\":2,\"617\":1,\"619\":1,\"620\":1,\"636\":1,\"666\":1,\"902\":1,\"1069\":1,\"1075\":2}}],[\"for\",{\"1\":{\"4\":2,\"20\":1,\"53\":2,\"58\":1,\"181\":1,\"182\":1,\"187\":2,\"191\":1,\"192\":1,\"193\":1,\"216\":1,\"255\":1,\"295\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"318\":1,\"324\":1,\"329\":2,\"340\":1,\"343\":5,\"349\":1,\"365\":2,\"394\":3,\"398\":1,\"399\":1,\"401\":1,\"431\":1,\"478\":1,\"480\":1,\"490\":3,\"708\":1,\"748\":1,\"781\":2,\"789\":4,\"799\":1,\"819\":1,\"836\":1,\"871\":2,\"876\":1,\"877\":1,\"1047\":6,\"1054\":2,\"1091\":1,\"1093\":1,\"1181\":2,\"1199\":1,\"1246\":1,\"1260\":1,\"1283\":1,\"1301\":1,\"1321\":1}}],[\"fs\",{\"1\":{\"10\":1}}],[\"fs​+l\",{\"1\":{\"10\":1}}],[\"fc​是载波频率\",{\"1\":{\"9\":1}}],[\"nt\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"ns\",{\"1\":{\"545\":3}}],[\"nice\",{\"1\":{\"498\":3}}],[\"nd\",{\"1\":{\"488\":1}}],[\"nc\",{\"1\":{\"488\":1}}],[\"n换行符进行切割\",{\"1\":{\"488\":2}}],[\"n个字符\",{\"1\":{\"571\":1}}],[\"n个类型变量\",{\"1\":{\"438\":1}}],[\"n个\",{\"1\":{\"363\":1}}],[\"nanotime\",{\"1\":{\"1205\":1}}],[\"nanos\",{\"1\":{\"372\":1}}],[\"navigate\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"nagocoler\",{\"1\":{\"619\":1}}],[\"nativemethodaccessorimpl\",{\"1\":{\"1278\":3}}],[\"native\",{\"1\":{\"300\":1,\"340\":1,\"372\":7,\"421\":1,\"1278\":1}}],[\"namegenerator\",{\"1\":{\"1327\":1}}],[\"name值\",{\"1\":{\"1133\":1}}],[\"name属性表示该注册的bean对应的对象的指定属性\",{\"1\":{\"1133\":1}}],[\"name属性就是为这个bean设定一个独一无二的名称\",{\"1\":{\"1127\":1}}],[\"names\",{\"1\":{\"993\":1}}],[\"namespace=\",{\"1\":{\"826\":1,\"842\":1}}],[\"name=penguin\",{\"1\":{\"1260\":1}}],[\"name=企鹅\",{\"1\":{\"1197\":1}}],[\"name=test\",{\"1\":{\"936\":1}}],[\"name=小明\",{\"1\":{\"852\":1}}],[\"name=\",{\"1\":{\"619\":1,\"636\":2,\"641\":2,\"660\":1,\"682\":3,\"683\":1,\"686\":1,\"824\":4,\"832\":1,\"852\":1,\"894\":1,\"951\":2,\"1017\":8,\"1069\":2,\"1071\":4,\"1075\":1,\"1093\":1,\"1119\":1,\"1127\":4,\"1128\":2,\"1131\":2,\"1133\":8,\"1134\":3,\"1135\":1,\"1136\":4,\"1137\":3,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1149\":3,\"1150\":4,\"1151\":2,\"1159\":1,\"1172\":3,\"1211\":1,\"1242\":4,\"1255\":4}}],[\"name>lbwnb<\",{\"1\":{\"1086\":1}}],[\"name>jsp<\",{\"1\":{\"1054\":1}}],[\"name>default<\",{\"1\":{\"1054\":1}}],[\"name>test<\",{\"1\":{\"1054\":2}}],[\"name>contextconfiglocation<\",{\"1\":{\"548\":1}}],[\"name>\",{\"1\":{\"545\":2,\"548\":2,\"817\":1,\"818\":1,\"1010\":1,\"1054\":4,\"1086\":1}}],[\"name>mvc<\",{\"1\":{\"545\":2,\"548\":1}}],[\"name+\",{\"1\":{\"464\":1}}],[\"named\",{\"1\":{\"340\":1,\"979\":2,\"1047\":1}}],[\"name\",{\"1\":{\"161\":3,\"162\":2,\"164\":7,\"166\":14,\"172\":4,\"222\":5,\"241\":15,\"274\":1,\"278\":1,\"288\":5,\"289\":4,\"290\":5,\"297\":1,\"324\":2,\"331\":4,\"340\":1,\"343\":1,\"348\":5,\"349\":5,\"356\":2,\"373\":2,\"375\":6,\"376\":2,\"377\":2,\"378\":5,\"398\":1,\"408\":14,\"409\":4,\"410\":4,\"411\":2,\"437\":4,\"438\":4,\"464\":4,\"499\":12,\"525\":1,\"563\":3,\"569\":1,\"575\":2,\"610\":8,\"612\":2,\"613\":2,\"706\":1,\"747\":2,\"796\":1,\"799\":4,\"810\":9,\"826\":1,\"835\":1,\"841\":10,\"849\":1,\"850\":2,\"851\":2,\"852\":1,\"853\":3,\"854\":2,\"855\":9,\"861\":3,\"862\":2,\"871\":1,\"877\":3,\"896\":2,\"897\":4,\"898\":2,\"900\":6,\"938\":1,\"1008\":1,\"1057\":3,\"1085\":1,\"1092\":1,\"1133\":1,\"1135\":5,\"1149\":10,\"1150\":1,\"1151\":1,\"1167\":3,\"1170\":1,\"1181\":3,\"1186\":1,\"1199\":2,\"1200\":9,\"1203\":8,\"1204\":1,\"1208\":1,\"1209\":2,\"1210\":1,\"1211\":6,\"1255\":1,\"1277\":1,\"1300\":7}}],[\"norollbackforclassname\",{\"1\":{\"1279\":1}}],[\"norollbackfor\",{\"1\":{\"1279\":1}}],[\"normal\",{\"1\":{\"780\":1}}],[\"noproviders\",{\"1\":{\"1260\":1}}],[\"nop\",{\"1\":{\"1260\":1}}],[\"nouniquebeandefinitionexception\",{\"1\":{\"1119\":1}}],[\"noargsconstructor来快速生成全参构造和无参构造\",{\"1\":{\"812\":1}}],[\"nobody\",{\"1\":{\"789\":1}}],[\"no\",{\"1\":{\"706\":1,\"708\":1,\"789\":2,\"841\":1,\"951\":1,\"1119\":1,\"1148\":1,\"1181\":2,\"1245\":1,\"1260\":2,\"1283\":1,\"1327\":1}}],[\"nohandlerfound\",{\"1\":{\"626\":1}}],[\"nosuchfieldexception\",{\"1\":{\"350\":1,\"462\":1}}],[\"nosuchmethodexception\",{\"1\":{\"348\":1,\"349\":1,\"350\":1,\"365\":1}}],[\"nonnull的成员字段\",{\"1\":{\"812\":1}}],[\"none\",{\"1\":{\"727\":1}}],[\"nonematch\",{\"1\":{\"520\":1}}],[\"non\",{\"1\":{\"324\":1,\"504\":4,\"1059\":1,\"1104\":1,\"1181\":1}}],[\"nom\",{\"1\":{\"302\":1}}],[\"notnull\",{\"1\":{\"1318\":2}}],[\"notempty\",{\"1\":{\"1319\":1}}],[\"note\",{\"1\":{\"1047\":1}}],[\"notation\",{\"1\":{\"609\":1}}],[\"notifyall\",{\"1\":{\"331\":1,\"372\":1,\"1247\":1}}],[\"notifyall其实和notify一样\",{\"1\":{\"318\":1}}],[\"notify\",{\"1\":{\"318\":4,\"372\":1}}],[\"not\",{\"1\":{\"296\":1,\"509\":1,\"662\":5,\"727\":1,\"747\":3,\"748\":1,\"749\":1,\"763\":3,\"789\":2,\"843\":1,\"1047\":5,\"1059\":2,\"1096\":1,\"1148\":2,\"1246\":3,\"1296\":1,\"1300\":1,\"1318\":2,\"1331\":1}}],[\"nodelist\",{\"1\":{\"819\":4}}],[\"node<k\",{\"1\":{\"215\":3,\"216\":3,\"217\":4,\"218\":2}}],[\"node<e>\",{\"1\":{\"182\":7}}],[\"node\",{\"1\":{\"182\":1,\"217\":1,\"819\":4}}],[\"novel\",{\"1\":{\"4\":1}}],[\"nullandemptysource\",{\"1\":{\"992\":1}}],[\"nullable\",{\"1\":{\"550\":1,\"1296\":1,\"1300\":4,\"1301\":1,\"1316\":2,\"1327\":2}}],[\"nullsource和\",{\"1\":{\"992\":1}}],[\"nullsource\",{\"1\":{\"992\":1}}],[\"nullvalues\",{\"1\":{\"987\":1}}],[\"nullfilterchainvalidator\",{\"1\":{\"709\":1}}],[\"nullpointerexception\",{\"1\":{\"424\":3,\"509\":1,\"512\":1,\"528\":1,\"789\":1,\"911\":1}}],[\"null\",{\"1\":{\"161\":1,\"182\":1,\"214\":1,\"216\":10,\"217\":3,\"221\":1,\"241\":2,\"247\":2,\"264\":4,\"284\":1,\"296\":1,\"373\":1,\"386\":1,\"424\":1,\"439\":2,\"454\":1,\"477\":2,\"480\":4,\"495\":1,\"509\":1,\"512\":3,\"528\":2,\"625\":5,\"626\":6,\"631\":1,\"636\":2,\"662\":5,\"668\":1,\"672\":1,\"692\":1,\"705\":2,\"706\":4,\"707\":1,\"708\":2,\"711\":1,\"712\":1,\"747\":6,\"748\":1,\"789\":13,\"799\":2,\"939\":3,\"987\":1,\"1054\":1,\"1072\":1,\"1093\":6,\"1096\":1,\"1104\":1,\"1116\":1,\"1117\":1,\"1211\":1,\"1242\":2,\"1244\":3,\"1246\":7,\"1247\":1,\"1273\":2,\"1296\":1,\"1297\":2,\"1300\":7,\"1301\":5,\"1310\":1,\"1318\":3}}],[\"numberguess\",{\"1\":{\"1211\":2}}],[\"number>\",{\"1\":{\"172\":3,\"173\":1}}],[\"numbers\",{\"1\":{\"75\":1}}],[\"number\",{\"1\":{\"10\":1,\"172\":1,\"173\":2,\"343\":1,\"437\":1}}],[\"n→∞lim​n1​e\",{\"1\":{\"154\":2}}],[\"never级别表示此方法不应该加入到任何事务中\",{\"1\":{\"1284\":1}}],[\"need\",{\"1\":{\"1047\":1,\"1148\":1}}],[\"nested级别表示如果存在外层事务\",{\"1\":{\"1284\":1}}],[\"nested\",{\"1\":{\"988\":2}}],[\"nestedservletexception\",{\"1\":{\"626\":2}}],[\"net\",{\"1\":{\"721\":1,\"726\":1,\"1190\":1}}],[\"netbian\",{\"1\":{\"490\":4}}],[\"network\",{\"1\":{\"142\":5,\"144\":1}}],[\"networks\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"142\":1}}],[\"nextelement\",{\"1\":{\"1057\":1}}],[\"nextfilter\",{\"1\":{\"710\":3}}],[\"nextline\",{\"1\":{\"531\":1,\"720\":1,\"804\":2,\"805\":2}}],[\"nextintscanner\",{\"1\":{\"531\":1}}],[\"nextint方法可以指定创建0\",{\"1\":{\"431\":1}}],[\"nextint\",{\"1\":{\"431\":1,\"531\":2,\"963\":1,\"990\":1}}],[\"nextindex\",{\"1\":{\"194\":1}}],[\"nextindex++\",{\"1\":{\"190\":1}}],[\"nextthreadnum\",{\"1\":{\"296\":1}}],[\"next\",{\"1\":{\"180\":1,\"181\":2,\"182\":4,\"187\":1,\"189\":3,\"190\":5,\"191\":1,\"193\":1,\"194\":1,\"215\":1,\"216\":2,\"218\":2,\"788\":1,\"797\":1,\"799\":2,\"804\":1,\"805\":1}}],[\"newconn\",{\"1\":{\"1247\":5}}],[\"newcap\",{\"1\":{\"217\":5}}],[\"newcapacity\",{\"1\":{\"182\":6}}],[\"newexecutor\",{\"1\":{\"1242\":1}}],[\"newestimatevt+1​\",{\"1\":{\"112\":1}}],[\"newdocumentbuilder\",{\"1\":{\"819\":1}}],[\"new表和old表\",{\"1\":{\"781\":1}}],[\"newpassword\",{\"1\":{\"665\":1,\"666\":7}}],[\"newbuilder\",{\"1\":{\"490\":3,\"524\":1}}],[\"newhttpclient\",{\"1\":{\"490\":4}}],[\"newhelloworld\",{\"1\":{\"461\":2}}],[\"newinputstream\",{\"1\":{\"480\":1}}],[\"newinstance\",{\"1\":{\"348\":4,\"349\":3,\"356\":2,\"799\":1,\"819\":1}}],[\"newline\",{\"1\":{\"270\":1}}],[\"newlist\",{\"1\":{\"236\":2}}],[\"newoutputstream\",{\"1\":{\"267\":1}}],[\"newtransaction\",{\"1\":{\"1242\":1}}],[\"newtasksmaybescheduled\",{\"1\":{\"324\":2}}],[\"newtab\",{\"1\":{\"217\":2}}],[\"newthr\",{\"1\":{\"217\":4}}],[\"newnode\",{\"1\":{\"216\":2}}],[\"newarr\",{\"1\":{\"171\":2}}],[\"new\",{\"1\":{\"161\":3,\"162\":1,\"171\":4,\"172\":3,\"173\":1,\"180\":1,\"182\":13,\"189\":1,\"193\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"217\":2,\"221\":1,\"222\":10,\"223\":3,\"224\":2,\"228\":7,\"233\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":6,\"247\":2,\"248\":5,\"249\":2,\"250\":1,\"251\":3,\"253\":3,\"254\":1,\"255\":4,\"262\":2,\"264\":1,\"265\":4,\"266\":3,\"267\":2,\"269\":6,\"270\":2,\"275\":1,\"277\":1,\"283\":4,\"284\":2,\"285\":3,\"286\":4,\"288\":5,\"290\":5,\"296\":1,\"297\":2,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":11,\"313\":4,\"318\":3,\"319\":3,\"320\":3,\"322\":4,\"323\":2,\"324\":4,\"329\":3,\"330\":2,\"331\":10,\"339\":1,\"341\":1,\"343\":1,\"350\":1,\"356\":3,\"373\":4,\"376\":2,\"377\":1,\"378\":1,\"384\":4,\"385\":1,\"386\":1,\"392\":5,\"393\":1,\"394\":1,\"395\":4,\"398\":1,\"401\":4,\"402\":2,\"408\":7,\"409\":1,\"410\":1,\"412\":4,\"413\":1,\"415\":2,\"423\":6,\"424\":3,\"431\":1,\"432\":1,\"437\":1,\"438\":5,\"439\":2,\"445\":2,\"446\":3,\"449\":3,\"451\":3,\"452\":2,\"453\":2,\"464\":1,\"475\":1,\"480\":1,\"490\":5,\"501\":2,\"512\":3,\"515\":1,\"518\":1,\"519\":1,\"522\":5,\"523\":2,\"524\":2,\"525\":2,\"528\":6,\"531\":1,\"552\":3,\"560\":3,\"561\":1,\"563\":1,\"569\":2,\"572\":1,\"573\":1,\"574\":3,\"576\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"585\":2,\"586\":1,\"588\":2,\"596\":1,\"599\":1,\"600\":2,\"601\":2,\"605\":1,\"612\":1,\"613\":2,\"615\":1,\"616\":2,\"617\":2,\"619\":2,\"620\":1,\"625\":3,\"626\":4,\"631\":1,\"636\":1,\"652\":1,\"658\":2,\"659\":2,\"664\":3,\"666\":4,\"671\":1,\"672\":1,\"687\":1,\"692\":1,\"699\":1,\"705\":3,\"708\":1,\"709\":6,\"712\":1,\"719\":3,\"720\":10,\"721\":3,\"726\":7,\"727\":3,\"781\":1,\"788\":1,\"789\":6,\"796\":1,\"799\":3,\"804\":1,\"805\":1,\"824\":1,\"826\":2,\"830\":2,\"877\":3,\"897\":1,\"902\":1,\"904\":5,\"910\":7,\"911\":1,\"912\":2,\"919\":1,\"920\":1,\"921\":2,\"929\":1,\"937\":2,\"938\":1,\"939\":1,\"946\":1,\"948\":3,\"963\":1,\"990\":2,\"991\":1,\"1008\":1,\"1017\":3,\"1059\":2,\"1072\":2,\"1075\":1,\"1076\":3,\"1091\":1,\"1093\":2,\"1104\":1,\"1117\":1,\"1119\":3,\"1125\":1,\"1132\":2,\"1148\":1,\"1157\":1,\"1159\":1,\"1160\":1,\"1166\":2,\"1167\":1,\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":2,\"1174\":2,\"1176\":1,\"1178\":1,\"1180\":1,\"1188\":1,\"1192\":3,\"1202\":1,\"1203\":2,\"1209\":1,\"1221\":1,\"1224\":3,\"1225\":4,\"1233\":1,\"1242\":1,\"1244\":2,\"1245\":2,\"1246\":4,\"1247\":2,\"1254\":2,\"1256\":1,\"1257\":1,\"1259\":2,\"1260\":2,\"1276\":3,\"1277\":1,\"1278\":1,\"1281\":1,\"1282\":1,\"1283\":1,\"1288\":1,\"1296\":7,\"1297\":1,\"1298\":8,\"1299\":1,\"1318\":4,\"1321\":1,\"1327\":1,\"1328\":2}}],[\"n=0∑∞​βnrt+n​\",{\"1\":{\"13\":1}}],[\"n∈n=\",{\"1\":{\"13\":1}}],[\"n∈1\",{\"1\":{\"8\":1}}],[\"n0​为用户所在位置的加性高斯白噪声\",{\"1\":{\"9\":1}}],[\"n\",{\"0\":{\"117\":1},\"1\":{\"8\":2,\"11\":1,\"13\":2,\"70\":1,\"71\":1,\"142\":1,\"216\":6,\"398\":1,\"403\":12,\"531\":2,\"720\":4,\"727\":2,\"733\":2,\"746\":2,\"1327\":1}}],[\"tx\",{\"1\":{\"1242\":4}}],[\"txt\",{\"1\":{\"248\":6,\"249\":2,\"250\":1,\"251\":2,\"253\":2,\"254\":1,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"285\":1,\"286\":2,\"288\":2,\"290\":2,\"726\":2}}],[\"tcp是传输层协议\",{\"1\":{\"1042\":1}}],[\"tcp协议实际上是经历了三次握手再进行通信\",{\"1\":{\"1042\":1}}],[\"tcp发送缓冲区\",{\"1\":{\"721\":1}}],[\"tcp接收缓冲区\",{\"1\":{\"721\":1}}],[\"tcp在传输过程中\",{\"1\":{\"721\":1}}],[\"title\",{\"1\":{\"853\":3}}],[\"title>\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1}}],[\"timeservlet\",{\"1\":{\"1076\":1}}],[\"time存储时间\",{\"1\":{\"746\":1}}],[\"timed\",{\"1\":{\"721\":1}}],[\"timeoutstring\",{\"1\":{\"1279\":1}}],[\"timeout>\",{\"1\":{\"1097\":1}}],[\"timeout>1<\",{\"1\":{\"1097\":1}}],[\"timeout=20\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"timeout\",{\"1\":{\"372\":2,\"1279\":2}}],[\"timerthread继承自thread\",{\"1\":{\"324\":1}}],[\"timerthread\",{\"1\":{\"324\":2}}],[\"timertask\",{\"1\":{\"322\":3,\"323\":1,\"324\":2}}],[\"timer\",{\"1\":{\"323\":4,\"324\":15}}],[\"timerlooptask\",{\"1\":{\"322\":3}}],[\"time\",{\"1\":{\"10\":1,\"81\":1,\"322\":5,\"1076\":4,\"1082\":1,\"1083\":2,\"1084\":2,\"1091\":3,\"1093\":1,\"1096\":3}}],[\"tupian\",{\"1\":{\"490\":2}}],[\"t会根据使用时提供的类型自动变成对应类型\",{\"1\":{\"438\":1}}],[\"tmp\",{\"1\":{\"248\":3,\"251\":3}}],[\"t2\",{\"1\":{\"241\":4,\"304\":2,\"305\":2,\"311\":2,\"312\":4,\"313\":2,\"318\":2,\"319\":2}}],[\"t1\",{\"1\":{\"241\":5,\"304\":2,\"305\":3,\"311\":2,\"312\":4,\"313\":2,\"318\":2,\"319\":2}}],[\"typecheckonly\",{\"1\":{\"1300\":2}}],[\"typealiases>\",{\"1\":{\"832\":2,\"1017\":1}}],[\"type=\",{\"1\":{\"619\":2,\"636\":4,\"641\":2,\"660\":2,\"666\":2,\"682\":4,\"683\":2,\"686\":1,\"817\":1,\"824\":2,\"832\":1,\"835\":1,\"841\":1,\"849\":1,\"850\":1,\"851\":1,\"853\":1,\"854\":1,\"855\":2,\"898\":1,\"1017\":2,\"1069\":2,\"1071\":2,\"1075\":1,\"1093\":1,\"1135\":1,\"1242\":3,\"1255\":2,\"1273\":1}}],[\"type1\",{\"1\":{\"343\":9}}],[\"types\",{\"1\":{\"343\":6}}],[\"typevariableimpl\",{\"1\":{\"343\":3}}],[\"type\",{\"1\":{\"222\":5,\"340\":4,\"343\":20,\"364\":4,\"365\":1,\"577\":1,\"617\":1,\"636\":1,\"666\":1,\"714\":1,\"902\":1,\"993\":8,\"1015\":1,\"1058\":1,\"1091\":1,\"1096\":1,\"1119\":1,\"1167\":1,\"1279\":1,\"1310\":1,\"1326\":1,\"1327\":1}}],[\"t>\",{\"1\":{\"192\":1,\"193\":1,\"509\":1}}],[\"t=0∑∞​γtrt+1​\",{\"1\":{\"151\":1}}],[\"t=0\",{\"1\":{\"112\":1,\"116\":1}}],[\"td\",{\"0\":{\"111\":1,\"114\":1,\"115\":1,\"119\":1,\"127\":1,\"138\":1},\"1\":{\"113\":1,\"138\":1,\"142\":1,\"156\":1}}],[\"t∈rn\",{\"1\":{\"46\":2}}],[\"t∈r2×1\",{\"1\":{\"8\":2}}],[\"tag\",{\"1\":{\"1319\":1}}],[\"taobao\",{\"1\":{\"403\":2}}],[\"taohai\",{\"1\":{\"222\":3}}],[\"taskcomponent\",{\"1\":{\"1192\":1}}],[\"taskfired\",{\"1\":{\"324\":1}}],[\"taskqueue\",{\"1\":{\"324\":2}}],[\"task\",{\"1\":{\"322\":6,\"324\":2,\"1190\":1,\"1192\":1,\"1225\":5}}],[\"tasks转换成continuing\",{\"1\":{\"19\":1}}],[\"tasks\",{\"1\":{\"19\":3,\"324\":2}}],[\"tab\",{\"1\":{\"216\":8}}],[\"tabular\",{\"1\":{\"130\":1}}],[\"table来删除一个表\",{\"1\":{\"752\":1}}],[\"table来进行修改\",{\"1\":{\"751\":1}}],[\"table来找出对应q\",{\"1\":{\"13\":1}}],[\"table语句来创建一张表\",{\"1\":{\"750\":1}}],[\"table过大\",{\"1\":{\"14\":1}}],[\"table\",{\"1\":{\"13\":2,\"215\":1,\"216\":1,\"217\":2,\"662\":2,\"748\":1,\"750\":1,\"751\":1,\"752\":1}}],[\"table管理\",{\"1\":{\"13\":1}}],[\"target>\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"target>17<\",{\"1\":{\"1002\":1,\"1032\":1}}],[\"targetbeanname\",{\"1\":{\"706\":5}}],[\"target=\",{\"1\":{\"641\":1}}],[\"target限定为只能作用于方法上\",{\"1\":{\"363\":1}}],[\"target\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":2,\"142\":4,\"296\":2,\"362\":1,\"363\":3,\"364\":4,\"365\":2,\"706\":1,\"1167\":1,\"1181\":1,\"1219\":2,\"1231\":3,\"1279\":1,\"1310\":1,\"1326\":1}}],[\"takewhile\",{\"1\":{\"479\":1}}],[\"take\",{\"1\":{\"86\":1,\"296\":1,\"331\":4}}],[\"taking\",{\"1\":{\"48\":1}}],[\"tel\",{\"1\":{\"1208\":1}}],[\"teach\",{\"1\":{\"769\":4,\"1132\":4}}],[\"teacherb\",{\"1\":{\"1174\":1}}],[\"teachera\",{\"1\":{\"1174\":1}}],[\"teacher2\",{\"1\":{\"1140\":1,\"1141\":1}}],[\"teacher属性是在构造方法中完成的初始化\",{\"1\":{\"1134\":1}}],[\"teacher\",{\"1\":{\"376\":7,\"1131\":3,\"1132\":8,\"1133\":8,\"1134\":7,\"1137\":2,\"1140\":1,\"1141\":1,\"1171\":1,\"1172\":9,\"1173\":8,\"1174\":6,\"1175\":2,\"1179\":6,\"1181\":14}}],[\"template\",{\"1\":{\"1256\":2}}],[\"templateresolver\",{\"1\":{\"560\":1}}],[\"temp目录\",{\"1\":{\"1047\":1}}],[\"temporal\",{\"0\":{\"109\":1}}],[\"ten\",{\"1\":{\"386\":1}}],[\"text=\",{\"1\":{\"563\":1,\"605\":1}}],[\"text+\",{\"1\":{\"356\":1,\"720\":2}}],[\"text\",{\"1\":{\"356\":3,\"446\":1,\"460\":2,\"461\":1,\"462\":1,\"465\":2,\"473\":6,\"475\":1,\"485\":3,\"494\":1,\"498\":2,\"500\":2,\"501\":2,\"504\":2,\"515\":1,\"534\":2,\"535\":1,\"536\":1,\"540\":1,\"541\":1,\"550\":1,\"553\":1,\"554\":1,\"558\":3,\"575\":8,\"577\":1,\"589\":4,\"593\":1,\"614\":1,\"617\":1,\"619\":1,\"620\":1,\"625\":1,\"626\":1,\"630\":1,\"631\":3,\"636\":3,\"641\":1,\"642\":2,\"643\":1,\"652\":1,\"658\":1,\"659\":2,\"660\":2,\"664\":2,\"666\":2,\"682\":2,\"683\":1,\"686\":2,\"708\":1,\"720\":1,\"727\":1,\"841\":1,\"842\":1,\"849\":1,\"850\":2,\"853\":1,\"855\":1,\"871\":2,\"876\":1,\"877\":1,\"882\":1,\"883\":2,\"884\":1,\"888\":1,\"897\":1,\"920\":1,\"930\":1,\"948\":1,\"956\":1,\"958\":1,\"959\":2,\"960\":1,\"961\":1,\"963\":1,\"969\":1,\"973\":1,\"974\":1,\"976\":1,\"986\":2,\"988\":1,\"1001\":1,\"1009\":1,\"1036\":1,\"1047\":3,\"1058\":1,\"1059\":1,\"1064\":1,\"1069\":1,\"1072\":1,\"1075\":1,\"1076\":1,\"1091\":3,\"1095\":1,\"1096\":2,\"1101\":1,\"1103\":2,\"1105\":1,\"1109\":1,\"1116\":2,\"1117\":1,\"1118\":2,\"1119\":3,\"1125\":1,\"1126\":1,\"1133\":2,\"1140\":1,\"1151\":1,\"1152\":1,\"1158\":1,\"1159\":1,\"1172\":1,\"1181\":2,\"1188\":2,\"1189\":1,\"1191\":1,\"1192\":1,\"1215\":1,\"1220\":1,\"1221\":1,\"1222\":1,\"1224\":1,\"1225\":1,\"1231\":1,\"1242\":1,\"1256\":1,\"1260\":1,\"1268\":1,\"1269\":1,\"1270\":1,\"1271\":1,\"1280\":1,\"1295\":2,\"1301\":3,\"1318\":1}}],[\"testfb\",{\"1\":{\"1328\":1}}],[\"testfilter2\",{\"1\":{\"1103\":1}}],[\"testfilter\",{\"1\":{\"1102\":1}}],[\"testdefinitionprocessor\",{\"1\":{\"1311\":1}}],[\"testevent\",{\"1\":{\"1192\":5}}],[\"testexception\",{\"1\":{\"422\":4}}],[\"testlistener\",{\"1\":{\"1105\":1,\"1191\":1,\"1192\":1}}],[\"testutils\",{\"1\":{\"1023\":2}}],[\"testserviceimpl\",{\"1\":{\"1277\":1,\"1278\":2,\"1281\":1,\"1308\":4}}],[\"testservice\",{\"1\":{\"1277\":2,\"1278\":2,\"1281\":1,\"1288\":2,\"1291\":1,\"1308\":1}}],[\"testservlet<\",{\"1\":{\"1054\":1}}],[\"testservlet\",{\"1\":{\"1054\":1,\"1059\":1,\"1064\":1}}],[\"tests\",{\"1\":{\"995\":2}}],[\"testsqlbuilder\",{\"1\":{\"902\":2}}],[\"testconfiguration\",{\"1\":{\"1278\":1,\"1288\":1,\"1291\":1,\"1328\":1}}],[\"testcondition\",{\"1\":{\"980\":2}}],[\"testclassorder来控制嵌套类的执行顺序\",{\"1\":{\"988\":1}}],[\"testing\",{\"1\":{\"1047\":1}}],[\"testinstance\",{\"1\":{\"986\":2}}],[\"testimpl\",{\"1\":{\"467\":2}}],[\"testmain\",{\"1\":{\"986\":2,\"1288\":1,\"1291\":1}}],[\"testmapper明明是一个我们自己定义接口啊\",{\"1\":{\"842\":1}}],[\"testmapper\",{\"1\":{\"826\":2,\"841\":1,\"842\":9,\"843\":2,\"861\":1,\"865\":6,\"871\":2,\"877\":2,\"883\":6,\"884\":4,\"888\":2,\"894\":1,\"895\":1,\"896\":1,\"903\":1,\"1017\":5,\"1255\":2,\"1256\":4,\"1257\":2,\"1260\":2,\"1277\":2,\"1281\":1,\"1308\":2}}],[\"testtemplate方法时\",{\"1\":{\"980\":1}}],[\"test3\",{\"1\":{\"959\":1,\"987\":1}}],[\"test注解或是其他标记junit测试案例的注解\",{\"1\":{\"1035\":1}}],[\"test注解\",{\"1\":{\"959\":1}}],[\"test注解即可快速创建新的测试用例\",{\"1\":{\"959\":1}}],[\"test1\",{\"1\":{\"959\":2,\"961\":1,\"963\":1,\"969\":1,\"974\":1,\"976\":1,\"977\":1,\"978\":1,\"979\":2,\"980\":1,\"985\":1,\"986\":2,\"987\":1,\"988\":3,\"990\":1,\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"995\":2,\"1063\":1,\"1224\":3}}],[\"test=123\",{\"1\":{\"1091\":2,\"1096\":1}}],[\"test=\",{\"1\":{\"873\":1,\"874\":2,\"902\":2}}],[\"test2\",{\"1\":{\"855\":2,\"959\":1,\"960\":1,\"976\":1,\"977\":1,\"986\":1,\"987\":1,\"988\":3,\"1063\":1,\"1281\":2,\"1282\":2,\"1283\":3}}],[\"test>\",{\"1\":{\"818\":1}}],[\"test用户的角色为user\",{\"1\":{\"692\":1}}],[\"testbeandefinitionregistrar\",{\"1\":{\"1311\":1}}],[\"testbeanprocessor\",{\"1\":{\"1307\":2}}],[\"testbean\",{\"1\":{\"588\":5,\"1311\":2}}],[\"test才可以得到此页面\",{\"1\":{\"569\":1}}],[\"test都会经过此方法进行处理\",{\"1\":{\"569\":1}}],[\"test是一个接口\",{\"1\":{\"467\":1}}],[\"test包\",{\"1\":{\"467\":1}}],[\"test包下所有内容暴露出去\",{\"1\":{\"465\":2}}],[\"test包下所有内容都暴露出去\",{\"1\":{\"464\":1}}],[\"test包暴露给指定的模块module\",{\"1\":{\"464\":1}}],[\"test<t>\",{\"1\":{\"480\":1}}],[\"test<>\",{\"1\":{\"438\":1,\"480\":1}}],[\"test<string\",{\"1\":{\"438\":1}}],[\"test<string>\",{\"1\":{\"343\":1,\"348\":1,\"349\":1,\"438\":1,\"480\":1}}],[\"test<a\",{\"1\":{\"438\":1}}],[\"test<integer>\",{\"1\":{\"438\":1}}],[\"test<\",{\"1\":{\"438\":1,\"1002\":1,\"1023\":2,\"1026\":1,\"1054\":1,\"1290\":1}}],[\"test这个包中\",{\"1\":{\"277\":1}}],[\"test\",{\"1\":{\"171\":2,\"173\":7,\"180\":1,\"193\":1,\"241\":21,\"248\":6,\"251\":1,\"253\":2,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"269\":3,\"274\":1,\"277\":7,\"278\":4,\"283\":2,\"284\":1,\"286\":1,\"343\":2,\"348\":5,\"349\":10,\"356\":10,\"363\":3,\"364\":9,\"365\":13,\"376\":2,\"378\":7,\"395\":1,\"398\":3,\"399\":1,\"408\":25,\"409\":6,\"410\":4,\"411\":11,\"412\":7,\"413\":1,\"414\":2,\"423\":3,\"424\":4,\"438\":7,\"439\":5,\"447\":10,\"448\":3,\"453\":4,\"464\":4,\"465\":2,\"466\":4,\"467\":10,\"468\":3,\"474\":4,\"480\":8,\"500\":1,\"563\":1,\"564\":1,\"569\":2,\"582\":2,\"585\":3,\"586\":4,\"617\":9,\"619\":1,\"620\":2,\"636\":1,\"664\":1,\"697\":1,\"699\":3,\"804\":3,\"805\":1,\"819\":2,\"826\":1,\"831\":1,\"832\":2,\"835\":1,\"836\":3,\"841\":4,\"842\":2,\"843\":1,\"849\":3,\"850\":1,\"851\":5,\"853\":3,\"854\":4,\"855\":5,\"861\":1,\"862\":1,\"886\":1,\"887\":1,\"894\":2,\"895\":1,\"897\":1,\"898\":1,\"899\":1,\"904\":3,\"908\":2,\"919\":1,\"920\":1,\"921\":1,\"927\":1,\"928\":1,\"929\":2,\"930\":3,\"936\":1,\"937\":1,\"939\":2,\"946\":1,\"947\":1,\"959\":3,\"960\":1,\"961\":1,\"963\":1,\"969\":1,\"976\":2,\"977\":2,\"978\":1,\"979\":4,\"980\":1,\"985\":1,\"986\":3,\"987\":4,\"988\":6,\"1016\":1,\"1017\":6,\"1018\":1,\"1023\":2,\"1035\":2,\"1036\":1,\"1037\":1,\"1047\":1,\"1054\":1,\"1059\":1,\"1061\":2,\"1064\":1,\"1075\":2,\"1083\":2,\"1084\":2,\"1085\":2,\"1091\":1,\"1116\":1,\"1117\":2,\"1119\":8,\"1124\":1,\"1125\":2,\"1126\":2,\"1127\":6,\"1128\":3,\"1130\":1,\"1131\":2,\"1133\":7,\"1134\":3,\"1136\":2,\"1137\":2,\"1139\":1,\"1140\":3,\"1141\":3,\"1147\":1,\"1148\":1,\"1149\":3,\"1150\":2,\"1151\":2,\"1158\":1,\"1159\":1,\"1160\":1,\"1167\":1,\"1172\":2,\"1177\":2,\"1188\":1,\"1190\":1,\"1197\":1,\"1198\":2,\"1199\":2,\"1200\":1,\"1203\":1,\"1207\":2,\"1219\":3,\"1220\":2,\"1223\":1,\"1224\":2,\"1231\":2,\"1237\":2,\"1277\":2,\"1278\":2,\"1281\":1,\"1282\":1,\"1283\":2,\"1288\":3,\"1291\":3,\"1328\":3}}],[\"terminate\",{\"1\":{\"1047\":1}}],[\"terminal\",{\"1\":{\"19\":1,\"228\":1}}],[\"terms\",{\"1\":{\"119\":1,\"1181\":1}}],[\"technology\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"trying\",{\"1\":{\"711\":1,\"789\":1}}],[\"try\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"324\":2,\"329\":2,\"331\":2,\"356\":2,\"424\":9,\"480\":2,\"490\":1,\"531\":2,\"620\":1,\"625\":2,\"626\":5,\"711\":1,\"719\":3,\"720\":2,\"721\":1,\"726\":2,\"727\":2,\"788\":2,\"789\":1,\"796\":1,\"798\":1,\"799\":1,\"804\":1,\"805\":1,\"806\":4,\"819\":1,\"824\":1,\"826\":1,\"830\":2,\"841\":2,\"842\":1,\"865\":2,\"883\":1,\"884\":1,\"1017\":1,\"1072\":2,\"1075\":1,\"1093\":1,\"1148\":1,\"1225\":2,\"1242\":1,\"1246\":2,\"1247\":1,\"1320\":1}}],[\"treemap\",{\"0\":{\"219\":1},\"1\":{\"224\":1}}],[\"treeifybin\",{\"1\":{\"216\":1}}],[\"treeify\",{\"1\":{\"216\":1}}],[\"treenode<k\",{\"1\":{\"216\":1}}],[\"treenode\",{\"1\":{\"216\":1}}],[\"treeset<>\",{\"1\":{\"207\":2}}],[\"treeset<integer>\",{\"1\":{\"207\":2}}],[\"treeset\",{\"0\":{\"207\":1},\"1\":{\"219\":1,\"224\":1}}],[\"true表示开启追加模式\",{\"1\":{\"250\":1}}],[\"true\",{\"1\":{\"180\":2,\"181\":1,\"182\":2,\"193\":1,\"216\":1,\"228\":1,\"241\":2,\"250\":1,\"301\":1,\"322\":1,\"329\":5,\"330\":1,\"331\":2,\"348\":1,\"349\":1,\"350\":4,\"462\":1,\"520\":3,\"595\":1,\"599\":1,\"600\":1,\"605\":1,\"625\":1,\"631\":1,\"636\":3,\"658\":1,\"666\":1,\"687\":1,\"705\":1,\"719\":1,\"721\":2,\"727\":3,\"806\":1,\"824\":1,\"826\":1,\"830\":1,\"842\":1,\"862\":1,\"865\":1,\"883\":2,\"884\":4,\"887\":1,\"888\":1,\"897\":2,\"898\":1,\"900\":1,\"901\":1,\"903\":1,\"920\":1,\"972\":1,\"980\":1,\"1017\":3,\"1072\":1,\"1076\":1,\"1093\":1,\"1130\":1,\"1141\":1,\"1150\":1,\"1151\":1,\"1167\":1,\"1171\":1,\"1246\":1,\"1277\":1,\"1281\":1,\"1282\":1,\"1283\":1,\"1326\":1,\"1327\":1}}],[\"truncated\",{\"0\":{\"69\":1,\"71\":1,\"72\":1},\"1\":{\"71\":1}}],[\"triggers\",{\"1\":{\"781\":1}}],[\"trigger\",{\"1\":{\"781\":2}}],[\"triggeraftercompletion\",{\"1\":{\"626\":2}}],[\"trial\",{\"1\":{\"19\":2}}],[\"trip\",{\"1\":{\"10\":1}}],[\"trace\",{\"1\":{\"708\":1,\"710\":1,\"713\":3,\"1059\":1,\"1300\":2}}],[\"trajectory以及对应的\",{\"1\":{\"154\":1}}],[\"trajectory是在策略给定下\",{\"1\":{\"19\":1}}],[\"trajectory\",{\"1\":{\"19\":4,\"41\":1,\"42\":1,\"154\":1}}],[\"transformedbeanname\",{\"1\":{\"1300\":1}}],[\"transferto\",{\"1\":{\"619\":1}}],[\"transactioninterceptor\",{\"1\":{\"1283\":2}}],[\"transactionisolationlevel\",{\"1\":{\"1242\":2,\"1273\":2}}],[\"transactionaspectsupport\",{\"1\":{\"1283\":4}}],[\"transactional注解的一些参数\",{\"1\":{\"1279\":1}}],[\"transactional注解\",{\"1\":{\"1277\":1}}],[\"transactional\",{\"1\":{\"1277\":1,\"1279\":1,\"1281\":2,\"1282\":2,\"1283\":2}}],[\"transactionmanager\",{\"1\":{\"1276\":2,\"1279\":3}}],[\"transaction接口\",{\"1\":{\"1272\":1}}],[\"transactionfactory\",{\"1\":{\"1242\":3}}],[\"transaction\",{\"1\":{\"782\":1,\"1242\":1,\"1267\":1,\"1272\":2,\"1273\":2,\"1283\":7}}],[\"transactions\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"transitive\",{\"1\":{\"465\":1}}],[\"transition\",{\"1\":{\"19\":2,\"20\":1}}],[\"transient\",{\"1\":{\"182\":4,\"215\":1,\"224\":1,\"290\":1}}],[\"transmission\",{\"1\":{\"8\":1}}],[\"t\",{\"1\":{\"8\":11,\"9\":20,\"10\":12,\"11\":8,\"13\":6,\"171\":10,\"172\":3,\"173\":8,\"180\":2,\"192\":3,\"193\":3,\"204\":2,\"297\":3,\"299\":2,\"301\":3,\"302\":3,\"320\":2,\"329\":7,\"438\":2,\"439\":2,\"480\":8,\"509\":7,\"516\":1,\"519\":1,\"521\":2,\"523\":4,\"524\":2,\"799\":1,\"841\":3,\"1205\":3,\"1211\":1,\"1246\":2,\"1300\":2,\"1327\":2,\"1328\":1}}],[\"together\",{\"1\":{\"1181\":1}}],[\"touching\",{\"1\":{\"1181\":2}}],[\"touppercase\",{\"1\":{\"511\":1,\"1202\":1,\"1203\":1,\"1211\":4}}],[\"tomact类加载机制\",{\"0\":{\"1108\":1}}],[\"tomact\",{\"0\":{\"1045\":1,\"1047\":1}}],[\"tomcat容器私有的类加载器\",{\"1\":{\"1109\":1}}],[\"tomcat最基本的类加载器\",{\"1\":{\"1109\":1}}],[\"tomcat本身也是一个java程序\",{\"1\":{\"1109\":1}}],[\"tomcat需要分别去加载不同应用程序的类以及依赖\",{\"1\":{\"1109\":1}}],[\"tomcat到底是如何加载和运行我们的web应用程序的\",{\"1\":{\"1109\":1}}],[\"tomcat类加载机制\",{\"0\":{\"1109\":1}}],[\"tomcat也自带了几个默认的servlet\",{\"1\":{\"1054\":1}}],[\"tomcat还自带管理页面\",{\"1\":{\"1047\":1}}],[\"tomcat会将jsp文件转换为java文件\",{\"1\":{\"1047\":1}}],[\"tomcat会在类路径中查找实现\",{\"1\":{\"550\":1}}],[\"tomcat服务器编写了一套自己的类加载机制\",{\"1\":{\"1109\":1}}],[\"tomcat服务器既然要同时运行多个web应用程序\",{\"1\":{\"1109\":1}}],[\"tomcat服务器会为我们提供一些默认的servlet\",{\"1\":{\"1054\":1}}],[\"tomcat服务器默认是使用8080端口\",{\"1\":{\"1047\":1}}],[\"tomcat服务端运行的一些依赖\",{\"1\":{\"1047\":1}}],[\"tomcat\",{\"1\":{\"1047\":6,\"1058\":1}}],[\"tomcat发送的sessionid默认是勾选了httponly选项的\",{\"1\":{\"642\":1}}],[\"tomcat自带的servlet\",{\"1\":{\"545\":1}}],[\"topic\",{\"1\":{\"950\":1}}],[\"total\",{\"1\":{\"852\":2}}],[\"tokenizetostringarray\",{\"1\":{\"1327\":1}}],[\"tokenvalidityseconds\",{\"1\":{\"687\":1}}],[\"tokenrepository\",{\"1\":{\"687\":2}}],[\"token\",{\"1\":{\"660\":2,\"682\":1,\"683\":1}}],[\"tojsonstring\",{\"1\":{\"612\":1,\"613\":1,\"615\":1}}],[\"tocollection\",{\"1\":{\"522\":2}}],[\"tochararray\",{\"1\":{\"401\":1}}],[\"tolowercase\",{\"1\":{\"454\":2,\"480\":2,\"511\":1}}],[\"tolist\",{\"1\":{\"228\":3,\"522\":3,\"528\":2}}],[\"tohexstring\",{\"1\":{\"372\":1,\"385\":1}}],[\"toindex\",{\"1\":{\"181\":1}}],[\"toarray\",{\"1\":{\"180\":2,\"181\":1,\"204\":2,\"522\":5}}],[\"tostring来为当前类生成预设的tostring方法\",{\"1\":{\"812\":1}}],[\"tostring\",{\"1\":{\"171\":4,\"255\":1,\"330\":1,\"372\":2,\"402\":2,\"408\":4,\"424\":1,\"432\":3,\"449\":2,\"451\":2,\"452\":1,\"464\":1,\"501\":2,\"522\":3,\"523\":1,\"525\":1,\"617\":2,\"812\":1,\"841\":1,\"902\":1,\"918\":1,\"927\":1,\"948\":1,\"1069\":1,\"1072\":1,\"1104\":1,\"1234\":1,\"1260\":1,\"1319\":1,\"1327\":1}}],[\"tooling\",{\"1\":{\"1181\":1}}],[\"tools\",{\"1\":{\"1047\":1,\"1181\":1}}],[\"tool\",{\"1\":{\"52\":1}}],[\"to\",{\"0\":{\"47\":1},\"1\":{\"4\":1,\"19\":1,\"20\":1,\"82\":1,\"86\":1,\"92\":1,\"98\":1,\"296\":2,\"324\":1,\"464\":1,\"465\":2,\"466\":3,\"467\":1,\"498\":3,\"509\":2,\"625\":1,\"711\":1,\"712\":1,\"713\":1,\"774\":1,\"782\":1,\"789\":3,\"852\":1,\"1047\":16,\"1148\":6,\"1181\":6,\"1246\":2,\"1247\":3,\"1260\":1}}],[\"than\",{\"1\":{\"1181\":2}}],[\"that\",{\"1\":{\"41\":1,\"58\":1,\"81\":1,\"296\":3,\"509\":2,\"789\":2,\"1047\":2,\"1148\":3,\"1181\":5,\"1300\":1}}],[\"thus\",{\"1\":{\"1148\":1}}],[\"thu\",{\"1\":{\"1091\":1,\"1096\":1}}],[\"th\",{\"1\":{\"563\":1,\"564\":1,\"605\":1,\"636\":1,\"660\":4,\"682\":2,\"683\":2}}],[\"th=\",{\"1\":{\"563\":1,\"564\":1}}],[\"thymeleaf会自动添加web应用程序的名称到链接前面\",{\"1\":{\"564\":1}}],[\"thymeleaf\",{\"1\":{\"560\":1,\"563\":1,\"564\":1}}],[\"thymeleafviewresolver\",{\"1\":{\"560\":6}}],[\"thymeleaf<\",{\"1\":{\"559\":1}}],[\"threadlocal<>\",{\"1\":{\"319\":1}}],[\"threadlocal<string>\",{\"1\":{\"319\":1,\"320\":1}}],[\"threadlocal定义在主线程中\",{\"1\":{\"319\":1}}],[\"thread\",{\"1\":{\"296\":7,\"297\":6,\"299\":5,\"301\":5,\"302\":3,\"304\":5,\"305\":4,\"311\":5,\"312\":18,\"313\":6,\"318\":5,\"319\":6,\"320\":3,\"322\":4,\"323\":1,\"324\":8,\"329\":10,\"330\":1,\"331\":9,\"445\":4,\"446\":8,\"789\":1,\"841\":1,\"888\":1,\"948\":1,\"1119\":1,\"1188\":4,\"1225\":2,\"1278\":1,\"1283\":1}}],[\"thread构造方法中需要传入一个runnable接口的实现\",{\"1\":{\"296\":1}}],[\"threadinfo\",{\"1\":{\"295\":2}}],[\"threadmxbean\",{\"1\":{\"295\":1}}],[\"threshold\",{\"1\":{\"216\":2,\"217\":3}}],[\"through\",{\"1\":{\"789\":1,\"1047\":1,\"1181\":3}}],[\"throughput\",{\"1\":{\"4\":1}}],[\"throwable>\",{\"1\":{\"1279\":2}}],[\"throwableanalyzer\",{\"1\":{\"709\":2}}],[\"throwable\",{\"1\":{\"372\":1,\"626\":3,\"841\":2,\"1224\":2,\"1225\":2,\"1231\":4,\"1237\":1,\"1247\":2}}],[\"throws\",{\"1\":{\"264\":1,\"285\":1,\"299\":1,\"300\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"329\":2,\"339\":1,\"348\":2,\"349\":3,\"350\":3,\"356\":1,\"365\":1,\"372\":5,\"377\":2,\"421\":1,\"423\":3,\"424\":4,\"462\":1,\"480\":3,\"490\":4,\"509\":3,\"550\":1,\"595\":3,\"600\":4,\"619\":1,\"625\":2,\"626\":5,\"668\":2,\"672\":1,\"680\":1,\"683\":1,\"684\":1,\"686\":1,\"692\":1,\"706\":2,\"707\":2,\"708\":3,\"710\":1,\"711\":2,\"712\":1,\"713\":1,\"789\":3,\"790\":2,\"798\":1,\"805\":1,\"806\":4,\"824\":1,\"826\":1,\"1054\":2,\"1057\":1,\"1059\":4,\"1064\":2,\"1069\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":1,\"1103\":3,\"1104\":3,\"1160\":1,\"1188\":3,\"1192\":1,\"1224\":2,\"1225\":1,\"1231\":4,\"1237\":1,\"1242\":2,\"1244\":4,\"1245\":2,\"1246\":1,\"1247\":2,\"1254\":1,\"1272\":5,\"1273\":4,\"1276\":1,\"1297\":2,\"1300\":3,\"1307\":4,\"1311\":2,\"1316\":1,\"1320\":1,\"1321\":1,\"1327\":1,\"1328\":2}}],[\"throw\",{\"1\":{\"182\":1,\"189\":1,\"267\":1,\"331\":1,\"423\":6,\"424\":3,\"446\":1,\"599\":1,\"605\":1,\"625\":1,\"672\":1,\"692\":1,\"720\":1,\"726\":1,\"789\":4,\"796\":1,\"799\":1,\"841\":1,\"990\":1,\"991\":1,\"1059\":1,\"1072\":1,\"1104\":1,\"1225\":2,\"1242\":1,\"1246\":2,\"1247\":1,\"1277\":1,\"1281\":1,\"1282\":1,\"1283\":1,\"1296\":1,\"1320\":1}}],[\"this\",{\"0\":{\"164\":1},\"1\":{\"154\":1,\"164\":1,\"166\":12,\"172\":3,\"180\":1,\"181\":3,\"182\":5,\"192\":1,\"193\":1,\"204\":1,\"215\":1,\"216\":1,\"222\":3,\"241\":4,\"264\":1,\"288\":1,\"289\":1,\"290\":1,\"296\":1,\"322\":4,\"324\":2,\"348\":2,\"349\":2,\"371\":1,\"372\":1,\"373\":3,\"375\":4,\"378\":2,\"408\":6,\"409\":1,\"410\":1,\"437\":3,\"438\":3,\"451\":1,\"453\":3,\"464\":2,\"474\":1,\"480\":1,\"499\":4,\"509\":5,\"523\":6,\"524\":4,\"525\":10,\"625\":31,\"626\":16,\"631\":4,\"705\":9,\"706\":13,\"707\":2,\"708\":7,\"709\":6,\"710\":10,\"711\":9,\"712\":7,\"713\":5,\"788\":1,\"789\":2,\"799\":3,\"810\":6,\"841\":8,\"900\":3,\"1047\":2,\"1059\":16,\"1083\":1,\"1104\":1,\"1133\":1,\"1134\":1,\"1135\":2,\"1136\":1,\"1149\":2,\"1173\":1,\"1179\":1,\"1181\":2,\"1192\":2,\"1200\":2,\"1203\":1,\"1219\":1,\"1242\":7,\"1244\":10,\"1245\":5,\"1246\":24,\"1247\":14,\"1273\":11,\"1296\":1,\"1297\":1,\"1300\":9,\"1301\":9,\"1308\":1,\"1317\":1,\"1318\":9,\"1319\":2,\"1320\":3,\"1321\":1,\"1327\":18,\"1328\":2}}],[\"there\",{\"1\":{\"1181\":1}}],[\"their\",{\"1\":{\"1181\":2}}],[\"these\",{\"1\":{\"1047\":1}}],[\"they\",{\"1\":{\"324\":1,\"1181\":1}}],[\"them\",{\"1\":{\"324\":1,\"1181\":3}}],[\"then\",{\"1\":{\"58\":2,\"617\":3,\"636\":1,\"666\":1,\"789\":1,\"1047\":1}}],[\"theorem来求解贝尔曼最优公式\",{\"1\":{\"58\":1}}],[\"theorem\",{\"1\":{\"53\":2,\"58\":1,\"62\":1,\"98\":1}}],[\"the\",{\"0\":{\"24\":1,\"43\":1,\"44\":1},\"1\":{\"4\":1,\"9\":1,\"10\":1,\"19\":6,\"20\":4,\"37\":1,\"40\":1,\"41\":2,\"47\":1,\"48\":4,\"49\":2,\"52\":1,\"53\":2,\"58\":2,\"81\":1,\"82\":2,\"86\":1,\"98\":2,\"135\":1,\"142\":2,\"296\":5,\"324\":7,\"340\":4,\"509\":8,\"711\":1,\"788\":4,\"789\":10,\"841\":1,\"1047\":27,\"1054\":4,\"1148\":8,\"1181\":12,\"1246\":5,\"1247\":1,\"1296\":1}}],[\"icon\",{\"1\":{\"1074\":3}}],[\"icon等\",{\"1\":{\"1047\":1}}],[\"ibatis\",{\"1\":{\"841\":2,\"843\":2,\"1272\":1}}],[\"ip连接是否有效\",{\"1\":{\"721\":1}}],[\"ip地址为\",{\"1\":{\"719\":2,\"720\":1,\"727\":2}}],[\"ignoringrequestmatchers\",{\"1\":{\"684\":1}}],[\"i>\",{\"1\":{\"683\":1}}],[\"ix\",{\"1\":{\"662\":1}}],[\"i都会更新成数组中下一个元素\",{\"1\":{\"394\":1}}],[\"i+1\",{\"1\":{\"799\":1}}],[\"i+\",{\"1\":{\"394\":1,\"447\":4}}],[\"i++\",{\"1\":{\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":8,\"318\":1,\"329\":2,\"394\":1,\"431\":1,\"478\":1,\"480\":1,\"490\":3,\"799\":1,\"819\":1,\"871\":1,\"876\":1}}],[\"i就是每一个数组中的元素\",{\"1\":{\"394\":1}}],[\"illegaltransactionstateexception\",{\"1\":{\"1283\":1}}],[\"illegalstateexception\",{\"1\":{\"990\":1,\"991\":1,\"1296\":1,\"1316\":1,\"1320\":1}}],[\"illegalaccessexception\",{\"1\":{\"348\":2,\"349\":1,\"350\":1,\"462\":1}}],[\"illegalargumentexception\",{\"1\":{\"182\":1}}],[\"illegal\",{\"1\":{\"182\":1}}],[\"ioc容器\",{\"1\":{\"1328\":1}}],[\"ioc容器默认只会调用无参构造\",{\"1\":{\"1134\":1}}],[\"ioc容器在创建对象时\",{\"1\":{\"1132\":2}}],[\"ioc容器创建的bean是只有一个还是每次索要的时候都会给我们一个新的对象\",{\"1\":{\"1129\":1}}],[\"ioc容器对象生成原理\",{\"0\":{\"1129\":1}}],[\"ioc容器实例化\",{\"1\":{\"1117\":1}}],[\"ioc\",{\"1\":{\"1117\":1,\"1328\":2}}],[\"ioc是inversion\",{\"1\":{\"1115\":1}}],[\"ioc理论\",{\"0\":{\"1117\":1}}],[\"ioc理论介绍\",{\"0\":{\"1115\":1}}],[\"ioc理论基础\",{\"0\":{\"1114\":1,\"1123\":1,\"1145\":1,\"1156\":1,\"1164\":1}}],[\"io<\",{\"1\":{\"1074\":2}}],[\"ioutils\",{\"1\":{\"620\":1,\"1074\":1,\"1075\":1}}],[\"io3\",{\"0\":{\"281\":1}}],[\"io流3\",{\"0\":{\"282\":1}}],[\"io流2\",{\"0\":{\"259\":1}}],[\"io流1\",{\"0\":{\"245\":1}}],[\"io2\",{\"0\":{\"258\":1}}],[\"ioexception\",{\"1\":{\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"356\":1,\"424\":6,\"480\":3,\"490\":4,\"619\":1,\"620\":1,\"626\":4,\"707\":2,\"708\":3,\"710\":1,\"711\":2,\"712\":1,\"713\":1,\"719\":3,\"720\":2,\"726\":2,\"973\":1,\"1054\":1,\"1057\":1,\"1059\":4,\"1064\":1,\"1069\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1083\":1,\"1093\":1,\"1102\":1,\"1103\":3,\"1104\":3,\"1254\":1,\"1276\":1,\"1297\":2}}],[\"io中\",{\"1\":{\"245\":1}}],[\"io1\",{\"0\":{\"244\":1}}],[\"io\",{\"0\":{\"1352\":1},\"1\":{\"182\":2,\"199\":1,\"224\":1,\"252\":2,\"462\":1,\"796\":1,\"910\":1,\"1074\":1,\"1113\":1,\"1211\":1,\"1219\":1}}],[\"id属性也可以\",{\"1\":{\"1127\":1}}],[\"idea会自动报错\",{\"1\":{\"1158\":1}}],[\"idea\",{\"0\":{\"1048\":1}}],[\"idea默认给我们添加了一个parent节点\",{\"1\":{\"1032\":1}}],[\"identified\",{\"1\":{\"772\":1}}],[\"identity\",{\"1\":{\"521\":1}}],[\"identically\",{\"1\":{\"75\":1}}],[\"id>\",{\"1\":{\"1010\":1,\"1037\":1}}],[\"id等于2的必须满足等于18岁\",{\"1\":{\"874\":1}}],[\"id等于1的必须同时要满足小于18岁\",{\"1\":{\"874\":1}}],[\"id直接放在请求路径中\",{\"1\":{\"589\":2}}],[\"id=1\",{\"1\":{\"852\":2}}],[\"id=\",{\"1\":{\"490\":1,\"617\":2,\"636\":1,\"660\":1,\"666\":2,\"824\":1,\"826\":1,\"831\":4,\"833\":1,\"834\":1,\"835\":2,\"836\":2,\"841\":2,\"842\":3,\"843\":1,\"849\":2,\"850\":1,\"851\":3,\"853\":1,\"854\":3,\"855\":5,\"861\":1,\"862\":1,\"863\":1,\"864\":1,\"873\":1,\"874\":1,\"876\":1,\"877\":1,\"886\":1,\"887\":1,\"895\":1,\"897\":1,\"898\":1,\"902\":1,\"1017\":1,\"1071\":1,\"1076\":1,\"1211\":1,\"1218\":1,\"1219\":2,\"1220\":1,\"1223\":1,\"1224\":1,\"1225\":1,\"1231\":3,\"1242\":1,\"1255\":1}}],[\"ids\",{\"1\":{\"295\":2}}],[\"id一般是int\",{\"1\":{\"213\":1}}],[\"id\",{\"1\":{\"172\":4,\"437\":4,\"438\":4,\"589\":6,\"669\":1,\"692\":1,\"714\":2,\"747\":6,\"748\":1,\"831\":4,\"833\":2,\"834\":3,\"835\":3,\"836\":1,\"841\":12,\"842\":1,\"843\":8,\"849\":2,\"850\":9,\"851\":7,\"852\":4,\"853\":6,\"855\":7,\"862\":2,\"863\":4,\"864\":2,\"873\":3,\"874\":4,\"876\":2,\"886\":2,\"887\":2,\"897\":4,\"898\":3,\"900\":7,\"901\":10,\"902\":12,\"903\":3,\"1150\":2}}],[\"idleconnections\",{\"1\":{\"1246\":2,\"1247\":2}}],[\"idle\",{\"1\":{\"10\":1}}],[\"iid\",{\"1\":{\"75\":1}}],[\"i\",{\"1\":{\"75\":2,\"78\":1,\"181\":3,\"190\":2,\"216\":3,\"228\":4,\"265\":1,\"299\":3,\"304\":5,\"305\":5,\"311\":4,\"312\":12,\"318\":3,\"329\":4,\"330\":1,\"343\":9,\"349\":1,\"350\":12,\"384\":9,\"385\":4,\"386\":6,\"394\":4,\"431\":2,\"439\":2,\"447\":5,\"448\":2,\"478\":8,\"479\":8,\"480\":2,\"490\":7,\"726\":5,\"727\":3,\"796\":2,\"799\":7,\"819\":3,\"871\":3,\"876\":3}}],[\"i−γpπk​​\",{\"1\":{\"68\":1}}],[\"i−γpπ​\",{\"1\":{\"47\":2}}],[\"ifaces\",{\"1\":{\"1247\":1}}],[\"ifmodifiedsince\",{\"1\":{\"1059\":2}}],[\"if>\",{\"1\":{\"873\":1,\"902\":2}}],[\"iframe>\",{\"1\":{\"641\":1}}],[\"if=\",{\"1\":{\"636\":1}}],[\"ifpresentorelse\",{\"1\":{\"480\":1}}],[\"ifpresent表示只有对象不为null才会执行里面的逻辑\",{\"1\":{\"454\":1}}],[\"ifpresent\",{\"1\":{\"454\":2,\"480\":2,\"1211\":1}}],[\"if\",{\"1\":{\"53\":1,\"58\":1,\"86\":1,\"98\":1,\"180\":1,\"182\":6,\"216\":10,\"217\":5,\"241\":4,\"247\":1,\"264\":2,\"299\":1,\"301\":1,\"304\":1,\"305\":1,\"324\":2,\"373\":2,\"376\":1,\"384\":1,\"423\":2,\"454\":1,\"499\":2,\"509\":3,\"599\":1,\"605\":1,\"617\":2,\"625\":11,\"626\":8,\"631\":2,\"636\":4,\"672\":1,\"692\":1,\"705\":3,\"706\":4,\"707\":1,\"708\":6,\"710\":3,\"711\":3,\"712\":2,\"727\":1,\"749\":1,\"789\":12,\"799\":2,\"819\":1,\"902\":1,\"972\":2,\"990\":1,\"991\":1,\"1047\":2,\"1059\":12,\"1072\":2,\"1076\":1,\"1093\":6,\"1096\":1,\"1104\":3,\"1211\":1,\"1224\":2,\"1244\":3,\"1246\":17,\"1247\":9,\"1273\":3,\"1277\":1,\"1281\":1,\"1282\":1,\"1283\":1,\"1296\":1,\"1297\":2,\"1300\":4,\"1301\":6,\"1310\":3,\"1321\":3,\"1327\":4}}],[\"ij​=pπ​\",{\"1\":{\"46\":1}}],[\"immutablecollections\",{\"1\":{\"528\":1}}],[\"immutable\",{\"1\":{\"528\":1}}],[\"immediate\",{\"0\":{\"43\":1},\"1\":{\"45\":1}}],[\"image\",{\"1\":{\"660\":1,\"687\":1,\"692\":4,\"727\":3,\"816\":1,\"818\":1,\"1042\":1,\"1074\":2,\"1091\":3,\"1096\":3,\"1199\":1}}],[\"images\",{\"1\":{\"490\":1}}],[\"imageinput\",{\"1\":{\"490\":3}}],[\"imageresponse\",{\"1\":{\"490\":2}}],[\"imagerequest\",{\"1\":{\"490\":2}}],[\"img\",{\"1\":{\"490\":1,\"810\":1,\"1109\":1}}],[\"impl\",{\"1\":{\"448\":2}}],[\"implementation\",{\"1\":{\"1260\":1}}],[\"implemented\",{\"1\":{\"1059\":1}}],[\"implementing\",{\"1\":{\"296\":1}}],[\"implements\",{\"1\":{\"182\":2,\"193\":1,\"199\":1,\"215\":2,\"224\":1,\"288\":1,\"289\":1,\"290\":1,\"376\":2,\"377\":1,\"439\":2,\"462\":1,\"467\":1,\"501\":1,\"504\":1,\"550\":1,\"595\":1,\"600\":1,\"668\":1,\"671\":1,\"672\":1,\"709\":1,\"910\":1,\"1054\":1,\"1102\":1,\"1103\":1,\"1105\":1,\"1117\":2,\"1132\":2,\"1160\":1,\"1180\":1,\"1186\":2,\"1191\":1,\"1192\":2,\"1231\":3,\"1244\":1,\"1245\":1,\"1247\":1,\"1273\":2,\"1277\":1,\"1281\":1,\"1307\":2,\"1308\":1,\"1310\":1,\"1311\":2,\"1327\":1,\"1328\":1}}],[\"import来进行bean的注册\",{\"1\":{\"1326\":1}}],[\"import来注册aspectjautoproxyregistrar\",{\"1\":{\"1310\":1}}],[\"import加载aspectjautoproxyregistrar\",{\"1\":{\"1310\":1}}],[\"import的方式来加载\",{\"1\":{\"1310\":1}}],[\"importingclassmetadata\",{\"1\":{\"1310\":2,\"1311\":1}}],[\"importbeandefinitionregistrar类只能通过其他类\",{\"1\":{\"1310\":1}}],[\"importbeandefinitionregistrar\",{\"1\":{\"1310\":1,\"1311\":1}}],[\"import还可以引入其他配置类\",{\"1\":{\"1168\":1}}],[\"import\",{\"1\":{\"180\":1,\"277\":3,\"278\":1,\"365\":4,\"386\":2,\"411\":1,\"431\":1,\"464\":1,\"467\":1,\"468\":1,\"512\":1,\"796\":2,\"826\":1,\"1032\":1,\"1168\":1,\"1310\":2,\"1318\":1,\"1326\":1}}],[\"importance\",{\"0\":{\"30\":1}}],[\"improvement\",{\"1\":{\"66\":1,\"70\":1,\"79\":1,\"82\":1,\"88\":1,\"111\":1,\"115\":1,\"120\":1}}],[\"i=1n​\",{\"1\":{\"19\":2}}],[\"its\",{\"1\":{\"324\":1,\"1181\":2}}],[\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称\",{\"1\":{\"876\":1}}],[\"item=\",{\"1\":{\"876\":1,\"877\":1}}],[\"itemplateresolver\",{\"1\":{\"560\":1}}],[\"item\",{\"1\":{\"182\":2,\"190\":1,\"819\":2,\"876\":2,\"877\":3}}],[\"iterable<string>\",{\"1\":{\"193\":1}}],[\"iterable<t>\",{\"1\":{\"193\":1,\"836\":1}}],[\"iterable<e>\",{\"1\":{\"180\":1}}],[\"iterable\",{\"1\":{\"192\":1,\"193\":1,\"994\":1}}],[\"iterate\",{\"1\":{\"478\":2,\"479\":2}}],[\"iterator<t>\",{\"1\":{\"193\":1}}],[\"iterator<string>\",{\"1\":{\"191\":1,\"193\":2}}],[\"iterator<e>\",{\"1\":{\"180\":2,\"189\":1,\"194\":1,\"201\":1,\"204\":1,\"224\":1}}],[\"iterator\",{\"1\":{\"180\":2,\"187\":3,\"191\":4,\"193\":3,\"204\":1,\"224\":2,\"330\":1}}],[\"iteration\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"70\":2,\"71\":1,\"72\":1},\"1\":{\"62\":1,\"68\":2,\"69\":2,\"70\":10,\"71\":3,\"76\":1,\"77\":1,\"79\":1,\"82\":1}}],[\"iterative\",{\"1\":{\"47\":1,\"92\":1}}],[\"it\",{\"1\":{\"4\":1,\"81\":1,\"296\":1,\"329\":2,\"509\":1,\"789\":3,\"1148\":1,\"1181\":3}}],[\"isfactorybean\",{\"1\":{\"1321\":1}}],[\"islazyinit\",{\"1\":{\"1321\":1}}],[\"isabstract\",{\"1\":{\"1321\":1}}],[\"isactive\",{\"1\":{\"625\":1}}],[\"isolation\",{\"1\":{\"1266\":1,\"1267\":4,\"1279\":4}}],[\"isvalid\",{\"1\":{\"1246\":1,\"1247\":1}}],[\"issynthetic\",{\"1\":{\"1301\":1}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"1300\":1,\"1301\":1}}],[\"issingleton\",{\"1\":{\"1180\":1,\"1321\":1,\"1327\":1}}],[\"issealed\",{\"1\":{\"504\":1}}],[\"istraceenabled\",{\"1\":{\"708\":1,\"710\":1,\"1300\":1}}],[\"istargetfilterlifecycle\",{\"1\":{\"706\":1}}],[\"isdriverallowed\",{\"1\":{\"789\":1}}],[\"isdebugenabled\",{\"1\":{\"708\":3,\"710\":1,\"712\":1,\"1246\":7,\"1247\":3,\"1273\":1}}],[\"isdirectory\",{\"1\":{\"255\":1}}],[\"isconcurrenthandlingstarted\",{\"1\":{\"626\":2}}],[\"isget\",{\"1\":{\"626\":3}}],[\"isinfoenabled\",{\"1\":{\"625\":1}}],[\"isinterrupted\",{\"1\":{\"301\":1}}],[\"iseagerinit\",{\"1\":{\"1321\":1}}],[\"iserrorenabled\",{\"1\":{\"625\":1}}],[\"isempty\",{\"1\":{\"180\":1,\"182\":1,\"204\":1,\"213\":1,\"224\":2,\"324\":2,\"331\":1,\"625\":1,\"631\":1,\"1246\":1,\"1327\":1}}],[\"ispresent\",{\"1\":{\"512\":3}}],[\"isblank方法用于判断是否字符串为空或者是仅包含空格\",{\"1\":{\"488\":1}}],[\"isblank\",{\"1\":{\"488\":2}}],[\"is\",{\"1\":{\"4\":3,\"19\":1,\"20\":2,\"41\":1,\"53\":1,\"58\":2,\"81\":1,\"86\":2,\"154\":1,\"296\":3,\"324\":1,\"509\":2,\"788\":4,\"789\":3,\"1047\":1,\"1181\":7,\"1300\":1}}],[\"ieee\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"inferred\",{\"1\":{\"1167\":1}}],[\"information\",{\"1\":{\"1047\":1}}],[\"infos\",{\"1\":{\"295\":2}}],[\"info\",{\"1\":{\"274\":3,\"295\":2,\"461\":2,\"463\":1,\"468\":3,\"625\":1,\"789\":6,\"908\":1,\"910\":4,\"911\":1,\"919\":1,\"929\":1,\"950\":2,\"1032\":1,\"1064\":1,\"1208\":1,\"1260\":2,\"1278\":1,\"1328\":1}}],[\"invasive\",{\"1\":{\"1181\":1}}],[\"invalidate\",{\"1\":{\"1097\":1,\"1246\":1,\"1247\":2}}],[\"invocationhandler\",{\"1\":{\"1247\":1}}],[\"invocation\",{\"1\":{\"1231\":2}}],[\"invocationtargetexception\",{\"1\":{\"348\":1,\"349\":1,\"350\":1}}],[\"invoking\",{\"1\":{\"710\":1,\"789\":1}}],[\"invokebeanfactorypostprocessors\",{\"1\":{\"1320\":1}}],[\"invokewithintransaction\",{\"1\":{\"1283\":1}}],[\"invokejoinpoint\",{\"1\":{\"1278\":1}}],[\"invokejoinpointusingreflection\",{\"1\":{\"1278\":1}}],[\"invoke0\",{\"1\":{\"1278\":1}}],[\"invoke方法就是代理方法\",{\"1\":{\"1231\":1}}],[\"invoker\",{\"1\":{\"841\":1}}],[\"invoker是mybatis内部编写一个用于反射设置对象属性值的工具\",{\"1\":{\"841\":1}}],[\"invoke不需要对象参数\",{\"1\":{\"349\":1}}],[\"invoke\",{\"1\":{\"349\":3,\"356\":2,\"841\":1,\"1231\":1,\"1247\":2,\"1278\":3,\"1283\":2}}],[\"invokedelegate\",{\"1\":{\"707\":2}}],[\"invoked\",{\"1\":{\"4\":1}}],[\"include\",{\"1\":{\"993\":1}}],[\"indicativesentences\",{\"1\":{\"962\":1}}],[\"indirectly\",{\"1\":{\"789\":1}}],[\"index=\",{\"1\":{\"876\":1}}],[\"index或是\",{\"1\":{\"569\":2}}],[\"indexoutofboundsexception\",{\"1\":{\"424\":2}}],[\"indexofsublist\",{\"1\":{\"237\":1}}],[\"indexof\",{\"1\":{\"181\":1,\"490\":2}}],[\"index++\",{\"1\":{\"182\":1}}],[\"index\",{\"1\":{\"181\":6,\"182\":4,\"560\":2,\"561\":2,\"563\":6,\"569\":6,\"571\":9,\"572\":3,\"573\":3,\"574\":9,\"575\":2,\"576\":3,\"579\":3,\"580\":3,\"581\":3,\"582\":6,\"583\":3,\"585\":3,\"586\":3,\"587\":4,\"588\":3,\"589\":19,\"599\":3,\"605\":3,\"612\":3,\"613\":3,\"615\":1,\"636\":2,\"658\":2,\"662\":1,\"679\":2,\"693\":1,\"695\":2,\"697\":2,\"699\":2,\"780\":3,\"876\":1,\"1207\":1}}],[\"independent\",{\"1\":{\"75\":1}}],[\"inetsocketaddress\",{\"1\":{\"721\":1}}],[\"installation\",{\"1\":{\"1047\":1}}],[\"install命令可以将当前项目安装到本地仓库\",{\"1\":{\"1034\":1}}],[\"install来安装我们自己的项目到本地maven仓库中\",{\"1\":{\"1023\":1}}],[\"instantiates\",{\"1\":{\"1148\":1}}],[\"instantiationexception\",{\"1\":{\"348\":2,\"349\":1,\"350\":1}}],[\"instanceof迎来了一波小更新\",{\"1\":{\"499\":1}}],[\"instanceof\",{\"1\":{\"216\":1,\"343\":2,\"365\":2,\"373\":1,\"376\":1,\"499\":2,\"625\":1,\"1059\":2,\"1104\":2,\"1321\":1}}],[\"instance\",{\"1\":{\"161\":1,\"340\":1,\"349\":4,\"545\":1,\"547\":1,\"549\":1,\"1002\":1,\"1023\":1,\"1032\":1,\"1119\":1,\"1148\":1,\"1167\":1,\"1217\":1,\"1242\":1,\"1300\":2}}],[\"insertstudent\",{\"1\":{\"897\":1,\"1277\":3,\"1281\":1,\"1282\":1,\"1283\":1}}],[\"insertspringsecurityfilterchain\",{\"1\":{\"705\":3}}],[\"insertalluser\",{\"1\":{\"877\":1}}],[\"insertuser\",{\"1\":{\"877\":1,\"896\":1,\"897\":2}}],[\"insert>\",{\"1\":{\"861\":1,\"862\":1,\"877\":1,\"897\":1}}],[\"insert|update|delete\",{\"1\":{\"781\":1}}],[\"insert\",{\"1\":{\"754\":3,\"796\":1,\"798\":2,\"806\":11,\"860\":2,\"861\":1,\"862\":1,\"871\":1,\"877\":2,\"884\":1,\"896\":2,\"897\":3,\"1277\":2}}],[\"insecure\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"inmemoryuserdetailsmanager\",{\"1\":{\"658\":1,\"659\":1}}],[\"injection\",{\"1\":{\"643\":1,\"1132\":1}}],[\"inner>\",{\"1\":{\"817\":1}}],[\"innertext\",{\"1\":{\"617\":2,\"1076\":1}}],[\"inner2\",{\"1\":{\"408\":2,\"930\":1}}],[\"inner1\",{\"1\":{\"408\":2,\"930\":1}}],[\"inner\",{\"1\":{\"408\":12,\"409\":5,\"410\":5,\"411\":3,\"474\":2,\"769\":1}}],[\"inherited\",{\"1\":{\"362\":1,\"1279\":1}}],[\"inheritablethreadlocal<>\",{\"1\":{\"320\":1}}],[\"inherits\",{\"1\":{\"296\":1}}],[\"initapplicationeventmulticaster\",{\"1\":{\"1320\":1}}],[\"init属性\",{\"1\":{\"1171\":1}}],[\"initmessagesource\",{\"1\":{\"1320\":1}}],[\"initmethod\",{\"1\":{\"1167\":1,\"1170\":1}}],[\"initmultipartresolver\",{\"1\":{\"625\":1}}],[\"init=\",{\"1\":{\"1130\":1}}],[\"initparams\",{\"1\":{\"1085\":1}}],[\"initconfiguration\",{\"1\":{\"904\":2}}],[\"initcontextholders\",{\"1\":{\"626\":1}}],[\"initdelegate\",{\"1\":{\"706\":3}}],[\"initfilterbean\",{\"1\":{\"706\":1}}],[\"initflashmapmanager\",{\"1\":{\"625\":1}}],[\"initframeworkservlet\",{\"1\":{\"625\":1}}],[\"initviewresolvers\",{\"1\":{\"625\":1}}],[\"initrequesttoviewnametranslator\",{\"1\":{\"625\":1}}],[\"inithandlerexceptionresolvers\",{\"1\":{\"625\":1}}],[\"inithandleradapters\",{\"1\":{\"625\":1}}],[\"inithandlermappings\",{\"1\":{\"625\":1,\"631\":1}}],[\"initthemeresolver\",{\"1\":{\"625\":1}}],[\"initlocaleresolver\",{\"1\":{\"625\":1}}],[\"initstrategies\",{\"1\":{\"625\":2}}],[\"initservletbean\",{\"1\":{\"625\":2}}],[\"initwebapplicationcontext\",{\"1\":{\"625\":2}}],[\"initbeanwrapper\",{\"1\":{\"625\":1}}],[\"initbinder注解\",{\"1\":{\"602\":1}}],[\"init\",{\"1\":{\"296\":1,\"548\":1,\"625\":1,\"704\":1,\"705\":1,\"706\":1,\"1054\":1,\"1055\":1,\"1064\":2,\"1072\":1,\"1147\":2,\"1176\":1,\"1308\":1,\"1311\":1}}],[\"initialized\",{\"1\":{\"1296\":1,\"1300\":1}}],[\"initializedriver\",{\"1\":{\"1244\":1}}],[\"initializers\",{\"1\":{\"550\":1}}],[\"initialization\",{\"1\":{\"1148\":1,\"1181\":1}}],[\"initializingbean\",{\"1\":{\"1327\":1}}],[\"initializing\",{\"1\":{\"625\":2}}],[\"initial\",{\"1\":{\"217\":3}}],[\"initialcapacity\",{\"1\":{\"182\":5}}],[\"inputmismatchexception\",{\"1\":{\"531\":1}}],[\"input\",{\"1\":{\"264\":3,\"509\":1,\"682\":2}}],[\"inputstreamreader\",{\"1\":{\"283\":3,\"720\":2}}],[\"inputstream\",{\"1\":{\"245\":1,\"247\":5,\"248\":9,\"251\":2,\"255\":2,\"264\":1,\"288\":2,\"290\":2,\"480\":4,\"490\":1,\"620\":3,\"720\":1,\"726\":3,\"727\":1,\"824\":3,\"1074\":5}}],[\"introduction\",{\"1\":{\"1181\":1,\"1226\":1}}],[\"int这样前面添加下划线\",{\"1\":{\"831\":1}}],[\"into\",{\"1\":{\"754\":3,\"796\":1,\"798\":2,\"806\":11,\"861\":1,\"862\":1,\"871\":1,\"877\":2,\"896\":1,\"897\":2,\"1277\":1}}],[\"into语句来向数据库中插入一条数据\",{\"1\":{\"754\":1}}],[\"int用于存储一般的整数\",{\"1\":{\"746\":1}}],[\"intfunction\",{\"1\":{\"522\":1}}],[\"intfunction<a\",{\"1\":{\"522\":1}}],[\"intsummarystatistics\",{\"1\":{\"228\":1}}],[\"ints\",{\"1\":{\"228\":2,\"521\":2}}],[\"intended\",{\"1\":{\"1047\":1}}],[\"intel\",{\"1\":{\"727\":1}}],[\"interactiveauthenticationsuccessevent\",{\"1\":{\"712\":1}}],[\"interacting\",{\"1\":{\"19\":1}}],[\"internal\",{\"1\":{\"711\":1,\"1278\":3}}],[\"internalauthenticationserviceexception\",{\"1\":{\"711\":1}}],[\"interceptor\",{\"1\":{\"1283\":3}}],[\"interceptorregistry\",{\"1\":{\"596\":1,\"600\":1,\"601\":1}}],[\"interceptor拦截器\",{\"0\":{\"593\":1}}],[\"interrupted\",{\"1\":{\"301\":1}}],[\"interruptedexception终止异常\",{\"1\":{\"318\":1}}],[\"interruptedexception\",{\"1\":{\"299\":1,\"300\":1,\"301\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":3,\"318\":2,\"319\":2,\"322\":2,\"329\":4,\"331\":2,\"372\":3,\"490\":4,\"1188\":3,\"1192\":1,\"1225\":1,\"1246\":1}}],[\"interrupt\",{\"1\":{\"301\":1}}],[\"interrupt用法\",{\"1\":{\"301\":1}}],[\"intermediate\",{\"1\":{\"228\":1}}],[\"interfaces\",{\"1\":{\"1047\":3}}],[\"interface\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"193\":1,\"194\":1,\"200\":1,\"201\":1,\"204\":1,\"213\":2,\"296\":2,\"363\":2,\"364\":4,\"365\":1,\"376\":3,\"377\":1,\"412\":1,\"415\":2,\"439\":1,\"447\":2,\"453\":1,\"467\":1,\"474\":2,\"504\":1,\"509\":1,\"569\":1,\"665\":1,\"668\":1,\"670\":1,\"708\":1,\"836\":1,\"842\":1,\"861\":1,\"895\":1,\"896\":1,\"903\":1,\"1047\":2,\"1071\":1,\"1117\":2,\"1132\":1,\"1167\":1,\"1242\":1,\"1255\":1,\"1272\":1,\"1277\":2,\"1279\":1,\"1310\":1,\"1316\":1,\"1326\":1,\"1327\":1}}],[\"integer的缩写\",{\"1\":{\"831\":1}}],[\"integer类中有一个叫做compare的静态方法\",{\"1\":{\"449\":1}}],[\"integercache会默认缓存\",{\"1\":{\"384\":1}}],[\"integercache\",{\"1\":{\"384\":4}}],[\"integer>\",{\"1\":{\"172\":1,\"222\":1,\"241\":1,\"475\":2}}],[\"integer\",{\"1\":{\"171\":7,\"182\":5,\"217\":2,\"222\":1,\"237\":1,\"340\":2,\"341\":1,\"343\":4,\"350\":4,\"372\":1,\"384\":13,\"385\":7,\"395\":1,\"415\":2,\"437\":3,\"438\":1,\"439\":2,\"447\":2,\"448\":2,\"449\":7,\"451\":10,\"452\":4,\"512\":7,\"521\":3,\"799\":2,\"810\":5,\"841\":2,\"852\":2,\"912\":2,\"1244\":2,\"1272\":1}}],[\"int\",{\"1\":{\"161\":2,\"162\":1,\"165\":3,\"166\":7,\"171\":2,\"180\":2,\"181\":10,\"182\":9,\"194\":2,\"204\":2,\"213\":2,\"215\":1,\"216\":3,\"217\":4,\"218\":1,\"222\":3,\"224\":1,\"228\":1,\"241\":1,\"248\":1,\"251\":1,\"274\":1,\"278\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":3,\"312\":14,\"318\":1,\"329\":2,\"330\":2,\"340\":2,\"343\":1,\"348\":1,\"349\":3,\"372\":2,\"375\":3,\"376\":1,\"377\":1,\"384\":3,\"392\":2,\"393\":2,\"394\":5,\"395\":4,\"396\":1,\"397\":1,\"398\":3,\"413\":1,\"415\":3,\"423\":4,\"424\":4,\"425\":1,\"431\":1,\"432\":2,\"449\":4,\"451\":3,\"452\":1,\"464\":2,\"478\":1,\"480\":1,\"490\":4,\"495\":2,\"496\":1,\"500\":1,\"521\":2,\"523\":4,\"524\":2,\"669\":1,\"692\":1,\"726\":2,\"727\":1,\"747\":2,\"748\":2,\"796\":2,\"799\":1,\"819\":1,\"826\":1,\"831\":4,\"835\":2,\"841\":6,\"842\":2,\"843\":4,\"849\":3,\"853\":3,\"854\":1,\"855\":3,\"860\":6,\"861\":1,\"863\":4,\"871\":1,\"876\":1,\"896\":1,\"897\":1,\"898\":2,\"900\":8,\"901\":2,\"902\":3,\"903\":1,\"963\":1,\"969\":2,\"991\":1,\"992\":1,\"1008\":1,\"1017\":2,\"1135\":2,\"1209\":1,\"1245\":7,\"1246\":1,\"1247\":1,\"1255\":1,\"1279\":1}}],[\"in\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"81\":1,\"98\":1,\"119\":1,\"264\":4,\"285\":1,\"296\":1,\"509\":2,\"531\":1,\"720\":1,\"721\":1,\"727\":2,\"763\":2,\"804\":1,\"805\":1,\"841\":3,\"876\":2,\"1047\":1,\"1119\":1,\"1148\":2,\"1181\":6,\"1278\":1,\"1283\":1,\"1327\":1}}],[\"mbd\",{\"1\":{\"1301\":2}}],[\"mbgd\",{\"0\":{\"106\":1}}],[\"msg\",{\"1\":{\"1059\":2}}],[\"mssrkn​​rtt​+1\",{\"1\":{\"10\":1}}],[\"mss\",{\"1\":{\"10\":1}}],[\"mm\",{\"1\":{\"948\":2,\"1076\":1}}],[\"m2文件夹\",{\"1\":{\"1009\":1}}],[\"m2\",{\"1\":{\"883\":2}}],[\"m1\",{\"1\":{\"883\":3}}],[\"mv\",{\"1\":{\"626\":5}}],[\"mvc\",{\"0\":{\"630\":1,\"1340\":1},\"1\":{\"553\":2,\"560\":2,\"589\":5,\"603\":1,\"604\":1,\"617\":3,\"619\":1,\"631\":1,\"636\":1,\"641\":1,\"642\":2,\"658\":1,\"660\":1,\"666\":1}}],[\"mvc详细解释如下\",{\"1\":{\"541\":1}}],[\"mvc介绍\",{\"0\":{\"541\":1}}],[\"mvc三层架构包括\",{\"1\":{\"540\":1}}],[\"mvc理论基础\",{\"0\":{\"540\":1}}],[\"m是指业务模型\",{\"1\":{\"541\":1}}],[\"must\",{\"1\":{\"1047\":2,\"1148\":1,\"1318\":2,\"1319\":1}}],[\"mutable\",{\"1\":{\"528\":1}}],[\"multipartconfig注解来表示此servlet用于处理文件上传请求\",{\"1\":{\"1075\":1}}],[\"multipartconfig\",{\"1\":{\"1075\":1}}],[\"multipartconfigelement\",{\"1\":{\"619\":1}}],[\"multipartrequestparsed\",{\"1\":{\"626\":3}}],[\"multipartfile\",{\"1\":{\"619\":1}}],[\"multipart\",{\"1\":{\"619\":2,\"620\":1,\"1075\":2}}],[\"multiply\",{\"1\":{\"386\":1}}],[\"multiple\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"multi\",{\"1\":{\"498\":2}}],[\"myformatter\",{\"1\":{\"944\":1,\"946\":1,\"947\":1}}],[\"mybatis将其bean信息注册到了容器中\",{\"1\":{\"1326\":1}}],[\"mybatis整合原理\",{\"0\":{\"1324\":1,\"1325\":1}}],[\"mybatis的事务管理分为两种形式\",{\"1\":{\"1272\":1}}],[\"mybatis的缓存机制有些复杂\",{\"1\":{\"882\":1}}],[\"mybatis对于数据库的事务管理\",{\"1\":{\"1272\":1}}],[\"mybatis事务封装介绍\",{\"0\":{\"1272\":1}}],[\"mybatis事务管理\",{\"0\":{\"1265\":1}}],[\"mybatis已经不再需要使用配置文件了\",{\"1\":{\"1259\":1}}],[\"mybatis针对于spring专门编写的支持框架\",{\"1\":{\"1253\":1}}],[\"mybatis针对于所有的sql操作都提供了对应的provider注解\",{\"1\":{\"902\":1}}],[\"mybatis实际上是在使用自己编写的数据源\",{\"1\":{\"1252\":1}}],[\"mybatis总共就三种数据源\",{\"1\":{\"1243\":1}}],[\"mybatis到底是怎么实现的\",{\"1\":{\"1243\":1}}],[\"mybatis数据源实现\",{\"0\":{\"1243\":1}}],[\"mybatis数据库测试\",{\"1\":{\"1017\":1}}],[\"mybatis依赖\",{\"1\":{\"1008\":1}}],[\"mybatis就会自动扫描对应包下所有的接口\",{\"1\":{\"1257\":1}}],[\"mybatis就会自动将对应的结果填入到对象的对应字段上\",{\"1\":{\"826\":1}}],[\"mybatis就可以正确使用jdk的日志框架进行日志打印了\",{\"1\":{\"951\":1}}],[\"mybatis同样可以正常解析\",{\"1\":{\"902\":1}}],[\"mybatis在插入后\",{\"1\":{\"897\":1}}],[\"mybatis在执行完查询语句后\",{\"1\":{\"841\":1}}],[\"mybatis9\",{\"0\":{\"891\":1}}],[\"mybatis不知道我们修改了数据\",{\"1\":{\"888\":1}}],[\"mybatis确实存在着缓存机制来进行性能优化\",{\"1\":{\"883\":1}}],[\"mybatis为了查询效率\",{\"1\":{\"882\":1}}],[\"mybatis为我们提供了几个默认的数据源实现\",{\"1\":{\"1242\":1}}],[\"mybatis为我们提供了\",{\"1\":{\"900\":1}}],[\"mybatis为我们提供了丰富的注解用于表示不同sql语句类型\",{\"1\":{\"896\":1}}],[\"mybatis为我们提供了一些参数用于处理这种问题\",{\"1\":{\"862\":1}}],[\"mybatis为我们提供的插入操作非常快捷\",{\"1\":{\"861\":1}}],[\"mybatis为我们的dml操作提供了几个预设方法\",{\"1\":{\"860\":1}}],[\"mybatis8\",{\"0\":{\"880\":1}}],[\"mybatis还针对多分支情况提供了choose操作\",{\"1\":{\"874\":1}}],[\"mybatis还为我们提供了一种更好的方式来处理这种问题\",{\"1\":{\"872\":1}}],[\"mybatis7\",{\"0\":{\"868\":1}}],[\"mybatis6\",{\"0\":{\"858\":1}}],[\"mybatis日志中\",{\"1\":{\"852\":1}}],[\"mybatis日志\",{\"0\":{\"852\":1}}],[\"mybatis一般情况下可以自动完成推断\",{\"1\":{\"850\":1}}],[\"mybatis5\",{\"0\":{\"846\":1}}],[\"mybatis也有日志系统\",{\"1\":{\"951\":1}}],[\"mybatis也为我们提供了丰富的注解用于处理这类问题\",{\"1\":{\"901\":1}}],[\"mybatis也为我们提供了多种转换方案\",{\"1\":{\"833\":1}}],[\"mybatis也能完成自动推断\",{\"1\":{\"861\":1}}],[\"mybatis也不可能提前帮我们写了实现类啊\",{\"1\":{\"842\":1}}],[\"mybatis仅仅是使用这种方式进行对象的构建\",{\"1\":{\"841\":1}}],[\"mybatis会先从二级缓存中查找数据\",{\"1\":{\"885\":1}}],[\"mybatis会选择性拼接我们的sql语句\",{\"1\":{\"873\":1}}],[\"mybatis会从传入的对象中自动获取需要的参数\",{\"1\":{\"863\":1}}],[\"mybatis会在查询完后自动为我们的user对象赋值\",{\"1\":{\"862\":1}}],[\"mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中\",{\"1\":{\"853\":1}}],[\"mybatis会并不能正确获取对应的参数\",{\"1\":{\"843\":1}}],[\"mybatis会出现问题\",{\"1\":{\"841\":1}}],[\"mybatis会自动判断\",{\"1\":{\"831\":1}}],[\"mybatis详解7\",{\"0\":{\"892\":1}}],[\"mybatis详解6\",{\"0\":{\"881\":1}}],[\"mybatis详解5\",{\"0\":{\"869\":1}}],[\"mybatis详解4\",{\"0\":{\"859\":1}}],[\"mybatis详解3\",{\"0\":{\"847\":1}}],[\"mybatis详解2\",{\"0\":{\"840\":1}}],[\"mybatis详解1\",{\"0\":{\"830\":1}}],[\"mybatis4\",{\"0\":{\"839\":1}}],[\"mybatis虽然可以查询到对应的记录\",{\"1\":{\"835\":1}}],[\"mybatisutils\",{\"1\":{\"865\":1,\"883\":2}}],[\"mybatisutil\",{\"1\":{\"830\":2,\"842\":1,\"884\":2}}],[\"mybatis3\",{\"0\":{\"829\":1}}],[\"mybatis非常智能\",{\"1\":{\"826\":1}}],[\"mybatis2\",{\"0\":{\"822\":1,\"823\":1}}],[\"mybatis\",{\"0\":{\"824\":1,\"1071\":1,\"1347\":1},\"1\":{\"816\":3,\"824\":6,\"825\":1,\"826\":4,\"830\":1,\"849\":1,\"872\":1,\"902\":2,\"1017\":4,\"1071\":5,\"1072\":2,\"1242\":3,\"1254\":1,\"1255\":3,\"1291\":1,\"1327\":1},\"2\":{\"821\":1,\"828\":1,\"838\":1,\"845\":1,\"857\":1,\"867\":1,\"879\":1,\"890\":1,\"906\":1}}],[\"mybatis1\",{\"0\":{\"815\":1,\"816\":1}}],[\"mybatis<\",{\"1\":{\"663\":2,\"1017\":1,\"1024\":1,\"1026\":1,\"1033\":1,\"1071\":1,\"1253\":2}}],[\"mysql的默认隔离级别\",{\"1\":{\"1270\":1}}],[\"mysql实现的驱动会被加载\",{\"1\":{\"789\":1}}],[\"mysql默认采用的是innodb引擎\",{\"1\":{\"782\":1}}],[\"mysql不支持\",{\"1\":{\"747\":1}}],[\"mysql就是一种关系型数据库\",{\"1\":{\"733\":1}}],[\"mysql\",{\"1\":{\"664\":2,\"732\":1,\"788\":4,\"796\":1,\"805\":1,\"824\":1,\"852\":1,\"904\":2,\"936\":2,\"1017\":2,\"1071\":2,\"1255\":2,\"1259\":2,\"1260\":3,\"1276\":2},\"2\":{\"741\":1,\"758\":1,\"776\":1,\"784\":1,\"793\":1,\"801\":1,\"808\":1}}],[\"mysql<\",{\"1\":{\"663\":1,\"1253\":1}}],[\"mythbusters\",{\"1\":{\"525\":1}}],[\"myclassloader\",{\"1\":{\"356\":3}}],[\"mix\",{\"1\":{\"1181\":1}}],[\"mirror>\",{\"1\":{\"1010\":1}}],[\"mirrorof>\",{\"1\":{\"1010\":1}}],[\"microsoft\",{\"1\":{\"732\":1,\"1096\":1}}],[\"milliseconds\",{\"1\":{\"1246\":1}}],[\"millis\",{\"1\":{\"300\":1}}],[\"min\",{\"1\":{\"233\":1,\"302\":2,\"431\":1,\"515\":1,\"617\":2,\"636\":1,\"641\":1,\"642\":1,\"765\":1,\"912\":1,\"978\":1}}],[\"mincapacity\",{\"1\":{\"182\":4}}],[\"mini\",{\"1\":{\"142\":2}}],[\"minisize\",{\"1\":{\"136\":1}}],[\"minimize\",{\"1\":{\"104\":1}}],[\"medium\",{\"1\":{\"993\":1}}],[\"me<\",{\"1\":{\"686\":1}}],[\"memcache等缓存框架\",{\"1\":{\"888\":1}}],[\"member\",{\"1\":{\"682\":1}}],[\"memory\",{\"1\":{\"311\":1}}],[\"meet\",{\"1\":{\"498\":3}}],[\"messagesource\",{\"1\":{\"1316\":1}}],[\"messageformat\",{\"1\":{\"1059\":1}}],[\"messageconverter等\",{\"1\":{\"553\":1}}],[\"message=\",{\"1\":{\"523\":1}}],[\"message\",{\"1\":{\"422\":4,\"523\":9,\"524\":5,\"969\":1,\"970\":1}}],[\"menu\",{\"1\":{\"331\":1}}],[\"me\",{\"1\":{\"299\":2,\"686\":2,\"687\":1,\"1093\":2}}],[\"merge\",{\"1\":{\"222\":1}}],[\"merge方法可以对重复键的值进行特殊操作\",{\"1\":{\"222\":1}}],[\"merge方法用于处理数据\",{\"1\":{\"222\":1}}],[\"metaclass\",{\"1\":{\"841\":1}}],[\"metrics\",{\"1\":{\"148\":2}}],[\"methodinvocation\",{\"1\":{\"1231\":1}}],[\"methodinterceptor\",{\"1\":{\"1231\":1}}],[\"methodbeforeadvice\",{\"1\":{\"1231\":2}}],[\"method就是我们的增强方法\",{\"1\":{\"1220\":1}}],[\"method是一样的\",{\"1\":{\"1176\":1}}],[\"method测试\",{\"1\":{\"1158\":1}}],[\"method指定对应的工厂方法\",{\"1\":{\"1158\":1}}],[\"method进行指定\",{\"1\":{\"1158\":1}}],[\"method属性来指定\",{\"1\":{\"1147\":1}}],[\"method和destroy\",{\"1\":{\"1147\":1,\"1176\":1}}],[\"method和constructor都和class一样\",{\"1\":{\"349\":1}}],[\"methodname\",{\"1\":{\"987\":1,\"1247\":2}}],[\"methodorderer\",{\"1\":{\"987\":4}}],[\"method模式\",{\"1\":{\"986\":1}}],[\"method=\",{\"1\":{\"619\":1,\"636\":1,\"641\":1,\"660\":1,\"682\":1,\"683\":1,\"1069\":1,\"1075\":1,\"1147\":2,\"1158\":1,\"1159\":1,\"1220\":1,\"1224\":1,\"1225\":1}}],[\"method\",{\"1\":{\"81\":2,\"101\":3,\"156\":1,\"296\":2,\"349\":15,\"356\":6,\"363\":2,\"364\":4,\"365\":1,\"569\":1,\"572\":1,\"589\":4,\"619\":1,\"620\":1,\"626\":3,\"841\":2,\"902\":1,\"1059\":12,\"1148\":5,\"1167\":1,\"1231\":6,\"1247\":5,\"1278\":3,\"1279\":1}}],[\"methodsource\",{\"1\":{\"994\":1}}],[\"methodsource注解即可指定方法\",{\"1\":{\"994\":1}}],[\"methods\",{\"1\":{\"81\":1,\"1148\":1}}],[\"means\",{\"1\":{\"92\":1}}],[\"means来划分各个无人机所管理的用户簇\",{\"1\":{\"13\":1}}],[\"means的优化目标是最小化无人机与对应集群用户的欧氏距离\",{\"1\":{\"13\":1}}],[\"means可以视为获得无人机部署的低复杂度方案\",{\"1\":{\"13\":1}}],[\"means算法\",{\"1\":{\"13\":1}}],[\"means和igk算法比具有较低的复杂度\",{\"1\":{\"5\":1}}],[\"mean算法获得初始单元划分\",{\"1\":{\"5\":1}}],[\"mean\",{\"0\":{\"43\":1,\"44\":1,\"99\":1,\"103\":1},\"1\":{\"5\":1,\"40\":1,\"41\":1,\"75\":1,\"77\":1,\"82\":1,\"92\":1}}],[\"mc\",{\"0\":{\"76\":1,\"80\":1,\"83\":1,\"85\":1,\"88\":1,\"114\":1},\"1\":{\"76\":1,\"80\":2,\"81\":1,\"82\":1,\"88\":2,\"101\":1,\"123\":1}}],[\"mdp就变为mp\",{\"1\":{\"20\":1}}],[\"mdp\",{\"0\":{\"20\":1}}],[\"maven会将该项目打成jar包\",{\"1\":{\"1038\":1}}],[\"maven测试和打包\",{\"0\":{\"1034\":1}}],[\"maven继承和多模块\",{\"0\":{\"1031\":1}}],[\"maven5\",{\"0\":{\"1029\":1,\"1030\":1}}],[\"maven项目导入自己项目\",{\"0\":{\"1023\":1}}],[\"maven项目结构\",{\"0\":{\"1001\":1}}],[\"maven4\",{\"0\":{\"1021\":1,\"1022\":1}}],[\"maven还给我们提供了一个resource目标\",{\"1\":{\"1017\":1}}],[\"maven3\",{\"0\":{\"1013\":1,\"1014\":1},\"1\":{\"1010\":1}}],[\"maven可以直接从中央仓库中下载大部分的依赖\",{\"1\":{\"1009\":1}}],[\"maven是如何进行依赖管理呢\",{\"1\":{\"1009\":1}}],[\"maven依赖作用域\",{\"0\":{\"1015\":1}}],[\"maven依赖管理原理\",{\"0\":{\"1009\":1}}],[\"maven依赖导入\",{\"0\":{\"1008\":1}}],[\"maven2\",{\"0\":{\"1006\":1,\"1007\":1}}],[\"maven的配置文件是以project为根节点\",{\"1\":{\"1002\":1}}],[\"maven就很好地解决了这个问题\",{\"1\":{\"1001\":1}}],[\"maven也需要安装环境\",{\"1\":{\"1000\":1}}],[\"maven利用一个中央信息片断能管理一个项目的构建\",{\"1\":{\"1000\":1}}],[\"maven\",{\"0\":{\"1048\":1,\"1350\":1},\"1\":{\"1000\":4,\"1002\":6,\"1010\":2,\"1023\":4,\"1032\":6},\"2\":{\"1005\":1,\"1012\":1,\"1020\":1,\"1028\":1,\"1040\":1}}],[\"maven1\",{\"0\":{\"998\":1,\"999\":1}}],[\"make\",{\"1\":{\"789\":1}}],[\"mandatory\",{\"1\":{\"1283\":2}}],[\"manifest>\",{\"1\":{\"1037\":1}}],[\"manipulation\",{\"1\":{\"744\":1}}],[\"many注解来指定其他查询语句进行嵌套查询\",{\"1\":{\"901\":1}}],[\"manual\",{\"1\":{\"788\":1}}],[\"managedtransaction\",{\"1\":{\"1273\":1}}],[\"manage\",{\"1\":{\"1148\":1}}],[\"managerid\",{\"1\":{\"748\":2}}],[\"manager\",{\"1\":{\"664\":3,\"666\":7,\"748\":1,\"939\":7,\"1047\":16}}],[\"managementfactory\",{\"1\":{\"295\":1}}],[\"mac\",{\"1\":{\"727\":1,\"976\":2}}],[\"macintosh\",{\"1\":{\"727\":1}}],[\"macos\",{\"1\":{\"727\":1}}],[\"machine\",{\"1\":{\"340\":1}}],[\"male\",{\"1\":{\"376\":1}}],[\"markerinterface\",{\"1\":{\"1327\":1}}],[\"marked\",{\"1\":{\"1283\":1}}],[\"mark已经失效\",{\"1\":{\"265\":1}}],[\"mark\",{\"1\":{\"265\":6}}],[\"markov\",{\"0\":{\"20\":1},\"1\":{\"20\":2,\"135\":1}}],[\"markovian\",{\"1\":{\"14\":1}}],[\"matter\",{\"1\":{\"1181\":1}}],[\"matching\",{\"1\":{\"841\":1,\"1119\":1}}],[\"matchingbeans\",{\"1\":{\"631\":3}}],[\"matches\",{\"1\":{\"403\":2,\"626\":2,\"979\":2}}],[\"matches方法用于对给定正则表达式进行匹配\",{\"1\":{\"403\":1}}],[\"match\",{\"1\":{\"403\":1,\"515\":1}}],[\"mathteacher\",{\"1\":{\"1133\":5,\"1134\":2}}],[\"math也是java\",{\"1\":{\"431\":1}}],[\"math类\",{\"1\":{\"431\":1}}],[\"math\",{\"1\":{\"222\":3,\"386\":3,\"431\":5,\"1205\":1,\"1211\":1}}],[\"matrix\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"map>\",{\"1\":{\"1136\":1}}],[\"mapunderscoretocamelcase\",{\"1\":{\"1017\":1}}],[\"mapperinterface\",{\"1\":{\"1328\":1}}],[\"mapper注解都能够被扫描并加载\",{\"1\":{\"1327\":1}}],[\"mapper注解即可完成\",{\"1\":{\"1257\":1}}],[\"mapperfactorybeanclass\",{\"1\":{\"1327\":1}}],[\"mapper交给spring进行管理\",{\"1\":{\"1241\":1}}],[\"mapper创在对应的mapper文件夹下\",{\"1\":{\"1071\":1}}],[\"mapper2\",{\"1\":{\"884\":2}}],[\"mapper>\",{\"1\":{\"826\":1,\"842\":1}}],[\"mappers>\",{\"1\":{\"826\":1,\"842\":1,\"894\":2,\"1017\":1,\"1071\":1,\"1255\":1}}],[\"mappers\",{\"1\":{\"819\":1,\"826\":1,\"841\":1}}],[\"mapperscan的原理就全部解释完毕了\",{\"1\":{\"1328\":1}}],[\"mapperscannerconfigurer\",{\"1\":{\"1326\":1,\"1327\":1}}],[\"mapperscannerregistrar\",{\"1\":{\"1326\":1}}],[\"mapperscans\",{\"1\":{\"1326\":1}}],[\"mapperscan是如何实现的\",{\"1\":{\"1326\":1}}],[\"mapperscan\",{\"1\":{\"671\":1,\"1257\":1,\"1259\":1,\"1276\":1,\"1326\":1}}],[\"mapper\",{\"1\":{\"671\":1,\"672\":2,\"692\":1,\"826\":3,\"842\":4,\"843\":2,\"865\":8,\"871\":2,\"876\":1,\"877\":2,\"883\":6,\"884\":2,\"888\":2,\"894\":2,\"897\":1,\"904\":1,\"1017\":1,\"1072\":2,\"1093\":2,\"1255\":1,\"1257\":3,\"1259\":1,\"1260\":2,\"1276\":1,\"1277\":4,\"1281\":2,\"1282\":1,\"1283\":1,\"1308\":4,\"1327\":1}}],[\"mappedhandler\",{\"1\":{\"626\":13}}],[\"mappings\",{\"1\":{\"1054\":1}}],[\"mapping>\",{\"1\":{\"545\":2,\"1054\":6}}],[\"mapping\",{\"1\":{\"53\":2,\"58\":5,\"62\":1,\"569\":1,\"1054\":1}}],[\"mapstreamdemo\",{\"1\":{\"519\":1}}],[\"maptoint\",{\"1\":{\"228\":1}}],[\"map中只有键为1的映射\",{\"1\":{\"214\":1}}],[\"map<test\",{\"1\":{\"241\":1}}],[\"map<string\",{\"1\":{\"222\":1,\"475\":2,\"631\":1,\"833\":1,\"836\":1,\"843\":1,\"1072\":1,\"1207\":1,\"1244\":1}}],[\"map<integer\",{\"1\":{\"214\":4,\"221\":1,\"223\":3}}],[\"map<\",{\"1\":{\"213\":1}}],[\"map<k\",{\"1\":{\"213\":1,\"215\":1}}],[\"map并不是collection体系下的接口\",{\"1\":{\"213\":1}}],[\"map目前只需要记住\",{\"1\":{\"207\":1}}],[\"map\",{\"0\":{\"212\":1,\"213\":1,\"220\":1},\"1\":{\"207\":1,\"212\":2,\"213\":2,\"214\":16,\"215\":1,\"221\":10,\"223\":12,\"224\":6,\"228\":1,\"241\":5,\"475\":7,\"519\":2,\"522\":4,\"834\":2,\"843\":2,\"1072\":3,\"1093\":1,\"1136\":2,\"1207\":3}}],[\"mainfilter\",{\"1\":{\"1104\":1}}],[\"maintain\",{\"1\":{\"1047\":1}}],[\"maintest\",{\"1\":{\"959\":2,\"986\":1,\"988\":1,\"1017\":2,\"1035\":1}}],[\"mainclass>\",{\"1\":{\"1037\":1}}],[\"mainconfiguration\",{\"1\":{\"652\":1,\"1166\":2,\"1167\":1,\"1168\":1,\"1169\":1,\"1172\":1,\"1176\":1,\"1177\":2,\"1188\":2,\"1190\":1,\"1192\":1,\"1198\":1,\"1232\":1,\"1233\":1,\"1254\":1,\"1256\":1,\"1257\":2,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"maincontroller\",{\"1\":{\"554\":1,\"569\":1,\"588\":1,\"589\":1}}],[\"main<\",{\"1\":{\"1037\":1}}],[\"maininterceptor\",{\"1\":{\"595\":1,\"596\":1,\"600\":1}}],[\"maininitializer\",{\"1\":{\"552\":1,\"619\":1}}],[\"mainobject\",{\"1\":{\"452\":2}}],[\"mainloop\",{\"1\":{\"324\":2}}],[\"main\",{\"1\":{\"142\":4,\"144\":1,\"161\":3,\"162\":1,\"171\":10,\"172\":3,\"173\":1,\"180\":2,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":4,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":1,\"277\":4,\"278\":2,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":2,\"312\":17,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":2,\"329\":2,\"330\":2,\"331\":7,\"339\":1,\"340\":1,\"341\":1,\"343\":10,\"348\":2,\"349\":5,\"350\":3,\"355\":9,\"356\":2,\"363\":2,\"364\":5,\"365\":3,\"376\":3,\"377\":1,\"378\":1,\"384\":4,\"385\":1,\"386\":2,\"392\":1,\"393\":1,\"394\":1,\"395\":2,\"396\":1,\"397\":1,\"398\":1,\"399\":2,\"401\":3,\"402\":3,\"403\":2,\"408\":2,\"409\":1,\"411\":2,\"412\":5,\"413\":1,\"414\":3,\"415\":9,\"424\":5,\"425\":1,\"431\":2,\"432\":1,\"437\":1,\"438\":3,\"439\":4,\"445\":1,\"446\":1,\"448\":2,\"449\":2,\"451\":1,\"452\":3,\"453\":1,\"461\":2,\"462\":1,\"464\":2,\"467\":2,\"468\":2,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":6,\"485\":2,\"487\":1,\"488\":3,\"490\":4,\"504\":1,\"512\":1,\"518\":1,\"519\":1,\"521\":1,\"522\":1,\"523\":2,\"719\":3,\"720\":2,\"726\":2,\"727\":2,\"796\":2,\"798\":1,\"805\":1,\"806\":4,\"824\":1,\"826\":1,\"830\":1,\"841\":1,\"908\":4,\"910\":2,\"911\":1,\"918\":1,\"919\":2,\"927\":1,\"929\":4,\"950\":4,\"956\":2,\"959\":4,\"1008\":2,\"1023\":1,\"1032\":2,\"1117\":1,\"1119\":5,\"1125\":1,\"1188\":1,\"1192\":2,\"1221\":1,\"1224\":1,\"1225\":1,\"1233\":1,\"1256\":1,\"1257\":1,\"1260\":3,\"1278\":3,\"1283\":4,\"1296\":3,\"1298\":3,\"1328\":1}}],[\"maxage\",{\"1\":{\"1092\":2}}],[\"maxa∈a\",{\"1\":{\"142\":1}}],[\"maxrequestsize\",{\"1\":{\"619\":1}}],[\"maxfilesize\",{\"1\":{\"619\":1}}],[\"maximum\",{\"1\":{\"217\":2}}],[\"max\",{\"1\":{\"182\":4,\"217\":2,\"233\":1,\"302\":1,\"386\":1,\"431\":1,\"727\":1,\"765\":1,\"912\":1,\"978\":1,\"1091\":1,\"1096\":1}}],[\"max​q^​\",{\"1\":{\"140\":1,\"141\":1,\"142\":3}}],[\"maybesetlastmodified\",{\"1\":{\"1059\":2}}],[\"may\",{\"1\":{\"19\":1,\"296\":1,\"841\":1}}],[\"m\",{\"1\":{\"9\":1,\"213\":1,\"221\":3,\"403\":4,\"733\":1}}],[\"more\",{\"1\":{\"1047\":1,\"1181\":1}}],[\"moreover\",{\"1\":{\"58\":1}}],[\"mozilla\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"mobile\",{\"1\":{\"727\":1}}],[\"mobility\",{\"1\":{\"14\":1}}],[\"monkey\",{\"1\":{\"796\":1}}],[\"monro\",{\"1\":{\"98\":2}}],[\"monto\",{\"0\":{\"95\":1}}],[\"monte\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"modified\",{\"1\":{\"1059\":1}}],[\"modifiers\",{\"1\":{\"350\":1}}],[\"modifiersfield\",{\"1\":{\"350\":3}}],[\"mode\",{\"1\":{\"727\":1,\"993\":2,\"1091\":1,\"1096\":1}}],[\"modelversion>\",{\"1\":{\"1002\":1,\"1023\":1,\"1032\":1}}],[\"modelattribute注解设置的值\",{\"1\":{\"602\":1}}],[\"modelattribute注解\",{\"1\":{\"602\":1}}],[\"modelandview\",{\"1\":{\"561\":2,\"563\":6,\"569\":4,\"572\":2,\"573\":2,\"574\":6,\"576\":2,\"579\":2,\"580\":2,\"581\":2,\"582\":4,\"583\":2,\"585\":2,\"586\":2,\"588\":2,\"595\":2,\"600\":2,\"626\":1}}],[\"modelmap\",{\"1\":{\"563\":1}}],[\"model|environment\",{\"1\":{\"45\":1}}],[\"model\",{\"0\":{\"10\":1,\"75\":1},\"1\":{\"14\":3,\"45\":2,\"76\":1,\"77\":2,\"541\":1,\"563\":3,\"575\":6,\"603\":1,\"605\":3,\"636\":3}}],[\"modules命令来列出所有的模块\",{\"1\":{\"463\":1}}],[\"module\",{\"1\":{\"461\":3,\"464\":8,\"465\":6,\"466\":7,\"467\":6,\"468\":2}}],[\"modles可选择\",{\"1\":{\"14\":1}}],[\"mos主要是有关传输速率rkn​​的函数\",{\"1\":{\"13\":1}}],[\"mosrkn​​​=t=0∑ts​​moskn​​\",{\"1\":{\"10\":1}}],[\"moskn​​\",{\"1\":{\"10\":3}}],[\"mos\",{\"1\":{\"5\":1}}],[\"movement\",{\"0\":{\"3\":1},\"1\":{\"4\":2}}],[\"a和b都是以原型模式进行创建\",{\"1\":{\"1301\":1}}],[\"a和c在大量地直接使用b\",{\"1\":{\"1116\":1}}],[\"aware的中文意思为感知\",{\"1\":{\"1186\":1}}],[\"aware\",{\"0\":{\"1186\":1}}],[\"aware接口+任务调度+监听器\",{\"0\":{\"1184\":1}}],[\"awgn\",{\"1\":{\"9\":1}}],[\"against\",{\"1\":{\"987\":1,\"1047\":1}}],[\"age=18\",{\"1\":{\"852\":1}}],[\"age=0\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"age>\",{\"1\":{\"817\":1}}],[\"age已经初始化完\",{\"1\":{\"166\":1}}],[\"age\",{\"1\":{\"161\":1,\"162\":2,\"166\":18,\"274\":1,\"278\":1,\"343\":1,\"348\":1,\"349\":1,\"373\":2,\"375\":6,\"376\":2,\"377\":2,\"398\":1,\"464\":4,\"610\":7,\"612\":2,\"613\":2,\"747\":3,\"834\":3,\"835\":3,\"836\":2,\"841\":6,\"843\":7,\"849\":1,\"850\":2,\"851\":2,\"852\":1,\"853\":3,\"855\":3,\"861\":2,\"862\":2,\"863\":4,\"871\":1,\"873\":1,\"874\":3,\"877\":3,\"896\":2,\"897\":4,\"898\":1,\"900\":6,\"902\":3,\"1008\":1,\"1135\":3}}],[\"agent从一个状态出发\",{\"1\":{\"48\":1}}],[\"agent从一个状态出发可以得到的平均return\",{\"1\":{\"48\":1}}],[\"agent可能走出的全部轨迹\",{\"1\":{\"19\":1}}],[\"agent将获得负奖励\",{\"1\":{\"13\":1}}],[\"agent\",{\"1\":{\"13\":1,\"19\":2,\"48\":2,\"154\":1,\"727\":1,\"1091\":1,\"1096\":1}}],[\"aferall\",{\"1\":{\"985\":1}}],[\"afterreturn\",{\"1\":{\"1236\":1}}],[\"afterreturning\",{\"1\":{\"1231\":1,\"1236\":3}}],[\"afterreturningadvice\",{\"1\":{\"1231\":1}}],[\"afterthrowing等\",{\"1\":{\"1236\":1}}],[\"afterstudy\",{\"1\":{\"1218\":1,\"1220\":1,\"1223\":1}}],[\"afterspringsecurityfilterchain\",{\"1\":{\"705\":1}}],[\"afterwards\",{\"1\":{\"1047\":1}}],[\"afterall则会在所有测试用例完成之后执行\",{\"1\":{\"985\":1}}],[\"aftereach来实现灵活控制\",{\"1\":{\"986\":1}}],[\"aftereach\",{\"1\":{\"985\":1}}],[\"aftercompletion\",{\"1\":{\"595\":1,\"600\":1}}],[\"after\",{\"1\":{\"218\":1,\"509\":9,\"1220\":1}}],[\"afternodeinsertion\",{\"1\":{\"216\":1}}],[\"afternodeaccess\",{\"1\":{\"216\":1}}],[\"aug\",{\"1\":{\"852\":1}}],[\"autowirecapablebeanfactory\",{\"1\":{\"1316\":1}}],[\"autowirecandidate\",{\"1\":{\"1167\":1,\"1170\":1}}],[\"autowired来进行依赖注入\",{\"1\":{\"1291\":1}}],[\"autowired注入\",{\"1\":{\"1175\":1}}],[\"autowired注解对成员字段进行自动装配\",{\"1\":{\"1175\":1}}],[\"autowired字段注入\",{\"1\":{\"1175\":1}}],[\"autowired默认是bytype\",{\"1\":{\"1175\":1}}],[\"autowired默认采用bytype的方式进行自动装配\",{\"1\":{\"1174\":1}}],[\"autowired时相同的\",{\"1\":{\"1175\":1}}],[\"autowired并不是只能用于字段\",{\"1\":{\"1173\":1}}],[\"autowired\",{\"1\":{\"1173\":2,\"1174\":1,\"1181\":3,\"1291\":1,\"1308\":1}}],[\"autowire\",{\"1\":{\"1140\":1,\"1318\":1}}],[\"autowire属性最普通的有两个值\",{\"1\":{\"1138\":1}}],[\"autowire=\",{\"1\":{\"1137\":1,\"1139\":1,\"1140\":1,\"1141\":1}}],[\"autocommit\",{\"1\":{\"830\":3,\"871\":1,\"1242\":5,\"1244\":1,\"1273\":2}}],[\"automatically\",{\"1\":{\"788\":1}}],[\"authresult\",{\"1\":{\"712\":6}}],[\"authenticate\",{\"1\":{\"711\":1}}],[\"authenticated\",{\"1\":{\"680\":1,\"681\":1}}],[\"authenticationexception\",{\"1\":{\"711\":1,\"713\":1}}],[\"authenticationresult\",{\"1\":{\"711\":4}}],[\"authentication\",{\"1\":{\"711\":1,\"712\":1,\"713\":2}}],[\"authenticationmanager\",{\"1\":{\"666\":1}}],[\"authorized\",{\"1\":{\"1047\":1}}],[\"authorizehttprequests\",{\"1\":{\"680\":1,\"681\":1,\"692\":1,\"693\":1}}],[\"authorizeservice\",{\"1\":{\"668\":1,\"672\":1}}],[\"authority\",{\"1\":{\"662\":2}}],[\"authorities\",{\"1\":{\"662\":3}}],[\"auth\",{\"1\":{\"662\":1,\"680\":2,\"681\":3,\"682\":1,\"692\":4,\"693\":3}}],[\"a1\",{\"1\":{\"767\":2}}],[\"a1​\",{\"1\":{\"19\":2,\"20\":2,\"81\":1}}],[\"a>\",{\"1\":{\"620\":1,\"1074\":1}}],[\"axios\",{\"1\":{\"617\":7,\"636\":3,\"641\":2,\"642\":2,\"660\":1,\"666\":1}}],[\"axios异步请求\",{\"0\":{\"617\":1}}],[\"aopconfigutils\",{\"1\":{\"1310\":3}}],[\"aop实际上也是通过这种机制实现的\",{\"1\":{\"1310\":1}}],[\"aop产生代理对象的逻辑是在属性填充之后\",{\"1\":{\"1301\":1}}],[\"aoputils\",{\"1\":{\"1278\":2}}],[\"aop2\",{\"0\":{\"1229\":1}}],[\"aop是基于动态代理实现的\",{\"1\":{\"1222\":1}}],[\"aop中运行的方法\",{\"1\":{\"1219\":1}}],[\"aop代理\",{\"1\":{\"1219\":1}}],[\"aop时在带有给定注释的类型中声明的方法的执行\",{\"1\":{\"1219\":1}}],[\"aop时在匹配类型中声明的方法的执行\",{\"1\":{\"1219\":1}}],[\"aop时方法的执行\",{\"1\":{\"1219\":5}}],[\"aop时使用的主要点切割指示器\",{\"1\":{\"1219\":1}}],[\"aop支持以下aspectj切点指示器\",{\"1\":{\"1219\":1}}],[\"aop=\",{\"1\":{\"1217\":1}}],[\"aop面向切片2\",{\"0\":{\"1230\":1}}],[\"aop面向切片\",{\"0\":{\"1215\":1}}],[\"aop1\",{\"0\":{\"1214\":1}}],[\"aop等\",{\"1\":{\"534\":1}}],[\"aop\",{\"0\":{\"1355\":1},\"1\":{\"534\":1,\"1215\":1,\"1217\":4,\"1218\":1,\"1219\":1,\"1220\":3,\"1224\":1,\"1225\":2,\"1226\":2,\"1231\":1,\"1278\":2,\"1283\":2}}],[\"a的模块呢\",{\"1\":{\"465\":1}}],[\"a依赖于其他模块\",{\"1\":{\"465\":1}}],[\"a不暴露\",{\"1\":{\"464\":1}}],[\"a中暴露出来的包内容了\",{\"1\":{\"464\":1}}],[\"a<t>\",{\"1\":{\"439\":2}}],[\"a<>\",{\"1\":{\"439\":1}}],[\"a<string>\",{\"1\":{\"439\":2}}],[\"aeiou\",{\"1\":{\"403\":1}}],[\"aerial\",{\"1\":{\"4\":1}}],[\"aa\",{\"1\":{\"991\":1}}],[\"aarch64\",{\"1\":{\"979\":1}}],[\"aasd\",{\"1\":{\"364\":1}}],[\"aaaa\",{\"1\":{\"228\":1,\"399\":1}}],[\"aaa\",{\"1\":{\"171\":1,\"200\":1,\"201\":1,\"205\":4,\"237\":2,\"402\":1,\"475\":4,\"480\":2,\"497\":1,\"528\":1,\"995\":2,\"1207\":1}}],[\"avatar=https\",{\"1\":{\"852\":1}}],[\"avatar\",{\"1\":{\"849\":1,\"850\":2,\"852\":1}}],[\"available\",{\"1\":{\"248\":2,\"255\":1,\"356\":1,\"843\":1,\"1119\":1}}],[\"avg\",{\"1\":{\"765\":1,\"779\":1}}],[\"avif\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"average\",{\"0\":{\"150\":1,\"153\":1},\"1\":{\"48\":2,\"154\":1}}],[\"above\",{\"1\":{\"1047\":1}}],[\"ab\",{\"1\":{\"488\":1}}],[\"abs方法可以求绝对值\",{\"1\":{\"431\":1}}],[\"abs\",{\"1\":{\"431\":1}}],[\"abstractrefreshableapplicationcontext\",{\"1\":{\"1296\":1}}],[\"abstractplatformtransactionmanager\",{\"1\":{\"1283\":2}}],[\"abstractapplicationcontext\",{\"1\":{\"1181\":1,\"1296\":1,\"1320\":1}}],[\"abstractannotationconfigdispatcherservletinitializer\",{\"1\":{\"552\":2,\"619\":1}}],[\"abstract=\",{\"1\":{\"1150\":1,\"1151\":1}}],[\"abstractsecuritywebapplicationinitializer\",{\"1\":{\"650\":1}}],[\"abstractset<e>\",{\"1\":{\"224\":1}}],[\"abstractsequentiallist<e>\",{\"1\":{\"182\":1,\"199\":1}}],[\"abstractmap<k\",{\"1\":{\"215\":1}}],[\"abstractlist<e>\",{\"1\":{\"182\":1}}],[\"abstract\",{\"1\":{\"173\":8,\"296\":1,\"375\":2,\"376\":1,\"412\":2,\"447\":2,\"474\":1,\"480\":2,\"504\":1,\"1104\":1,\"1296\":1}}],[\"abc\",{\"1\":{\"403\":2,\"897\":1}}],[\"abcabccaa\",{\"1\":{\"403\":1}}],[\"abcd\",{\"1\":{\"248\":3,\"462\":1,\"488\":1}}],[\"a是上一次计算的值\",{\"1\":{\"228\":1}}],[\"apache\",{\"1\":{\"841\":2,\"843\":2,\"873\":1,\"1000\":3,\"1002\":3,\"1023\":3,\"1032\":3,\"1047\":1,\"1272\":1}}],[\"apng\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"api保持一致\",{\"1\":{\"1260\":1}}],[\"api<\",{\"1\":{\"1025\":1,\"1175\":1,\"1260\":1}}],[\"api的改进等\",{\"1\":{\"480\":1}}],[\"api\",{\"0\":{\"476\":1},\"1\":{\"228\":1,\"462\":1,\"476\":1,\"489\":1,\"513\":2,\"617\":1,\"787\":1}}],[\"api添加了一个新的抽象称为\",{\"1\":{\"228\":1}}],[\"appclassloader\",{\"1\":{\"1109\":1}}],[\"apptest\",{\"1\":{\"779\":1}}],[\"app>\",{\"1\":{\"545\":1}}],[\"app\",{\"1\":{\"545\":2,\"1047\":1}}],[\"applied\",{\"1\":{\"708\":1}}],[\"applicationstartup\",{\"1\":{\"1320\":2}}],[\"applicationlistener<testevent>\",{\"1\":{\"1192\":1}}],[\"applicationlistener<contextrefreshedevent>\",{\"1\":{\"1191\":1}}],[\"applicationeventpublisher\",{\"1\":{\"1192\":2,\"1316\":1}}],[\"applicationeventpublisheraware\",{\"1\":{\"1192\":1}}],[\"applicationevent\",{\"1\":{\"1192\":1}}],[\"applicationcontextaware\",{\"1\":{\"1327\":1}}],[\"applicationcontext是依靠内部维护的beanfactory对象来完成这些功能的\",{\"1\":{\"1316\":1}}],[\"applicationcontext是应用程序上下文的顶层接口\",{\"1\":{\"1119\":1}}],[\"applicationcontext有着多种实现\",{\"1\":{\"1297\":1}}],[\"applicationcontext才具有了管理和生产bean对象的能力\",{\"1\":{\"1296\":1}}],[\"applicationcontext\",{\"1\":{\"625\":2,\"631\":1,\"1119\":3,\"1125\":1,\"1166\":2,\"1169\":1,\"1192\":1,\"1221\":1,\"1224\":1,\"1225\":1,\"1233\":1,\"1256\":1,\"1257\":1,\"1260\":1,\"1278\":1,\"1288\":1,\"1296\":2,\"1298\":2,\"1299\":1,\"1316\":2,\"1327\":1,\"1328\":1}}],[\"application\",{\"1\":{\"615\":1,\"616\":1,\"617\":3,\"636\":1,\"666\":1,\"727\":3,\"789\":1,\"1047\":1,\"1091\":3,\"1096\":3,\"1119\":1,\"1221\":1,\"1224\":1,\"1225\":1,\"1296\":2,\"1299\":1}}],[\"applets\",{\"1\":{\"787\":1}}],[\"applewebkit\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"apple\",{\"1\":{\"412\":3,\"994\":1}}],[\"applyafterconcurrenthandlingstarted\",{\"1\":{\"626\":1}}],[\"applyposthandle\",{\"1\":{\"626\":1}}],[\"applyprehandle\",{\"1\":{\"626\":1}}],[\"applydefaultviewname\",{\"1\":{\"626\":1}}],[\"apply\",{\"1\":{\"181\":1}}],[\"append\",{\"1\":{\"254\":1,\"402\":7,\"948\":11}}],[\"appears\",{\"1\":{\"81\":1}}],[\"appropriate\",{\"1\":{\"324\":1}}],[\"approximation\",{\"0\":{\"130\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"92\":1,\"147\":1}}],[\"approximate\",{\"1\":{\"82\":1}}],[\"approach\",{\"1\":{\"14\":2,\"1181\":2}}],[\"around\",{\"1\":{\"1224\":1,\"1225\":1,\"1237\":2}}],[\"article\",{\"1\":{\"1190\":1}}],[\"artifactid\",{\"1\":{\"1003\":2}}],[\"artifactid>\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"611\":1,\"616\":1,\"649\":2,\"663\":4,\"1002\":1,\"1008\":1,\"1017\":3,\"1018\":1,\"1023\":2,\"1024\":1,\"1025\":3,\"1026\":2,\"1032\":2,\"1033\":6,\"1037\":1,\"1071\":2,\"1074\":1,\"1118\":1,\"1175\":1,\"1217\":1,\"1253\":4,\"1260\":3,\"1290\":2}}],[\"artteacher\",{\"1\":{\"1132\":2,\"1133\":6,\"1134\":3,\"1140\":1,\"1141\":1}}],[\"art\",{\"1\":{\"1126\":2,\"1127\":1}}],[\"artstudent\",{\"1\":{\"1126\":4,\"1127\":1,\"1149\":4,\"1150\":3,\"1151\":3,\"1178\":2}}],[\"archive>\",{\"1\":{\"1037\":1}}],[\"arch\",{\"1\":{\"979\":1}}],[\"are\",{\"1\":{\"843\":1,\"1047\":4,\"1148\":2,\"1181\":4}}],[\"arithmeticexception\",{\"1\":{\"423\":1}}],[\"argnames\",{\"1\":{\"1235\":1,\"1236\":1}}],[\"argue\",{\"1\":{\"1181\":1}}],[\"argumentssource\",{\"1\":{\"995\":1}}],[\"argument\",{\"1\":{\"509\":2}}],[\"arg就是构造方法的一个参数\",{\"1\":{\"1134\":1}}],[\"arg标签\",{\"1\":{\"1134\":1}}],[\"arg0\",{\"1\":{\"843\":1}}],[\"arg1\",{\"1\":{\"843\":1}}],[\"arg\",{\"1\":{\"399\":2,\"900\":3,\"1134\":1,\"1135\":2,\"1224\":2}}],[\"args\",{\"1\":{\"161\":3,\"162\":1,\"171\":5,\"172\":3,\"173\":1,\"180\":1,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":2,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":1,\"277\":2,\"278\":1,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":1,\"339\":1,\"340\":1,\"341\":1,\"343\":9,\"348\":2,\"349\":3,\"350\":3,\"355\":3,\"356\":1,\"363\":1,\"364\":3,\"365\":2,\"376\":2,\"377\":1,\"378\":1,\"384\":4,\"385\":1,\"386\":2,\"392\":1,\"393\":1,\"394\":1,\"395\":2,\"396\":1,\"397\":1,\"398\":1,\"399\":3,\"401\":3,\"402\":3,\"403\":2,\"408\":2,\"409\":1,\"411\":1,\"412\":3,\"413\":1,\"414\":3,\"415\":5,\"424\":4,\"425\":1,\"431\":2,\"432\":1,\"437\":1,\"438\":3,\"439\":2,\"445\":1,\"446\":1,\"448\":1,\"449\":2,\"451\":1,\"452\":1,\"453\":1,\"461\":1,\"462\":1,\"464\":1,\"468\":1,\"475\":3,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":5,\"485\":2,\"487\":1,\"488\":3,\"490\":4,\"497\":1,\"504\":1,\"512\":1,\"518\":1,\"519\":1,\"521\":1,\"522\":1,\"523\":1,\"719\":3,\"720\":2,\"726\":2,\"727\":2,\"796\":1,\"798\":1,\"805\":1,\"806\":4,\"824\":1,\"826\":1,\"830\":1,\"908\":1,\"910\":1,\"950\":2,\"956\":1,\"1008\":1,\"1023\":1,\"1032\":1,\"1117\":1,\"1119\":3,\"1125\":1,\"1188\":1,\"1192\":1,\"1219\":2,\"1221\":1,\"1224\":1,\"1225\":1,\"1231\":3,\"1233\":1,\"1235\":1,\"1247\":2,\"1256\":1,\"1257\":1,\"1260\":1,\"1278\":1,\"1296\":3,\"1298\":2,\"1300\":4,\"1328\":1}}],[\"arrav\",{\"1\":{\"395\":1}}],[\"array就是我们要遍历的数组\",{\"1\":{\"394\":1}}],[\"arraydeque<>\",{\"1\":{\"202\":1}}],[\"array\",{\"1\":{\"182\":2,\"392\":2,\"393\":2,\"394\":4,\"395\":2,\"449\":6,\"451\":6,\"452\":3,\"613\":3}}],[\"arraylist中取第一个元素\",{\"1\":{\"1246\":1}}],[\"arraylist源码部分\",{\"1\":{\"182\":1}}],[\"arraylist<e>\",{\"1\":{\"182\":1}}],[\"arraylist<>\",{\"1\":{\"180\":1,\"182\":6,\"228\":5,\"233\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":1,\"330\":1,\"343\":1,\"350\":1,\"515\":1,\"518\":1,\"519\":1,\"522\":1,\"1321\":1}}],[\"arraylist<string>\",{\"1\":{\"180\":1,\"182\":1}}],[\"arraylist\",{\"0\":{\"182\":1},\"1\":{\"180\":2,\"182\":3,\"190\":1,\"343\":1,\"350\":1,\"522\":2,\"528\":1,\"631\":1}}],[\"arrays类\",{\"1\":{\"432\":2}}],[\"arrays\",{\"1\":{\"171\":9,\"181\":1,\"182\":4,\"187\":2,\"191\":2,\"192\":1,\"205\":1,\"206\":1,\"222\":1,\"228\":2,\"234\":1,\"235\":1,\"236\":1,\"237\":4,\"255\":1,\"330\":3,\"343\":1,\"432\":5,\"449\":5,\"451\":4,\"452\":2,\"516\":2,\"521\":1,\"522\":2,\"918\":1,\"927\":1,\"1069\":1,\"1234\":1,\"1319\":1,\"1327\":1}}],[\"arr\",{\"1\":{\"171\":12,\"330\":3,\"395\":8,\"397\":2,\"424\":2,\"432\":2,\"992\":1}}],[\"adaptbeaninstance\",{\"1\":{\"1300\":1}}],[\"adam\",{\"1\":{\"525\":1}}],[\"advisor\",{\"1\":{\"1231\":1}}],[\"advisor>\",{\"1\":{\"1231\":1}}],[\"advice\",{\"1\":{\"1226\":1,\"1231\":1}}],[\"advantage\",{\"0\":{\"25\":1}}],[\"adriver\",{\"1\":{\"789\":6}}],[\"ad\",{\"1\":{\"682\":5,\"686\":2}}],[\"admin\",{\"1\":{\"501\":2,\"658\":4,\"659\":4,\"692\":2,\"1047\":2}}],[\"addtoconfig\",{\"1\":{\"1327\":1}}],[\"addthen\",{\"1\":{\"511\":1}}],[\"addpropertyvalue\",{\"1\":{\"1326\":1}}],[\"addpathpatterns\",{\"1\":{\"596\":1,\"600\":2,\"601\":2}}],[\"addclasspath>\",{\"1\":{\"1037\":1}}],[\"addcookie\",{\"1\":{\"585\":1,\"1091\":1,\"1093\":2}}],[\"addhandler\",{\"1\":{\"919\":1,\"920\":1,\"929\":1}}],[\"addmappers\",{\"1\":{\"904\":1}}],[\"adduser\",{\"1\":{\"861\":2,\"862\":1}}],[\"addbatch\",{\"1\":{\"798\":2}}],[\"added\",{\"1\":{\"789\":1,\"1260\":1}}],[\"addifabsent\",{\"1\":{\"789\":1}}],[\"additionalfilters\",{\"1\":{\"710\":1}}],[\"addinterceptor\",{\"1\":{\"596\":1,\"600\":2,\"601\":2}}],[\"addinterceptors\",{\"1\":{\"596\":1,\"600\":1,\"601\":1}}],[\"addlistener\",{\"1\":{\"705\":2}}],[\"addlast\",{\"1\":{\"201\":1}}],[\"address\",{\"1\":{\"682\":1,\"1208\":1}}],[\"addresourcelocations\",{\"1\":{\"564\":1,\"678\":1}}],[\"addresourcehandler\",{\"1\":{\"564\":1,\"678\":1}}],[\"addresourcehandlers\",{\"1\":{\"564\":1,\"678\":1}}],[\"addattribute\",{\"1\":{\"563\":1,\"575\":2,\"605\":1,\"636\":1}}],[\"addall\",{\"1\":{\"180\":1,\"181\":1,\"204\":1,\"205\":1,\"206\":1}}],[\"addfirst\",{\"1\":{\"201\":1}}],[\"add\",{\"1\":{\"171\":2,\"180\":2,\"181\":1,\"182\":13,\"194\":1,\"200\":1,\"204\":1,\"205\":3,\"207\":6,\"228\":16,\"236\":2,\"237\":2,\"241\":1,\"312\":9,\"331\":3,\"350\":1,\"515\":4,\"518\":4,\"519\":4,\"522\":4,\"528\":2,\"613\":1,\"616\":1,\"699\":2,\"751\":1,\"1047\":2,\"1246\":1,\"1247\":1}}],[\"a∈a∑​π\",{\"1\":{\"155\":1}}],[\"a∈a∑​▽θ​π\",{\"1\":{\"155\":2}}],[\"ak​=k1​是满足上面三个条件的\",{\"1\":{\"98\":1}}],[\"ak​→0不要过快\",{\"1\":{\"98\":1}}],[\"ak​→0\",{\"1\":{\"98\":1}}],[\"ak​\",{\"1\":{\"97\":1}}],[\"ak∗​∣s\",{\"1\":{\"79\":1}}],[\"ak∗​\",{\"1\":{\"66\":1}}],[\"a3​\",{\"1\":{\"81\":2}}],[\"a4​\",{\"1\":{\"81\":2}}],[\"a2\",{\"1\":{\"767\":1}}],[\"a2​\",{\"1\":{\"81\":4}}],[\"a2c\",{\"0\":{\"25\":1}}],[\"a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"aspectjautoproxyregistrar\",{\"1\":{\"1310\":3}}],[\"aspect注解和\",{\"1\":{\"1233\":1}}],[\"aspect>\",{\"1\":{\"1220\":2,\"1224\":1,\"1225\":1,\"1231\":1}}],[\"aspect标签\",{\"1\":{\"1220\":1}}],[\"aspects<\",{\"1\":{\"1217\":1}}],[\"aspect\",{\"1\":{\"1215\":1,\"1220\":2,\"1224\":1,\"1225\":1,\"1226\":1,\"1233\":1}}],[\"asynctest\",{\"1\":{\"1188\":2}}],[\"async\",{\"1\":{\"1188\":1,\"1225\":2}}],[\"async注解即可将此方法标记为异步\",{\"1\":{\"1188\":1}}],[\"asyncmanager\",{\"1\":{\"626\":5}}],[\"aservice\",{\"1\":{\"1119\":4}}],[\"asc|desc\",{\"1\":{\"764\":3}}],[\"asdf\",{\"1\":{\"343\":1}}],[\"asdasda\",{\"1\":{\"228\":1}}],[\"aslist\",{\"1\":{\"182\":2,\"187\":2,\"191\":2,\"192\":1,\"205\":1,\"206\":1,\"222\":1,\"228\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":4,\"330\":1,\"343\":1,\"521\":1}}],[\"as\",{\"1\":{\"58\":1,\"104\":1,\"324\":2,\"779\":2,\"855\":2,\"1246\":2}}],[\"assign\",{\"1\":{\"1047\":1}}],[\"assisted\",{\"1\":{\"4\":1}}],[\"assembleconnectiontypecode\",{\"1\":{\"1246\":1}}],[\"assembles\",{\"1\":{\"1148\":1}}],[\"assembly<\",{\"1\":{\"1037\":1}}],[\"assembly\",{\"1\":{\"1037\":1}}],[\"assertarrayequals\",{\"1\":{\"1017\":1}}],[\"assertall\",{\"1\":{\"972\":1}}],[\"assert在junit5时名称发生了变化assertions\",{\"1\":{\"1017\":1}}],[\"assertsame\",{\"1\":{\"971\":1}}],[\"assertthrows\",{\"1\":{\"973\":1}}],[\"asserttrue\",{\"1\":{\"970\":1,\"972\":4}}],[\"assertture\",{\"1\":{\"970\":1}}],[\"assertequals\",{\"1\":{\"963\":1,\"969\":3}}],[\"assertions\",{\"1\":{\"963\":1,\"969\":3,\"970\":2,\"971\":1,\"972\":5,\"973\":1,\"987\":1,\"1017\":1}}],[\"assertionerror\",{\"1\":{\"425\":1}}],[\"assert\",{\"1\":{\"425\":2,\"706\":1,\"1318\":2,\"1319\":1}}],[\"assert断言表达式\",{\"1\":{\"425\":1}}],[\"assumetrue\",{\"1\":{\"974\":1}}],[\"assumptions\",{\"1\":{\"974\":1}}],[\"assubclass\",{\"1\":{\"343\":2}}],[\"association\",{\"1\":{\"853\":1}}],[\"association>\",{\"1\":{\"850\":1,\"855\":1}}],[\"associate\",{\"1\":{\"20\":1}}],[\"assdw\",{\"1\":{\"228\":1}}],[\"already\",{\"1\":{\"789\":1,\"1296\":1}}],[\"alwaysremember\",{\"1\":{\"686\":1}}],[\"aliyun\",{\"1\":{\"1010\":1}}],[\"alias=\",{\"1\":{\"832\":1,\"1128\":1}}],[\"aliasfor\",{\"1\":{\"569\":2,\"1167\":2,\"1279\":2}}],[\"alive\",{\"1\":{\"727\":1,\"1091\":3,\"1096\":3}}],[\"alibaba\",{\"1\":{\"611\":1,\"616\":1}}],[\"alice\",{\"1\":{\"528\":1}}],[\"alert\",{\"1\":{\"564\":1,\"617\":4,\"636\":2,\"643\":1,\"666\":1}}],[\"although\",{\"1\":{\"1148\":1}}],[\"alter\",{\"1\":{\"751\":2}}],[\"alt\",{\"1\":{\"446\":1,\"460\":2,\"461\":1,\"462\":1,\"465\":2,\"473\":6,\"475\":1,\"485\":3,\"494\":1,\"498\":2,\"500\":2,\"501\":2,\"504\":2,\"515\":1,\"534\":2,\"535\":1,\"536\":1,\"540\":1,\"541\":1,\"550\":1,\"553\":1,\"554\":1,\"558\":3,\"593\":1,\"614\":1,\"617\":1,\"619\":1,\"620\":1,\"625\":1,\"626\":1,\"630\":1,\"631\":3,\"636\":1,\"642\":2,\"643\":1,\"652\":1,\"658\":1,\"659\":2,\"664\":2,\"683\":1,\"686\":2,\"708\":1,\"841\":1,\"842\":1,\"849\":1,\"850\":2,\"853\":1,\"855\":1,\"871\":2,\"876\":1,\"877\":1,\"882\":1,\"883\":2,\"884\":1,\"888\":1,\"897\":1,\"920\":1,\"930\":1,\"948\":1,\"956\":1,\"958\":1,\"959\":2,\"960\":1,\"961\":1,\"963\":1,\"969\":1,\"973\":1,\"974\":1,\"976\":1,\"986\":2,\"988\":1,\"1001\":1,\"1009\":1,\"1036\":1,\"1091\":1,\"1095\":1,\"1101\":1,\"1103\":2,\"1105\":1,\"1109\":1,\"1116\":2,\"1117\":1,\"1118\":2,\"1119\":3,\"1125\":1,\"1126\":1,\"1133\":2,\"1140\":1,\"1151\":1,\"1152\":1,\"1158\":1,\"1159\":1,\"1172\":1,\"1181\":2,\"1188\":2,\"1189\":1,\"1191\":1,\"1192\":1,\"1215\":1,\"1220\":1,\"1221\":1,\"1222\":1,\"1224\":1,\"1225\":1,\"1231\":1,\"1242\":1,\"1256\":1,\"1260\":1,\"1268\":1,\"1269\":1,\"1270\":1,\"1271\":1,\"1280\":1,\"1295\":2,\"1301\":3,\"1318\":1}}],[\"along\",{\"1\":{\"154\":1}}],[\"alogorithm\",{\"0\":{\"132\":1}}],[\"algorithms\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"algorithm\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"71\":1,\"72\":1,\"95\":1},\"1\":{\"58\":1,\"68\":2,\"70\":2,\"71\":1,\"76\":1,\"79\":1,\"98\":1}}],[\"allowearlyreference\",{\"1\":{\"1301\":2}}],[\"allows\",{\"1\":{\"1047\":4}}],[\"allargsconstructor和\",{\"1\":{\"812\":1}}],[\"allargsconstructor\",{\"1\":{\"810\":1,\"1008\":1}}],[\"all|权限1\",{\"1\":{\"774\":2}}],[\"allmatch\",{\"1\":{\"520\":1}}],[\"all\",{\"1\":{\"41\":1,\"53\":1,\"912\":2,\"928\":2,\"1148\":1,\"1181\":1}}],[\"a∑​π\",{\"1\":{\"45\":1,\"155\":1}}],[\"a∑​p\",{\"1\":{\"44\":1}}],[\"a∼π​\",{\"1\":{\"26\":3,\"155\":1}}],[\"a∣s\",{\"1\":{\"20\":1,\"26\":3,\"41\":1,\"43\":2,\"44\":5,\"45\":4,\"48\":3,\"49\":1,\"55\":2,\"57\":2,\"58\":1,\"63\":2,\"66\":3,\"79\":1,\"87\":1,\"113\":1,\"148\":1,\"153\":1,\"155\":14,\"156\":2}}],[\"annoattrs\",{\"1\":{\"1326\":1}}],[\"annometa\",{\"1\":{\"1326\":1}}],[\"annotatedbeandefinitionreader\",{\"1\":{\"1318\":2}}],[\"annotated\",{\"1\":{\"1181\":1,\"1318\":1}}],[\"annotationclass\",{\"1\":{\"1327\":1}}],[\"annotationconfigutils\",{\"1\":{\"1310\":1,\"1318\":1}}],[\"annotationconfigapplicationcontext的基本内容就初始化好了\",{\"1\":{\"1318\":1}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"1166\":2,\"1169\":1,\"1176\":2,\"1188\":2,\"1192\":1,\"1233\":1,\"1256\":1,\"1257\":1,\"1260\":1,\"1278\":1,\"1288\":1,\"1297\":1,\"1317\":1,\"1318\":1,\"1328\":1}}],[\"annotationconfigwebapplicationcontext\",{\"1\":{\"705\":2}}],[\"annotationattributes\",{\"1\":{\"1310\":1,\"1326\":1}}],[\"annotationawareordercomparator\",{\"1\":{\"631\":1}}],[\"annotationmetadata\",{\"1\":{\"1310\":1,\"1311\":1,\"1326\":1}}],[\"annotation可以用于表示标记了哪些注解的方法被切入\",{\"1\":{\"1219\":1}}],[\"annotations\",{\"1\":{\"1181\":3}}],[\"annotation提供的\",{\"1\":{\"1176\":1}}],[\"annotation<\",{\"1\":{\"1175\":1}}],[\"annotation这个包被移除并且更名为jakarta\",{\"1\":{\"1175\":1}}],[\"annotationprocessor\",{\"1\":{\"811\":1}}],[\"annotationtype\",{\"1\":{\"365\":2}}],[\"annotation\",{\"1\":{\"365\":14,\"1167\":1,\"1175\":2,\"1181\":1,\"1219\":1}}],[\"answer\",{\"1\":{\"1181\":2}}],[\"another\",{\"1\":{\"1246\":1}}],[\"anotherinteger\",{\"1\":{\"451\":2}}],[\"anonymousauthenticationfilter\",{\"1\":{\"714\":1}}],[\"aninterface\",{\"1\":{\"343\":2}}],[\"anyrequest\",{\"1\":{\"680\":1,\"681\":1,\"692\":1,\"693\":1}}],[\"anymatch\",{\"1\":{\"520\":1}}],[\"any\",{\"1\":{\"53\":1,\"58\":1,\"86\":1,\"296\":1,\"1047\":1}}],[\"an\",{\"1\":{\"19\":1,\"47\":1,\"48\":1,\"296\":1,\"509\":2,\"711\":1,\"1181\":1}}],[\"andthen\",{\"1\":{\"509\":1,\"511\":2}}],[\"and\",{\"0\":{\"3\":1},\"1\":{\"4\":2,\"14\":1,\"48\":1,\"49\":1,\"52\":1,\"53\":1,\"75\":1,\"142\":1,\"324\":2,\"763\":1,\"788\":1,\"804\":2,\"805\":2,\"834\":1,\"835\":1,\"843\":2,\"873\":1,\"874\":3,\"902\":2,\"1047\":4,\"1071\":1,\"1148\":3,\"1181\":7}}],[\"atomicity\",{\"1\":{\"1266\":1}}],[\"attempted\",{\"1\":{\"1247\":1}}],[\"attempt\",{\"1\":{\"1181\":1}}],[\"attempting\",{\"1\":{\"789\":1}}],[\"attemptauthentication\",{\"1\":{\"711\":1}}],[\"attack\",{\"1\":{\"642\":1}}],[\"attrname\",{\"1\":{\"625\":2}}],[\"attributesfor\",{\"1\":{\"1310\":1}}],[\"attribute\",{\"1\":{\"603\":1,\"1327\":1}}],[\"at+1​\",{\"1\":{\"116\":2,\"139\":1,\"140\":1}}],[\"at\",{\"1\":{\"19\":1,\"20\":1,\"843\":1,\"1181\":1,\"1278\":7,\"1283\":8,\"1319\":1}}],[\"at​∣st​\",{\"1\":{\"156\":1}}],[\"at​=a\",{\"1\":{\"43\":1,\"44\":2,\"48\":2,\"49\":1,\"75\":1,\"77\":1,\"78\":1,\"119\":1}}],[\"at​\",{\"1\":{\"13\":1,\"116\":8,\"120\":5,\"139\":2,\"140\":2,\"156\":1}}],[\"ai​\",{\"1\":{\"19\":1,\"142\":2}}],[\"accumulatedrequesttime\",{\"1\":{\"1246\":1}}],[\"accumulatedwaittime\",{\"1\":{\"1246\":1}}],[\"accumulatedcheckouttime\",{\"1\":{\"1246\":1,\"1247\":2}}],[\"accumulatedcheckouttimeofoverdueconnections\",{\"1\":{\"1246\":1}}],[\"accumulator\",{\"1\":{\"521\":2}}],[\"accommodate\",{\"1\":{\"1181\":1}}],[\"account1\",{\"1\":{\"501\":2}}],[\"account0\",{\"1\":{\"501\":2}}],[\"account\",{\"1\":{\"501\":7,\"636\":6,\"641\":1,\"658\":1,\"660\":4,\"669\":1,\"670\":1,\"672\":4,\"692\":6}}],[\"accpeted\",{\"1\":{\"727\":1}}],[\"acc\",{\"1\":{\"296\":2}}],[\"accessing\",{\"1\":{\"1296\":1}}],[\"accessed\",{\"1\":{\"1047\":1}}],[\"access\",{\"1\":{\"1047\":5}}],[\"accessors来控制生成getter和setter的样式\",{\"1\":{\"812\":1}}],[\"accesscontrolcontext\",{\"1\":{\"296\":2}}],[\"accepted\",{\"1\":{\"727\":1}}],[\"accept\",{\"1\":{\"189\":1,\"192\":1,\"193\":1,\"509\":3,\"510\":2,\"511\":1,\"577\":1,\"719\":2,\"720\":2,\"726\":1,\"727\":5,\"1091\":3,\"1096\":3}}],[\"actual\",{\"1\":{\"969\":1}}],[\"activeconnections\",{\"1\":{\"1246\":5,\"1247\":1}}],[\"active\",{\"1\":{\"747\":2}}],[\"action=\",{\"1\":{\"619\":1,\"636\":1,\"641\":1,\"660\":1,\"682\":1,\"683\":1,\"1069\":1,\"1075\":1}}],[\"actions\",{\"1\":{\"20\":1}}],[\"action\",{\"0\":{\"48\":1,\"115\":1,\"119\":1},\"1\":{\"13\":1,\"19\":3,\"20\":2,\"48\":8,\"49\":2,\"53\":2,\"57\":2,\"63\":1,\"66\":1,\"70\":2,\"75\":1,\"77\":5,\"79\":6,\"81\":9,\"82\":3,\"84\":4,\"86\":2,\"92\":1,\"115\":4,\"116\":1,\"119\":2,\"120\":1,\"131\":1,\"189\":3,\"192\":3,\"193\":3,\"296\":1}}],[\"actor\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"academic\",{\"0\":{\"1334\":1},\"2\":{\"15\":1,\"21\":1,\"34\":1,\"50\":1,\"59\":1,\"73\":1,\"90\":1,\"107\":1,\"128\":1,\"145\":1,\"158\":1}}],[\"a\",{\"1\":{\"4\":1,\"13\":3,\"14\":2,\"19\":7,\"20\":5,\"26\":2,\"41\":3,\"43\":1,\"44\":3,\"45\":6,\"48\":13,\"49\":2,\"52\":1,\"53\":1,\"55\":3,\"57\":1,\"58\":2,\"63\":6,\"66\":6,\"70\":1,\"75\":3,\"77\":11,\"78\":8,\"79\":3,\"81\":2,\"82\":2,\"84\":6,\"86\":1,\"92\":1,\"113\":1,\"115\":4,\"116\":3,\"119\":3,\"120\":4,\"135\":1,\"141\":3,\"142\":22,\"153\":5,\"155\":9,\"156\":4,\"161\":1,\"165\":4,\"173\":4,\"180\":1,\"181\":3,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"203\":2,\"204\":1,\"205\":1,\"206\":1,\"207\":2,\"221\":2,\"228\":6,\"241\":4,\"264\":1,\"296\":3,\"376\":1,\"384\":7,\"386\":1,\"396\":3,\"398\":1,\"403\":6,\"408\":2,\"413\":3,\"414\":5,\"415\":5,\"423\":4,\"424\":2,\"425\":2,\"438\":3,\"439\":7,\"452\":2,\"464\":3,\"465\":2,\"466\":2,\"467\":2,\"476\":1,\"485\":4,\"488\":1,\"500\":2,\"503\":2,\"504\":6,\"509\":2,\"512\":5,\"521\":4,\"522\":1,\"528\":1,\"727\":1,\"789\":1,\"806\":4,\"969\":2,\"1047\":3,\"1096\":1,\"1116\":1,\"1117\":5,\"1127\":2,\"1128\":2,\"1148\":4,\"1174\":2,\"1181\":2,\"1246\":5,\"1247\":1,\"1298\":4,\"1300\":2}}],[\"a+b=c\",{\"1\":{\"0\":1}}],[\"ds\",{\"1\":{\"1273\":2}}],[\"durability\",{\"1\":{\"1266\":1}}],[\"during\",{\"1\":{\"1181\":1}}],[\"due\",{\"1\":{\"1181\":1}}],[\"dmaven\",{\"1\":{\"1036\":1}}],[\"dml\",{\"0\":{\"753\":1,\"860\":1},\"1\":{\"744\":1}}],[\"dd\",{\"1\":{\"948\":1}}],[\"ddl\",{\"0\":{\"745\":1}}],[\"dtd\",{\"1\":{\"824\":3,\"826\":3,\"1017\":3,\"1071\":3,\"1242\":3,\"1255\":3}}],[\"df\",{\"1\":{\"748\":1}}],[\"db\",{\"1\":{\"744\":1}}],[\"dbcreator\",{\"1\":{\"744\":1}}],[\"dcl\",{\"0\":{\"771\":1},\"1\":{\"744\":1}}],[\"dql\",{\"0\":{\"761\":1},\"1\":{\"744\":1}}],[\"dqn\",{\"0\":{\"141\":1},\"1\":{\"142\":1,\"144\":1}}],[\"druid等\",{\"1\":{\"1260\":1}}],[\"drop\",{\"1\":{\"749\":1,\"751\":1,\"752\":1,\"779\":1,\"780\":1,\"781\":1}}],[\"dropwhile\",{\"1\":{\"479\":1}}],[\"driver>\",{\"1\":{\"1244\":1}}],[\"driverproperties\",{\"1\":{\"1244\":3}}],[\"driverclassloader\",{\"1\":{\"1244\":1}}],[\"driver=com\",{\"1\":{\"936\":1}}],[\"driverinfo\",{\"1\":{\"789\":2}}],[\"driveraction\",{\"1\":{\"789\":1}}],[\"drivermanager是管理我们的数据库驱动的\",{\"1\":{\"789\":1}}],[\"drivermanager\",{\"0\":{\"789\":1},\"1\":{\"788\":1,\"789\":4,\"796\":1,\"798\":1,\"804\":1,\"805\":1,\"806\":4,\"1244\":1}}],[\"driver\",{\"1\":{\"664\":1,\"788\":6,\"789\":14,\"824\":2,\"904\":1,\"936\":1,\"1017\":2,\"1071\":2,\"1242\":1,\"1244\":1,\"1255\":2,\"1259\":1,\"1260\":1,\"1276\":1}}],[\"driven\",{\"1\":{\"4\":1}}],[\"doscan\",{\"1\":{\"1327\":2}}],[\"doservice\",{\"1\":{\"626\":2}}],[\"dotrace\",{\"1\":{\"1059\":1}}],[\"dooptions\",{\"1\":{\"1059\":1}}],[\"dodelete\",{\"1\":{\"1059\":1}}],[\"dodispatch\",{\"1\":{\"626\":2}}],[\"dopatch\",{\"1\":{\"1059\":1}}],[\"doput\",{\"1\":{\"1059\":1}}],[\"dopost\",{\"1\":{\"626\":1,\"1059\":1,\"1069\":1,\"1072\":2,\"1075\":1,\"1083\":1}}],[\"dopost等方法进行处理\",{\"1\":{\"626\":1}}],[\"dohead\",{\"1\":{\"1059\":1}}],[\"dormant\",{\"1\":{\"873\":1}}],[\"dog\",{\"1\":{\"796\":1}}],[\"dogetbean\",{\"1\":{\"1300\":3}}],[\"dogetconnection\",{\"1\":{\"1244\":5}}],[\"doget\",{\"1\":{\"626\":1,\"1059\":5,\"1064\":1,\"1074\":1,\"1076\":1,\"1083\":1,\"1093\":1}}],[\"dofilterinternal\",{\"1\":{\"708\":2}}],[\"dofilter\",{\"1\":{\"704\":1,\"707\":4,\"708\":10,\"709\":1,\"710\":3,\"711\":5,\"1102\":1,\"1103\":8,\"1104\":6}}],[\"dologout\",{\"1\":{\"683\":2}}],[\"dologin\",{\"1\":{\"680\":2,\"682\":1}}],[\"domain属性\",{\"1\":{\"1092\":1}}],[\"domain\",{\"1\":{\"1092\":1}}],[\"domain=localhost\",{\"1\":{\"642\":1}}],[\"dom\",{\"1\":{\"643\":1}}],[\"docs\",{\"1\":{\"995\":1,\"1047\":1,\"1113\":2,\"1211\":2,\"1219\":2}}],[\"documentbuilder\",{\"1\":{\"819\":1}}],[\"documentbuilderfactory\",{\"1\":{\"819\":2}}],[\"document\",{\"1\":{\"617\":2,\"636\":1,\"642\":1,\"660\":2,\"666\":3,\"727\":1,\"819\":1,\"1076\":1,\"1091\":1,\"1096\":1}}],[\"documented\",{\"1\":{\"362\":1,\"1167\":1,\"1279\":1,\"1310\":1,\"1326\":1}}],[\"doctype\",{\"1\":{\"562\":1,\"563\":1,\"564\":1,\"605\":1,\"617\":2,\"636\":3,\"641\":1,\"642\":1,\"824\":1,\"826\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"doxy\",{\"1\":{\"403\":1}}],[\"does\",{\"1\":{\"403\":1,\"789\":1,\"1148\":1}}],[\"do\",{\"1\":{\"403\":3}}],[\"double用于存储双精度的小数\",{\"1\":{\"746\":1}}],[\"double\",{\"1\":{\"165\":3,\"384\":2,\"991\":1}}],[\"download=\",{\"1\":{\"620\":1,\"1074\":1}}],[\"download\",{\"1\":{\"619\":1,\"620\":3,\"811\":1,\"1047\":1}}],[\"down\",{\"1\":{\"8\":1}}],[\"d0​\",{\"1\":{\"152\":1}}],[\"dπ​\",{\"1\":{\"135\":2,\"152\":1}}],[\"di\",{\"1\":{\"1132\":1}}],[\"div>\",{\"1\":{\"563\":1,\"605\":1,\"619\":1,\"636\":2,\"643\":2,\"666\":1,\"682\":1,\"686\":1,\"1069\":3,\"1075\":2,\"1076\":1,\"1093\":1}}],[\"divide\",{\"1\":{\"386\":1}}],[\"difference\",{\"0\":{\"109\":1}}],[\"discarding\",{\"1\":{\"1247\":1}}],[\"discounted\",{\"1\":{\"19\":1,\"42\":1,\"113\":1,\"137\":1}}],[\"displaynamegeneration注解来配置使用\",{\"1\":{\"962\":1}}],[\"displayname\",{\"1\":{\"961\":1,\"987\":1,\"1017\":1}}],[\"displayname注解来为其命名\",{\"1\":{\"961\":1}}],[\"dispatch\",{\"1\":{\"626\":1}}],[\"dispatchexception\",{\"1\":{\"626\":4}}],[\"dispatcherservlet初始化过程我们已经了解了\",{\"1\":{\"625\":1}}],[\"dispatcherservlet<\",{\"1\":{\"545\":1,\"548\":1}}],[\"dispatcherservlet\",{\"1\":{\"545\":1,\"558\":1,\"560\":1}}],[\"disabledif用于\",{\"1\":{\"980\":1}}],[\"disabledif在类上使用时\",{\"1\":{\"980\":1}}],[\"disabledonjre\",{\"1\":{\"977\":1}}],[\"disabledonos\",{\"1\":{\"976\":1}}],[\"disabled\",{\"1\":{\"960\":1}}],[\"disable来关闭某一个测试用例\",{\"1\":{\"960\":1}}],[\"disableencodeurlfilter\",{\"1\":{\"714\":1}}],[\"disable\",{\"1\":{\"684\":1}}],[\"dist\",{\"1\":{\"617\":2,\"636\":1,\"641\":1,\"642\":1}}],[\"distinct表示去重再统计\",{\"1\":{\"765\":1}}],[\"distinct\",{\"1\":{\"204\":1,\"228\":3,\"269\":1,\"476\":1,\"515\":1,\"762\":1,\"765\":7}}],[\"distributon\",{\"0\":{\"134\":1},\"1\":{\"135\":3}}],[\"distributed\",{\"1\":{\"75\":1}}],[\"distribution\",{\"0\":{\"135\":1},\"1\":{\"20\":1,\"133\":1,\"135\":1,\"152\":1}}],[\"da\",{\"1\":{\"789\":2}}],[\"dao\",{\"1\":{\"1071\":1}}],[\"daoauthenticationprovider\",{\"1\":{\"666\":2}}],[\"dao等\",{\"1\":{\"625\":1}}],[\"dateformat\",{\"1\":{\"948\":2,\"1076\":2}}],[\"datetime用于混合存储日期+时间\",{\"1\":{\"746\":1}}],[\"date存储日期\",{\"1\":{\"746\":1}}],[\"date\",{\"1\":{\"331\":2,\"849\":1,\"948\":4,\"1076\":3,\"1091\":1,\"1096\":1,\"1190\":1}}],[\"data注解\",{\"1\":{\"883\":1}}],[\"data类似\",{\"1\":{\"812\":1}}],[\"data就不建议此类有继承关系\",{\"1\":{\"812\":1}}],[\"data能代表\",{\"1\":{\"812\":1}}],[\"databases\",{\"1\":{\"773\":1}}],[\"database来删除一个数据库\",{\"1\":{\"749\":1}}],[\"database来创建一个数据库\",{\"1\":{\"749\":1}}],[\"database\",{\"1\":{\"749\":3,\"841\":1,\"1246\":2}}],[\"datasourcetransactionmanager\",{\"1\":{\"1276\":1}}],[\"datasource>\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"datasource\",{\"1\":{\"664\":5,\"666\":3,\"671\":3,\"687\":3,\"904\":2,\"936\":4,\"1242\":1,\"1244\":1,\"1245\":4,\"1246\":2,\"1247\":2,\"1259\":5,\"1260\":8,\"1273\":4,\"1276\":14}}],[\"data=\",{\"1\":{\"523\":1}}],[\"dataoutputstream\",{\"1\":{\"286\":4}}],[\"datainputstream\",{\"1\":{\"286\":4}}],[\"data\",{\"1\":{\"81\":1,\"324\":1,\"490\":4,\"501\":1,\"523\":9,\"524\":3,\"583\":1,\"603\":1,\"615\":1,\"616\":2,\"617\":7,\"619\":1,\"620\":1,\"636\":2,\"666\":2,\"669\":1,\"692\":1,\"726\":1,\"744\":4,\"787\":1,\"826\":2,\"835\":1,\"849\":2,\"853\":2,\"855\":2,\"1008\":1,\"1071\":1,\"1075\":2,\"1255\":1}}],[\"daily\",{\"0\":{\"1332\":1},\"2\":{\"1\":1}}],[\"daily1\",{\"0\":{\"0\":1}}],[\"dpg\",{\"0\":{\"33\":1}}],[\"d\",{\"0\":{\"152\":1},\"1\":{\"10\":3,\"75\":1,\"150\":2,\"152\":5,\"228\":1,\"373\":1,\"375\":1,\"488\":1,\"710\":2,\"806\":1,\"819\":2,\"1117\":1}}],[\"dkn​​\",{\"1\":{\"9\":1}}],[\"dkn​​=hn2​\",{\"1\":{\"8\":1}}],[\"dkn​\",{\"1\":{\"9\":1}}],[\"dynamic\",{\"1\":{\"4\":1,\"45\":1,\"619\":1}}],[\"developers\",{\"1\":{\"1181\":1}}],[\"developer\",{\"1\":{\"1181\":1}}],[\"development\",{\"1\":{\"824\":2,\"904\":1,\"1017\":2,\"1071\":2,\"1242\":2,\"1255\":2}}],[\"details\",{\"1\":{\"1190\":1,\"1260\":1}}],[\"detail表的查询操作\",{\"1\":{\"852\":1}}],[\"detail表的对应信息\",{\"1\":{\"851\":1}}],[\"detail=userdetail\",{\"1\":{\"852\":1}}],[\"detail\",{\"1\":{\"849\":1,\"850\":3,\"851\":2,\"852\":1,\"901\":2}}],[\"detectallhandlermappings\",{\"1\":{\"631\":1}}],[\"deterministic\",{\"0\":{\"33\":1,\"105\":1},\"1\":{\"14\":1,\"19\":1,\"53\":2}}],[\"deny\",{\"1\":{\"744\":1}}],[\"debug\",{\"1\":{\"708\":3,\"710\":1,\"712\":1,\"1246\":8,\"1247\":3,\"1260\":1,\"1273\":1}}],[\"delegatetouse\",{\"1\":{\"707\":3}}],[\"delegate\",{\"1\":{\"706\":6,\"707\":3}}],[\"delegatemonitor\",{\"1\":{\"706\":1}}],[\"delegatingmethodaccessorimpl\",{\"1\":{\"1278\":2}}],[\"delegatingfilterproxy是如何执行dofilter方法的\",{\"1\":{\"707\":1}}],[\"delegatingfilterproxy的一个成员变量delegate被赋值为得到的filter\",{\"1\":{\"706\":1}}],[\"delegatingfilterproxy在做什么\",{\"1\":{\"706\":1}}],[\"delegatingfilterproxy\",{\"1\":{\"705\":3,\"707\":1}}],[\"delegatingwebmvcconfiguration\",{\"1\":{\"553\":1}}],[\"delete>\",{\"1\":{\"864\":1,\"876\":1}}],[\"delete等操作时\",{\"1\":{\"781\":1}}],[\"delete时\",{\"1\":{\"781\":1}}],[\"delete三种指令为核心\",{\"1\":{\"744\":1}}],[\"deleteusers\",{\"1\":{\"876\":2}}],[\"deleteuserbyid\",{\"1\":{\"864\":1,\"865\":3,\"871\":1,\"876\":1}}],[\"deleteuser\",{\"1\":{\"665\":1}}],[\"delete\",{\"1\":{\"402\":1,\"589\":4,\"691\":1,\"744\":1,\"756\":2,\"781\":1,\"796\":1,\"860\":2,\"864\":1,\"876\":3,\"884\":1,\"1059\":1}}],[\"decentralized\",{\"1\":{\"1181\":1}}],[\"declaration\",{\"1\":{\"1181\":1}}],[\"decide\",{\"1\":{\"1181\":1}}],[\"decimal\",{\"1\":{\"748\":1}}],[\"decision\",{\"0\":{\"20\":1}}],[\"decorate\",{\"1\":{\"708\":2,\"709\":2}}],[\"decode\",{\"1\":{\"385\":1}}],[\"dependson\",{\"1\":{\"1171\":1}}],[\"depends\",{\"1\":{\"1131\":1,\"1181\":1}}],[\"dependencies<\",{\"1\":{\"1037\":1}}],[\"dependencies>\",{\"1\":{\"1008\":1,\"1024\":1,\"1033\":3}}],[\"dependency\",{\"1\":{\"1132\":1,\"1181\":2}}],[\"dependencymanagement>\",{\"1\":{\"1033\":1}}],[\"dependency>\",{\"1\":{\"544\":1,\"551\":1,\"559\":1,\"611\":1,\"616\":1,\"649\":2,\"663\":4,\"1008\":1,\"1017\":3,\"1018\":1,\"1023\":1,\"1024\":1,\"1025\":3,\"1026\":1,\"1033\":6,\"1071\":2,\"1074\":1,\"1118\":1,\"1175\":1,\"1217\":1,\"1253\":4,\"1260\":3,\"1290\":2}}],[\"departmentname\",{\"1\":{\"748\":3}}],[\"departmentid\",{\"1\":{\"748\":2}}],[\"departments\",{\"1\":{\"747\":2,\"748\":2}}],[\"department\",{\"1\":{\"747\":2}}],[\"deprecated\",{\"1\":{\"361\":1,\"788\":1}}],[\"deployment\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"defined\",{\"1\":{\"1181\":3}}],[\"defineclass\",{\"1\":{\"356\":3}}],[\"definition\",{\"1\":{\"744\":1,\"1296\":2,\"1311\":4}}],[\"deflate\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"defaulting\",{\"1\":{\"1260\":1}}],[\"defaultnetworktimeout\",{\"1\":{\"1244\":1}}],[\"defaulttransactionisolationlevel\",{\"1\":{\"1244\":1}}],[\"defaultlistablebeanfactory\",{\"1\":{\"1296\":7,\"1297\":1,\"1298\":4,\"1318\":1}}],[\"defaultlocale\",{\"1\":{\"1211\":1}}],[\"defaultlevel\",{\"1\":{\"939\":2}}],[\"defaultformatter\",{\"1\":{\"939\":2}}],[\"defaultbundle\",{\"1\":{\"910\":7,\"912\":2}}],[\"default=\",{\"1\":{\"824\":1,\"1017\":1,\"1071\":1,\"1242\":1,\"1255\":1}}],[\"default来指定默认值\",{\"1\":{\"812\":1}}],[\"defaultscope\",{\"1\":{\"1327\":2}}],[\"defaultsqlsession\",{\"1\":{\"1242\":2}}],[\"defaultsuccessurl\",{\"1\":{\"680\":1}}],[\"defaultservlethandlerconfigurer\",{\"1\":{\"564\":1,\"678\":1}}],[\"defaultvalue\",{\"1\":{\"581\":1}}],[\"default\",{\"1\":{\"180\":4,\"181\":2,\"182\":1,\"189\":2,\"192\":1,\"193\":2,\"204\":1,\"215\":1,\"217\":4,\"330\":1,\"364\":1,\"376\":2,\"474\":2,\"495\":1,\"496\":1,\"497\":3,\"509\":1,\"569\":8,\"747\":2,\"748\":1,\"749\":1,\"1054\":1,\"1167\":5,\"1279\":13,\"1310\":2,\"1326\":2,\"1327\":1}}],[\"deque<string>\",{\"1\":{\"201\":1,\"202\":1}}],[\"deque<e>\",{\"1\":{\"182\":1,\"199\":1,\"201\":1}}],[\"deque\",{\"0\":{\"199\":1,\"201\":1},\"1\":{\"201\":5,\"202\":1}}],[\"deeptostring\",{\"1\":{\"432\":1}}],[\"deep\",{\"0\":{\"141\":1},\"1\":{\"141\":1}}],[\"desiredautocommit\",{\"1\":{\"1273\":2}}],[\"desiredlevel\",{\"1\":{\"1273\":2}}],[\"designators\",{\"1\":{\"1219\":1}}],[\"design\",{\"0\":{\"3\":1}}],[\"destruction\",{\"1\":{\"1148\":1}}],[\"destroybeans\",{\"1\":{\"1320\":1}}],[\"destroymethod\",{\"1\":{\"1167\":1,\"1170\":1}}],[\"destroy\",{\"1\":{\"1054\":1,\"1055\":1,\"1147\":2,\"1176\":1}}],[\"dest\",{\"1\":{\"727\":1,\"1091\":1,\"1096\":1}}],[\"desc=description\",{\"1\":{\"936\":1}}],[\"descriptorrefs>\",{\"1\":{\"1037\":1}}],[\"descriptorref>\",{\"1\":{\"1037\":1}}],[\"description=我是一个阳光开朗大男孩\",{\"1\":{\"852\":1}}],[\"description\",{\"1\":{\"849\":1,\"850\":2,\"852\":1}}],[\"describes\",{\"1\":{\"135\":1}}],[\"desc>\",{\"1\":{\"817\":1}}],[\"descendingiterator\",{\"1\":{\"201\":1}}],[\"descent\",{\"0\":{\"100\":1},\"1\":{\"101\":2}}],[\"demonstrating\",{\"1\":{\"4\":1}}],[\"d1\",{\"2\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
