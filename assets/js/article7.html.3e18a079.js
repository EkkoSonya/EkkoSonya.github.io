"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[1195],{83671:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},29360:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>b,data:()=>f});var e=a(7847);const t=a.p+"assets/img/34.22bf4095.png",p=a.p+"assets/img/35.6a38ce67.png",l=a.p+"assets/img/36.6b37213c.png",i=(0,e.Lk)("h2",{id:"营业状态设置1",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#营业状态设置1"},[(0,e.Lk)("span",null,"营业状态设置1")])],-1),o=(0,e.Lk)("h3",{id:"redis介绍",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#redis介绍"},[(0,e.Lk)("span",null,"Redis介绍")])],-1),c=(0,e.Lk)("p",null,[(0,e.eW)("Redis是一个基于"),(0,e.Lk)("strong",null,"内存"),(0,e.eW)("的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的"),(0,e.Lk)("strong",null,"存储中间件"),(0,e.eW)("。")],-1),u=(0,e.Lk)("strong",null,"官网",-1),r={href:"https://redis.io",target:"_blank",rel:"noopener noreferrer"},d=(0,e.Lk)("strong",null,"中文网",-1),k={href:"https://www.redis.net.cn/",target:"_blank",rel:"noopener noreferrer"},m=(0,e.Fv)('<p><strong>key-value结构存储：</strong></p><p><strong>主要特点：</strong></p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）</li><li>企业应用广泛</li></ul><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><p><strong>关系型数据库(RDBMS)：</strong></p><ul><li>Mysql</li><li>Oracle</li><li>DB2</li><li>SQLServer</li></ul><p><strong>非关系型数据库(NoSql)：</strong></p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h4 id="基本命令" tabindex="-1"><a class="header-anchor" href="#基本命令"><span>基本命令</span></a></h4><p>启动：<code>redis-server.exe redis.conf</code></p><p>启动时默认创建了 16 个数据库</p><p>连接: <code>redis-cli.exe</code></p><p>通过redis-cli.exe命令默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：</p><ul><li>-h ip地址</li><li>-p 端口号</li><li>-a 密码（如果需要）</li></ul><h3 id="redis数据类型" tabindex="-1"><a class="header-anchor" href="#redis数据类型"><span>Redis数据类型</span></a></h3><h4 id="_5种常用数据类型" tabindex="-1"><a class="header-anchor" href="#_5种常用数据类型"><span>5种常用数据类型</span></a></h4><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set / zset</li></ul><h4 id="各自特点" tabindex="-1"><a class="header-anchor" href="#各自特点"><span>各自特点</span></a></h4><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构 (适合存对象)</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList (可以左右插入，适合存储跟顺序有关系的数据)</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(sorted set/zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素 (适合各种排行榜数据)</li></ul><h3 id="redis常用命令" tabindex="-1"><a class="header-anchor" href="#redis常用命令"><span>Redis常用命令</span></a></h3><p>在Mysql中是通过Sql语句来操作的，与数据类型无关，但在Redis中是不一样的，是根据数据类型不同，命令也不同</p><h4 id="字符串操作命令" tabindex="-1"><a class="header-anchor" href="#字符串操作命令"><span>字符串操作命令</span></a></h4><p>Redis 中字符串类型常用命令：</p><ul><li><code>SET key value</code>: 设置指定key的值</li><li><code>GET key</code>: 获取指定key的值</li><li><code>SETEX key seconds value</code>: 设置指定key的值，并将 key 的过期时间设为 seconds 秒 (短信验证码)</li><li><code>SETNX key value</code>: 只有在 key 不存在时设置 key 的值 (分布式锁)</li></ul>',27),v={href:"https://www.redis.net.cn",target:"_blank",rel:"noopener noreferrer"},g=(0,e.Fv)('<h4 id="哈希操作命令-h" tabindex="-1"><a class="header-anchor" href="#哈希操作命令-h"><span>哈希操作命令 <code>H</code></span></a></h4><p>Redis hash 是一个<code>string</code>类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><code>HSET key field value</code>: 将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>: 获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>: 删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>: 获取哈希表中所有字段</li><li><code>HVALS key</code>: 获取哈希表中所有值</li></ul><p>比如，存一个人的示例对象，key为对应id, 然后 field 和 value 为对应属性和值</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="列表操作命令-l-r-br" tabindex="-1"><a class="header-anchor" href="#列表操作命令-l-r-br"><span>列表操作命令 <code>L|R|BR</code></span></a></h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><code>LPUSH key value1 [value2]</code>: 将一个或多个值插入到列表头部 (这样插入顺序是 value2 value1 相反的)</li><li><code>RPUSH key value1 [value2]</code>: 在列表中添加一个或多个值到列表尾部</li><li><code>LRANGE key start stop</code>: 获取列表指定范围内的元素 (全部返回 <code>lrange list 0 -1</code>)</li><li><code>RPOP key</code>: 移除并获取列表最后一个元素</li><li><code>LLEN key</code>: 获取列表长度</li><li><code>BRPOP key1 [key2 ] timeout</code>: 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</li></ul><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="集合操作命令-s" tabindex="-1"><a class="header-anchor" href="#集合操作命令-s"><span>集合操作命令 <code>S</code></span></a></h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><code>SADD key member1 [member2]</code>: 向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>: 返回集合中的所有成员</li><li><code>SCARD key</code>: 获取集合的成员数</li><li><code>SINTER key1 [key2]</code>: 返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>: 返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>: 移除集合中一个或多个成员</li></ul><h4 id="有序集合操作命令-z" tabindex="-1"><a class="header-anchor" href="#有序集合操作命令-z"><span>有序集合操作命令 <code>Z</code></span></a></h4><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会<strong>关联一个double类型的分数</strong>。常用命令：</p><p>常用命令：</p><ul><li><code>ZADD key score1 member1 [score2 member2]</code>: 向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>: 通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>: 有序集合中对指定成员的分数加上增量 increment</li><li><code>ZREM key member [member ...]</code>: 移除有序集合中的一个或多个成员</li></ul><h4 id="通用命令" tabindex="-1"><a class="header-anchor" href="#通用命令"><span>通用命令</span></a></h4><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li><code>KEYS pattern</code>: 查找所有符合给定模式(pattern)的 key</li><li><code>EXISTS key</code>: 检查给定 key 是否存在</li><li><code>TYPE key</code> : 返回 key 所储存的值的类型</li><li><code>DEL key</code>:该命令用于在 key 存在是删除 key</li></ul>',19),h={},b=(0,a(83671).A)(h,[["render",function(n,s){const a=(0,e.g2)("ExternalLinkIcon");return(0,e.uX)(),(0,e.CE)("div",null,[i,o,c,(0,e.Lk)("p",null,[u,(0,e.eW)(": "),(0,e.Lk)("a",r,[(0,e.eW)("https://redis.io"),(0,e.bF)(a)]),d,(0,e.eW)(": "),(0,e.Lk)("a",k,[(0,e.eW)("https://www.redis.net.cn/"),(0,e.bF)(a)])]),m,(0,e.Lk)("p",null,[(0,e.eW)("更多命令可以参考Redis中文网："),(0,e.Lk)("a",v,[(0,e.eW)("https://www.redis.net.cn"),(0,e.bF)(a)])]),g])}]]),f=JSON.parse('{"path":"/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article7.html","title":"Javassm - item1-7 (营业状态设置1)","lang":"zh-CN","frontmatter":{"title":"Javassm - item1-7 (营业状态设置1)","date":"2025-11-12T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"营业状态设置1 Redis介绍 Redis是一个基于内存的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件。 官网: https://redis.io 中文网: https://www.redis.net.cn/ key-value结构存储： 主要特点： 基于内存存储，读写性能高 适合存储热点数据（热点商品、资讯、新闻...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article7.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Javassm - item1-7 (营业状态设置1)"}],["meta",{"property":"og:description","content":"营业状态设置1 Redis介绍 Redis是一个基于内存的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件。 官网: https://redis.io 中文网: https://www.redis.net.cn/ key-value结构存储： 主要特点： 基于内存存储，读写性能高 适合存储热点数据（热点商品、资讯、新闻..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-12T18:11:03.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-12T18:11:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Javassm - item1-7 (营业状态设置1)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-12T18:11:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"营业状态设置1","slug":"营业状态设置1","link":"#营业状态设置1","children":[{"level":3,"title":"Redis介绍","slug":"redis介绍","link":"#redis介绍","children":[{"level":4,"title":"基本命令","slug":"基本命令","link":"#基本命令","children":[]}]},{"level":3,"title":"Redis数据类型","slug":"redis数据类型","link":"#redis数据类型","children":[{"level":4,"title":"5种常用数据类型","slug":"_5种常用数据类型","link":"#_5种常用数据类型","children":[]},{"level":4,"title":"各自特点","slug":"各自特点","link":"#各自特点","children":[]}]},{"level":3,"title":"Redis常用命令","slug":"redis常用命令","link":"#redis常用命令","children":[{"level":4,"title":"字符串操作命令","slug":"字符串操作命令","link":"#字符串操作命令","children":[]},{"level":4,"title":"哈希操作命令 H","slug":"哈希操作命令-h","link":"#哈希操作命令-h","children":[]},{"level":4,"title":"列表操作命令 L|R|BR","slug":"列表操作命令-l-r-br","link":"#列表操作命令-l-r-br","children":[]},{"level":4,"title":"集合操作命令 S","slug":"集合操作命令-s","link":"#集合操作命令-s","children":[]},{"level":4,"title":"有序集合操作命令 Z","slug":"有序集合操作命令-z","link":"#有序集合操作命令-z","children":[]},{"level":4,"title":"通用命令","slug":"通用命令","link":"#通用命令","children":[]}]}]}],"git":{"createdTime":1762971063000,"updatedTime":1762971063000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"code/java_item/1-苍穹外卖/article7.md","localizedDate":"2025年11月12日","excerpt":"<h2>营业状态设置1</h2>\\n<h3>Redis介绍</h3>\\n<p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的<strong>存储中间件</strong>。</p>\\n<p><strong>官网</strong>: <a href=\\"https://redis.io\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://redis.io</a>\\n<strong>中文网</strong>: <a href=\\"https://www.redis.net.cn/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.redis.net.cn/</a></p>","autoDesc":true}')},85470:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>b,data:()=>f});var e=a(7847);const t=a.p+"assets/img/36.7e4da618.png",p=a.p+"assets/img/37.365f6c23.png",l=a.p+"assets/img/38.9032f203.png",i=a.p+"assets/img/39.cbfb709e.png",o=a.p+"assets/img/40.aafbba3a.png",c=a.p+"assets/img/41.3fd4d113.png",u=a.p+"assets/img/42.45968471.png",r=a.p+"assets/img/43.dd4c2663.png",d=a.p+"assets/img/44.61180580.png",k=a.p+"assets/img/45.20b08ef1.png",m=(0,e.Fv)('<h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h2><p>之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁</p><h3 id="集群环境下的并发问题" tabindex="-1"><a class="header-anchor" href="#集群环境下的并发问题"><span>集群环境下的并发问题</span></a></h3><p>1、我们将服务启动两份，端口分别为8081和8082</p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</p><p>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因</p><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>在这种情况下，我们就需要使用分布式锁来解决这个问题</p><h3 id="基本原理和实现方式对比" tabindex="-1"><a class="header-anchor" href="#基本原理和实现方式对比"><span>基本原理和实现方式对比</span></a></h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="分布式锁条件" tabindex="-1"><a class="header-anchor" href="#分布式锁条件"><span>分布式锁条件</span></a></h4><ul><li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p>安全性：安全也是程序中必不可少的一环</p></li></ul><h4 id="常见分布式锁" tabindex="-1"><a class="header-anchor" href="#常见分布式锁"><span>常见分布式锁</span></a></h4><ul><li><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p></li><li><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p></li><li><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p></li></ul><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="redis分布式锁的实现思路" tabindex="-1"><a class="header-anchor" href="#redis分布式锁的实现思路"><span>Redis分布式锁的实现思路</span></a></h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁 <code>SETNX lock thread1</code></li><li>超时释放：获取锁时添加一个超时时间 <code>EXPIRE lock 10</code></li><li>确保原子性，用一个命令 <code>SET lock thread1 NX EX 10</code></li></ul></li><li><p>释放锁：</p><ul><li>手动释放 <code>DEL key</code></li></ul></li></ul><p>核心思路：</p><p>我们利用 redis 命令 <code>SET lock thread1 NX EX 10</code>，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key，返回1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑</p><p>没有抢到锁的，采用非阻塞的方法，直接表示获取锁失败，</p><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="redis分布式锁实现1" tabindex="-1"><a class="header-anchor" href="#redis分布式锁实现1"><span>Redis分布式锁实现1</span></a></h3><p>加锁逻辑 (非阻塞模式)</p><h4 id="锁实现" tabindex="-1"><a class="header-anchor" href="#锁实现"><span>锁实现</span></a></h4><h5 id="接口" tabindex="-1"><a class="header-anchor" href="#接口"><span>接口</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILock</span> <span class="token punctuation">{</span>\n    <span class="token doc-comment comment">/**\n     * 尝试获取锁\n     * <span class="token keyword">@param</span> <span class="token parameter">timeoutSec</span>\n     * <span class="token keyword">@return</span>\n     */</span>\n    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token doc-comment comment">/**\n     * 释放锁\n     */</span>\n    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="simpleredislock" tabindex="-1"><a class="header-anchor" href="#simpleredislock"><span><code>SimpleRedisLock</code></span></a></h5><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleRedisLock</span> <span class="token keyword">implements</span> <span class="token class-name">ILock</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;lock:&quot;</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取线程标示</span>\n        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 获取锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="修改业务代码" tabindex="-1"><a class="header-anchor" href="#修改业务代码"><span>修改业务代码</span></a></h5><p>根据用户ID来尝试去Redis中获取锁，如果成功，就执行创建订单逻辑，失败就返回 (不能重复下单)，然后再等事务对应的代码执行结束，数据库更新后再释放锁，从而避免并发时的重复下单</p><p>这样在同一时间内，同一个用户即使同时发很多请求，也只有一个请求可以获取并行锁进入尝试创建订单的逻辑，这样当用户之前没有订单时，也不会发生多线程进入查询得到0订单的情况</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 查询优惠券</span>\n    <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 判断秒杀是否开始和结束</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;秒杀尚未开始&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;秒杀已经结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 判断库存是否充足</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;库存不足&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 创建锁对象(新增代码)</span>\n    <span class="token class-name">SimpleRedisLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token string">&quot;order:&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">,</span> stringRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁对象</span>\n    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 加锁失败</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;不允许重复下单&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取代理对象(事务)</span>\n        <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="redis分布式锁误删情况" tabindex="-1"><a class="header-anchor" href="#redis分布式锁误删情况"><span>Redis分布式锁误删情况</span></a></h3><h4 id="情况分析" tabindex="-1"><a class="header-anchor" href="#情况分析"><span>情况分析</span></a></h4><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁</p><p>然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>解决方案</strong></p><p>就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除</p><p>假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑</p><p>当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="解决误删情况" tabindex="-1"><a class="header-anchor" href="#解决误删情况"><span>解决误删情况</span></a></h4><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><p>因为此时后端服务分布式，可能有多个端口对应多个JVM，因此不<strong>同的线程生成的UUID是不同的</strong>，可以进行区分</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><figure><img src="'+u+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="加锁" tabindex="-1"><a class="header-anchor" href="#加锁"><span>加锁</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;lock:&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取线程标示</span>\n    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁</span>\n    <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="释放锁" tabindex="-1"><a class="header-anchor" href="#释放锁"><span>释放锁</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取线程标示</span>\n    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁中的标示</span>\n    <span class="token class-name">String</span> id <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 判断标示是否一致</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>threadId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="分布式锁的原子性问题" tabindex="-1"><a class="header-anchor" href="#分布式锁的原子性问题"><span>分布式锁的原子性问题</span></a></h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，<strong>正准备删除锁</strong>，阻塞了一段时间 (JVM垃圾回收等)，导致<strong>此时他的锁到期</strong>了</p><p>那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的<strong>原子性</strong>问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性</p>',65),v={href:"https://www.runoob.com/lua/lua-tutorial.html",target:"_blank",rel:"noopener noreferrer"},g=(0,e.Fv)('<p>这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现<code>拿锁比锁删锁</code>是一个原子性动作了</p><h5 id="lua中redis提供的调用函数" tabindex="-1"><a class="header-anchor" href="#lua中redis提供的调用函数"><span>lua中Redis提供的调用函数</span></a></h5><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;命令名称&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;其它参数&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如，我们要执行<code>set name jack</code>，则脚本是这样：</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token operator">#</span> 执行 set name jack\nredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;set&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;jack&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token operator">#</span> 先执行 set name jack\nredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;set&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Rose&#39;</span><span class="token punctuation">)</span>\n<span class="token operator">#</span> 再执行 get name\n<span class="token keyword">local</span> name <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span>\n<span class="token operator">#</span> 返回\n<span class="token keyword">return</span> name\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="redis执行lua脚本-eval" tabindex="-1"><a class="header-anchor" href="#redis执行lua脚本-eval"><span>Redis执行lua脚本 <code>EVAL</code></span></a></h5><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下</p><div class="language-redis line-numbers-mode" data-ext="redis" data-title="redis"><pre class="language-redis"><code>EVAL &quot;return redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)&quot; 0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果脚本中的key、value不想写死，可以作为参数传递</p><p>key类型参数会放入<code>KEYS</code>数组，其它参数会放入<code>ARGV</code>数组(这里数组起始元素是从1开始的)</p><p>在脚本中可以从KEYS和ARGV数组获取这些参数：</p><figure><img src="'+d+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="java调用lua脚本解决原子性问题" tabindex="-1"><a class="header-anchor" href="#java调用lua脚本解决原子性问题"><span>java调用lua脚本解决原子性问题</span></a></h4><h5 id="释放锁的逻辑" tabindex="-1"><a class="header-anchor" href="#释放锁的逻辑"><span>释放锁的逻辑</span></a></h5><p>释放锁的业务流程是这样的</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span>\n<span class="token comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;GET&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>\n  <span class="token comment">-- 一致，则删除锁</span>\n  <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;DEL&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">end</span>\n<span class="token comment">-- 不一致，则直接返回</span>\n<span class="token keyword">return</span> <span class="token number">0</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="具体代码" tabindex="-1"><a class="header-anchor" href="#具体代码"><span>具体代码</span></a></h5><p>我们的<code>RedisTemplate</code>中，可以利用execute方法去执行lua脚本，参数对应关系就如下</p><figure><img src="'+k+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>Java代码</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">;</span>\n<span class="token keyword">static</span> <span class="token punctuation">{</span>\n    <span class="token constant">UNLOCK_SCRIPT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">&quot;unlock.lua&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用lua脚本</span>\n    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>\n            <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">,</span>\n            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span>\n            <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>在之前的逻辑上，已经实现了单个JVM时的 一人一单 和 阻止超卖的情况，主要逻辑也封装在了 <code>createVoucherOrder</code> 函数中</p><p>但是当开了多个服务，存在多个 JVM 时，此时处理 一人一单 的逻辑就不行了, 因为本质是通过不同的 <code>userId.toString().intern()</code> 在通过 <code>synchronized</code> 来创建悲观锁使得同一时刻一个用户只能有一个请求可以创建订单，这样就解决了一人一单</p><p>但是 多个JVM时，这种锁就没用了，因为不同的JVM对象是不同的。</p><p>所以需要考虑别的方法，采用分布式锁来解决，即多个JVM去Redis获取锁，这样就不会有问题了，但是会出现<strong>误删</strong>和<strong>原子性</strong>的情况，所以又要解决</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁 <ul><li>特性： <ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission</p><p>死锁 —— 添加过期时间</p><p>误删 —— 删之前判断一下当前这把锁是否是属于自己的</p><p>原子性问题 —— lua表达式来解决</p><p>锁不住 (过期时间到了之后续期) —— <code>redission</code></p>',39),h={},b=(0,a(83671).A)(h,[["render",function(n,s){const a=(0,e.g2)("ExternalLinkIcon");return(0,e.uX)(),(0,e.CE)("div",null,[m,(0,e.Lk)("p",null,[(0,e.eW)("Lua是一种编程语言，它的基本语法可以参考网站："),(0,e.Lk)("a",v,[(0,e.eW)("https://www.runoob.com/lua/lua-tutorial.html"),(0,e.bF)(a)])]),g])}]]),f=JSON.parse('{"path":"/code/java_item/2-hmdp/article7.html","title":"item2-7 (优惠券秒杀2 - 分布式锁)","lang":"zh-CN","frontmatter":{"title":"item2-7 (优惠券秒杀2 - 分布式锁)","category":["code"],"tag":["java_item"],"order":-0.6,"description":"分布式锁 之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁 集群环境下的并发问题 1、我们将服务启动两份，端口分别为8081和8082 2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/2-hmdp/article7.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"item2-7 (优惠券秒杀2 - 分布式锁)"}],["meta",{"property":"og:description","content":"分布式锁 之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁 集群环境下的并发问题 1、我们将服务启动两份，端口分别为8081和8082 2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-09T16:42:22.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:modified_time","content":"2025-12-09T16:42:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"item2-7 (优惠券秒杀2 - 分布式锁)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-09T16:42:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[{"level":3,"title":"集群环境下的并发问题","slug":"集群环境下的并发问题","link":"#集群环境下的并发问题","children":[]},{"level":3,"title":"基本原理和实现方式对比","slug":"基本原理和实现方式对比","link":"#基本原理和实现方式对比","children":[{"level":4,"title":"分布式锁条件","slug":"分布式锁条件","link":"#分布式锁条件","children":[]},{"level":4,"title":"常见分布式锁","slug":"常见分布式锁","link":"#常见分布式锁","children":[]}]},{"level":3,"title":"Redis分布式锁的实现思路","slug":"redis分布式锁的实现思路","link":"#redis分布式锁的实现思路","children":[]},{"level":3,"title":"Redis分布式锁实现1","slug":"redis分布式锁实现1","link":"#redis分布式锁实现1","children":[{"level":4,"title":"锁实现","slug":"锁实现","link":"#锁实现","children":[{"level":5,"title":"接口","slug":"接口","link":"#接口","children":[]},{"level":5,"title":"SimpleRedisLock","slug":"simpleredislock","link":"#simpleredislock","children":[]},{"level":5,"title":"修改业务代码","slug":"修改业务代码","link":"#修改业务代码","children":[]}]}]},{"level":3,"title":"Redis分布式锁误删情况","slug":"redis分布式锁误删情况","link":"#redis分布式锁误删情况","children":[{"level":4,"title":"情况分析","slug":"情况分析","link":"#情况分析","children":[]},{"level":4,"title":"解决误删情况","slug":"解决误删情况","link":"#解决误删情况","children":[{"level":5,"title":"加锁","slug":"加锁","link":"#加锁","children":[]},{"level":5,"title":"释放锁","slug":"释放锁","link":"#释放锁","children":[]}]}]},{"level":3,"title":"分布式锁的原子性问题","slug":"分布式锁的原子性问题","link":"#分布式锁的原子性问题","children":[{"level":4,"title":"Lua脚本","slug":"lua脚本","link":"#lua脚本","children":[{"level":5,"title":"lua中Redis提供的调用函数","slug":"lua中redis提供的调用函数","link":"#lua中redis提供的调用函数","children":[]},{"level":5,"title":"Redis执行lua脚本 EVAL","slug":"redis执行lua脚本-eval","link":"#redis执行lua脚本-eval","children":[]}]},{"level":4,"title":"java调用lua脚本解决原子性问题","slug":"java调用lua脚本解决原子性问题","link":"#java调用lua脚本解决原子性问题","children":[{"level":5,"title":"释放锁的逻辑","slug":"释放锁的逻辑","link":"#释放锁的逻辑","children":[]},{"level":5,"title":"具体代码","slug":"具体代码","link":"#具体代码","children":[]}]}]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1765127830000,"updatedTime":1765298542000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":2}]},"readingTime":{"minutes":12.35,"words":3704},"filePathRelative":"code/java_item/2-hmdp/article7.md","localizedDate":"2025年12月7日","excerpt":"<h2>分布式锁</h2>\\n<p>之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁</p>\\n<h3>集群环境下的并发问题</h3>\\n<p>1、我们将服务启动两份，端口分别为8081和8082</p>\\n<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p>\\n<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</p>\\n<p>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因</p>","autoDesc":true}')}}]);