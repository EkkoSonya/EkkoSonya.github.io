"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[2424],{83671:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},8963:(n,s,a)=>{n.exports=a.p+"assets/img/2.7205c9e9.png"},96096:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>d});var e=a(7847);const t=a.p+"assets/img/9.5cb0c852.png",p=(0,e.Fv)('<h2 id="苍穹外卖" tabindex="-1"><a class="header-anchor" href="#苍穹外卖"><span>苍穹外卖</span></a></h2><h3 id="接口文档导入" tabindex="-1"><a class="header-anchor" href="#接口文档导入"><span>接口文档导入</span></a></h3><p>前企业主流的前后端分离开发方式，那么这种方式就要求我们之前需要先将接口定义好，这样前后端人员才能并行开发。其实，在真实的企业开发中，接口设计过程其实是一个非常漫长的过程，可能需要多次开会讨论调整，甚至在开发的过程中才会发现某些接口定义还需要再调整，这种情况其实是非常常见的</p><p><strong>前后端分离开发流程</strong>：</p><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="接口管理平台" tabindex="-1"><a class="header-anchor" href="#接口管理平台"><span>接口管理平台</span></a></h4>',6),o={href:"https://yapi.pro/",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Lk)("h4",{id:"swagger-knife4j",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#swagger-knife4j"},[(0,e.Lk)("span",null,"Swagger (knife4j)")])],-1),i={href:"https://swagger.io/",target:"_blank",rel:"noopener noreferrer"},l=(0,e.Fv)('<ol><li><p>使得前后端分离开发更加方便，有利于团队协作</p></li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试</p><p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p></li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><h5 id="使用步骤" tabindex="-1"><a class="header-anchor" href="#使用步骤"><span>使用步骤</span></a></h5><ol><li><p>导入 knife4j 的maven坐标</p><p>在pom.xml中添加依赖</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>knife4j-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在配置类中加入 knife4j 相关配置</p><p>WebMvcConfiguration.java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n     * 通过knife4j生成接口文档\n     * <span class="token keyword">@return</span>\n*/</span>\n <span class="token annotation punctuation">@Bean</span>\n <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">docket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token class-name">ApiInfo</span> apiInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">&quot;苍穹外卖项目接口文档&quot;</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">&quot;2.0&quot;</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">&quot;苍穹外卖项目接口文档&quot;</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n     <span class="token class-name">Docket</span> docket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span><span class="token constant">SWAGGER_2</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span>apiInfo<span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span><span class="token class-name">RequestHandlerSelectors</span><span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">&quot;com.sky.controller&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n             <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n     <span class="token keyword">return</span> docket<span class="token punctuation">;</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>设置静态资源映射，否则接口文档页面无法访问</p><p>WebMvcConfiguration.java</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n     * 设置静态资源映射\n     * <span class="token keyword">@param</span> <span class="token parameter">registry</span>\n*/</span>\n<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span><span class="token class-name">ResourceHandlerRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">&quot;/doc.html&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:/META-INF/resources/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">&quot;/webjars/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:/META-INF/resources/webjars/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h5 id="swagger-常用注解" tabindex="-1"><a class="header-anchor" href="#swagger-常用注解"><span>Swagger 常用注解</span></a></h5><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>@Api</code></td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td><code>@ApiMode</code>l</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td><code>@ApiModelProperty</code></td><td>用在属性上，描述属性信息</td></tr><tr><td><code>@ApiOperation</code></td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><p>接下来，使用上述注解，生成可读性更好的接口文档</p>',9),u={},r=(0,a(83671).A)(u,[["render",function(n,s){const a=(0,e.g2)("ExternalLinkIcon");return(0,e.uX)(),(0,e.CE)("div",null,[p,(0,e.Lk)("p",null,[(0,e.eW)("将课程资料中提供的项目接口导入YApi。访问地址："),(0,e.Lk)("a",o,[(0,e.eW)("https://yapi.pro/"),(0,e.bF)(a)])]),c,(0,e.Lk)("p",null,[(0,e.eW)("Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务("),(0,e.Lk)("a",i,[(0,e.eW)("https://swagger.io/"),(0,e.bF)(a)]),(0,e.eW)(")。 它的主要作用是：")]),l])}]]),d=JSON.parse('{"path":"/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article2.html","title":"Javassm - item1-2 (接口文档导入)","lang":"zh-CN","frontmatter":{"title":"Javassm - item1-2 (接口文档导入)","date":"2025-10-18T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"苍穹外卖 接口文档导入 前企业主流的前后端分离开发方式，那么这种方式就要求我们之前需要先将接口定义好，这样前后端人员才能并行开发。其实，在真实的企业开发中，接口设计过程其实是一个非常漫长的过程，可能需要多次开会讨论调整，甚至在开发的过程中才会发现某些接口定义还需要再调整，这种情况其实是非常常见的 前后端分离开发流程： alt textalt text ...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article2.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Javassm - item1-2 (接口文档导入)"}],["meta",{"property":"og:description","content":"苍穹外卖 接口文档导入 前企业主流的前后端分离开发方式，那么这种方式就要求我们之前需要先将接口定义好，这样前后端人员才能并行开发。其实，在真实的企业开发中，接口设计过程其实是一个非常漫长的过程，可能需要多次开会讨论调整，甚至在开发的过程中才会发现某些接口定义还需要再调整，这种情况其实是非常常见的 前后端分离开发流程： alt textalt text ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-16T17:59:51.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-10-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-16T17:59:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Javassm - item1-2 (接口文档导入)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-16T17:59:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"苍穹外卖","slug":"苍穹外卖","link":"#苍穹外卖","children":[{"level":3,"title":"接口文档导入","slug":"接口文档导入","link":"#接口文档导入","children":[{"level":4,"title":"接口管理平台","slug":"接口管理平台","link":"#接口管理平台","children":[]},{"level":4,"title":"Swagger  (knife4j)","slug":"swagger-knife4j","link":"#swagger-knife4j","children":[{"level":5,"title":"使用步骤","slug":"使用步骤","link":"#使用步骤","children":[]},{"level":5,"title":"Swagger 常用注解","slug":"swagger-常用注解","link":"#swagger-常用注解","children":[]}]}]}]}],"git":{"createdTime":1760637591000,"updatedTime":1760637591000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":2.29,"words":688},"filePathRelative":"code/java_item/1-苍穹外卖/article2.md","localizedDate":"2025年10月18日","excerpt":"<h2>苍穹外卖</h2>\\n<h3>接口文档导入</h3>\\n<p>前企业主流的前后端分离开发方式，那么这种方式就要求我们之前需要先将接口定义好，这样前后端人员才能并行开发。其实，在真实的企业开发中，接口设计过程其实是一个非常漫长的过程，可能需要多次开会讨论调整，甚至在开发的过程中才会发现某些接口定义还需要再调整，这种情况其实是非常常见的</p>\\n<p><strong>前后端分离开发流程</strong>：</p>\\n<figure><figcaption>alt text</figcaption></figure>\\n<h4>接口管理平台</h4>\\n<p>将课程资料中提供的项目接口导入YApi。访问地址：<a href=\\"https://yapi.pro/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://yapi.pro/</a></p>","autoDesc":true}')},36701:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>d});var e=a(7847);const t=a.p+"assets/img/2.8d6afa4f.png",p=a.p+"assets/img/3.8d56235a.png",o=a.p+"assets/img/4.466c4a42.png",c=a.p+"assets/img/5.1f4031fe.png",i=a.p+"assets/img/6.f63d3f60.png",l=[(0,e.Fv)('<h2 id="_1-短信登录" tabindex="-1"><a class="header-anchor" href="#_1-短信登录"><span>1. 短信登录</span></a></h2><h3 id="_1-1-基于session实现登录" tabindex="-1"><a class="header-anchor" href="#_1-1-基于session实现登录"><span>1.1 基于Session实现登录</span></a></h3><h4 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程"><span>基本流程</span></a></h4><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="发送验证码" tabindex="-1"><a class="header-anchor" href="#发送验证码"><span>发送验证码</span></a></h5><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><h5 id="短信验证码登录、注册" tabindex="-1"><a class="header-anchor" href="#短信验证码登录、注册"><span>短信验证码登录、注册</span></a></h5><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><h5 id="校验登录状态" tabindex="-1"><a class="header-anchor" href="#校验登录状态"><span>校验登录状态</span></a></h5><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><h4 id="_1-实现发送短信验证码" tabindex="-1"><a class="header-anchor" href="#_1-实现发送短信验证码"><span>1) 实现发送短信验证码</span></a></h4><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="请求格式" tabindex="-1"><a class="header-anchor" href="#请求格式"><span>请求格式</span></a></h5><ul><li>方式：<code>Post</code></li><li>路径：<code>/user/code</code></li><li>请求参数：路径自带 <code>@RequestParam</code></li></ul><p>对应的 Controller Service 层代码：</p><h5 id="controller-层" tabindex="-1"><a class="header-anchor" href="#controller-层"><span><code>Controller</code> 层</span></a></h5><p><code>UserController</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * 登录功能\n * <span class="token keyword">@param</span> <span class="token parameter">loginForm</span> 登录参数，包含手机号、验证码；或者手机号、密码\n */</span>\n<span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// TODO 实现登录功能</span>\n    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;功能未完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="service层" tabindex="-1"><a class="header-anchor" href="#service层"><span><code>Service</code>层</span></a></h5><p>接口：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUserService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n  <span class="token class-name">Result</span> <span class="token function">senCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>\n<span class="token annotation punctuation">@Service</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserMapper</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">IUserService</span> <span class="token punctuation">{</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">senCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 校验手机号</span>\n      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n          <span class="token comment">// 不符合 返回报错</span>\n          <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;手机号格式错误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 生成验证码</span>\n      <span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token class-name">RandomUtil</span><span class="token punctuation">.</span><span class="token function">randomNumbers</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 保存验证码到 session</span>\n      session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">,</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 发送验证码</span>\n      log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;验证码：{}&quot;</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 返回</span>\n      <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-实现短信验证码登录" tabindex="-1"><a class="header-anchor" href="#_2-实现短信验证码登录"><span>2) 实现短信验证码登录</span></a></h4><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="请求格式-1" tabindex="-1"><a class="header-anchor" href="#请求格式-1"><span>请求格式</span></a></h5><ul><li>方式：<code>Post</code></li><li>路径：<code>/user/login</code></li><li>请求参数：Json格式 <code>@RequestBody</code></li></ul><h5 id="controller层" tabindex="-1"><a class="header-anchor" href="#controller层"><span><code>Controller</code>层</span></a></h5><p><code>UserController</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 实现登录功能</span>\n    <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>loginForm<span class="token punctuation">,</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="service层-1" tabindex="-1"><a class="header-anchor" href="#service层-1"><span><code>Service</code>层</span></a></h5><p><strong>接口：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>实现类：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">LoginFormDTO</span> loginForm<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">String</span> phone <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 校验手机号</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">RegexUtils</span><span class="token punctuation">.</span><span class="token function">isPhoneInvalid</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">// 不符合 返回报错</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;手机号格式错误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 校验验证码</span>\n    <span class="token class-name">Object</span> code <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">String</span> userCode <span class="token operator">=</span> loginForm<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>code <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>code<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>userCode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">// 不一致报错</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;验证码错误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 一致 根据手机号查询用户</span>\n    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">&quot;phone&quot;</span><span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 不存在 创建新用户</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        user<span class="token punctuation">.</span><span class="token function">setPhone</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        user<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span><span class="token string">&quot;Penguin_&quot;</span><span class="token operator">+</span><span class="token class-name">RandomUtil</span><span class="token punctuation">.</span><span class="token function">randomString</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 保存信息到session</span>\n    session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-校验登录状态" tabindex="-1"><a class="header-anchor" href="#_3-校验登录状态"><span>3) 校验登录状态</span></a></h4><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="tomcat-运行原理" tabindex="-1"><a class="header-anchor" href="#tomcat-运行原理"><span>tomcat 运行原理</span></a></h5><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>当用户发起请求时，会访问我们向tomcat注册的端口</p><p>任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外</p><p>当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p>在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><h5 id="添加拦截器" tabindex="-1"><a class="header-anchor" href="#添加拦截器"><span>添加拦截器</span></a></h5><p><code>com.hmdp.interceptor</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n      <span class="token comment">//1.获取session</span>\n      <span class="token class-name">HttpSession</span> session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">//2.获取session中的用户</span>\n      <span class="token class-name">Object</span> user <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">//3.判断用户是否存在</span>\n      <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n          <span class="token comment">//4.不存在，拦截，返回401状态码</span>\n          response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">//5.存在，保存用户信息到 Threadlocal</span>\n      <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">UserDTO</span><span class="token punctuation">)</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">//6.放行</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="注册拦截器" tabindex="-1"><a class="header-anchor" href="#注册拦截器"><span>注册拦截器</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>\n  <span class="token annotation punctuation">@Resource</span>\n  <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>\n\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 登录拦截器</span>\n      registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n              <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span>\n                      <span class="token string">&quot;/shop/**&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/voucher/**&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/shop-type/**&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/upload/**&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/blog/hot&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/user/code&quot;</span><span class="token punctuation">,</span>\n                      <span class="token string">&quot;/user/login&quot;</span>\n              <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',50)],u={},r=(0,a(83671).A)(u,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,l)}]]),d=JSON.parse('{"path":"/code/java_item/2-hmdp/article2.html","title":"item2-2 (短信登录)","lang":"zh-CN","frontmatter":{"title":"item2-2 (短信登录)","date":"2025-11-25T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"1. 短信登录 1.1 基于Session实现登录 基本流程 alt textalt text 发送验证码 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号 如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户 短信验证码登录、注册 用户将验证码和手机号进行输入，后台从se...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/2-hmdp/article2.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"item2-2 (短信登录)"}],["meta",{"property":"og:description","content":"1. 短信登录 1.1 基于Session实现登录 基本流程 alt textalt text 发送验证码 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号 如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户 短信验证码登录、注册 用户将验证码和手机号进行输入，后台从se..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-01T11:24:28.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-01T11:24:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"item2-2 (短信登录)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-01T11:24:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"1. 短信登录","slug":"_1-短信登录","link":"#_1-短信登录","children":[{"level":3,"title":"1.1 基于Session实现登录","slug":"_1-1-基于session实现登录","link":"#_1-1-基于session实现登录","children":[{"level":4,"title":"基本流程","slug":"基本流程","link":"#基本流程","children":[{"level":5,"title":"发送验证码","slug":"发送验证码","link":"#发送验证码","children":[]},{"level":5,"title":"短信验证码登录、注册","slug":"短信验证码登录、注册","link":"#短信验证码登录、注册","children":[]},{"level":5,"title":"校验登录状态","slug":"校验登录状态","link":"#校验登录状态","children":[]}]},{"level":4,"title":"1) 实现发送短信验证码","slug":"_1-实现发送短信验证码","link":"#_1-实现发送短信验证码","children":[{"level":5,"title":"请求格式","slug":"请求格式","link":"#请求格式","children":[]},{"level":5,"title":"Controller 层","slug":"controller-层","link":"#controller-层","children":[]},{"level":5,"title":"Service层","slug":"service层","link":"#service层","children":[]}]},{"level":4,"title":"2) 实现短信验证码登录","slug":"_2-实现短信验证码登录","link":"#_2-实现短信验证码登录","children":[{"level":5,"title":"请求格式","slug":"请求格式-1","link":"#请求格式-1","children":[]},{"level":5,"title":"Controller层","slug":"controller层","link":"#controller层","children":[]},{"level":5,"title":"Service层","slug":"service层-1","link":"#service层-1","children":[]}]},{"level":4,"title":"3) 校验登录状态","slug":"_3-校验登录状态","link":"#_3-校验登录状态","children":[{"level":5,"title":"tomcat 运行原理","slug":"tomcat-运行原理","link":"#tomcat-运行原理","children":[]},{"level":5,"title":"添加拦截器","slug":"添加拦截器","link":"#添加拦截器","children":[]},{"level":5,"title":"注册拦截器","slug":"注册拦截器","link":"#注册拦截器","children":[]}]}]}]}],"git":{"createdTime":1764588268000,"updatedTime":1764588268000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":4.24,"words":1272},"filePathRelative":"code/java_item/2-hmdp/article2.md","localizedDate":"2025年11月25日","excerpt":"<h2>1. 短信登录</h2>\\n<h3>1.1 基于Session实现登录</h3>\\n<h4>基本流程</h4>\\n<figure><figcaption>alt text</figcaption></figure>\\n<h5>发送验证码</h5>\\n<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>\\n<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>\\n<h5>短信验证码登录、注册</h5>\\n<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>","autoDesc":true}')},12053:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>v,data:()=>m});var e=a(7847);const t=a.p+"assets/img/3.97a18b24.png",p=a.p+"assets/img/4.b43f773b.png";var o=a(8963);const c=a.p+"assets/img/5.b08e341b.png",i=a.p+"assets/img/6.cb3b3701.png",l=a.p+"assets/img/7.f0860bd0.png",u=a.p+"assets/img/8.621c92e9.png",r=a.p+"assets/img/9.d555226d.png",d=[(0,e.Fv)('<h2 id="juc2" tabindex="-1"><a class="header-anchor" href="#juc2"><span>JUC2</span></a></h2><h3 id="锁类型" tabindex="-1"><a class="header-anchor" href="#锁类型"><span>锁类型</span></a></h3><p>在 JDK 1.6 之前，所有的锁都是“重量级”锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 <code>synchronized</code> 块的线程将被阻塞，直到锁被释放</p><p>因为涉及到了线程上下文切换和用户态与内核态的切换，因此效率低</p><p>所以为了减少获得锁和释放锁带来的性能消耗，JDK 1.6引入了&quot;偏向锁&quot;和&quot;轻量级锁&quot;的概念，对 <code>synchronized</code> 做了升级</p><p>在 JDK 1.6 以后，一个对象有四种锁状态，级别由低到高是：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><p>⼏种锁会随着竞争情况逐渐升级，锁的升级很容易发⽣，但是锁降级发⽣的条件就⽐较苛刻了，锁降级发生在 Stop The World 期间，当 JVM 进⼊安全点的时候，会检查是否有闲置的锁，然后进行降级</p><p>不同于大部分文章说的锁不能降级，实际上 HotSpot JVM 是支持锁降级的</p><blockquote><p>In its current implementation, monitor deflation is performed during every STW pause, while all Java threads are waiting at a safepoint. We have seen safepoint cleanup stalls up to 200ms on monitor heavy-applications</p></blockquote><p>大致的意思就是重量级锁降级发生于 STW 阶段，降级对象为仅仅能被 VMThread 访问而没有其他 JavaThread 访问的对象</p><p>当对象状态为偏向锁时，<code>Mark Word</code> 存储的是偏向的线程 ID；当状态为轻量级锁时， Mark Word 存储的是指向线程栈中 Lock Record 的指针；当状态为重量级时， Mark Word 为指向堆中的 monitor（监视器）对象的指针</p><h4 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁"><span>重量级锁</span></a></h4><p>重量级锁依赖于操作系统的互斥锁(mutex，⽤于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段)实现</p><p>而在操作系统中线程间的状态转换需要相对较长的时间，所以重量级锁的效率低，但被阻塞的线程不会消耗 CPU</p><p>当多个线程同时请求某个对象锁时，对象锁会设置不同的状态来区分请求的线程：</p><ul><li>Contention List: 所有请求锁的线程将被首先放到这个竞争队列里</li><li>Entry List：Contention List 中那些有资格成为候选⼈的线程被移到 Entry List</li><li>Wait Set：那些调⽤ wait ⽅法被阻塞的线程被放置到 Wait Set</li><li>OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为 OnDeck</li><li>Owner：获得锁的线程称为 Owner</li><li>!Owner：释放锁的线程</li></ul><p>对于每一个建立的对象，都有一个<code>monitor</code>与之关联，在Java虚拟机（HotSpot）中，monitor是由<code>ObjectMonitor</code>实现的：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>ObjectMonitor() {\n  _header       = NULL;\n  _count        = 0; //记录个数\n  _waiters      = 0,\n  _recursions   = 0;\n  _object       = NULL;\n  _owner        = NULL;\n  _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet\n  _WaitSetLock  = 0 ;\n  _Responsible  = NULL ;\n  _succ         = NULL ;\n  _cxq          = NULL ;\n  FreeNext      = NULL ;\n  _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表\n  _SpinFreq     = 0 ;\n  _SpinClock    = 0 ;\n  OwnerIsThread = 0 ;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个等待锁的线程都会被封装成<code>ObjectWaiter</code>对象，进入到如下机制：</p><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><code>ObjectWaiter</code>首先会进入 <code>Entry Set</code> 等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1</p><p>若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet 集合中等待被唤醒</p><p>若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p><p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p><p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制</p><p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p><hr><p>当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀个 <code>ObjectWaiter</code> 对象插入到 <code>Contention List</code> 队列的队首，然后调用 park 方法挂起当前线程</p><p>当线程释放锁时，会从 <code>Contention List</code> 或 <code>EntryList</code> 中挑选⼀个线程唤醒，被选中的线程叫做 <code>Heir presumptive</code> 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁</p><p>但 <code>synchronized</code> 是非公平的，所以假定继承人不⼀定能获得锁</p><p>这是因为对于重量级锁，线程需要先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销，如果子旋不成功再进入等待队列，这对那些已经在等待队列中的线程来说，稍微显得不公平</p><p>还有一个不公平的地方是子旋线程可能会抢占了 Ready 线程的锁。</p><p>如果线程获得锁后调用 <code>Object.wait</code> ⽅法，则会将线程加到 <code>WaitSet</code> 中，当被 <code>Object.notify</code> 唤醒后，会将线程从 <code>WaitSet</code> 移动到 <code>Contention List</code> 或 <code>EntryList</code> 中去</p><p>需要注意的是，当调用⼀个锁对象的 <code>wait</code> 或 <code>notify</code> 方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</p><h4 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁"><span>轻量级锁</span></a></h4><blockquote><p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p></blockquote><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌一手<strong>同一时间只有一个线程在占用资源</strong>），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p><p>它不像是重量级锁那样，需要向操作系统申请互斥量。</p><p>它的运作机制如下：</p><p>JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 <code>Displaced Mark Word</code></p><p>如果⼀个线程获得锁的时候发现是轻量级锁，会把锁的 <code>Mark Word</code> 复制到自己的 <code>Displaced Mark Word</code> 里面</p><p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。</p><p>如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><blockquote><p>CAS（Compare And Swap）是一种无锁算法（我们之前在Springboot阶段已经讲解过了），它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。</p><p>比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p><p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p></blockquote><p>如果CAS操作失败了的话，那么说明可能<strong>这时有线程已经进入这个同步代码块</strong>了</p><p>这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p><p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>所以，轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p><p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord和复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程</p><h4 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁"><span>偏向锁</span></a></h4><p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了</p><p>它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p><p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p><p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p><p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p><p>所以，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p><p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="锁的升级流程" tabindex="-1"><a class="header-anchor" href="#锁的升级流程"><span>锁的升级流程</span></a></h5><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="锁消除和锁粗化" tabindex="-1"><a class="header-anchor" href="#锁消除和锁粗化"><span>锁消除和锁粗化</span></a></h4><p>锁消除和锁粗化都是在运行时的一些优化方案</p><p>比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。</p><p>锁粗化则是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p><h3 id="jmm内存模型" tabindex="-1"><a class="header-anchor" href="#jmm内存模型"><span>JMM内存模型</span></a></h3><p>这里提到的内存模型和JVM中介绍的内存模型不在同一个层次，JVM中的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型，是在JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型实现的</p><h4 id="java内存模型" tabindex="-1"><a class="header-anchor" href="#java内存模型"><span>Java内存模型</span></a></h4><p>在我们的CPU中，一般都会有高速缓存，而它的出现，是为了解决内存的速度跟不上处理器的处理速度的问题，所以CPU内部会添加一级或多级高速缓存来提高处理器的数据获取效率，但是这样也会导致一个很明显的问题，因为现在基本都是多核心处理器，每个处理器都有一个自己的高速缓存，那么又该怎么去保证每个处理器的高速缓存内容一致呢？</p><p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p><p>而Java也采用了类似的模型来实现支持多线程的内存模型：</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="jmm模型" tabindex="-1"><a class="header-anchor" href="#jmm模型"><span>JMM模型</span></a></h5><p>JMM（Java Memory Model）内存模型规定如下：</p><ul><li><p>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而<strong>局部变量这种属于线程私有，不包括在内</strong>）</p></li><li><p>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，<strong>必须在工作内存中进行</strong>，<strong>不能直接操作主内存中的数据</strong></p></li><li><p>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存</p></li></ul><p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作</p><p>具体是怎么实现的呢？</p><ul><li>主内存：对应堆中存放对象的实例的部分</li><li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中</li></ul><h5 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h5><p>前面我们提到，在CPU中可能会遇到缓存不一致的问题，而Java中，也会遇到，比如下面这种情况：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程1结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程2结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">//等上面两个线程结束</span>\n        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里是两个线程同时对变量<code>i</code>各自进行100000次自增操作，但是实际得到的结果并不是我们所期望的那样</p><p>因为自增操作 <code>i++</code> 实际上在编译后不是一条字节码指令完成的</p><figure><img src="'+u+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>包括变量<code>i</code>的获取、修改、保存，都是被拆分为一个一个的操作完成的，那么这个时候就有可能出现在修改完保存之前，另一条线程也保存了，但是当前线程是毫不知情的</p><h4 id="重排序" tabindex="-1"><a class="header-anchor" href="#重排序"><span>重排序</span></a></h4><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p><ol><li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序。</li><li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序。</li></ol><p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率，比如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们其实可以交换第一行和第二行：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使发生交换，但是我们程序最后的运行结果是不会变的，当然这里只通过代码的形式演示，实际上JVM在执行字节码指令时也会进行优化，可能两个指令并不会按照原有的顺序进行</p><p>虽然单线程下指令重排确实可以起到一定程度的优化作用，但是在多线程下，似乎会导致一些问题：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>   \n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n            b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段代码，在正常情况下，按照我们的正常思维，是不可能输出<code>A</code>的，因为只要b等于1，那么a肯定也是1才对，因为a是在b之前完成的赋值。但是，如果进行了重排序，那么就有可能，a和b的赋值发生交换，b先被赋值为1，而恰巧这个时候，线程1开始判定b是不是1了，这时a还没来得及被赋值为1，可能线程1就已经走到打印那里去了，所以，是有可能输出<code>A</code>的。</p><h4 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字"><span>volatile关键字</span></a></h4><blockquote><ul><li>原子性：就是要做什么事情要么做完，要么就不做，不存在做一半的情况</li><li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</li><li>有序性：即程序执行的顺序按照代码的先后顺序执行</li></ul></blockquote><p>如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作</p><p>下面这个操作看起来是一个有限循环，但是是无限的：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程结束！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在修改a的值...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上这就是我们之前说的，虽然我们主线程中修改了a的值，但是另一个线程并不知道a的值发生了改变，所以循环中依然是使用旧值在进行判断，因此，普通变量是不具有<strong>可见性</strong>的。</p><p>要解决这种问题，我们第一个想到的肯定是加锁，同一时间只能有一个线程使用，这样总行了吧，确实，这样的话肯定是可以解决问题的</p><h5 id="可以保证可见性" tabindex="-1"><a class="header-anchor" href="#可以保证可见性"><span>可以保证可见性</span></a></h5><p>但是，除了硬加一把锁的方案，我们也可以使用<code>volatile</code>关键字来解决，此关键字的第一个作用，就是<strong>保证变量的可见性</strong></p><p>当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量<strong>强制刷新到主内存</strong>中去，并且这个写会操作会导致其他线程中的<code>volatile</code>变量缓存无效</p><p>这样，另一个线程修改了这个变量时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p><p>那么我们就来试试看：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token comment">//添加volatile关键字</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程结束！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在修改a的值...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果还真的如我们所说的那样，当a发生改变时，循环立即结束。</p><h5 id="无法保证原子性" tabindex="-1"><a class="header-anchor" href="#无法保证原子性"><span>无法保证原子性</span></a></h5><p>当然，虽然说<code>volatile</code>能够保证可见性，但是<strong>不能保证原子性</strong>，要解决我们上面的<code>i++</code>的问题，以我们目前所学的知识，还是只能使用加锁来完成</p><p>不对啊，<code>volatile</code>不是能在改变变量的时候其他线程可见吗，那为什么还是不能保证原子性呢？</p><p>还是那句话，自增操作是被瓜分为了<strong>多个步</strong>骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，已经刹不住车了，所以依然会将a的值再更新为一次100）—— 原子类来解决</p><h5 id="禁止指令重排" tabindex="-1"><a class="header-anchor" href="#禁止指令重排"><span>禁止指令重排</span></a></h5><p>最后一个功能就是<code>volatile</code>会禁止指令重排</p><p>也就是说，如果我们操作的是一个<code>volatile</code>变量，它将不会出现重排序的情况，也就解决了我们最上面的问题。</p><p>若用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p><blockquote><p>内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ol><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</li></ol><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序。</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table></blockquote><p>所以<code>volatile</code>能够保证，之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。</p><h5 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h5><p>最后我们来总结一下<code>volatile</code>关键字的三个特性：</p><ul><li>保证可见性</li><li>不保证原子性</li><li>防止指令重排</li></ul><h4 id="happens-before原则" tabindex="-1"><a class="header-anchor" href="#happens-before原则"><span>happens-before原则</span></a></h4><p>JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p><ul><li><p><strong>程序次序规则</strong> 同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作</p><ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证<strong>代码的执行结果一定是和按照顺序执行得到的一致</strong>，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求</li></ul></li><li><p><strong>监视器锁规则</strong> 对一个锁的解锁操作，happens-before后续对这个锁的加锁操作</p><ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li><p><strong>volatile变量规则</strong> 对一个volatile变量的写操作happens-before后续对这个变量的读操作</p><ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li></ul></li><li><p><strong>线程启动规则：</strong> 主线程A启动线程B，线程B中可以看到主线程启动B之前的操作</p><ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li></ul></li><li><p><strong>线程加入规则：</strong> 如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</p></li><li><p><strong>传递性规则：</strong> 如果A happens-before B，B happens-before C，那么A happens-before C。</p></li></ul><p>那么我们来从happens-before原则的角度，来解释一下下面的程序结果：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n        b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n          <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> \n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们定义以上出现的操作：</p><ul><li><strong>A：</strong> 将变量<code>a</code>的值修改为<code>10</code></li><li><strong>B：</strong> 将变量<code>b</code>的值修改为<code>a + 1</code></li><li><strong>C：</strong> 主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果为<code>true</code>那么就打印<code>a</code></li></ul><p>首先我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B</p><p>接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C</p><p>最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code></p>',136)],k={},v=(0,a(83671).A)(k,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,d)}]]),m=JSON.parse('{"path":"/code/%E5%85%AB%E8%82%A1/JUC/article2.html","title":"JUC2 - 基本介绍2","lang":"zh-CN","frontmatter":{"title":"JUC2 - 基本介绍2","date":"2025-12-26T00:00:00.000Z","category":["code"],"tag":["java","juc"],"order":-0.5,"description":"JUC2 锁类型 在 JDK 1.6 之前，所有的锁都是“重量级”锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 synchronized 块的线程将被阻塞，直到锁被释放 因为涉及到了线程上下文切换和用户态与内核态的切换，因此效率低 所以为了减少获得锁和释放锁带来的性能消耗，JDK 1.6引入了\\"偏向锁\\"和\\"轻量级锁\\"的概念，对 s...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/%E5%85%AB%E8%82%A1/JUC/article2.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"JUC2 - 基本介绍2"}],["meta",{"property":"og:description","content":"JUC2 锁类型 在 JDK 1.6 之前，所有的锁都是“重量级”锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 synchronized 块的线程将被阻塞，直到锁被释放 因为涉及到了线程上下文切换和用户态与内核态的切换，因此效率低 所以为了减少获得锁和释放锁带来的性能消耗，JDK 1.6引入了\\"偏向锁\\"和\\"轻量级锁\\"的概念，对 s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-26T17:10:55.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"juc"}],["meta",{"property":"article:published_time","content":"2025-12-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-26T17:10:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC2 - 基本介绍2\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-26T17:10:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"JUC2","slug":"juc2","link":"#juc2","children":[{"level":3,"title":"锁类型","slug":"锁类型","link":"#锁类型","children":[{"level":4,"title":"重量级锁","slug":"重量级锁","link":"#重量级锁","children":[]},{"level":4,"title":"轻量级锁","slug":"轻量级锁","link":"#轻量级锁","children":[]},{"level":4,"title":"偏向锁","slug":"偏向锁","link":"#偏向锁","children":[]},{"level":4,"title":"总结","slug":"总结","link":"#总结","children":[{"level":5,"title":"锁的升级流程","slug":"锁的升级流程","link":"#锁的升级流程","children":[]}]},{"level":4,"title":"锁消除和锁粗化","slug":"锁消除和锁粗化","link":"#锁消除和锁粗化","children":[]}]},{"level":3,"title":"JMM内存模型","slug":"jmm内存模型","link":"#jmm内存模型","children":[{"level":4,"title":"Java内存模型","slug":"java内存模型","link":"#java内存模型","children":[{"level":5,"title":"JMM模型","slug":"jmm模型","link":"#jmm模型","children":[]},{"level":5,"title":"例子","slug":"例子","link":"#例子","children":[]}]},{"level":4,"title":"重排序","slug":"重排序","link":"#重排序","children":[]},{"level":4,"title":"volatile关键字","slug":"volatile关键字","link":"#volatile关键字","children":[{"level":5,"title":"可以保证可见性","slug":"可以保证可见性","link":"#可以保证可见性","children":[]},{"level":5,"title":"无法保证原子性","slug":"无法保证原子性","link":"#无法保证原子性","children":[]},{"level":5,"title":"禁止指令重排","slug":"禁止指令重排","link":"#禁止指令重排","children":[]},{"level":5,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":4,"title":"happens-before原则","slug":"happens-before原则","link":"#happens-before原则","children":[]}]}]}],"git":{"createdTime":1766769055000,"updatedTime":1766769055000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":22.73,"words":6819},"filePathRelative":"code/八股/JUC/article2.md","localizedDate":"2025年12月26日","excerpt":"<h2>JUC2</h2>\\n<h3>锁类型</h3>\\n<p>在 JDK 1.6 之前，所有的锁都是“重量级”锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 <code>synchronized</code> 块的线程将被阻塞，直到锁被释放</p>\\n<p>因为涉及到了线程上下文切换和用户态与内核态的切换，因此效率低</p>\\n<p>所以为了减少获得锁和释放锁带来的性能消耗，JDK 1.6引入了\\"偏向锁\\"和\\"轻量级锁\\"的概念，对 <code>synchronized</code> 做了升级</p>\\n<p>在 JDK 1.6 以后，一个对象有四种锁状态，级别由低到高是：</p>\\n<ul>\\n<li>无锁状态</li>\\n<li>偏向锁状态</li>\\n<li>轻量级锁状态</li>\\n<li>重量级锁状态</li>\\n</ul>","autoDesc":true}')},10046:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>d});var e=a(7847);const t=a.p+"assets/img/1.a707d667.png",p=a.p+"assets/img/2.150c77ad.png",o=a.p+"assets/img/3.1483383f.png",c=a.p+"assets/img/4.b54dd091.png",i=a.p+"assets/img/5.7133e99e.png",l=[(0,e.Fv)('<h2 id="jvm内存管理" tabindex="-1"><a class="header-anchor" href="#jvm内存管理"><span>JVM内存管理</span></a></h2><p>在传统的C/C++开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效</p><p>因此，内存管理是一个非常严肃的问题。</p><p>比如我们就可以通过C语言动态申请内存，并用于存放数据：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">//动态申请4个int大小的内存空间</span>\n    <span class="token keyword">int</span><span class="token operator">*</span> memory <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">//修改第一个int空间的值</span>\n    memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token comment">//修改第二个int空间的值</span>\n    memory<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n    <span class="token comment">//遍历内存区域中所有的值</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> memory<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">//释放指针所指向的内存区域</span>\n    <span class="token function">free</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">//最后将指针赋值为NULL</span>\n    memory <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在Java中，这种操作实际上是不允许的，Java只支持<strong>直接使用基本数据类型和对象类型</strong></p><p>至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制</p><p>这样就帮助我们节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C/C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行</p><p>只有了解了JVM的内存管理机制，我们才能够在出现内存相关问题时找到解决方案</p><h2 id="内存区域划分" tabindex="-1"><a class="header-anchor" href="#内存区域划分"><span>内存区域划分</span></a></h2><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>内存区域一共分为5个区域</p><p>其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁</p><p>而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的</p><p>每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。</p><p>内存划分完成之后，我们的JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了</p><h3 id="大致划分" tabindex="-1"><a class="header-anchor" href="#大致划分"><span>大致划分</span></a></h3><h4 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h4><p>首先我们来介绍一下程序计数器，它和我们的传统8086 CPU中PC寄存器的工作差不多，因为JVM虚拟机目的就是实现物理机那样的程序执行。</p><p>在8086 CPU中，PC作为程序计数器，负责储存内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址，进入下一个指令周期时，就会根据当前地址所指向的指令，进行执行。</p><p>而JVM中的程序计数器可以看做是<strong>当前线程所执行字节码的行号指示器</strong></p><p>而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令。</p><p>因为Java的多线程也是依靠<strong>时间片轮转算法</strong>进行的，因此一个CPU同一时间也只会处理一个线程，当某个线程的时间片消耗完成后，会自动切换到下一个线程继续执行</p><p>而当前线程的执行位置会<strong>被保存到当前线程的程序计数器中</strong>，当下次轮转到此线程时，又继续根据之前的执行位置继续向下执行。</p><p>程序计数器因为只需要记录很少的信息，所以只占用很少一部分内存。</p><h4 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h4><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素）</p><h5 id="栈帧组成" tabindex="-1"><a class="header-anchor" href="#栈帧组成"><span>栈帧组成</span></a></h5><p>栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等</p><p>其中局部变量表就是我们方法中的局部变量，实际上局部变量表在class文件中就已经定义好了</p><p>操作数栈就是我们之前字节码执行时使用到的栈结构；</p><p>每个栈帧还保存了一个<strong>可以指向当前方法所在类</strong>的运行时常量池</p><p>目的是：当前方法中如果需要调用其他方法的时候，能够从运行时常量池中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</p><p>最后是方法出口，也就是方法该如何结束，是抛出异常还是正常返回</p><h5 id="模拟分析" tabindex="-1"><a class="header-anchor" href="#模拟分析"><span>模拟分析</span></a></h5><p>这里我们来模拟一下整个虚拟机栈的运作流程，我们先编写一个测试类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们的主方法执行后，会依次执行三个方法<code>a() -&gt; b() -&gt; c() -&gt; 返回</code>，我们首先来观察一下反编译之后的结果：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>{\n  public com.test.Main();   #这个是构造方法\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/test/Main;\n\n  public static void main(java.lang.String[]);    #主方法\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: invokestatic  #2                  // Method a:()I\n         3: istore_1\n         4: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         7: iload_1\n         8: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\n        11: return\n      LineNumberTable:\n        line 5: 0\n        line 6: 4\n        line 7: 11\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      12     0  args   [Ljava/lang/String;\n            4       8     1   res   I\n\n  public static int a();\n    descriptor: ()I\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=0, args_size=0\n         0: invokestatic  #5                  // Method b:()I\n         3: ireturn\n      LineNumberTable:\n        line 10: 0\n\n  public static int b();\n    descriptor: ()I\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=0, args_size=0\n         0: invokestatic  #6                  // Method c:()I\n         3: ireturn\n      LineNumberTable:\n        line 14: 0\n\n  public static int c();\n    descriptor: ()I\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=0\n         0: bipush        10\n         2: istore_0\n         3: bipush        20\n         5: istore_1\n         6: iload_0\n         7: iload_1\n         8: iadd\n         9: ireturn\n      LineNumberTable:\n        line 18: 0\n        line 19: 3\n        line 20: 6\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            3       7     0     a   I\n            6       4     1     b   I\n}\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到在编译之后，我们整个方法的最大操作数栈深度、局部变量表都是已经确定好的，当我们程序开始执行时，会根据这些信息封装为对应的栈帧，我们从<code>main</code>方法开始看起：</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>接着我们继续往下，到了<code>0: invokestatic #2 // Method a:()I</code>时，需要调用方法<code>a()</code></p><p>这时当前方法就不会继续向下运行了，而是去执行方法<code>a()</code>，那么同样的，将此方法也入栈，注意是放入到栈顶位置，<code>main</code>方法的栈帧会被压下去</p><p>这时，进入方法a之后，又继而进入到方法b，最后在进入c，因此，到达方法c的时候，我们的虚拟机栈变成了：</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>现在我们依次执行方法c中的指令，最后返回a+b的结果，在方法c返回之后，也就代表方法c已经执行结束了，栈帧4会自动出栈，这时栈帧3就得到了上一栈帧返回的结果，并继续执行，但是由于紧接着马上就返回，所以继续重复栈帧4的操作，此时栈帧3也出栈并继续将结果交给下一个栈帧2，最后栈帧2再将结果返回给栈帧1，然后栈帧1就可以继续向下运行了，最后输出结果。</p><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h4><p>本地方法栈与虚拟机栈作用差不多</p>',50)],u={},r=(0,a(83671).A)(u,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,l)}]]),d=JSON.parse('{"path":"/code/%E5%85%AB%E8%82%A1/JVM/article2.html","title":"JVM2 - 内存管理1","lang":"zh-CN","frontmatter":{"title":"JVM2 - 内存管理1","category":["code"],"tag":["java","jvm"],"order":-0.5,"description":"JVM内存管理 在传统的C/C++开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效 因此，内存管理是一个非常严肃的问题。 比如我们就可以通过C语言动态申请内存，并用于存放数据： 而在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/%E5%85%AB%E8%82%A1/JVM/article2.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"JVM2 - 内存管理1"}],["meta",{"property":"og:description","content":"JVM内存管理 在传统的C/C++开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效 因此，内存管理是一个非常严肃的问题。 比如我们就可以通过C语言动态申请内存，并用于存放数据： 而在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-07T17:17:10.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:modified_time","content":"2025-12-07T17:17:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM2 - 内存管理1\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-07T17:17:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"JVM内存管理","slug":"jvm内存管理","link":"#jvm内存管理","children":[]},{"level":2,"title":"内存区域划分","slug":"内存区域划分","link":"#内存区域划分","children":[{"level":3,"title":"大致划分","slug":"大致划分","link":"#大致划分","children":[{"level":4,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":4,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[{"level":5,"title":"栈帧组成","slug":"栈帧组成","link":"#栈帧组成","children":[]},{"level":5,"title":"模拟分析","slug":"模拟分析","link":"#模拟分析","children":[]}]},{"level":4,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]}]}]}],"git":{"createdTime":1765127830000,"updatedTime":1765127830000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":6.75,"words":2024},"filePathRelative":"code/八股/JVM/article2.md","localizedDate":"2025年12月7日","excerpt":"<h2>JVM内存管理</h2>\\n<p>在传统的C/C++开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效</p>\\n<p>因此，内存管理是一个非常严肃的问题。</p>\\n<p>比如我们就可以通过C语言动态申请内存，并用于存放数据：</p>\\n<div class=\\"language-c\\" data-ext=\\"c\\" data-title=\\"c\\"><pre class=\\"language-c\\"><code><span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span> <span class=\\"token string\\">&lt;stdlib.h&gt;</span></span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span> <span class=\\"token string\\">&lt;stdio.h&gt;</span></span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//动态申请4个int大小的内存空间</span>\\n    <span class=\\"token keyword\\">int</span><span class=\\"token operator\\">*</span> memory <span class=\\"token operator\\">=</span> <span class=\\"token function\\">malloc</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">sizeof</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">*</span> <span class=\\"token number\\">4</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//修改第一个int空间的值</span>\\n    memory<span class=\\"token punctuation\\">[</span><span class=\\"token number\\">0</span><span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token number\\">10</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//修改第二个int空间的值</span>\\n    memory<span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token number\\">2</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//遍历内存区域中所有的值</span>\\n    <span class=\\"token keyword\\">for</span> <span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> i <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>i <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">4</span><span class=\\"token punctuation\\">;</span>i<span class=\\"token operator\\">++</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token function\\">printf</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"%d \\"</span><span class=\\"token punctuation\\">,</span> memory<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token comment\\">//释放指针所指向的内存区域</span>\\n    <span class=\\"token function\\">free</span><span class=\\"token punctuation\\">(</span>memory<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//最后将指针赋值为NULL</span>\\n    memory <span class=\\"token operator\\">=</span> <span class=\\"token constant\\">NULL</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}')}}]);