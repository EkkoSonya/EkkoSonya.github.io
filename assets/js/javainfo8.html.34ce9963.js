"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[1266],{83671:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,o]of t)a[e]=o;return a}},57968:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>i,data:()=>d});var o=a(7847);const c=a.p+"assets/img/12.23153b96.png",p=a.p+"assets/img/13.6b26eccd.png",n=[(0,o.Fv)('<h2 id="tomcat类加载机制" tabindex="-1"><a class="header-anchor" href="#tomcat类加载机制"><span>Tomcat类加载机制</span></a></h2><p>Tomcat到底是如何加载和运行我们的Web应用程序的。</p><p>Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离</p><p>也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问</p><p>而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。</p><figure><img src="'+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：</p><ul><li><p><code>Common ClassLoader</code>：Tomcat最基本的类加载器，该加载路径中的<code>class</code>可以被Tomcat容器本身以及各个Web应用程序访问。</p></li><li><p><code>Catalina ClassLoader</code>：Tomcat<strong>容器私有的类加载器</strong>，该加载路径中的class对于Web应用程序不可见。</p></li><li><p><code>Shared ClassLoader</code>：各个Web应用程序<strong>共享的类加载器</strong>，该加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。</p></li><li><p><code>Webapp ClassLoader</code>：各个Web应用程序私有的类加载器，该加载路径中的class只对<strong>当前Web应用程序可见</strong>，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。</p></li><li><p><code>JasperLoader</code>：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。</p></li></ul><p>通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的<code>双亲委派机制</code>（即每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。）</p><p>比如<code>Webapp ClassLoader</code>，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？</p><p>难道Tomcat的开发团队没有考虑到这个问题吗？</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>实际上，WebAppClassLoader的加载机制是这样的：</p><p><code>WebAppClassLoader</code> 加载类的时候，绕开了 <code>AppClassLoader</code>，直接先使用 <code>ExtClassLoader</code> 来加载类。</p><p>这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到<code>WebAppClassLoader</code>进行加载，如果还失败，再使用<code>AppClassloader</code>进行加载。</p>',15)],r={},i=(0,a(83671).A)(r,[["render",function(e,t){return(0,o.uX)(),(0,o.CE)("div",null,n)}]]),d=JSON.parse('{"path":"/code/javaweb/8-%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9/javainfo8.html","title":"Content - Tomact类加载机制","lang":"zh-CN","frontmatter":{"title":"Content - Tomact类加载机制","date":"2025-07-24T00:00:00.000Z","category":["code"],"tag":["javaweb"],"order":-0.746,"description":"Tomcat类加载机制 Tomcat到底是如何加载和运行我们的Web应用程序的。 Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离 也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问 而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/javaweb/8-%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9/javainfo8.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Content - Tomact类加载机制"}],["meta",{"property":"og:description","content":"Tomcat类加载机制 Tomcat到底是如何加载和运行我们的Web应用程序的。 Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离 也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问 而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-24T12:57:42.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"javaweb"}],["meta",{"property":"article:published_time","content":"2025-07-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-24T12:57:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Content - Tomact类加载机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-24T12:57:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"Tomcat类加载机制","slug":"tomcat类加载机制","link":"#tomcat类加载机制","children":[]}],"git":{"createdTime":1753361862000,"updatedTime":1753361862000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":2.72,"words":817},"filePathRelative":"code/javaweb/8-网络内容/javainfo8.md","localizedDate":"2025年7月24日","excerpt":"<h2>Tomcat类加载机制</h2>\\n<p>Tomcat到底是如何加载和运行我们的Web应用程序的。</p>\\n<p>Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离</p>\\n<p>也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问</p>\\n<p>而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。</p>\\n<figure><figcaption>img</figcaption></figure>","autoDesc":true}')}}]);