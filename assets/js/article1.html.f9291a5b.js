"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[7085],{83671:(n,e)=>{e.A=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},8963:(n,e,a)=>{n.exports=a.p+"assets/img/2.7205c9e9.png"},80612:(n,e,a)=>{a.r(e),a.d(e,{comp:()=>x,data:()=>f});var s=a(7847);const t=a.p+"assets/img/2.d95d4aa4.png",i=a.p+"assets/img/3.bd60b429.png",l=a.p+"assets/img/1.f96f1209.png",o=a.p+"assets/img/4.24a348e7.png",p=a.p+"assets/img/6.fe26854d.png",r=a.p+"assets/img/7.41450918.png",c=a.p+"assets/img/8.74c8be41.png",d=a.p+"assets/img/5.cc527826.png",u=(0,s.Fv)('<h2 id="苍穹外卖" tabindex="-1"><a class="header-anchor" href="#苍穹外卖"><span>苍穹外卖</span></a></h2><h3 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h3><h4 id="功能架构" tabindex="-1"><a class="header-anchor" href="#功能架构"><span>功能架构</span></a></h4><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="管理端功能" tabindex="-1"><a class="header-anchor" href="#管理端功能"><span>管理端功能</span></a></h5><p>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p><h5 id="用户端功能" tabindex="-1"><a class="header-anchor" href="#用户端功能"><span>用户端功能</span></a></h5><p>微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。</p><h4 id="整体结构" tabindex="-1"><a class="header-anchor" href="#整体结构"><span>整体结构</span></a></h4><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h4><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>(1). 用户层 本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI、apache echarts(展示图表)等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p>(2). 网关层 Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p>(3). 应用层 SpringBoot： 快速构建Spring项目, 采用 &quot;约定优于配置&quot; 的思想, 简化Spring项目的配置开发。 SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。 Spring Task: 由Spring提供的定时任务框架。 httpclient: 主要实现了对http请求的发送。 Spring Cache: 由Spring提供的数据缓存框架 JWT: 用于对应用程序上的用户进行身份验证的标记。 阿里云OSS: 对象存储服务，在项目中主要存储文件，如图片等。 Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。 POI: 封装了对Excel表格的常用操作。 WebSocket: 一种通信网络协议，使客户端和服务器之间的数据交换更加简单，用于项目的来单、催单功能实现。</p><p>(4). 数据层 MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。 Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存。 Mybatis： 本项目持久层将会使用Mybatis开发。 pagehelper: 分页插件。 spring data redis: 简化java代码操作Redis的API。</p><p>(5). 工具 git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。 maven: 项目构建工具。 junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。 postman: 接口测工具，模拟用户发起的各类HTTP请求，获取对应的响应结果。</p><h3 id="后端搭建" tabindex="-1"><a class="header-anchor" href="#后端搭建"><span>后端搭建</span></a></h3><h4 id="碰到问题" tabindex="-1"><a class="header-anchor" href="#碰到问题"><span>碰到问题</span></a></h4><p>找不到符号 (更该jdk版本23——&gt;17)</p><p>配置属性类</p><h4 id="项目结构" tabindex="-1"><a class="header-anchor" href="#项目结构"><span>项目结构</span></a></h4><p>基于maven进行项目构建，进行分模块开发</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="sky-common" tabindex="-1"><a class="header-anchor" href="#sky-common"><span>sky-common</span></a></h5><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="sky-pojo" tabindex="-1"><a class="header-anchor" href="#sky-pojo"><span>sky-pojo</span></a></h5><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="sky-server" tabindex="-1"><a class="header-anchor" href="#sky-server"><span>sky-server</span></a></h5><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="nginx反向代理和负载均衡" tabindex="-1"><a class="header-anchor" href="#nginx反向代理和负载均衡"><span>nginx反向代理和负载均衡</span></a></h4><figure><img src="'+d+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="_1-nginx反向代理" tabindex="-1"><a class="header-anchor" href="#_1-nginx反向代理"><span>1. nginx反向代理</span></a></h5><p>这种就是通过nginx来反向代理，将前端发送的动态请求由 nginx 转发到后端服务器，从而避免跨域等问题</p><p><strong>nginx 反向代理的好处：</strong></p><ul><li><p>提高访问速度</p><p>因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</p></li><li><p>进行负载均衡</p><p>所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</p></li><li><p>保证后端服务安全</p><p>因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。</p></li></ul><p><strong>nginx 反向代理的配置方式：</strong></p><div class="language-nginx line-numbers-mode" data-ext="nginx" data-title="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">server</span></span><span class="token punctuation">{</span>\n    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>\n    <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>\n    \n    <span class="token directive"><span class="token keyword">location</span> /api/</span><span class="token punctuation">{</span>\n        <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8080/admin/</span><span class="token punctuation">;</span> <span class="token comment">#反向代理</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>proxy_pass</strong>: 该指令是用来设置代理服务器的地址，可以是主机名称，IP地址加端口号等形式。</p>',39),m={href:"http://localhost:80/api/../..",target:"_blank",rel:"noopener noreferrer"},g={href:"http://localhost:8080/admin/",target:"_blank",rel:"noopener noreferrer"},h=(0,s.Fv)('<h5 id="_2-负载均衡" tabindex="-1"><a class="header-anchor" href="#_2-负载均衡"><span>2. 负载均衡</span></a></h5><p>当如果服务以集群的方式进行部署时，那nginx在转发请求到服务器时就需要做相应的负载均衡。其实，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p><p><strong>nginx 负载均衡的配置方式：</strong></p><div class="language-nginx line-numbers-mode" data-ext="nginx" data-title="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">upstream</span> webservers</span><span class="token punctuation">{</span>\n    <span class="token directive"><span class="token keyword">server</span> 192.168.100.128:8080</span><span class="token punctuation">;</span>\n    <span class="token directive"><span class="token keyword">server</span> 192.168.100.129:8080</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token directive"><span class="token keyword">server</span></span><span class="token punctuation">{</span>\n    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>\n    <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>\n    \n    <span class="token directive"><span class="token keyword">location</span> /api/</span><span class="token punctuation">{</span>\n        <span class="token directive"><span class="token keyword">proxy_pass</span> http://webservers/admin</span><span class="token punctuation">;</span><span class="token comment">#负载均衡</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>upstream</strong>: 如果代理服务器是一组服务器的话，我们可以使用upstream指令配置后端服务器组。</p>',5),v={href:"http://localhost:80/api/../..",target:"_blank",rel:"noopener noreferrer"},k={href:"http://webservers/admin",target:"_blank",rel:"noopener noreferrer"},b=(0,s.Fv)('<p>**注：**upstream后面的名称可自定义，但要上下保持一致。</p><p><strong>nginx 负载均衡策略：</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td></tr><tr><td>ip_hash</td><td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td></tr><tr><td>least_conn</td><td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td></tr><tr><td>url_hash</td><td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td></tr><tr><td>fair</td><td>依据响应时间方式，响应时间短的服务将会被优先分配</td></tr></tbody></table><h3 id="完善登录功能" tabindex="-1"><a class="header-anchor" href="#完善登录功能"><span>完善登录功能</span></a></h3><p><strong>问题</strong>：员工表中的密码是明文存储，安全性太低</p><p><strong>解决思路：</strong></p><ol><li>将密码加密后存储，提高安全性</li><li>使用MD5加密方式对明文密码加密</li></ol><p><strong>实现步骤：</strong></p><ol><li><p>修改数据库中明文密码，改为MD5加密后的密文</p></li><li><p>修改Java代码，前端提交的密码进行MD5加密后再跟数据库中密码比对</p><p>打开EmployeeServiceImpl.java，修改比对密码</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n     * 员工登录\n     *\n     * <span class="token keyword">@param</span> <span class="token parameter">employeeLoginDTO</span>\n     * <span class="token keyword">@return</span>\n     */</span>\n    <span class="token keyword">public</span> <span class="token class-name">Employee</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">EmployeeLoginDTO</span> employeeLoginDTO<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        <span class="token comment">//1、根据用户名查询数据库中的数据</span>\n       \n        <span class="token comment">//2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）</span>\n        <span class="token comment">//.......</span>\n        <span class="token comment">//密码比对</span>\n        <span class="token comment">// TODO 后期需要进行md5加密，然后再进行比对</span>\n        password <span class="token operator">=</span> <span class="token class-name">DigestUtils</span><span class="token punctuation">.</span><span class="token function">md5DigestAsHex</span><span class="token punctuation">(</span>password<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>password<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">//密码错误</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">PasswordErrorException</span><span class="token punctuation">(</span><span class="token class-name">MessageConstant</span><span class="token punctuation">.</span><span class="token constant">PASSWORD_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">//........</span>\n\n        <span class="token comment">//3、返回实体对象</span>\n        <span class="token keyword">return</span> employee<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>',9),y={},x=(0,a(83671).A)(y,[["render",function(n,e){const a=(0,s.g2)("ExternalLinkIcon");return(0,s.uX)(),(0,s.CE)("div",null,[u,(0,s.Lk)("p",null,[(0,s.eW)("如上代码的含义是：监听80端口号， 然后当我们访问 "),(0,s.Lk)("a",m,[(0,s.eW)("http://localhost:80/api/../.."),(0,s.bF)(a)]),(0,s.eW)(" 这样的接口的时候，它会通过 location /api/ {} 这样的反向代理到 "),(0,s.Lk)("a",g,[(0,s.eW)("http://localhost:8080/admin/"),(0,s.bF)(a)]),(0,s.eW)(" 上来。")]),h,(0,s.Lk)("p",null,[(0,s.eW)("如上代码的含义是：监听80端口号， 然后当我们访问 "),(0,s.Lk)("a",v,[(0,s.eW)("http://localhost:80/api/../.."),(0,s.bF)(a)]),(0,s.eW)(" 这样的接口的时候，它会通过 location /api/ {} 这样的反向代理到 "),(0,s.Lk)("a",k,[(0,s.eW)("http://webservers/admin"),(0,s.bF)(a)]),(0,s.eW)("，根据webservers名称找到一组服务器，根据设置的负载均衡策略(默认是轮询)转发到具体的服务器。")]),b])}]]),f=JSON.parse('{"path":"/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article1.html","title":"Javassm - item1-1 (项目介绍+环境搭建)","lang":"zh-CN","frontmatter":{"title":"Javassm - item1-1 (项目介绍+环境搭建)","date":"2025-10-17T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"苍穹外卖 介绍 功能架构 alt textalt text 管理端功能 员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。 用户端功能 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。 整体结构 al...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article1.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Javassm - item1-1 (项目介绍+环境搭建)"}],["meta",{"property":"og:description","content":"苍穹外卖 介绍 功能架构 alt textalt text 管理端功能 员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。 用户端功能 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。 整体结构 al..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-16T17:59:51.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-10-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-16T17:59:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Javassm - item1-1 (项目介绍+环境搭建)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-16T17:59:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"苍穹外卖","slug":"苍穹外卖","link":"#苍穹外卖","children":[{"level":3,"title":"介绍","slug":"介绍","link":"#介绍","children":[{"level":4,"title":"功能架构","slug":"功能架构","link":"#功能架构","children":[{"level":5,"title":"管理端功能","slug":"管理端功能","link":"#管理端功能","children":[]},{"level":5,"title":"用户端功能","slug":"用户端功能","link":"#用户端功能","children":[]}]},{"level":4,"title":"整体结构","slug":"整体结构","link":"#整体结构","children":[]},{"level":4,"title":"技术选型","slug":"技术选型","link":"#技术选型","children":[]}]},{"level":3,"title":"后端搭建","slug":"后端搭建","link":"#后端搭建","children":[{"level":4,"title":"碰到问题","slug":"碰到问题","link":"#碰到问题","children":[]},{"level":4,"title":"项目结构","slug":"项目结构","link":"#项目结构","children":[{"level":5,"title":"sky-common","slug":"sky-common","link":"#sky-common","children":[]},{"level":5,"title":"sky-pojo","slug":"sky-pojo","link":"#sky-pojo","children":[]},{"level":5,"title":"sky-server","slug":"sky-server","link":"#sky-server","children":[]}]},{"level":4,"title":"nginx反向代理和负载均衡","slug":"nginx反向代理和负载均衡","link":"#nginx反向代理和负载均衡","children":[{"level":5,"title":"1. nginx反向代理","slug":"_1-nginx反向代理","link":"#_1-nginx反向代理","children":[]},{"level":5,"title":"2. 负载均衡","slug":"_2-负载均衡","link":"#_2-负载均衡","children":[]}]}]},{"level":3,"title":"完善登录功能","slug":"完善登录功能","link":"#完善登录功能","children":[]}]}],"git":{"createdTime":1760637591000,"updatedTime":1760637591000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":5.82,"words":1747},"filePathRelative":"code/java_item/1-苍穹外卖/article1.md","localizedDate":"2025年10月17日","excerpt":"<h2>苍穹外卖</h2>\\n<h3>介绍</h3>\\n<h4>功能架构</h4>\\n<figure><figcaption>alt text</figcaption></figure>\\n<h5>管理端功能</h5>\\n<p>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p>\\n<h5>用户端功能</h5>\\n<p>微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。</p>\\n<h4>整体结构</h4>\\n<figure><figcaption>alt text</figcaption></figure>","autoDesc":true}')},88039:(n,e,a)=>{a.r(e),a.d(e,{comp:()=>o,data:()=>p});var s=a(7847);const t=a.p+"assets/img/1.f6501f03.png",i=[(0,s.Fv)('<p>主要是来学习 Redis 的应用</p><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h2><ul><li><p>短信登录</p><p>这一块我们会使用redis共享session来实现</p></li><li><p>商户查询缓存</p><p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p></li><li><p>优惠卷秒杀</p><p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p></li><li><p>附近的商户</p><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p></li><li><p>UV统计</p><p>主要是使用Redis来完成统计功能</p></li><li><p>用户签到</p><p>使用Redis的BitMap数据统计功能</p></li><li><p>好友关注</p><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p></li><li><p>达人探店</p><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p></li></ul><h2 id="导入项目" tabindex="-1"><a class="header-anchor" href="#导入项目"><span>导入项目</span></a></h2><p><strong>SQL表</strong></p><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>导入后端项目</strong></p><p><strong>导入前端项目</strong></p>',8)],l={},o=(0,a(83671).A)(l,[["render",function(n,e){return(0,s.uX)(),(0,s.CE)("div",null,i)}]]),p=JSON.parse('{"path":"/code/java_item/2-hmdp/article1.html","title":"item2-1 (项目介绍+环境搭建)","lang":"zh-CN","frontmatter":{"title":"item2-1 (项目介绍+环境搭建)","date":"2025-11-25T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"主要是来学习 Redis 的应用 目标 短信登录 这一块我们会使用redis共享session来实现 商户查询缓存 通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容 优惠卷秒杀 通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/2-hmdp/article1.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"item2-1 (项目介绍+环境搭建)"}],["meta",{"property":"og:description","content":"主要是来学习 Redis 的应用 目标 短信登录 这一块我们会使用redis共享session来实现 商户查询缓存 通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容 优惠卷秒杀 通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-01T11:24:28.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-01T11:24:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"item2-1 (项目介绍+环境搭建)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-01T11:24:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":2,"title":"导入项目","slug":"导入项目","link":"#导入项目","children":[]}],"git":{"createdTime":1764588268000,"updatedTime":1764588268000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":1.13,"words":340},"filePathRelative":"code/java_item/2-hmdp/article1.md","localizedDate":"2025年11月25日","excerpt":"<p>主要是来学习 Redis 的应用</p>\\n<h2>目标</h2>\\n<ul>\\n<li>\\n<p>短信登录</p>\\n<p>这一块我们会使用redis共享session来实现</p>\\n</li>\\n<li>\\n<p>商户查询缓存</p>\\n<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>\\n</li>\\n<li>\\n<p>优惠卷秒杀</p>\\n<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>\\n</li>\\n<li>\\n<p>附近的商户</p>\\n<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>\\n</li>\\n<li>\\n<p>UV统计</p>\\n<p>主要是使用Redis来完成统计功能</p>\\n</li>\\n<li>\\n<p>用户签到</p>\\n<p>使用Redis的BitMap数据统计功能</p>\\n</li>\\n<li>\\n<p>好友关注</p>\\n<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>\\n</li>\\n<li>\\n<p>达人探店</p>\\n<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>\\n</li>\\n</ul>","autoDesc":true}')},12800:(n,e,a)=>{a.r(e),a.d(e,{comp:()=>l,data:()=>o});var s=a(7847);const t=[(0,s.Fv)('<h2 id="启动项目" tabindex="-1"><a class="header-anchor" href="#启动项目"><span>启动项目</span></a></h2><p>注意点:</p><h3 id="docker配置问题" tabindex="-1"><a class="header-anchor" href="#docker配置问题"><span>docker配置问题</span></a></h3><p>如果启动后想改 mysql 密码，再去 <code>docker-compose.yaml</code>修改，是无效的</p><blockquote><p>你挂载了 <code>mysql-data:/var/lib/mysql</code>，而这个数据卷里已经存在旧的 MySQL 初始化数据 MySQL 只在“第一次初始化数据目录”时读取 MYSQL_ROOT_PASSWORD 后续再改环境变量，完全不会生效</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 停容器</span>\ndocker compose down\n\n<span class="token comment">// 删除数据卷（关键）</span>\ndocker volume rm pai_smart_mysql<span class="token operator">-</span>data\n\n<span class="token comment">// 注意：</span>\n<span class="token comment">// pai_smart_mysql-data = 项目名_卷名</span>\n\n<span class="token comment">// 重新启动</span>\ndocker compose up <span class="token operator">-</span>d\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一次：</p><p>MySQL 会重新初始化 MYSQL_ROOT_PASSWORD=123456 会生效 root 可直接登录</p><p>凡是和「安全、密码、集群元数据、系统索引」有关的配置：</p><p>一旦 data volume 已初始化，再改 environment = 不生效</p><h3 id="application读取问题" tabindex="-1"><a class="header-anchor" href="#application读取问题"><span>application读取问题</span></a></h3><p>Spring Boot 是通过 spring.profiles.active 决定用 application.yaml + 哪个 application-xxx.yaml 的</p><p>IDEA 里本质就是：启动时传不同的 profile 参数</p><p>假设你现在有：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>application.yaml\napplication-docker.yaml\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>加载规则是：</p><p>永远加载 <code>application.yaml</code></p><p>再加载：<code>application-${spring.profiles.active}.yaml</code></p><p>后加载的会覆盖前面的</p>',19)],i={},l=(0,a(83671).A)(i,[["render",function(n,e){return(0,s.uX)(),(0,s.CE)("div",null,t)}]]),o=JSON.parse('{"path":"/code/java_item/3-smart/article1.html","title":"item3-1","lang":"zh-CN","frontmatter":{"title":"item3-1","date":"2025-12-15T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"启动项目 注意点: docker配置问题 如果启动后想改 mysql 密码，再去 docker-compose.yaml修改，是无效的 你挂载了 mysql-data:/var/lib/mysql，而这个数据卷里已经存在旧的 MySQL 初始化数据 MySQL 只在“第一次初始化数据目录”时读取 MYSQL_ROOT_PASSWORD 后续再改环境变量...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/3-smart/article1.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"item3-1"}],["meta",{"property":"og:description","content":"启动项目 注意点: docker配置问题 如果启动后想改 mysql 密码，再去 docker-compose.yaml修改，是无效的 你挂载了 mysql-data:/var/lib/mysql，而这个数据卷里已经存在旧的 MySQL 初始化数据 MySQL 只在“第一次初始化数据目录”时读取 MYSQL_ROOT_PASSWORD 后续再改环境变量..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-26T17:10:55.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-12-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-26T17:10:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"item3-1\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-26T17:10:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"启动项目","slug":"启动项目","link":"#启动项目","children":[{"level":3,"title":"docker配置问题","slug":"docker配置问题","link":"#docker配置问题","children":[]},{"level":3,"title":"application读取问题","slug":"application读取问题","link":"#application读取问题","children":[]}]}],"git":{"createdTime":1766769055000,"updatedTime":1766769055000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":0.92,"words":275},"filePathRelative":"code/java_item/3-smart/article1.md","localizedDate":"2025年12月15日","excerpt":"<h2>启动项目</h2>\\n<p>注意点:</p>\\n<h3>docker配置问题</h3>\\n<p>如果启动后想改 mysql 密码，再去 <code>docker-compose.yaml</code>修改，是无效的</p>\\n<blockquote>\\n<p>你挂载了 <code>mysql-data:/var/lib/mysql</code>，而这个数据卷里已经存在旧的 MySQL 初始化数据\\nMySQL 只在“第一次初始化数据目录”时读取 MYSQL_ROOT_PASSWORD 后续再改环境变量，完全不会生效</p>\\n</blockquote>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token comment\\">// 停容器</span>\\ndocker compose down\\n\\n<span class=\\"token comment\\">// 删除数据卷（关键）</span>\\ndocker volume rm pai_smart_mysql<span class=\\"token operator\\">-</span>data\\n\\n<span class=\\"token comment\\">// 注意：</span>\\n<span class=\\"token comment\\">// pai_smart_mysql-data = 项目名_卷名</span>\\n\\n<span class=\\"token comment\\">// 重新启动</span>\\ndocker compose up <span class=\\"token operator\\">-</span>d\\n</code></pre></div>","autoDesc":true}')},58507:(n,e,a)=>{a.r(e),a.d(e,{comp:()=>p,data:()=>r});var s=a(7847);const t=a.p+"assets/img/1.3c100ada.png";var i=a(8963);const l=[(0,s.Fv)('<h2 id="juc1" tabindex="-1"><a class="header-anchor" href="#juc1"><span>JUC1</span></a></h2><h3 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程"><span>进程与线程</span></a></h3><h3 id="并发与并行" tabindex="-1"><a class="header-anchor" href="#并发与并行"><span>并发与并行</span></a></h3><h4 id="顺序执行" tabindex="-1"><a class="header-anchor" href="#顺序执行"><span>顺序执行</span></a></h4><p>顺序执行其实很好理解，就是我们依次去将这些任务完成了</p><h4 id="并发执行" tabindex="-1"><a class="header-anchor" href="#并发执行"><span>并发执行</span></a></h4><p>并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转）</p><p>只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。</p><p>而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU的数量是不可能赶得上我们的线程数的，所以说这时就要求我们的程序有良好的并发性能，来应对同一时间大量的任务处理。学习Java并发编程，能够让我们在以后的实际场景中，知道该如何应对高并发的情况</p><h4 id="并行执行" tabindex="-1"><a class="header-anchor" href="#并行执行"><span>并行执行</span></a></h4><p>并行执行就突破了同一时间只能处理一个任务的限制，我们同一时间可以做多个任务</p><p>比如我们要进行一些排序操作，就可以用到并行计算，只需要等待所有子任务完成，最后将结果汇总即可。包括分布式计算模型MapReduce，也是采用的并行计算思路</p><h3 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制"><span>锁机制</span></a></h3><p>通过 <code>synchronized</code> 关键字，可以实现加锁功能，这样就能够很好地解决线程之间争抢资源的情况</p><p>使用 <code>synchronized</code>，一定是和某个对象相关联的，比如我们要对某一段代码加锁，那么我们就需要提供一个对象来作为锁本身：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">//这里使用的是Main类的Class对象作为锁</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的字节码为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token number">0</span> ldc #<span class="token number">7</span> <span class="token operator">&lt;</span>com<span class="token operator">/</span>ekko<span class="token operator">/</span><span class="token class-name">Main</span><span class="token operator">&gt;</span>\n <span class="token number">2</span> dup\n <span class="token number">3</span> astore_1\n <span class="token number">4</span> monitorenter\n <span class="token number">5</span> aload_1\n <span class="token number">6</span> monitorexit\n <span class="token number">7</span> <span class="token keyword">goto</span> <span class="token number">15</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span>\n<span class="token number">10</span> astore_2\n<span class="token number">11</span> aload_1\n<span class="token number">12</span> monitorexit\n<span class="token number">13</span> aload_2\n<span class="token number">14</span> athrow\n<span class="token number">15</span> <span class="token keyword">return</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-准备锁对象" tabindex="-1"><a class="header-anchor" href="#_1-准备锁对象"><span>1. 准备锁对象</span></a></h4><ul><li><p><code>0: ldc #7 &lt;com/ekko/Main&gt;</code></p><ul><li><strong>动作</strong>：从常量池加载 <code>com.ekko.Main</code> 的类对象（Class Object）</li><li><strong>栈</strong>：<code>[ ClassRef ]</code></li><li><strong>说明</strong>：我们要对这个类对象加锁</li></ul></li><li><p><code>2: dup</code></p><ul><li><strong>动作</strong>：复印栈顶的 Class 引用</li><li><strong>栈</strong>：<code>[ ClassRef, ClassRef ]</code></li><li>一份引用要马上被 <code>monitorenter</code> 吃掉用来加锁。</li><li>另一份引用必须保存起来（存入局部变量），以备将来 <strong>解锁（monitorexit）</strong> 时使用</li></ul></li></ul><h4 id="_2-加锁并执行" tabindex="-1"><a class="header-anchor" href="#_2-加锁并执行"><span>2. 加锁并执行</span></a></h4><p>每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）</p><ul><li><p><code>3: astore_1</code></p><ul><li><strong>动作</strong>：把栈顶的一份引用弹出，存入局部变量表 Slot 1</li><li><strong>栈</strong>：<code>[ ClassRef ]</code></li><li><strong>说明</strong>：Slot 1 里的这个变量就是我们备份的“锁对象”</li></ul></li><li><p><code>4: monitorenter</code></p><ul><li><strong>动作</strong>：弹出栈顶剩下的那个 Class 引用，尝试获取它的 Monitor 锁</li><li><strong>栈</strong>：<code>[ ]</code></li><li><strong>说明</strong>：代码执行到这，线程就持有了锁</li></ul></li><li><p><strong><code>5: aload_1</code></strong></p><ul><li><strong>动作</strong>：从 Slot 1 把刚才备份的 Class 引用拿出来，压入栈顶</li><li><strong>栈</strong>：<code>[ ClassRef ]</code></li><li><strong>说明</strong>：因为同步块里是空的，没有任何业务逻辑，所以直接准备解锁了。为了解锁，必须先把锁对象拿回栈上</li></ul></li><li><p><strong><code>6: monitorexit</code></strong></p><ul><li><strong>动作</strong>：弹出栈顶引用，释放锁。</li><li><strong>栈</strong>：<code>[ ]</code></li><li><strong>说明</strong>：正常执行结束，释放锁。</li></ul></li><li><p><strong><code>7: goto 15</code></strong></p><ul><li><strong>动作</strong>：跳到第 15 行（return），结束方法。</li></ul></li></ul><h4 id="_3-捕获异常" tabindex="-1"><a class="header-anchor" href="#_3-捕获异常"><span>3. 捕获异常</span></a></h4><p>在 10 - 14 行是编译器自动生成的<strong>异常处理逻辑</strong></p><p>JVM 必须保证：<strong>即使同步块里抛出了异常，锁也必须被释放，否则会造成死锁</strong></p><ul><li><p><code>10: astore_2</code></p><ul><li><strong>触发场景</strong>：如果在第 4 行 (<code>monitorenter</code>) 到第 6 行 (<code>monitorexit</code>) 之间发生了异常，程序会跳到这里（通过异常表跳转）</li><li><strong>动作</strong>：把捕获到的<strong>异常对象</strong>保存到 Slot 2</li></ul></li><li><p><code>11: aload_1</code></p><ul><li><strong>动作</strong>：赶紧把 Slot 1 里备份的锁对象拿出来。</li><li><strong>说明</strong>：这时候你就明白为什么最开始需要 <code>dup</code> 和 <code>astore_1</code> 了吧？就是为了这种危急时刻能找到锁对象</li></ul></li><li><p><code>12: monitorexit</code></p><ul><li><strong>动作</strong>：释放锁。</li><li><strong>说明</strong>：确保锁被释放</li></ul></li><li><p><code>13: aload_2</code></p><ul><li><strong>动作</strong>：把刚才存起来的异常对象拿回栈顶</li></ul></li><li><p><code>14: athrow</code></p><ul><li><strong>动作</strong>：把异常重新抛出去，让外层代码处理</li></ul></li></ul><figure><img src="'+t+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头"><span>对象头</span></a></h4><p>对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放hashCode和对象的锁信息，在不同状态下，它存储的数据结构有一些不同</p><h5 id="对象头的组成结构" tabindex="-1"><a class="header-anchor" href="#对象头的组成结构"><span>对象头的组成结构</span></a></h5><p>在 64 位 JVM（开启指针压缩）中，普通对象的对象头通常占用 <strong>12 字节</strong>。它主要包含三个部分（如果是数组则是三个）：</p><table><thead><tr><th><strong>组成部分</strong></th><th><strong>英文名称</strong></th><th><strong>大小 (64位 JVM)</strong></th><th><strong>作用描述</strong></th></tr></thead><tbody><tr><td><strong>标记字段</strong></td><td><strong>Mark Word</strong></td><td>8 字节 (64 bit)</td><td><strong>核心</strong> 存储对象的运行时数据：哈希码、GC分代年龄、锁状态标志等。</td></tr><tr><td><strong>类型指针</strong></td><td><strong>Klass Pointer</strong></td><td>4 字节 (开启压缩)</td><td>指向方法区中该类的元数据（Class 对象），JVM 通过它知道“我是谁”。</td></tr><tr><td><strong>数组长度</strong></td><td><strong>Array Length</strong></td><td>4 字节</td><td><strong>仅数组对象才有</strong> 记录数组的长度</td></tr></tbody></table><h5 id="mark-word" tabindex="-1"><a class="header-anchor" href="#mark-word"><span>Mark Word</span></a></h5><p>这是对象头里最复杂、最动态的部分</p><p>为了节省内存，Mark Word 的格式是不固定的，它会随着对象状态的变化而“复用”这 64 个 bit</p><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>它主要记录以下几类信息：</p><ul><li><p>锁状态：你刚才问的 synchronized，锁到底存在哪？就存在这里</p></li><li><p>GC 信息：对象活了多久（年龄）</p></li><li><p>身份信息：对象的 HashCode</p></li></ul><table><thead><tr><th><strong>锁状态</strong></th><th><strong>存储内容</strong></th><th><strong>锁标志位 (最后2bit)</strong></th></tr></thead><tbody><tr><td><strong>无锁 (Normal)</strong></td><td><code>Unused</code> (25bit) + <code>HashCode</code> (31bit) + <code>GC年龄</code> (4bit)</td><td><code>01</code></td></tr><tr><td><strong>偏向锁 (Biased)</strong></td><td><code>Thread ID</code> (线程ID) + <code>Epoch</code> + <code>GC年龄</code> (4bit)</td><td><code>01</code> (偏向位 1)</td></tr><tr><td><strong>轻量级锁 (Lightweight)</strong></td><td>指向栈中<strong>锁记录 (Lock Record)</strong> 的指针</td><td><code>00</code></td></tr><tr><td><strong>重量级锁 (Heavyweight)</strong></td><td>指向堆中 <strong>Monitor (互斥量)</strong> 的指针</td><td><code>10</code></td></tr><tr><td><strong>GC 标记</strong></td><td>空</td><td><code>11</code></td></tr></tbody></table><h5 id="内存示例" tabindex="-1"><a class="header-anchor" href="#内存示例"><span>内存示例</span></a></h5><p>假设你写了一个简单的类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> hp<span class="token punctuation">;</span> <span class="token comment">// 4 bytes</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">Hero</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个对象 h 在内存里长这样（开启指针压缩）：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>|----------------------------------------------------------|\n|                     Object Header (12 Bytes)             |\n|----------------------------------------------------------|\n|  Mark Word (8 Bytes)   |  Klass Pointer (4 Bytes)        |\n|  (锁/Hash/Age)         |  (指向 Hero.class)               |\n|----------------------------------------------------------|\n|                     Instance Data (4 Bytes)              |\n|----------------------------------------------------------|\n|  int hp (4 Bytes)                                        |\n|----------------------------------------------------------|\n|                     Padding (对齐填充)                    |\n|----------------------------------------------------------|\n|  JVM 要求对象大小必须是 8 的倍数。                        |\n|  12 + 4 = 16，正好是 8 的倍数，所以这里不需要 Padding。      |\n|----------------------------------------------------------|\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',45)],o={},p=(0,a(83671).A)(o,[["render",function(n,e){return(0,s.uX)(),(0,s.CE)("div",null,l)}]]),r=JSON.parse('{"path":"/code/%E5%85%AB%E8%82%A1/JUC/article1.html","title":"JUC1 - 基本介绍1","lang":"zh-CN","frontmatter":{"title":"JUC1 - 基本介绍1","date":"2025-12-26T00:00:00.000Z","category":["code"],"tag":["java","juc"],"order":-0.5,"description":"JUC1 进程与线程 并发与并行 顺序执行 顺序执行其实很好理解，就是我们依次去将这些任务完成了 并发执行 并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转） 只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。 而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/%E5%85%AB%E8%82%A1/JUC/article1.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"JUC1 - 基本介绍1"}],["meta",{"property":"og:description","content":"JUC1 进程与线程 并发与并行 顺序执行 顺序执行其实很好理解，就是我们依次去将这些任务完成了 并发执行 并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转） 只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。 而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-26T17:10:55.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"juc"}],["meta",{"property":"article:published_time","content":"2025-12-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-26T17:10:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC1 - 基本介绍1\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-26T17:10:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"JUC1","slug":"juc1","link":"#juc1","children":[{"level":3,"title":"进程与线程","slug":"进程与线程","link":"#进程与线程","children":[]},{"level":3,"title":"并发与并行","slug":"并发与并行","link":"#并发与并行","children":[{"level":4,"title":"顺序执行","slug":"顺序执行","link":"#顺序执行","children":[]},{"level":4,"title":"并发执行","slug":"并发执行","link":"#并发执行","children":[]},{"level":4,"title":"并行执行","slug":"并行执行","link":"#并行执行","children":[]}]},{"level":3,"title":"锁机制","slug":"锁机制","link":"#锁机制","children":[{"level":4,"title":"1. 准备锁对象","slug":"_1-准备锁对象","link":"#_1-准备锁对象","children":[]},{"level":4,"title":"2. 加锁并执行","slug":"_2-加锁并执行","link":"#_2-加锁并执行","children":[]},{"level":4,"title":"3. 捕获异常","slug":"_3-捕获异常","link":"#_3-捕获异常","children":[]},{"level":4,"title":"对象头","slug":"对象头","link":"#对象头","children":[{"level":5,"title":"对象头的组成结构","slug":"对象头的组成结构","link":"#对象头的组成结构","children":[]},{"level":5,"title":"Mark Word","slug":"mark-word","link":"#mark-word","children":[]},{"level":5,"title":"内存示例","slug":"内存示例","link":"#内存示例","children":[]}]}]}]}],"git":{"createdTime":1766769055000,"updatedTime":1766769055000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":5.46,"words":1638},"filePathRelative":"code/八股/JUC/article1.md","localizedDate":"2025年12月26日","excerpt":"<h2>JUC1</h2>\\n<h3>进程与线程</h3>\\n<h3>并发与并行</h3>\\n<h4>顺序执行</h4>\\n<p>顺序执行其实很好理解，就是我们依次去将这些任务完成了</p>\\n<h4>并发执行</h4>\\n<p>并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转）</p>\\n<p>只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。</p>\\n<p>而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU的数量是不可能赶得上我们的线程数的，所以说这时就要求我们的程序有良好的并发性能，来应对同一时间大量的任务处理。学习Java并发编程，能够让我们在以后的实际场景中，知道该如何应对高并发的情况</p>","autoDesc":true}')}}]);