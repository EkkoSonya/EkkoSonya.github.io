<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="http://ekkosonya.cn/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="http://ekkosonya.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>EkkoSonya&amp;apos;s Blog</title>
    <link>http://ekkosonya.cn/</link>
    <description>笔记记录</description>
    <language>zh-CN</language>
    <pubDate>Wed, 06 Aug 2025 16:08:57 GMT</pubDate>
    <lastBuildDate>Wed, 06 Aug 2025 16:08:57 GMT</lastBuildDate>
    <generator>@vuepress/plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>code</category>
    <item>
      <title>Javassm - Spring1</title>
      <link>http://ekkosonya.cn/code/java_ssm/Spring/spring1.html</link>
      <guid>http://ekkosonya.cn/code/java_ssm/Spring/spring1.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Javassm - Spring1</source>
      <description>SSM（Spring+SpringMVC+Mybatis） Spring 简介 Spring是一个框架(文档：https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core) 它是为了简化开发而生，它是轻量级的IoC和AOP的容器框架，主要...</description>
      <category>code</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>SSM（Spring+SpringMVC+Mybatis）</p>
<h2>Spring 简介</h2>
<p>Spring是一个框架(文档：<a href="https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core</a>)</p>
<p>它是为了简化开发而生，它是轻量级的<strong>IoC</strong>和<strong>AOP</strong>的容器框架，主要是针对<strong>Bean</strong>的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。</p>
<h2>IoC理论基础 1</h2>
<p>Spring框架最核心的其实它的IoC容器</p>
<h3>IoC理论介绍</h3>
<p>IOC是Inversion of Control的缩写，翻译为：“控制反转”</p>
<p>把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<h4>以前耦合情况</h4>
<p>在我们之前的图书管理系统Web应用程序中，我们发现，整个程序其实是依靠各个部分相互协作，共同完成一个操作</p>
<p>比如要展示借阅信息列表，那么首先需要使用Servlet进行请求和响应的数据处理，然后请求的数据全部交给对应的Service（业务层）来处理，当Service发现要从数据库中获取数据时，再向对应的Mapper发起请求。</p>
<p>它们之间就像连接在一起的齿轮：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>就像一个团队，每个人的分工都很明确，流水线上的一套操作必须环环相扣，这是一种<strong>高度耦合</strong>的体系。</p>
<p>但是这样存在一个很严重的问题，很容易出现，之前写好的代码，实现的功能，需要全部推翻，改成新的功能，那么我们就不得不去修改某些流水线上的模块，但是这样一修改，会直接导致整个流水线的引用关系大面积更新。</p>
<p>比如下面的情况：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，A和C在大量地直接使用B，但是某一天，这个B的实现已经过时了，此时来了个把功能实现的更好的D，我们需要用这个新的类来完成业务了：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>可以看到，因为类之间的关联性太强了，会开始大面积报错，所有之前用了B的类，得挨个进行修改，全都改成D.</p>
<p>因此，高耦合度带来的缺点是很明显的，也是现代软件开发中很致命的问题。</p>
<p>如果要改善这种情况，我们只能将各个模块进行解耦，让各个模块之间的依赖性不再那么地强。</p>
<p>也就是说，Service的实现类，不再由我们决定，而是让程序自己决定，所有的实现类对象，全部交给程序来管理，所有对象之间的关系，也由程序来动态决定，这样就引入了IoC理论。</p>
<h4>IoC理论</h4>
<figure><figcaption>alt text</figcaption></figure>
<p>我们可以将对象交给<strong>IoC容器进行管理</strong>，比如当我们需要一个接口的实现时，由它根据<strong>配置文件来决定到底给我们哪一个实现类</strong>，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码。</p>
<p>还是之前的代码，但是有了IoC容器加持之后：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">IoC</span><span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token comment">//瞎编的一个容器类，但是是那个意思，即根据所给的接口确定类</span>
    <span class="token comment">//比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Service</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>   
    <span class="token comment">//一律使用Service，具体实现由IoC容器提供</span>
    <span class="token keyword">public</span> <span class="token class-name">Service</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Service</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Service</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>   
<span class="token comment">//使用Service做一个顶层抽象</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  
<span class="token comment">//B依然是具体实现类，并交给IoC容器管理</span>
</code></pre></div><p>当具体实现类发生修改时，我们同样只需要将新的实现类交给IoC容器管理，这样我们无需修改之前的任何代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Service</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   
<span class="token comment">//现在实现类变成了D，但是之前的代码并不会报错</span>
</code></pre></div><p>这样，即使我们的底层实现类发生了修改，也不会导致与其相关联的类出现错误，而进行大面积修改，通过定义抽象+容器管理的形式，我们就可以将原有的强关联解除。</p>
<p>高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，一个由Spring IoC容器实例化、组装和管理的对象，我们称其为<code>Bean</code>。</p>
<h3>第一个Spring项目</h3>
<p>首先一定要明确，使用Spring首要目的是为了使得软件项目进行解耦，而不是为了去简化代码。</p>
<p>Spring并不是一个独立的框架，它实际上包含了很多的模块：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>而我们首先要去学习的就是<code>Core Container</code>，也就是核心容器模块，只有了解了Spring的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。</p>
<p>Spring是一个<strong>非入侵式</strong>的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring核心框架的Maven依赖坐标：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>6.0.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>注意：</strong> 与旧版教程不同的是，Spring 6要求你使用的Java版本为<code>17</code>及以上，包括后面我们在学习SpringMvc时，要求Tomcat版本必须为10以上。</p>
<p>这个依赖中包含了如下依赖：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>这里出现的都是Spring核心相关的内容，如Beans、Core、Context、SpEL以及非常关键的AOP框架</p>
<h4>使用 <code>bean</code></h4>
<p>Spring会给我们提供IoC容器用于管理Bean，但是我们得先为这个容器编写一个配置文件，我们可以通过配置文件告诉容器需要管理哪些Bean以及Bean的属性、依赖关系等等。</p>
<p>首先我们需要在resource中创建一个Spring配置文件（在resource中创建的文件，会在编译时被一起放到类路径下），命名为test.xml，直接右键点击即可创建：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>Spring为我们提供了一个IoC容器，用于去存放我们需要使用的对象，我们可以将对象交给IoC容器进行管理，当我们需要使用对象时，就可以向IoC容器去索要，并由它来决定给我们哪一个对象。</p>
<p>而我们如果需要使用Spring为我们提供的IoC容器，那么就需要创建一个应用程序上下文，它代表的就是IoC容器，它会负责实例化、配置和组装Bean：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种</span>
    <span class="token comment">//因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类</span>
    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这里写上刚刚的名字</span>
<span class="token punctuation">}</span>
</code></pre></div><p>比如现在我们要让IoC容器帮助我们管理一个Student对象（Bean），当我们需要这个对象时再申请，那么就需要这样，首先先将Student类定义出来：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>bean</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>既然现在要让别人帮忙管理对象，那么就不能再由我们自己去new这个对象了，而是编写对应的配置，我们打开刚刚创建的<code>test.xml</code>文件进行编辑，添加：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">&lt;</span>bean name<span class="token operator">=</span><span class="token string">"student"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.test.bean.Student"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>这里我们就在配置文件中编写好了对应Bean的信息，之后容器就会根据这里的配置进行处理了。</p>
<p>现在，这个对象不需要我们再去创建了，而是由IoC容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//使用getBean方法来获取对应的对象（Bean）</span>
    student<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同理，我们也可以实现前面IoC提到的例子：</p>
<p>此时有 接口<code>Serivce</code> 和 对应实现类 <code>Aservice</code></p>
<figure><figcaption>alt text</figcaption></figure>
<p>此时我们去配置文件注册好对应的<code>Aservice</code>的<code>bean</code></p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.service.Aservice<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>然后，我们在项目里使用<code>Service</code>来创建对象，向容器找到对应实现的类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"application.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Service</span> service <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样最终实现的类就是对应的 <code>Aservice</code></p>
<figure><figcaption>alt text</figcaption></figure>
<p>所以，当<code>Aservice</code>被更新了，变成<code>Bservice</code>，将对应的配置文件修改就行，它会自动找到对应接口是否存在<code>bean</code>的实现类。</p>
<p>如果有多个的话，这样是会报错的，后续应该有解决方案。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread <span class="token string">"main"</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>NoUniqueBeanDefinitionException</span><span class="token operator">:</span> 
  <span class="token class-name">No</span> qualifying bean of type '<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>Service</span>' available<span class="token operator">:</span> 
  expected single matching bean but found <span class="token number">2</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>Aservice</span>#<span class="token number">0</span><span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>Bservice</span>#<span class="token number">0</span>
</code></pre></div><p>实际上，这里得到的Student对象是由Spring通过反射机制帮助我们创建的</p>
<figure><figcaption>alt text</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>Javassm - Spring2 (Bean注册与配置 + 依赖注入)</title>
      <link>http://ekkosonya.cn/code/java_ssm/Spring/spring2.html</link>
      <guid>http://ekkosonya.cn/code/java_ssm/Spring/spring2.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Javassm - Spring2 (Bean注册与配置 + 依赖注入)</source>
      <description>IoC理论基础 2 Bean注册与配置 详细了解一下如何向Spring注册Bean以及Bean的相关配置。 实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的： 但是为了简单起见，我们还是从单配置文件开始讲起 配置并注册Bean 首先我们需要知道如何配置Bean并注册。 要配置一个Bean，只需要添加： 但是这样写的话，Spring无法...</description>
      <category>code</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>IoC理论基础 2</h2>
<h3>Bean注册与配置</h3>
<p>详细了解一下如何向<code>Spring</code>注册<code>Bean</code>以及<code>Bean</code>的相关配置。</p>
<p>实际上我们的配置文件<strong>可以有很多个</strong>，并且这些配置文件是可以相互导入的：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">...</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>但是为了简单起见，我们还是从<strong>单配置文件</strong>开始讲起</p>
<h4>配置并注册<code>Bean</code></h4>
<p>首先我们需要知道如何配置Bean并注册。</p>
<p>要配置一个Bean，只需要添加：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>但是这样写的话，Spring无法得知我们要配置的Bean到底是哪一个类，所以说我们还得指定对应的类才可以：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><figure><figcaption>alt text</figcaption></figure>
<p>可以看到类的旁边出现了Bean的图标，表示我们的Bean已经注册成功了，这样，我们就可以根据类型向容器索要Bean实例对象了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//getBean有多种形式，其中第一种就是根据类型获取对应的Bean</span>
    <span class="token comment">//容器中只要注册了对应类的Bean或是对应类型子类的Bean，都可以获取到</span>
    <span class="token class-name">Student</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    student<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>表示，当我们尝试获取该类的<code>bean</code>来创建对象时，容器会去找注册的<code>bean</code>是否有对应的类或者其类的子类。</p>
<h4>创建对象的类存在多个对应<code>bean</code></h4>
<p>不过在有些时候，Bean的获取可能会出现歧义，我们可以来分别注册两个子类的Bean：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArtStudent</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">art</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我爱画画"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SportStudent</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我爱运动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>但是此时我们在创建<code>Student</code>类时，获取<code>Bean</code>时会找到有两个子类都满足：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行时得到如下报错：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>这里出现了一个<code>Bean</code>定义不唯一异常，很明显，因为我们需要的类型是<code>Student</code>，但是此时有两个<code>Bean</code>定义都满足这个类型，它们都是<code>Student</code>的子类，此时IoC容器不知道给我们返回哪一个<code>Bean</code>，所以就只能抛出异常了。</p>
<p>因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ArtStudent</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">ArtStudent</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">art</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4><code>name</code>属性</h4>
<p>那要是两个<code>Bean</code>的类型都是一样的呢？</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这种情况下，就无法使用<code>Class</code>来进行区分了，除了为<code>Bean</code>指定对应类型之外，我们也可以为<code>Bean</code>指定一个名称用于区分：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>art<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sport<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p><code>name</code>属性就是为这<code>个Bean</code>设定一个独一无二的名称（id属性也可以，跟name功能相同，但是会检查命名是否规范，否则会显示黄标）</p>
<p>不同的<code>Bean</code>名字不能相同，否则报错：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这样，这两个Bean我们就可以区分出来了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然目前这两Bean定义都是一模一样的，也没什么区别，但是这确实是两个不同的Bean，只是类型一样而已，之后我们还可以为这两个Bean分别设置不同的其他属性。</p>
<h4><code>alias</code>别名</h4>
<p>我们可以给Bean起名字，也可以起别名</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这样，我们使用别名也是可以拿到对应的Bean的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4>IoC容器对象生成原理</h4>
<p>那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？</p>
<p>我们现在在主方法中连续获取两次Bean对象：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student1 <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> student2 <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1 <span class="token operator">==</span> student2<span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">//默认为单例模式，对象始终为同一个</span>
</code></pre></div><p>我们发现，最后得到的结果为true</p>
<p>那么说明每次从IoC容器获取到的对象，<strong>始终都是同一个</strong>，默认情况下，通过IoC容器进行管理的Bean都是<strong>单例模式</strong>的，这个对象只会被创建一次。</p>
<p>如果我们希望每次拿到的对象都是一个新的，我们也可以将其<strong>作用域进行修改</strong></p>
<p>这里一共有两种作用域，第一种是<code>singleton</code>，默认情况下就是这一种，当然还有<code>prototype</code>，表示为原型模式，这种模式每次得到的对象都是一个新的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student1 <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//原型模式下，对象不再始终是同一个了</span>
<span class="token class-name">Student</span> student2 <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1 <span class="token operator">==</span> student2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>实际上，当Bean的作用域为单例模式时，那么它会在<strong>一开始（容器加载配置时）就被创建</strong>，我们之后拿到的都是这个对象。</p>
<p>而处于原型模式下，<strong>只有在获取时才会被创建</strong>，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。</p>
<h5>懒加载 <code>lazy-init</code></h5>
<p>当然，如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以开启懒加载：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">lazy-init</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>开启懒加载后，只有在真正第一次使用时才会创建对象。</p>
<h5>规定加载顺序 <code>depends-on</code></h5>
<p>因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建）那么我们可以使用<code>depends-on</code>来设定前置加载Bean，这样被依赖的Bean一定会在之前加载，比如Teacher应该在Student之前加载：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Teacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">depends-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这样就可以保证Bean的加载顺序了。</p>
<h3>依赖注入</h3>
<p>依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。</p>
<p>现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，我们使用容器的目标之一是<strong>消除类之间的强关联</strong>.</p>
<p>其实现的主要功能是，IoC容器在创建对象时，会根据我们提供的信息作为对象的属性来提前注入到对象中</p>
<p>比如现在有一个教师接口：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Teacher</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体的实现有两个：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArtTeacher</span> <span class="token keyword">implements</span> <span class="token class-name">Teacher</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是美术老师，我教你画画！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramTeacher</span> <span class="token keyword">implements</span> <span class="token class-name">Teacher</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是编程老师，我教你学Golang！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们的学生一开始有一个老师教他，比如美术老师：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArtTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token comment">//在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        teacher<span class="token punctuation">.</span><span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改<code>Student</code>类的定义：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgramTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以想象一下，如果现在冒出来各种各样的类都需要这样去用<code>Teacher</code>，那么一旦<code>Teacher</code>的实现发生变化，会导致我们挨个对之前用到<code>Teacher</code>的类进行修改，这就很难受了。</p>
<p>而有了<strong>依赖注入</strong>之后，Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值</p>
<p>也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中</p>
<h4><code>property</code> 标签</h4>
<p>我们可以使用<code>property</code>标签来实现，将<code>bean</code>标签展开：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mathTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.MathTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.ArtTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul>
<li><code>name</code>属性表示该注册的<code>bean</code>对应的对象的指定属性(<code>name</code>值)</li>
<li><code>ref</code>属性表示赋给这个属性的值来自另一个对应的<code>bean</code>注册对象中</li>
<li><code>value</code>属性表示赋给这个属性的值为<code>value</code>对应的值</li>
</ul>
<p>同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
    <span class="token comment">//要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTeacher</span><span class="token punctuation">(</span><span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>teacher <span class="token operator">=</span> teacher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><figure><figcaption>alt text</figcaption></figure>
<p>使用<code>property</code>来指定需要注入的值是一个Bean，这里我们选择ProgramTeacher，那么在使用时，Student类中的得到的就是这个Bean的对象了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><figcaption>alt text</figcaption></figure>
<p>可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置</p>
<p>这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!--  只需要修改这里的class即可，现在改为ArtTeacher  --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mathTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.MathTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.ArtTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mathTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这样，这个Bean的class就变成了新的类型，并且我们不需要再去调整其他位置的代码</p>
<p>通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？</p>
<p>当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">&lt;</span>bean name<span class="token operator">=</span><span class="token string">"student"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.test.bean.Student"</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"卢本伟"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
</code></pre></div><p>直接使用<code>value</code>可以直接传入一个具体值。</p>
<h4>构造注入 <code>constructor-arg</code> 标签</h4>
<p>实际上，在很多情况下，类中的某些参数是<strong>在构造方法中就已经完成初始化</strong>，而不是创建之后，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>   
    <span class="token comment">//构造方法中完成，所以说是一个final变量</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//Teacher属性是在构造方法中完成的初始化</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>teacher <span class="token operator">=</span> teacher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法</p>
<p>我们展开bean标签，添加一个<code>constructor-arg</code>标签：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mathTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.MathTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.ArtTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这里的<code>constructor-arg</code>就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。</p>
<p>通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机<strong>提前到了对象构造时</strong>。</p>
<h5>多种构造函数情况</h5>
<p>现在我们的Student类中是这样定义的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是一号构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是二号构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时我们希望使用的是二号构造方法，那么怎么才能指定呢？</p>
<p>有2种方式，我们可以给标签添加类型：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>也可以指定为对应的参数名称：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>如果是参数数量不同，就根据参数数量来区分就行</p>
<p>反正只要能够保证<strong>我们指定的参数匹配到目标构造方法</strong>即可。</p>
<h5>集合类型情况</h5>
<p>现在我们的类中出现了一个比较特殊的类型，它是一个集合类型：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于这种集合类型，有着特殊的支持：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--  对于集合类型，我们可以直接使用标签编辑集合的默认值  --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>AAA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>BBB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>CCC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用<code>entry</code>来注入：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>语文<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100.0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>数学<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>80.0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>英语<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>92.5<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>至此，我们就已经完成了两种依赖注入的学习：</p>
<ul>
<li>Setter依赖注入：通过成员属性对应的set方法完成注入。</li>
<li>构造方法依赖注入：通过构造方法完成注入。</li>
</ul>
<h3>自动装配 <code>autowire</code> 属性</h3>
<p>在之前，如果我们需要使用依赖注入的话，我们需要对<code>property</code>参数进行配置：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>但是有些时候为了方便，我们也可以开启<strong>自动装配</strong>。</p>
<p>自动装配就是让IoC容器<strong>自己去寻找需要填入的</strong>值，我们只需要将set方法提供好就可以了，这里需要添加autowire属性：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><h4><code>byName</code> + <code>byType</code></h4>
<p><code>autowire</code>属性最普通的有两个值</p>
<p>一个是byName，还有一个是byType</p>
<p>顾名思义，一个是根据类型(即对应的类或者其子类)去寻找合适的Bean自动装配</p>
<p>还有一个是根据名字(根据<code>setxxx</code>中的<code>xxx</code>)去找，这样我们就不需要显式指定<code>property</code>了。</p>
<p>此时set方法旁边会出现一个自动装配图标，效果和上面是一样的。</p>
<h4><code>constructor</code></h4>
<p>对于使用构造方法完成的依赖注入，也支持自动装配，我们只需要将autowire修改为：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>constructor<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这样，我们只需要提供一个对应参数的构造方法就可以了（这种情况<strong>默认也是byType寻找</strong>的）</p>
<p>这样同样可以完成自动注入</p>
<h4>候选名单 <code>autowire-candidate</code></h4>
<p>自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>此时，由于<code>autowire</code>的规则为byType，存在两个候选Bean，但是我们其实希望ProgramTeacher这个Bean在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ProgramTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">autowire-candidate</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>当<code>autowire-candidate</code>设定false时，这个Bean将不再作为自动装配的候选Bean，此时自动装配候选就只剩下一个唯一的Bean了，报错消失，程序可以正常运行。</p>
<h4>优先选择 <code>primary</code></h4>
<p>除了这种方式，我们也可以设定primary属性，表示这个Bean作为主要的Bean，当出现歧义时，也会优先选择：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">primary</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ProgramTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Javassm - Spring3 (Bean生命周期与继承)</title>
      <link>http://ekkosonya.cn/code/java_ssm/Spring/spring3.html</link>
      <guid>http://ekkosonya.cn/code/java_ssm/Spring/spring3.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Javassm - Spring3 (Bean生命周期与继承)</source>
      <description>IoC理论基础 3 Bean生命周期与继承 初始化 init-method 和 销毁 destroy-method 我们可以为Bean指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务 通过init-method和destroy-method属性来指定： 其中的值为对应对象的某个函数 初始化和销毁的时机 那么什么时候是初始化，什么时候...</description>
      <category>code</category>
      <pubDate>Tue, 05 Aug 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>IoC理论基础 3</h2>
<h3>Bean生命周期与继承</h3>
<h4>初始化 <code>init-method</code> 和 销毁 <code>destroy-method</code></h4>
<p>我们可以为<code>Bean</code>指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务</p>
<p>通过<code>init-method</code>和<code>destroy-method</code>属性来指定：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>destroy<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>其中的值为对应对象的某个函数</p>
<h5>初始化和销毁的时机</h5>
<p>那么什么时候是初始化，什么时候又是销毁呢？</p>
<ul>
<li>
<p>当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行<code>init-method</code></p>
</li>
<li>
<p>我们可以调用<code>close</code>方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行<code>destroy-method</code></p>
</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 容器创建时，默认情况下Bean都是单例的</span>
<span class="token comment">// 那么都会在一开始就加载好，对象构造完成后，会执行init-method</span>
<span class="token class-name">ClassPathXmlApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 我们可以调用close方法关闭容器</span>
<span class="token comment">// 此时容器内存放的Bean也会被一起销毁，会执行destroy-method</span>
context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，如果Bean不是单例模式，而是采用的<strong>原型模式</strong>，那么就<strong>只会在获取时才创建，并调用<code>init-method</code></strong>，而对应的销毁方法不会被调用，即使你<code>contest.close()</code></p>
<p>因此，对于<strong>原型模式</strong>下的Bean，Spring<strong>无法顾及其完整生命周期</strong>，而在单例模式下，Spring能够从Bean对象的创建<strong>一直管理到对象的销毁</strong></p>
<p>官方文档原文如下：</p>
<blockquote>
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp" target="_blank" rel="noopener noreferrer">bean post-processor</a>, which holds a reference to beans that need to be cleaned up.</p>
</blockquote>
<h4>继承 (属性继承) <code>parent</code></h4>
<p>Bean之间也是具备继承关系的，只不过这里的继承并不是类的继承，而是<strong>属性的继承</strong>，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SportStudent</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArtStudent</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
   
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时，我们先将ArtStudent注册一个Bean：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtStudent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>小明<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这里我们会注入一个name的初始值，此时我们创建了一个<code>SportStudent</code>的Bean，我们希望这个Bean的属性跟刚刚创建的Bean属性是一样的，那么我们可以写一个一模一样的：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>小明<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>但是如果属性太多的话，写起来有点麻烦</p>
<p>这种情况，我们就可以配置Bean之间的继承关系了，我们可以让<code>SportStudent</code>这个Bean直接继承ArtStudent这个Bean配置的属性：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误）</p>
<h5>单独配置其他属性</h5>
<p>当然，如果子类中某些属性比较特殊，<strong>也可以在继承的基础上单独配置</strong>：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtStudent<span class="token punctuation">"</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>小明<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h5>抽象<code>Bean</code></h5>
<p>如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，<strong>容器就不会创建这个Bean的对象</strong>了：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ArtStudent<span class="token punctuation">"</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>小明<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.SportStudent<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>artStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>注意，一旦声明为抽象Bean，那么就无<strong>法通过容器获取到其实例化对象</strong>了。</p>
<figure><figcaption>alt text</figcaption></figure>
<p>不过Bean的继承使用频率不是很高，了解就行。</p>
<h4>默认全局配置</h4>
<p>这里最后再提一下，我们前面已经学习了各种各样的Bean配置属性，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>这样，即使Bean没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非Bean自己进行配置覆盖掉默认配置。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Javassm - Spring4 (工厂模式和工厂Bean)</title>
      <link>http://ekkosonya.cn/code/java_ssm/Spring/spring4.html</link>
      <guid>http://ekkosonya.cn/code/java_ssm/Spring/spring4.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Javassm - Spring4 (工厂模式和工厂Bean)</source>
      <description>IoC理论基础 4 工厂模式和工厂Bean 默认情况下，容器会调用Bean对应类型的构造方法进行对象创建 但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中 我们更希望 Spring 不要直接利用反射机制通过构造方法创建Bean对象, 而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的Bean对象： f...</description>
      <category>code</category>
      <pubDate>Wed, 06 Aug 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>IoC理论基础 4</h2>
<h3>工厂模式和工厂Bean</h3>
<p>默认情况下，容器会调用Bean对应类型的构造方法进行对象创建</p>
<p>但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中</p>
<p>我们更希望 Spring 不要直接利用反射机制通过构造方法创建Bean对象, 而是利用反射机制先找到<strong>对应的工厂类</strong>，然后<strong>利用工厂类去生成需要的Bean对象</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我被构造了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Student</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"欢迎光临电子厂"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4><code>factory-method</code></h4>
<p>得到的<code>Bean</code>依然是对应对象的<code>Bean</code>, 而不是对应工厂的。</p>
<p>此时Student有一个工厂，我们正常情况下需要使用工厂才可以得到Student对象，现在我们希望Spring也这样做，不要直接去反射搞构造方法创建，我们可以通过<code>factory-method</code>进行指定：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.StudentFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>注意，这里的Bean类型需要填写为<strong>Student类的工厂类</strong>，并且添加<code>factory-method</code>指定对应的工厂方法</p>
<p>但是<strong>最后注册的是工厂方法的返回类型</strong>，所以说依然是<code>Student</code>的Bean</p>
<p>此时我们再去进行获取，拿到的也是通过工厂方法得到的对象</p>
<figure><figcaption>alt text</figcaption></figure>
<blockquote>
<p>这里有一个误区，千万不要认为是我们注册了StudentFactory这个Bean，class填写为这个类这个<strong>只是为了告诉Spring我们的工厂方法在哪个位置</strong>，真正注册的是工厂方法提供的东西。
也可以用<code>init-method</code>测试，当你把对应的<code>init</code>方法写在<code>StudentFactory</code>中，idea会自动报错，只有写在<code>Student</code>中才是正确的。
</p>
</blockquote>
<p>可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对Bean进行依赖注入等操作了，而是只能在工厂方法中完成.</p>
<h4>工厂<code>Bean</code> - <code>factory-bean</code></h4>
<p>当然，可能某些工厂类需要构造出对象之后才能使用(比如对应构建实体类对象的方法不是<code>Static</code>)</p>
<p>就需要先将这个工厂类注册为一个<code>bean</code>，然后再基于这个<code>bean</code>作为新的<code>bean</code>的<code>factory-bean</code>的值</p>
<p>我们也可以将某个工厂类直接注册为工厂Bean：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"欢迎光临电子厂"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在需要<code>StudentFactory</code>对象才可以获取到<code>Student</code>，此时我们就<strong>只能先将其注册为Bean了</strong>，像这样将工厂类注册为Bean，我们称其为工厂Bean，然后再使用<code>factory-bean</code>来指定Bean的工厂Bean：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.StudentFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getStudent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>注意，使用factory-bean之后，不再要求指定class，我们可以直接使用了：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为Bean，此时我们就可以在配置文件中为工厂Bean配置依赖注入等内容了。</p>
<p>这里还有一个很细节的操作，如果我们想获取工厂Bean为我们提供的Bean，<strong>可以直接输入工厂Bean的名称，这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> bean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"studentFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，如果我们需要获取工厂类的实例，可以在名称前面添加<code>&amp;</code>符号：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">StudentFactory</span> bean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">StudentFactory</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"&amp;studentFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5>直接继承<code>FactoryBean&lt;?&gt;</code></h5>
<p>不需要注册工厂<code>bean</code>，xml只需要：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.entity.StudentFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>然后让对应的工厂类继承<code>FactoryBean</code>:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getStudent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Javassm - Spring5</title>
      <link>http://ekkosonya.cn/code/java_ssm/Spring/spring5.html</link>
      <guid>http://ekkosonya.cn/code/java_ssm/Spring/spring5.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Javassm - Spring5</source>
      <description>IoC理论基础 5 使用注解开发 前面我们已经完成了大部分的配置文件学习，但是我们发现，使用配置文件进行配置，似乎有点复杂 可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满Bean配置，并且会继续庞大下去。 所以可以用注解来进行配置 AnnotationConfigApplicationContext() 既然现在要使用注解来进行开发，那么我...</description>
      <category>code</category>
      <pubDate>Wed, 06 Aug 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>IoC理论基础 5</h2>
<h3>使用注解开发</h3>
<p>前面我们已经完成了大部分的配置文件学习，但是我们发现，使用配置文件进行配置，似乎有点复杂</p>
<p>可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满Bean配置，并且会继续庞大下去。</p>
<p>所以可以用注解来进行配置</p>
<h4><code>AnnotationConfigApplicationContext()</code></h4>
<p>既然现在要使用注解来进行开发，那么我们就删掉之前的xml配置文件吧，我们来看看使用注解能有多方便。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们使用<code>AnnotationConfigApplicationContext</code>作为上下文实现，它是注解配置的。</p>
<p>既然现在采用注解，我们就需要使用类来编写配置文件</p>
<p>只需要创建一个配置类就可以了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以为<code>AnnotationConfigApplicationContext</code>指定一个默认的配置类：</p>
<p>这个构造方法可以接收多个配置类（更准确的说是多个组件）</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//这个构造方法可以接收多个配置类（更准确的说是多个组件）</span>
<span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">MainConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4>注册<code>Bean</code> (<code>@Bean(xxx)</code>)</h4>
<p>那么现在我们该如何配置Bean呢？</p>
<p><code>@Bean</code> 中包含的属性：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">ANNOTATION_TYPE</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Bean</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">autowireCandidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">initMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">destroyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"(inferred)"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体例子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"student"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样写相对于配置文件中的：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4>引入其他配置类 <code>@Import</code></h4>
<p>多个配置合并成一个再集体导入</p>
<p>通过<code>@Import</code>还可以引入其他配置类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">LBWConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token comment">//在讲解到Spring原理时，我们还会遇到它，目前只做了解即可。</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h4>具体使用</h4>
<p>只不过现在变成了由Java代码为我们提供Bean配置，这样会更加的灵活，也更加便于控制Bean对象的创建。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">MainConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用方法是相同的，这跟使用XML配置是一样的。</p>
<h4><code>@Bean</code>设置的配置</h4>
<p>初始化方法和摧毁方法、自动装配可以直接在@Bean注解中进行配置：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> initMethod <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> autowireCandidate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>其他注解设置的配置 (lazy, 单例/原型@Scope 等)</h4>
<p>其次，我们可以使用一些其他的注解来配置其他属性，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Lazy</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>     <span class="token comment">//对应lazy-init属性</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>    <span class="token comment">//对应scope属性 是单例还是原型</span>
<span class="token annotation punctuation">@DependsOn</span><span class="token punctuation">(</span><span class="token string">"teacher"</span><span class="token punctuation">)</span>    <span class="token comment">//对应depends-on属性</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>依赖注入的配置</h4>
<p>对于那些我们需要通过构造方法或是Setter完成依赖注入的Bean，比如：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.ProgramTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>像这种需要引入其他Bean进行的注入，我们可以直接将其作为形式参数放到方法中：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Teacher</span> <span class="token function">teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>teacher<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 要有对应的构造函数或者对应setteacher</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时我们可以看到，旁边已经出现图标了：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>运行程序之后，我们发现，这样确实可以直接得到对应的Bean并使用。</p>
<h5>自动装配 <code>@Autowired</code></h5>
<p>只不过，除了这种基于构造器或是Setter的依赖注入之外，我们也可以直接到Bean对应的类中使用自动装配：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>   
    <span class="token comment">//使用此注解来进行自动装配，由IoC容器自动为其赋值</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们甚至连构造方法和Setter都不需要去编写了，就能直接完成自动装配</p>
<p>很快，应该是根据对应的属性的类去找有没有对应的<code>Bean</code>，不需要给<code>Bean</code>取别名对应</p>
<p>当然，<code>@Autowired</code>并不是只能用于字段，对于构造方法或是Setter，它同样可以：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTeacher</span><span class="token punctuation">(</span><span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>teacher <span class="token operator">=</span> teacher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5>指定装配 <code>@Qualifier</code></h5>
<p><code>@Autowired</code>默认采用<code>byType</code>的方式进行自动装配，也就是说会使用类型进行配</p>
<p>那么要是出现了多个相同类型的Bean，如果我们想要指定使用其中的某一个该怎么办呢？</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Teacher</span> <span class="token function">teacherA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Teacher</span> <span class="token function">teacherB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时，我们可以配合<code>@Qualifier</code>进行名称匹配：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token comment">//匹配名称为a的Teacher类型的Bean</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5><code>@Resource</code> (移除)</h5>
<p>这里需要提一下，在我们旧版本的SSM教程中讲解了<code>@Resource</code>这个注解，但是现在它没有了。</p>
<p>随着Java版本的更新迭代，某些javax包下的包，会被逐渐弃用并移除。在JDK11版本以后，<code>javax.annotation</code>这个包被移除并且更名为<code>jakarta.annotation</code></p>
<p>其中有一个非常重要的注解，叫做<code>@Resource</code>，它的作用与<code>@Autowired</code>时相同的，也可以实现自动装配，但是在IDEA中并不推荐使用<code>@Autowired</code>注解对成员字段进行自动装配，而是推荐使用<code>@Resource</code>，如果需要使用这个注解，还需要额外导入包：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>jakarta.annotation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jakarta.annotation-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>使用方法一样，直接替换掉就可以了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>只不过，他们两有些机制上的不同：</p>
<ul>
<li>@Resource默认<strong>ByName</strong>如果找不到则<strong>ByType</strong>，可以添加到set方法、字段上。</li>
<li>@Autowired默认是<strong>byType</strong>，只会根据类型寻找，可以添加在构造方法、set方法、字段、方法参数上。</li>
</ul>
<p>因为<code>@Resource</code>的匹配机制更加合理高效，因此官方并不推荐使用<code>@Autowired</code>字段注入</p>
<p>当然，实际上Spring官方更推荐我们使用基于构造方法或是Setter的<code>@Autowired</code>注入，比如S etter 注入的一个好处是，Setter 方法使该类的对象能够在以后重新配置或重新注入。</p>
<p>其实，最后使用哪个注解，还是看你自己，要是有强迫症不能忍受黄标但是又实在想用字段注入，那就用@Resource注解。</p>
<h4>初始化和销毁注解</h4>
<p>除了这个注解之外，还有<code>@PostConstruct</code>和<code>@PreDestroy</code>，它们效果和<code>init-method</code>和<code>destroy-method</code>是一样的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@PostConstruct</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是初始化方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@PreDestroy</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是销毁方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们只需要将其添加到对应的方法上即可：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">AnnotationConfigApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">MainConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> student <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到效果是完全一样的，这些注解都是<code>jakarta.annotation</code>提供的，有关Spring和JakartaEE的渊源，还请各位小伙伴自行了解。</p>
<h4><code>@Component</code>(常用注册Bean方式)</h4>
<p>前面我们介绍了使用@Bean来注册Bean，但是实际上我们发现，如果只是简单将一个类作为Bean的话，这样写还是不太方便，因为都是固定模式，<strong>就是单纯的new一个对象出来</strong>，能不能像之前一样，让容器自己反射获取构造方法去生成这个对象呢？</p>
<p>肯定是可以的，我们可以在需要注册为Bean的类上添加<code>@Component</code>注解来将一个类进行注册(<strong>现在最常用的方式</strong>)</p>
<p>不过要实现这样的方式，我们需要添加一个自动扫描 <code>@ComponentScan</code> 来告诉Spring，它需要在哪些包中查找我们提供的<code>@Component</code>声明的Bean。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"penguin"</span><span class="token punctuation">)</span>   <span class="token comment">//同样可以自己起名字</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>要注册这个类的Bean，只需要添加<code>@Component</code>即可，然后配置一下包扫描：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.test.bean"</span><span class="token punctuation">)</span>   
<span class="token comment">//包扫描，这样Spring就会去扫描对应包下所有的类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>或者</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScans</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.test.bean"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfiguration</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>Spring在扫描对应包下所有的类时，会自动将那些添加了@Component的类注册为Bean</p>
<p>只不过这种方式只适用于我们自己编写类的情况，如果是第三方包提供的类，只能使用前者完成注册，并且这种方式并不是那么的灵活。</p>
<h4>默认<code>name</code>命名</h4>
<p>不过，无论是通过<code>@Bean</code>还是<code>@Component</code>形式注册的Bean，Spring都会为其添加一个默认的name属性，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它的默认名称生产规则依然是<strong>类名并按照首字母小写的驼峰命名法</strong>来的，所以说对应的就是student：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">//这样同样可以获取到</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样的，如果是通过<code>@Bean</code>注册的，默认名称是对应的方法名称：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">artStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"artStudent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4>其他</h4>
<p>相比传统的XML配置方式，注解形式的配置确实能够减少我们很多工作量。</p>
<p>并且，对于这种使用<code>@Component</code>注册的Bean，如果其构造方法不是默认无参构造，<strong>那么默认会对其每一个参数都进行自动注入</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>   
        <span class="token comment">//如果有Teacher类型的Bean，那么这里的参数会被自动注入</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>teacher <span class="token operator">=</span> teacher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>工厂模式处理</h4>
<p>最后，对于我们之前使用的工厂模式，Spring也提供了接口，我们可以直接实现接口表示这个Bean是一个工厂Bean：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//生产的Bean对象</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//生产的Bean类型</span>
        <span class="token keyword">return</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//生产的Bean是否采用单例模式</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>讨论</h4>
<p>实际上跟我们之前在配置文件中编写是一样的，这里就不多说了。</p>
<p>请注意，使用注解虽然可以省事很多，代码也能变得更简洁，但是这并不代表XML配置文件就是没有意义的，它们有着各自的优点，在不同的场景下合理使用，能够起到事半功倍的效果，官方原文：</p>
<blockquote>
<p>Are annotations better than XML for configuring Spring?</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.</p>
<p>No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java" target="_blank" rel="noopener noreferrer">JavaConfig</a> option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the <a href="https://spring.io/tools" target="_blank" rel="noopener noreferrer">Spring Tools for Eclipse</a>.</p>
</blockquote>
<p>在最后，留一个问题，现在有两个类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">Student</span> student<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这两个类互相需要注入对方的实例对象，这个时候Spring会怎么进行处理呢？</p>
<p>测试了，加了这种注解是可以正常运行的不会报错，但如果我改成这样：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">Student</span> student<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>就会报错：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>月 <span class="token number">06</span><span class="token punctuation">,</span> <span class="token number">2025</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">12</span> 下午 <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span>AbstractApplicationContext</span> refresh
警告<span class="token operator">:</span> <span class="token class-name">Exception</span> encountered during context initialization <span class="token operator">-</span> cancelling refresh attempt<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>UnsatisfiedDependencyException</span><span class="token operator">:</span> 
    <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> 'student' defined in file<span class="token operator">:</span> <span class="token class-name">Unsatisfied</span> dependency expressed through constructor parameter <span class="token number">0</span><span class="token operator">:</span> <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> 'teacher' defined in file <span class="token operator">:</span> <span class="token class-name">Unsatisfied</span> dependency expressed through constructor parameter <span class="token number">0</span><span class="token operator">:</span> <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> 'student'<span class="token operator">:</span> <span class="token class-name">Requested</span> bean is currently in creation<span class="token operator">:</span> 
    <span class="token class-name">Is</span> there an unresolvable circular reference<span class="token operator">?</span>
</code></pre></div><p>问了GPT回答：</p>
<p>在 构造器注入 的情况下，Spring 必须一次性把依赖注入进去，无法像 setter注入 或 字段注入 那样延迟注入，因此两个类互相通过构造器注入会导致无法完成初始化。</p>
<p>而采用 <code>@Autowired</code>，可以让 Spring 能先创建一个 Bean 再回头注入依赖。</p>
<p>或者如果一定用构造器注入，可以用 @Lazy 让其中一个依赖延迟到使用时再初始化。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Lazy</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>teacher <span class="token operator">=</span> teacher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样 Spring 创建 Student 时不会立刻去创建 Teacher，避免循环依赖。</p>
<p>如果Bean变成原型模式，Spring又会怎么处理呢？</p>
<p>对于单例情况：</p>
<ul>
<li>
<p>单例 Bean 的循环依赖（构造器以外）时，Spring 可以用 三级缓存（三级缓存机制） 暂存早期引用，允许先暴露一个“半成品”Bean，让另一个 Bean 注入，最后再完成填充。</p>
</li>
<li>
<p>但是 构造器注入 场景下没法这么干，因为构造函数必须一次性拿到所有参数，Spring 没法先造个半成品放进去。</p>
</li>
</ul>
<p>但对于原型模式：</p>
<p>原型 Bean 是 每次请求都会新建一个实例，Spring 不会缓存它。
这意味着：</p>
<ul>
<li>
<p>对于 原型 Bean 的循环依赖，Spring 完全没有缓存机制可用
所以即使是 setter/字段注入，Spring 也无法像单例那样从缓存取“早期引用”来解循环</p>
</li>
<li>
<p>结果就是：无论是构造器注入还是 setter 注入，只要原型 Bean有循环依赖，都会直接报错</p>
</li>
</ul>
<figure><figcaption>alt text</figcaption></figure>
<figure><figcaption>alt text</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>Java 杂</title>
      <link>http://ekkosonya.cn/code/java%209-17/javainfo6.html</link>
      <guid>http://ekkosonya.cn/code/java%209-17/javainfo6.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Java 杂</source>
      <description>Consumer Consumer是Java 8中的一个函数式接口，它位于java.util.function包中。 定义了一个名为accept的抽象方法，该方法接受一个参数并且不返回任何结果。 换句话说，Consumer接口表示一个消费者，它可以对给定的对象执行某些操作，但不产生任何结果。 接口声明 主要就两个方法： accept 核心方法是acce...</description>
      <category>code</category>
      <pubDate>Wed, 30 Jul 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2><code>Consumer</code></h2>
<p><code>Consumer</code>是Java 8中的一个函数式接口，它位于<code>java.util.function</code>包中。</p>
<p>定义了一个名为<code>accept</code>的抽象方法，该方法接受一个参数并且不返回任何结果。</p>
<p>换句话说，<code>Consumer</code>接口表示一个消费者，它可以对给定的对象<strong>执行某些操作，但不产生任何结果</strong>。</p>
<h3>接口声明</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * Performs this operation on the given argument.
     *
     * <span class="token keyword">@param</span> <span class="token parameter">t</span> the input argument
     */</span>
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * Returns a composed <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Consumer</span></span></span><span class="token punctuation">}</span> that performs, in sequence, this
     * operation followed by the <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">after</span></span><span class="token punctuation">}</span> operation. If performing either
     * operation throws an exception, it is relayed to the caller of the
     * composed operation.  If performing this operation throws an exception,
     * the <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">after</span></span><span class="token punctuation">}</span> operation will not be performed.
     *
     * <span class="token keyword">@param</span> <span class="token parameter">after</span> the operation to perform after this operation
     * <span class="token keyword">@return</span> a composed <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Consumer</span></span></span><span class="token punctuation">}</span> that performs in sequence this
     * operation followed by the <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">after</span></span><span class="token punctuation">}</span> operation
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">NullPointerException</span></span> if <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">after</span></span><span class="token punctuation">}</span> is null
     */</span>
    <span class="token keyword">default</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">andThen</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>after<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> after<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主要就两个方法：</p>
<h4><code>accept</code></h4>
<p>核心方法是<code>accept</code>，该方法接受一个参数，并在方法体内定义具体的操作</p>
<p>这是抽象方法，也是我们需要给的</p>
<p>具体示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Lambda表达式简化</span>
<span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> printer <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 accept 方法执行操作</span>
printer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4><code>addThen</code></h4>
<p>第二个是 <code>addThen</code>，为了方便 <code>Consumer</code> 链式操作</p>
<p><code>Consumer</code>接口还支持链式操作，也就是将多个<code>Consumer</code>组合在一起，形成一个新的<code>Consumer</code>。</p>
<p>这可以通过<code>andThen</code>方法来实现，该方法允许将两个<code>Consumer</code>连接在一起，顺序执行。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> upperCasePrinter <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> lowerCasePrinter <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 andThen 方法连接两个 Consumer</span>
<span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> combinedPrinter <span class="token operator">=</span> upperCasePrinter<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>lowerCasePrinter<span class="token punctuation">)</span><span class="token punctuation">;</span>

combinedPrinter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>传递的参数都是一样的不会被上一个影响，都是<code>Hello, World!</code></p>
<h2><code>Optional</code></h2>
<p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Optional</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Java8Tester</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   
      <span class="token class-name">Java8Tester</span> java8Tester <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Java8Tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Integer</span> value1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token class-name">Integer</span> value2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
      <span class="token comment">// Optional.ofNullable - 允许传递为 null 参数</span>
      <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> a <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
      <span class="token comment">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span>
      <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> b <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>java8Tester<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    
   <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> a<span class="token punctuation">,</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
      <span class="token comment">// Optional.isPresent - 判断值是否存在</span>
        
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一个参数值存在: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二个参数值存在: "</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
      <span class="token comment">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span>
      <span class="token class-name">Integer</span> value1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
      <span class="token comment">//Optional.get - 获取值，值需要存在</span>
      <span class="token class-name">Integer</span> value2 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> value1 <span class="token operator">+</span> value2<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2><code>Stream</code></h2>
<p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</p>
<p>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。</p>
<h3>特点</h3>
<ul>
<li>
<p>不是数据结构，不会保存数据。</p>
</li>
<li>
<p>不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）</p>
</li>
<li>
<p>惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</p>
</li>
</ul>
<h3>操作</h3>
<p><code>Stream</code>可以由<strong>数组或集合</strong>创建，对流的操作分为两种：</p>
<ul>
<li>
<p>中间操作，每次返回一个新的流，可以有多个
（筛选filter、映射map、排序sorted、去重组合skip—limit）</p>
</li>
<li>
<p>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。
终端操作会产生一个新的集合或值。（遍历foreach、匹配find–match、规约reduce、聚合max–min–count、收集collect）</p>
</li>
</ul>
<figure><figcaption>alt text</figcaption></figure>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"武汉加油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"中国加油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"世界加油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"世界加油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> count <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。</p>
<h3>创建流</h3>
<p>如果是<strong>数组</strong>的话，可以使用 <code>Arrays.stream()</code> 或者 <code>Stream.of()</code>创建流</p>
<p>如果是<strong>集合</strong>的话，可以直接使用 <code>stream()</code> 方法创建流，因为该方法已经添加到 Collection 接口中。</p>
<p>查看 <code>Stream</code> 源码的话，你会发现 <code>of()</code> 方法内部其实调用了<code>Arrays.stream()</code> 方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外，集合还可以调用 <code>parallelStream()</code> 方法创建并发流，默认使用的是 <code>ForkJoinPool.commonPool()</code>线程池。</p>
<h3>操作流</h3>
<h4>过滤 <code>filter</code></h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterStreamDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"周杰伦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"王力宏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"陶喆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"林俊杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"王"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>映射 <code>map</code></h4>
<p>把一个流中的元素转化成新的流中的元素</p>
<p>map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法</p>
<p>也就是把 <code>Stream&lt;String&gt;</code> 的流转成一个 <code>Stream&lt;Integer&gt;</code> 的流</p>
<p>新的流中的内容被修改为对应字符串的长度</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapStreamDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"周杰伦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"王力宏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"陶喆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"林俊杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>匹配</h4>
<p>Stream 类提供了三个方法可供进行元素匹配，它们分别是：</p>
<ul>
<li>
<p><code>anyMatch()</code>，只要有一个元素匹配传入的条件，就返回 true。</p>
</li>
<li>
<p><code>allMatch()</code>，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。</p>
</li>
<li>
<p><code>noneMatch()</code>，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。</p>
</li>
</ul>
<h4>组合 <code>reduce</code></h4>
<p><code>reduce()</code> 方法的主要作用是把 <code>Stream</code> 中的元素组合起来，它有两种用法：</p>
<ul>
<li>
<p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code>
没有起始值，只有一个参数，就是运算规则，此时返回 <code>Optional</code>。</p>
</li>
<li>
<p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>
有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。</p>
</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReduceStreamDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> optional <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> optional1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional1<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> reduce <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reduce<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> reduce1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reduce1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>转换流 <code>collect()</code></h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectStreamDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"周杰伦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"王力宏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"陶喆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"林俊杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span> str <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>toArray()</code> 方法可以将流转换成数组</p>
<p>来看一下 <code>toArray()</code> 方法的源码。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">A</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">IntFunction</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> generator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也就是说 <code>String[]::new</code> 是一个 <code>IntFunction</code>，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x$<span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>x$<span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也就是相当于返回了一个指定长度的字符串数组。</p>
<p>当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 <code>map()</code> 方法和 <code>collect()</code> 方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过 <code>stream()</code> 方法创建集合的流后，再通过 <code>map(String:length)</code> 将其映射为字符串长度的一个新流，最后通过 <code>collect()</code>方法将其转换成新的集合。</p>
<p><code>Collectors</code> 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。</p>
<h2><code>Builder</code></h2>
<p>一般构建对象时会有两种方法：</p>
<ol>
<li>通过构造函数来构建</li>
<li>一个默认的构造函数，然后用 <code>setter</code> 方法设置</li>
</ol>
<p>比如一个api结果返回值的类Result，其在代码中频繁被使用：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCode</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Result{"</span> <span class="token operator">+</span>
                <span class="token string">"code="</span> <span class="token operator">+</span> code <span class="token operator">+</span>
                <span class="token string">", message='"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>
                <span class="token string">", data="</span> <span class="token operator">+</span> data <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果要使用它，一般的方法是：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//方法1，使用全量的构造函数</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"success"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//方法2，使用空的构造函数加setter函数赋值</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result2<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result2<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result2<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这两种使用方法的弊端有：</p>
<ol>
<li>方法一：当只需要部分参数的时候需要再定义个构造函数（比如失败的情况只需要code和message，结果肯定是空，因此不需要data），且一旦参数较多，则构造函数冗长；</li>
<li>方法二：setter冗长；</li>
</ol>
<h3>建造者模式</h3>
<p>其实是一种设计模式，叫做建造者模式，它的含义是将一个复杂的对象的构建与它的表示分离，同样的构建过程可以创建不同的表示</p>
<p>可以在 <code>Result</code> 内加入一个 <code>Builder</code> 类:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        code <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token class-name">String</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        message <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token class-name">T</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        data <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后使用的时候：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result<span class="token punctuation">.</span>Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token string">"failure"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result4 <span class="token operator">=</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token string">"failure"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所以只需要构造一个 <code>builder</code>，通过 <code>Result.builder()</code> 然后根据属性调用对应的方法进行修改，最后使用 <code>build()</code> 就可以创造出不同的对象</p>
<h3><code>Lombok</code> 中的 <code>@Builder</code></h3>
<p>lombok 用 <code>@Builder</code> 来辅助设计</p>
<p><code>@Builder</code>可以让你以下面显示的那样调用你的代码，来初始化你的实例对象：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"Adam Savage"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">city</span><span class="token punctuation">(</span><span class="token string">"San Francisco"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">job</span><span class="token punctuation">(</span><span class="token string">"Mythbusters"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">job</span><span class="token punctuation">(</span><span class="token string">"Unchained Reaction"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>@Builder</code>可以放在类，构造函数或方法上。 虽然放在类上和放在构造函数上这两种模式是最常见的用例，但@Builder最容易用放在方法的用例来解释</p>
<p>具体操作：</p>
<p>使用<code>@Builder</code>注释的方法具体实现了：</p>
<ul>
<li>
<p>一个名为<code>FooBuilder</code>的内部静态类，并具有和实体类<strong>一致的属性</strong>（称为构建器）。</p>
</li>
<li>
<p>在构建器中：对于目标类中的所有的属性和未初始化的final字段，都会在构建器中创建对应属性；</p>
</li>
<li>
<p>在构建器中：创建一个无参的default构造函数。</p>
</li>
<li>
<p>在构建器中：对于实体类中的每个参数，都会对应创建类似于<code>setter</code>的方法，方法名与该参数名相同。 并且返回值是<strong>构建器本身</strong>（<strong>便于链式调用</strong>）</p>
</li>
<li>
<p>在构建器中：一个<code>build()</code>方法，调用此方法，就会根据设置的值进行创建实体对象。</p>
</li>
<li>
<p>在构建器中：同时也会生成一个<code>toString()</code>方法。</p>
</li>
<li>
<p>在实体类中：会创建一个<code>builder()</code>方法，它的目的是用来创建构建器。</p>
</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Builder</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 编译后：</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
    <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">User<span class="token punctuation">.</span>UserBuilder</span> <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User<span class="token punctuation">.</span>UserBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UserBuilder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
        <span class="token class-name">UserBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 
        <span class="token keyword">public</span> <span class="token class-name">User<span class="token punctuation">.</span>UserBuilder</span> <span class="token function">username</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">User<span class="token punctuation">.</span>UserBuilder</span> <span class="token function">password</span><span class="token punctuation">(</span><span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"User.UserBuilder(username="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">+</span> <span class="token string">", password="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 12-16 - 1</title>
      <link>http://ekkosonya.cn/code/java%209-17/javainfo5.html</link>
      <guid>http://ekkosonya.cn/code/java%209-17/javainfo5.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Java 12-16 - 1</source>
      <description>Java 12-16 新特性 由于Java版本的更新迭代速度自Java 9开始为半年更新一次 Java 8到Java 9隔了整整三年，所以各个版本之间的更新内容比较少了。 alt textalt text Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能 12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续...</description>
      <category>code</category>
      <pubDate>Tue, 29 Jul 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>Java 12-16 新特性</h2>
<p>由于Java版本的更新迭代速度自Java 9开始为半年更新一次</p>
<p>Java 8到Java 9隔了整整三年，所以各个版本之间的更新内容比较少了。</p>
<figure><figcaption>alt text</figcaption></figure>
<p>Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能</p>
<p>12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用。</p>
<h3>新的switch语法</h3>
<p>在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活</p>
<p>比如我们想要编写一个根据成绩得到等级的方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 传入分数（范围 0 - 100）返回对应的等级：
 *      100-90：优秀
 *      70-80：良好
 *      60-70：及格
 *      0-60：寄
 * <span class="token keyword">@param</span> <span class="token parameter">score</span> 分数
 * <span class="token keyword">@return</span> 等级
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">grade</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们想要使用switch来实现这个功能，之前的写法是：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">grade</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>
    score <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token comment">//既然分数段都是整数，那就直接整除10</span>
    <span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token number">9</span><span class="token operator">:</span>
            res <span class="token operator">=</span>  <span class="token string">"优秀"</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>
            res <span class="token operator">=</span> <span class="token string">"良好"</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>
            res <span class="token operator">=</span> <span class="token string">"及格"</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            res <span class="token operator">=</span> <span class="token string">"不及格"</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4><code>switch</code> 新语法</h4>
<p>但是现在我们可以使用新的特性了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">grade</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>
    score <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token comment">//既然分数段都是整数，那就直接整除10</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        <span class="token comment">//增强版switch语法</span>
        <span class="token keyword">case</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token operator">-&gt;</span> <span class="token string">"优秀"</span><span class="token punctuation">;</span>   
        <span class="token comment">//语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了</span>
        <span class="token keyword">case</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token operator">-&gt;</span> <span class="token string">"良好"</span><span class="token punctuation">;</span> 
        <span class="token keyword">case</span> <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token string">"及格"</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token string">"不及格"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过最后编译出来的样子，貌似还是和之前是一样的</p>
<h4>详细规则</h4>
<p>这种全新的switch语法称为<code>switch表达式</code>，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
    <span class="token comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span>
    <span class="token keyword">case</span> <span class="token punctuation">[</span>匹配值<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"优秀"</span><span class="token punctuation">;</span>
    <span class="token comment">// case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开</span>
    <span class="token comment">// 使用 -&gt; 来返回如果匹配此case语句的结果</span>
    <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment">//根据不同的分支，可以存在多个case</span>
    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token string">"不及格"</span><span class="token punctuation">;</span>   
    <span class="token comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//增强版switch语法</span>
    <span class="token keyword">case</span> <span class="token punctuation">[</span>匹配值<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"优秀"</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>   
        <span class="token comment">//我们可以使用花括号来将整套逻辑括起来</span>
        <span class="token comment">//... 我是其他要做的事情</span>
        <span class="token keyword">yield</span>  <span class="token string">"不及格"</span><span class="token punctuation">;</span>  <span class="token comment">//注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，也可以像这样：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//增强版switch语法</span>
    <span class="token keyword">case</span> <span class="token punctuation">[</span>匹配值<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token operator">:</span>
        <span class="token keyword">yield</span> <span class="token string">"AAA"</span><span class="token punctuation">;</span>   <span class="token comment">//传统的:写法，通过yield指定返回结果，同样不需要break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"默认情况"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token string">"BBB"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。</p>
<p><strong>注意：</strong> switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。</p>
<h3>文本块 - 三引号</h3>
<p>如果你学习过Python，一定知道三引号：</p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment">#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span>
multi_line <span class="token operator">=</span>  <span class="token triple-quoted-string string">"""
                nice to meet you!
                  nice to meet you!
                      nice to meet you!
                """</span>
<span class="token keyword">print</span> multi_line
</code></pre></div><p>没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>可以看到，Java中也可以使用这样的三引号来表示字符串</p>
<p>我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：</p>
<figure><figcaption>alt text</figcaption></figure>
<p><strong>注意：</strong> 文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。</p>
<h3>新的instanceof语法</h3>
<p>在Java 14，instanceof迎来了一波小更新</p>
<p>比如我们之前要重写一个类的<code>equals</code>方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//首先判断是否为Student类型</span>
            <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>  <span class="token comment">//如果是，那么就类型转换</span>
            <span class="token keyword">return</span> student<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//最后比对属性是否一样</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在之前我们一直都是采用这种<strong>先判断类型，然后类型转换，最后才能使用的方式</strong></p>
<p>但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量, 只需要在比较后面加个变量名，等于比较完就强制转换</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> student<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
            <span class="token comment">//在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的</span>
            <span class="token keyword">return</span> student<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在使用<code>instanceof</code>判断类型成立后，<strong>会自动强制转换类型为指定类型</strong>，简化了我们手动转换的步骤。</p>
<p><strong>注意：</strong> 新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h3>空指针异常的改进</h3>
<p>相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//可能给进来的a或是b为null</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么为空时，就会直接：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>但是由于我们这里a和b都调用了<code>length()</code>方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）</p>
<p>但是当我们在Java 14或更高版本运行时：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>这里会明确指出是哪一个变量调用出现了空指针。</p>
<h3>记录类型 <code>record</code></h3>
<p>继类、接口、枚举、注解之后的又一新类型，"记录 <code>record</code>"</p>
<p>在Java 14中首次出场，这一出场，Lombok的噩梦来了。</p>
<p>在实际开发中，很多的类仅仅只是充当<strong>一个实体类</strong>罢了，保存的是<strong>一些不可变数据</strong></p>
<p>比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>   
    <span class="token comment">//使用Lombok，一个注解就搞定了</span>
    <span class="token class-name">String</span> username<span class="token punctuation">;</span>
    <span class="token class-name">String</span> password<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Lombok可以说是简化代码的神器了，他能在编译时自动生成<code>getter</code>和<code>setter</code>、构造方法、toString()方法等实现</p>
<p>而<strong>记录类型</strong>本质上也是一个普通的类</p>
<p>是<code>final</code>类型且继承自<code>java.lang.Record</code>抽象类</p>
<p>它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">record</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//直接把字段写在括号中</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>并且toString也是被重写了的：</p>
<figure><figcaption>alt text</figcaption></figure>
<p><code>equals()</code>方法仅做成员字段之间的值比较，也是帮助我们实现好了的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Account</span> account0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token string">"Admin"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Account</span> account1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token string">"Admin"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//两个属性都是一模一样的</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>account0<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>account1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//得到true</span>
</code></pre></div><p>是不是感觉这种类型就是专门为这种实体类而生的。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">record</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>  
    <span class="token comment">//支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：</strong> 记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h2>Java 17 新特性</h2>
<p>Java 17作为新的LTS长期维护版本</p>
<h3>密封类型 <code>sealed</code> + <code>permits</code></h3>
<p>密封类型可以说是Java 17正式推出的又一重磅类型</p>
<p>它在Java 15首次提出并测试了两个版本。</p>
<p>在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。</p>
<p>但有的时候，可能并不是所有的类我们都希望能够被继承。</p>
<p>所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p>
<p>实际上在之前我们如果<strong>不希望别人继承我们的类</strong>，可以直接添加<code>final</code>关键字：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>   <span class="token comment">//添加final关键字后，不允许对此类继承</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的</p>
<p>但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。</p>
<p>但是现在我们可以使用<strong>密封类型</strong> <code>sealed</code> 来实现这个功能：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">permits</span> <span class="token class-name">B</span><span class="token punctuation">{</span>   
    <span class="token comment">//在class关键字前添加sealed关键字，表示此类为密封类型</span>
    <span class="token comment">// permits后面跟上允许继承的类型，多个子类使用逗号隔开</span>

<span class="token punctuation">}</span>
</code></pre></div><h4>要求</h4>
<p>密封类型有以下要求：</p>
<ul>
<li>
<p>可以基于普通类、抽象类、接口，也可以是继承自其他抽象类的子类或是实现其他接口的类等。</p>
</li>
<li>
<p><strong>必须有子类继承</strong>，且不能是匿名内部类或是lambda的形式。</p>
</li>
<li>
<p><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</p>
</li>
<li>
<p>继承的子类必须<strong>显式标记</strong>为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</p>
</li>
</ul>
<p>标准的声明格式如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token punctuation">[</span><span class="token keyword">abstract</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">class</span><span class="token operator">/</span><span class="token keyword">interface</span><span class="token punctuation">]</span> 类名 <span class="token punctuation">[</span><span class="token keyword">extends</span> 父类<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">implements</span> 接口<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">permits</span> <span class="token punctuation">[</span>子类<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
        <span class="token comment">//里面的该咋写咋写</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意子类格式为：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token punctuation">[</span><span class="token keyword">final</span><span class="token operator">/</span><span class="token keyword">sealed</span><span class="token operator">/</span><span class="token keyword">non-sealed</span><span class="token punctuation">]</span> <span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类 <span class="token punctuation">{</span>
    <span class="token comment">//必须继承自父类</span>
    <span class="token comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span>
    <span class="token comment">//sealed类型：同父类，需要指定由哪些类继承。</span>
    <span class="token comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span>
<span class="token punctuation">}</span>
</code></pre></div><p>比如现在我们写了这些类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">A</span>  <span class="token keyword">permits</span> <span class="token class-name">B</span><span class="token punctuation">{</span>   <span class="token comment">//指定B继承A</span>

<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>   <span class="token comment">//在子类final，彻底封死</span>

<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到其他的类无论是继承A还是继承B都无法通过编译：</p>
<figure><figcaption>alt text</figcaption></figure>
<figure><figcaption>alt text</figcaption></figure>
<p>但是如果此时我们主动将B设定为<code>non-sealed</code>类型：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">non-sealed</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这样就可以正常继承了，因为B指定了<code>non-sealed</code>主动放弃了密封特性，这样就显得非常灵活了。</p>
<p>当然我们也可以<strong>通过反射来获取类是否为密封类型</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> a <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">isSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//是否为密封</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java8回顾</title>
      <link>http://ekkosonya.cn/code/java%209-17/javainfo.html</link>
      <guid>http://ekkosonya.cn/code/java%209-17/javainfo.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Java8回顾</source>
      <description>Java8 Lambda 表达式 匿名内部类 在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如： 在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在run()方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。 ...</description>
      <category>code</category>
      <pubDate>Sun, 27 Jul 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>Java8</h2>
<h3>Lambda 表达式</h3>
<h4>匿名内部类</h4>
<p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//现在我们想新建一个线程来搞事情</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        <span class="token comment">//创建一个实现Runnable的匿名内部类</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//具体的实现逻辑</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在创建<code>Thread</code>时，我们需要传入一个<code>Runnable</code>接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在<code>run()</code>方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p>
<h4>Lambda 使用</h4>
<p>在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减。</p>
<p>真正有用的那一部分代码，实际上就是我们对<code>run()</code>方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，现在只需要一个简短的lambda表达式即可：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//现在我们想新建一个线程来做事情</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//只需留下我们需要具体实现的方法体</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>即 原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于<code>() ‐&gt; { 代码语句 }</code>的形式进行替换即可。</p>
<p>这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p>
<blockquote>
<p>但是注意，它的底层其实并不只是<strong>简简单单的语法糖替换</strong>，而是通过<code>invokedynamic</code>指令实现的</p>
<p>匿名内部类会在编译时<strong>创建一个单独</strong>的class文件，但是lambda却不会，间接说明编译之后lambda并不是<strong>以匿名内部类的形式存在</strong>的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//现在我们想新建一个线程来做事情</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token comment">//这里我们拋个异常看看</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><figcaption>alt text</figcaption></figure>
<p>可以看到，实际上是Main类中的<code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。
所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。
比如Runnable接口需要一个方法体对它的<code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p>
</blockquote>
<h4>Lambda 具体规范</h4>
<p>Lambda表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; { 代码语句，包括返回值 }</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须<strong>有且仅有一个抽象方法</strong>（可以有多个方法，但是必须保证<strong>其他方法有默认实现</strong>，必须留一个抽象方法出来）</li>
</ul>
<p>Java中接口的方法默认是 <code>public abstract</code>, 变量默认是 <code>public static final</code></p>
<p>比如我们之前使用的Runable类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>   
<span class="token comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此，Runable的的匿名内部类实现，就可以简写为：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们也可以写一个：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   
  <span class="token comment">//接口类型</span>
    <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它的Lambda表达式的实现就可以写为：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//这里我们就简单将i转换为字符串形式</span>
</code></pre></div><p>不过还可以进行优化，首先方法参数类型是可以省略的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> i <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Test</span> test <span class="token operator">=</span> i <span class="token operator">-&gt;</span> i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>
</code></pre></div><h5>应用现有的方法函数作为方法体 (方法引用)</h5>
<p>Lambda 本质是：我们为所需要的接口<strong>提供了一个方法作为它的实现</strong></p>
<p>除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//接口中的定义</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token operator">::</span><span class="token function">impl</span><span class="token punctuation">;</span>    
    <span class="token comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">impl</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"我是已经存在的实现"</span><span class="token operator">+</span>i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来）</p>
<h4>方法引用 举例</h4>
<p>比如我们现在需要对一个数组进行排序：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//来个数组</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> o1 <span class="token operator">-</span> o2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//按从小到大的顺序排列</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是我们发现，Integer类中有一个叫做<code>compare</code>的静态方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>返回正数，第二个参数排前面，返回负数，第一个参数排前面</p>
<p>这个方法是一个静态方法，但是它却和<code>Comparator</code>需要实现的方法返回值和参数定义一模一样，所以：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//直接指定一手，效果和上面是一模一样</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>非静态方法作为方法引用</h4>
<h5>默认使用 <code>类::方法</code></h5>
<p>如果使用非静态方法，依然采用 <code>类::方法</code> 的情况</p>
<p>Lambda 会识别，然后使用相应接口的抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数来尝试调用</p>
<p>我们注意到Comparator要求我们实现的方法为：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> o1 <span class="token operator">-</span> o2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中o1和o2都是Integer类型的，我们发现Integer类中有一个<code>compareTo</code>方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> anotherInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> anotherInteger<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>只不过这个方法并不是静态的，而是对象所有：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//这样进行比较也行，和上面效果依然是一样的</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，<code>o1</code>作为目标对象，<code>o2</code>作为参数，正好匹配了<code>compareTo</code>方法，所以，直接缩写：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compareTo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//注意这里调用的不是静态方法</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5><code>对象::方法</code></h5>
<p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法</p>
<p>通过具体对象，即 <code>对象::方法</code>，这样就仿造了静态方法时的情况，此时就不会使用默认的情况(即用参数1调用方法，该方法参数为参数2)</p>
<p>而是类似 静态方法作为方法引用时，两个参数对应。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Main</span> mainObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mainObject<span class="token operator">::</span><span class="token function">reserve</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reserve</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> a<span class="token punctuation">,</span> <span class="token class-name">Integer</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//现在Main类中有一个刚好匹配的方法</span>
    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>构造方法作为方法引用</h4>
<p>当然，类的构造方法 <code>类::new</code> 同样可以作为方法引用传递：</p>
<p>类的构造方法默认返回自身对象</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//现在我们需要一个参数为String返回值为String的实现</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们发现，String类中刚好有一个：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token class-name">String</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  <span class="token comment">//由于String类的构造方法返回的肯定是一个String类型的对象，</span>
  <span class="token comment">//且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>coder <span class="token operator">=</span> original<span class="token punctuation">.</span>coder<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>于是：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>   
    <span class="token comment">//没错，构造方法直接使用new关键字就行</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。</p>
<p>Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。</p>
<h3>Optional类</h3>
<p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。</p>
<p>我们先来看看下面这个例子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>   
  <span class="token comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//那太简单了吧，直接转换打印一气呵成</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是这样实现的话，我们少考虑了一个问题，万一给进来的<code>str</code>是<code>null</code>呢？</p>
<p>如果是<code>null</code>的话，在调用<code>toLowerCase</code>方法时岂不是直接空指针异常了？</p>
<p>所以我们还得判空一下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决</p>
<p>这时，<code>Optional</code>来了，我们可以将任何的变量包装进Optional类中使用：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Optional</span>
            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>   <span class="token comment">//将str包装进Optional</span>
            <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>   
              <span class="token comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>   
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于这里只有一句打印，所以我们来优化一下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Optional</span>
            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>   <span class="token comment">//将str包装进Optional</span>
            <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p>
<p>除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"VVV"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//orElse表示如果为空就返回里面的内容</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java9 - 模块机制</title>
      <link>http://ekkosonya.cn/code/java%209-17/javainfo2.html</link>
      <guid>http://ekkosonya.cn/code/java%209-17/javainfo2.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Java9 - 模块机制</source>
      <description>Java9 Java 9的主要特性有，全新的模块机制、接口的private方法等。 模块机制 简介 当我们导入一个jar包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库 实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。 于是...</description>
      <category>code</category>
      <pubDate>Sun, 27 Jul 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>Java9</h2>
<p>Java 9的主要特性有，全新的模块机制、接口的private方法等。</p>
<h3>模块机制</h3>
<h4>简介</h4>
<p>当我们导入一个<code>jar</code>包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库</p>
<p>实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。</p>
<p>于是，Java 9引入了<strong>模块机制</strong>来对这种情况进行优化，在之前的我们的项目是这样的：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>而在引入模块机制之后：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。</p>
<h5>实现包的分离管理</h5>
<p>这里我们创建一个新的项目，并在<code>src</code>目录下，新建<code>module-info.java</code>文件表示此项目采用模块管理机制：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token class-name">NewHelloWorld</span> <span class="token punctuation">{</span>  <span class="token comment">//模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p>接着我们来创建一个主类：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>package com.ekko;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}

</code></pre></div><p>程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了</p>
<p>Java为我们提供的<code>logging</code>相关日志库，即 <code>java.util.loggin</code></p>
<p>我们发现现在不见了，实际上它就是被作为一个模块单独存在，这里我们需进行<strong>模块导入</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token class-name">NewHelloWorld</span> <span class="token punctuation">{</span>  <span class="token comment">//模块名称随便起一个就可以</span>
    <span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span>   
    <span class="token comment">//除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库</span>
    <span class="token comment">//当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se;  即可</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们导入java.logging相关模块后，就可以正常使用Logger了</p>
<p>否则，如果未在 <code>module-info.java</code> 中导入，会提示找不到</p>
<figure><figcaption>alt text</figcaption></figure>
<p>模块化机制提供了另一个级别的Java代码可见性、可访问性的控制。</p>
<h5>提高安全性</h5>
<p>尝试通过反射获取JDK提供的类中的字段：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//Java17版本的String类</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span><span class="token punctuation">,</span>
               <span class="token class-name">Constable</span><span class="token punctuation">,</span> <span class="token class-name">ConstantDesc</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Stable</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span> 
     <span class="token comment">//自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[]</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchFieldException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringClass <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token class-name">Field</span> field <span class="token operator">=</span> stringClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//这里我们通过反射来获取String类中的value字段</span>
    field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//由于是private访问权限，所以我们修改一下</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是我们发现，在程序运行之后，修改操作被阻止了：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的。</p>
<h4>介绍</h4>
<p>首先模块具有四种类型：</p>
<ul>
<li>
<p><strong>系统模块：</strong> 来自JDK和JRE的模块（官方提供的模块，比如我们上面用的）
我们也可以直接使用<code>java --list-modules</code>命令来列出所有的模块，不同的模块会导出不同的包供我们使用。</p>
</li>
<li>
<p><strong>应用程序模块：</strong> 我们自己写的Java模块项目。</p>
</li>
<li>
<p><strong>自动模块：</strong> 可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是<strong>直接导出所有的包</strong>，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。</p>
</li>
<li>
<p><strong>未命名模块：</strong> 我们自己创建的一个Java项目，如果没有创建<code>module-info.java</code>，那么会按照未命名模块进行处理
未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。
不过，由于没有使用Java 9的模块新特性，未命名模块只能<strong>默认暴露给其他未命名的模块和自动模块</strong>，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）</p>
</li>
</ul>
<h4>例子</h4>
<p>这里我们就来创建两个项目，看看如何使用模块机制</p>
<p>首先我们在项目A中，添加一个<code>User</code>类，然后在项目B使用：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token operator">+</span><span class="token string">" ("</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁)"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着我们编写一下项目A的模块设置：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们将<code>com.test</code>包下所有内容都暴露出去，默认情况下<strong>所有的包都是私有</strong>的，就算其他项目将此项目作为依赖也无法使用。</p>
<p>接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b <span class="token punctuation">{</span>
    <span class="token keyword">requires</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们就可以在Main类中使用模块<code>module.a</code>中暴露出来的包内容了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span><span class="token class-name">User</span></span><span class="token punctuation">;</span>   
<span class="token comment">//如果模块module.a不暴露，那么将无法导入</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"penguin"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然除了普通的<code>exports</code>进行包的暴露之外，我们也可以直接指定将包暴露给<strong>指定的模块</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>   
    <span class="token comment">//这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用</span>
<span class="token punctuation">}</span>
</code></pre></div><h5>依赖传递 <code>transitive</code></h5>
<p>如果模块<code>module.a</code>依赖于其他模块，那么会不会传递给依赖于模块<code>module.a</code>的模块呢？</p>
<p>默认是不传递的</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>   <span class="token comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span>
    <span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span>   <span class="token comment">//这里添加一个模块的依赖</span>
<span class="token punctuation">}</span>
</code></pre></div><figure><figcaption>alt text</figcaption></figure>
<p>可以看到，在模块<code>module.b</code>中，并<strong>没有进行依赖传递</strong>，说明哪个模块导入的依赖只能哪个模块用</p>
<p>但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>   
    <span class="token comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span>
    <span class="token keyword">requires</span> <span class="token keyword">transitive</span> <span class="token namespace">java<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span>   
    <span class="token comment">//使用transitive来向其他模块传递此依赖</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在就可以使用了：</p>
<figure><figcaption>alt text</figcaption></figure>
<h5>开启反射 <code>open</code></h5>
<p>还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的</p>
<p>那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">open</span> <span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>   
  <span class="token comment">//直接添加open关键字开放整个模块的反射权限</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
    <span class="token keyword">opens</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>   
    <span class="token comment">//通过使用opens关键字来为其他模块开放反射权限</span>
    <span class="token comment">//也可以指定目标开放反射 opens com.test to module.b;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5>指定实现 <code>uses</code> + <code>provides</code></h5>
<p>我们还可以指定模块需要使用的抽象类或是接口实现：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">open</span> <span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token keyword">to</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
    <span class="token keyword">uses</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span>  
    <span class="token comment">//使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以在模块B中去实现一下，然后声明我们提供了实现类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>main</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token keyword">module</span><span class="token punctuation">.</span>b <span class="token punctuation">{</span>
    <span class="token keyword">requires</span> <span class="token keyword">module</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>   <span class="token comment">//导入项目A的模块，此模块暴露了com.test包</span>
    <span class="token keyword">provides</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span><span class="token class-name">Test</span> <span class="token keyword">with</span> <span class="token namespace">com<span class="token punctuation">.</span>main<span class="token punctuation">.</span></span><span class="token class-name">TestImpl</span><span class="token punctuation">;</span>  <span class="token comment">//声明此模块提供了Test的实现类</span>
<span class="token punctuation">}</span>
</code></pre></div><h5>简单使用</h5>
<p>了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目</p>
<p>然后我们导入了lombok框架的依赖，如果我们不创建<code>module-info.java</code>文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>java<span class="token punctuation">.</span></span><span class="token class-name">Log</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Log</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//使用lombok提供的注解，可以正常运行</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好<code>module-info.java</code>文件：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们还需要去依赖对应的模块：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span> <span class="token punctuation">{</span>
    <span class="token keyword">requires</span> <span class="token namespace">lombok</span><span class="token punctuation">;</span>   <span class="token comment">//lombok模块</span>
    <span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span>    <span class="token comment">//JUL日志模块，也需要使用到</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们就可以正常使用了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java9 - 2</title>
      <link>http://ekkosonya.cn/code/java%209-17/javainfo3.html</link>
      <guid>http://ekkosonya.cn/code/java%209-17/javainfo3.html</guid>
      <source url="http://ekkosonya.cn/rss.xml">Java9 - 2</source>
      <description>Java9 JShell交互式编程 Java 9为我们通过了一种交互式编程工具JShell alt textalt text 环境配置完成后，我们只需要输入jshell命令即可开启交互式编程了，它支持我们一条一条命令进行操作。 比如我们来做一个简单的计算： alt textalt text 我们一次输入一行（可以不加分号），先定义一个a=10和b=10...</description>
      <category>code</category>
      <pubDate>Sun, 27 Jul 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>Java9</h2>
<h3>JShell交互式编程</h3>
<p>Java 9为我们通过了一种交互式编程工具<code>JShell</code></p>
<figure><figcaption>alt text</figcaption></figure>
<p>环境配置完成后，我们只需要输入<code>jshell</code>命令即可开启交互式编程了，它支持我们一条一条命令进行操作。</p>
<p>比如我们来做一个简单的计算：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。</p>
<figure><figcaption>alt text</figcaption></figure>
<p>我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>除了直接运行我们写进去的代码之外，它还支持使用命令，输入<code>help</code>来查看命令列表：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>比如我们可以使用<code>/vars</code>命令来展示当前定义的变量列表：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>当我们不想使用jshell时，直接输入<code>/exit</code>退出即可</p>
<h3>接口中的private方法</h3>
<p>接口中的方法默认是 <code>public abstract</code></p>
<p>在Java 8中，接口中 的方法支持添加<code>default</code>关键字来添加默认实现：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是test方法默认实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而在Java 9中，接口再次得到强化，现在接口中可以存在<strong>私有方法</strong>了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是test方法默认实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
        <span class="token comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   
        <span class="token comment">//声明一个私有方法</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是接口中的私有方法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。</p>
<h3>集合类新增工厂方法 <code>xx.of()</code></h3>
<p>在之前，如果我们想要快速创建一个Map只能：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//要快速使用Map，需要先创建一个Map对象，然后再添加数据</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"BBB"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而在Java 9之后，我们可以直接通过<code>of</code>方法来快速创建了：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"BBB"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//直接一句搞定</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：</p>
<figure><figcaption>alt text</figcaption></figure>
<p>但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是<strong>无法进行修改</strong>的。</p>
<p>当然，除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"BBB"</span><span class="token punctuation">,</span> <span class="token string">"CCC"</span><span class="token punctuation">,</span> <span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//注意Set中元素顺序并不一定你的添加顺序</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">,</span> <span class="token string">"CCC"</span><span class="token punctuation">,</span> <span class="token string">"BBB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//好耶，再也不用Arrays了</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>改进的 Stream API</h3>
<p>这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span>
            <span class="token comment">//这里我们可以直接将一些元素封装到Stream中</span>
            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">//通过过滤器过滤</span>
            <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">//去重</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//最后打印</span>
<span class="token punctuation">}</span>
</code></pre></div><p>自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成</p>
<p>如此方便的框架，在Java 9得到了进一步的增强：</p>
<h4><code>ofNullable</code></h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token comment">//如果传入null会报错</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> 
            <span class="token comment">//使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>利用 <code>Stream</code> 来迭代生成数据 <code>iterate</code></h4>
<p>还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">//Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。</span>
            <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>   <span class="token comment">//这里限制生成20个</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token comment">//不知道怎么写？参考一下：for (int i = 0;i &lt; 20;i++)</span>
            <span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>数据截断 <code>takeWhile</code> + <code>dropWhile</code></h4>
<p>Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">takeWhile</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>   <span class="token comment">//当i小于10时正常通过，一旦大于等于10直接截断</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stream</span>
            <span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-&gt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">dropWhile</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>   
            <span class="token comment">//和上面相反，上来就是截断状态，只有当满足条件时再开始通过</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但实际上还是遍历了20个，只不过会删除其他不符合条件的</p>
<h3>其他小型变动</h3>
<p><code>Try-with-resource</code>语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">newInputStream</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"pom.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//单独丢进try中，效果是一样的</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在Java 8中引入了<code>Optional</code>类，它很好的解决了判空问题：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//比如现在我们想执行 System.out.println(str.toLowerCase())</span>
    <span class="token comment">//但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常</span>
    <span class="token comment">//但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装</span>
    <span class="token class-name">Optional</span>
            <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>str <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种写法就有点像Kotlin或是JS中的语法：</p>
<div class="language-kotlin" data-ext="kt" data-title="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>str <span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//传入的String对象可能为null，这里类型写为String?</span>
    <span class="token function">println</span><span class="token punctuation">(</span>str<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">lowercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// ?.表示只有不为空才进行调用</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在Java 9新增了一些更加方便的操作：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresentOrElse</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">//通过使用ifPresentOrElse，我们同时处理两种情况</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被包装的元素为："</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//第一种情况和ifPresent是一样的</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被包装的元素为null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//第二种情况是如果为null的情况</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们也可以使用<code>or()</code>方法快速替换为另一个Optional类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装</span>
      <span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然还支持直接转换为Stream，这里就不多说了。</p>
<p>在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>   <span class="token comment">//这里我们写一个泛型类</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">T</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"AAA"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢</span>
        <span class="token comment">//在Java 9之后，这样的写法终于可以编译通过了</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> t<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>