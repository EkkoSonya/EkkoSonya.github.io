const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":947,\"nextId\":947,\"documentIds\":{\"0\":\"2\",\"1\":\"2@0\",\"2\":\"2@1\",\"3\":\"3\",\"4\":\"3#类与对象\",\"5\":\"3#方法的创建与使用\",\"6\":\"3#方法的进阶使用\",\"7\":\"3#this-的使用\",\"8\":\"3#方法的重载\",\"9\":\"3#构造方法\",\"10\":\"3@0\",\"11\":\"3@1\",\"12\":\"4\",\"13\":\"4#泛型-2\",\"14\":\"4#泛型方法\",\"15\":\"4#泛型界限\",\"16\":\"4#类型擦除\",\"17\":\"4@0\",\"18\":\"4@1\",\"19\":\"5\",\"20\":\"5#集合类-1\",\"21\":\"5#集合类\",\"22\":\"5#集合类与数组区别\",\"23\":\"5#集合根接口\",\"24\":\"5#list-列表\",\"25\":\"5#arraylist\",\"26\":\"5@0\",\"27\":\"5@1\",\"28\":\"6\",\"29\":\"6#集合类-2\",\"30\":\"6#迭代器\",\"31\":\"6#iterator-简介\",\"32\":\"6#源码定义\",\"33\":\"6#不同集合类-迭代器-实现用例\",\"34\":\"6#使用示例\",\"35\":\"6#其他遍历-集合类-的方式\",\"36\":\"6#iterable-介绍\",\"37\":\"6#listiterator-介绍\",\"38\":\"6@0\",\"39\":\"6@1\",\"40\":\"7\",\"41\":\"7#集合类-3\",\"42\":\"7#quene-和-deque\",\"43\":\"7#quene-队列\",\"44\":\"7#deque-双端队列\",\"45\":\"7#其他集合类实现-队列\",\"46\":\"7#优先级队列\",\"47\":\"7#set-集合\",\"48\":\"7#hashset\",\"49\":\"7#linkedhashset\",\"50\":\"7#treeset\",\"51\":\"7@0\",\"52\":\"7@1\",\"53\":\"8\",\"54\":\"8#集合类-4\",\"55\":\"8#map\",\"56\":\"8#map-基本定义\",\"57\":\"8#hashmap\",\"58\":\"8#hashmap-底层实现\",\"59\":\"8#put-方法\",\"60\":\"8#resize-方法\",\"61\":\"8#linkedhashmap\",\"62\":\"8#treemap\",\"63\":\"8#map-的一些方法\",\"64\":\"8#compute\",\"65\":\"8#merge\",\"66\":\"8#replace\",\"67\":\"8#hashset-底层实现\",\"68\":\"8@0\",\"69\":\"8@1\",\"70\":\"9\",\"71\":\"9#stream流\",\"72\":\"9@0\",\"73\":\"9@1\",\"74\":\"10\",\"75\":\"10#collections-工具类\",\"76\":\"10#最大-最小\",\"77\":\"10#二分搜索\",\"78\":\"10#快速填充\",\"79\":\"10#空集合\",\"80\":\"10#查找位置\",\"81\":\"10@0\",\"82\":\"10@1\",\"83\":\"11\",\"84\":\"11#集合类对象相等判定\",\"85\":\"11@0\",\"86\":\"11@1\",\"87\":\"12\",\"88\":\"12#io流1\",\"89\":\"12#文件字节流\",\"90\":\"12#输入流-java-io-fileinputstream\",\"91\":\"12#文件读取\",\"92\":\"12#输出流-java-io-fileoutputstream\",\"93\":\"12#追加操作\",\"94\":\"12#文件拷贝操作实现\",\"95\":\"12#文件字符流\",\"96\":\"12#filereader\",\"97\":\"12#filewriter\",\"98\":\"12#file类\",\"99\":\"12@0\",\"100\":\"12@1\",\"101\":\"13\",\"102\":\"13#io流2\",\"103\":\"13#缓冲流\",\"104\":\"13#缓冲字节流\",\"105\":\"13#缓冲字节读取流-bufferedinputstream\",\"106\":\"13#缓冲流特性\",\"107\":\"13#_1-装饰着模式\",\"108\":\"13#_2-缓冲机制\",\"109\":\"13#_3-缓冲流可以叠加\",\"110\":\"13#缓冲字节输出流-bufferedoutputstream\",\"111\":\"13#缓冲字符流\",\"112\":\"13#缓冲字符读取流-bufferedreader\",\"113\":\"13#缓冲字符输出流-bufferedwriter\",\"114\":\"13@0\",\"115\":\"13@1\",\"116\":\"14\",\"117\":\"14#静态变量和静态方法\",\"118\":\"14#静态变量初始化\",\"119\":\"14#包的访问与控制\",\"120\":\"14#包的声明和导入\",\"121\":\"14#访问权限控制\",\"122\":\"14@0\",\"123\":\"14@1\",\"124\":\"15\",\"125\":\"15#io流3\",\"126\":\"15#转换流\",\"127\":\"15#打印流-printstream\",\"128\":\"15#输入流\",\"129\":\"15#数据流-datainputstream\",\"130\":\"15#对象流\",\"131\":\"15#对象序列化\",\"132\":\"15#serialversionuid\",\"133\":\"15#transient关键字\",\"134\":\"15@0\",\"135\":\"15@1\",\"136\":\"16\",\"137\":\"16#多线程\",\"138\":\"16#进程与线程概念\",\"139\":\"16#线程的创建和启动\",\"140\":\"16#start方法\",\"141\":\"16#run方法\",\"142\":\"16#sleep方法\",\"143\":\"16#线程的休眠和中断\",\"144\":\"16#中断\",\"145\":\"16#线程优先级\",\"146\":\"16#线程的礼让和加入\",\"147\":\"16#yield-主动让出cpu资源\",\"148\":\"16#join\",\"149\":\"16@0\",\"150\":\"16@1\",\"151\":\"17\",\"152\":\"17#多线程2\",\"153\":\"17#线程锁和线程同步\",\"154\":\"17#多线程下java内存管理\",\"155\":\"17#线程锁-synchronized\",\"156\":\"17#死锁\",\"157\":\"17@0\",\"158\":\"17@1\",\"159\":\"18\",\"160\":\"18#多线程3\",\"161\":\"18#wait-和-notify-方法\",\"162\":\"18#threadlocal\",\"163\":\"18#inheritablethreadlocal\",\"164\":\"18#定时器-timer\",\"165\":\"18#自己定义的定时器\",\"166\":\"18#timer\",\"167\":\"18#timer-不会终止\",\"168\":\"18@0\",\"169\":\"18@1\",\"170\":\"19\",\"171\":\"19#多线程4\",\"172\":\"19#守护线程\",\"173\":\"19#集合类\",\"174\":\"19#生产者与消费者\",\"175\":\"19@0\",\"176\":\"19@1\",\"177\":\"20\",\"178\":\"20#反射1\",\"179\":\"20#反射\",\"180\":\"20#java-类加载机制\",\"181\":\"20#class-类\",\"182\":\"20#获取相应类的class对象\",\"183\":\"20#基本数据类型的-class-对象\",\"184\":\"20#数组的-class-对象\",\"185\":\"20#class-对象与多态\",\"186\":\"20#类型比较\",\"187\":\"20@0\",\"188\":\"20@1\",\"189\":\"21\",\"190\":\"21#反射2\",\"191\":\"21#创建类对象-getconstructor-newinstance\",\"192\":\"21#调用类方法-getmethod-getdeclaredmethod\",\"193\":\"21#修改类的属性-getfield\",\"194\":\"21@0\",\"195\":\"21@1\",\"196\":\"22\",\"197\":\"22#反射3\",\"198\":\"22#类加载器-appclassloader-extclassloader-bootstarpclassloader\",\"199\":\"22#自己编译的类加载到-jvm-中\",\"200\":\"22@0\",\"201\":\"22@1\",\"202\":\"23\",\"203\":\"23#注解\",\"204\":\"23#预设注解\",\"205\":\"23#元注解\",\"206\":\"23#override定义\",\"207\":\"23#注解的使用\",\"208\":\"23#反射获取注解-getannotation\",\"209\":\"23@0\",\"210\":\"23@1\",\"211\":\"24\",\"212\":\"24#封装-继承和多态\",\"213\":\"24#封装\",\"214\":\"24#继承\",\"215\":\"24#object-类\",\"216\":\"24#方法重写-override\",\"217\":\"24#控制符-final\",\"218\":\"24#抽象类-abstract\",\"219\":\"24#接口-interface\",\"220\":\"24#object类中的-克隆方法\",\"221\":\"24#枚举类-enum\",\"222\":\"24@0\",\"223\":\"24@1\",\"224\":\"25\",\"225\":\"25#面向对象高级篇1\",\"226\":\"25#基本类型包装类\",\"227\":\"25#所有包装类如下\",\"228\":\"25#包装类的方法\",\"229\":\"25#特殊包装类\",\"230\":\"25@0\",\"231\":\"25@1\",\"232\":\"26\",\"233\":\"26#面向对象高级篇-2\",\"234\":\"26#数组\",\"235\":\"26#定义\",\"236\":\"26#方法\",\"237\":\"26#访问元素\",\"238\":\"26#特性\",\"239\":\"26#final性质\",\"240\":\"26#多维数组\",\"241\":\"26#可变长参数\",\"242\":\"26#main函数的-string-args\",\"243\":\"26#字符串\",\"244\":\"26#string-类\",\"245\":\"26#stringbuilder-类\",\"246\":\"26#正则表达式\",\"247\":\"26@0\",\"248\":\"26@1\",\"249\":\"27\",\"250\":\"27#内部类\",\"251\":\"27#成员内部类-属于-对象\",\"252\":\"27#静态内部类-属于-类\",\"253\":\"27#局部内部类\",\"254\":\"27#静态内部类编译特性\",\"255\":\"27#匿名内部类\",\"256\":\"27#匿名内部类特性\",\"257\":\"27#lambda表达式\",\"258\":\"27#方法引用\",\"259\":\"27@0\",\"260\":\"27@1\",\"261\":\"28\",\"262\":\"28#面向对象高级篇-4\",\"263\":\"28#异常机制\",\"264\":\"28#异常类型\",\"265\":\"28#自定义异常\",\"266\":\"28#抛出异常-throw\",\"267\":\"28#异常的处理-try-catch-finally\",\"268\":\"28#断言表达式-assert\",\"269\":\"28@0\",\"270\":\"28@1\",\"271\":\"29\",\"272\":\"29#面向对象高级篇-6\",\"273\":\"29#常用工具类\",\"274\":\"29#数学工具类-math\",\"275\":\"29#数组工具类-arrays\",\"276\":\"29@0\",\"277\":\"29@1\",\"278\":\"30\",\"279\":\"30#泛型-1\",\"280\":\"30#使用泛型的原因\",\"281\":\"30#泛型类-classname-t\",\"282\":\"30#泛型和多态\",\"283\":\"30@0\",\"284\":\"30@1\",\"285\":\"31\",\"286\":\"31#java8\",\"287\":\"31#lambda-表达式\",\"288\":\"31#匿名内部类\",\"289\":\"31#lambda-使用\",\"290\":\"31#lambda-具体规范\",\"291\":\"31#应用现有的方法函数作为方法体-方法引用\",\"292\":\"31#方法引用-举例\",\"293\":\"31#非静态方法作为方法引用\",\"294\":\"31#默认使用-类-方法\",\"295\":\"31#对象-方法\",\"296\":\"31#构造方法作为方法引用\",\"297\":\"31#optional类\",\"298\":\"31@0\",\"299\":\"31@1\",\"300\":\"32\",\"301\":\"32#java9\",\"302\":\"32#模块机制\",\"303\":\"32#简介\",\"304\":\"32#实现包的分离管理\",\"305\":\"32#提高安全性\",\"306\":\"32#介绍\",\"307\":\"32#例子\",\"308\":\"32#依赖传递-transitive\",\"309\":\"32#开启反射-open\",\"310\":\"32#指定实现-uses-provides\",\"311\":\"32#简单使用\",\"312\":\"32@0\",\"313\":\"32@1\",\"314\":\"33\",\"315\":\"33#java9\",\"316\":\"33#jshell交互式编程\",\"317\":\"33#接口中的private方法\",\"318\":\"33#集合类新增工厂方法-xx-of\",\"319\":\"33#改进的-stream-api\",\"320\":\"33#ofnullable\",\"321\":\"33#利用-stream-来迭代生成数据-iterate\",\"322\":\"33#数据截断-takewhile-dropwhile\",\"323\":\"33#其他小型变动\",\"324\":\"33@0\",\"325\":\"33@1\",\"326\":\"34\",\"327\":\"34#java10\",\"328\":\"34#局部变量类型推断-var\",\"329\":\"34#java11\",\"330\":\"34#用于lambda的形参局部变量语法\",\"331\":\"34#针对于string类的方法增强\",\"332\":\"34#全新的httpclient使用\",\"333\":\"34#httpclient类使用\",\"334\":\"34@0\",\"335\":\"34@1\",\"336\":\"35\",\"337\":\"35#java-12-16-新特性\",\"338\":\"35#新的switch语法\",\"339\":\"35#switch-新语法\",\"340\":\"35#详细规则\",\"341\":\"35#文本块-三引号\",\"342\":\"35#新的instanceof语法\",\"343\":\"35#空指针异常的改进\",\"344\":\"35#记录类型-record\",\"345\":\"35#java-17-新特性\",\"346\":\"35#密封类型-sealed-permits\",\"347\":\"35#要求\",\"348\":\"35@0\",\"349\":\"35@1\",\"350\":\"36\",\"351\":\"36#consumer\",\"352\":\"36#接口声明\",\"353\":\"36#accept\",\"354\":\"36#addthen\",\"355\":\"36#optional\",\"356\":\"36#stream\",\"357\":\"36#特点\",\"358\":\"36#操作\",\"359\":\"36#创建流\",\"360\":\"36#操作流\",\"361\":\"36#过滤-filter\",\"362\":\"36#映射-map\",\"363\":\"36#匹配\",\"364\":\"36#组合-reduce\",\"365\":\"36#转换流-collect\",\"366\":\"36#builder\",\"367\":\"36#建造者模式\",\"368\":\"36#lombok-中的-builder\",\"369\":\"36@0\",\"370\":\"36@1\",\"371\":\"37\",\"372\":\"37@0\",\"373\":\"37@1\",\"374\":\"38\",\"375\":\"38@0\",\"376\":\"38@1\",\"377\":\"39\",\"378\":\"39#主要动机\",\"379\":\"39#主要贡献\",\"380\":\"39#主要内容\",\"381\":\"39#系统结构\",\"382\":\"39#基本设置\",\"383\":\"39#信号模型\",\"384\":\"39#quality-of-experience-model\",\"385\":\"39#优化问题建立\",\"386\":\"39#解决方案\",\"387\":\"39#无人机的3d部署\",\"388\":\"39#无人机的动态移动设计\",\"389\":\"39@0\",\"390\":\"39@1\",\"391\":\"40\",\"392\":\"40#强化学习框架图\",\"393\":\"40#_1-基本概念\",\"394\":\"40#_2-markov-decision-process-mdp\",\"395\":\"40@0\",\"396\":\"40@1\",\"397\":\"41\",\"398\":\"41#_1-the-simplest-actor-critic-qac\",\"399\":\"41#_2-advantage-actor-critic-a2c\",\"400\":\"41#_2-1-baseline\",\"401\":\"41#_2-2-最好的-baseline\",\"402\":\"41#_2-3-对应算法\",\"403\":\"41#_3-off-policy-actor-critic\",\"404\":\"41#_3-1-重要性采样-importance-sampling\",\"405\":\"41#_3-2-off-policy\",\"406\":\"41#_3-3-伪代码\",\"407\":\"41#_4-deterministic-actor-critic-dpg\",\"408\":\"41@0\",\"409\":\"41@1\",\"410\":\"42\",\"411\":\"42#核心内容\",\"412\":\"42#_1-state-value\",\"413\":\"42#_1-1\",\"414\":\"42#_1-2-state-value\",\"415\":\"42#_1-3-state-value-与-return-的区别\",\"416\":\"42#_2-bellman-equation\",\"417\":\"42#_2-1-the-mean-of-immediate-rewards\",\"418\":\"42#_2-2-the-mean-of-future-rewards\",\"419\":\"42#_2-3-bellman-equation\",\"420\":\"42#_2-4-bellman-equation-matrix-vector-form\",\"421\":\"42#_3-why-to-slove-state-value\",\"422\":\"42#_4-action-value\",\"423\":\"42#_5-总结\",\"424\":\"42@0\",\"425\":\"42@1\",\"426\":\"43\",\"427\":\"43#_1-optimal-policy\",\"428\":\"43#_2-bellman-optimality-equation-boe\",\"429\":\"43#_2-1-基本形式\",\"430\":\"43#_2-2-如何求解\",\"431\":\"43#_2-2-1-如何处理等式右边的-最优策略\",\"432\":\"43#_2-求解-state-value\",\"433\":\"43@0\",\"434\":\"43@1\",\"435\":\"44\",\"436\":\"44#_1-value-iteration-algorithm\",\"437\":\"44#_1-1-具体步骤\",\"438\":\"44#_1-2-伪代码\",\"439\":\"44#_2-policy-iteration-algorithm\",\"440\":\"44#_2-1-算法描述\",\"441\":\"44#_2-2-伪代码\",\"442\":\"44#_2-3-一些问题\",\"443\":\"44#_3-truncated-policy-iteration-algorithm\",\"444\":\"44#_3-1-value-iteration-与-policy-iteration-算法比较\",\"445\":\"44#_3-2-truncated-policy-iteration-algorithm\",\"446\":\"44#truncated-policy-iteration-algorithm-是否是收敛的\",\"447\":\"44@0\",\"448\":\"44@1\",\"449\":\"45\",\"450\":\"45#_1-mc-basic\",\"451\":\"45#_1-1-算法思路\",\"452\":\"45#_1-2-如何估计\",\"453\":\"45#_1-3-具体算法\",\"454\":\"45#_2-mc-exploring-starts\",\"455\":\"45#_2-1-episode-的高效利用\",\"456\":\"45#_2-2-高效地更新-policy\",\"457\":\"45#_2-3-mc-exploring-starts\",\"458\":\"45#_2-4-exploring-statrts的解释\",\"459\":\"45#_3-mc-eplison-greedy\",\"460\":\"45#_3-1-soft-policy\",\"461\":\"45#_3-2-greedy-policy\",\"462\":\"45#_3-3-greedy-policy-引入-mc-based-算法中\",\"463\":\"45#_3-3-算法流程\",\"464\":\"45@0\",\"465\":\"45@1\",\"466\":\"46\",\"467\":\"46#_1-引言\",\"468\":\"46#_1-1-求均值的方法\",\"469\":\"46#_2-robbins-monto-rm-algorithm\",\"470\":\"46#_2-1-问题引入\",\"471\":\"46#_2-2-算法介绍\",\"472\":\"46#_2-3-收敛性分析\",\"473\":\"46#_2-4-应用于-mean-estimation-中\",\"474\":\"46#_3-stochastic-gradient-descent\",\"475\":\"46#_3-1-问题引入\",\"476\":\"46#_3-2-sgd-分析\",\"477\":\"46#mean-estimation-问题转化\",\"478\":\"46#sgd-正确性和收敛性分析\",\"479\":\"46#_3-3-sgd-另一种问题描述方法-deterministic-formulation\",\"480\":\"46#_3-4-bgd-mbgd-sgdw\",\"481\":\"46@0\",\"482\":\"46@1\",\"483\":\"47\",\"484\":\"47#_1-引入\",\"485\":\"47#_2-td-learning-of-state-value\",\"486\":\"47#_2-1-算法描述\",\"487\":\"47#_2-2-算法分析\",\"488\":\"47#_2-3-td-算法-与-mc-算法的比较\",\"489\":\"47#_3-td-learning-of-action-value\",\"490\":\"47#_3-1-sarsa\",\"491\":\"47#_3-2-n-step-sarsa\",\"492\":\"47#_3-3-expected-sarsa\",\"493\":\"47#_4-td-learning-of-optimal-action-value\",\"494\":\"47#_4-1-q-learning\",\"495\":\"47#_4-2-off-policy-on-policy\",\"496\":\"47#on-policy\",\"497\":\"47#off-policy\",\"498\":\"47#_4-3-q-learning-伪代码\",\"499\":\"47#off-poicy-版本\",\"500\":\"47#on-policy-版本\",\"501\":\"47#_5-td-算法的统一形式和总结\",\"502\":\"47@0\",\"503\":\"47@1\",\"504\":\"48\",\"505\":\"48#_1-引入\",\"506\":\"48#_2-alogorithm-of-state-value-estimation\",\"507\":\"48#_2-1-obejctive-function\",\"508\":\"48#uniform-distributon\",\"509\":\"48#stationary-distribution\",\"510\":\"48#_2-2-optimization-algorithms-优化算法\",\"511\":\"48#monte-carlo-learning-with-function-approximation\",\"512\":\"48#td-learning-with-function-approximation\",\"513\":\"48#_3-sarsa-with-function-approximation\",\"514\":\"48#_4-q-learning-with-function-approximation\",\"515\":\"48#_5-deep-q-learning-dqn\",\"516\":\"48#优化方法\",\"517\":\"48#经验回放-replay-buffer\",\"518\":\"48#伪代码\",\"519\":\"48@0\",\"520\":\"48@1\",\"521\":\"49\",\"522\":\"49#_1-基本思路\",\"523\":\"49#_2-目标函数定义\",\"524\":\"49#_2-1-average-state-value\",\"525\":\"49#另一种表达\",\"526\":\"49#d-s-的选择\",\"527\":\"49#_2-2-average-return-value\",\"528\":\"49#另一种表达-1\",\"529\":\"49#_3-目标函数梯度求解\",\"530\":\"49#_4-reinforce-梯度上升算法\",\"531\":\"49#reinforce-算法\",\"532\":\"49@0\",\"533\":\"49@1\",\"534\":\"50\",\"535\":\"50#socket\",\"536\":\"50#socket-连接示例\",\"537\":\"50#使用socket进行数据传输\",\"538\":\"50#杂项\",\"539\":\"50@0\",\"540\":\"50@1\",\"541\":\"51\",\"542\":\"51#socket2\",\"543\":\"51#socket-传输文件\",\"544\":\"51#使用浏览器访问socket服务器\",\"545\":\"51@0\",\"546\":\"51@1\",\"547\":\"52\",\"548\":\"52#数据库-1\",\"549\":\"52#简介\",\"550\":\"52#数据模型\",\"551\":\"52#数据库创建\",\"552\":\"52#数据库的规范化\",\"553\":\"52#第一范式-1nf\",\"554\":\"52#第二范式-2nf\",\"555\":\"52#第三范式-3nf\",\"556\":\"52#bcnf\",\"557\":\"52@0\",\"558\":\"52@1\",\"559\":\"53\",\"560\":\"53#数据库-2\",\"561\":\"53#sql-语句\",\"562\":\"53#数据库定义语言-ddl\",\"563\":\"53#sql数据类型\",\"564\":\"53#列级约束条件\",\"565\":\"53#表级约束条件\",\"566\":\"53#数据库操作\",\"567\":\"53#创建表-create\",\"568\":\"53#修改表-alter\",\"569\":\"53#删除表-drop\",\"570\":\"53#数据库操纵语言-dml\",\"571\":\"53#插入数据-insert-into\",\"572\":\"53#修改数据-update\",\"573\":\"53#删除数据\",\"574\":\"53@0\",\"575\":\"53@1\",\"576\":\"54\",\"577\":\"54#数据库-3\",\"578\":\"54#数据库查询语言-dql\",\"579\":\"54#单表查询-selecet\",\"580\":\"54#常用where查询条件\",\"581\":\"54#排序查询-order-by\",\"582\":\"54#聚集函数\",\"583\":\"54#分组和分页查询\",\"584\":\"54#多表查询\",\"585\":\"54#自身连接查询\",\"586\":\"54#外连接查询\",\"587\":\"54#嵌套查询\",\"588\":\"54#数据库控制语言-dcl\",\"589\":\"54#创建用户\",\"590\":\"54#登陆用户\",\"591\":\"54#用户授权\",\"592\":\"54@0\",\"593\":\"54@1\",\"594\":\"55\",\"595\":\"55#数据库-4\",\"596\":\"55#视图\",\"597\":\"55#索引\",\"598\":\"55#触发器\",\"599\":\"55#事务\",\"600\":\"55@0\",\"601\":\"55@1\",\"602\":\"56\",\"603\":\"56#主要内容\",\"604\":\"56#jdbc\",\"605\":\"56#使用jdbc连接数据库\",\"606\":\"56#drivermanager\",\"607\":\"56#了解connection\",\"608\":\"56#了解statement\",\"609\":\"56@0\",\"610\":\"56@1\",\"611\":\"57\",\"612\":\"57#jdbc\",\"613\":\"57#执行dml操作-executeupdate\",\"614\":\"57#执行dql操作-executequery\",\"615\":\"57#执行批处理操作-addbatch\",\"616\":\"57#将查询结果映射为对象\",\"617\":\"57@0\",\"618\":\"57@1\",\"619\":\"58\",\"620\":\"58#jdbc\",\"621\":\"58#实现登陆与sql注入攻击\",\"622\":\"58#使用preparedstatement\",\"623\":\"58#管理事务\",\"624\":\"58@0\",\"625\":\"58@1\",\"626\":\"59\",\"627\":\"59#lombok1\",\"628\":\"59#配置lombok\",\"629\":\"59#使用lombok\",\"630\":\"59@0\",\"631\":\"59@1\",\"632\":\"60\",\"633\":\"60#mybatis1\",\"634\":\"60#xml语言\",\"635\":\"60#转义字符\",\"636\":\"60#解析xml文件\",\"637\":\"60@0\",\"638\":\"60@1\",\"639\":\"61\",\"640\":\"61#mybatis2\",\"641\":\"61#初次使用-mybatis\",\"642\":\"61#sqlsessionfactory\",\"643\":\"61#直接读取实体类\",\"644\":\"61@0\",\"645\":\"61@1\",\"646\":\"62\",\"647\":\"62#mybatis详解1\",\"648\":\"62#查询操作\",\"649\":\"62#别名\",\"650\":\"62#hashmap-转换\",\"651\":\"62#多参数查询\",\"652\":\"62#resultmap\",\"653\":\"62#查询列表操作\",\"654\":\"62@0\",\"655\":\"62@1\",\"656\":\"63\",\"657\":\"63#mybatis详解2\",\"658\":\"63#指定构造方法\",\"659\":\"63#接口绑定-sqlsession-getmapper-xxx-class\",\"660\":\"63#多参数表示\",\"661\":\"63@0\",\"662\":\"63@1\",\"663\":\"64\",\"664\":\"64#mybatis详解3\",\"665\":\"64#复杂查询\",\"666\":\"64#一对一查询\",\"667\":\"64#嵌套结果映射-association\",\"668\":\"64#嵌套-select-查询-select-association\",\"669\":\"64#mybatis日志\",\"670\":\"64#一对多查询-查询一个-返回多个\",\"671\":\"64#嵌套查询\",\"672\":\"64#多对一查询-多-多\",\"673\":\"64@0\",\"674\":\"64@1\",\"675\":\"65\",\"676\":\"65#mybatis详解4\",\"677\":\"65#dml-操作\",\"678\":\"65#插入-insert标签\",\"679\":\"65#自增主键id-usegeneratedkeys\",\"680\":\"65#修改-update标签\",\"681\":\"65#删除\",\"682\":\"65#事务操作\",\"683\":\"65@0\",\"684\":\"65@1\",\"685\":\"66\",\"686\":\"66#mybatis详解5\",\"687\":\"66#动态sql\",\"688\":\"66#批处理-executortype-batch\",\"689\":\"66#动态sql介绍\",\"690\":\"66#条件判断-if标签\",\"691\":\"66#选择判断-choose\",\"692\":\"66#实现批量处理-foreach\",\"693\":\"66#批量删除\",\"694\":\"66#批量插入\",\"695\":\"66@0\",\"696\":\"66@1\",\"697\":\"67\",\"698\":\"67#mybatis详解6\",\"699\":\"67#缓存机制\",\"700\":\"67#一级缓存-作用在sqlsession\",\"701\":\"67#二级缓存-作用在mapper\",\"702\":\"67#查找顺序\",\"703\":\"67#单独配置取消二级缓存-usecache-false\",\"704\":\"67#操作结束-清除所有缓存-flushcache\",\"705\":\"67#缓存一致性问题\",\"706\":\"67@0\",\"707\":\"67@1\",\"708\":\"68\",\"709\":\"68#mybatis详解7\",\"710\":\"68#使用注解开发\",\"711\":\"68#调整-mybatis-config-xml\",\"712\":\"68#修改对应接口-注解\",\"713\":\"68#举例\",\"714\":\"68#配置这些额外的参数-options\",\"715\":\"68#实体类字段名称与数据库不同-results\",\"716\":\"68#结合xml配置\",\"717\":\"68#指定构造方法-constructorargs\",\"718\":\"68#关联查询-注解只支持嵌套查询\",\"719\":\"68#动态sql配置-selectprovider注解\",\"720\":\"68#二级缓存配置-cachenamespace\",\"721\":\"68#configuration\",\"722\":\"68@0\",\"723\":\"68@1\",\"724\":\"69\",\"725\":\"69#jul日志系统\",\"726\":\"69#jul基本使用\",\"727\":\"69#级别划分\",\"728\":\"69#自定义级别设置-logger-log\",\"729\":\"69#修改日志的默认打印级别\",\"730\":\"69@0\",\"731\":\"69@1\",\"732\":\"70\",\"733\":\"70#jul日志系统2\",\"734\":\"70#日志核心内容\",\"735\":\"70#核心部分-handler\",\"736\":\"70#consolehandler\",\"737\":\"70#filehandler\",\"738\":\"70#修改输出格式-formatter\",\"739\":\"70@0\",\"740\":\"70@1\",\"741\":\"71\",\"742\":\"71#jul日志系统3\",\"743\":\"71#日志继承关系\",\"744\":\"71#rootlogger\",\"745\":\"71#修改默认情况下的打印等级\",\"746\":\"71#重复logger问题\",\"747\":\"71#名称分级-自动构建继承关系\",\"748\":\"71@0\",\"749\":\"71@1\",\"750\":\"72\",\"751\":\"72#jul日志系统4\",\"752\":\"72#日志默认配置\",\"753\":\"72#properties-格式\",\"754\":\"72#java读取properties\",\"755\":\"72#获取系统数据getproperties\",\"756\":\"72#jul设置默认配置-logmanger\",\"757\":\"72@0\",\"758\":\"72@1\",\"759\":\"73\",\"760\":\"73#jul日志系统5\",\"761\":\"73#自定义日志格式\",\"762\":\"73#修改对应formatter\",\"763\":\"73#手动修改-setformatter\",\"764\":\"73#配置文件修改\",\"765\":\"73#自定义例子\",\"766\":\"73#第三方框架兼容性\",\"767\":\"73#lombok日志注解\",\"768\":\"73#mybatis日志\",\"769\":\"73@0\",\"770\":\"73@1\",\"771\":\"74\",\"772\":\"74#junit单元测试1\",\"773\":\"74#单元测试\",\"774\":\"74#junit使用\",\"775\":\"74#导入依赖\",\"776\":\"74#使用-注解-test\",\"777\":\"74#跳过某个测试-disable\",\"778\":\"74#测试自定义名称-displayname\",\"779\":\"74#预设的名称生成器-displaynamegeneration\",\"780\":\"74#判断测试是否成功-—-断言-assertions\",\"781\":\"74@0\",\"782\":\"74@1\",\"783\":\"75\",\"784\":\"75#junit单元测试2\",\"785\":\"75#断言工具-assertions\",\"786\":\"75#值判断-assertions-assertequals\",\"787\":\"75#真假判断-assertions-assertture-false\",\"788\":\"75#对象判断-assertions-assertsame\",\"789\":\"75#复杂判断\",\"790\":\"75#异常判断-assertions-assertthrows\",\"791\":\"75#假设工具-assumptions\",\"792\":\"75#条件测试和执行\",\"793\":\"75#指定操作系统-enabledonos\",\"794\":\"75#指定jdk版本-enableonjre\",\"795\":\"75#指定jdk版本范围-enableonjrerange-min-xxx-max-xxx\",\"796\":\"75#系统属性判断-enabledifsystemproperty\",\"797\":\"75#自定义方法-enabledif-xxx\",\"798\":\"75@0\",\"799\":\"75@1\",\"800\":\"76\",\"801\":\"76#junit单元测试3\",\"802\":\"76#生命周期\",\"803\":\"76#测试类的生命周期\",\"804\":\"76#测试顺序控制-testmethodorder-xxx-class\",\"805\":\"76#嵌套测试-nested\",\"806\":\"76#重复和参数化测试\",\"807\":\"76#重复测试-repeatedtest-x\",\"808\":\"76#参数化测试-parameterizedtest-valuesource\",\"809\":\"76#空值-nullsource\",\"810\":\"76#枚举值-enumsource-xx-class\",\"811\":\"76#特定的方法来生成参数\",\"812\":\"76#字段\",\"813\":\"76@0\",\"814\":\"76@1\",\"815\":\"77\",\"816\":\"77#maven1-简介与项目结构\",\"817\":\"77#简介\",\"818\":\"77#maven项目结构\",\"819\":\"77#核心配置-pom-xml\",\"820\":\"77#项目标识\",\"821\":\"77@0\",\"822\":\"77@1\",\"823\":\"78\",\"824\":\"78#maven2\",\"825\":\"78#maven依赖导入\",\"826\":\"78#maven依赖管理原理\",\"827\":\"78#修改国内镜像源\",\"828\":\"78@0\",\"829\":\"78@1\",\"830\":\"79\",\"831\":\"79#maven3-依赖作用域\",\"832\":\"79#maven依赖作用域\",\"833\":\"79#scope-属性\",\"834\":\"79#测试导入\",\"835\":\"79#第四个作用域-导入本地jar包\",\"836\":\"79@0\",\"837\":\"79@1\",\"838\":\"80\",\"839\":\"80#maven4-导入本地依赖\",\"840\":\"80#maven项目导入自己项目-mvn-install\",\"841\":\"80#依赖传递\",\"842\":\"80#可选依赖-optional\",\"843\":\"80#排除依赖中的不必要依赖-exclusion\",\"844\":\"80@0\",\"845\":\"80@1\",\"846\":\"81\",\"847\":\"81#maven5-继承、多模块-测试和打包\",\"848\":\"81#maven继承和多模块\",\"849\":\"81#继承\",\"850\":\"81#多模块-dependencymanagement\",\"851\":\"81#maven测试和打包\",\"852\":\"81#test-命令\",\"853\":\"81#package-命令\",\"854\":\"81#打包成可执行文件-maven-assembly-plugin\",\"855\":\"81#多模块测试打包\",\"856\":\"81@0\",\"857\":\"81@1\",\"858\":\"82\",\"859\":\"82#网络基础1\",\"860\":\"82@0\",\"861\":\"82@1\",\"862\":\"83\",\"863\":\"83#网络基础2\",\"864\":\"83#tomact-安装\",\"865\":\"83#idea-maven-构建-web-项目\",\"866\":\"83@0\",\"867\":\"83@1\",\"868\":\"84\",\"869\":\"84#网络基础3\",\"870\":\"84#servlet\",\"871\":\"84#创建servlet\",\"872\":\"84#servlet-的生命周期\",\"873\":\"84#service-方法\",\"874\":\"84#servletrequest-内容\",\"875\":\"84#servletresponse-内容\",\"876\":\"84#httpservlet\",\"877\":\"84#webservlet注解详解\",\"878\":\"84#不同路径配置\",\"879\":\"84#替换默认路径\",\"880\":\"84#配置多个访问路径\",\"881\":\"84#loadonstartup-属性\",\"882\":\"84@0\",\"883\":\"84@1\",\"884\":\"85\",\"885\":\"85#servlet2\",\"886\":\"85#使用post请求完成登陆\",\"887\":\"85#实现简单登录功能\",\"888\":\"85#mybatis-配置\",\"889\":\"85#实现登录功能\",\"890\":\"85#上传和下载文件\",\"891\":\"85#下载\",\"892\":\"85#上传\",\"893\":\"85#使用xhr请求数据\",\"894\":\"85@0\",\"895\":\"85@1\",\"896\":\"86\",\"897\":\"86#servlet3\",\"898\":\"86#重定向与请求转发\",\"899\":\"86#重定向-302-resp-sendredirect\",\"900\":\"86#请求转发\",\"901\":\"86#servletcontext对象-全局存储通信\",\"902\":\"86#初始化参数-webinitparam\",\"903\":\"86#全局定义初始化参数\",\"904\":\"86@0\",\"905\":\"86@1\",\"906\":\"87\",\"907\":\"87#cookie\",\"908\":\"87#简单使用\",\"909\":\"87#属性\",\"910\":\"87#应用\",\"911\":\"87#session\",\"912\":\"87#原理\",\"913\":\"87#应用-session\",\"914\":\"87#session-配置\",\"915\":\"87@0\",\"916\":\"87@1\",\"917\":\"88\",\"918\":\"88#filter\",\"919\":\"88#添加过滤器-filter\",\"920\":\"88#允许请求通过-filterchain-dofilter\",\"921\":\"88#httpfilter-接口\",\"922\":\"88#listener\",\"923\":\"88@0\",\"924\":\"88@1\",\"925\":\"89\",\"926\":\"89#tomcat类加载机制\",\"927\":\"89@0\",\"928\":\"89@1\",\"929\":\"90\",\"930\":\"91\",\"931\":\"92\",\"932\":\"93\",\"933\":\"94\",\"934\":\"95\",\"935\":\"96\",\"936\":\"97\",\"937\":\"98\",\"938\":\"99\",\"939\":\"100\",\"940\":\"101\",\"941\":\"102\",\"942\":\"103\",\"943\":\"104\",\"944\":\"105\",\"945\":\"106\",\"946\":\"107\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[2],\"4\":[1,85],\"5\":[1,56],\"6\":[1],\"7\":[2,23],\"8\":[1,20],\"9\":[1,75],\"10\":[null,null,1],\"11\":[null,null,1],\"12\":[3],\"13\":[2],\"14\":[1,100],\"15\":[1,79],\"16\":[1,46],\"17\":[null,null,1],\"18\":[null,null,1],\"19\":[3],\"20\":[2],\"21\":[1,17],\"22\":[1,14],\"23\":[1,138],\"24\":[2,112],\"25\":[1,229],\"26\":[null,null,1],\"27\":[null,null,1],\"28\":[3],\"29\":[2],\"30\":[1,36],\"31\":[1,20],\"32\":[1,31],\"33\":[3,30],\"34\":[1,35],\"35\":[3,51],\"36\":[1,64],\"37\":[1,37],\"38\":[null,null,1],\"39\":[null,null,1],\"40\":[3],\"41\":[2],\"42\":[3,18],\"43\":[2,55],\"44\":[2,72],\"45\":[2,22],\"46\":[1,43],\"47\":[2,67],\"48\":[1,44],\"49\":[1,30],\"50\":[1,41],\"51\":[null,null,1],\"52\":[null,null,1],\"53\":[3],\"54\":[2],\"55\":[1,15],\"56\":[2,84],\"57\":[1,65],\"58\":[2,69],\"59\":[2,104],\"60\":[2,89],\"61\":[1,36],\"62\":[1,9],\"63\":[2],\"64\":[1,49],\"65\":[1,65],\"66\":[1,33],\"67\":[2,72],\"68\":[null,null,1],\"69\":[null,null,1],\"70\":[2],\"71\":[1,181],\"72\":[null,null,1],\"73\":[null,null,1],\"74\":[3],\"75\":[2,9],\"76\":[3,16],\"77\":[1,30],\"78\":[1,29],\"79\":[1,33],\"80\":[1,57],\"81\":[null,null,1],\"82\":[null,null,1],\"83\":[2],\"84\":[1,108],\"85\":[null,null,1],\"86\":[null,null,1],\"87\":[2],\"88\":[1,49],\"89\":[1],\"90\":[1,43],\"91\":[1,60],\"92\":[1,45],\"93\":[1,26],\"94\":[1,37],\"95\":[1,4],\"96\":[1,40],\"97\":[1,30],\"98\":[1,60],\"99\":[null,null,1],\"100\":[null,null,1],\"101\":[2],\"102\":[1],\"103\":[1,19],\"104\":[1],\"105\":[1,28],\"106\":[1],\"107\":[2,38],\"108\":[2,60],\"109\":[2,9],\"110\":[1,24],\"111\":[1,3],\"112\":[1,39],\"113\":[1,26],\"114\":[null,null,1],\"115\":[null,null,1],\"116\":[2],\"117\":[1,52],\"118\":[1,27],\"119\":[1],\"120\":[1,90],\"121\":[1,60],\"122\":[null,null,1],\"123\":[null,null,1],\"124\":[2],\"125\":[1],\"126\":[1,49],\"127\":[1,48],\"128\":[1,24],\"129\":[1,39],\"130\":[1,7],\"131\":[1,41],\"132\":[1,24],\"133\":[1,55],\"134\":[null,null,1],\"135\":[null,null,1],\"136\":[2],\"137\":[1],\"138\":[1,71],\"139\":[1,69],\"140\":[1,29],\"141\":[1,5],\"142\":[1,59],\"143\":[1,36],\"144\":[1,65],\"145\":[1,37],\"146\":[1],\"147\":[1,43],\"148\":[1,54],\"149\":[null,null,1],\"150\":[null,null,1],\"151\":[2],\"152\":[1],\"153\":[1],\"154\":[1,72],\"155\":[1,91],\"156\":[1,75],\"157\":[null,null,1],\"158\":[null,null,1],\"159\":[2],\"160\":[1],\"161\":[2,92],\"162\":[1,54],\"163\":[1,25],\"164\":[1],\"165\":[1,39],\"166\":[1,37],\"167\":[1,110],\"168\":[null,null,1],\"169\":[null,null,1],\"170\":[2],\"171\":[1],\"172\":[1,50],\"173\":[1,79],\"174\":[1,75],\"175\":[null,null,1],\"176\":[null,null,1],\"177\":[2],\"178\":[1],\"179\":[1,17],\"180\":[2,26],\"181\":[2,5],\"182\":[1,36],\"183\":[3,59],\"184\":[3,30],\"185\":[2],\"186\":[1,105],\"187\":[null,null,1],\"188\":[null,null,1],\"189\":[2],\"190\":[1],\"191\":[1,81],\"192\":[1,123],\"193\":[1,81],\"194\":[null,null,1],\"195\":[null,null,1],\"196\":[2],\"197\":[1],\"198\":[1,50],\"199\":[3,106],\"200\":[null,null,1],\"201\":[null,null,1],\"202\":[2],\"203\":[1,18],\"204\":[1,26],\"205\":[1,22],\"206\":[1,39],\"207\":[1,50],\"208\":[1,65],\"209\":[null,null,1],\"210\":[null,null,1],\"211\":[2],\"212\":[2,16],\"213\":[1],\"214\":[1,4],\"215\":[2,79],\"216\":[1,74],\"217\":[1,14],\"218\":[1,73],\"219\":[1,141],\"220\":[2,73],\"221\":[1,72],\"222\":[null,null,1],\"223\":[null,null,1],\"224\":[2],\"225\":[1],\"226\":[1,9],\"227\":[1,97],\"228\":[1,25],\"229\":[1,69],\"230\":[null,null,1],\"231\":[null,null,1],\"232\":[5],\"233\":[2],\"234\":[1,5],\"235\":[1,47],\"236\":[1,40],\"237\":[1,29],\"238\":[1,32],\"239\":[1,22],\"240\":[1,24],\"241\":[1,43],\"242\":[1,25],\"243\":[1,15],\"244\":[2,65],\"245\":[2,60],\"246\":[1,148],\"247\":[null,null,1],\"248\":[null,null,1],\"249\":[2,6],\"250\":[1,3],\"251\":[4,93],\"252\":[4,34],\"253\":[1,35],\"254\":[1,42],\"255\":[1,84],\"256\":[1,35],\"257\":[1,53],\"258\":[1,67],\"259\":[null,null,1],\"260\":[null,null,1],\"261\":[2],\"262\":[2],\"263\":[1],\"264\":[1,50],\"265\":[1,23],\"266\":[1,57],\"267\":[1,104],\"268\":[1,26],\"269\":[null,null,1],\"270\":[null,null,1],\"271\":[2],\"272\":[2,5],\"273\":[1],\"274\":[1,59],\"275\":[1,45],\"276\":[null,null,1],\"277\":[null,null,1],\"278\":[3],\"279\":[2],\"280\":[1,79],\"281\":[1,106],\"282\":[1,44],\"283\":[null,null,1],\"284\":[null,null,1],\"285\":[1],\"286\":[1],\"287\":[2],\"288\":[1,35],\"289\":[2,63],\"290\":[2,60],\"291\":[3,34],\"292\":[2,54],\"293\":[1],\"294\":[1,66],\"295\":[1,52],\"296\":[1,42],\"297\":[1,61],\"298\":[null,null,1],\"299\":[null,null,1],\"300\":[2],\"301\":[1,5],\"302\":[1],\"303\":[1,21],\"304\":[1,61],\"305\":[1,59],\"306\":[1,37],\"307\":[1,59],\"308\":[1,33],\"309\":[1,18],\"310\":[2,33],\"311\":[1,43],\"312\":[null,null,1],\"313\":[null,null,1],\"314\":[2],\"315\":[1],\"316\":[1,24],\"317\":[1,31],\"318\":[1,55],\"319\":[3,37],\"320\":[1,19],\"321\":[2,45],\"322\":[2,33],\"323\":[1,110],\"324\":[null,null,1],\"325\":[null,null,1],\"326\":[3],\"327\":[1,5],\"328\":[1,39],\"329\":[1,9],\"330\":[1,22],\"331\":[1,48],\"332\":[1,7],\"333\":[1,126],\"334\":[null,null,1],\"335\":[null,null,1],\"336\":[4],\"337\":[4,16],\"338\":[1,45],\"339\":[1,29],\"340\":[1,59],\"341\":[2,30],\"342\":[1,46],\"343\":[1,34],\"344\":[1,71],\"345\":[3,2],\"346\":[2,42],\"347\":[1,68],\"348\":[null,null,1],\"349\":[null,null,1],\"350\":[2],\"351\":[1,12],\"352\":[1,59],\"353\":[1,21],\"354\":[1,32],\"355\":[1,60],\"356\":[1,16],\"357\":[1,12],\"358\":[1,48],\"359\":[1,34],\"360\":[1],\"361\":[1,30],\"362\":[1,47],\"363\":[1,15],\"364\":[1,55],\"365\":[1,74],\"366\":[1,63],\"367\":[1,41],\"368\":[1,66],\"369\":[null,null,1],\"370\":[null,null,1],\"371\":[2,76],\"372\":[null,null,1],\"373\":[null,null,2],\"374\":[1,48],\"375\":[null,null,1],\"376\":[null,null,2],\"377\":[10,6],\"378\":[1,45],\"379\":[1,29],\"380\":[1],\"381\":[1],\"382\":[1,44],\"383\":[1,105],\"384\":[4,82],\"385\":[1,34],\"386\":[1],\"387\":[1,157],\"388\":[1,67],\"389\":[null,null,1],\"390\":[null,null,6],\"391\":[2],\"392\":[1,1],\"393\":[2,118],\"394\":[6,54],\"395\":[null,null,1],\"396\":[null,null,1],\"397\":[4,19],\"398\":[7,2],\"399\":[6,8],\"400\":[3,28],\"401\":[3,8],\"402\":[3,3],\"403\":[5,10],\"404\":[6,3],\"405\":[4,4],\"406\":[2,1],\"407\":[6,3],\"408\":[null,null,1],\"409\":[null,null,1],\"410\":[2],\"411\":[1,5],\"412\":[3],\"413\":[1,16],\"414\":[4,27],\"415\":[7,36],\"416\":[3,35],\"417\":[8,10],\"418\":[7,23],\"419\":[4,47],\"420\":[8,34],\"421\":[6,34],\"422\":[3,72],\"423\":[2,29],\"424\":[null,null,1],\"425\":[null,null,1],\"426\":[2,16],\"427\":[3,36],\"428\":[6],\"429\":[3,28],\"430\":[2,8],\"431\":[5,21],\"432\":[4,75],\"433\":[null,null,1],\"434\":[null,null,1],\"435\":[4,6],\"436\":[4,18],\"437\":[2,53],\"438\":[3,1],\"439\":[4,3],\"440\":[3,70],\"441\":[2,1],\"442\":[3,44],\"443\":[5,6],\"444\":[7,71],\"445\":[6,23],\"446\":[5,1],\"447\":[null,null,1],\"448\":[null,null,1],\"449\":[6,51],\"450\":[3,16],\"451\":[2,61],\"452\":[3,33],\"453\":[3,49],\"454\":[4,10],\"455\":[4,63],\"456\":[3,52],\"457\":[5,1],\"458\":[4,33],\"459\":[4,9],\"460\":[4,25],\"461\":[4,39],\"462\":[7,12],\"463\":[2,1],\"464\":[null,null,1],\"465\":[null,null,1],\"466\":[2,33],\"467\":[2],\"468\":[2,32],\"469\":[5],\"470\":[3,17],\"471\":[2,31],\"472\":[3,44],\"473\":[6,41],\"474\":[4],\"475\":[3,57],\"476\":[4],\"477\":[3,8],\"478\":[2,67],\"479\":[6,11],\"480\":[5,1],\"481\":[null,null,1],\"482\":[null,null,1],\"483\":[4],\"484\":[2,50],\"485\":[6,10],\"486\":[3,36],\"487\":[2,37],\"488\":[7],\"489\":[6,23],\"490\":[3,37],\"491\":[5,3],\"492\":[3,2],\"493\":[7,21],\"494\":[4,24],\"495\":[6,7],\"496\":[2,9],\"497\":[2,17],\"498\":[5,17],\"499\":[3,10],\"500\":[3,1],\"501\":[3,2],\"502\":[null,null,1],\"503\":[null,null,1],\"504\":[6,11],\"505\":[2,12],\"506\":[6,9],\"507\":[4,15],\"508\":[2,22],\"509\":[2,52],\"510\":[4,40],\"511\":[6,19],\"512\":[5,15],\"513\":[5,10],\"514\":[6,13],\"515\":[6,21],\"516\":[1,110],\"517\":[4,3],\"518\":[1,13],\"519\":[null,null,1],\"520\":[null,null,1],\"521\":[5,10],\"522\":[2,38],\"523\":[2],\"524\":[5,22],\"525\":[1,5],\"526\":[3,21],\"527\":[4,20],\"528\":[1,27],\"529\":[2,60],\"530\":[3,40],\"531\":[2,1],\"532\":[null,null,1],\"533\":[null,null,1],\"534\":[2],\"535\":[1,9],\"536\":[2,52],\"537\":[1,83],\"538\":[1,64],\"539\":[null,null,1],\"540\":[null,null,1],\"541\":[2],\"542\":[1],\"543\":[2,65],\"544\":[1,179],\"545\":[null,null,1],\"546\":[null,null,1],\"547\":[2],\"548\":[2],\"549\":[1,24],\"550\":[1,37],\"551\":[1,24],\"552\":[1,12],\"553\":[3,11],\"554\":[3,15],\"555\":[3,17],\"556\":[1,22],\"557\":[null,null,1],\"558\":[null,null,2],\"559\":[2],\"560\":[2],\"561\":[2,64],\"562\":[3],\"563\":[1,36],\"564\":[1,82],\"565\":[1,52],\"566\":[1,22],\"567\":[1,16],\"568\":[1,25],\"569\":[1,8],\"570\":[3],\"571\":[1,19],\"572\":[1,13],\"573\":[1,11],\"574\":[null,null,1],\"575\":[null,null,2],\"576\":[2],\"577\":[2],\"578\":[3],\"579\":[1,17],\"580\":[2,19],\"581\":[1,20],\"582\":[1,26],\"583\":[1,22],\"584\":[1,24],\"585\":[1,13],\"586\":[1,32],\"587\":[1,11],\"588\":[3,3],\"589\":[1,14],\"590\":[1,15],\"591\":[1,21],\"592\":[null,null,1],\"593\":[null,null,2],\"594\":[2],\"595\":[2],\"596\":[1,62],\"597\":[1,35],\"598\":[1,49],\"599\":[1,72],\"600\":[null,null,1],\"601\":[null,null,2],\"602\":[2],\"603\":[1,1],\"604\":[1,34],\"605\":[1,90],\"606\":[1,157],\"607\":[1,17],\"608\":[1,19],\"609\":[null,null,1],\"610\":[null,null,2],\"611\":[2],\"612\":[1],\"613\":[1,64],\"614\":[1,16],\"615\":[1,36],\"616\":[1,94],\"617\":[null,null,1],\"618\":[null,null,2],\"619\":[2],\"620\":[1],\"621\":[1,64],\"622\":[1,81],\"623\":[1,85],\"624\":[null,null,1],\"625\":[null,null,2],\"626\":[2],\"627\":[1,48],\"628\":[1,33],\"629\":[1,44],\"630\":[null,null,1],\"631\":[null,null,2],\"632\":[2],\"633\":[1,39],\"634\":[1,49],\"635\":[1,15],\"636\":[1,77],\"637\":[null,null,1],\"638\":[null,null,2],\"639\":[2],\"640\":[1],\"641\":[2,116],\"642\":[1,19],\"643\":[1,110],\"644\":[null,null,1],\"645\":[null,null,2],\"646\":[2],\"647\":[1,53],\"648\":[1,61],\"649\":[1,35],\"650\":[2,31],\"651\":[1,34],\"652\":[1,62],\"653\":[1,88],\"654\":[null,null,1],\"655\":[null,null,2],\"656\":[2],\"657\":[1],\"658\":[1,153],\"659\":[1,89],\"660\":[1,87],\"661\":[null,null,1],\"662\":[null,null,2],\"663\":[2],\"664\":[1],\"665\":[1],\"666\":[1,51],\"667\":[1,47],\"668\":[3,42],\"669\":[1,79],\"670\":[4,64],\"671\":[1,41],\"672\":[3,77],\"673\":[null,null,1],\"674\":[null,null,2],\"675\":[2],\"676\":[1],\"677\":[2,19],\"678\":[2,40],\"679\":[1,40],\"680\":[2,23],\"681\":[1,17],\"682\":[1,50],\"683\":[null,null,1],\"684\":[null,null,2],\"685\":[2],\"686\":[1],\"687\":[1],\"688\":[1,77],\"689\":[1,21],\"690\":[2,43],\"691\":[1,40],\"692\":[1,5],\"693\":[1,56],\"694\":[1,53],\"695\":[null,null,1],\"696\":[null,null,2],\"697\":[2],\"698\":[1],\"699\":[1,21],\"700\":[3,74],\"701\":[3,98],\"702\":[1,8],\"703\":[1,23],\"704\":[2,26],\"705\":[1,55],\"706\":[null,null,1],\"707\":[null,null,2],\"708\":[2],\"709\":[1],\"710\":[1,14],\"711\":[1,21],\"712\":[1,20],\"713\":[1,29],\"714\":[1,56],\"715\":[1,39],\"716\":[2,13],\"717\":[1,38],\"718\":[3,41],\"719\":[4,80],\"720\":[1,32],\"721\":[1,45],\"722\":[null,null,1],\"723\":[null,null,2],\"724\":[2],\"725\":[1,41],\"726\":[1,4],\"727\":[1,61],\"728\":[1,27],\"729\":[1,41],\"730\":[null,null,1],\"731\":[null,null,2],\"732\":[2],\"733\":[1],\"734\":[1],\"735\":[1,46],\"736\":[1,24],\"737\":[1,22],\"738\":[1,24],\"739\":[null,null,1],\"740\":[null,null,2],\"741\":[2],\"742\":[1],\"743\":[1],\"744\":[1,31],\"745\":[1,15],\"746\":[2,30],\"747\":[2,27],\"748\":[null,null,1],\"749\":[null,null,2],\"750\":[2],\"751\":[1],\"752\":[1],\"753\":[1,30],\"754\":[1,24],\"755\":[1,24],\"756\":[1,59],\"757\":[null,null,1],\"758\":[null,null,2],\"759\":[2],\"760\":[1],\"761\":[1,35],\"762\":[1],\"763\":[1,13],\"764\":[1,9],\"765\":[1,45],\"766\":[1,10],\"767\":[1,30],\"768\":[1,48],\"769\":[null,null,1],\"770\":[null,null,2],\"771\":[2],\"772\":[1],\"773\":[1,49],\"774\":[1],\"775\":[1,10],\"776\":[2,32],\"777\":[2,13],\"778\":[2,13],\"779\":[2,17],\"780\":[2,31],\"781\":[null,null,1],\"782\":[null,null,2],\"783\":[2],\"784\":[1],\"785\":[1,5],\"786\":[1,31],\"787\":[1,13],\"788\":[1,6],\"789\":[1,25],\"790\":[1,23],\"791\":[1,18],\"792\":[1,5],\"793\":[2,26],\"794\":[1,22],\"795\":[1,27],\"796\":[1,27],\"797\":[1,36],\"798\":[null,null,1],\"799\":[null,null,2],\"800\":[2],\"801\":[1],\"802\":[1,33],\"803\":[1,47],\"804\":[1,45],\"805\":[2,38],\"806\":[1,2],\"807\":[1,23],\"808\":[2,48],\"809\":[1,23],\"810\":[1,27],\"811\":[1,32],\"812\":[1,43],\"813\":[null,null,1],\"814\":[null,null,2],\"815\":[2],\"816\":[2],\"817\":[1,46],\"818\":[1,17],\"819\":[1,65],\"820\":[1,37],\"821\":[null,null,1],\"822\":[null,null,2],\"823\":[2],\"824\":[1],\"825\":[1,58],\"826\":[1,27],\"827\":[1,47],\"828\":[null,null,1],\"829\":[null,null,2],\"830\":[2],\"831\":[2],\"832\":[1,22],\"833\":[1,39],\"834\":[1,165],\"835\":[2,32],\"836\":[null,null,1],\"837\":[null,null,2],\"838\":[2],\"839\":[2],\"840\":[1,64],\"841\":[1,25],\"842\":[1,38],\"843\":[1,31],\"844\":[null,null,1],\"845\":[null,null,2],\"846\":[4],\"847\":[5],\"848\":[1],\"849\":[1,86],\"850\":[1,55],\"851\":[1,21],\"852\":[1,19],\"853\":[1,27],\"854\":[1,63],\"855\":[1,19],\"856\":[null,null,1],\"857\":[null,null,2],\"858\":[2],\"859\":[1,106],\"860\":[null,null,1],\"861\":[null,null,1],\"862\":[2],\"863\":[1],\"864\":[2,269],\"865\":[5,17],\"866\":[null,null,1],\"867\":[null,null,1],\"868\":[2],\"869\":[1],\"870\":[1,27],\"871\":[1,84],\"872\":[2,27],\"873\":[1,24],\"874\":[1,47],\"875\":[1,39],\"876\":[1,137],\"877\":[2,5],\"878\":[1,18],\"879\":[1,10],\"880\":[1,5],\"881\":[1,47],\"882\":[null,null,1],\"883\":[null,null,1],\"884\":[2],\"885\":[1],\"886\":[1,78],\"887\":[1,3],\"888\":[2,111],\"889\":[1,86],\"890\":[1],\"891\":[1,62],\"892\":[1,70],\"893\":[1,89],\"894\":[null,null,1],\"895\":[null,null,1],\"896\":[2],\"897\":[1],\"898\":[1],\"899\":[2,38],\"900\":[1,79],\"901\":[2,35],\"902\":[1,22],\"903\":[1,28],\"904\":[null,null,1],\"905\":[null,null,1],\"906\":[4],\"907\":[1,5],\"908\":[1,128],\"909\":[1,66],\"910\":[1,102],\"911\":[1,12],\"912\":[1,15],\"913\":[1,152],\"914\":[1,22],\"915\":[null,null,1],\"916\":[null,null,1],\"917\":[4],\"918\":[1,20],\"919\":[1,39],\"920\":[1,52],\"921\":[1,75],\"922\":[1,28],\"923\":[null,null,1],\"924\":[null,null,1],\"925\":[2],\"926\":[1,76],\"927\":[null,null,1],\"928\":[null,null,1],\"929\":[1,3],\"930\":[1],\"931\":[1],\"932\":[1],\"933\":[3],\"934\":[2],\"935\":[1],\"936\":[1],\"937\":[1],\"938\":[2],\"939\":[1],\"940\":[2],\"941\":[2],\"942\":[2],\"943\":[2],\"944\":[2],\"945\":[2],\"946\":[2]},\"averageFieldLength\":[1.7616298243959394,42.755490730723615,0.9311178932424955],\"storedFields\":{\"0\":{\"h\":\"daily1\",\"t\":[\"a+b=c\"]},\"1\":{\"c\":[\"daily\"]},\"2\":{\"c\":[\"d1\"]},\"3\":{\"h\":\"Java - 类与对象1\"},\"4\":{\"h\":\"类与对象\",\"t\":[\"类: 是对一类事物的描述，是抽象的、概念上的定义.对象: 是某一类事物实际存在的每个个体，因而也被称为实例（instance）， 是类的一个具体化个体.\",\"类的创建: 类名的首字母通常是大写的.\",\"public class Person {//这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } \",\"对象实例的创建 new Person() :\",\"public static void main(String[] args) { Person p = new Person(); } \",\"对于对象而言，其变量名存储的是对象的引用（类似于c++指针的情况），并非是所对应的对象本身，即\",\"public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p1存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p1 = new Person(); Person p2 = p1; // 我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制 } \",\"在创建了对象之后，就可以进行一定操作，如: 访问、修改对象的属性. 不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象. 关于对象类型的变量，我们也可以不对任何对象进行引用：\",\"public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \\\"小红\\\"; //我任性，就是要操作 System.out.println(p.name); } \",\"会出现异常，即空指针异常. 对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\"]},\"5\":{\"h\":\"方法的创建与使用\",\"t\":[\"类除了具有属性外，还可以定义一些方法来描述同一类的行为。 方法是语句的集合，是为了完成某件事情而存在的。 方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\",\"方法的定义如下:\",\"返回值类型 方法名称() { 方法体... } \",\"具体而言:\",\"public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\\\"我叫 \\\"+name+\\\" 今年 \\\"+age+\\\" 岁了！\\\"); } } \",\"方法的调用:\",\"public static void main(String[] args) { Person p = new Person(); p.name = \\\"小明\\\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } \"]},\"6\":{\"h\":\"方法的进阶使用\"},\"7\":{\"h\":\"this 的使用\",\"t\":[\"有时候我们的方法中可能会出现一些与成员变量重名的变量：\",\"void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的 //这里实际上是将方法参数的局部变量name赋值为本身 } \",\"我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\",\"void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } \",\"当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\",\"String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } \"]},\"8\":{\"h\":\"方法的重载\",\"t\":[\"有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况。\",\"一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\",\"int sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } \"]},\"9\":{\"h\":\"构造方法\",\"t\":[\"我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？ 要在对象创建时进行处理，我们可以使用**构造方法（构造器）**来完成。\",\"构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\",\"public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \\\"小明\\\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \\\"男\\\"; } } \",\"构造方法会在new的时候自动执行, 当然，我们也可以为构造方法设定参数：\",\"public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } \",\"注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法.\",\"当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\",\"public class Person { String name = \\\"未知\\\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \\\"男\\\"; } \",\"这里需要特别注意，成员变量的初始化，并不是在构造方法之后，而是在这之前就已经完成了.\",\"Person(String name, int age, String sex){ System.out.println(this.age); // 在赋值之前看看是否有初始值 // 这里是 this.age 而非 age // 此时this.age已经初始化完，但还未复制，this.age = 0 this.name = name; this.age = age; this.sex = sex; } \",\"我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\",\"public class Person { String name; int age; String sex; { System.out.println(\\\"我是代码块\\\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\\\"我被构造了\\\"); this.name = name; this.age = age; this.sex = sex; } } \"]},\"10\":{\"c\":[\"code\"]},\"11\":{\"c\":[\"java\"]},\"12\":{\"h\":\"Java - 泛型 2\"},\"13\":{\"h\":\"泛型 2\"},\"14\":{\"h\":\"泛型方法\",\"t\":[\"当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。\",\"当某个方法（无论是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：\",\"public class Main { public static void main(String[] args) { String str = test(\\\"Hello World!\\\"); } private static <T> T test(T t){ //在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法 return t; } } \",\"泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型 T 作为参数，同样的类型 T 作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成 String 类型，因此返回值也是 String 类型。\",\"public static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \\\"Hello\\\"); System.out.println(Arrays.toString(strings)); } private <T> void add(T[] arr, T t){ arr[0] = t; } \",\"实际上泛型方法在很多工具类中也有，比如说 Arrays 的排序方法：\",\"Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; } }); \",\"比如现在我们想要让数据从大到小排列，我们就可以自定义：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr)); } \",\"因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -> o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr)); } \",\"包括数组复制方法：\",\"public static void main(String[] args) { String[] arr = {\\\"AAA\\\", \\\"BBB\\\", \\\"CCC\\\"}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr)); } \",\"因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。\"]},\"15\":{\"h\":\"泛型界限\",\"t\":[\"上界 extend\",\"下界 super 仅适用于通配符，对于类型变量来说是不支持的\",\"现在有一个新的需求，现在没有 String 类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\",\"public class Score<T extends Number> { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; } } \",\"只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：\",\"实际上就像这样：\",\"20241106133117\",\"同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：\",\"public static void main(String[] args) { Score<? extends Integer> score = new Score<>(\\\"数据结构与算法\\\", \\\"EP074512\\\", 60); } \",\"那么既然泛型有上界，那么有没有下界呢？肯定的啊：\",\"20241106133159\",\"只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：\",\"20241106133211\",\"那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\",\"public static void main(String[] args) { Score<? extends Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 } \",\"但是我们限定下界的话，因为还是有可能是 Object，所以说依然是跟之前一样：\",\"public static void main(String[] args) { Score<? super Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Object o = score.getValue(); } \",\"通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。\"]},\"16\":{\"h\":\"类型擦除\",\"t\":[\"前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？\",\"public abstract class A <T>{ abstract T test(T t); } \",\"实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：\",\"public abstract class A { abstract Object test(Object t); //默认就是Object } \",\"当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：\",\"public abstract class A <T extends Number>{ //设定上界为Number abstract T test(T t); } \",\"那么编译之后：\",\"public abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类 } \",\"因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：\",\"public static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型 } \",\"只不过此时编译器会给出警告\"]},\"17\":{\"c\":[\"code\"]},\"18\":{\"c\":[\"java\"]},\"19\":{\"h\":\"Java - 集合类 1\"},\"20\":{\"h\":\"集合类 1\"},\"21\":{\"h\":\"集合类\",\"t\":[\"集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\",\"集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。\"]},\"22\":{\"h\":\"集合类与数组区别\",\"t\":[\"集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\",\"相同之处：\",\"它们都是容器，都能够容纳一组元素。\",\"不同之处：\",\"数组的大小是固定的，集合的大小是可变的。\",\"数组可以存放基本数据类型，但集合只能存放对象。\",\"数组存放的类型只能是一种，但集合可以有不同种类的元素。\"]},\"23\":{\"h\":\"集合根接口\",\"t\":[\"所有的集合类最终都是实现自集合根接口的\",\"Java 中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\",\"import java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"树脂666\\\"); } } \",\"比如 ArrayList 类，它的祖先就是Collection接口：\",\"20241120130452\",\"public interface Collection<E> extends Iterable<E> { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator<E> iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 <T> T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection<?> c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection<? extends E> c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection<?> c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate<? super E> filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator<E> each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection<?> c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); } } \"]},\"24\":{\"h\":\"List 列表\",\"t\":[\"List 列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。\",\"List 是集合类型的一个分支，它的主要特性有：\",\"是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置\",\"列表中允许存在重复元素 (只要 集合的 equal 方法判定为 True 就是重复)\",\"List 直接继承自前面介绍的 Collection 接口，其中很多地方重新定义了一次 Collection 接口中定义的方法，这样做是为了更加明确方法的具体功能\",\"可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作\",\"//List是一个有序的集合类，每个元素都有一个自己的下标位置 //List中可插入重复元素 //针对于这些特性，扩展了Collection接口中一些额外的操作 public interface List<E> extends Collection<E> { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection<? extends E> c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator<E> operator) { Objects.requireNonNull(operator); final ListIterator<E> li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\\\"unchecked\\\", \\\"rawtypes\\\"}) default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(); //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List<E> subList(int fromIndex, int toIndex); ... } \"]},\"25\":{\"h\":\"ArrayList\",\"t\":[\"在 ArrayList 中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity < 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 } } \",\"一般的，如果我们要使用一个集合类，我们会使用接口的引用：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\\\"科技与狠活\\\"); //使用add添加元素 list.add(\\\"上头啊\\\"); System.out.println(list); //打印集合类，可以得到一个非常规范的结果 } \",\"集合的各种功能我们都可以来测试一下\",\"特别注意一下，我们在使用 Integer 时，要注意传参问题：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除 } \",\"那要是这样写呢？\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list); } \",\"可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象：\",\"//ArrayList源码部分 public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false; } \",\"列表中允许存在相同元素，所以说我们可以添加两个一模一样的：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); System.out.println(list); } \",\"那要是此时我们删除对象呢，是一起删除还是只删除一个呢？\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); list.remove(str); System.out.println(list); } \",\"这种情况下，只会删除排在前面的第一个元素。\",\"集合类是支持嵌套使用的，一个集合中可以存放多个集合\",\"public static void main(String[] args) { List<List<String>> list = new LinkedList<>(); list.add(new LinkedList<>()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty()); } \",\"在 Arrays 工具类中，我们可以快速生成一个只读的List：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); //非常方便 System.out.println(list); } \",\"注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\")); System.out.println(list); } \",\"当然，也可以利用静态代码块：\",\"public static void main(String[] args) { List<String> list = new ArrayList<String>() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\\\"A\\\"); add(\\\"B\\\"); add(\\\"C\\\"); }}; System.out.println(list); } \",\"这里我们接着介绍另一个列表实现类，LinkedList 同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { transient int size = 0; //引用首结点 transient Node<E> first; //引用尾结点 transient Node<E> last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node<E> { //内部使用的结点类 E item; Node<E> next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node<E> prev; Node(Node<E> prev, E element, Node<E> next) { this.item = element; this.next = next; this.prev = prev; } } ... } \",\"LinkedList 的使用和 ArrayList 的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。\",\"只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。\"]},\"26\":{\"c\":[\"code\"]},\"27\":{\"c\":[\"java\"]},\"28\":{\"h\":\"Java - 集合类 2\"},\"29\":{\"h\":\"集合类 2\"},\"30\":{\"h\":\"迭代器\",\"t\":[\"实际上我们的集合类都是支持使用foreach语法 (增强 for 语法) 的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); } } \",\"但是由于仅仅是语法糖，实际上编译之后会修改为 迭代器 iterator 的形式：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } \"]},\"31\":{\"h\":\"简介\",\"t\":[\"通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：\",\"20241126232114\",\"一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：\",\"20241126232128\",\"每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。\",\"至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。\"]},\"32\":{\"h\":\"源码定义\",\"t\":[\"主要方法： next() | hasNext() | remove()\",\"public interface Iterator<E> { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\\\"remove\\\"); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } } \"]},\"33\":{\"h\":\"不同集合类 迭代器 实现用例\",\"t\":[\"ArrayList 就是直接按下标访问：\",\"public E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素 } \",\"LinkedList 就是不断向后寻找结点：\",\"public E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素 } \",\"虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现.\"]},\"34\":{\"h\":\"使用示例\",\"t\":[\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 } } \",\"注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。\",\"为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { System.out.println(s); } } \"]},\"35\":{\"h\":\"其他遍历 集合类 的方式\",\"t\":[\"在 Java8 提供了一个支持 Lambda 表达式的 forEach 方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作\",\"即对于 集合类 自身存在一个 forEach 的方法：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); list.forEach(System.out::println); } \",\"这个效果跟上面的写法是完全一样的，因为 forEach 方法内部本质上也是迭代器在处理，这个方法是在 Iterable 接口中定义的：\",\"default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 } } \"]},\"36\":{\"h\":\"介绍\",\"t\":[\"20241120130452\",\"//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了 public interface Iterable<T> { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator<T> iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator<T> spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } \",\"得益于 Iterable 提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用 foreach 语法：\",\"public class Test implements Iterable<String>{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator<String> iterator() { return new Iterator<String>() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \\\"测试\\\"; } }; } } \"]},\"37\":{\"h\":\"介绍\",\"t\":[\"这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：\",\"这种迭代器因为能够双向遍历，所以说可以反复使用。\",\"public interface ListIterator<E> extends Iterator<E> { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e); } \"]},\"38\":{\"c\":[\"code\"]},\"39\":{\"c\":[\"java\"]},\"40\":{\"h\":\"Java - 集合类 3\"},\"41\":{\"h\":\"集合类 3\"},\"42\":{\"h\":\"Quene 和 Deque\",\"t\":[\"其中 LinkedList 除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable \"]},\"43\":{\"h\":\"Quene 队列\",\"t\":[\"20241127001435\",\"我们先来看看队列接口，它扩展了大量队列相关操作：\",\"public interface Queue<E> extends Collection<E> { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek(); } \",\"我们可以直接将一个 LinkedList 当做一个队列来使用：\",\"public static void main(String[] args) { Queue<String> queue = new LinkedList<>(); //当做队列使用，还是很方便的 queue.offer(\\\"AAA\\\"); queue.offer(\\\"BBB\\\"); System.out.println(queue.poll()); System.out.println(queue.poll()); } \"]},\"44\":{\"h\":\"Deque 双端队列\",\"t\":[\"普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作\",\"利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用\",\"//在双端队列中，所有的操作都有分别对应队首和队尾的 public interface Deque<E> extends Queue<E> { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator<E> descendingIterator(); } \",\"我们可以来测试一下，比如我们可以直接当做栈来进行使用：\",\"public static void main(String[] args) { Deque<String> deque = new LinkedList<>(); deque.push(\\\"AAA\\\"); deque.push(\\\"BBB\\\"); System.out.println(deque.pop()); System.out.println(deque.pop()); } \"]},\"45\":{\"h\":\"其他集合类实现 队列\",\"t\":[\"当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：\",\"public static void main(String[] args) { Deque<String> deque = new ArrayDeque<>(); //数组实现的栈和队列 Queue<String> queue = new PriorityQueue<>(); //优先级队列 } \"]},\"46\":{\"h\":\"优先级队列\",\"t\":[\"这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的(4/5/10)，类似于VIP用户可以优先结束排队。\",\"我们也可以自定义比较规则，同样需要给一个 Comparator 的实现(10/5/4)：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的\",\"想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。\"]},\"47\":{\"h\":\"Set 集合\",\"t\":[\"Set集合，这种集合类型比较特殊\",\"set 接口中定义的方法都是 Collection 中直接继承的，因此，Set支持的功能其实也就和 Collection 中定义的差不多，只不过：\",\"不允许出现重复元素\",\"不支持随机访问（不允许通过下标访问）\",\"public interface Set<E> extends Collection<E> { // Set 集合中基本都是从 Collection 直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator<E> iterator(); Object[] toArray(); <T> T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection<?> c); //同样是只能插入那些不重复的元素 boolean addAll(Collection<? extends E> c); boolean retainAll(Collection<?> c); boolean removeAll(Collection<?> c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); } } \"]},\"48\":{\"h\":\"HashSet\",\"t\":[\"它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个 HashMap 在实现，这个需要我们学习了Map之后再来讨论）\",\"我们可以非常高效的从 HashSet 中存取元素，我们先来测试一下它的特性：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\\\"AAA\\\")); System.out.println(set); //可以看到，最后实际上只有一个成功插入了 } \",\"在 Set 接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除 Set 中的某个对象：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); System.out.println(set.remove(\\\"AAA\\\")); System.out.println(set); } \",\"由于底层采用哈希表实现，所以说无法维持插入元素的顺序：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"49\":{\"h\":\"LinkedHashSet\",\"t\":[\"那要是我们就是想要使用维持顺序的Set集合呢？\",\"我们可以使用 LinkedHashSet，LinkedHashSet 底层维护的不再是一个 HashMap，而是 LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\",\"public static void main(String[] args) { Set<String> set = new LinkedHashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"50\":{\"h\":\"TreeSet\",\"t\":[\"还有一种Set叫做TreeSet，它会在元素插入时进行排序：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>(); set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>((a, b) -> b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"目前，Set 集合只是粗略的进行了讲解，但是学习 Map 之后，我们还会回来看我们 Set 的底层实现，所以说最重要的还是 Map目前只需要记住 Set 的性质、使用即可。\"]},\"51\":{\"c\":[\"code\"]},\"52\":{\"c\":[\"java\"]},\"53\":{\"h\":\"Java - 集合类 4\"},\"54\":{\"h\":\"集合类 4\"},\"55\":{\"h\":\"Map\",\"t\":[\"映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\",\"Map 就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值\",\"Map 并不是 Collection 体系下的接口，而是单独的一个体系，因为操作特殊\"]},\"56\":{\"h\":\"Map 基本定义\",\"t\":[\"在 Map 中，这些映射关系被存储为键值对，Map 接口中定义的操作：\",\"// Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊 // 这里需要填写两个泛型参数， // 其中K就是键的类型，V就是值的类型， // 比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的 public interface Map<K,V> { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map<? extends K, ? extends V> m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set<K> keySet(); //返回Map中存放的所有值 Collection<V> values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set<Map.Entry<K, V>> entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry<K,V> { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ... } \"]},\"57\":{\"h\":\"HashMap\",\"t\":[\"底层采用哈希表实现\",\"基本示例\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \\\"小红\\\"); System.out.println(map.get(2)); //使用get方法根据键获取对应的值 } \",\"Map 中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的\",\"为了防止意外将之前的键值对覆盖掉，我们可以使用 putIfAbsent：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); map.putIfAbsent(1, \\\"小红\\\"); //Java8 新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); } \",\"我们在获取一个不存在的映射时，默认会返回 null 作为结果：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null } \",\"我们也可以为这种情况添加一个预备方案 getOrDefault，当 Map 中不存在时，可以返回一个备选的返回值：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); System.out.println(map.getOrDefault(3, \\\"备胎\\\")); //Java8新增操作，当不存在对应的键值对时，返回备选方案 } \",\"因为 HashMap 底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的\",\"如果需要维护顺序，我们同样可以使用 LinkedHashMap，它的内部对插入顺序进行了维护\"]},\"58\":{\"h\":\"HashMap 底层实现\",\"t\":[\"HashMap 的底层实现是由 哈希表 实现的。\",\"哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：\",\"20241130000528\",\"实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... static class Node<K,V> implements Map.Entry<K,V> { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node<K,V> next; ... } ... transient Node<K,V>[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } \",\"可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：\",\"HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板\",\"HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构\"]},\"59\":{\"h\":\"put 方法\",\"t\":[\"public V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; // 通过resize方法初始化底层哈希表，初始容量为16， // 后续会根据情况扩容，底层哈希表的长度永远是2的n次方 // 因为传入的哈希值可能会很大，这里同样是进行取余操作 // (n - 1) & hash 等价于 hash % n // 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果这个位置上什么都没有，那就直接放一个新的结点 else { // 这种情况就是哈希冲突了 Node<K,V> e; K k; // 如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount >= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash); //那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size > threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null } \"]},\"60\":{\"h\":\"resize 方法\",\"t\":[\"resize 在初始化时会调用一次，此外在每次扩容时会调用。\",\"根据上面的推导，我们在正常插入一个键值对时，会得到 null 返回值，而冲突时会得到一个被覆盖的值.\",\"HashMap的一个链表长度过大时，会自动转换为红黑树：\",\"20241130001811\",\"但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap > 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap >= MAXIMUM_CAPACITY) { // 如果旧的容量已经大于最大限制了， // 那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr << 1; //新的阈值也提升到原来的两倍 } else if (oldThr > 0) // 旧容量不大于0只可能是还没初始化 // 这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参 new 出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; // 新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值为负载因子乘以默认容量，负载因子默认为0.75 // 也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了， // 反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 } } \"]},\"61\":{\"h\":\"LinkedHashMap\",\"t\":[\"HashMap 并不会维持插入的顺序，LinkedHashMap 是直接继承自HashMap，具有 HashMap 的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序\",\"static class Entry<K,V> extends HashMap.Node<K,V> { // LinkedHashMap中的结点实现 Entry<K,V> before, after; // 这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); } } \",\"这样我们在遍历 LinkedHashMap 时，顺序就同我们的插入顺序一致。\",\"当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\"]},\"62\":{\"h\":\"TreeMap\",\"t\":[\"它的内部直接维护了一个红黑树（没有使用哈希表）\",\"因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的 TreeSet 是一样的\"]},\"63\":{\"h\":\"Map 的一些方法\"},\"64\":{\"h\":\"\",\"t\":[\"compute 会将指定 Key 的值进行重新计算，若 Key 不存在，v 会返回 null\",\"computeIfPresent 当 Key 存在时存在则计算并赋予新的值\",\"computeIfAbsent 不存在Key时，计算并将键值对放入Map中：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.compute(1, (k, v) -> { //compute 会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\\\"M\\\"; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -> { // 当Key存在时存在则计算并赋予新的值 return v+\\\"M\\\"; //这里返回原来的value+M }); System.out.println(map); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.computeIfAbsent(0, (k) -> { //若不存在则计算并插入新的值 return \\\"M\\\"; //这里返回M }); System.out.println(map); } \"]},\"65\":{\"h\":\"\",\"t\":[\"merge方法用于处理数据：\",\"public static void main(String[] args) { List<Student> students = Arrays.asList( new Student(\\\"yoni\\\", \\\"English\\\", 80), new Student(\\\"yoni\\\", \\\"Chiness\\\", 98), new Student(\\\"yoni\\\", \\\"Math\\\", 95), new Student(\\\"taohai.wang\\\", \\\"English\\\", 50), new Student(\\\"taohai.wang\\\", \\\"Chiness\\\", 72), new Student(\\\"taohai.wang\\\", \\\"Math\\\", 41), new Student(\\\"Seely\\\", \\\"English\\\", 88), new Student(\\\"Seely\\\", \\\"Chiness\\\", 89), new Student(\\\"Seely\\\", \\\"Math\\\", 92) ); Map<String, Integer> scoreMap = new HashMap<>(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -> scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -> System.out.println(\\\"key:\\\" + k + \\\"总分\\\" + \\\"value:\\\" + v)); } static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; } } \"]},\"66\":{\"h\":\"\",\"t\":[\"replace方法可以快速替换某个映射的值\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\">>>\\\"); //直接替换为新的 System.out.println(map); } \",\"也可以精准匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\"巴卡\\\", \\\"玛卡\\\"); //只有键和值都匹配时，才进行替换 System.out.println(map); } \",\"包括 remove 方法，也支持键值同时匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.remove(0, \\\"单走\\\"); //只有同时匹配时才移除 System.out.println(map); } \"]},\"67\":{\"h\":\"HashSet 底层实现\",\"t\":[\"它的底层很简单，底层是直接用 HashMap 套壳实现的。\",\"因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value\",\"public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable { private transient HashMap<E,Object> map; //对，你没看错，底层直接用 map 来做事 // 因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value private static final Object PRESENT = new Object(); // 直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap<>(); } ... // 你会发现所有的方法全是替身攻击 public Iterator<E> iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } } \",\"通过观察 HashSet 的源码发现，HashSet 几乎都在操作内部维护的一个HashMap ，也就是说，HashSet 只是一个表壳，而内部维护的 HashMap 才是灵魂！\",\"就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。\",\"所以说，HashSet 利用了 HashMap 内部的数据结构，轻松地就实现了 Set 定义的全部功能！\",\"再来看 TreeSet，实际上用的就是我们的 TreeMap\",\"LinkedSet 用的就是 LinkedMap\"]},\"68\":{\"c\":[\"code\"]},\"69\":{\"c\":[\"java\"]},\"70\":{\"h\":\"Java - Stream流\"},\"71\":{\"h\":\"Stream流\",\"t\":[\"Java 8 API添加了一个新的抽象称为 流Stream，可以让你以一种声明的方式处理数据。\",\"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\",\"Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\",\"这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\",\"元素流在管道中经过 中间操作（intermediate operation）的处理，最后由 最终操作(terminal operation)得到前面处理的结果。\",\"20241130004116\",\"我们就可以把一个 Stream 当做流水线处理：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"aaaa\\\", \\\"asdasda\\\", \\\"AssdW\\\", \\\"xx\\\", \\\"add\\\", \\\"Xss\\\", \\\"sdawErs\\\")); // 过滤 长度不超过 3 // 过滤 首字母不是大写字母 // 去除 重复字符串 // filter(...) 里面条件为 true 的会保留 // distinct 去重 list = list.stream() .filter(str -> str.length() > 3) .filter(str -> str.charAt(0) >= 'A' && str.charAt(0) <= 'Z') .distinct() .collect(Collectors.toList()); System.out.println(list); } \",\"类似\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); list.add(3); list = list.stream() .distinct() //去重（使用equals判断） .sorted((a, b) -> b - a) //进行倒序排列 .map(e -> e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } \",\"当遇到大量的复杂操作时，我们就可以使用 Stream 来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\",\"注意：不能认为每一步是直接依次执行的！\",\"实际上，stream 会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。\",\"接下来，我们用一堆随机数来进行更多流操作的演示：\",\"public static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random.ints(-100, 100) // 生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -> i < 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } \",\"我们可以生成一个统计实例来帮助我们快速进行统计：\",\"public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } \",\"普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -> i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } \",\"我们还可以通过flat来对整个流进行进一步细分：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"A,B\\\"); list.add(\\\"C,D\\\"); list.add(\\\"E,F\\\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -> Arrays.stream(e.split(\\\",\\\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } \",\"我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -> a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum); } \"]},\"72\":{\"c\":[\"code\"]},\"73\":{\"c\":[\"java\"]},\"74\":{\"h\":\"Java - Collections 工具类\"},\"75\":{\"h\":\"Collections 工具类\",\"t\":[\"我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。\",\"既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的 Collocations 类就是专用于集合的工具类\"]},\"76\":{\"h\":\"最大 | 最小\",\"t\":[\"我们想快速求得List中的最大值和最小值：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); Collections.max(list); Collections.min(list); } \"]},\"77\":{\"h\":\"二分搜索\",\"t\":[\"同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现 Comparable 接口的类）：\",\"public static void main(String[] args) { List<Integer> list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8)); } \"]},\"78\":{\"h\":\"快速填充\",\"t\":[\"我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list); } \",\"如果集合中本身没有元素，那么fill操作不会生效。\"]},\"79\":{\"h\":\"空集合\",\"t\":[\"有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：\",\"public static void main(String[] args) { List<Integer> list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常 } \",\"### 只读集合\",\"我们也可以将一个可修改的集合变成只读的集合：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); List<Integer> newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常 } \"]},\"80\":{\"h\":\"查找位置\",\"t\":[\"我们也可以寻找子集合的位置：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5))); } \",\"得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：\",\"public static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list.add(\\\"aaa\\\"); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list); } \",\"没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：\",\"public static void main(String[] args) { List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\\\"aaa\\\"); System.out.println(list); } \",\"checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：\",\"20241130005736\",\"是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。\"]},\"81\":{\"c\":[\"code\"]},\"82\":{\"c\":[\"java\"]},\"83\":{\"h\":\"Java - 集合类对象相等判定\"},\"84\":{\"h\":\"集合类对象相等判定\",\"t\":[\"Oject类中的 equals 方法比较的是地址，所以自己定义的类要自己重写 equals 等方法，否则给你当成 Object 类\",\"equals 方法 和 == 的区别\",\"集合类中并不是通过 == 进行判断的，都是根据 equals 方法进行判断的\",\"remove 也是根据 equals 进行判断来删除元素\",\"20241130012855\",\"对于 List 列表 判断两个元素是否相同，是根据 元素中的 equals 方法判断的\",\"public class Main { public static void main(String[] args) { List<Test> list = new ArrayList<>(); Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); list.add(t1); System.out.println(list.remove(t2)); // 这样会把 t1 移除，因为 Test 的 equals 判断修改成根据 name 进行判断 } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } } } \",\"对于 Map 以及 Set 而言 两个对象只有 equals 方法判断相同后，还需要判断 hashCode 方法也相同，才认为这两个元素是相同的\",\"对于 Object 定义中提到，如果两个对象通过 equals 判断相同，那么它们的 hashCode 也需要相同。\",\"因此，在重写 equals 方法时，也需要考虑重写 hashCode 方法，保证当两个对象通过 equals 方法判断相同时，它们通过 hashCode 得到的 hash 值也相同\",\"如下，因为重写了 equals 和 hashCode 所以只要 name 一致，通过 map 操作就是相同的\",\"public class Main { public static void main(String[] args) { Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); Map<Test, Integer> map = new HashMap<>(); map.put(t1, 2); System.out.println(map.get(t2)); } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } @Override public int hashCode() { return Objects.hashCode(name); } } } \"]},\"85\":{\"c\":[\"code\"]},\"86\":{\"c\":[\"java\"]},\"87\":{\"h\":\"Java - IO1\"},\"88\":{\"h\":\"IO流1\",\"t\":[\"一般在java.io中\",\"字节流：\",\"处理单位：以字节（8 位）为单位进行读写操作。\",\"适用场景：适用于处理所有类型的数据，包括文本、图片、音频、视频等二进制数据。\",\"主要类：InputStream 和 OutputStream 及其子类，如 FileInputStream 和 FileOutputStream。\",\"编码处理：不涉及字符编码转换，直接处理原始字节数据。\",\"字符流：\",\"处理单位：以字符（16 位）为单位进行读写操作。\",\"适用场景：专门用于处理文本数据，如读取和写入文本文件。\",\"主要类：Reader 和 Writer 及其子类，如 FileReader 和 FileWriter。\",\"编码处理：自动处理字符编码转换，适用于处理文本文件。\",\"主要区别：处理单位：字节流以字节为单位，字符流以字符为单位。 适用范围：字节流适用于所有类型的数据，字符流仅适用于文本数据。 编码处理：字节流不处理字符编码，字符流自动处理字符编码转换。 性能：字符流在处理文本数据时通常更高效，因为它们直接操作字符，减少了字节到字符的转换时间。\"]},\"89\":{\"h\":\"文件字节流\"},\"90\":{\"h\":\"输入流\",\"t\":[\"我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用\",\"public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\\\"路径\\\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } \",\"不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法：\",\"public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\\\"路径\\\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } \",\"这种语法只支持实现了AutoCloseable接口的类\"]},\"91\":{\"h\":\"文件读取\",\"t\":[\"read 方法 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } \",\"available 方法 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量） 因此与read结合，可以一次直接读取全部数据：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } \",\"也可以控制读取的数量：\",\"System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 \",\"skip 方法 可以跳过指定数量的字节\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } \"]},\"92\":{\"h\":\"输出流\",\"t\":[\"public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } \",\"输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容:\",\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\\\"lbwnb\\\".getBytes()); //也可以直接写入byte[] outputStream.write(\\\"lbwnb\\\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"93\":{\"h\":\"追加操作\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\", true)) { //true表示开启追加模式 outputStream.write(\\\"lb\\\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } \"]},\"94\":{\"h\":\"文件拷贝操作实现\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\"); FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); } } \"]},\"95\":{\"h\":\"文件字符流\",\"t\":[\"java.io.FileReader & java.io.FileWriter\"]},\"96\":{\"h\":\"\",\"t\":[\"字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用.\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } \",\"同理，字符流只支持char[]类型作为存储：\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"97\":{\"h\":\"\",\"t\":[\"writer除了write方法外，还有一个append方法，但效果是一致的\",\"public static void main(String[] args) { try(FileWriter writer = new FileWriter(\\\"output.txt\\\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } \"]},\"98\":{\"h\":\"类\",\"t\":[\"专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\",\"public static void main(String[] args) { File file = new File(\\\"test.txt\\\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } \",\"通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容:\",\"File file = new File(\\\"/\\\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } \",\"如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\",\"File file = new File(\\\"test.txt\\\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } \"]},\"99\":{\"c\":[\"code\"]},\"100\":{\"c\":[\"java\"]},\"101\":{\"h\":\"Java - IO2\"},\"102\":{\"h\":\"IO流2\"},\"103\":{\"h\":\"缓冲流\",\"t\":[\"虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，**提前将部分内容存入内存（缓冲区）**在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\",\"20250225181159\"]},\"104\":{\"h\":\"缓冲字节流\"},\"105\":{\"h\":\"缓冲字节读取流\",\"t\":[\"要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可:\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } \"]},\"106\":{\"h\":\"缓冲流特性\"},\"107\":{\"h\":\"1. 装饰着模式\",\"t\":[\"实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式\",\"对应缓冲流的close源码：\",\"public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } \",\"实际上这种模式是父类FilterInputStream提供的规范\"]},\"108\":{\"h\":\"2. 缓冲机制\",\"t\":[\"I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存BufferedInputStream 支持 reset() 和 mark() 操作 即通过 mark 标记位置, reset 可以返回之前标记过的位置。\",\"当调用 mark(readlimit) 之后，输入流会以某种方式保留之后读取的readlimit 数量的内容，当读取的内容数量超过 readlimit 则之后的内容不会被保留，当调用 reset() 之后，会使得当前的读取位置回到 mark() 调用时的位置。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \"]},\"109\":{\"h\":\"3. 缓冲流可以叠加\",\"t\":[\"即可以进行套娃：BufferedInputStream stream = new BufferedInputStream(new BufferedInputStream(new FileInputStream(\\\"test.txt\\\")))\"]},\"110\":{\"h\":\"缓冲字节输出流\",\"t\":[\"其实和BufferedInputStream原理差不多，只是反向操作\",\"try (BufferedOutputStream stream = new BufferedOutputStream(Files.newOutputStream(Paths.get(\\\"src/1.txt\\\")))){ stream.write(\\\"Hello Penguin!\\\".getBytes()); } catch (IOException e) { throw new RuntimeException(e); } \"]},\"111\":{\"h\":\"缓冲字符流\",\"t\":[\"BufferedReader | BufferedWriter\"]},\"112\":{\"h\":\"缓冲字符读取流\",\"t\":[\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"相比Reader更方便的是，它支持按行读取\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } \",\"读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } \",\"它同样也支持mark()和reset()操作\"]},\"113\":{\"h\":\"缓冲字符输出流\",\"t\":[\"public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\\\"output.txt\\\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\\\"汉堡做滴彳亍不彳亍\\\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } \"]},\"114\":{\"c\":[\"code\"]},\"115\":{\"c\":[\"java\"]},\"116\":{\"h\":\"Java - 类与对象2\"},\"117\":{\"h\":\"静态变量和静态方法\",\"t\":[\"Static 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。 我们通过使用 static 关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\",\"一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\",\"public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } \",\"public static void main(String[] args) { Person.info = \\\"让我看看\\\"; System.out.println(Person.info); } \",\"同样的，我们可以将方法标记为静态：\",\"static void test(){ System.out.println(\\\"我是静态方法\\\"); } \",\"静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样:\",\"因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值, 同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的.\"]},\"118\":{\"h\":\"静态变量初始化\",\"t\":[\"我们实际上是将 .class 文件丢给 JVM 去执行的，而每一个 .class 文件其实就是我们编写的一个类，我们在 Java 中使用一个类之前， JVM 并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\",\"访问类的静态变量，或者为静态变量赋值\",\"new 创建类的实例（隐式加载）\",\"调用类的静态方法\",\"子类初始化时\",\"其他的情况会在讲到反射时介绍\",\"所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\"]},\"119\":{\"h\":\"包的访问与控制\"},\"120\":{\"h\":\"包的声明和导入\",\"t\":[\"包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\",\"包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的 www.baidu.com ，后面的 baidu.com 就是域名，我们的包就可以命名为com.baidu，其中的.就是用于分割的，对应多个文件夹，比如com.test\",\"20240815234719\",\"我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 需要通过关键字 package，用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\",\"package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } \",\"当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中） 而当我们需要使用其他包中的类时，需要先进行导入才可以： 需要通过关键字 import 导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类:\",\"import com.test.entity.Person; //使用import关键字导入其他包中的类 import com.test.entity.*; \",\"Java会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\",\"不同类的重名问题 在不同包下的类，即使类名相同，也是不同的两个类：\",\"package com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } \",\"由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\",\"public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } \",\"我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\"]},\"121\":{\"h\":\"访问权限控制\",\"t\":[\"Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\",\"private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。\",\"什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。\",\"protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）\",\"public - 公共，标记为公共的内容，允许在任何地方被访问。\",\"当前类\",\"同一个包下的类\",\"不同包下的子类\",\"不同包下的类\",\"public\",\"✅\",\"✅\",\"✅\",\"✅\",\"protected\",\"✅\",\"✅\",\"✅\",\"❌\",\"默认\",\"✅\",\"✅\",\"❌\",\"❌\",\"private\",\"✅\",\"❌\",\"❌\",\"❌\",\"默认的情况下，在当前包以外的其他包中无法访问。\",\"如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\",\"public class Person { String name; int age; String sex; public static void test(){ System.out.println(\\\"我是静态方法！\\\"); } } \",\"静态导入：\",\"import static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } \"]},\"122\":{\"c\":[\"code\"]},\"123\":{\"c\":[\"java\"]},\"124\":{\"h\":\"Java - IO3\"},\"125\":{\"h\":\"IO流3\"},\"126\":{\"h\":\"转换流\",\"t\":[\"有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦\",\"public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\\\"test.txt\\\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\\\"lbwnb\\\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } \",\"同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现\",\"public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\\\"test.txt\\\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } \",\"InputStreamReader 和 OutputStreamWriter 本质也是Reader和Writer，因此可以直接放入 BufferedReader 来实现更加方便的操作。\"]},\"127\":{\"h\":\"打印流\",\"t\":[\"打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类\",\"public final static PrintStream out = null; \",\"因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。\",\"PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\",\"可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\",\"public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\\\"test.txt\\\"))){ stream.println(\\\"penguin\\\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } \",\"我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\",\"20250225192918\"]},\"128\":{\"h\":\"输入流\",\"t\":[\"之前使用的Scanner，使用的是系统提供的输入流\",\"public static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入 } \",\"我们也可以使用Scanner来扫描其他的输入流：\",\"public static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\\\"秘制小汉堡.txt\\\")); //将文件内容作为输入流进行扫描 } \"]},\"129\":{\"h\":\"数据流\",\"t\":[\"数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\",\"public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\\\"test.txt\\\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } \",\"用于写入基本数据类型:\",\"public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\\\"output.txt\\\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } \",\"注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\"]},\"130\":{\"h\":\"对象流\",\"t\":[\"ObjectOutputStream不仅支持基本数据类型，而且通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\"]},\"131\":{\"h\":\"对象序列化\",\"t\":[\"自己定义的类要序列化保存，则必须实现Serializable接口才能被序列化\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"penguin\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } \"]},\"132\":{\"h\":\"\",\"t\":[\"在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\",\"static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } \"]},\"133\":{\"h\":\"关键字\",\"t\":[\"如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"lbw\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } \",\"其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\"]},\"134\":{\"c\":[\"code\"]},\"135\":{\"c\":[\"java\"]},\"136\":{\"h\":\"Java - 多线程与反射1\"},\"137\":{\"h\":\"多线程\"},\"138\":{\"h\":\"进程与线程概念\",\"t\":[\"进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\",\"20250226173747\",\"在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时。\",\"线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\",\"在Java中，我们从开始，一直以来编写的都是单线程应用程序(运行main()方法的内容), 也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程:\",\"public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } \"]},\"139\":{\"h\":\"线程的创建和启动\",\"t\":[\"线程之间是同时运行的 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式\",\" /** * Creates a new Thread that inherits the given AccessControlContext. * This is not a public constructor. */ Thread(Runnable target, AccessControlContext acc) { init(null, target, \\\"Thread-\\\" + nextThreadNum(), 0, acc, false); } //Runnable @FunctionalInterface public interface Runnable { /** * When an object implementing interface <code>Runnable</code> is used * to create a thread, starting the thread causes the object's * <code>run</code> method to be called in that separately executing * thread. * <p> * The general contract of the method <code>run</code> is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } \"]},\"140\":{\"h\":\"方法\",\"t\":[\"20250226175843\",\"创建好后，通过调用start()方法来运行此线程:\",\"public static void main(String[] args) { Thread t = new Thread(() -> { //直接编写逻辑 System.out.println(\\\"我是另一个线程！\\\"); }); t.start(); //调用此方法来开始执行此线程 } \",\"Thread.currentThread() // 获取当前线程对象 Thread t = new Thread(() -> { //自定义线程名称 System.out.println(\\\"我是另一个线程！\\\"); }, \\\"name\\\"); Thread.currentThread().getName() // 获取线程名称 \"]},\"141\":{\"h\":\"方法\",\"t\":[\"run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\"]},\"142\":{\"h\":\"方法\",\"t\":[\"实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间\",\"Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s \",\"我们也可以使用stop()方法来强行终止此线程\",\"public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i < 50; i++) { System.out.println(\\\"打印:\\\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } \",\"虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\"]},\"143\":{\"h\":\"线程的休眠和中断\",\"t\":[\"20250226175843\",\"一个线程处于运行状态下，线程的下一个状态会出现以下情况：\",\"当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。\",\"当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。\",\"当线程出现异常或错误 / 被 stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。\",\"通过调用sleep()方法可以将当前线程进入休眠，使得线程处于等待状态一段时间。\",\"在sleep代码中可以发现，显示声明了会抛出一个InterruptedException异常\",\"public static native void sleep(long millis) throws InterruptedException; \"]},\"144\":{\"h\":\"中断\",\"t\":[\"每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。\",\"interrupt用法：\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\\\"线程被中断了！\\\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } \",\"通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\",\"Thread.interrupted(); /复位中断标记（返回值是当前是否有中断标记） \"]},\"145\":{\"h\":\"线程优先级\",\"t\":[\"Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！ 我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\",\"MIN_PRIORITY 最低优先级\",\"MAX_PRIORITY 最高优先级\",\"NOM_PRIORITY 常规优先级\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } \",\"优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\"]},\"146\":{\"h\":\"线程的礼让和加入\"},\"147\":{\"h\":\"主动让出CPU资源\",\"t\":[\"我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { if(i % 5 == 0) { System.out.println(\\\"让位！\\\"); Thread.yield(); } System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); } }); t1.start(); t2.start(); } \",\"观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\"]},\"148\":{\"h\":\"\",\"t\":[\"当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入:\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); if(i == 10){ try { System.out.println(\\\"线程1加入到此线程！\\\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } \",\"我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！\"]},\"149\":{\"c\":[\"code\"]},\"150\":{\"c\":[\"java\"]},\"151\":{\"h\":\"Java - 多线程与反射2\"},\"152\":{\"h\":\"多线程2\"},\"153\":{\"h\":\"线程锁和线程同步\"},\"154\":{\"h\":\"多线程下java内存管理\",\"t\":[\"20250226223324\",\"线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。\",\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：\",\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\",\"实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！ 好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\",\"比如我们可以来看看下面这个问题：\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\"]},\"155\":{\"h\":\"线程锁\",\"t\":[\"为了避免上面的这个现象，引入 线程锁 的概念\",\"synchronized(对象 | 类){ 代码块 } \",\"synchronized需要在括号中填入一个内容，必须是一个对象或是一个类，因此有对象锁和类锁区别（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\",\"当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC中我们还会讲到乐观锁，如CAS算法）\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\",\"synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\",\"private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"我们发现实际上效果是相同的，只不过这个锁不用你去给， 如果是静态方法，就是使用的类锁，\",\"public class Main { private static int i = 0; private static synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (Main.class){ // Main.class 就保证三个线程的锁是一致的 类锁 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"而如果是普通成员方法，就是使用的对象锁。\",\"public class Main { private static int i = 0; private synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { Main main = new Main(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (main){ // 使用 main 才正确 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。\"]},\"156\":{\"h\":\"死锁\",\"t\":[\"死锁是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\",\"20250226231025\",\"我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\\\"线程1\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\\\"线程2\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } \",\"所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？ 我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程号，然后 jstack pid 即可\",\"jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。\",\"因此，前面说不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\"]},\"157\":{\"c\":[\"code\"]},\"158\":{\"c\":[\"java\"]},\"159\":{\"h\":\"Java - 多线程与反射3\"},\"160\":{\"h\":\"多线程3\"},\"161\":{\"h\":\"和 方法\",\"t\":[\"Object 类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()\",\"他们其实是需要配合synchronized来使用的，平常环境下是无法使用的，只有当对象作为锁时，才能用这三个方法。\",\"实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了。\",\"wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁。wait需要捕获 InterruptedException终止异常。\",\"当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\",\"notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\",\"wait()方法是让该线程从 运行态 -> 等待(waiting)态; notify()则是让处于 等待态的线程变为 阻塞态，所以仍然需要等在运行的线程结束才会转为运行态。\",\"wait()支持参数，可以给他传一个时间参数进去的，是一种自动唤醒机制：在指定时间内，如果没有其他线程唤醒自己，则主动唤醒自己。\",\"如果是 wait() | wait(0) 则表示永久等待，必须要有 notify()才会转换\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { System.out.println(\\\"开始等待\\\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\\\"等待结束！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o1){ System.out.println(\\\"开始唤醒！\\\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i < 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } \"]},\"162\":{\"h\":\"\",\"t\":[\"专门创建一个独属于某个线程的变量\",\"20250309155822\",\"我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部只能存储一个变量，不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。\",\"ThreadLocal定义在主线程中\",\"public static void main(String[] args) throws InterruptedException { ThreadLocal<String> local = new ThreadLocal<>(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -> { local.set(\\\"penguin\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程1变量值已设定！\\\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"线程1读取变量值：\\\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -> { local.set(\\\"pig\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程2变量值已设定！\\\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } \",\"不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\"]},\"163\":{\"h\":\"\",\"t\":[\"为子线程的 local 设置初始值，如果子线程修改了也是可以\",\"public static void main(String[] args) { ThreadLocal<String> local = new InheritableThreadLocal<>(); Thread t = new Thread(() -> { local.set(\\\"lbwnb\\\"); new Thread(() -> { System.out.println(local.get()); }).start(); }); t.start(); } \"]},\"164\":{\"h\":\"定时器\"},\"165\":{\"h\":\"自己定义的定时器\",\"t\":[\"public static void main(String[] args) { new TimerTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -> { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \",\"public static void main(String[] args) { new TimerLoopTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -> { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \"]},\"166\":{\"h\":\"\",\"t\":[\"我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等\",\"public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000, 500); //执行一个延时任务 // 运行函数，延迟，循环间隔 } \"]},\"167\":{\"h\":\"不会终止\",\"t\":[\"虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\",\"public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } \",\"TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\",\"public Timer(String name) { thread.setName(name); thread.start(); } \",\"而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\",\"public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() && newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } } } \",\"我们可以通过调用cancel()方法来关闭它的工作线程：\",\"public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } \"]},\"168\":{\"c\":[\"code\"]},\"169\":{\"c\":[\"java\"]},\"170\":{\"h\":\"Java - 多线程与反射4\"},\"171\":{\"h\":\"多线程4\"},\"172\":{\"h\":\"守护线程\",\"t\":[\"t.setDaemon(true);\",\"守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。\",\"而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂。\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \",\"在守护线程中产生的新线程也是守护的：\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { Thread it = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \"]},\"173\":{\"h\":\"集合类\",\"t\":[\"java中也有些使用并行来进行操作的\",\"集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。\",\"并行流 parallelStream()\",\" default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作 } \",\"并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\",\" public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -> System.out.println(Thread.currentThread().getName()+\\\" -> \\\"+i)); } \",\"我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序。\",\"在Arrays数组工具类中，也包含大量的并行方法：\",\" public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } \",\"集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题\"]},\"174\":{\"h\":\"生产者与消费者\",\"t\":[\"所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\",\"通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\",\"public class Main { private static final Queue<Object> queue = new LinkedList<>(); public static void main(String[] args) { new Thread(Main::add, \\\"厨师1\\\").start(); new Thread(Main::add, \\\"厨师2\\\").start(); new Thread(Main::take, \\\"顾客1\\\").start(); new Thread(Main::take, \\\"顾客2\\\").start(); new Thread(Main::take, \\\"顾客3\\\").start(); } private static void add(){ while (true){ try { Thread.sleep(3000); synchronized (queue) { String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"put menu\\\"); queue.offer(new Object()); queue.notifyAll(); } } catch (InterruptedException e) { e.printStackTrace(); } } } private static void take(){ while (true) { try { synchronized (queue){ while(queue.isEmpty())queue.wait(); queue.poll(); String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"eat\\\"); } Thread.sleep(4000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \"]},\"175\":{\"c\":[\"code\"]},\"176\":{\"c\":[\"java\"]},\"177\":{\"h\":\"Java - 反射1\"},\"178\":{\"h\":\"反射1\"},\"179\":{\"h\":\"反射\",\"t\":[\"反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\",\"简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\"]},\"180\":{\"h\":\"JAVA 类加载机制\",\"t\":[\"20250310160214\",\"在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\",\"简单理解为： 默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。\",\"Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。\"]},\"181\":{\"h\":\"Class 类\",\"t\":[\"在类加载过程的同时，会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。\"]},\"182\":{\"h\":\"获取相应类的Class对象\",\"t\":[\"共有三种方法，无论哪种方法所获取到的 Class 对象始终是相同的。 所以类锁本质上就是对应的类的 Class 对象。\",\"public static void main(String[] args) throws ClassNotFoundException { Class<String> clazz = String.class; //使用class关键字，通过类名获取 Class<?> clazz2 = Class.forName(\\\"java.lang.String\\\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class<?> Class<?> clazz3 = new String(\\\"cpdd\\\").getClass(); //通过实例对象获取 } \"]},\"183\":{\"h\":\"基本数据类型的 Class 对象\",\"t\":[\"基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的.\",\"/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\\\"unchecked\\\") public static final Class<Integer> TYPE = (Class<Integer>) Class.getPrimitiveClass(\\\"int\\\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class<?> getPrimitiveClass(String name); //C++实现，并非Java定义 \",\"每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\",\"包装类型都有一个TYPE，其实也就是基本类型的Class，但包装类的Class和基本类的Class显然是不同的。\",\"public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } \"]},\"184\":{\"h\":\"数组的 Class 对象\",\"t\":[\"数组类型也是一种类型，只是编程不可见\",\"public static void main(String[] args) { Class<String[]> clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\\\"10\\\"))); //强制类型转换（会报错） } \"]},\"185\":{\"h\":\"Class 对象与多态\"},\"186\":{\"h\":\"类型比较\",\"t\":[\"正常情况下，我们使用instanceof进行类型比较, 它可以判断一个对象是否为此接口或是类的实现或是子类：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str instanceof String); } \",\"有了 Class 后，可以有其他方式判断类型：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } \",\"asSubClass()，判断是否为子类或是接口/抽象类的实现\",\" public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } \",\"getSuperclass()，可以获取到父类的Class对象\",\" public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } \",\"getGenericSuperclass()，获取父类的原始类型的Type\",\" public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } \",\"我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class\",\" public static void main(String[] args) { Integer i = 10; for (Class<?> anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } \",\"泛型的参数获取 ParameterizedType | TypeVariableImpl\",\"如果一个类的父类是泛型，其对应的 class 就不是正常的 class， 而是一个参数化类型:\",\"class sun.reflect.generics.reflectiveObjects.TypeVariableImpl\",\"对应地，我们从 参数化类型中可以获取到泛型在定义过程中的参数类型 getActualTypeArguments。\",\" public static void main(String[] args) { ParameterizedType type = (ParameterizedType) ArrayList.class.getGenericSuperclass(); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"在这种情况下，对应的 type 由于泛型中未定义，所以是 E, 对应的class 类型为 TypeVariableImpl\",\"20250310165216\",\"如果我们已经明确了继承的泛型的类型，那么对应返回的就是确定的类型 class\",\" <!-- Test.java --> public class Test <T> { } <!-- Student.java --> public class Student extends Test<String> { String name; int age; } <!-- Main.java --> public static void main(String[] args) { ParameterizedType type = (ParameterizedType) Student.class.getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170039\",\"此外，如果这种情况，由于类型擦除机制，仍然是获取不到具体的 class 的, 返回的仍然是 E\",\" public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"ASDF\\\")); ParameterizedType type = (ParameterizedType) list.getClass().getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170551\"]},\"187\":{\"c\":[\"code\"]},\"188\":{\"c\":[\"java\"]},\"189\":{\"h\":\"Java - 反射2\"},\"190\":{\"h\":\"反射2\"},\"191\":{\"h\":\"创建类对象\",\"t\":[\"可以通过Class对象来创建对象、调用方法、修改变量。\",\"我们通过 newInstance() 即可创建对应的对象实例。\",\"通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常\",\"当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。\",\"当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class<Student> clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\\\"萨日朗\\\"); } } \",\"在JDK9之后，不再推荐使用newInstance()方法, 而是通过获取构造器 getConstructor()，来实例化对象，通过获取类的构造方法（构造器）来创建对象实例，会更加合理。 我们可以使用getConstructor()方法来获取类的权限为 public 的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型\",\" public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getConstructor(String.class); Student student = constructor.newInstance(\\\"penguin\\\"); student.test(); } public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(){ System.out.println(this.name); } } \",\"当访问权限不是public的时候, 会无法找到此构造方法, 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）.\",\" Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\\\"what's up\\\"); student.test(); \"]},\"192\":{\"h\":\"调用类方法\",\"t\":[\"我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用。\",\"通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。\",\"// Student.java package com.test; public class Student { public void test(String str){ System.out.println(\\\"Penguin \\\"+str); } } // Main.java public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \\\"!!!\\\"); //通过Method对象的invoke方法来调用方法 } \",\"我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。\",\"同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用, 即通过 getDeclaredMethod + setAccessible 组合。\",\"// 将test()方法的权限修饰符改为private后 public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \\\"what's up\\\"); //通过Method对象的invoke方法来调用方法 } \",\"Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息(``)：\",\"// Student.java public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(String s, int i){ System.out.println(this.name); } } // Main.java public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Constructor<?> constructor = clazz.getConstructor(String.class); Object penguin = constructor.newInstance(\\\"penguin\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class, int.class); method.invoke(penguin, \\\"qq\\\", 123); System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 for (Parameter parameter : method.getParameters()) { System.out.println(parameter); } } \",\"20250312002044\",\"当方法的参数为可变参数时, 变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：\",\"Method method = clazz.getDeclaredMethod(\\\"test\\\", String[].class); \",\"当方法是静态方法时，invoke不需要对象参数，因为是属于类的。\",\"反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。\"]},\"193\":{\"h\":\"修改类的属性\",\"t\":[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段，在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，当访问private字段时，同样可以按照上面的操作进行越权访问（JAVA高版本不行，对反射进行了限制）\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, NoSuchFieldException { Integer i = 10; Field value = Integer.class.getDeclaredField(\\\"value\\\"); value.setAccessible(true); System.out.println(value.get(i)); value.set(i, 20); System.out.println(i); } \",\"通过反射可以直接将final修饰符直接去除\",\"public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\\\"value\\\"); Field modifiersField = Field.class.getDeclaredField(\\\"modifiers\\\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()&~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } \",\"我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：\",\"public static void main(String[] args) throws ReflectiveOperationException { List<String> i = new ArrayList<>(); Field field = ArrayList.class.getDeclaredField(\\\"size\\\"); field.setAccessible(true); field.set(i, 10); i.add(\\\"测试\\\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } \",\"实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！\",\"再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！\"]},\"194\":{\"c\":[\"code\"]},\"195\":{\"c\":[\"java\"]},\"196\":{\"h\":\"Java - 反射3\"},\"197\":{\"h\":\"反射3\"},\"198\":{\"h\":\"类加载器\",\"t\":[\"类加载器就是用于加载一个类的，但是类加载器并不是只有一个。\",\"思考： 既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？\",\"package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\\\"我姓🐴，我叫🐴nb\\\"); } } \",\"会出现以下报错：\",\"错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) \",\"但是我们明明在自己写的String类中定义了main方法，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行\",\"20250312005934\",\"实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了。\",\"public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } \"]},\"199\":{\"h\":\"自己编译的类加载到 JVM 中\",\"t\":[\"既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：\",\"package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\\\" > 我是测试方法！\\\"+str); } } \",\"通过javac命令，手动编译一个.class文件：\",\"javac src/main/java/com/test/Test.java \",\"编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：\",\"//定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class<?> defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\\\"Test.class\\\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class<?> clazz = classLoader.defineClass(\\\"com.test.Test\\\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } \",\"现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：\",\"try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"我们来试试看修改成员字段之后，再来调用此方法：\",\"try { Object obj = clazz.newInstance(); Field field = clazz.getField(\\\"text\\\"); //获取成员变量 String text; field.set(obj, \\\"华强\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。\"]},\"200\":{\"c\":[\"code\"]},\"201\":{\"c\":[\"java\"]},\"202\":{\"h\":\"Java - 注解\"},\"203\":{\"h\":\"注解\",\"t\":[\"注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。\",\"比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。\"]},\"204\":{\"h\":\"预设注解\",\"t\":[\"JDK预设了以下注解，作用于代码：\",\"@Override- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\",\"@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。\",\"@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）\",\"@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。\",\"@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\"]},\"205\":{\"h\":\"元注解\",\"t\":[\"元注解是作用于注解上的注解，用于我们编写自定义的注解：\",\"@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\",\"@Documented - 标记这些注解是否包含在用户文档中。\",\"@Target - 标记这个注解应该是哪种 Java 成员。\",\"@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\",\"@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\"]},\"206\":{\"h\":\"定义\",\"t\":[\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。\",\"@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。\",\"既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } \",\"这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：\",\"@Test public class Main { @Test public static void main(String[] args) { } } \",\"这样，一个最简单的注解就被我们创建了。\"]},\"207\":{\"h\":\"注解的使用\",\"t\":[\"我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } \",\"默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } \",\"public class Main { @Test(test = \\\"\\\") public static void main(String[] args) { } } \",\"我们也可以使用default关键字来为这些属性指定默认值：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \\\"ppenguin！\\\"; } \",\"当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } \",\"当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：\",\"@Test(\\\"aasd\\\") public static void main(String[] args) { } \",\"public class Main { @Test({\\\"value1\\\", \\\"value2\\\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } \"]},\"208\":{\"h\":\"反射获取注解\",\"t\":[\"既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：\",\" // Test.java import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } // Main.java public static void main(String[] args) { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：\",\"public static void main(String[] args) throws NoSuchMethodException { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getMethod(\\\"test\\\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。\",\"所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。\"]},\"209\":{\"c\":[\"code\"]},\"210\":{\"c\":[\"java\"]},\"211\":{\"h\":\"Java - 类与对象3\"},\"212\":{\"h\":\"封装 继承和多态\",\"t\":[\"封装、继承和多态是面向对象编程的三大特性。\",\"封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\",\"继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\",\"多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\",\"正是这三大特性，让我们的Java程序更加生动形象。\"]},\"213\":{\"h\":\"封装\"},\"214\":{\"h\":\"继承\",\"t\":[\"父类是 super 子类是 this\"]},\"215\":{\"h\":\"Object 类\",\"t\":[\"Object 是最顶层的类，所有其他类都是继承它的 方法： euqals toString clone hashcode\",\"public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class<?> getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } \"]},\"216\":{\"h\":\"方法重写\",\"t\":[\"方法的重载是为某个方法提供更多种类 而方法的重写是覆盖原有的方法实现,重写方法要求与父类的定义完全一致 比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了\",\"public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) && //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age && //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } \",\"在修改后 即使强制类型转换 但实际上还是在调用本身的方法\",\" Person p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); Person p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 \",\"我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用 super 关键字： satic 成员方法中不能用 super\",\"@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } \",\"如果父类的方法是 private, 那么无法重写\"]},\"217\":{\"h\":\"控制符\",\"t\":[\"final 对于成员变量，则表示只能赋一次值。只能在构造函数进行赋值(如果有初始值，构造函数也不能赋值)，其他地方不能修改 对于成员方法，会限制其子类不允许其重写所对应的成员变量 在 类 上 加 final, 表示这个类不能再被继承了\"]},\"218\":{\"h\":\"抽象类\",\"t\":[\"抽象类具有 抽象方法，正常实例化方法是无法创造抽象类的实例\",\"抽象方法是指：只保留方法的定义，并不编写方法的主体，具体的实现由 子类 来实现.\",\"要使用抽象类，我们只能去创建它的子类对象。\",\"抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类\",\"抽象方法的访问权限不能为 private, 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\",\"public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } \",\"而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法 不过如果子类也是抽象类，就不一定需要实现。\",\"public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \\\"工人\\\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } } \",\"发现对于 抽象类 中定义的 抽象方法，其子类的对应的方法的访问权限需要高于抽象类中的方法，且同样不能使用 private。 即 如果抽象方法在抽象类定义的是 public, 子类对应必须是 public 不能是 protected; 而如果抽象类定义的是 protected，子类也可以定义 public\"]},\"219\":{\"h\":\"接口\",\"t\":[\"接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\",\"接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\",\"实际上接口的目标就是将类所具有某些的行为抽象出来。\",\"可以理解为 接口 相当于 只有抽象类中的抽象方法，甚至都不是一个类了。\",\"接口里只能定义对应的抽象方法，不过可以省略 abstract 定义 并且默认在类中实现的权限是 public\",\"定义接口 interface\",\"实现接口 implements\",\"接口可以实现很多个，只需要用 逗号 隔开即可，类只能继承一个、\",\"所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\",\"java8开始，接口中的方法可以存在默认实现，default 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\",\"接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法 接口中定义的静态变量只能是public static final的 接口中定义的静态方法也只能是public的 这些可以省 直接int a = 1static void test()这种即可 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容\",\"接口是可以继承 (extends) 自其他接口的, 并且接口没有继承数量限制，接口支持多继承 接口的继承相当于是对接口功能的融合罢了\",\"接口的默认方法是保底的，只要一个类的父类或者自身有对应方法，就不会执行接口的默认方法\",\"接口中如果定义了与 Object 同名的方法，不能使用默认，因为其他类就算继承这个接口，由于类本身都是继承 Object 的，这个默认方法没有任何作用\",\"比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\",\"接口定义:\",\"public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } \",\"让类来使用这个接口\",\"public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\\\"我会学习！\\\"); } } \",\"接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用，即\",\"public class Main { public static void main(String[] args) { Study study = new Teacher(\\\"penguin\\\",18,\\\"male\\\"); study.study() //这里的话只能使用接口中的方法，以及Object的方法 } } \",\"接口同样支持向下转型：\",\"public static void main(String[] args) { Study study = new Teacher(\\\"小王\\\", 27, \\\"男\\\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } \",\"从Java8开始，接口中可以存在让抽象方法的默认实现：\",\"public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\\\"我是默认实现\\\"); } } \"]},\"220\":{\"h\":\"Object类中的 克隆方法\",\"t\":[\"这是浅拷贝，克隆出来的与原来的对象不是一个对象，但对象中的属性都是同一个地址\",\"克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\",\"浅拷贝： 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。\",\"深拷贝： 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。\",\"package java.lang; public interface Cloneable { //这个接口中什么都没定义 } \",\"具体实现克隆:\",\"public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\\\"我会学习！\\\"); } } \",\"克隆实现：\",\"public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } \"]},\"221\":{\"h\":\"枚举类\",\"t\":[\"public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } \",\"使用枚举类也非常方便，就像使用普通类型那样：\",\"public class Student { private Status status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } \",\"使用就像对象的参数一样:\",\"Status.RUNNING Status.STUDY Status.SLEEP \",\"枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\",\"//这里使用javap命令对class文件进行反编译得到 Compiled from \\\"Status.java\\\" public final class com.test.Status extends java.lang.Enum<com.test.Status> { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } \",\"枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\",\"public enum Status { RUNNING(\\\"睡觉\\\"), STUDY(\\\"学习\\\"), SLEEP(\\\"睡觉\\\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } \",\"public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } \"]},\"222\":{\"c\":[\"code\"]},\"223\":{\"c\":[\"java\"]},\"224\":{\"h\":\"Java - 类与对象4\"},\"225\":{\"h\":\"面向对象高级篇1\"},\"226\":{\"h\":\"基本类型包装类\",\"t\":[\"Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\"]},\"227\":{\"h\":\"所有包装类如下\",\"t\":[\"20241017002218\",\"其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\",\"byte -> Byte\",\"boolean -> Boolean\",\"short -> Short\",\"char -> Character\",\"int -> Integer\",\"long -> Long\",\"float -> Float\",\"double -> Double\",\"包装类型的自动装箱和拆箱机制 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想） 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\",\" public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 // 不需要 Integer i = new Integer(10) // 这里本质上就是被自动包装成了一个Integer类型的对象， // 只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的 Integer i = 10; int a = i; } \",\"因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\",\" public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } \",\"那么自动装箱的呢？\",\" public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\",\"但是如果超出这个缓存范围的话，就会得到不同的对象了：\",\"public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制。\"]},\"228\":{\"h\":\"包装类的方法\",\"t\":[\"包装类支持字符串直接转换\",\" public static void main(String[] args) { Integer i = new Integer(\\\"666\\\"); //直接将字符串的666，转换为数字666 System.out.println(i); // 字符串转Integer有多个方法： Integer i = Integer.valueOf(\\\"5555\\\"); Integer i = Integer.decode(\\\"0xA6\\\"); Integer.toHexString(166) } \"]},\"229\":{\"h\":\"特殊包装类\",\"t\":[\"BigInteger 和 BigDecimal 都在 java.math 中\",\"Void类 没啥意义 不能 new 只能 Void v = null\",\"BigInteger import java.math.BigInteger 用于计算超大数字，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字。 但不支持 自动装箱|拆箱机制，计算的话也只能通过 BigInteger 提供的方法进行计算。 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\",\" public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); BigInteger h = BigInteger.valueOf(100) // 乘法 BigInteger a = h.multiply(BigInteger.TEN) } \",\"BigDecimal import java.math.BigDecimal 浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算\",\"public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } \"]},\"230\":{\"c\":[\"code\"]},\"231\":{\"c\":[\"java\"]},\"232\":{\"h\":\"Java - 数组 | 字符串 | 正则表达式\"},\"233\":{\"h\":\"面向对象高级篇 2\"},\"234\":{\"h\":\"数组\",\"t\":[\"数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素。\"]},\"235\":{\"h\":\"定义\",\"t\":[\"数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建） 即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用 new 关键字\",\"public static void main(String[] args) { int[] array = new int[10]; //类型[]就表示这个是一个数组类型 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } \",\"创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的 其他定义方法:\",\"类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 \"]},\"236\":{\"h\":\"方法\",\"t\":[\"数组的 length 是在一开始就确定的，而且是 final类型 的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\",\" public static void main(String[] args) { int[] array = new int[10]; System.out.println(\\\"当前数组长度为：\\\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } \",\"array 虽然是继承于 Object，但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现，所以可能不满足真实需求。\"]},\"237\":{\"h\":\"访问元素\",\"t\":[\"for 或者 foreach\",\" public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i < array.length; i++) { System.out.print(array[i] + \\\" \\\"); } for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\\\" \\\"); //每一轮循环，i都会更新成数组中下一个元素 } } \"]},\"238\":{\"h\":\"特性\",\"t\":[\"这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\",\" public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; // 这样是不能赋值的 会报错 } \",\"由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的, 即 int[] arr = new int[10] 是不能 Object[] arrav = arr 这样的\",\"但是如果是引用类型的话，是可以的,因为父类都是 Object\",\" public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } \"]},\"239\":{\"h\":\"性质\",\"t\":[\" public static void main(String[] args) { final int[] a = {1,2,3,4}; // 值还是可以修改，只是数组的地址不准修改 a[0] = 4; // 允许 a = {2,4,8,7}; //不允许 } \"]},\"240\":{\"h\":\"多维数组\",\"t\":[\"既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的\",\"public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } \"]},\"241\":{\"h\":\"可变长参数\",\"t\":[\"public void function(参数类型...参数名称) 这样参数名称所表示的就是一个数组\",\"public class Person { String name; int age; String sex; // 可以传入 0 - N 个类型的实参 public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } } public static void main(String[] args) { Person person = new Person(); person.test(\\\"1！\\\", \\\"5！\\\", \\\"哥们在这跟你说唱\\\"); //这里我们可以自由传入任意数量的字符串 } \",\"注意，如果同时存在其他参数，那么可变长参数只能放在最后：\",\"public void test(int a, int b, String... strings){ } \"]},\"242\":{\"h\":\"函数的\",\"t\":[\"public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } \",\"可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：java com/test/Main lbwnb aaaa xxxxx 因此会读取命令行中的指令参数进行存储到 args 中。\"]},\"243\":{\"h\":\"字符串\",\"t\":[\"字符串类是一个比较特殊的类，它用于保存字符串。 我们知道，基本类型 char 可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组） Java中没有字符串这种基本类型，因此只能使用类来进行定义。 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\"]},\"244\":{\"h\":\"String 类\",\"t\":[\"String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象, 也可以象征性 new 不过没必要 如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了\",\"public static void main(String[] args) { String str1 = \\\"Hello World\\\"; String str2 = \\\"Hello World\\\"; System.out.println(str1 == str2); // 这样就不同 String str3 = new String(\\\"Hello World\\\"); String str4 = new String(\\\"Hello World\\\"); System.out.println(str3 == str4); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } \",\"因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用 ==， String类重载了equals方法用于判断和比较内容是否相同\",\"获取长度 str.length()\",\"public static void main(String[] args) { String str = \\\"Hello World\\\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } \",\"字符串类中提供了很多方便我们操作的方法， 比如字符串的裁剪 (substring)、分割操作 (split)\",\" public static void main(String[] args) { String str = \\\"Hello World\\\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); String[] strings = str.split(\\\" \\\"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } \",\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组: char[] chars = str.toCharArray()字符数组转字符串: String str = new String(chars)\"]},\"245\":{\"h\":\"StringBuilder 类\",\"t\":[\"StringBuilder 就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足\",\"public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\\\"AAA\\\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\\\"BBB\\\"); builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } \",\"字符串支持使用 + 和 += 进行拼接操作, 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\",\"对于变量来说\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } \",\"如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？ 这种情况实际上会被优化为下面的写法：\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } \"]},\"246\":{\"h\":\"正则表达式\",\"t\":[\"str.match(正则表达式)\",\"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\",\"public static void main(String[] args) { String str = \\\"oooo\\\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\\\"o+\\\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } \",\"用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\",\"字符\",\"描述\",\"*\",\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \\\"z\\\" 以及 \\\"zoo\\\"。***** 等价于 {0,}。\",\"+\",\"匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \\\"zo\\\" 以及 \\\"zoo\\\"，但不能匹配 \\\"z\\\"。+ 等价于 {1,}。\",\"?\",\"匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \\\"do\\\" 、 \\\"does\\\"、 \\\"doxy\\\" 中的 \\\"do\\\" 。? 等价于 {0,1}。\",\"{n}\",\"n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \\\"Bob\\\" 中的 o，但是能匹配 \\\"food\\\" 中的两个 o。\",\"{n,}\",\"n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \\\"Bob\\\" 中的 o，但能匹配 \\\"foooood\\\" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\",\"{n,m}\",\"m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \\\"fooooood\\\" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\",\"如果我们想要表示一个范围内的字符，可以使用方括号：\",\"public static void main(String[] args) { String str = \\\"abcabccaa\\\"; System.out.println(str.matches(\\\"[abc]*\\\")); //表示abc这几个字符可以出现 0 - N 次 } \",\"对于普通字符来说，我们可以下面的方式实现多种字符匹配：\",\"字符\",\"描述\",\"[ABC]\",\"匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中所有的 e o u a 字母。\",\"[^ABC]\",\"匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中除了 e o u a 字母的所有字母。\",\"[A-Z]\",\"[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。\",\".\",\"匹配除换行符（\\\\n、\\\\r）之外的任何单个字符，相等于 [^\\\\n\\\\r]\",\"[\\\\s\\\\S]\",\"匹配所有。\\\\s 是匹配所有空白符，包括换行，\\\\S 非空白符，不包括换行。\",\"\\\\w\",\"匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\",\"当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\",\"正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\"]},\"247\":{\"c\":[\"code\"]},\"248\":{\"c\":[\"java\"]},\"249\":{\"h\":\"Java - 内部类\",\"t\":[\"静态 属于 类， 成员 属于 对象。\"]},\"250\":{\"h\":\"内部类\",\"t\":[\"内部类顾名思义，就是创建在内部的类。\"]},\"251\":{\"h\":\"成员内部类 (属于 对象)\",\"t\":[\"成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用\",\"成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的， 如果我们要使用成员内部类，那么就需要创造一个对象，才能去 new 一个成员内部类。\",\"我们可以直接在类的内部定义成员内部类：\",\"public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\\\"我是成员内部类！\\\"); } } } \",\"public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 inner.test(); } \",\"注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.\",\"这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\\\"我是成员内部类：\\\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } \",\"每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\",\"20241027012950\",\"public static void main(String[] args) { Test a = new Test(\\\"小明\\\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\\\"小红\\\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } \",\"那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个 (就近原则) 如果需要指定为外部的对象，那么需要在前面添加外部类型名称Test.this.\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\\\"方法参数的name = \\\"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\\\"成员内部类的name = \\\"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\\\"成员内部类的name = \\\"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } \",\"包括对方法的调用和super关键字的使用，也是一样的：\",\"public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } \"]},\"252\":{\"h\":\"静态内部类 (属于 类)\",\"t\":[\"静态内部类就像静态方法和静态变量一样，是属于类的，不需要，依附任何对象我们可以直接创建使用。\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\\\"我是静态内部类！\\\"); } } } \",\"不需要依附任何对象，我们可以直接创建静态内部类的对象：\",\"public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } \",\"静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的\"]},\"253\":{\"h\":\"局部内部类\",\"t\":[\"(这种局部内部类的形式，使用频率很低，基本上不会用到) 局部内部类就像局部变量一样，可以在方法中定义。 基本定义是：(不需要声明访问权限，因为它作用范围就只是方法内)\",\"public 方法名(){ class 局部内部类名 { 内容 } } \",\"既然是在方法中声明的类，那作用范围也就只能在方法中了\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 public void test(){ System.out.println(\\\"我是局部内部类\\\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } \"]},\"254\":{\"h\":\"静态内部类编译特性\",\"t\":[\"package com.test; import com.test.entity.Test; public class Main { public static void main(String[] args) { Test.Inner.test(); } } \",\"package com.test.entity; public class Test { static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"内部类静态方法\\\"); } } } \",\"结果是：\",\"20241027015244\",\"说明这种情况下，只是初始化了内部类的，并没有初始化内部类，因为并没有使用到外部类的任何静态变量，所以只初始化了内部类。 因为在编译的时候，类的内部类它会单独生成一个 .class，当你使用内部类静态方法，不会调用外部类的 class 只有在你使用到外部类的静态变量或方法后，才会初始化外部类, 但还是先初始化内部类。\",\"package com.test.entity; public class Test { public static String name = \\\"penguin\\\"; static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"使用外部静态变量\\\" + name); System.out.println(\\\"内部类静态方法\\\"); } } } \",\"输出为：\",\"20241027015718\"]},\"255\":{\"h\":\"匿名内部类\",\"t\":[\"匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\",\"不能直接通过 new 的方式去创建一个抽象类或是接口对象，正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\",\"但我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象\",\"public abstract class Student { public abstract void test(); } \",\"public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\\\"我是匿名内部类的实现!\\\"); } }; student.test(); } \",\"此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）\",\"同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类 这样就是一个实现 接口 中方法 的匿名类，但类名必须与接口一致。\",\"package com.test.entity; public interface Study { void study(); } \",\"public class Main { public static void main(String[] args) { Study ss = new Study() { @Override public void study() { System.out.println(\\\"penguin\\\"); } }; ss.study(); } } \",\"匿名对象本身不能定义新的属性。匿名对象的类是在创建时匿名生成的，但它继承自一个现有的类或实现了一个接口。因此，匿名类只能访问其父类的属性或方法，无法直接定义新的属性.\",\"在 Java 中，匿名对象通常不能直接给属性赋值，因为匿名对象没有类名，无法显式定义构造函数或初始化块 因此，为了在创建匿名对象时进行属性初始化，Java 提供了一种特殊的语法，即使用初始化块 {}。\",\"当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 类似：\",\"package com.test.entity; public class Penguin { protected String apple; public void test(){ System.out.println(apple); } } \",\"public class Main { public static void main(String[] args) { Penguin pp = new Penguin(){ { apple = \\\"ppp\\\"; } }; pp.test(); } } \"]},\"256\":{\"h\":\"匿名内部类特性\",\"t\":[\"对于 匿名内部类 或者 Lambda 中，如果想用外部变量，只能使用 final 的变量，如果不是 final，会隐式修改为 final 即之后不能修改\",\"public static void main(String[] args) { int a = 10; // a = 20; // 如果修改了a 就会报错 Study pp = new Study{ @Override public void study(){ System.out.println(a); } } pp.test(); } \"]},\"257\":{\"h\":\"Lambda表达式\",\"t\":[\"如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式\",\"public static void main(String[] args) { Study study = () -> System.out.println(\\\"我是学习方法！\\\"); //是不是感觉非常简洁！ study.study(); } \",\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda 仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"如果有一个参数和返回值的话：\",\"public static void main(String[] args) { Study study = (a) -> { System.out.println(\\\"我是学习方法\\\"); return \\\"今天学会了\\\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } \",\"如果参数只有一个，那么可以省去小括号 如果方法体中只有一个返回语句，可以直接省去花括号和return关键字\",\"Study study = (a) -> { return \\\"今天学会了\\\"+a; //这种情况是可以简化的 }; ==================================== Study study = (a) -> \\\"今天学会了\\\"+a; ==================================== Study study = a -> \\\"今天学会了\\\"+a; \",\"如果一个方法的参数需要的是一个接口的实现:\",\"public static void main(String[] args) { test(a -> \\\"今天学会了\\\"+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } \",\"对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\"]},\"258\":{\"h\":\"方法引用\",\"t\":[\"方法引用 类名::方法名 就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义 参数一样，返回值一样 一样才行）\",\"public interface Study { int sum(int a, int b); //待实现的求和方法 } \",\"那么使用时候，可以直接使用Lambda表达式：\",\"public static void main(String[] args) { Study study = (a, b) -> a + b; } \",\"只不过还能更简单，因为Integer类中默认提供了求两个int值之和的静态方法：\",\"public static void main(String[] args) { Study study = (a, b) -> Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } ================= 方法引用 类名::方法名 ========================= public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } \",\"方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。\",\"任何方法都可以通过方法引用作为实现：\",\"public interface Study { String study(); } \",\"如果是普通成员方法 (成员方法只能通过 对象 调用，不是静态方法)，我们同样需要使用对象来进行方法引用：\",\"public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \\\"卡布奇诺今犹在，不见当年倒茶人。\\\"; } \",\"因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\",\"public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } \",\"反正只要是符合接口中方法的定义的，都可以直接进行方法引用。\"]},\"259\":{\"c\":[\"code\"]},\"260\":{\"c\":[\"java\"]},\"261\":{\"h\":\"Java - 异常\"},\"262\":{\"h\":\"面向对象高级篇 4\"},\"263\":{\"h\":\"异常机制\"},\"264\":{\"h\":\"异常类型\",\"t\":[\"我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等. 他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自 Exception 类\",\"运行时异常 继承自 RuntimeException 在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。 所有的运行时异常都继承自 RuntimeExceptionRuntimeException 是继承 Exception\",\"编译时异常 继承 Exception 编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！ 默认继承自 Exception 类的异常都是编译时异常。 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\",\"protected native Object clone() throws CloneNotSupportedException; \",\"20241029001425\",\"错误 Error错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了。 比如 OutOfMemoryError 就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\"]},\"265\":{\"h\":\"自定义异常\",\"t\":[\"异常其实就两大类，一个是编译时异常 Exception，一个是运行时异常 RuntimeException。 我们自定义异常也是从这两类中进行选择。\",\"自定义编译时异常 编译时异常只需要继承 Exception 就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\",\"public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } \",\"自定义运行时异常 运行时异常只需要继承 RuntimeException 就行了\",\"public class TestException extends RuntimeException{ public TestException(String message){ super(message); } } \"]},\"266\":{\"h\":\"抛出异常\",\"t\":[\"当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\",\"public static int test(int a, int b) { if(b == 0) throw new ArithmeticException(\\\"被除数不能为0\\\"); //throw new RuntimeException(\\\"被除数不能为0\\\"); //使用throw关键字来抛出异常 return a / b; } \",\"异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在 RuntimeException 的构造方法中我们可以写入原因。\",\"注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以，因为不这样就无法编译了： throws Exception\",\"就是说如果这个函数结束时有异常，要么自己处理好，要么就往上一级函数上 throw\",\"private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\\\"我是编译时异常！\\\"); } \",\"如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\",\"private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } \",\"最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\",\"@Override protected Object clone() { return new Object(); } \"]},\"267\":{\"h\":\"异常的处理\",\"t\":[\"当程序没有按照我们理想的样子运行而出现异常时（默认会交给 JVM 来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息） 现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获\",\"异常处理：要么一直 throw 交给上一级函数 最终到 main 给 jvm 处理; 要么在当前函数通过 try-catch 进行捕获。\",\"无论是否出现异常，都会在最后执行任务，可以交给 finally 语句块来处理，可以只跟 try 使用。\",\"public static void main(String[] args) { // try...catch 进行异常捕获 try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\\\"异常错误信息：\\\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\\\"程序继续正常运行！\\\"); } \",\"如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用 try-catch 语句块进行异常的捕获，不然就无法通过编译.\",\"public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } \",\"当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\",\"public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } \",\"注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到\",\"public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\\\"捕获到异常\\\"); } } \",\"当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 但是要注意一下顺序 try {} catch { xxxException | xxxException e }{ }\",\"try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } // 可以简写为 try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } \"]},\"268\":{\"h\":\"断言表达式\",\"t\":[\"我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下。\",\"assert断言表达式，如果 assert 后面的表达式判断结果为 false，将抛出 AssertionError 错误。\",\"比如我们可以判断变量的值，如果大于10就抛出错误：\",\"public static void main(String[] args) { int a = 10; assert a > 10; } \"]},\"269\":{\"c\":[\"code\"]},\"270\":{\"c\":[\"java\"]},\"271\":{\"h\":\"Java - 工具类\"},\"272\":{\"h\":\"面向对象高级篇 6\",\"t\":[\"工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\"]},\"273\":{\"h\":\"常用工具类\"},\"274\":{\"h\":\"数学工具类\",\"t\":[\"Math类 是在 java.util 中，因此可以直接调用。\",\"public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } \",\"随机数生成 Random 类\",\"import java.util.Random; public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i < 30; i++) { System.out.print(random.nextInt(100)+\\\" \\\"); //nextInt方法可以指定创建0 - x之内的随机数 } } \"]},\"275\":{\"h\":\"数组工具类\",\"t\":[\"Arrays类 是在 java.util 中，因此可以直接调用。\",\"一些方法：Arrays.toString | Arrays.sort | Arrays.fill | Arrays.copyOfArrays.deepToString 可以对 多维数组 打印\",\"Arrays类 用于便捷操作数组，比如我们想要打印数组，可以直接通过 toString 方法转换字符串：\",\"public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } \"]},\"276\":{\"c\":[\"code\"]},\"277\":{\"c\":[\"java\"]},\"278\":{\"h\":\"Java - 泛型 1\"},\"279\":{\"h\":\"泛型 1\"},\"280\":{\"h\":\"使用泛型的原因\",\"t\":[\"为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个 Score 类呢？\",\"现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\",\"可以直接使用一个 Object 类进行存储成绩\",\"public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } \",\"以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\",\"public static void main(String[] args) { Score score = new Score(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", \\\"优秀\\\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } \",\"使用Object类型作为引用，对于使用者来说，由于是 Object 类型，所以说并不能直接判断存储的类型到底是 String 还是 Integer ，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\",\"所以说这种解决办法虽然可行，但并不是最好的方案。\",\"为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效 率。\"]},\"281\":{\"h\":\"泛型类\",\"t\":[\"泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\",\"我们可以将一个类定义为一个泛型类：\",\"public class Score<T> { //泛型类需要使用<>，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; } } \",\"具体使用:\",\"public static void main(String[] args) { Score<String> score = new Score<String>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); // 因为现在有了类型变量，在使用时同样需要跟上<>并在其中填写明确要使用的类型 // 这样我们就可以根据不同的类型进行选择了 // 这种形式也可以 Score<String> score = new Score<>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value); } \",\"泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！\",\"因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用对象定义的泛型的\",\"我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个 Object 类型的变量，因为无论具体类型是什么，一定是 Object 类的子类。\",\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组.\",\"具体类型不同的泛型类变量，不能使用不同的变量进行接收 \",\"如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 ? 通配符 就好像默认其是 Object 类型\",\" public static void main(String[] args) { Test<?> test = new Test<Integer>(); test = new Test<String>(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成 Object } \",\"泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个 那么在使用时，就需要将这三种类型都进行明确指定\",\" public class Test<A, B, C> { //多个类型变量使用逗号隔开 public A a; public B b; public C c; } ------------------------------------- public static void main(String[] args) { Test<String, Integer, Character> test = new Test<>(); //使用钻石运算符可以省略其中的类型 test.a = \\\"lbwnb\\\"; test.b = 10; test.c = '淦'; } \",\"泛型只能确定为一个引用类型，基本类型是不支持的, 如果要存放基本数据类型的值，我们只能使用对应的包装类\",\"当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的\"]},\"282\":{\"h\":\"泛型和多态\",\"t\":[\"不只是类，包括接口、抽象类，都是可以支持泛型的：\",\"public interface Study<T> { T test(); } \",\"当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：\",\"public class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study<Integer> { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } } } \",\"或者是继续摆烂，依然使用泛型：\",\"public class Main { public static void main(String[] args) { A<String> a = new A<>(); String i = a.test(); } static class A<T> implements Study<T> { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } } } \",\"继承也是同样的：\",\"static class A<T> { } static class B extends A<String> { } \"]},\"283\":{\"c\":[\"code\"]},\"284\":{\"c\":[\"java\"]},\"285\":{\"h\":\"Java8回顾\"},\"286\":{\"h\":\"Java8\"},\"287\":{\"h\":\"Lambda 表达式\"},\"288\":{\"h\":\"匿名内部类\",\"t\":[\"在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：\",\"public static void main(String[] args) { //现在我们想新建一个线程来搞事情 Thread thread = new Thread(new Runnable() { //创建一个实现Runnable的匿名内部类 @Override public void run() { //具体的实现逻辑 System.out.println(\\\"Hello World!\\\"); } }); thread.start(); } \",\"在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在run()方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。\"]},\"289\":{\"h\":\"Lambda 使用\",\"t\":[\"在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减。\",\"真正有用的那一部分代码，实际上就是我们对run()方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，现在只需要一个简短的lambda表达式即可：\",\"public static void main(String[] args) { //现在我们想新建一个线程来做事情 Thread thread = new Thread(() -> { System.out.println(\\\"Hello World!\\\"); //只需留下我们需要具体实现的方法体 }); thread.start(); } \",\"即 原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于() ‐> { 代码语句 }的形式进行替换即可。\",\"这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。\",\"但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过invokedynamic指令实现的\",\"匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：\",\"//现在我们想新建一个线程来做事情 Thread thread = new Thread(() -> { throw new UnsupportedOperationException(); //这里我们拋个异常看看 }); thread.start(); \",\"alt text\",\"可以看到，实际上是Main类中的lambda$main$0()方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。 所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。 比如Runnable接口需要一个方法体对它的run()方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。\"]},\"290\":{\"h\":\"Lambda 具体规范\",\"t\":[\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"Java中接口的方法默认是 public abstract, 变量默认是 public static final\",\"比如我们之前使用的Runable类：\",\"@FunctionalInterface //添加了此注解的接口，都支持lambda表达式，符合函数式接口定义 public interface Runnable { public abstract void run(); //有且仅有一个抽象方法，此方法返回值为void，且没有参数 } \",\"因此，Runable的的匿名内部类实现，就可以简写为：\",\"Runnable runnable = () -> { }; \",\"我们也可以写一个：\",\"@FunctionalInterface public interface Test { //接口类型 String test(Integer i); //只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果 } \",\"它的Lambda表达式的实现就可以写为：\",\"Test test = (Integer i) -> { return i+\\\"\\\"; }; //这里我们就简单将i转换为字符串形式 \",\"不过还可以进行优化，首先方法参数类型是可以省略的：\",\"Test test = (i) -> { return i+\\\"\\\"; }; \",\"由于只有一个参数，可以不用添加小括号（多个参数时需要）：\",\"Test test = i -> { return i+\\\"\\\"; }; \",\"由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：\",\"Test test = i -> i+\\\"\\\"; \"]},\"291\":{\"h\":\"应用现有的方法函数作为方法体 (方法引用)\",\"t\":[\"Lambda 本质是：我们为所需要的接口提供了一个方法作为它的实现\",\"除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：\",\"String test(Integer i); //接口中的定义 \",\"public static void main(String[] args) { Test test = Main::impl; //使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现 } public static String impl(Integer i){ return \\\"我是已经存在的实现\\\"+i; } \",\"所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来）\"]},\"292\":{\"h\":\"方法引用 举例\",\"t\":[\"比如我们现在需要对一个数组进行排序：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; //来个数组 Arrays.sort(array, new Comparator<Integer>() { //Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可 @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); System.out.println(Arrays.toString(array)); //按从小到大的顺序排列 } \",\"但是我们发现，Integer类中有一个叫做compare的静态方法：\",\"public static int compare(int x, int y) { return (x < y) ? -1 : ((x == y) ? 0 : 1); } \",\"返回正数，第二个参数排前面，返回负数，第一个参数排前面\",\"这个方法是一个静态方法，但是它却和Comparator需要实现的方法返回值和参数定义一模一样，所以：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, Integer::compare); //直接指定一手，效果和上面是一模一样 System.out.println(Arrays.toString(array)); } \"]},\"293\":{\"h\":\"非静态方法作为方法引用\"},\"294\":{\"h\":\"默认使用\",\"t\":[\"如果使用非静态方法，依然采用 类::方法 的情况\",\"Lambda 会识别，然后使用相应接口的抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数来尝试调用\",\"我们注意到Comparator要求我们实现的方法为：\",\"public int compare(Integer o1, Integer o2) { return o1 - o2; } \",\"其中o1和o2都是Integer类型的，我们发现Integer类中有一个compareTo方法：\",\"public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } \",\"只不过这个方法并不是静态的，而是对象所有：\",\"Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); //这样进行比较也行，和上面效果依然是一样的 } }); System.out.println(Arrays.toString(array)); \",\"实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，o1作为目标对象，o2作为参数，正好匹配了compareTo方法，所以，直接缩写：\",\"public static void main(String[] args) { Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, Integer::compareTo); //注意这里调用的不是静态方法 System.out.println(Arrays.toString(array)); } \"]},\"295\":{\"h\":\"\",\"t\":[\"成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法\",\"通过具体对象，即 对象::方法，这样就仿造了静态方法时的情况，此时就不会使用默认的情况(即用参数1调用方法，该方法参数为参数2)\",\"而是类似 静态方法作为方法引用时，两个参数对应。\",\"public static void main(String[] args) { Main mainObject = new Main(); Integer[] array = new Integer[]{4, 6, 1, 9, 2, 0, 3, 7, 8, 5}; Arrays.sort(array, mainObject::reserve); //使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法 System.out.println(Arrays.toString(array)); } public int reserve(Integer a, Integer b){ //现在Main类中有一个刚好匹配的方法 return b.compareTo(a); } \"]},\"296\":{\"h\":\"构造方法作为方法引用\",\"t\":[\"当然，类的构造方法 类::new 同样可以作为方法引用传递：\",\"类的构造方法默认返回自身对象\",\"public interface Test { String test(String str); //现在我们需要一个参数为String返回值为String的实现 } \",\"我们发现，String类中刚好有一个：\",\"public String(String original) { //由于String类的构造方法返回的肯定是一个String类型的对象， //且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的 this.value = original.value; this.coder = original.coder; this.hash = original.hash; } \",\"于是：\",\"public static void main(String[] args) { Test test = String::new; //没错，构造方法直接使用new关键字就行 } \",\"当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。\",\"Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。\"]},\"297\":{\"h\":\"Optional类\",\"t\":[\"Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。\",\"我们先来看看下面这个例子：\",\"public static void hello(String str){ //现在我们要实现一个方法，将传入的字符串转换为小写并打印 System.out.println(str.toLowerCase()); //那太简单了吧，直接转换打印一气呵成 } \",\"但是这样实现的话，我们少考虑了一个问题，万一给进来的str是null呢？\",\"如果是null的话，在调用toLowerCase方法时岂不是直接空指针异常了？\",\"所以我们还得判空一下：\",\"public static void hello(String str){ if(str != null) { System.out.println(str.toLowerCase()); } } \",\"但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决\",\"这时，Optional来了，我们可以将任何的变量包装进Optional类中使用：\",\"public static void hello(String str){ Optional .ofNullable(str) //将str包装进Optional .ifPresent(s -> { //ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void） System.out.println(s); }); } \",\"由于这里只有一句打印，所以我们来优化一下：\",\"public static void hello(String str){ Optional .ofNullable(str) //将str包装进Optional .ifPresent(System.out::println); //println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法 } \",\"这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。\",\"除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：\",\"System.out.println(Optional.ofNullable(str).get()); \",\"不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：\",\"System.out.println(Optional.ofNullable(str).orElse(\\\"VVV\\\")); //orElse表示如果为空就返回里面的内容 \"]},\"298\":{\"c\":[\"code\"]},\"299\":{\"c\":[\"java新特性\"]},\"300\":{\"h\":\"Java9 - 模块机制\"},\"301\":{\"h\":\"Java9\",\"t\":[\"Java 9的主要特性有，全新的模块机制、接口的private方法等。\"]},\"302\":{\"h\":\"模块机制\"},\"303\":{\"h\":\"简介\",\"t\":[\"当我们导入一个jar包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库\",\"实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。\",\"于是，Java 9引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：\",\"alt text\",\"而在引入模块机制之后：\",\"alt text\",\"可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。\"]},\"304\":{\"h\":\"实现包的分离管理\",\"t\":[\"这里我们创建一个新的项目，并在src目录下，新建module-info.java文件表示此项目采用模块管理机制：\",\"module NewHelloWorld { //模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同 } \",\"接着我们来创建一个主类：\",\"package com.ekko; public class Main { public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); } } \",\"程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了\",\"Java为我们提供的logging相关日志库，即 java.util.loggin\",\"我们发现现在不见了，实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：\",\"module NewHelloWorld { //模块名称随便起一个就可以 requires java.logging; //除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库 //当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se; 即可 } \",\"这里我们导入java.logging相关模块后，就可以正常使用Logger了\",\"否则，如果未在 module-info.java 中导入，会提示找不到\",\"alt text\",\"模块化机制提供了另一个级别的Java代码可见性、可访问性的控制。\"]},\"305\":{\"h\":\"提高安全性\",\"t\":[\"尝试通过反射获取JDK提供的类中的字段：\",\"//Java17版本的String类 public final class String implements java.io.Serializable, Comparable<String>, CharSequence, Constable, ConstantDesc { @Stable private final byte[] value; //自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[] .... } \",\"public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class<String> stringClass = String.class; Field field = stringClass.getDeclaredField(\\\"value\\\"); //这里我们通过反射来获取String类中的value字段 field.setAccessible(true); //由于是private访问权限，所以我们修改一下 System.out.println(field.get(\\\"ABCD\\\")); } \",\"但是我们发现，在程序运行之后，修改操作被阻止了：\",\"alt text\",\"反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的。\"]},\"306\":{\"h\":\"介绍\",\"t\":[\"首先模块具有四种类型：\",\"系统模块： 来自JDK和JRE的模块（官方提供的模块，比如我们上面用的） 我们也可以直接使用java --list-modules命令来列出所有的模块，不同的模块会导出不同的包供我们使用。\",\"应用程序模块： 我们自己写的Java模块项目。\",\"自动模块： 可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。\",\"未命名模块： 我们自己创建的一个Java项目，如果没有创建module-info.java，那么会按照未命名模块进行处理 未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。 不过，由于没有使用Java 9的模块新特性，未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）\"]},\"307\":{\"h\":\"例子\",\"t\":[\"这里我们就来创建两个项目，看看如何使用模块机制\",\"首先我们在项目A中，添加一个User类，然后在项目B使用：\",\"package com.test; public class User { String name; int age; public User(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return name+\\\" (\\\"+age+\\\"岁)\\\"; } } \",\"接着我们编写一下项目A的模块设置：\",\"module module.a { exports com.test; } \",\"这里我们将com.test包下所有内容都暴露出去，默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用。\",\"接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：\",\"module module.b { requires module.a; } \",\"现在我们就可以在Main类中使用模块module.a中暴露出来的包内容了：\",\"import com.test.User; //如果模块module.a不暴露，那么将无法导入 public class Main { public static void main(String[] args) { User user = new User(\\\"penguin\\\", 18); System.out.println(user); } } \",\"当然除了普通的exports进行包的暴露之外，我们也可以直接指定将包暴露给指定的模块：\",\"module module.a { exports com.test to module.b; //这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用 } \"]},\"308\":{\"h\":\"依赖传递\",\"t\":[\"如果模块module.a依赖于其他模块，那么会不会传递给依赖于模块module.a的模块呢？\",\"默认是不传递的\",\"module module.a { exports com.test to module.b; //使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入 requires java.logging; //这里添加一个模块的依赖 } \",\"alt text\",\"可以看到，在模块module.b中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用\",\"但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：\",\"module module.a { exports com.test to module.b; //使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入 requires transitive java.logging; //使用transitive来向其他模块传递此依赖 } \",\"现在就可以使用了：\",\"alt text\"]},\"309\":{\"h\":\"开启反射\",\"t\":[\"还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的\",\"那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：\",\"open module module.a { //直接添加open关键字开放整个模块的反射权限 exports com.test to module.b; } \",\"module module.a { exports com.test to module.b; opens com.test; //通过使用opens关键字来为其他模块开放反射权限 //也可以指定目标开放反射 opens com.test to module.b; } \"]},\"310\":{\"h\":\"指定实现 +\",\"t\":[\"我们还可以指定模块需要使用的抽象类或是接口实现：\",\"package com.test; public interface Test { } \",\"open module module.a { exports com.test to module.b; uses com.test.Test; //使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到 } \",\"我们可以在模块B中去实现一下，然后声明我们提供了实现类：\",\"package com.main; import com.test.Test; public class TestImpl implements Test { } \",\"module module.b { requires module.a; //导入项目A的模块，此模块暴露了com.test包 provides com.test.Test with com.main.TestImpl; //声明此模块提供了Test的实现类 } \"]},\"311\":{\"h\":\"简单使用\",\"t\":[\"了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目\",\"然后我们导入了lombok框架的依赖，如果我们不创建module-info.java文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：\",\"package com.test; import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\\\"Hello World!\\\"); //使用lombok提供的注解，可以正常运行 } } \",\"现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好module-info.java文件：\",\"module com.test { } \",\"我们还需要去依赖对应的模块：\",\"module com.test { requires lombok; //lombok模块 requires java.logging; //JUL日志模块，也需要使用到 } \",\"这样我们就可以正常使用了。\"]},\"312\":{\"c\":[\"code\"]},\"313\":{\"c\":[\"java新特性\"]},\"314\":{\"h\":\"Java9 - 2\"},\"315\":{\"h\":\"Java9\"},\"316\":{\"h\":\"JShell交互式编程\",\"t\":[\"Java 9为我们通过了一种交互式编程工具JShell\",\"alt text\",\"环境配置完成后，我们只需要输入jshell命令即可开启交互式编程了，它支持我们一条一条命令进行操作。\",\"比如我们来做一个简单的计算：\",\"alt text\",\"我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。\",\"alt text\",\"我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：\",\"alt text\",\"除了直接运行我们写进去的代码之外，它还支持使用命令，输入help来查看命令列表：\",\"alt text\",\"比如我们可以使用/vars命令来展示当前定义的变量列表：\",\"alt text\",\"当我们不想使用jshell时，直接输入/exit退出即可\"]},\"317\":{\"h\":\"接口中的private方法\",\"t\":[\"接口中的方法默认是 public abstract\",\"在Java 8中，接口中 的方法支持添加default关键字来添加默认实现：\",\"public interface Test { default void test(){ System.out.println(\\\"我是test方法默认实现\\\"); } } \",\"而在Java 9中，接口再次得到强化，现在接口中可以存在私有方法了：\",\"public interface Test { default void test(){ System.out.println(\\\"我是test方法默认实现\\\"); this.inner(); //接口中方法的默认实现可以直接调用接口中的私有方法 } private void inner(){ //声明一个私有方法 System.out.println(\\\"我是接口中的私有方法！\\\"); } } \",\"注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。\"]},\"318\":{\"h\":\"集合类新增工厂方法\",\"t\":[\"在之前，如果我们想要快速创建一个Map只能：\",\"public static void main(String[] args) { Map<String, Integer> map = new HashMap<>(); //要快速使用Map，需要先创建一个Map对象，然后再添加数据 map.put(\\\"AAA\\\", 19); map.put(\\\"BBB\\\", 23); System.out.println(map); } \",\"而在Java 9之后，我们可以直接通过of方法来快速创建了：\",\"public static void main(String[] args) { Map<String, Integer> map = Map.of(\\\"AAA\\\", 18, \\\"BBB\\\", 20); //直接一句搞定 System.out.println(map); } \",\"是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：\",\"alt text\",\"但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是无法进行修改的。\",\"当然，除了Map之外，其他的集合类都有相应的of方法：\",\"public static void main(String[] args) { Set<String> set = Set.of(\\\"BBB\\\", \\\"CCC\\\", \\\"AAA\\\"); //注意Set中元素顺序并不一定你的添加顺序 List<String> list = List.of(\\\"AAA\\\", \\\"CCC\\\", \\\"BBB\\\"); //好耶，再也不用Arrays了 } \"]},\"319\":{\"h\":\"改进的 Stream API\",\"t\":[\"这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。\",\"public static void main(String[] args) { Stream .of(\\\"A\\\", \\\"B\\\", \\\"B\\\", \\\"C\\\") //这里我们可以直接将一些元素封装到Stream中 .filter(s -> s.equals(\\\"B\\\")) //通过过滤器过滤 .distinct() //去重 .forEach(System.out::println); //最后打印 } \",\"自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成\",\"如此方便的框架，在Java 9得到了进一步的增强：\"]},\"320\":{\"h\":\"\",\"t\":[\"public static void main(String[] args) { Stream .of(null) //如果传入null会报错 .forEach(System.out::println); Stream .ofNullable(null) //使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了 .forEach(System.out::println); } \"]},\"321\":{\"h\":\"利用 来迭代生成数据\",\"t\":[\"还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：\",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) //Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。 .limit(20) //这里限制生成20个 .forEach(System.out::println); } \",\"public static void main(String[] args) { Stream //不知道怎么写？参考一下：for (int i = 0;i < 20;i++) .iterate(0, i -> i < 20, i -> i + 1) //快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成 .forEach(System.out::println); } \"]},\"322\":{\"h\":\"数据截断 +\",\"t\":[\"Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：\",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) .limit(20) .takeWhile(i -> i < 10) //当i小于10时正常通过，一旦大于等于10直接截断 .forEach(System.out::println); } \",\"public static void main(String[] args) { Stream .iterate(0, i -> i + 1) .limit(20) .dropWhile(i -> i < 10) //和上面相反，上来就是截断状态，只有当满足条件时再开始通过 .forEach(System.out::println); } \",\"但实际上还是遍历了20个，只不过会删除其他不符合条件的\"]},\"323\":{\"h\":\"其他小型变动\",\"t\":[\"Try-with-resource语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：\",\"public static void main(String[] args) throws IOException { InputStream inputStream = Files.newInputStream(Paths.get(\\\"pom.xml\\\")); try (inputStream) { //单独丢进try中，效果是一样的 for (int i = 0; i < 100; i++) System.out.print((char) inputStream.read()); } } \",\"在Java 8中引入了Optional类，它很好的解决了判空问题：\",\"public static void main(String[] args) throws IOException { test(null); } public static void test(String s){ //比如现在我们想执行 System.out.println(str.toLowerCase()) //但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常 //但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装 Optional .ofNullable(s) .ifPresent(str -> System.out.println(str.toLowerCase())); } \",\"这种写法就有点像Kotlin或是JS中的语法：\",\"fun main() { test(null) } fun test(str : String?){ //传入的String对象可能为null，这里类型写为String? println(str?.lowercase()) // ?.表示只有不为空才进行调用 } \",\"在Java 9新增了一些更加方便的操作：\",\"public static void main(String[] args) { String str = null; Optional.ofNullable(str).ifPresentOrElse(s -> { //通过使用ifPresentOrElse，我们同时处理两种情况 System.out.println(\\\"被包装的元素为：\\\"+s); //第一种情况和ifPresent是一样的 }, () -> { System.out.println(\\\"被包装的元素为null\\\"); //第二种情况是如果为null的情况 }); } \",\"我们也可以使用or()方法快速替换为另一个Optional类：\",\"public static void main(String[] args) { String str = null; Optional.ofNullable(str) .or(() -> Optional.of(\\\"AAA\\\")) //如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装 .ifPresent(System.out::println); } \",\"当然还支持直接转换为Stream，这里就不多说了。\",\"在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：\",\"public abstract class Test<T>{ //这里我们写一个泛型类 public T t; public Test(T t) { this.t = t; } public abstract T test(); } \",\"public static void main(String[] args) throws IOException { Test<String> test = new Test<>(\\\"AAA\\\") { //在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢 //在Java 9之后，这样的写法终于可以编译通过了 @Override public String test() { return t; } }; } \",\"当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。\"]},\"324\":{\"c\":[\"code\"]},\"325\":{\"c\":[\"java新特性\"]},\"326\":{\"h\":\"Java10-11 - 1\"},\"327\":{\"h\":\"Java10\",\"t\":[\"Java 10主要带来的是一些内部更新，相比Java 9带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了\"]},\"328\":{\"h\":\"局部变量类型推断\",\"t\":[\"在Java中，我们可以使用自动类型推断：\",\"public static void main(String[] args) { // String a = \\\"Hello World!\\\"; 之前我们定义变量必须指定类型 var a = \\\"Hello World!\\\"; //现在我们使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型 } \",\"但是注意，var关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。\",\"alt text\",\"我们来看看是不是类型也能正常获取：\",\"public static void main(String[] args) { var a = \\\"Hello World!\\\"; System.out.println(a.getClass()); } \",\"这里虽然是有了var关键字进行自动类型推断，但是最终还是会变成String类型，得到的Class也是String类型。\",\"但是Java终究不像JS那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：\",\"alt text\",\"并且var关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：\",\"alt text\",\"有关Java 10新增的一些其他改进，这里就不提了。\"]},\"329\":{\"h\":\"Java11\",\"t\":[\"Java 11 是继Java 8之后的又一个TLS长期维护版本，在Java 17出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于Lambda的形参局部变量语法。\"]},\"330\":{\"h\":\"用于Lambda的形参局部变量语法\",\"t\":[\"在Java 10我们认识了var关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在lambda中使用\",\"但是实际上这里是完全可以进行类型推断的，所以在Java 11，终于是支持了，这样编写就不会报错了：\",\"public static void main(String[] args){ Consumer<String> consumer = (var str) -> {}; } \"]},\"331\":{\"h\":\"针对于String类的方法增强\",\"t\":[\"在Java 11为String新增一些更加方便的操作：\",\"str.isBlank(): 判断字符串是否为空或者仅包含空格\",\"str.lines(): 返回的是一个 Stream<String> 类型，根据字符串中的\\\\n换行符进行切割，分为多个字符串，并转换为Stream进行操作\",\"public static void main(String[] args) { var str = \\\"AB\\\\nC\\\\nD\\\"; System.out.println(str.isBlank()); //isBlank方法用于判断是否字符串为空或者是仅包含空格 str.lines().forEach(System.out::println); //根据字符串中的\\\\n换行符进行切割，分为多个字符串，并转换为Stream进行操作 } \",\"str.repeat(): 让字符串重复拼接\",\"public static void main(String[] args) { String str = \\\"ABCD\\\"; //比如现在我们有一个ABCD，但是现在我们想要一个ABCDABCD这样的基于原本字符串的重复字符串 System.out.println(str.repeat(2)); //一个repeat就搞定了 } \",\"快速地进行空格去除操作：\",\"public static void main(String[] args) { String str = \\\" A B C D \\\"; System.out.println(str.strip()); //去除首尾空格 System.out.println(str.stripLeading()); //去除首部空格 System.out.println(str.stripTrailing()); //去除尾部空格 } \"]},\"332\":{\"h\":\"全新的HttpClient使用\",\"t\":[\"在Java 9的时候其实就已经引入了全新的Http Client API，用于取代之前比较老旧的HttpURLConnection类\",\"新的API支持最新的HTTP2和WebSocket协议。\"]},\"333\":{\"h\":\"类使用\",\"t\":[\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { //直接创建一个新的HttpClient HttpClient client = HttpClient.newHttpClient(); //现在我们只需要构造一个Http请求实体 // 就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似） HttpRequest request = HttpRequest.newBuilder().uri(new URI(\\\"https://www.baidu.com\\\")).build(); //现在我们就可以把请求发送出去了 // 注意send方法后面参数，还需要一个响应体处理器（内置了很多） // 这里我们选择ofString直接响应实体转换为String字符串 HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } \",\"利用全新的客户端，我们甚至可以轻松地做一个爬虫\",\"比如现在我们想去批量下载某个网站的壁纸：\",\"网站地址：https://pic.netbian.com/4kmeinv/\",\"不同的壁纸似乎都是这样：https://pic.netbian.com/tupian/数字.html\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { //先不要一次性获取太多，先来10个 HttpRequest request = HttpRequest.newBuilder().uri(new URI(\\\"https://pic.netbian.com/tupian/\\\"+(29327 + i)+\\\".html\\\")).build(); //这里我们按照规律，批量获取 HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); //这里打印一下看看网页 } } \",\"接着我们需要来观察一下网站的HTML具体怎么写的，把图片的地址提取出来：\",\"好了，知道图片在哪里直接字符串截取：\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { ... String html = response.body(); String prefix = \\\"<a href=\\\\\\\"\\\\\\\" id=\\\\\\\"img\\\\\\\"><img src=\\\\\\\"\\\"; //先找好我们要截取的前面一段，作为前缀去匹配位置 String suffix = \\\"\\\\\\\" data-pic=\\\"; //再找好我们要截取的屁股后面紧接着的位置，作为后缀去匹配位置 //直接定位，然后前后截取，得到最终的图片地址 html = html.substring(html.indexOf(prefix) + prefix.length()); html = html.substring(0, html.indexOf(suffix)); System.out.println(html); //最终的图片地址就有了 } } \",\"好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：\",\"public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException { HttpClient client = HttpClient.newHttpClient(); for (int i = 0; i < 10; i++) { ... //创建请求，把图片取到 HttpRequest imageRequest = HttpRequest.newBuilder().uri(new URI(\\\"https://pic.netbian.com\\\"+html)).build(); //这里以输入流的方式获取，不过貌似可以直接下载文件 HttpResponse<InputStream> imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream()); //拿到输入流和文件输出流 InputStream imageInput = imageResponse.body(); FileOutputStream stream = new FileOutputStream(\\\"images/\\\"+i+\\\".jpg\\\"); //一会要保存的格式 try (stream;imageInput){ //直接把要close的变量放进来就行，简洁一些了 int size; //下面具体保存过程的不用我多说了吧 byte[] data = new byte[1024]; while ((size = imageInput.read(data)) > 0) { stream.write(data, 0, size); } } } } \"]},\"334\":{\"c\":[\"code\"]},\"335\":{\"c\":[\"java新特性\"]},\"336\":{\"h\":\"Java 12-16 - 1\"},\"337\":{\"h\":\"Java 12-16 新特性\",\"t\":[\"由于Java版本的更新迭代速度自Java 9开始为半年更新一次\",\"Java 8到Java 9隔了整整三年，所以各个版本之间的更新内容比较少了。\",\"alt text\",\"Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能\",\"12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用。\"]},\"338\":{\"h\":\"新的switch语法\",\"t\":[\"在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活\",\"比如我们想要编写一个根据成绩得到等级的方法：\",\"/** * 传入分数（范围 0 - 100）返回对应的等级： * 100-90：优秀 * 70-80：良好 * 60-70：及格 * 0-60：寄 * @param score 分数 * @return 等级 */ public static String grade(int score){ } \",\"现在我们想要使用switch来实现这个功能，之前的写法是：\",\"public static String grade(int score){ score /= 10; //既然分数段都是整数，那就直接整除10 String res = null; switch (score) { case 10: case 9: res = \\\"优秀\\\"; break; case 8: case 7: res = \\\"良好\\\"; break; case 6: res = \\\"及格\\\"; break; default: res = \\\"不及格\\\"; break; } return res; } \"]},\"339\":{\"h\":\"新语法\",\"t\":[\"但是现在我们可以使用新的特性了：\",\"public static String grade(int score){ score /= 10; //既然分数段都是整数，那就直接整除10 return switch (score) { //增强版switch语法 case 10, 9 -> \\\"优秀\\\"; //语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了 case 8, 7 -> \\\"良好\\\"; case 6 -> \\\"及格\\\"; default -> \\\"不及格\\\"; }; } \",\"不过最后编译出来的样子，貌似还是和之前是一样的\"]},\"340\":{\"h\":\"详细规则\",\"t\":[\"这种全新的switch语法称为switch表达式，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：\",\"var res = switch (obj) { //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收 case [匹配值, ...] -> \\\"优秀\\\"; // case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开 // 使用 -> 来返回如果匹配此case语句的结果 case ... //根据不同的分支，可以存在多个case default -> \\\"不及格\\\"; //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的 }; \",\"那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？\",\"var res = switch (obj) { //增强版switch语法 case [匹配值, ...] -> \\\"优秀\\\"; default -> { //我们可以使用花括号来将整套逻辑括起来 //... 我是其他要做的事情 yield \\\"不及格\\\"; //注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字 } }; \",\"当然，也可以像这样：\",\"var res = switch (args.length) { //增强版switch语法 case [匹配值, ...]: yield \\\"AAA\\\"; //传统的:写法，通过yield指定返回结果，同样不需要break default: System.out.println(\\\"默认情况\\\"); yield \\\"BBB\\\"; }; \",\"这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。\",\"注意： switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。\"]},\"341\":{\"h\":\"文本块 - 三引号\",\"t\":[\"如果你学习过Python，一定知道三引号：\",\"#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串 multi_line = \\\"\\\"\\\" nice to meet you! nice to meet you! nice to meet you! \\\"\\\"\\\" print multi_line \",\"没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：\",\"alt text\",\"可以看到，Java中也可以使用这样的三引号来表示字符串\",\"我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：\",\"alt text\",\"注意： 文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。\"]},\"342\":{\"h\":\"新的instanceof语法\",\"t\":[\"在Java 14，instanceof迎来了一波小更新\",\"比如我们之前要重写一个类的equals方法：\",\"public class Student { private final String name; public Student(String name) { this.name = name; } @Override public boolean equals(Object obj) { if(obj instanceof Student) { //首先判断是否为Student类型 Student student = (Student) obj; //如果是，那么就类型转换 return student.name.equals(this.name); //最后比对属性是否一样 } return false; } } \",\"在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式\",\"但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量, 只需要在比较后面加个变量名，等于比较完就强制转换\",\"public class Student { private final String name; public Student(String name) { this.name = name; } @Override public boolean equals(Object obj) { if(obj instanceof Student student) { //在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的 return student.name.equals(this.name); } return false; } } \",\"在使用instanceof判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤。\",\"注意： 新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。\"]},\"343\":{\"h\":\"空指针异常的改进\",\"t\":[\"相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：\",\"public static void test(String a, String b){ int length = a.length() + b.length(); //可能给进来的a或是b为null System.out.println(length); } \",\"那么为空时，就会直接：\",\"alt text\",\"但是由于我们这里a和b都调用了length()方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）\",\"但是当我们在Java 14或更高版本运行时：\",\"alt text\",\"这里会明确指出是哪一个变量调用出现了空指针。\"]},\"344\":{\"h\":\"记录类型\",\"t\":[\"继类、接口、枚举、注解之后的又一新类型，\\\"记录 record\\\"\",\"在Java 14中首次出场，这一出场，Lombok的噩梦来了。\",\"在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据\",\"比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：\",\"@Data public class Account { //使用Lombok，一个注解就搞定了 String username; String password; } \",\"Lombok可以说是简化代码的神器了，他能在编译时自动生成getter和setter、构造方法、toString()方法等实现\",\"而记录类型本质上也是一个普通的类\",\"是final类型且继承自java.lang.Record抽象类\",\"它会在编译时，会自动编译出 public gethashcode 、equals、toString 等方法。\",\"public record Account(String username, String password) { //直接把字段写在括号中 } \",\"使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：\",\"alt text\",\"并且toString也是被重写了的：\",\"alt text\",\"equals()方法仅做成员字段之间的值比较，也是帮助我们实现好了的：\",\"Account account0 = new Account(\\\"Admin\\\", \\\"123456\\\"); Account account1 = new Account(\\\"Admin\\\", \\\"123456\\\"); //两个属性都是一模一样的 System.out.println(account0.equals(account1)); //得到true \",\"是不是感觉这种类型就是专门为这种实体类而生的。\",\"public record Account(String username, String password) implements Runnable { //支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了 @Override public void run() { } } \",\"注意： 记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。\"]},\"345\":{\"h\":\"Java 17 新特性\",\"t\":[\"Java 17作为新的LTS长期维护版本\"]},\"346\":{\"h\":\"密封类型 +\",\"t\":[\"密封类型可以说是Java 17正式推出的又一重磅类型\",\"它在Java 15首次提出并测试了两个版本。\",\"在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。\",\"但有的时候，可能并不是所有的类我们都希望能够被继承。\",\"所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是限制类的继承。\",\"实际上在之前我们如果不希望别人继承我们的类，可以直接添加final关键字：\",\"public final class A{ //添加final关键字后，不允许对此类继承 } \",\"这样有一个缺点，如果添加了final关键字，那么无论是谁，包括我们自己也是没办法实现继承的\",\"但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。\",\"但是现在我们可以使用密封类型sealed 来实现这个功能：\",\"public sealed class A permits B{ //在class关键字前添加sealed关键字，表示此类为密封类型 // permits后面跟上允许继承的类型，多个子类使用逗号隔开 } \"]},\"347\":{\"h\":\"要求\",\"t\":[\"密封类型有以下要求：\",\"可以基于普通类、抽象类、接口，也可以是继承自其他抽象类的子类或是实现其他接口的类等。\",\"必须有子类继承，且不能是匿名内部类或是lambda的形式。\",\"sealed写在原来final的位置，但是不能和final、non-sealed关键字同时出现，只能选择其一。\",\"继承的子类必须显式标记为final、sealed或是non-sealed类型。\",\"标准的声明格式如下：\",\"public sealed [abstract] [class/interface] 类名 [extends 父类] [implements 接口, ...] permits [子类, ...]{ //里面的该咋写咋写 } \",\"注意子类格式为：\",\"public [final/sealed/non-sealed] class 子类 extends 父类 { //必须继承自父类 //final类型：任何类不能再继承当前类，到此为止，已经封死了。 //sealed类型：同父类，需要指定由哪些类继承。 //non-sealed类型：重新开放为普通类，任何类都可以继承。 } \",\"比如现在我们写了这些类：\",\"public sealed class A permits B{ //指定B继承A } \",\"public final class B extends A { //在子类final，彻底封死 } \",\"我们可以看到其他的类无论是继承A还是继承B都无法通过编译：\",\"alt text\",\"alt text\",\"但是如果此时我们主动将B设定为non-sealed类型：\",\"public non-sealed class B extends A { } \",\"这样就可以正常继承了，因为B指定了non-sealed主动放弃了密封特性，这样就显得非常灵活了。\",\"当然我们也可以通过反射来获取类是否为密封类型：\",\"public static void main(String[] args) { Class<A> a = A.class; System.out.println(a.isSealed()); //是否为密封 } \"]},\"348\":{\"c\":[\"code\"]},\"349\":{\"c\":[\"java新特性\"]},\"350\":{\"h\":\"Java 杂\"},\"351\":{\"h\":\"\",\"t\":[\"Consumer是Java 8中的一个函数式接口，它位于java.util.function包中。\",\"定义了一个名为accept的抽象方法，该方法接受一个参数并且不返回任何结果。\",\"换句话说，Consumer接口表示一个消费者，它可以对给定的对象执行某些操作，但不产生任何结果。\"]},\"352\":{\"h\":\"接口声明\",\"t\":[\"public interface Consumer<T> { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed {@code Consumer} that performs, in sequence, this * operation followed by the {@code after} operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the {@code after} operation will not be performed. * * @param after the operation to perform after this operation * @return a composed {@code Consumer} that performs in sequence this * operation followed by the {@code after} operation * @throws NullPointerException if {@code after} is null */ default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"主要就两个方法：\"]},\"353\":{\"h\":\"\",\"t\":[\"核心方法是accept，该方法接受一个参数，并在方法体内定义具体的操作\",\"这是抽象方法，也是我们需要给的\",\"具体示例：\",\"// Lambda表达式简化 Consumer<String> printer = (s) -> System.out.println(s); // 使用 accept 方法执行操作 printer.accept(\\\"Hello, World!\\\"); \"]},\"354\":{\"h\":\"\",\"t\":[\"第二个是 addThen，为了方便 Consumer 链式操作\",\"Consumer接口还支持链式操作，也就是将多个Consumer组合在一起，形成一个新的Consumer。\",\"这可以通过andThen方法来实现，该方法允许将两个Consumer连接在一起，顺序执行。\",\"Consumer<String> upperCasePrinter = (s) -> System.out.println(s.toUpperCase()); Consumer<String> lowerCasePrinter = (s) -> System.out.println(s.toLowerCase()); // 使用 andThen 方法连接两个 Consumer Consumer<String> combinedPrinter = upperCasePrinter.andThen(lowerCasePrinter); combinedPrinter.accept(\\\"Hello, World!\\\"); \",\"传递的参数都是一样的不会被上一个影响，都是Hello, World!\"]},\"355\":{\"h\":\"\",\"t\":[\"Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\",\"Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。\",\"Optional 类的引入很好的解决空指针异常。\",\"import java.util.Optional; public class Java8Tester { public static void main(String args[]){ Java8Tester java8Tester = new Java8Tester(); Integer value1 = null; Integer value2 = new Integer(10); // Optional.ofNullable - 允许传递为 null 参数 Optional<Integer> a = Optional.ofNullable(value1); // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException Optional<Integer> b = Optional.of(value2); System.out.println(java8Tester.sum(a,b)); } public Integer sum(Optional<Integer> a, Optional<Integer> b){ // Optional.isPresent - 判断值是否存在 System.out.println(\\\"第一个参数值存在: \\\" + a.isPresent()); System.out.println(\\\"第二个参数值存在: \\\" + b.isPresent()); // Optional.orElse - 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); //Optional.get - 获取值，值需要存在 Integer value2 = b.get(); return value1 + value2; } } \"]},\"356\":{\"h\":\"\",\"t\":[\"Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。\",\"使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。\"]},\"357\":{\"h\":\"特点\",\"t\":[\"不是数据结构，不会保存数据。\",\"不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）\",\"惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。\"]},\"358\":{\"h\":\"操作\",\"t\":[\"Stream可以由数组或集合创建，对流的操作分为两种：\",\"中间操作，每次返回一个新的流，可以有多个 （筛选filter、映射map、排序sorted、去重组合skip—limit）\",\"终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。 终端操作会产生一个新的集合或值。（遍历foreach、匹配find–match、规约reduce、聚合max–min–count、收集collect）\",\"alt text\",\"List<String> list = new ArrayList<>(); list.add(\\\"武汉加油\\\"); list.add(\\\"中国加油\\\"); list.add(\\\"世界加油\\\"); list.add(\\\"世界加油\\\"); long count = list.stream().distinct().count(); System.out.println(count); \",\"中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。\"]},\"359\":{\"h\":\"创建流\",\"t\":[\"如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of()创建流\",\"如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。\",\"查看 Stream 源码的话，你会发现 of() 方法内部其实调用了Arrays.stream() 方法。\",\"public static<T> Stream<T> of(T... values) { return Arrays.stream(values); } \",\"另外，集合还可以调用 parallelStream() 方法创建并发流，默认使用的是 ForkJoinPool.commonPool()线程池。\"]},\"360\":{\"h\":\"操作流\"},\"361\":{\"h\":\"过滤\",\"t\":[\"public class FilterStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); Stream<String> stream = list.stream().filter(element -> element.contains(\\\"王\\\")); stream.forEach(System.out::println); } } \"]},\"362\":{\"h\":\"映射\",\"t\":[\"把一个流中的元素转化成新的流中的元素\",\"map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法\",\"也就是把 Stream<String> 的流转成一个 Stream<Integer> 的流\",\"新的流中的内容被修改为对应字符串的长度\",\"public class MapStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); Stream<Integer> stream = list.stream().map(String::length); stream.forEach(System.out::println); } } \"]},\"363\":{\"h\":\"匹配\",\"t\":[\"Stream 类提供了三个方法可供进行元素匹配，它们分别是：\",\"anyMatch()，只要有一个元素匹配传入的条件，就返回 true。\",\"allMatch()，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。\",\"noneMatch()，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。\"]},\"364\":{\"h\":\"组合\",\"t\":[\"reduce() 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：\",\"Optional<T> reduce(BinaryOperator<T> accumulator) 没有起始值，只有一个参数，就是运算规则，此时返回 Optional。\",\"T reduce(T identity, BinaryOperator<T> accumulator) 有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。\",\"public class ReduceStreamDemo { public static void main(String[] args) { Integer[] ints = {0, 1, 2, 3}; List<Integer> list = Arrays.asList(ints); Optional<Integer> optional = list.stream().reduce((a, b) -> a + b); Optional<Integer> optional1 = list.stream().reduce(Integer::sum); System.out.println(optional.orElse(0)); System.out.println(optional1.orElse(0)); int reduce = list.stream().reduce(6, (a, b) -> a + b); System.out.println(reduce); int reduce1 = list.stream().reduce(6, Integer::sum); System.out.println(reduce1); } } \"]},\"365\":{\"h\":\"转换流\",\"t\":[\"public class CollectStreamDemo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"周杰伦\\\"); list.add(\\\"王力宏\\\"); list.add(\\\"陶喆\\\"); list.add(\\\"林俊杰\\\"); String[] strArray = list.stream().toArray(String[]::new); System.out.println(Arrays.toString(strArray)); List<Integer> list1 = list.stream().map(String::length).collect(Collectors.toList()); List<String> list2 = list.stream().collect(Collectors.toCollection(ArrayList::new)); System.out.println(list1); System.out.println(list2); String str = list.stream().collect(Collectors.joining(\\\", \\\")).toString(); System.out.println(str); } } \",\"toArray() 方法可以将流转换成数组\",\"来看一下 toArray() 方法的源码。\",\"<A> A[] toArray(IntFunction<A[]> generator); \",\"也就是说 String[]::new 是一个 IntFunction，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：\",\"String[] strArray = (String[])list.stream().toArray((x$0) -> { return new String[x$0]; }); System.out.println(Arrays.toString(strArray)); \",\"也就是相当于返回了一个指定长度的字符串数组。\",\"当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 map() 方法和 collect() 方法。\",\"List<Integer> list1 = list.stream().map(String::length).collect(Collectors.toList()); \",\"通过 stream() 方法创建集合的流后，再通过 map(String:length) 将其映射为字符串长度的一个新流，最后通过 collect()方法将其转换成新的集合。\",\"Collectors 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。\"]},\"366\":{\"h\":\"\",\"t\":[\"一般构建对象时会有两种方法：\",\"通过构造函数来构建\",\"一个默认的构造函数，然后用 setter 方法设置\",\"比如一个api结果返回值的类Result，其在代码中频繁被使用：\",\"public class Result<T> { private int code; private String message; private T data; public Result(int code, String message, T data) { this.code = code; this.message = message; this.data = data; } public Result() { } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public T getData() { return data; } public void setData(T data) { this.data = data; } @Override public String toString() { return \\\"Result{\\\" + \\\"code=\\\" + code + \\\", message='\\\" + message + '\\\\'' + \\\", data=\\\" + data + '}'; } } \",\"如果要使用它，一般的方法是：\",\"public class Main { public static void main(String[] args) { //方法1，使用全量的构造函数 Result<String> result1 = new Result<>(200, \\\"success\\\", \\\"\\\"); //方法2，使用空的构造函数加setter函数赋值 Result<String> result2 = new Result<>(); result2.setCode(200); result2.setMessage(\\\"success\\\"); result2.setData(\\\"\\\"); } } \",\"这两种使用方法的弊端有：\",\"方法一：当只需要部分参数的时候需要再定义个构造函数（比如失败的情况只需要code和message，结果肯定是空，因此不需要data），且一旦参数较多，则构造函数冗长；\",\"方法二：setter冗长；\"]},\"367\":{\"h\":\"建造者模式\",\"t\":[\"其实是一种设计模式，叫做建造者模式，它的含义是将一个复杂的对象的构建与它的表示分离，同样的构建过程可以创建不同的表示\",\"可以在 Result 内加入一个 Builder 类:\",\"public static final class Builder<T> { private int code; private String message; private T data; private Builder() { } public Builder code(int val) { code = val; return this; } public Builder message(String val) { message = val; return this; } public Builder data(T val) { data = val; return this; } public Result build() { return new Result(this); } } \",\"然后使用的时候：\",\"Result<String> result3 = new Result.Builder<>().code(404).message(\\\"failure\\\").build(); Result<String> result4 = Result.newBuilder().code(404).message(\\\"failure\\\").build(); \",\"所以只需要构造一个 builder，通过 Result.builder() 然后根据属性调用对应的方法进行修改，最后使用 build() 就可以创造出不同的对象\"]},\"368\":{\"h\":\"中的\",\"t\":[\"lombok 用 @Builder 来辅助设计\",\"@Builder可以让你以下面显示的那样调用你的代码，来初始化你的实例对象：\",\"Person.builder() .name(\\\"Adam Savage\\\") .city(\\\"San Francisco\\\") .job(\\\"Mythbusters\\\") .job(\\\"Unchained Reaction\\\") .build(); \",\"@Builder可以放在类，构造函数或方法上。 虽然放在类上和放在构造函数上这两种模式是最常见的用例，但@Builder最容易用放在方法的用例来解释\",\"具体操作：\",\"使用@Builder注释的方法具体实现了：\",\"一个名为FooBuilder的内部静态类，并具有和实体类一致的属性（称为构建器）。\",\"在构建器中：对于目标类中的所有的属性和未初始化的final字段，都会在构建器中创建对应属性；\",\"在构建器中：创建一个无参的default构造函数。\",\"在构建器中：对于实体类中的每个参数，都会对应创建类似于setter的方法，方法名与该参数名相同。 并且返回值是构建器本身（便于链式调用）\",\"在构建器中：一个build()方法，调用此方法，就会根据设置的值进行创建实体对象。\",\"在构建器中：同时也会生成一个toString()方法。\",\"在实体类中：会创建一个builder()方法，它的目的是用来创建构建器。\",\"@Builder public class User { private String username; private String password; } // 编译后： public class User { private String username; private String password; User(String username, String password) { this.username = username; this.password = password; } public static User.UserBuilder builder() { return new User.UserBuilder(); } public static class UserBuilder { private String username; private String password; UserBuilder() {} public User.UserBuilder username(String username) { this.username = username; return this; } public User.UserBuilder password(String password) { this.password = password; return this; } public User build() { return new User(this.username, this.password); } public String toString() { return \\\"User.UserBuilder(username=\\\" + this.username + \\\", password=\\\" + this.password + \\\")\\\"; } } } \"]},\"369\":{\"c\":[\"code\"]},\"370\":{\"c\":[\"java新特性\"]},\"371\":{\"h\":\"hint - List初始化\",\"t\":[\"带初始值的初始化\",\"如果是 java 9+, 可以直接使用 list.of\",\"List<String> list = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"); \",\"List<String> list = List.of( new Student(\\\"aaa\\\",1), new Student(\\\"bbb\\\",2), new Student(\\\"ccc\\\",3), ); \",\"这种方式创建的列表 不可修改，add() 和 remove() 都会抛出 UnsupportedOperationException。\",\"但如果是 java 8，就没有这个，可以使用 Stream\",\" List<Student> list1 = Stream.of( new Student(\\\"Alice\\\", 20), new Student(\\\"Bob\\\", 21), new Student(\\\"Charlie\\\", 22) ).collect(Collectors.toList()); \",\"特性\",\"List.of(...)\",\"Stream.of(...).collect(Collectors.toList())\",\"Java 版本要求\",\"Java 9 及以上\",\"Java 8 及以上\",\"是否可变\",\"❌ 不可变（immutable）\",\"✅ 可变（mutable）\",\"是否支持增删元素\",\"❌ 抛出 UnsupportedOperationException\",\"✅ 支持 .add() / .remove() 等操作\",\"是否允许包含 null\",\"❌ 不允许，包含会抛出 NullPointerException\",\"✅ 允许包含 null\",\"是否简洁\",\"✅ 更简洁\",\"较繁琐，但功能灵活\",\"实际返回的 List 类型\",\"通常为 ImmutableCollections.ListN\",\"通常为 ArrayList\"]},\"372\":{\"c\":[\"code\"]},\"373\":{\"c\":[\"java hint\"]},\"374\":{\"h\":\"hint2\",\"t\":[\"-128 到 +127 以内的int值都是自动包装好，所以对象都是一个 \",\"Scanner 的 nextIntScanner scanner = new Scanner(System.in);scanner.nextInt() 只读整数，不读换行符（\\\\n） 换行符仍然留在输入缓冲区中，需要清理对应的换行符\",\"Java 中 finally 的行为\",\"不论 try 里是正常结束、遇到 return、遇到异常，finally 块里的内容都会被执行。\",\" try { System.out.println(prompt); return scanner.nextInt(); } catch (InputMismatchException e) { System.err.println(\\\"输入的不是数字，重新输入\\\"); } finally { scanner.nextLine(); // 关键：清除输入缓冲区的换行符 } \",\"即使这样，也会执行 finally，这样解决了缓冲区存在 \\\\n 的问题\",\"consume\"]},\"375\":{\"c\":[\"code\"]},\"376\":{\"c\":[\"java hint\"]},\"377\":{\"h\":\"Reinforcement Learning in Multiple-UAV Networks:Deployment and Movement Design\",\"t\":[\"2019 IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"378\":{\"h\":\"主要动机\",\"t\":[\"A novel framework is proposed for quality of experience driven deployment and dynamic movement of multiple unmanned aerial vehicles (UAVs).\",\"过去研究大多没有基于用户的移动(movement of users)来考虑无人机的机动性，更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署。\",\"考虑QoE, 而不是仅考虑吞吐量(throughput)，即需要考虑地面不同用户的具体需求。(QoE is invoked for demonstrating the users’ satisfaction, and it is supposed to be considered in UAV-assisted wireless networks)\",\"该文设计的是3D部署，过去研究主要考虑的是2D部署。\"]},\"379\":{\"h\":\"主要贡献\",\"t\":[\"提出了一个理想的由QoE驱动的多无人机协助通信框架。该框架将无人机部署在三维空间内，以 mean opinion score(MOS) 为指标。通过优化无人机的部署和动态移动来解决总用户MOS最大化问题。\",\"提出解决总用户MOS最大化问题的三步骤: \",\"通过GAK-mean算法获得初始单元划分。\",\"设计一种基于 q-learning 的部署方法，在初始时间假设用户处于静止下不断调整 UAVs 3D位置进行优化处理。\",\"设计一种基于 q-learning 的无人机3D动态运动设计算法。\",\"该文基于q-learning的方案来解决无人机的NP-hard 3D部署和移动问题，并与传统的基于遗传的学习算法进行对比。\",\"该文提出的算法具较快的收敛性，与K-means和IGK算法比具有较低的复杂度。\"]},\"380\":{\"h\":\"主要内容\"},\"381\":{\"h\":\"系统结构\"},\"382\":{\"h\":\"基本设置\",\"t\":[\"考虑无人机辅助无线网络的下行链路传输(down-link transmission)，即无人机作为空中基站。\",\"对于指定区域，会将其划分为N个簇，其中用户表示为K=K1​,…,KN​，其中KN​表示划分到集群N的用户，N∈1,2,…,N。\",\"每个用户只能属于一个集群，Kn​∩Kn′​=ϕ,n′=n,\",\"在任意时刻t，同一无人机通过FDMA同时为同一集群中的多个用户提供服务\",\"对于用户kn​∈Kn​，其坐标表示为wkn​​=[xkn​​(t),ykn​​(t)]T∈R2×1\",\"对于无人机n(飞行速度恒定)，其垂直高度表示为hn​(t)∈[hmin​,hmax​],0≤t≤Ts​，其水平坐标表示为qn​(t)=[xn​(t),yn​(t)]T∈R2×1,0≤t≤Ts​\",\"无人机n与用户kn​在时间t的距离表示为:\",\"dkn​​=hn2​(t)+[xn​(t)−xkn​​(t)]2+[yn​(t)−ykn​​(t)]2​\"]},\"383\":{\"h\":\"信号模型\",\"t\":[\"无人机往往有更高的LoS链接概率，该文中表示为:\",\"PLoS​(θkn​​)=b1​(π180​θkn​​−ζ)b2​PNLoS​=1−PLoS​\",\"其中θkn​​(t)=sin−1[dkn​(t)​hn​(t)​]，表示无人机与用户之间的仰角。b1​,b2​,ζ是由环境决定的常数。在实际应用中，为了在LoS信道概率和路径损耗之间取得平衡，需要合理选择无人机n的垂直高度hn​(t)。\",\"在时间t，从无人机n到用户kn​的信道功率增益(the channel power gain)为:\",\"gkn​​(t)=K0​−1dkn​​−α[t](PLos​μLoS​+PNLos​μNLoS​)−1\",\"其中K0​=(c4πfc​​)2，α是表示路径损耗指数(常数)，μLoS​,μNLoS​是表示LoS和NLoS链路的衰减因子，fc​是载波频率，c是光速。\",\"对于无人机n，其可用带宽为Bn​，将其平均分配给其∣Kn​∣个关联用户，其每个用户带宽表示为: Bkn​​=Bn​/Kn​. 该文中不同集群所利用的频谱是不同的，且无人机向关联用户的发射功率是恒定的。 同样，对于无人机的总发射功率也均匀地分配给每个用户，pkn​​=Pmax​/Kn​\",\"由于不同集群的频谱不同，可以减轻无人机对用户接收到的干扰。因此，在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为:\",\"Γkn​​(t)=σ2pkn​​gkn​​(t)​\",\"其中σ2=Bkn​​N0​, N0​为用户所在位置的加性高斯白噪声(AWGN)的功率谱密度。\",\"为了满足不同用户传输速率要求，对于用户kn​存在特定的信噪比目标γkn​​, 即Γ≥γkn​​.\",\"由此，存在Lemma1： 为了保证所有用户都能连接到网络，我们对无人机的发射功率有一个约束，可以表示为\",\"Pmax​≥γσ2K0​dkn​​α(t)μNLoS​\",\"根据香农定理: 信道容量C=B∗log(1+NS​)，且传输率永远都不可能超过信道容量C。 因此对于用户kn​的在时刻t的传输速率rkn​​(t)，表示为rkn​​(t)=Bkn​​log2​[1+σ2pkn​​gkn​​(t)​].\",\"Proposition1: 无人机n的高度需满足:\",\"dkn​​(t)sin[180π​(ζ+eM(t))]≤hn​(t)≤(γK0​σ2μLoS​Pmax​​)\",\"其中\",\"M(t)=b2​ln(b1​(μLoS​−μNLoS​)S(t)​−μLoS​−μNLoS​μNLoS​​​S(t)=γK0​σ2dkn​​α(t)Pm​ax​\",\"Proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件。 可知，其高度的下界是距离dkn​​(t)的函数；高度的上界是最大发射功率Pmax​的函数。 因此，随着无人机与用户之间距离和发射功率的变化，需要调整相应无人机的高度，以向用户提供可靠的服务。\"]},\"384\":{\"h\":\"Quality-of-Experience Model\",\"t\":[\"由于不同用户对于传输速率的需求是不同的，所以在无人机辅助通信网络中我们需要考虑QoE模型。\",\"在该文中，采用MOS作为用户QoS衡量的标准，具体如下:\",\"MOSkn​​(t)=ζ1​MOSkn​​delay(t)+ζ2​MOSkn​​rate(t)\",\"其中，ζ1​,ζ2​是系数，且ζ1​+ζ2​=1。\",\"根据MOS数值，共划分5个等级: excellent(4.5) very good(2~3.5) fair(1~2) poor(1)。\",\"在该文中考虑的是网页浏览应用传输情况，因此MOSkn​​delay(t)可以忽略，因此，此时的MOS模型定义如下:\",\"MOSkn​​(t)=−C1​ln[d(rkn​​(t))]+C2​\",\"d(rkn​​(t))是与传输速率有关的延迟时间，MOSkn​​(t)为t时刻的MOS评分，取值范围从1−4.5。C1​和C2​是通过分析web浏览应用程序的实验结果确定的常数，分别设为1.120和4.6746。\",\"d(rkn​​(t))=3RTT+rkn​​(t)FS​+L(rkn​​MSS​)+RTT−rkn​​(t)2MSS(2L−1)​\",\"其中，RTT[s]表示round trip time(数据包从发送端-接收端-发送端的时间)，FS[bit]是网页大小，MSS[bit]是最大报文长度，L=min[L1​,L2​]表示 the number of slow start cycles with idle periods。\",\"L1​=log2​(MSSrkn​​RTT​+1)−1,L2​=log2​(2MSSFS​+1)−1.\",\"用户rkn​​在一段时间Ts​内的MOS总和为:\",\"MOSrkn​​​=t=0∑Ts​​MOSkn​​(t)\"]},\"385\":{\"h\":\"优化问题建立\",\"t\":[\"假设功率Q=qn​(t),0≤t≤Ts​, 高度H=hn​(t),0≤t≤Ts​\",\"本文目的是优化无人机在每个时隙的位置，从而最大化所有用户的总MOS值。具体表述如下:\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​∑t=0Ts​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"该优化问题是一个non-convex问题，因为目标函数对于无人机的3D坐标是非凸的。\",\"总用户的MOS取决于无人机的发射功率、数量和位置(水平位置和高度)。\"]},\"386\":{\"h\":\"解决方案\"},\"387\":{\"h\":\"无人机的3D部署\",\"t\":[\"考虑以下场景，将上述优化问题简化:\",\"无人机n以可变高度悬停在用户上方，用户是保持静态的。 每架无人机的带宽和发射功率都均匀分配给每个用户。 因此我们将优化问题简化为区域分割问题。\",\"描述如下: 但即使仅考虑用户聚类，该问题依然是NP-hard问题\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"无人机-用户关联策略(用户区域划分算法)\",\"采用基于遗传算法的GAK-means算法 由于特定用户的MOS与该用户与无人机之间的距离有关，因此GAK-means可以视为获得无人机部署的低复杂度方案。\",\"根据N个用户，根据遗传算法找到CN​个最优个体作为簇的中心。\",\"将无人机部署在每个中心内，再将用户划分给距离最近的无人机\",\"重复步骤，再找到新的簇的各中心，再根据欧几里得距离重新划分，直到各个簇的成员没有太大变化，划分完毕。\",\"无人机3D部署算法\",\"根据所给定的用户划分情况，目标是获得无人机的最佳3D位置，来最大化MOS总和。 由于GAK-means的优化目标是最小化无人机与对应集群用户的欧氏距离，MOS主要是有关传输速率rkn​​的函数，因此MOS不仅与欧氏距离有关，还与LoS的概率有关。\",\"采用Q-learning算法\",\"智能体(agent): UAVn,n∈N={1,2,…,N}\",\"状态(state): 对于每个智能体，其状态为其3D坐标，定义为ξ=(xUAV​,yUAV​,hUAV​)\",\"状态空间(state space S): 这里采用离散化空间坐标，即xUAV​:{0,1,…,Xd​},yUAV​:0,1,…,Yd​,hUAV​:{hmin​,…,hmax​}，所以状态其实共有(XD​+1)×(Yd​+1)×(hmax​−hmin​+1)个\",\"动作空间(action space): 每次无人机会根据当前状态st​∈S，按照所给定策略J来执行一个动作at​∈A从而获得奖励rt​以及下一个状态st+1​ 该论文中在精度和模型复杂型上作出平衡，共考虑7个方向。 (1,0,0)：右转 (−1,0,0)：左转 (0,1,0)：前进 (0,−1,0)：后退 (0,0,1)：上行 (0,0,−1)：下行 (0,0,0)：静止\",\"状态转换模型: 当执行动作at​时，从状态st​到st+1​，并获得奖励rt​的这一过程可以用条件转移概率p(st+1​,rt​∣st​,at​)来表示。 Q-learning的优化目标是最大化长期收益\",\"Gt​=E[n=0∑∞​βnrt+n​]\",\"奖励(reward): 如果agent在当前时刻t所执行的动作能够提高总MOS，则无人机将获得正奖励。否则，agent将获得负奖励。\",\"xt​=⎩⎨⎧​1,−0.1,−1,​ifMOSnew​>MOSold​ifMOSnew​=MOSold​ifMOSnew​<MOSold​​\",\"具体代码：（策略为贪心策略）\",\"算法1\",\"个人理解：\",\"通过K-means来划分各个无人机所管理的用户簇。无人机的位置初始化也是随机部署的\",\"但每个无人机所管理的用户不同，其目标也应该不一样，不能用同一个Q-table管理，这里是每个无人机都有一张自己的Q-table，来进行迭代？ 还是同一张Q-table，只不过根据区域划分，不同的无人机agent的Q(s,a)的s是有范围的？(个人感觉是这个)\",\"最终输出的结果，应该是无人机最终停的位置即是部署的最佳位置(因为q-learning是优化长期目标)，发现在该位置静止是最优的，表示是最佳部署位置。\",\"最终输出结果，是根据Q-table来找出对应q(s,a)当a为静止时，最大的q(s,a)值，对应s就是UAV的部署位置\"]},\"388\":{\"h\":\"无人机的动态移动设计\",\"t\":[\"考虑用户在每个时隙移动的情况，由于用户在每个时隙都处于漫游状态，因此随着用户位置的变化，每个集群中无人机的最优位置也会发生变化，无人机需要进行移动。\",\"在本文中不考虑用户移动到其他集群的情况 因为在不考虑用户自由穿梭集群的情况，对于动作空间而言，仅需要考虑无人机的7个移动方向即可；但若考虑集群情况，动作空间包含两个部分：选择移动方向和选择关联用户。设无人机总数为N，∣Kn​∣为第n个簇的用户总数，则用户的关联动作数为2N∑n=1N​∣Kn​∣，∑n=1N​∣Kn​∣是总用户数，每个用户都需要判断是否与每个无人机关联，因此是2N 则总动作空间的大小为7+2N∑n=1N​∣Kn​∣会导致动作空间过大，Q-table过大。\",\"1.用户漫游模型 在设计无人机的移动之前，需考虑用户的移动性，这里有多种mobility modles可选择，如a deterministic approach, a hybrid approach, and a random walk model. 在本文中，采用的是the random walk model(Markovian mobility model) 每个用户的移动方向均匀分布在左、右、前、后四个方向。 用户的速度设为[0,cmax​]，其中cmax​表示用户的最大速度。\",\"2.基于q-learning的移动算法 与基于q-learning的部署算法不同的是，在此情况下，状态除了要考虑无人机的3D位置外，还需要考虑所有用户的2D位置。即ξ={xUAV​,yUAV​,hUAV​,xuser​,yuser​}(xuser​,yuser​)由用户的初始位置和运动模型决定，(xUAV​,yUAV​,hUAV​)由无人机的位置和它们在最后时隙采取的动作决定.\",\"训练阶段: \",\"测试阶段:\\n\"]},\"389\":{\"c\":[\"academic\"]},\"390\":{\"c\":[\"UAV\",\"IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"391\":{\"h\":\"RL1 - 基本概念\"},\"392\":{\"h\":\"强化学习框架图\",\"t\":[\"主要框架\"]},\"393\":{\"h\":\"1. 基本概念\",\"t\":[\"State(状态)：The status of the agent with respect to the environment.\",\"State Space(状态空间): 所有状态的集合。S={si​}i=1n​。\",\"Action(动作): 对于每一个状态，都有可选择的动作。\",\"Action space of a state: 对应状态中所有可选择的动作集合。A(si​)={ai​}i=1n​\",\"State transition(状态转换): s1​→a1​s2​。定义了agent与环境的交互行为。\",\"State transition probability: p(s2​∣s1​,a1​)，即状态s1​采用动作a1​转到状态s2​的概率。\",\"Policy π: 指导agent在当前状态下选择哪个动作。\",\"Reward(奖励): 在执行一个动作后获得的一个常数(依赖于当前状态和所采取的动作)。同样可以用条件概率的形式进行描述，如p(r=1∣s1​,a1​)，即在状态s1​下采用动作a1​获得的奖励r=1的概率。\",\"Trajectory：a state-action-reward chain.(可以有限，也可以是无限长的trajectory) s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​. 个人理解，trajectory是在策略给定下，agent可能走出的全部轨迹，并非只是一个单一的轨迹。\",\"Return of a trajectory：将对应的轨迹所获得的所有reward的总和，可以粗步衡量一个策略的好坏。\",\"Discounted return(of a trajectory)：为了应对具有无限步的trajectory的return=∞的情况。 s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​…. 此时该trajectory的return=0+0+0+1+1+⋯=∞。 引入discount rate, γ∈[0,1). 此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​ 显然，如果γ接近0，即此时的discounted return越短视，注重近期的reward；γ接近1，更远视，更注重长远的reward。\",\"Episode(trial)：When interacting with the environment following a policy, the agent may stop at some terminal states. The resulting trajectory is called an episode(or a trial)/ 即表示具有终止状态terminal states的trajectory，通常是具有有限步长的trajectory. 同理，这样的任务称为episodic tasks。\",\"continuing tasks：即不具备terminal states的任务，会与环境一直交互下去。 可以通过设置将episodic tasks转换成continuing tasks，如可以在target states中限制action space，控制其一直待在target states中。 Deterministic — Stochastic\"]},\"394\":{\"h\":\"2.Markov decision process(MDP)\",\"t\":[\"关键元素：\",\"Sets： \",\"State：the set of states S\",\"Action：the set of actions A(s) is associate for state s∈S\",\"Reward：the set of rewards R(s,a).\",\"Probability distribution： \",\"State transition probability p(s′∣s,a): 表示在状态s下采取动作a，转换到状态s′的概率。\",\"Reward probability p(r∣s,a): 表示在状态s下采取动作a，获得reward r 的概率。\",\"Policy：at state s, the probability to choose action a is π(a∣s). 表示在各状态执行各动作的概率。\",\"Markov property：即无记忆的特性。 p(st+1​∣at+1​,st​,…,a1​,s0​)=p(st+1​∣at+1​,st​)r(st+1​∣at+1​,st​,…,a1​,s0​)=p(rt+1​∣at+1​,st​)\",\"Markov process：在policy是确定的情况下，MDP就变为MP。\"]},\"395\":{\"c\":[\"academic\"]},\"396\":{\"c\":[\"强化学习\"]},\"397\":{\"h\":\"RL10 - Actor-Critic 方法\",\"t\":[\"actor: 对应 policy update\",\"critic: 对应 policy evaluation 或者 value evaluation\",\"20240830184236\",\"显然，是在基于 策略梯度上升 算法的基础上，将对于 Q 值的估计通过一个网络来进行描述，这个便成为 critic, 而对应的策略梯度上升算法就是对应 actor。\",\"20240830184312\"]},\"398\":{\"h\":\"1. The simplest actor-critic (QAC)\",\"t\":[\"20240830184330\",\"20240830184424\"]},\"399\":{\"h\":\"2. Advantage actor-critic (A2C)\",\"t\":[\"核心思想：在 QAC 的基础上来引入偏置量(baseline)，从而减小方差，提升采样的效率。\"]},\"400\":{\"h\":\"2.1 baseline\",\"t\":[\"在策略梯度算法中引入一个 baseline, 不会影响所求的梯度。 即:\",\"▽θ​J(θ)​=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)]=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)−b(S)]​\",\"证明: 要证明加入baseline成立，只需要保证:\",\"ES∼η,A∼π​[▽θ​ln(A∣S,θ)b(S)]=0\",\"20240830185127\",\"作用:\",\"因此，我们需要找到一个 baseline 来保证这个梯度的方差最小即可。\"]},\"401\":{\"h\":\"2.2 最好的 baseline\",\"t\":[\"20240830185324\",\"在实际情况中，我们通常将 baseline 设置为 vπ​(s)\"]},\"402\":{\"h\":\"2.3 对应算法\",\"t\":[\"20240830185537\",\"20240830185556\",\"20240830185629\"]},\"403\":{\"h\":\"3. off-policy actor-critic\",\"t\":[\"通过 重要性采样 的方法，将处于 另一分布下 的策略所采集的数据来 运用到 策略更新 中。\"]},\"404\":{\"h\":\"3.1 重要性采样 (Importance sampling)\",\"t\":[\"20240830200056\",\"20240830200118\",\"20240830200138\"]},\"405\":{\"h\":\"3.2 off-policy\",\"t\":[\"20240830200248\",\"20240830200305\",\"20240830200320\",\"20240830200343\"]},\"406\":{\"h\":\"3.3 伪代码\",\"t\":[\"20240830200406\"]},\"407\":{\"h\":\"4. Deterministic actor-critic (DPG)\",\"t\":[\"1234\",\"20240830200608\",\"20240830200624\"]},\"408\":{\"c\":[\"academic\"]},\"409\":{\"c\":[\"强化学习\"]},\"410\":{\"h\":\"RL2 - 贝尔曼公式\"},\"411\":{\"h\":\"核心内容\",\"t\":[\"state value\",\"the Bellman equation\"]},\"412\":{\"h\":\"1.State value\"},\"413\":{\"h\":\"1.1\",\"t\":[\"引入随机变量后对应的discounted return的描述。 即一个trajectory下的discounted return。 由此可以推导出一个多步的trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的discounted return为：Gt​=Rt+1​+γRt+2​+γ2Rt+3​+…\",\"γ 为discounted rate\",\"Gt​也是一个随机变量\"]},\"414\":{\"h\":\"1.2 State value\",\"t\":[\"State value 是 Gt​ 的期望, 也称为 state value function 表示为 The expection(expected value or mean) of Gt​:\",\"vπ​(s)=E[Gt​∣St​=s]\",\"是一个有关状态s的函数.\",\"vπ​(s) 是基于一个给定策略 π , 对于不同的策略，所得到的 state value 是不同的.\",\"state value 可以用来衡量一个状态的价值.\"]},\"415\":{\"h\":\"1.3 State value 与 return 的区别\",\"t\":[\"Return 是针对一条trajectory所求的，而 State value 则是对多个 trajectory 求 return 再求平均值。 The state value is the mean of all possible returns that can be obtained starting from a state. 只有当所有东西都是确定性的(π(a∣s),p(r∣s,a),p(s′∣s,a))，state value 与 return 是一致的.\"]},\"416\":{\"h\":\"2. Bellman equation\",\"t\":[\"用来描述所有状态的state value的关系. 根据一个 random trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的 discounted return Gt​ 为:\",\"Gt​​=Rt+1​+γRt+2​+γ2Rt+3​+…=Rt+1​+γ(Rt+2​+γRt+3​+…)=Rt+1​+γGt+1​​\",\"因此，对应的 state value 为:\",\"vπ​(s)​=E[Gt​∣St​=s]=E[Rt+1​+γGt+1​∣St​=s]=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s]​\",\"需要推导E[Rt+1​∣St​=s]和E[Gt+1​∣St​=s]的计算即可。\"]},\"417\":{\"h\":\"2.1 The mean of immediate rewards:\",\"t\":[\"E[Rt+1​∣St​=s]​=a∑​π(a∣s)E[Rt+1​∣St​=s,At​=a]=a∑​π(a∣s)r∑​p(r∣s,a)r​\"]},\"418\":{\"h\":\"2.2 The mean of future rewards:\",\"t\":[\"E[Gt+1​∣St​=s]​=s′∑​E[Gt+1​∣St​=s,St+1​=s′]=s′∑​E[Gt+1​∣St+1​=s′](无记忆性)=s′∑​vπ​(s′)p(s′∣s)=s′∑​vπ​(s′)a∑​p(s′∣s,a)π(a∣s)​\",\"个人推导：\",\"E[Gt+1​∣St​=s]​=a∑​π(a∣s)E[Gt+1​∣St​=s,At​=a]=a∑​π(a∣s)s′∑​E[Gt+1​∣St​=s,At​=a,St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)E[Gt+1​∣St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​\"]},\"419\":{\"h\":\"2.3 Bellman equation\",\"t\":[\"vπ​(s)​=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s],=mean of immediate rewards a∑​π(a∣s)r∑​p(r∣s,a)r​​+mean of future rewards γa∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​​,=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)],∀s∈S.​\",\"该式子针对状态空间中的所有状态均成立.\",\"通过 Bootstrapping , 可以求解 state value.\",\"π(a∣s) 表示一个给定的策略. 求解Bellman equation 称为策略评估(Policy evaluation).\",\"p(r∣s,a),p(s′∣s,a) 是由环境决定的(dynamic model|environment model). 后续可能是未知的(model-free)，需要通过采样解决.\"]},\"420\":{\"h\":\"2.4 Bellman equation (Matrix-vector form)\",\"t\":[\" 此时,对于所有状态s，对应的 Bellman equation 为\",\"vπ​(s)=rπ​(s)+γs′∑​pπ​(s′∣s)vπ​(s′)​\",\"将所有状态的 Bellman equation 整合，重新修改为 matrix-vector form.\",\"vπ​=rπ​+γPπ​vπ​​\",\"其中,\",\"vπ​=[vπ​(s1​),…,vπ​(sn​)]T∈Rn\",\"rπ​=[rπ​(s1​),…,rπ​(sn​)]T∈Rn\",\"Pπ​∈Rn×n, where [Pπ​]ij​=pπ​(sj​∣si​), 表示状态转移矩阵.\"]},\"421\":{\"h\":\"3. Why to slove state value\",\"t\":[\"为了进行 Policy evaluation, 即对于给定策略，求出其对应状态的 state value 的过程。\",\"通过 Bellman euqation 进行求解。\",\"The closed-form solution(不常用):\",\"vπ​=(I−γpπ​)−1rπ​​\",\"An iterative solution(一种迭代策略):\",\"vk+1​=rπ​+γPπ​vk​​\",\"可以最开始均初始化为 0 , 然后进行不断迭代，可以得到一个序列v0​,v1​,v2​,…. 最终可以证明：vk​→vπ​=(I−γpπ​)−1rπ​,k→∞\"]},\"422\":{\"h\":\"4. Action value\",\"t\":[\"State value: agent从一个状态出发可以得到的平均return. the average return the agent can get starting from a state\",\"Action value: agent从一个状态出发，采取一个指定的action可以得到的平均return。 the average return the agent can get starting from a state and taking an action.\",\"通过求解 action value 我们可以分析出在该状态下采取哪个 action 收益最大. Action value 定义:\",\"qπ​(s,a)=E[Gt​∣St​=s,At​=a]​\",\"同样地，qπ​(s,a)是依赖于策略π的，并且与状态 s 和动作 a 有关.\",\"vπ​(s)E[Gt​∣St​=s]​​=a∑​qπ​(s,a)E[Gt​∣St​=s,At​=a]​​π(a∣s)\",\"因此，vπ​(s)=∑a​qπ​(s,a)π(a∣s) 由于,\",\"vπ​(s)=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)]​\",\"所以，qπ​(s,a)=∑r​p(r∣s,a)r+γ∑s′​p(s′∣s,a)vπ​(s′)\",\"实际意义是：在当前状态s下采取动作 a 所获得的均值，加上 γ 的转到下一个状态的 state value 加权均值。\",\"引入 action value 后，对于 state value 实际意义的解释：在当前状态s下，根据策略π, 所有可能动作的 action value 的加权均值。\",\"state value 和 action value 可以互相转化。\"]},\"423\":{\"h\":\"5. 总结\",\"t\":[\"State value: vπ​(s)=E[Gt​∣St​=s]\",\"Action value: qπ​(s,a)=E[Gt​∣St​=s,At​=a]\",\"State value 是 action value 的根据策略π加权平均，即vπ​(s)=∑a​π(a∣s)q(s,a)\",\"The Bellman equation (elementwise form and matrix-vector form)\",\"求解 the Bellman equation (2种方法)\"]},\"424\":{\"c\":[\"academic\"]},\"425\":{\"c\":[\"强化学习\"]},\"426\":{\"h\":\"RL3 - 贝尔曼最优公式\",\"t\":[\"Core concepts: optimal state value and optimal policy\",\"A fundamental tool: the Bellman optimality equation (BOE)\"]},\"427\":{\"h\":\"1. Optimal policy\",\"t\":[\"最优策略的定义: A policy π∗ is optimal if π∗(s)≥vπ​(s) for all s and for any other policy π. 需要确定几件事:\",\"最优策略是否存在 存在，根据 the contraction mapping Theorem.\",\"最优策略是否唯一 唯一，根据 the contraction mapping Theorem.\",\"最优策略是 stochastic 还是 deterministic deterministic 且 greedy\",\"如何得到最优策略 选取状态中最大的 action value 作为下一步的 action\"]},\"428\":{\"h\":\"2. Bellman optimality equation (BOE)\"},\"429\":{\"h\":\"2.1 基本形式\",\"t\":[\"对于贝尔曼最优公式而言，其策略π表示的是最优策略，除了需要求解 state value 外，还需要求解最优策略π.elementwise form:\",\"vπ​(s)​=πmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)),∀s∈S=πmax​a∑​π(a∣s)q(a,s),∀s∈S​\",\"matrix-vector foem:\",\"v=πmax​(rπ​+γPπ​v)​\"]},\"430\":{\"h\":\"2.2 如何求解\",\"t\":[\"对于贝尔曼最优公式而言，区别于贝尔曼公式，只是求解各状态的 state value, 我们还需要理解其所描述的最优策略π∗ 具体分两步:\"]},\"431\":{\"h\":\"2.2.1 如何处理等式右边的 (最优策略)\",\"t\":[\"vπ​(s)=maxπ​∑a​π(a∣s)q(s,a), 为了让右边取到最大值的情况，我们只需要在当前状态下，保证选取最大的 action value 即可，对应策略表示为:\",\"π(a∣s)={10​a=a∗a=a∗​\",\"其中a∗表示在该状态下计算出来的最大 action value 对应的动作，即a∗=argmaxa​q(s∣a)\"]},\"432\":{\"h\":\"2. 求解 state value\",\"t\":[\"将 BOE 转换为 v=f(v) 的形式，其中f(v):=maxπ​(rπ​+γPπ​v)f(v)对应一个向量, [f(v)]s​=maxπ​∑a​π(a∣s)q(s∣a),∀s∈S\",\"求解方法：\",\"Fix point: f(x)=x\",\"Contraction mapping(contractive function): ∣∣f(x1​)−f(x2​)∣∣≤γ∣∣x1​−x2​∣∣\",\"由此可以根据Contraction Mapping Theorem: For any equation that has the form of x=f(x), if f is a contraction mapping, then\",\"Existence: 存在不动点x∗，满足f(x∗)=x∗\",\"Uniqueness: 不动点x∗是唯一的\",\"Algorithm: Consider a sequence xk​ where xk+1​=f(xk​), then xk​→x∗ as k→∞. Moreover, the convergence rate is exponentially fast.\",\"因此，可以通过Contraction Mapping Theorem来求解贝尔曼最优公式，因为其满足该理论，即f(v)是一个contraction mapping。\"]},\"433\":{\"c\":[\"academic\"]},\"434\":{\"c\":[\"强化学习\"]},\"435\":{\"h\":\"RL4 - 值迭代和策略迭代(动态规划)\",\"t\":[\"贝尔曼最优公式:\",\"v=f(v)=πmax​(rπ​+γPπ​v)\"]},\"436\":{\"h\":\"1. Value iteration algorithm\",\"t\":[\"根据 chapter 3 中涉及的 contraction mapping theorem, 我们可以通过对应的迭代算法来求解贝尔曼最优公式\",\"vk+1​=f(vk​)=πmax​(rπ​+γPπ​vk​),k=1,2,3…\",\"这种迭代算法称为 value iteration.\"]},\"437\":{\"h\":\"1.1 具体步骤\",\"t\":[\"共分为 2 步：\",\"Policy update 这步是更新策略π，即求解右边的式子，πk+1​=argmaxπ​(rπ​+γPπ​vk​), 其中vk​是给定的。 其对应的 elementwise form:\",\"πk+1​(s)=πargmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)v(s′)),s∈S 由于 p(s′∣s,a),p(r∣s,a),v(s′) 是已知的，显然，这里的最优策略πk+1​是一个 greedy policy，我们只需要挑选在当前迭代下最大的 action value 就好了, 即:\",\"πk+1​(a∣s)={10​a=ak∗​(s)a=ak∗​(s)​ 其中ak∗​(s)=argmaxa​qk​(a,s).\",\"value update 根据 Policy update 的策略πk+1​, 求解下一步的vk+1​, 即\",\"vk+1​=rπk+1​​+γPπk+1​​vk​这里的vk​并不是 state value 由于πk+1​是 greedy 的，对应的vk+1​(s)=maxa​qk​(a,s)\"]},\"438\":{\"h\":\"1.2 伪代码\",\"t\":[\"20240810190018\"]},\"439\":{\"h\":\"2. Policy iteration algorithm\",\"t\":[\"算法迭代示意图:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\"]},\"440\":{\"h\":\"2.1 算法描述\",\"t\":[\"首先随机设计一个初始的策略π0​\",\"Step 1: policy evaluation (PE) 策略评估 该步骤是用来计算当前策略 πk​ 的 state value. 可以通过 Bellman equation 进行求解，即:\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"根据对应的 Elementwise form:\",\"vπk​(j+1)​(s)=a∑​πk​(a∣s)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​(j)​(s′)),s∈S\",\"由此进行迭代，直到设置的收敛条件为止，即j→∞ 或者 ∣∣vπk+1​(j+1)​(s)−vπk​(j)​(s)∣∣≤δ.\",\"Step 2: policy improvement (PI) 策略提升 该步骤是根据 PE 所求出的 state value, 根据 action value，来提升当前策略 πk​\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"对应的 Elementwise form:\",\"πk+1​(s)=πargmax​a∑​πk​(a∣s)qπk​​(s,a)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​​(s′))​​,s∈S\",\"这里，显然是可以通过一个 greedy 的策略来进行选择，即:\",\"πk+1​(a∣s)={10​a=ak∗​(s),a=ak∗​(s).​\",\"其中 aK∗​(s)=argmaxa​qπk​​(s,a).\"]},\"441\":{\"h\":\"2.2 伪代码\",\"t\":[\"20240811002219\"]},\"442\":{\"h\":\"2.3 一些问题\",\"t\":[\"在 PE 步骤中，如何通过 Bellman equation 得到 state value vπk​​. 根据 chapter 2 中求解 Bellman equation 的方法 一种是可以直接通过矩阵求逆进行求解，即 vπk​​=(I−γPπk​​)−1rπk​​，实际不常用. 一种是通过迭代算法来求解\",\"vπk​(j+1)​=rπk​​+γPπk​​vπk​(j)​\",\"在 PI 步骤中，如何确保策略 πk+1​ 是优于 πk​的.\",\"为什么这个迭代算法最终可以找到最优策略 每次迭代都会使得策略进行提升，那么\",\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",\"我们需要保证策略是不断提升，且最终会收敛到最优策略v∗\",\"policy iteration algorithm 与 value iteration algorithm 之间存在什么关系.\"]},\"443\":{\"h\":\"3. Truncated policy iteration algorithm\",\"t\":[\"该算法是 value iteration 以及 policy iteration 一般化的推广\"]},\"444\":{\"h\":\"3.1 value iteration 与 policy iteration 算法比较\",\"t\":[\"Policy iteration: 需要初始化策略π0​, 之后进行迭代\",\"Policy evaluation (PE): 通过 Bellman equation 求解当前策略的 state value.\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"内嵌迭代算法求解.\",\"Policy improvement (PI): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"Value iteration: 需要初始化猜测的 state value v0​\",\"Policy update (PU): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vk​)\",\"Value update (VU): 进行迭代\",\"vk+1​=rπk+1​​+γPπk+1​​vk​\",\"两个算法迭代过程十分类似: Policy iteration:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\",\"Value iteration:\",\"u0​PU​π1′​VU​u1​PU​π2′​VU​u2​PU​…\",\"Policy iteration algorithm\",\"Value iteration algorithm\",\"Comments\",\"1) Policy:\",\"π0​\",\"N/A\",\"2) Value:\",\"vπ0​​=rπ0​​+γPπ0​​vπ0​​\",\"v0​:=vπ0​​\",\"对于 policy iteration，vπ0​​是通过迭代算法来求的; 而 value iteration 我们这里强行初始化为vπ0​​，方便后续比较\",\"3) Policy:\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"在策略更新上，这两个算法是一致的。\",\"4) Value:\",\"vπ1​​=rπ1​​+γPπ1​​vπ1​​\",\"v1​=rπ1​​+γPπ1​​v0​\",\"对于 Policy iteration 而言, 这里需要通过迭代算法来精确求出 vπ1​​; 对于 Value iteration，则只是进行一次带入求解。\",\"5) Policy:\",\"π2​=argmaxπ​(rπ​+γPπ​vπ1​​)\",\"π2′​=argmaxπ​(rπ​+γPπ​v1​)\",\"⋮\",\"⋮\",\"⋮\",\"⋮\"]},\"445\":{\"h\":\"3.2 Truncated policy iteration algorithm\",\"t\":[\"20240811010933\",\"显然，在求解 Bellman equation 中，Value iteration 只是进行了一步求解，而 Policy iteration 进行了无穷多步来进行了真实的求解 state value，显然在现实运行算法中是无法做到的。 因此 Truncated policy iteration algorithm 就是进行迭代 n 步来求解。\"]},\"446\":{\"h\":\"truncated policy iteration algorithm 是否是收敛的\",\"t\":[\"20240811011334\"]},\"447\":{\"c\":[\"academic\"]},\"448\":{\"c\":[\"强化学习\"]},\"449\":{\"h\":\"RL5 - 蒙特卡洛方法 (Monte Carlo) model-free\",\"t\":[\"如何在没有模型 (即p(r∣s,a),p(s′∣s,a)等均未知) 的情况下进行估计 通过 Monte Carlo estimation. 其核心思想是： 若有一系列(i.i.d)样本采样，得到一个样本序列x1​,x2​,…,xN​ 那么对于随机变量X的估计可以为：\",\"E[x]≈xˉ=N1​j=1∑N​xj​\",\"该方法成立的数学依据是 大数定理 (Law of Large Numbers)样本必须是独立同分布(iid, independent and identically distributed)\",\"为什么考虑 mean estimation. 因为无论是 state value 还是 action value 其原始定义都是从期望出发的。\",\"vπ​(s)=E[Gt​∣St​=s];qπ​(s,a)=E[Gt​∣St​=s,At​=a]\"]},\"450\":{\"h\":\"1. MC Basic\",\"t\":[\"最简单的示例算法，用于解释 MC 的原理，但现实场景中不太经常使用，效率过低。\",\"核心思想：如何将 Policy iteration algorithm 转换为 model-free 的情况。\"]},\"451\":{\"h\":\"1.1 算法思路\",\"t\":[\"Policy iteration 算法的核心是 先根据当前策略计算出各个状态的 state value， 再将 state value 转换为 action value，更新策略的步骤就是选择此时 action value 最大的 action.\",\"{Policyevaluation:vπk​​=rπk​​+γPπk​​vπk​​Policyimprovement:πk+1​=argmaxπ​(rπ​+γPπ​vπk​​)​\",\"显然其核心关键就是在 PE 中 通过迭代算法求解 Bellman equation 的 state value后：\",\"对于 model-based 的情况, 因为 p(r∣s,a),p(s′∣s,a) 已知，我们可以很轻松的求出各个情况下的q(s,a)，从而选择每个状态下最大的 action value 即可。\",\"qπk​​(s,a)=r∑​p(r∣s,a)+γs′∑​p(s′∣s,a)vπk​​(s)\",\"对于 model-free 的情况，此时 p(r∣s,a),p(s′∣s,a) 未知，我们不能通过之前的方法来求出q(s,a)，需要从 action value 的定义出发，即：\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]\",\"从此可以发现，我们可以通过前面所引入的 mean estimation 方法，来进行求解 q(s,a).\"]},\"452\":{\"h\":\"1.2 如何估计\",\"t\":[\"从指定的 (s,a) 出发，根据策略 πk​, 我们可以生成一个 episode.\",\"这个 episode 的 return 为 g(s,a).\",\"显然，g(s,a) 就是前面 Gt​ 的一个 sample.\",\"假设我们有了一系列 从状态 s 出发, 采取动作 a 的 episodes, 即 g(j)(s,a). 那么我们可以对 qπk​​(s,a) 进行估计，即\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]≈N1​i=1∑N​g(i)(s,a).\"]},\"453\":{\"h\":\"1.3 具体算法\",\"t\":[\"与 Policy iteration algorithm 步骤类似 首先初始化一个随机的策略π0​，然后进行迭代，对于 kth 迭代，有：\",\"Step 1: Policy evaluation. 求在策略πk​下所有的 action value, q(s,a). 具体求解方法，如 1.2 节所述，只不过我们此时需要遍历所有的 action-state pair. 为什么不去求 state value，因为最终策略更新的核心仍然是 action value, 即使先估计了 state value, 我们仍需要估计 action value.\",\"Step 2: Policy improvement. 这是来求解 πk+1​(s)=argmaxπ​∑a​π(a∣s)qπk​​(s,a),foralls∈S 这个仍然与之前一致，采用 greedy policy，即对于每个状态，我们选取其 action value 最大的 action.πk+1​(ak∗​∣s)=1，其中ak∗​=argmaxa​qπk​​(s,a)\",\"20240811233346\"]},\"454\":{\"h\":\"2. MC Exploring Starts\",\"t\":[\"MC Exploring Starts 是针对 MC Basic 的一些改进，即对于数据(experience)更加高效利用。\"]},\"455\":{\"h\":\"2.1 Episode 的高效利用\",\"t\":[\"Visit: every time a state-action pair appears in the episode, it is called a visit of that state-action pair.\",\"考虑一个 episode, 跟随策略π,\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…\",\"对于 MC-Basic, 这一条 episode 仅用作估计 state-action pair (s1​,a2​) 的 action value q(s1​,a2​)，但存在一定的浪费, 对于一个 episode, 可以拆分为多个 episode, 从而进行多次利用.\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s1​a2​​s2​a3​​s5​a1​​…s2​a3​​s5​a1​​…s5​a1​​…​[originalepisode][episodestartingfrom(s2​,a4​)][episodestartingfrom(s1​,a2​)][episodestartingfrom(s2​,a3​)][episodestartingfrom(s5​,a1​)]​\",\"这样，我们不仅可以用来估计q(s1​,a2​), 还可以估计q(s2​,a4​),q(s2​,a3​)…\",\"Data-efficient methods:\",\"first-visit method 记录在 episode 中第一次出现的 state-action pair, 如果该 state-action pair 再次出现, 不记录 action value 估计中.\",\"every-visit method 对于每个 state-action pair, 都记录 action value 估计中.\"]},\"456\":{\"h\":\"2.2 高效地更新 Policy\",\"t\":[\"什么时候更新策略也是一个影响效率的因素。\",\"方法1：如 MC Based 一样，在收集到了足够多的 从给定的 state-action pair 出发的 episodes 后, 通过 mean estimation 估计了q(s,a)后, 才进行更新。 缺点，等候时间过长，只有当所有 episodes 均收集完，才能进行 策略更新。\",\"方法2：直接 uses the return of a single episode to approximate the action value. 这类算法统称为：Generalized policy iteration (GPI). 它会在 Policy-evaluation 和 policy-improvement 中不断切换，即不需要完全精确地求出 action value，就直接去更新策略。\"]},\"457\":{\"h\":\"2.3 MC Exploring Starts\",\"t\":[\"20240812004534\"]},\"458\":{\"h\":\"2.4 Exploring Statrts的解释\",\"t\":[\"Exploring 表示对于每一个 action-state pair (s,a), 都需要有多个 episodes, 这样才能去估计相应的qπ​(s,a). 如果存在一个 action value 未能访问，就不能确保所选择的 action 是最优的。\",\"Starts 表示对于对应 action-state pair (s,a) 的 episodes，每次都是从对应的状态 s 出发，选择对应的动作 a 进行的采样。 如果从其他状态出发，得到的 episode，如果经过了 (s,a)，那么这称为 visit , 但目前无法保证 visit 一定可以遍历所给定的 (s,a).\",\"据目前而言，Exploring Starts 是一个必要条件.\"]},\"459\":{\"h\":\"3. MC Eplison-Greedy\",\"t\":[\"将 Exploring Starts 条件转换掉，通过采取 Soft Policies 的方法。\"]},\"460\":{\"h\":\"3.1 Soft Policy\",\"t\":[\"A policy is called soft if the probability to take any action is positive. 显然 soft policy 是 stochastic 的，并且如果按照这样一个策略，在 episode 足够长的情况下，我们可以确保其可以遍历所有的 state-action pair.\"]},\"461\":{\"h\":\"3.2 -greedy policy\",\"t\":[\"在这里，我们采用的是 ϵ-greedy policies, 其属于 soft policies.\",\"π(a∣s)={1−∣A(s)∣ϵ​(∣A(s)∣−1),∣A(s)∣ϵ​,​forthegreedyaction,fortheother∣A(s)∣−1action,​\",\"其中 ϵ∈[0,1] 且 ∣A(s)∣ 为状态 s 的动作数量.ϵ-greedy policy 可以平衡 exploitation 和 exploration. 显然ϵ=0, policy 就是 greedy 的; 如果ϵ=1, 此时就是随机策略，其探索性就很强.\"]},\"462\":{\"h\":\"3.3 -greedy policy 引入 MC-based 算法中\",\"t\":[\"对于 MC Basic 以及 MC Exploring 中的 policy improvement 中，找的是在所有可能策略中的最优策略，因此是一个确定的贪心策略。\",\"20240812011140\"]},\"463\":{\"h\":\"3.3 算法流程\",\"t\":[\"20240812010538\"]},\"464\":{\"c\":[\"academic\"]},\"465\":{\"c\":[\"强化学习\"]},\"466\":{\"h\":\"RL6 - 随机近似理论与随机梯度下降算法\",\"t\":[\"针对 mean estimation 问题进行研究，因为在 RL 中 无论是 state value 还是 action value 其定义都是一个均值 (means)\",\"Stochastic approximation(SA): SA refers to a broad class of stochastic iterative algorithms soloving root finding or optimization problems.\"]},\"467\":{\"h\":\"1. 引言\"},\"468\":{\"h\":\"1.1 求均值的方法\",\"t\":[\"第一种：直接通过 E[x]≈xˉ:=N1​∑i=1N​xi​，进行估计，只有当样本全部收集完才能估计.\",\"第二种: 增量式的迭代算法. 假设:\",\"wk+1​=k1​i=1∑k​xi​,k=1,2,…\",\"对应的\",\"wk​=k−11​i=1∑k−1​xi​,k=2,3,…\",\"那么，wk+1​可以由wk​推导出来，即\",\"wk+1​​=k1​∑i=1k​xi​​=k1​(∑i=1k−1​xi​+xk​)=k1​((k−1)wk​+xk​)​=wk​−k1​(wk​−xk​)​\",\"因此，wk+1​=wk​−k1​(wk​−xk​)\"]},\"469\":{\"h\":\"2. Robbins-Monto(RM) algorithm\"},\"470\":{\"h\":\"2.1 问题引入\",\"t\":[\"假设我们需要求解如下方程:\",\"g(w)=0\",\"其中, w∈R 且需要被求解出来，g:R→R 为一个函数方程. 显然，如果对于 g(w) 已知的情况，我们可以通过一些特定的算法进行求解。 如果 g(w) 未知，就需要新的算法进行解决。\"]},\"471\":{\"h\":\"2.2 算法介绍\",\"t\":[\"RM 算法就可以用来求解当 g(w) 未知时的情况，即函数 g(w) 是一个黑盒，我们只能通过 输入序列: wk​, 得到含有噪音的观测值序列: g​(wk​,ηk​) 具体解决如下:\",\"wk+1​=wk​−ak​g​(wk​,ηk​),k=1,2,3,…\",\"其中:\",\"wk​ 是第 k 次方程根的估计.\",\"g​(wk​,ηk​)=g(wk​)+ηk​ 是第 k 次的观测值(含噪音).\",\"ak​ 是一个 positive coefficient.\"]},\"472\":{\"h\":\"2.3 收敛性分析\",\"t\":[\"Robbins-Monro Theorem In the Robbins-Monro algorithm, if\",\"0<c1​≤▽w​g(w)≤c2​,forallw; 要求g(w)必须是递增的，确保根是存在且唯一的。\",\"∑k=1∞​ak​=∞ 且 ∑k=1∞​ak2​<∞;∑k=1∞​ak2​=∞ 保证 ak​→0,k→0∑k=1∞​ak​=∞ 保证 ak​→0不要过快.\",\"E[ηk​∣Hk​]=0 且 E[ηk2​∣Hk​]<∞; 其中Hk​=wk​,wk−1​,…, 那么 wk​ converges with probability 1 (w.p.1) to the root w∗ satisfying g(w∗)=0.\",\"ak​=k1​是满足上面三个条件的. 但实际上我们往往是选择一个非常小的常数。\"]},\"473\":{\"h\":\"2.4 应用于 mean estimation 中\",\"t\":[\"比如我们要估计某个随机变量X的 E[X] 我们可以设计如下方程:\",\"g(w)≐w−E[X].\",\"那么只要求解 g(w)=0, 我们就可以得到 E[X] 的值。 同样，我们不能直接得到随机变量的值，而是对应的样本 x，sample of X. 即，我们得到的观测值是:\",\"g​(w,x)≐w−x\",\"我们可以修改为噪音 η 的形式，\",\"g​(w,η)​=w−x​=w−x+E[X]−E[X]=(w−E[X])+(E[X]−x)​≐g(w)+η​\",\"因此我们可以通过 RM 算法来进行求解\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​(wk​−xk​)\"]},\"474\":{\"h\":\"3. Stochastic gradient descent\"},\"475\":{\"h\":\"3.1 问题引入\",\"t\":[\"需要求解一个优化问题:\",\"wargmin​J(w)=E[f(w,X)]\",\"其中，\",\"w 是需要被优化的参数\",\"X 是一个随机变量\",\"w 和 X 可以是标量，也可以是向量. 对于函数 f(⋅) 输出为标量.\",\"对于这个问题，我们有以下几种方法:\",\"Method 1: 梯度下降法 (gradient descent, GD)\",\"wk+1​=wk​−αk​▽w​E[f(wk​,X)]=wk​−αk​E[▽w​f(wk​,X)]\",\"但由于 j(w) 是一个期望值，我们很难直接获得.\",\"Method 2: batch gradient descent (BGD) 借用 MC 的思想，我们可以将:\",\"E[▽w​f(wk​,X)]≈n1​i=1∑n​▽w​f(wk​,xi​).\",\"因此\",\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f(wk​,xi​)\",\"但需要大量的 samples 收集完毕才能进行一次迭代.\",\"Method 3: 随机梯度下降(SGD) 考虑能否仅用一次 sample 进行迭代.\",\"wk+1​=wk​−αk​▽w​f(wk​,xk​)\",\"但能否保证其精确度，以及是否可以到最后优化的成果。\"]},\"476\":{\"h\":\"3.2 SGD 分析\"},\"477\":{\"h\":\"mean estimation 问题转化\",\"t\":[\"我们可以将 均值估计 问题 转化为 一个 优化问题 进行求解：\",\"20240814014058\"]},\"478\":{\"h\":\"SGD 正确性和收敛性分析\",\"t\":[\"从 GD 到 SGD:\",\"wk+1​=wk​−αk​E[▽w​f(wk​,X)]⇓wk+1​=wk​−αk​▽w​f(wk​,x)​\",\"显然我们可以将 ▽w​f(wk​,x) 视为 E[▽w​f(wk​,x)] 的一个观测值(含噪声):\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]+η▽w​f(wk​,x)−E[▽w​f(wk​,x)]​​\",\"因为\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]\",\"因此，我们需要思考使用 SGD 时wk​→w∗ as k→∞ 是否成立。\",\"我们可以将 SGD 视为一个特殊情况下的 RM 算法 SGD的目标是 minimize\",\"J(w)=E[f(w,X)]\",\"而最小值问题，往往可以转化为导数为 0 的情况,\",\"▽w​J(w)=E[▽w​f(w,X)]=0\",\"显然，可以参考 RM 算法, 让\",\"g(w)=▽w​J(w)=E[▽w​f(w,X)]\",\"从而转换为一个 root-finding 问题. 相应的，对于观测值g​(w,η),\",\"g~​(w,η)​=∇w​f(w,x)=g(w)E[∇w​f(w,X)]​​+η∇w​f(w,x)−E[∇w​f(w,X)]​​.​\",\"因此，我们就可以通过 RM 算法进行求解g(w)=0,\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​▽w​f(wk​,xk​)\",\"对应收敛性证明\"]},\"479\":{\"h\":\"3.3 SGD 另一种问题描述方法 (deterministic formulation)\",\"t\":[\"在之前关于使用 SGD 算法的问题描述中，我们是引入了 随机变量 和 期望的情况. 我们可以将这个问题可以转化为一个随机变量的方法，从而引入 SGD 算法.\"]},\"480\":{\"h\":\"3.4 BGD MBGD SGDw\",\"t\":[\"20240814230747\"]},\"481\":{\"c\":[\"academic\"]},\"482\":{\"c\":[\"强化学习\"]},\"483\":{\"h\":\"RL7 - Temporal-Difference Learning\"},\"484\":{\"h\":\"1. 引入\",\"t\":[\"考虑一个复杂的均值估计问题: 计算\",\"ω=E[R+γv(X)],\",\"其中, R, X 均是随机变量，γ 是常数，v(⋅) 表示一个函数。 显然我们仍然可以通过 RM 算法进行求解，假设我们可以得到有关随机变量 R, X 的采样 {x},{r}\",\"g(w)g~​(w,η)​=w−E[R+γv(X)]=w−[r+γv(x)]=(w−E[R+γv(X)])+(E[R+γv(X)]−[r+γv(x)])≐g(w)+η​\",\"因此，我们可以将该问题定义为一个 root-finding 问题: g(w)=0. 相应的 RM 算法为:\",\"wk+1​=wk​−αk​g~​(wk​,ηk​)=wk​−αk​[wk​−[rk​+γv(xk​)]]\"]},\"485\":{\"h\":\"2. TD Learning of state value\",\"t\":[\"求解给定策略 π 的 state value，这样就可以与 policy improvement 结合去寻找最优策略。\"]},\"486\":{\"h\":\"2.1 算法描述\",\"t\":[\"算法所需的数据(experience): 根据给定的策略 π 所生成的数据 (s0​,r1​,s1​,…,st​,rt+1​,st+1​,…) or {(st​,rt+1​,st+1​)}\",\"相应的算法是:\",\"vt+1​(st​)vt+1​(s)​=vt​(st​)−αt​(st​)[vt​(st​)−[rt+1​+γvt​(st+1​)]]=vt​(s),∀s=st​,​\",\"其中 t=0,1,2,…, vt​(st​)是关于 vπ​(st​) 的估计。\",\"newestimatevt+1​(st​)​​=currentestimatevt​(st​)​​−αt​(st​)[vt​(st​)−TDtargetvt​ˉ​[rt+1​+γvt​(st+1​)]​​]​TDerrorδt​​\"]},\"487\":{\"h\":\"2.2 算法分析\",\"t\":[\"TD 算法是用来求解一个 给定策略 π 的 Bellman equation.\",\"根据 state value 的定义，对于策略 π 的 state value\",\"vπ​(s)=E[R+γG∣S=s],s∈S\",\"其中 G 是 discounted return。\",\"E[G∣S=s]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s)=E[vπ​(S′)∣S=s]\",\"因此，我们可以写出 Bellman equation 的新形式，称为 Bellman expection equation\",\"vπ​(s)=E[E+γvπ​(S′)∣S=s],s∈S\"]},\"488\":{\"h\":\"2.3 TD 算法 与 MC 算法的比较\"},\"489\":{\"h\":\"3. TD Learning of action value\",\"t\":[\"Sarsa (state-action-reward-state-action) Sarsa 算法其目的是用于直接估计 action value, 从而可以在 policy improvement 中直接根据 action value 进行更新即可。\",\"Sarsa 算法同样是来求解 Bellman equation:\",\"qπ​(s,a)=E[R+γqπ​(S′,A′)∣s,a],∀s,a\"]},\"490\":{\"h\":\"3.1 Sarsa\",\"t\":[\"假设我们具有 some experience {(st​,at​,rt+1​,st+1​,at+1​)} 对应的 Sarsa 算法如下来进行估计 action value:\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(sa​,at​)−αt​(st​,at​)[qt​(sa​,at​)−[rt+1​+γqt​(st+1​,at+1​)]]=qt​(s,a),∀(s,a)=(st​,at​)​\",\"其中 t=0,1,2,…, qt​(st​,at​) 是qπ​(st​,at​)的估计。\",\"收敛性情况\",\"20240817000114\",\"伪代码\",\"20240817000134\",\"20240817000230\"]},\"491\":{\"h\":\"3.2 n-step Sarsa\",\"t\":[\"20240817000500\",\"20240817000601\",\"20240817000642\"]},\"492\":{\"h\":\"3.3 Expected Sarsa\",\"t\":[\"20240817000331\",\"20240817000409\"]},\"493\":{\"h\":\"4. TD Learning of optimal action value\",\"t\":[\"Q-learning 算法是用来解决 action value 形式下的贝尔曼最优公式 (Bellman optimality equation in terms of action value)\",\"q(s,a)=E[Rt+1​+γamax​q(St+1​,a)∣St​=s,At​=a],∀s,a\"]},\"494\":{\"h\":\"4.1 Q-learning\",\"t\":[\"Q-learning 直接估计的是 optimal action value，因此不需要进行 policy improvement。\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(st​,at​)−αt​(st​,at​)[qt​(st​,at​)−[rt+1​+γa∈Amax​qt​(st+1​,a)]]=qt​(s,a),∀(s,a)=(st​,at​)​\"]},\"495\":{\"h\":\"4.2. off-policy | on-policy\",\"t\":[\"behavior policy: 是用来与环境进行交互，从而生成经验数据的策略\",\"target policy: 是我们不断进行更新的策略，最终优化的策略\"]},\"496\":{\"h\":\"on - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是一致的，即我通过这个策略与环境进行交互生成一系列经验，在通过经验来更新这个策略。\"]},\"497\":{\"h\":\"off - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是不同的，即我通过一个策略与环境进行交互生成一系列经验。再通过这些经验来不断改进更新另一个策略，这另一个策略会更新到最优的策略。\",\"Sarsa，MC 是 on-policy 的 Q-learning 是 off-policy 的\"]},\"498\":{\"h\":\"4.3 Q-learning 伪代码\",\"t\":[\"因为 Q-learning 是 off-policy 的，因此，如果我们强制让 target policy 与 behavior ppolicy 一致也是可以的，此时也可以是 on-policy 的。\"]},\"499\":{\"h\":\"off-poicy 版本\",\"t\":[\"20240818182057\",\"此时 target policy 就不需要是 ϵ−greedy 策略了，因为不需要 target policy 进行生成数据。\"]},\"500\":{\"h\":\"on-policy 版本\",\"t\":[\"20240818181917\"]},\"501\":{\"h\":\"5. TD 算法的统一形式和总结\",\"t\":[\"20240818182301\",\"20240818182231\"]},\"502\":{\"c\":[\"academic\"]},\"503\":{\"c\":[\"强化学习\"]},\"504\":{\"h\":\"RL8 - 值函数近似(Value Function Approximation)\",\"t\":[\"对于 q-value 的估计从 基于表格的 (tabular representation) 转换到 基于函数的 (function representation)\"]},\"505\":{\"h\":\"1. 引入\",\"t\":[\"通过使用一个函数来进行拟合 state values 或者 action values: v^(s,w)≈vπ​(s)， 其中w∈Rm是参数向量。\",\"可以提高存储效率\",\"提高泛化能力\"]},\"506\":{\"h\":\"2. Alogorithm of state value estimation\",\"t\":[\"目标: 寻找一个最优的参数w，使得v^(s,w)最接近真实的vπ​(s).\",\"共两步:\",\"定义目标函数\",\"优化目标函数的算法\"]},\"507\":{\"h\":\"2.1 Obejctive function\",\"t\":[\"J(w)=E[(vπ​(S)−v^(S,w))2]\",\"分析随机变量 S 的 probability distribution (即对于损失函数中的 expection 需要考虑怎样对状态进行平均):\"]},\"508\":{\"h\":\"uniform distributon\",\"t\":[\"认为所有状态都是同等重要的，即各个状态的可能性为∣S∣1​ 因此这种情况下的 objective function 可以写成:\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=∣S∣1​s∈S∑​(vπ​(s)−v^(s,w))2\",\"但实际情况可能并不是所有状态的概率都是一致的，基于给定策略下，一些状态可能很少被访问，另一些则频繁被访问，因此采用这种 objective function 就不太可行。\"]},\"509\":{\"h\":\"stationary distribution\",\"t\":[\"stationary: 表示是一种长时间的交互行为\",\"distributon: 表示是 状态 的分布\",\"通常也称为 steady-state distributon or limiting distributon.\",\"describes the long-run behavior of a Markov process. 即基于一个策略，我们不断地与环境进行交互，最终会达到一个平稳的状态，此时可以分析每一个状态在这个策略下的概率。\",\"设 {dπ​(s)}s∈S​ 表示 基于策略 π 下的 stationary distribution。其中 dπ​(s)≥0 且 ∑s∈S​dπ​(s)=1\",\"那么此时的 objective function 可以表示为：\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=s∈S∑​dπ​(s)(vπ​(s)−v^(s,w))2\",\"20240820181406\",\"20240820181718\"]},\"510\":{\"h\":\"2.2 Optimization algorithms 优化算法\",\"t\":[\"目前的优化算法只是在估计给定策略的 statevalue\",\"minisize obejctive function J(w), 采用 梯度下降 算法:\",\"wk+1​=wk​−αk​▽w​J(wk​)\",\"对应目标函数的真实梯度是：\",\"▽w​j(w)​=▽w​E[(vπ​(S)−v^(S,w))2]=E[▽w​(vπ​(S)−v^(S,w))2]=−2E[(vπ​(S)−v^(S,w))▽w​v^(S,w)]​\",\"这里包含了一个 Expection，因此可以考虑 SGD 方法进行求解：\",\"wk+1​=wk​+αk​(vπ​(st​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\",\"其中st​是随机变量S的一个样本。 但这里还有一个难点，vπ​(st​) 我们是无法估计的，这是我们所求的量，因此需要用近似算法来进行替代，从而使得算法可行。\"]},\"511\":{\"h\":\"Monte Carlo learning with function approximation\",\"t\":[\"设 gt​ 表示在一个 episode 中，从状态 st​ 出发的 discounted return。因此我们用 gt​ 来近似 vπ​(st​), 即：\",\"wk+1​=wk​+αk​(gt​−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"512\":{\"h\":\"TD Learning with function approximation\",\"t\":[\"在 TD 算法中，我们将 rt+1​+γv^(st+1​,wt​) 来近似 vπ​(st​), 因此对应算法为：\",\"wk+1​=wk​+αk​(rt+1​+γv^(st+1​,wt​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"513\":{\"h\":\"3. Sarsa with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γq^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"20240820184127\"]},\"514\":{\"h\":\"4. Q-learning with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γa∈A(st+1​)max​q^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"on-policy版本：\",\"20240820184405\"]},\"515\":{\"h\":\"5. Deep Q-learning (DQN)\",\"t\":[\"Deep Q-learning 目的是最小化目标函数(objective/loss function):\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"其中 (S,A,R,S′) 均是随机变量。\"]},\"516\":{\"h\":\"优化方法\",\"t\":[\"采用梯度下降。\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"对于 q^​(S,A,w) 求解梯度还是很好求的。 但对于 maxa∈A(S′)​q^​(S′,a,w) 其求解梯度比较难求，在 DQN 中采用一个 固定 的方法进行解决。 尝试将 y≐R+γmaxa∈A(S′)​q^​(S′,a,w) 中的 w 进行固定求解，具体如下：\",\"引入两个网络：\",\"main network q^​(s,a,w)w 会一直进行更新，根据梯度下降的公式。\",\"target network q^​(s′,a,wT​) 并不是一直进行更新，而是等 main network 更新一定次数后，将该网络的 w 复制到 wT​ 中\",\"将 objective function 修改为：\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))2]\",\"在计算 main network q^​(s,a,w) 的梯度时，将 q^​(S′,a,wT​) 中的 wT​ 固定不动，因此左侧那个类似 TD target 的就不是有关 w 的函数，不用进行求导，从而方便计算。 然后在更新了一定次数之后，在将 wT​=w 进行赋值。\",\"因此对应的损失函数的梯度可以修改为：\",\"▽w​J​=E[−2(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))▽w​q^​(S,A,w)]=E[−2(YT​−q^​(S,A,w))▽w​q^​(S,A,w)]​\",\"一些细节:\",\"w 和 wT​ 表示 the main and target networks 的参数，在初始化的时候是设为相同的。\",\"在每一次迭代时，我们需要从经验池 (the replay buffer) 中取出一定数量的样本 (a mini-batch of samples {(s,a,r,s')}) 进行训练。\",\"网络的输入包括 状态 s 和 动作 a. 在训练求解梯度时，我们先直接求解 target network 的输出，视为 yT​≐r+γmaxa∈A(s′)​q^​(s′,a,wT​)。 然后我们通过 mini-batch 样本 {(s,a,yT​)}, 通过梯度的算法来最小化对应的损失函数, 假设有 N 个样本，那么对应的损失函数求解为：\",\"J(w)=i=1∑N​yT​−q^​(s,a,w) 即可以通过梯度下降，来更新参数值\",\"wt+1​=wt​+αt​N1​i=1∑N​(yT​−q^​(si​,ai​,wt​))⋅▽w​q^​(si​,ai​,wt​)\"]},\"517\":{\"h\":\"经验回放 (replay buffer)\",\"t\":[\"20240820230827\",\"20240820230920\",\"20240820230944\"]},\"518\":{\"h\":\"伪代码\",\"t\":[\"20240820231024\",\"但在发表 DQN 的文章中，不太一样，在原文是 on-policy 且 main network 的输出是不一样的。\",\"20240820231205\"]},\"519\":{\"c\":[\"academic\"]},\"520\":{\"c\":[\"强化学习\"]},\"521\":{\"h\":\"RL9 - 策略梯度法(Policy gradient)\",\"t\":[\"之前介绍的方法都是 value-based 的方法，从这章开始时基于 policy-based 的方法。\",\"policy function approximation 是直接建立一个基于策略的目标函数来进行梯度上升的优化。\"]},\"522\":{\"h\":\"1. 基本思路\",\"t\":[\"将基于表格表示的策略 转换为 基于函数表示的策略。 即此时策略 π 可以描述为：\",\"π(a∣s,θ)\",\"其中，θ∈Rm表示参数向量，是我们需要进行优化的。\",\"当策略是以表格的形式保存时，我们定义最优的策略为 在该策略下的所有 state value 都是最大的。\",\"当策略是以函数的形式存在时，我们定义 最优的策略 为 可以最大化一个确定的常数指标(certain scalar metrics).\",\"Policy gradient 的基本步骤：\",\"确定 metrics/objective function，来定义最优的策略：J(θ)\",\"进行优化，如梯度上升算法\",\"θt+1​=θt​+α▽θ​J(θt​)\"]},\"523\":{\"h\":\"2. 目标函数定义\"},\"524\":{\"h\":\"2.1 average state value\",\"t\":[\"vˉπ​=s∈S∑​d(s)vπ​(s)=dTvπ​\",\"vˉπ​ 显然是 state value 的加权平均。\",\"d(s)≥0 是各个 state 的权重\",\"∑s∈S​d(s)=1, 我们可以认为 d(s) 是 概率分布，因此该指标可以描述为:\",\"vˉπ​=ES∼d​[vπ​(S)]\"]},\"525\":{\"h\":\"另一种表达\",\"t\":[\"J(θ)=E[t=0∑∞​γtRt+1​]\",\"20240826173749\"]},\"526\":{\"h\":\"d(s)的选择\",\"t\":[\"d 与策略 π 无关 这种情况我们将 d 表示为 d0​, vˉπ​ 表示为 vˉπ0​. 这种情况下的 d 可以根据对各个状态的重要程度进行选择： 一种是将所有状态视为同等重要，一种则是有所偏向。\",\"d 与策略 π 有关 d 表示为 dπ​(s), 即在策略 π 下的 stationary distribution。\"]},\"527\":{\"h\":\"2.2 average return value\",\"t\":[\"rˉπ​=s∈S∑​dπ​(s)rπ​(s)=ES∼d​[rπ​(s)]\",\"其中:\",\"rπ​(s)r(s,a)​≐a∈A∑​π(a∣s)r(s,a)=E[R∣s,a]=r∑​rp(r∣s,a)​\",\"rπ​(s)表示在策略π下 状态s时可以得到的平均reward。r(s,a)表示在单步情况下(在状态s采用动作a)时的平均reward。\"]},\"528\":{\"h\":\"另一种表达\",\"t\":[\"假设 agent 跟随一个 给定的策略 然后生成了一个 trajectory以及对应的 rewards (Rt+1​,Rt+2​,…)\",\"对应 average single-step reward along this trajectory is\",\"====​n→∞lim​n1​E[Rt+1​+Rt+2​+⋯+Rt+n​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​]s∑​dπ​(s)rπ​(s)rˉπ​​\"]},\"529\":{\"h\":\"3. 目标函数梯度求解\",\"t\":[\"这里在视频没有详细介绍，只给出了梯度的公式：\",\"▽θ​J(θ)​=s∈S∑​η(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"其中\",\"J(θ) 可以是 vˉπ​,rˉπ​,vˉπ0​ 任何一种。\",\"\\\"=\\\" 有表示 严格等于 近似 以及 成比例等于\",\"η 表示 state 的权重或者分布\",\"具体推导过程:\",\"▽θ​lnπ(a∣s,θ)▽θ​J(θ)​=π(a∣s,θ)▽θ​π(a∣s,θ)​=s∈S∑​d(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=s∈S∑​d(s)a∈A∑​π(a∣s,θ)▽θ​lnπ(a∣s,θ)qπ​(s,a)=ES∼d​[a∑​π(s∣S,θ)▽θ​lnπ(a∣S,θ)qπ​(S,a)]=ES∼d,A∼π​[▽θ​lnπ(A∣S,θ)qπ​(S,A)]≐E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"根据这个式子我们就可以通过 SGD 方法，从而可以进行近似求解：\",\"▽θ​J(θ)≈▽θ​lnπ(a∣s,θ)qπ​(s,a)\",\"一些特性 这里的策略是随机性 的，因为我们需要计算的是 lnπ(a∣s,θ), 因此我们需要保证对于所有的 s,a,θ\",\"π(a∣s,θ)≥0\",\"20240826180244\"]},\"530\":{\"h\":\"4. REINFORCE 梯度上升算法\",\"t\":[\"梯度上升算法的本质就是最大化目标函数 J(θ)\",\"θt+1​​=θt​+α▽θ​J(θ)=θt​+αE[▽θ​lnπ(A∣S,θt​)qπ​(S,A)]​\",\"而对应的真实梯度可以用一个估计的梯度来替代:\",\"θt+1​=θt​+α▽θ​lnπ(at​∣st​,θt​)qπ​(s,a)\",\"但还存在 qπ​(s,a) 是未知的，我们也可以进行近似：\",\"θt+1​=θt​+α▽θ​lnπ(a∣s,θt​)qt​(st​,at​)\",\"这里可以用不同的方法来近似 qπ​(s,a).\",\"Monte-Carlo based method， 我们便称为 REINFORCE\",\"也可以采用基于 TD 的算法 或者 其他的算法。\",\"一些细节\",\"20240826181340\",\"20240826181538\",\"20240826181638\"]},\"531\":{\"h\":\"REINFORCE 算法\",\"t\":[\"20240826181712\"]},\"532\":{\"c\":[\"academic\"]},\"533\":{\"c\":[\"强化学习\"]},\"534\":{\"h\":\"javaweb - Socket1\"},\"535\":{\"h\":\"Socket\",\"t\":[\"通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。\"]},\"536\":{\"h\":\"socket 连接示例\",\"t\":[\"//服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); //由于继承了Autocloseble 省略 socket.close() }catch (IOException e){ e.printStackTrace(); } } \",\"//客户端 public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ System.out.println(\\\"已连接到服务端！\\\"); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } \",\"实际上它就是一个TCP连接的建立过程：\",\"20250319235934\",\"一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } \"]},\"537\":{\"h\":\"使用Socket进行数据传输\",\"t\":[\"通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：\",\"注意：\",\"如果服务端是 Socket socket = server.accept(); 最后需要 socket.close 不然会报错\",\"如果接收端读取的是 reader.readLine(), 注意需要添加 \\\\n，writer.write(text+ \\\"\\\\n\\\");, writer不会主动加 \\\\n\",\"OutputStream 是把东西先到对应的流里 InputStream 是获取对应流的内容\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080) ){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.print(\\\"接收到客户端数据：\\\"); System.out.println(reader.readLine()); //向客户端发请求 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"receiver!\\\"); writer.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080); Scanner scanner = new Scanner(System.in); ){ System.out.println(\\\"已连接到服务端！\\\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); System.out.println(\\\"请输入要发送给服务端的内容：\\\"); String text = scanner.nextLine(); writer.write(text+ \\\"\\\\n\\\"); writer.flush(); System.out.println(\\\"数据已发送：\\\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\\\"收到服务器返回：\\\"+reader.readLine()); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"538\":{\"h\":\"杂项\",\"t\":[\"我们可以手动关闭单向的流：\",\"socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 \",\"如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间：\",\" socket.setSoTimeout(3000); \",\"当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：\",\" java.net.SocketTimeoutException: Read timed out \",\"我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接 connect 方法，调用无参构造方法不会自动连接。\",\"try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\\\"localhost\\\", 8080), 1000); //手动调用connect方法进行连接 } \",\"如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生：\",\"socket.setKeepAlive(true); \",\"当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。\",\"TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：\",\" socket.setReceiveBufferSize(25565); //TCP接收缓冲区 socket.setSendBufferSize(25565); //TCP发送缓冲区 \"]},\"539\":{\"c\":[\"code\"]},\"540\":{\"c\":[\"javaweb\"]},\"541\":{\"h\":\"javaweb - Socket2\"},\"542\":{\"h\":\"Socket2\"},\"543\":{\"h\":\"Socket 传输文件\",\"t\":[\"其实本质上都差不多，主要掌握几种流之间的操作，和 socket 的用法\",\"一般 xxxOutputStream 的操作是往对应的xxx流内写入一些东西；xxxInputStream 的操作是从对应的xxx流内获取一些东西。\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080); FileOutputStream fileOutputStream = new FileOutputStream(\\\"net/data.txt\\\"); ){ Socket socket = server.accept(); InputStream inputstream = socket.getInputStream(); byte[] bytes = new byte[1024]; int i; while((i = inputstream.read(bytes)) != -1){ fileOutputStream.write(bytes); } fileOutputStream.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ FileInputStream fileInputStream = new FileInputStream(\\\"1.txt\\\"); OutputStream stream = socket.getOutputStream(); byte[] bytes = new byte[1024]; int i; while((i = fileInputStream.read(bytes)) != -1){ stream.write(bytes, 0, i); } stream.flush(); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"544\":{\"h\":\"使用浏览器访问Socket服务器\",\"t\":[\"Http请求是基于TCP协议，不会保持长久连接，在收到响应的数据后会立即关闭TCP连接。\",\"尝试自己写的http相应时，要保持服务器一直在线，不能一个socket之后就done了，因为浏览器访问时会不止发一个请求，所以如果没有始终在线，浏览器会显示无法访问。\",\"查看浏览器发起的请求\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\\\"接收到客户端数据：\\\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } \",\"通过访问 http://localhost:8080 或是 http://127.0.0.1:8080, 来连接我们本地端口的服务器。\",\"我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：\",\"GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: keep-alive Cache-Control: max-age=0 sec-ch-ua: \\\"Chromium\\\";v=\\\"94\\\", \\\"Google Chrome\\\";v=\\\"94\\\", \\\";Not A Brand\\\";v=\\\"99\\\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \\\"macOS\\\" Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 \",\"实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。\",\"既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：\",\"HTTP/1.1 200 Accpeted \",\"然后就是响应内容（注意一定要换行再写），对应支持HTTP协议的响应内容：\",\"public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ // 必须加 while(true) 因为浏览器不止发一个请求 while(true){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"HTTP/1.1 200 Accepted\\\\r\\\\n\\\"); writer.write(\\\"\\\\r\\\\n\\\"); writer.write(\\\"Penguin!\\\"); writer.flush(); socket.close(); } }catch (Exception e){ e.printStackTrace(); } } } \"]},\"545\":{\"c\":[\"code\"]},\"546\":{\"c\":[\"javaweb\"]},\"547\":{\"h\":\"javaweb - 数据库1\"},\"548\":{\"h\":\"数据库 1\"},\"549\":{\"h\":\"简介\",\"t\":[\"数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。\",\"常见的数据库有很多种，包括但不限于：\",\"MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统\"]},\"550\":{\"h\":\"数据模型\",\"t\":[\"数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：\",\"属性不可再分\",\"一个实体的属性可以有很多个\",\"用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的\",\"属性取值可以有一定的约束，比如性别只能是男或是女\",\"实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。\",\"通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。\",\"1\"]},\"551\":{\"h\":\"数据库创建\",\"t\":[\"既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：\",\"学生表：用于存放所有学生的数据，学生（学号，姓名，性别）\",\"教师表：用于存放所有教师的数据，教师（教师号，姓名）\",\"授课表：用于存放教师与学生的授课信息，授课（学号，教师号）\",\"其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。\"]},\"552\":{\"h\":\"数据库的规范化\",\"t\":[\"要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。\",\"1NF对表中每一列进行约束，2NF对主属性和其他属性的依赖关系产生约束，3NF对依赖关系进一步加强，BCNF则是对主键的选取进行唯一确定\"]},\"553\":{\"h\":\"第一范式（1NF）\",\"t\":[\"第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：\",\"学生（姓名，电话号码）\",\"电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为：\",\"学生（姓名，座机号码，手机号码）\",\"满足第一范式是关系型数据库最基本的要求！\"]},\"554\":{\"h\":\"第二范式（2NF）\",\"t\":[\"第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：\",\"学生（学号，姓名，性别）\",\"学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。\"]},\"555\":{\"h\":\"第三范式（3NF）\",\"t\":[\"在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。\",\"学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）\",\"实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：\",\"学生借书情况（借阅编号，学生学号，书籍编号）\",\"书籍（书籍编号，书籍名称，书籍作者）\",\"这样就消除了传递依赖，从而满足第三范式。\"]},\"556\":{\"h\":\"BCNF\",\"t\":[\"BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：\",\"(仓库ID, 存储物品ID) →(管理员ID, 数量)\",\"(管理员ID, 存储物品ID) → (仓库ID, 数量)\",\"所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：\",\"(仓库ID) → (管理员ID)\",\"(管理员ID) → (仓库ID)\",\"即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。\"]},\"557\":{\"c\":[\"code\"]},\"558\":{\"c\":[\"javaweb\",\"mysql\"]},\"559\":{\"h\":\"javaweb - 数据库2\"},\"560\":{\"h\":\"数据库 2\"},\"561\":{\"h\":\"SQL 语句\",\"t\":[\"结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。\",\"SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！\",\"SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。\",\"我们要学习的就是以下四种类型的SQL语言：\",\"数据查询语言（Data Query Language, DQL） 基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。\",\"数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集， 以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。\",\"数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。\",\"DCL（Data Control Language）是数据库控制语言。 是用来设置或更改数据库用户或角色权限的语句 包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。\",\"我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）\"]},\"562\":{\"h\":\"数据库定义语言（DDL）\"},\"563\":{\"h\":\"SQL数据类型\",\"t\":[\"以下的数据类型用于字符串存储：\",\"char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。\",\"varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。\",\"以下数据类型用于存储数字：\",\"smallint用于存储小的整数，范围在 (-32768，32767)\",\"int用于存储一般的整数，范围在 (-2147483648，2147483647)\",\"bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)\",\"float用于存储单精度小数\",\"double用于存储双精度的小数\",\"以下数据类型用于存储时间：\",\"date存储日期\",\"time存储时间\",\"year存储年份\",\"datetime用于混合存储日期+时间\"]},\"564\":{\"h\":\"列级约束条件\",\"t\":[\"列级约束有六种：\",\"主键 Primary key 确保列中的每个值都是唯一的，并且不能为空。一个表只能有一个主键，主键列的值用来唯一标识每一行数据。在主键列中，不允许有重复的值和空值。\",\"id INT PRIMARY KEY 表示 id 列是主键，且不能为空且唯一。\",\"外键 foreign key 用于建立和维护两表之间的关系，确保列中的值必须存在于另一表的主键或唯一约束列中。它保证数据的参照完整性。即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值。\",\"FOREIGN KEY (department_id) REFERENCES departments(id)，表示 department_id 列是外键，参照 departments 表的 id 列。\",\"唯一 unique 确保列中的每个值都是唯一的，但允许空值。与主键类似，唯一约束保证列中所有的非空数据都是唯一的。一个表可以有多个唯一约束，不同于主键，唯一约束允许有空值。\",\"email VARCHAR(255) UNIQUE 表示 email 列的值是唯一的。\",\"检查 check （MySQL不支持） 用于定义列的值必须满足某些条件。检查约束通常用于限制某些特定的数值范围或模式。\",\"age INT CHECK (age >= 18)，表示 age 列的值必须大于或等于 18。\",\"默认 default 用于为列指定默认值。如果在插入数据时没有为该列提供值，则会使用默认值。默认值仅在插入数据时使用，如果插入时该列有明确值，则默认值不会生效。\",\"status VARCHAR(10) DEFAULT 'active'，表示 status 列在未指定值时默认值为 'active'。\",\"非空/空值 not null/ null 用于定义列是否可以为空。NOT NULL 约束要求该列的每一行必须有一个非空值，而 NULL 允许列中的某些行没有值。\",\"name VARCHAR(100) NOT NULL 表示 name 列不能为 NULL，每一行必须有值。\"]},\"565\":{\"h\":\"表级约束条件\",\"t\":[\"表级约束有四种：主键、外键、唯一、检查\",\"主键 主键约束保证表中的每一行数据都有唯一的标识符，且该列的值不能为空。一个表只能有一个主键。\",\"CONSTRAINT pk_primary_key PRIMARY KEY (id)\",\"外键 外键约束用于在两个表之间建立参照完整性关系，确保某列的值必须存在于另一表的主键或唯一约束列中。\",\"CREATE TABLE Departments ( DepartmentID INT, DepartmentName VARCHAR(50) NOT NULL, Location VARCHAR(50), ManagerID INT, Budget DECIMAL(10, 2), CONSTRAINT PK_Departments PRIMARY KEY (DepartmentID), CONSTRAINT UC_DepartmentName UNIQUE (DepartmentName), CONSTRAINT CK_BudgetPositive CHECK (Budget >= 0), CONSTRAINT FK_Manager FOREIGN KEY (ManagerID) REFERENCES Employees(EmployeeID), CONSTRAINT DF_Location DEFAULT 'Headquarters' FOR Location ); \"]},\"566\":{\"h\":\"数据库操作\",\"t\":[\"我们可以通过create database来创建一个数据库：\",\"CREATE DATABASE 数据库名 \",\"为了能够支持中文，我们在创建时可以设定编码格式：\",\"CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; \",\"如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库：\",\"DROP DATABASE 数据库名 \"]},\"567\":{\"h\":\"创建表\",\"t\":[\"在创建表之前，一定要先切换到我们要创建表的数据库内 use xxxx;，默认并不是你创建的数据库。\",\"数据库创建完成后，我们一般通过create table语句来创建一张表：\",\"create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) \"]},\"568\":{\"h\":\"修改表\",\"t\":[\"如果我们想修改表结构，我们可以通过alter table来进行修改：\",\"ALTER TABLE 表名 [ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] \",\"我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。\"]},\"569\":{\"h\":\"删除表\",\"t\":[\"我们可以通过drop table来删除一个表：\",\"DROP TABLE 表名[restrict|cascade] \",\"其中restrict和cascade上面的效果一致。\"]},\"570\":{\"h\":\"数据库操纵语言 (DML)\"},\"571\":{\"h\":\"插入数据\",\"t\":[\"通过使用insert into语句来向数据库中插入一条数据（一条记录）：\",\"INSERT INTO 表名 VALUES(值1, 值2, 值3) \",\"如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) \",\"我们也可以一次性向数据库中插入多条数据：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) \",\"我们来试试看向我们刚刚创建的表中添加三条数据。\"]},\"572\":{\"h\":\"修改数据\",\"t\":[\"我们可以通过update语句来更新表中的数据：\",\"UPDATE 表名 SET 列名=值,... WHERE 条件 \",\"注意，SQL语句中的等于判断是=\",\"警告： 如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！\"]},\"573\":{\"h\":\"删除数据\",\"t\":[\"我们可以通过使用delete来删除表中的数据：\",\"DELETE FROM 表名 \",\"通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据：\",\"DELETE FROM 表名 WHERE 条件 \"]},\"574\":{\"c\":[\"code\"]},\"575\":{\"c\":[\"javaweb\",\"mysql\"]},\"576\":{\"h\":\"javaweb - 数据库3\"},\"577\":{\"h\":\"数据库 3\"},\"578\":{\"h\":\"数据库查询语言 (DQL)\"},\"579\":{\"h\":\"单表查询\",\"t\":[\"单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询：\",\"-- 指定查询某一列数据 SELECT 列名[,列名] FROM 表名 -- 会以别名显示此列 SELECT 列名 别名 FROM 表名 -- 查询所有的列数据 SELECT * FROM 表名 -- 只查询不重复的值 SELECT DISTINCT 列名 FROM 表名 \",\"我们也可以添加where字句来限定查询目标：\",\"SELECT * FROM 表名 WHERE 条件 \"]},\"580\":{\"h\":\"常用 查询条件\",\"t\":[\"一般的比较运算符，包括=、>、<、>=、<=、!=等。\",\"是否在集合中：in、not in\",\"字符模糊匹配：like，not like % 表示任意内容 比如 03% 表示03开头\",\"多重条件连接查询：and、or、not\"]},\"581\":{\"h\":\"排序查询\",\"t\":[\"我们可以通过order by来将查询结果进行排序：\",\"SELECT * FROM 表名 ORDER BY 列名 ASC|DESC \",\"使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。\",\"我们也可以可以同时添加多个排序：\",\"SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC \",\"这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。\"]},\"582\":{\"h\":\"聚集函数\",\"t\":[\"聚集函数一般用作统计，包括：\",\"count([distinct]*)统计所有的行数（distinct表示去重再统计，下同）\",\"count([distinct]列名)统计某列的值总和\",\"sum([distinct]列名)求一列的和（注意必须是数字类型的）\",\"avg([distinct]列名)求一列的平均值（注意必须是数字类型）\",\"max([distinct]列名)求一列的最大值\",\"min([distinct]列名)求一列的最小值\",\"一般聚集函数是这样使用的：\",\"SELECT count(distinct 列名) FROM 表名 WHERE 条件 \"]},\"583\":{\"h\":\"分组和分页查询\",\"t\":[\"通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 \",\"我们还可以添加having来限制分组条件：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 \",\"我们可以通过limit来限制查询的数量，只取前n个结果：\",\"SELECT * FROM 表名 LIMIT 数量 \",\"我们也可以进行分页：\",\"SELECT * FROM 表名 LIMIT 起始位置,数量 \"]},\"584\":{\"h\":\"多表查询\",\"t\":[\"多表查询是同时查询的两个或两个以上的表，多表查询会通过连接转换为单表查询。\",\"SELECT * FROM 表1, 表2 \",\"直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。\",\"SELECT * FROM 表1, 表2 WHERE 条件 \",\"这样，只会从笛卡尔积的结果中得到满足条件的数据。\",\"注意： 如果两个表中都带有此属性，需要添加表名前缀来指明是哪一个表的数据。比如 select * from a1, a2 where a1.xxx;\"]},\"585\":{\"h\":\"自身连接查询\",\"t\":[\"自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：\",\"SELECT * FROM 表名 别名1, 表名 别名2 \",\"其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。\"]},\"586\":{\"h\":\"外连接查询\",\"t\":[\"可以叠着使用\",\"外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：\",\"通过使用inner join xxx on进行内连接 只会返回两个表满足条件的交集部分： select * from student inner join teach on student.sid = teach.sid;\",\"通过使用left join xxx on进行左连接 不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： select * from student left join teach on student.sid = teach.sid;\",\"右连接类似 right join xxx on\"]},\"587\":{\"h\":\"嵌套查询\",\"t\":[\"我们可以将查询的结果作为另一个查询的条件，比如：\",\"SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) \",\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。\"]},\"588\":{\"h\":\"数据库控制语言（DCL）\",\"t\":[\"庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。\"]},\"589\":{\"h\":\"创建用户\",\"t\":[\"我们可以通过create user来创建用户：\",\"CREATE USER 用户名 identified by 密码; \",\"也可以不带密码：\",\"CREATE USER 用户名; \",\"我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。\"]},\"590\":{\"h\":\"登陆用户\",\"t\":[\"首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：\",\"login -u 用户名 -p \",\"输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：\",\"show databases; \",\"我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！\"]},\"591\":{\"h\":\"用户授权\",\"t\":[\"我们可以通过使用grant来为一个数据库用户进行授权：\",\"grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] \",\"其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。\",\"我们可以使用revoke来收回一个权限：\",\"revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 \"]},\"592\":{\"c\":[\"code\"]},\"593\":{\"c\":[\"javaweb\",\"mysql\"]},\"594\":{\"h\":\"javaweb - 数据库4\"},\"595\":{\"h\":\"数据库 4\"},\"596\":{\"h\":\"视图\",\"t\":[\"视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。\",\"既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 对视图的修改就是对基本表的修改，相当于一个指针。\",\"我们可以通过create view来创建视图;\",\"CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; \",\"WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。\",\"若视图是由两个以上基本表导出的，则此视图不允许更新。\",\"若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。\",\"若视图的字段来自集函数，则此视图不允许更新。\",\"若视图定义中含有GROUP BY子句，则此视图不允许更新。\",\"若视图定义中含有DISTINCT短语，则此视图不允许更新。\",\"若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade > (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。\",\"一个不允许更新的视图上定义的视图也不允许更新\",\"通过drop来删除一个视图：\",\"drop view apptest \"]},\"597\":{\"h\":\"索引\",\"t\":[\"在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：\",\"-- 创建索引 CREATE INDEX 索引名称 ON 表名 (列名) -- 查看表中的索引 show INDEX FROM student \",\"索引类型包括：NORMAL, UNIQUE, FULLTEST, SPATIAL\",\"索引方法：BTREE, HASH\",\"我们也可以通过下面的命令删除一个索引：\",\"drop index 索引名称 on 表名 \",\"虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。\"]},\"598\":{\"h\":\"触发器\",\"t\":[\"触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。\",\"触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）\",\"比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。\",\"CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno \",\"FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！\",\"通过下面的命令来查看触发器：\",\"SHOW TRIGGERS \",\"如果不需要，我们就可以删除此触发器：\",\"DROP TRIGGER 触发器名称 \"]},\"599\":{\"h\":\"事务\",\"t\":[\"当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：\",\"SHOW ENGINES; \",\"MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。\",\"事务具有以下特性：\",\"原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\",\"一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\",\"隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\",\"持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\",\"类似 git 的操作？开启事务只有当commit后才能在真正的数据库里看到\",\"我们通过以下例子来探究以下事务：\",\"begin; #开始事务 ... rollback; #回滚事务 savepoint 回滚点; #添加回滚点 rollback to 回滚点; #回滚到指定回滚点 ... commit; #提交事务 -- 一旦提交，就无法再进行回滚了！ \",\"函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。\"]},\"600\":{\"c\":[\"code\"]},\"601\":{\"c\":[\"javaweb\",\"mysql\"]},\"602\":{\"h\":\"javaweb - JAVA与数据库1\"},\"603\":{\"h\":\"主要内容\",\"t\":[\"通过Java如何去使用数据库来帮助我们存储数据\"]},\"604\":{\"h\":\"JDBC\",\"t\":[\"JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。\",\"我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。\"]},\"605\":{\"h\":\"使用JDBC连接数据库\",\"t\":[\"//注意前两步都放在try()中，因为在最后需要释放资源！ //1. 通过DriverManager来获得数据库连接 try (Connection connection = DriverManager.getConnection( \\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement() ){ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\\\"select * from student\\\"); //4. 查看结果 while (set.next()){ System.out.println(set.getString(1)); } }catch (SQLException e){ e.printStackTrace(); } //5. 释放资源，try-with-resource语法会自动帮助我们close \",\"其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序）\",\"注意： 6.0版本以上，不用手动加载驱动，我们直接使用即可！ 即不需要使用 反射 来加载驱动类\",\"Class.forName(\\\"com.mysql.jdbc.Driver\\\") \",\"如果加载会提示\",\"Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. \"]},\"606\":{\"h\":\"DriverManager\",\"t\":[\"DriverManager是管理我们的数据库驱动的, 来分析我们设定的驱动是否可以连接，如果成功就返回对应的 connection\",\"public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\\\"registerDriver: \\\" + driver); } \",\"private static Connection getConnection( String url, java.util.Properties info, Class<?> caller) throws SQLException { /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) { // synchronize loading of the correct classloader. if (callerCL == null) { callerCL = Thread.currentThread().getContextClassLoader(); } } if(url == null) { throw new SQLException(\\\"The url cannot be null\\\", \\\"08001\\\"); } println(\\\"DriverManager.getConnection(\\\\\\\"\\\" + url + \\\"\\\\\\\")\\\"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) { // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) { try { println(\\\" trying \\\" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! println(\\\"getConnection returning \\\" + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { println(\\\" skipping: \\\" + aDriver.getClass().getName()); } } // if we got here nobody could connect. if (reason != null) { println(\\\"getConnection failed: \\\" + reason); throw reason; } println(\\\"getConnection: no suitable driver found for \\\"+ url); throw new SQLException(\\\"No suitable driver found for \\\"+ url, \\\"08001\\\"); } \",\"我们可以通过调用getConnection()来进行数据库的链接：\",\"@CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\\\"user\\\", user); } if (password != null) { info.put(\\\"password\\\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } \",\"我们可以手动为驱动管理器添加一个日志打印：\",\"static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } \",\"现在我们执行的数据库操作日志会在控制台实时打印。\"]},\"607\":{\"h\":\"了解Connection\",\"t\":[\"Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句：\",\"Statement createStatement() throws SQLException; \",\"我们发现除了普通的Statement，还存在PreparedStatement：\",\"PreparedStatement prepareStatement(String sql) throws SQLException; \",\"在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。\",\"它还支持事务的处理，也放到后面来详细进行讲解。\"]},\"608\":{\"h\":\"了解Statement\",\"t\":[\"我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！\",\"Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。\",\"也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。\",\"6\"]},\"609\":{\"c\":[\"code\"]},\"610\":{\"c\":[\"javaweb\",\"mysql\"]},\"611\":{\"h\":\"javaweb - JAVA与数据库2\"},\"612\":{\"h\":\"JDBC\"},\"613\":{\"h\":\"执行DML操作\",\"t\":[\"删除、更新、添加\",\"import java.io.PrintWriter; import java.sql.*; public class Main { public static void main(String[] args) { try ( Connection connection = DriverManager.getConnection(\\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); Statement statement = connection.createStatement(); ){ int i = statement.executeUpdate(\\\"insert into student values(4,'monkey','男')\\\"); // statement.executeUpdate(\\\"delete from student where sid = 4\\\"); // int i = statement.executeUpdate(\\\"update student set name = 'dog' where sid=3\\\"); System.out.println(\\\"生效了：\\\"+i+\\\"行\\\"); } catch (SQLException e) { throw new RuntimeException(e); } } } \"]},\"614\":{\"h\":\"执行DQL操作\",\"t\":[\"执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 一开始是在第一行上面，可以理解在标题栏\",\"//首先要明确，select返回的数据类似于一个excel表格 while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行 } \",\"我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。\",\"7\"]},\"615\":{\"h\":\"执行批处理操作\",\"t\":[\"当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\\\"insert into user values ('f', 1234)\\\"); statement.addBatch(\\\"insert into user values ('e', 1234)\\\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); } } \"]},\"616\":{\"h\":\"将查询结果映射为对象\",\"t\":[\"既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类：\",\"public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\\\"我叫：\\\"+name+\\\"，学号为：\\\"+sid+\\\"，我的性别是：\\\"+sex); } } \",\"现在我们来进行一个转换：\",\"while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say(); } \",\"注意： 列的下标是从1开始的。\",\"我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射：\",\"private static <T> T convert(ResultSet set, Class<T> clazz){ try { Constructor<T> constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class<?>[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i < param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\\\"错误的类型转换：\\\"+object[i].getClass()+\\\" -> \\\"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; } } \",\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了：\",\"while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say(); } \",\"实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。\"]},\"617\":{\"c\":[\"code\"]},\"618\":{\"c\":[\"javaweb\",\"mysql\"]},\"619\":{\"h\":\"javaweb - JAVA与数据库3\"},\"620\":{\"h\":\"JDBC\"},\"621\":{\"h\":\"实现登陆与SQL注入攻击\",\"t\":[\"在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写：\",\"try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\\\"select * from user where username='\\\"+scanner.nextLine()+\\\"'and pwd='\\\"+scanner.nextLine()+\\\"';\\\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } \",\"用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢：\",\"Test 1111' or 1=1; -- # Test 登陆成功！ \",\"1=1一定是true，那么我们原本的SQL语句会变为：\",\"select * from user where username='Test' and pwd='1111' or 1=1; -- ' \",\"我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。\"]},\"622\":{\"h\":\"使用\",\"t\":[\"我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); PreparedStatement statement = connection.prepareStatement(\\\"select * from user where username= ? and pwd=?;\\\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } } \",\"我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么：\",\"com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- '; \",\"我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！\"]},\"623\":{\"h\":\"管理事务\",\"t\":[\"JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false)方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。\",\"con.setAutoCommit(); //关闭自动提交后相当于开启事务。 // SQL语句 // SQL语句 // SQL语句 con.commit();或 con.rollback(); \",\"一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); } } \",\"我们来接着尝试一下使用回滚操作：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"同样的，我们也可以去创建一个回滚点来实现定点回滚：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\\\"insert into user values ('d', 1234)\\\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } } \"]},\"624\":{\"c\":[\"code\"]},\"625\":{\"c\":[\"javaweb\",\"mysql\"]},\"626\":{\"h\":\"javaweb - Lombok1\"},\"627\":{\"h\":\"Lombok1\",\"t\":[\"我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！\",\"通过使用 Lombok（小辣椒）就可以解决这样的问题！\",\"img\",\"使用原生方式和小辣椒方式编写类的区别，首先是传统方式：\",\"public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } \",\"而使用Lombok之后：\",\"@Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } \",\"我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！\"]},\"628\":{\"h\":\"配置Lombok\",\"t\":[\"首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download\",\"然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。\",\"重启IDEA\",\"Lombok 是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理(编译阶段处理)。\",\"Java的编译过程可以分成三个阶段： \",\"所有源文件会被解析成语法树。\",\"调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。\",\"最后，语法树会被分析并转化成类文件。\",\"实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。\"]},\"629\":{\"h\":\"使用Lombok\",\"t\":[\"我们通过实战来演示一下Lombok的实用注解：\",\"我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。\",\"我们还可以使用@Accessors来控制生成Getter和Setter的样式。\",\"我们通过添加@ToString来为当前类生成预设的toString方法。\",\"我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。\",\"我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。\",\"我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。\",\"使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。\",\"一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。\",\"使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。\",\"使用@SneakyThrows来自动生成try-catch代码块。\",\"使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换）\",\"使用@Builder来快速生成建造者模式。\",\"通过使用@Builder.Default来指定默认值。\",\"通过使用@Builder.ObtainVia来指定默认值的获取方式。\"]},\"630\":{\"c\":[\"code\"]},\"631\":{\"c\":[\"javaweb\",\"Lombok\"]},\"632\":{\"h\":\"javaweb - Mybatis1\"},\"633\":{\"h\":\"Mybatis1\",\"t\":[\"在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。\",\"再次强调： 学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。\",\"image-20230306163528771\",\"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。\"]},\"634\":{\"h\":\"XML语言\",\"t\":[\"在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <outer> <name>阿伟</name> <desc>怎么又在玩电动啊</desc> <inner type=\\\"1\\\"> <age>10</age> <sex>男</sex> </inner> </outer> \",\"HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。\",\"一个XML文件存在以下的格式规范：\",\"必须存在一个根节点，将所有的子标签全部包含。\",\"可以但不必须包含一个头部声明（主要是可以设定编码格式）\",\"所有的标签必须成对出现，可以嵌套但不能交叉嵌套\",\"区分大小写。\",\"标签中可以存在属性，比如上面的type=\\\"1\\\"就是inner标签的一个属性，属性的值由单引号或双引号包括。\",\"XML文件也可以使用注释：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!-- 注释内容 --> \",\"通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件）\"]},\"635\":{\"h\":\"转义字符\",\"t\":[\"image-20230306163528771\",\"如果嫌一个一个改太麻烦，也可以使用CDATA <![CDATA[ xxxxx ] 来快速创建不解析区域：\",\"<test> <name><![CDATA[我看你<><><>是一点都不懂哦>>>]]></name> </test> \"]},\"636\":{\"h\":\"解析XML文件\",\"t\":[\"如何将定义好的XML文件读取到Java程序中\",\"JDK为我们内置了一个叫做org.w3c的XML解析库：\",\"// 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\\\"file:mappers/test.xml\\\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\\\"test\\\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 // 节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i < childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \\\"：\\\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本 // （内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } \",\"当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的）\",\"不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！\"]},\"637\":{\"c\":[\"code\"]},\"638\":{\"c\":[\"javaweb\",\"mybatis\"]},\"639\":{\"h\":\"javaweb - Mybatis2\"},\"640\":{\"h\":\"Mybatis2\"},\"641\":{\"h\":\"初次使用 Mybatis\",\"t\":[\"文档网站：https://mybatis.org/mybatis-3/zh_CN/configuration.html\",\"我们需要导入Mybatis的依赖，依赖导入完成后，编写Mybatis的配置文件(通过一个XML文件去配置)\",\"按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <!-- 对应哪个数据库的JDBC驱动 com.mysql.cj.jdbc.Driver --> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容）\",\"通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了 （也可以不使用配置文件，自行阅读官方文档）\",\"配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象：\",\"public static void main(String[] args) throws FileNotFoundException { String resource = \\\"mybatis-config.xml\\\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try(SqlSession s = sqlSessionFactory.openSession(true)){ } } \",\"直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！\"]},\"642\":{\"h\":\"\",\"t\":[\"那么现在我们来看看，SqlSessionFactory对象是什么东西：\",\"每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话 —— SqlSession对象，\",\"每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。\",\"而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。\"]},\"643\":{\"h\":\"直接读取实体类\",\"t\":[\"我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段\",\"在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。\",\"首先编写实体类，直接使用Lombok：\",\"import lombok.Data; @Data public class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex; } \",\"在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"com.test.entity.Student\\\"> select * from student </select> </mapper> \",\"其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。\",\"我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。\",\"编写好后，我们在配置文件中添加这个Mapper映射器：\",\"<mappers> <mapper url=\\\"file:mappers/TestMapper.xml\\\"/> <!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --> </mappers> \",\"最后在程序中使用我们定义好的Mapper即可：\",\"public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \",\"我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！\"]},\"644\":{\"c\":[\"code\"]},\"645\":{\"c\":[\"javaweb\",\"mybatis\"]},\"646\":{\"h\":\"javaweb - Mybatis3\"},\"647\":{\"h\":\"Mybatis详解1\",\"t\":[\"由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些：\",\"public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } \",\"现在我们只需要在main方法中这样写即可查询结果了：\",\"public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \"]},\"648\":{\"h\":\"查询操作\",\"t\":[\"XML配置sql操作\",\"对应java进行调用\",\"查询操作在XML配置中使用一个select标签进行囊括\",\"假设我们现在需要编写一个根据ID查询用户的操作，首先我们需要指定select操作的id：\",\"<select id=\\\"selectUserById\\\"> </select> \",\"接着是我们需要进行查询的参数，这里我们需要根据用户ID查询，那么传入的参数就是一个int类型的参数，参数也可以是字符串类型的，类型名称：\",\"如果是基本类型，需要使用_int这样前面添加下划线。\",\"如果是JDK内置的包装类型或是其他类型，可以直接使用其名称，比如String、int（Integer的缩写）、Long\",\"如果是自己编写的类型，需要完整的包名+类名才可以。\",\"当然也可以直接不填这个属性，Mybatis会自动判断：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> </select> \",\"接下来就是编写我们的SQL语句了，由于这里我们需要通过一个参数来查询，所以需要填入一个占位符，通过使用#{xxx}或是${xxx}来填入我们给定的属性，名称随便：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> select * from user where id = #{id} </select> \",\"实际上Mybatis也是通过PreparedStatement首先进行一次预编译，来有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此对于常见的一些查询参数，我们一般都使用#{xxx}来进行操作保证安全性。\",\"最后我们查询到结果后，一般都是将其转换为对应的实体类对象，所以说这里我们之间填写之前建好的实体类名称，使用resultType属性来指定：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"649\":{\"h\":\"别名\",\"t\":[\"当然，如果你觉得像这样每次都要写一个完整的类名太累了，也可以为它起个别名，我们只需要在Mybatis的配置文件中进行编写即可：\",\"<typeAliases> <typeAlias type=\\\"com.test.User\\\" alias=\\\"User\\\"/> </typeAliases> \",\"也可以直接扫描整个包下的所有实体类，自动起别名，默认情况下别名就是类的名称：\",\"<typeAliases> <package name=\\\"com.test.entity\\\"/> </typeAliases> \",\"这样，SQL语句映射配置我们就编写好了，接着就是Java这边进行调用了：\",\"//这里我们填写刚刚的id，然后将我们的参数填写到后面 User user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"650\":{\"h\":\"hashmap 转换\",\"t\":[\"当然，如果你不需要转换为实体类，Mybatis也为我们提供了多种转换方案，比如转换为一个Map对象：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} </select> \",\"//使用Map类型变量进行接受，Key为String类型，Value为Object类型 Map<String, Object> user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"651\":{\"h\":\"多参数查询\",\"t\":[\"我们可以尝试接着来写一个同时查询ID和年龄的查询操作：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"因为这里需要多个参数，我们可以使用一个Map (Map.of是JAVA9的特性)或是具有同样参数的实体类来传递，显然Map用起来更便捷一些，注意key的名称需要与我们编写的SQL语句中占位符一致：\",\"User user = session.selectOne(\\\"selectUserByIdAndAge\\\", Map.of(\\\"id\\\", 1, \\\"age\\\", 18)); System.out.println(user); \"]},\"652\":{\"h\":\"\",\"t\":[\"下面这种情况，实体类中定义的属性名称和我们数据库中的名称不一样\",\"这会导致Mybatis自动处理出现问题：\",\"@Data public class User { int uid; String username; int age; } \",\"运行后发现，Mybatis虽然可以查询到对应的记录，但是转换的实体类数据并没有被添加上去，这是因为数据库字段名称与类中字段名称不匹配导致的，我们可以手动配一个resultMap来解决这种问题，直接在Mapper中添加：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultMap=\\\"user\\\"> select * from user where id = #{id} and age = #{age} </select> <resultMap id=\\\"user\\\" type=\\\"com.test.User\\\"> <!-- 因为id为主键，这里也可以使用<id>标签，有助于提高性能 --> <result column=\\\"id\\\" property=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"column 对应数据库字段名\",\"property 对应实体类属性名\",\"这里我们在resultMap标签中配置了一些result标签，每一个result标签都可以配置数据库字段和类属性的对应关系，这样Mybatis就可以按照我们的配置来正确找到对应的位置并赋值了，没有手动配置的字段会按照之前默认的方式进行赋值。\",\"配置完成后，最终只需要将resultType改为resultMap并指定对应id即可，然后就能够正确查询了。\",\"这里有一个RowBounds参数，用于实现分页效果，但是其分页功能是对查询到的数据进行划分，非常鸡肋，这里不进行介绍，了解即可。\"]},\"653\":{\"h\":\"查询列表操作\",\"t\":[\"我们再来尝试编写一下查询一个列表，查询列表时，resultType无需设置为list这种类型，而是使用List内部所包含的类型\",\"所以这里还是填写com.test.User类型或是Map类型：\",\"<select id=\\\"selectUsers\\\" resultType=\\\"com.test.User\\\"> select * from user; </select> \",\"由于返回的结果是一个列表，这里我们需要使用selectList方法来执行，如果使用之前的selectOne会导致异常：\",\"List<User> user = session.selectList(\\\"selectUsers\\\"); System.out.println(user); \",\"我们同样可以进行简单的条件查询，比如我们想要查询所有年龄大于等于18岁的用户：\",\"<select id=\\\"selectUsersByAge\\\" resultType=\\\"com.test.User\\\"> select * from user where age &gt; #{age}; </select> \",\"注意由于这里是XML配置，其中一些字符被用作标签表示，无法代表其原本的意思，比如小于、大于符号，分别需要使用&lt;和&gt;来进行转义。\",\"List<User> user = session.selectList(\\\"selectUsersByAge\\\", 18); \",\"一个比较特殊的选择方法selectMap\",\"可以将查询结果以一个Map的形式表示，只不过这和我们之前说的Map不太一样，它返回的Map是使用我们想要的属性作为Key，然后得到的结果作为Value的Map，它适用于单个数据查询或是多行数据查询：\",\"//最后一个参数为我们希望作为key的属性 Map<String, User> user = session.selectMap(\\\"selectUserById\\\", 1, \\\"id\\\"); \",\"可以看到这个Map中确实使用的是id作为Key，然后查询得到的实体对象作为Value。\",\"还有一个比较特殊的选择操作是selectCursor\",\"可以得到一个Cursor对象，同样是用于列表查询的，只不过使用起来和我们之前JDBC中的ResultSet比较类似，也是通过迭代器的形式去进行数据的读取，官方解释它主要用于惰性获取数据，提高性能：\",\"public interface Cursor<T> extends Closeable, Iterable<T> { ... } \",\"可以看到它本身是实现了Iterable接口的，表明它可以获取迭代器或是直接使用foreach来遍历：\",\"Cursor<User> cursor = session.selectCursor(\\\"selectUsers\\\"); for (User user : cursor) { System.out.println(user); } \",\"只不过这种方式在大部分请情况下还是用的比较少，我们主要还是以selectOne和selectList为主。\",\"最后还有一个普通的select方法，它支持我们使用Lambda的形式进行查询结果的处理：\",\"session.select(\\\"selectUsers\\\", context -> { //使用ResultHandler来处理结果 System.out.println(context.getResultObject()); }); \",\"结果会自动进行遍历并依次执行我们传入的Lambda表达式。\"]},\"654\":{\"c\":[\"code\"]},\"655\":{\"c\":[\"javaweb\",\"mybatis\"]},\"656\":{\"h\":\"javaweb - Mybatis4\"},\"657\":{\"h\":\"Mybatis详解2\"},\"658\":{\"h\":\"指定构造方法\",\"t\":[\"(一般不咋用) 通过前面的学习，我们已经知道如何使用Mybatis进行各种查询操作。我们知道，Mybatis在执行完查询语句后，会自动将查询的结果转换为我们所需要的实体类\",\"实际上Mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象，然后通过反射进行赋值，我们可以手动编写一个带调试信息的无参构造：\",\"public User() { System.out.println(\\\"????\\\"); } \",\"alt text\",\"可以看到Mybatis确实调用了我们的无参构造方法来构建对象，属性则是通过反射进行赋值，这里截取部分Mybatis源代码进行演示：\",\"//这里的object就是刚刚构造好的实体类对象，prop是要设置的值的字段信息，value就是要设置的值 private void setBeanProperty(PropertyTokenizer prop, Object object, Object value) { try { //Invoker是Mybatis内部编写一个用于反射设置对象属性值的工具 Invoker method = metaClass.getSetInvoker(prop.getName()); Object[] params = { value }; try { method.invoke(object, params); //通过Invoker为传入的实体类对象赋值 } catch (Throwable t) { throw ExceptionUtil.unwrapThrowable(t); } } catch (Throwable t) { ... } } \",\"由于Mybatis默认情况下直接通过无参构造来创建实体类对象，如果我们的类中存在其他的构造方法覆盖掉默认的无参构造，那么Mybatis会选择可用的构造方法来进行构造。\",\"但是如果存在多个构造方法，Mybatis会出现问题：\",\"@ToString public class User { ... public User(int id) { this.id = id; } public User(String name, int age) { this.name = name; this.age = age; } } \",\"运行时出现错误：\",\"Exception in thread \\\"main\\\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.User matching [java.lang.Integer, java.lang.String, java.lang.Integer] ### The error may exist in file:mappers/TestMapper.xml \",\"此时由于类中存在多个构造方法，而Mybatis不知道该如何选择，那么就会告诉我们找不到合适的构造方法，要解决这种问题也很简单，我们不需要删除这些多余的构造方法，只需添加一个无参构造或是全参构造即可，注意全参构造必须与查询结果字段参数一一对应。\",\"但是注意，Mybatis仅仅是使用这种方式进行对象的构建，而字段的赋值无论是什么构造方法，都会使用反射进行一次赋值：\",\"public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; //这里我们让age在赋值时增加一次 } \",\"我们会发现，就算像这样进行了修改，最终的结果依然是被赋值为数据库中的结果，也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了。\",\"如果需要让Mybatis完全使用构造方法进行对象构建与赋值工作，那么我们需要在XML中手动编写配置，同样需要使用resultMap来完成：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.User\\\"> <constructor> </constructor> </resultMap> \",\"这一次我们在resultMap中添加constructor标签，表示我们的查询结果直接使用指定的构造方法来处理。接着我们需要配置一下constructor里面的内容，使其符合我们指定构造方法的定义，比如现在我们有一个这样的构造方法：\",\"public User(int id, String name) { this.id = id; this.name = name + \\\"同学\\\"; } \",\"那么对应的XML配置编写为，使用arg标签来代表每一个参数，主键可以使用idArg来表示，有助于优化性能：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> </constructor> \",\"注意参数的顺序，必须和构造方法的顺序一致，否则会导致Mybatis无法确认。\",\"指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值。\"]},\"659\":{\"h\":\"接口绑定\",\"t\":[\"之前通过创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，可以用接口来简化\",\"通过namespace来将各种操作绑定到一个接口上，然后使用方法的形式来表示，注意接口的参数和返回值必须正确对应，否则可能会出现问题：\",\"public interface TestMapper { List<Student> selectStudent(); Student selectStuById(int id); List<Student> selectStusBySex(String sex); } \",\"接着将Mapper文件的命名空间修改为我们的接口完整名称：\",\"<mapper namespace=\\\"com.test.mapper.TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"Student\\\"> select * from student </select> <select id=\\\"selectStuById\\\" resultType=\\\"Student\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectStusBySex\\\" resultType=\\\"Student\\\"> select * from student where sex = #{sex} </select> </mapper> \",\"这里建议将对应的xml配置也放到放到同包中，作为内部资源：\",\"alt text\",\"作为内部资源后，我们需要修改一下配置文件中的mapper文件目录，不使用url而是resource表示是Jar内部的文件：\",\"<mappers> <mapper resource=\\\"com/test/mapper/TestMapper.xml\\\"/> </mappers> \",\"现在我们可以直接通过SqlSession获取我们编写接口的实现类，这个实现类是由Mybatis根据我们的配置自动生成的，不需要我们做任何事情：\",\"try(SqlSession sqlSession = MybatisUtil.openSession(true)) { TestMapper mapper = sqlSession.getMapper(TestMapper.class); //直接获取实现类 //这里调用我们编写的接口方法 mapper.selectStudent().forEach(System.out::println); } \",\"那肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？\",\"我们可以通过调用getClass()方法来看看实现类是个什么：\",\"TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getClass()); \",\"我们发现，得到的类名称很奇怪class jdk.proxy2.$Proxy4，它其实是通过动态代理生成的，相当于在程序运行过程中动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。\"]},\"660\":{\"h\":\"多参数表示\",\"t\":[\"xml中参数名改为 param1, param2, ...\",\"用注解 @param(xx)\",\"我们接着来看更方便的用法，有些时候，我们的查询操作可能需要不止一个参数：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"com.test.entity.User\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"一种最简单的方式就是和之前一样，我们使用一个Map作为参数，然后将这些参数添加到Map中进行传递：\",\"User selectUserByIdAndAge(Map<String, Object> map); \",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserByIdAndAge(Map.of(\\\"id\\\", 1, \\\"age\\\", 18))); \",\"只不过，这样编写实在是太复杂了，要是由一种更简单的方式就好了，我们也可以直接将这两个参数定义到形参列表中：\",\"User selectUserByIdAndAge(int id, int age); \",\"只不过这种方式查询的话，Mybatis会并不能正确获取对应的参数：\",\"### Cause: org.apache.ibatis.binding.BindingException: Parameter 'id' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) \",\"这是因为Java代码编译后形参名称无法保留，导致Mybatis无法确定具体哪个参数交什么名字，\",\"所以默认情况下它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等，这里id实际上就是param1：\",\"select * from user where id = #{param1} and age = #{param2} \",\"当然，如果你实在需要使用对应的属性名称，我们也可以手动添加一个@Param注解来指定某个参数的名称：\",\"User selectUserByIdAndAge(@Param(\\\"id\\\") int id, @Param(\\\"age\\\") int age); \",\"这样Mybatis就可以正确识别了。\"]},\"661\":{\"c\":[\"code\"]},\"662\":{\"c\":[\"javaweb\",\"mybatis\"]},\"663\":{\"h\":\"javaweb - Mybatis5\"},\"664\":{\"h\":\"Mybatis详解3\"},\"665\":{\"h\":\"复杂查询\"},\"666\":{\"h\":\"一对一查询\",\"t\":[\"首先来看最简单的一对一查询，假设我们每个用户都有一个自己的详细信息表：\",\"alt text\",\"这里的id与用户id一致，作为用户id的逻辑外键，表示对应用户的详细信息。对应的实体类为：\",\"@Data public class UserDetail { int id; String description; Date register; String avatar; } @Data public class User { int id; String name; int age; UserDetail detail; } \",\"现在我们希望查询User时，同时将用户的详细信息包含在内，像这种一对一查询该怎么实现呢？\",\"我们现在同样需要使用resultMap来自定义映射规则\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> </resultMap> \",\"MyBatis 有两种不同的方式加载关联：\",\"嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。\",\"嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。\"]},\"667\":{\"h\":\"嵌套结果映射\",\"t\":[\"我们先来看第一种方式，需要使用关联查询将用户的详细信息一并获取，然后配置关联查询相关信息，最后由Mybatis来对查询的结果进行处理即可.\",\"首先是关联查询的SQL语句，这里我们直接使用左连接：\",\"select * from user left join user_detail on user.id = user_detail.id where user.id = #{id} \",\"alt text\",\"接着我们需要在resultMap编写好对应关系，一对一查询我们可以使用association标签来进行指定，其中property就是需要进行一对一处理的对象\",\"在此标签内部填写需要进行一对一映射的对象属性：\",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" javaType=\\\"UserDetail\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"description\\\" column=\\\"description\\\"/> <result property=\\\"register\\\" column=\\\"register\\\"/> <result property=\\\"avatar\\\" column=\\\"avatar\\\"/> </association> </resultMap> \",\"这里的column和javaType可以不填，Mybatis一般情况下可以自动完成推断，配置完成后，我们在查询时Mybatis就可以自动把额外信息也封装好了：\",\"alt text\"]},\"668\":{\"h\":\"嵌套 Select 查询\",\"t\":[\"们可以在查询user表的时候，同时查询user_detail表的对应信息，分别执行两个选择语句，最后再由Mybatis将其结果合并，效果和第一种方法是一样的：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <select id=\\\"selectUserDetailById\\\" resultType=\\\"com.test.entity.UserDetail\\\"> select * from user_detail where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" select=\\\"selectUserDetailById\\\" javaType=\\\"com.test.entity.UserDetail\\\"/> </resultMap> \",\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息，并使用association标签的select属性来指定关联查询操作，得到结果是一样的\"]},\"669\":{\"h\":\"Mybatis日志\",\"t\":[\"我们可以开启Mybatis的日志来观察具体执行的操作，这里我们需要在Mybatis配置文件中添加：\",\"<settings> <setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\"/> </settings> \",\"这样Mybatis运行时就会打印日志到控制台了：\",\"... Opening JDBC Connection Created connection 1962329560. ==> Preparing: select * from user where id = ? ==> Parameters: 1(Integer) <== Columns: id, name, age <== Row: 1, 小明, 18 ====> Preparing: select * from user_detail where id = ? ====> Parameters: 1(Integer) <==== Columns: id, description, register, avatar <==== Row: 1, 我是一个阳光开朗大男孩, 2024-08-16 15:15:03, https://www.baidu.com <==== Total: 1 <== Total: 1 User(id=1, name=小明, age=18, detail=UserDetail(id=1, description=我是一个阳光开朗大男孩, register=Fri Aug 16 15:15:03 CST 2024, avatar=https://www.baidu.com)) Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@74f6c5d8] Returned connection 1962329560 to pool. \",\"Mybatis日志中，==>向右的箭头就是发送给MySQL服务器的SQL语句以及其参数列表，<==向左的箭头就是得到的结果，可以看到这里一共执行了两次SQL语句，分别是user表和user_detail表的查询操作\"]},\"670\":{\"h\":\"一对多查询 (查询一个 - 返回多个)\",\"t\":[\"collection - 实体属性为列表\",\"association - 实体属性为实体类\",\"我们接着来看一对多查询，现在来一个新的表，用于存放用户借阅的图书，对应实体类如下：\",\"@Data public class Book { int bid; String title; } @Data public class User { int id; String name; int age; List<Book> books; //直接得到用户所属的所有书籍信息 } \",\"其中book表设计如下，其中uid作为用户id的逻辑外键，表示这本书是谁借的：\",\"alt text\",\"对于一对多查询，我们也可以进行关联查询来让Mybatis自动解析结果并封装为对象\",\"首先还是关联查询的SQL语句，这里我们让user左连接到book表中：\",\"select * from user left join book on user.id = book.uid where user.id = #{id} \",\"此时由于出现了多行数据，我们需要配置一个collection标签来让其可以正确处理关联的集合结果，Mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中：\",\"<resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <collection property=\\\"books\\\" ofType=\\\"com.test.entity.Book\\\"> <id column=\\\"bid\\\" property=\\\"bid\\\"/> <result column=\\\"title\\\" property=\\\"title\\\"/> </collection> </resultMap> \",\"我们需要在resultMap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系，当然这个关系哪怕只写一个Mybatis也可以自动推断其他的，不过建议还是写完整一点\"]},\"671\":{\"h\":\"嵌套查询\",\"t\":[\"此外也可以用 select 嵌套查询来解决，操作是同样的\",\"<select id=\\\"selectStuById\\\" resultMap=\\\"test\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectBookBySid\\\" resultType=\\\"com.test.entity.Book\\\"> select * from book where uid = #{sid} </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <collection property=\\\"books\\\" select=\\\"selectBookBySid\\\" column=\\\"sid\\\" ofType=\\\"com.test.entity.Book\\\"/> </resultMap> \"]},\"672\":{\"h\":\"多对一查询 (多 - 多)\",\"t\":[\"了解了一对多，那么多对一又该如何查询\",\"比如每个用户现在都有一个小组，但是他们目前都是在同一个小组中，此时我们查询所有用户信息的时候，需要自动携带他们的小组：\",\"alt text\",\"这里我们需要修改一下user表来记录每一个用户所属的小组id，这里使用gid作为分组id的逻辑外键\",\"接着是实体类设计：\",\"@Data public class Group { int id; String name; } @Data public class User { int id; String name; int age; Group group; } \",\"接着就是编写SQL映射，实际上这里跟我们之前的一对一非常类似，我们只需要让查询出来的每一个用户都左连接分组信息即可，这样Mybatis就可以通过association来自动处理了：\",\"select *, groups.name as gname from user left join `groups` on user.gid = groups.id \",\"注意SQL语句中一些字段存在歧义，我们需要手动为其起个别名，接着就是XML编写了：\",\"<select id=\\\"selectAllUser\\\" resultMap=\\\"test2\\\"> select *, groups.name as gname from user left join `groups` on user.gid = groups.id </select> <resultMap id=\\\"test2\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <association property=\\\"group\\\"> <id column=\\\"gid\\\" property=\\\"id\\\"/> <result column=\\\"gname\\\" property=\\\"name\\\"/> </association> </resultMap> \",\"这样我们就可以成功实现多对一查询了，这与之前的一对一比较类似。\",\"当然，也可以嵌套select\",\"<select id=\\\"selectStudent\\\" resultMap=\\\"test\\\"> select * from student </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <association property=\\\"group\\\" select=\\\"selectGroup\\\" column=\\\"gid\\\" javaType=\\\"com.test.entity.Group\\\"/> </resultMap> <select id=\\\"selectGroup\\\" resultType=\\\"com.test.entity.Group\\\"> select * from `group` where gid = #{gid} </select> \"]},\"673\":{\"c\":[\"code\"]},\"674\":{\"c\":[\"javaweb\",\"mybatis\"]},\"675\":{\"h\":\"javaweb - Mybatis6\"},\"676\":{\"h\":\"Mybatis详解4\"},\"677\":{\"h\":\"DML 操作\",\"t\":[\"前面我们介绍了查询操作，我们接着来看修改相关操作(增、删、改)。\",\"Mybatis为我们的DML操作提供了几个预设方法：\",\"int insert(String statement); int insert(String statement, Object parameter); int update(String statement); int update(String statement, Object parameter); int delete(String statement); int delete(String statement, Object parameter); \",\"可以看到，这些方法默认情况下返回的结果都是int类型的，这与我们之前JDBC中是一样的，它代表执行SQL后受影响的行数。\"]},\"678\":{\"h\":\"插入 标签\",\"t\":[\"我们来尝试编写一个插入操作\",\"Mybatis为我们提供的插入操作非常快捷，我们可以直接让一个User对象作为参数传入\",\"即可在配置中直接解析其属性到insert语句中，这里需要用到insert标签：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里我们将parameterType类型设置为我们的实体类型，这样下面在使用#{name}时Mybatis就会自动调用类中对应的Get方法来获取结果\",\"不过，即使这里不指定具体类型，Mybatis也能完成自动推断，非常智能(参数名称要与实体类参数对应)。\",\"和之前一样，我们也可以直接将其绑定到一个接口上：\",\"public interface TestMapper { int addUser(User user); } \",\"注意返回类型必须是int或是long这类数字类型，表示生效的行数，然后这里我们传入的参数直接写成对应的类型即可。\"]},\"679\":{\"h\":\"自增主键ID\",\"t\":[\"有些时候，我们的数据插入后使用的是一个自增主键ID，那么这个自增的主键值我们该如何获取到呢？\",\"Mybatis为我们提供了一些参数用于处理这种问题：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里useGeneratedKeys设置为true表示我们希望获取数据库生成的键\",\"keyProperty设置为User类中的需要获取自增结果的属性名，keyColumn为数据库中自增的字段名称\",\"但是一般情况下不需要手动设置，但是某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，必须设置。\",\"这样我们就可以获取到自增后的值了，接着我们什么都不需要做，Mybatis会在查询完后自动为我们的User对象赋值：\"]},\"680\":{\"h\":\"修改 标签\",\"t\":[\"我们接着来看修改操作，比如要根据ID修改用户的年龄：\",\"<update id=\\\"setUserAgeById\\\"> update user set age = #{age} where id = #{id} </update> \",\"int setUserAgeById(User user); \",\"这里的参数我们依然选择使用User，和之前insert一样，Mybatis会从传入的对象中自动获取需要的参数，当然我们也可以将此方法设计为两个参数的形式：\",\"int setUserAgeById(@Param(\\\"age\\\") int age, @Param(\\\"id\\\") int id); \"]},\"681\":{\"h\":\"删除\",\"t\":[\"删除操作则更为简单，假设我们要根据用户的id进行数据的删除：\",\"<delete id=\\\"deleteUserById\\\"> delete from user where id = #{id} </delete> \",\"这些操作相比查询操作来说非常简单就可以实现，这里就不多做介绍了。\"]},\"682\":{\"h\":\"事务操作\",\"t\":[\"我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多\",\"在创建SqlSession的时候不填写参数默认使用的就是事务模式：\",\"try (SqlSession session = sqlSessionFactory.openSession(false)) { ... } \",\"我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的：\",\"try(SqlSession session = MybatisUtils.openSession(false)) { TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); //虽然日志中已经提示生效1行，但是并没有提交 } \",\"SqlSession接口中为我们提供了事务操作相关的方法，这里我们可以直接尝试进行事务的提交：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(7); session.commit(); //通过SqlSession进行事务提交 \",\"注意，如果我们在提交事务之前，没有进行任何的DML操作，也就是删除、更新、插入的其中任意一种操作，那么调用commit方法则不会进行提交，当然如果仍然需要提交的话也可以使用commit(true)来强制提交。\",\"我们接着来测试一下回滚操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); System.out.println(mapper.selectUserById(1)); //此时由于数据被删除，无法查到 session.rollback(); //进行回滚操作 System.out.println(mapper.selectUserById(1)); //之前被删除的数据回来了 \",\"事务相关操作非常简单，这里就暂时先介绍这么多。\"]},\"683\":{\"c\":[\"code\"]},\"684\":{\"c\":[\"javaweb\",\"mybatis\"]},\"685\":{\"h\":\"javaweb - Mybatis7\"},\"686\":{\"h\":\"Mybatis详解5\"},\"687\":{\"h\":\"动态SQL\"},\"688\":{\"h\":\"批处理\",\"t\":[\"在之前JDBC讲解的时候，我们就提到过批量执行语句的问题，当我们要执行很多条语句时，可能会一个一个地提交：\",\"//现在要求把下面所有用户都插入到数据库中 List<String> users = List.of(\\\"小刚\\\", \\\"小强\\\", \\\"小王\\\", \\\"小美\\\", \\\"小黑子\\\"); //使用for循环来一个一个执行insert语句 for (String user : users) { statement.executeUpdate(\\\"insert into user (name, age) values ('\\\" + user + \\\"', 18)\\\"); } \",\"虽然这样看似非常完美，也符合逻辑，但是实际上我们每次执行SQL语句，都像是去厨房端菜到客人桌上一样，我们每次上菜的时候只从厨房端一个菜，效率非常低\",\"但是如果我们每次上菜推一个小推车装满N个菜一起上，效率就会提升很多，而数据库也是这样，我们每一次执行SQL语句，都需要一定的时间开销\",\"但是如果我把这些任务合在一起告诉数据库，效率会截然不同：\",\"alt text\",\"可见，使用循环操作执行数据库相关操作实际上非常耗费资源，不仅带来网络上的额外开销，还有数据库的额外开销\",\"更推荐使用批处理来优化这种情况，一次性提交一个批量操作给数据库。\",\"需要在Mybatis中开启批处理，我们只需要在创建SqlSession时进行一些配置即可：\",\"factory.openSession(ExecutorType.BATCH, autoCommit); \",\"在使用openSession时直接配置ExecutorType为BATCH即可，这样SqlSession会开启批处理模式，在多次处理相同SQL时会尽可能转换为一次执行，开启批处理后，无论是否处于事务模式下，我们都需要flushStatements()来一次性提交之前是所有批处理操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } session.flushStatements(); \",\"此时日志中可以看到Mybatis在尽可能优化我们的SQL操作：\",\"alt text\"]},\"689\":{\"h\":\"动态SQL介绍\",\"t\":[\"除了使用批处理之外，Mybatis还为我们提供了一种更好的方式来处理这种问题，我们可以使用动态SQL来一次性生成一个批量操作的SQL语句\",\"动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\",\"简单来说，动态SQL在执行时可以进行各种条件判断以及循环拼接等操作，极大地提升了SQL语句编写的的灵活性。\"]},\"690\":{\"h\":\"条件判断 标签\",\"t\":[\"在编写SQL时，我们可以添加一些用于条件判断的标签到XML的SQL语句中\",\"比如我们希望在根据ID查询用户时，如果查询的ID大于3，那么必须同时要满足大于18岁这个条件，这看似是一个很奇怪的查询条件，此时动态SQL就能很轻松实现这个操作：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",\"如果不满足，那么就不拼接里面的内容到原本的SQL中，其中test属性就是我们需要填写的判断条件，它采用OGNL表达式进行编写，语法与Java比较相似\",\"详细了解: https://commons.apache.org/dormant/commons-ognl/\",\"当我们查询条件不同时，Mybatis会选择性拼接我们的SQL语句\"]},\"691\":{\"h\":\"选择判断\",\"t\":[\"除了if操作之外，Mybatis还针对多分支情况提供了choose操作，它类似于Java中的switch语句\",\"比如现在我们希望在查询用户时，ID等于1的必须同时要满足小于18岁，ID等于2的必须满足等于18岁，其他情况的必须满足大于18岁(这需求有点抽象)\",\"我们可以像这样进行编写：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <choose> <when test=\\\"id == 1\\\"> and age &lt;= 18 </when> <when test=\\\"id == 2\\\"> and age = 18 </when> <otherwise> and age > 18 </otherwise> </choose> </select> \",\"注意在when中不允许使用<或是>这种模糊匹配的条件(实际运行好像是可以的)。\"]},\"692\":{\"h\":\"实现批量处理\",\"t\":[\"foreach操作，它与Java中的for类似，可以实现批量操作，这非常适合处理我们前面说的批量执行SQL的问题：\"]},\"693\":{\"h\":\"批量删除\",\"t\":[\"for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } \",\"但是实际上这种情况完全可以简写为一个SQL语句：\",\"DELETE FROM users WHERE id IN (1, 2, 3, 4, 5); \",\"使用foreach来完成它就很简单了：\",\"<delete id=\\\"deleteUsers\\\"> delete from user where id in <foreach collection=\\\"list\\\" item=\\\"item\\\" index=\\\"index\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\"> #{item} </foreach> </delete> \",\"其中:\",\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称，即我们在JAVA中所传给他的值\",\"open和close用于控制起始和结束位置添加的符号\",\"separator用于控制分隔符\",\"现在执行以下操作：\",\"session.delete(\\\"deleteUsers\\\", List.of(1, 2, 3, 4, 5)); \",\"最后实际执行的SQL为：\",\"alt text\"]},\"694\":{\"h\":\"批量插入\",\"t\":[\"我们再来看一个例子，比如现在我们想要批量插入一些用户到数据库里面，原本Java应该这样写，但是这是一种极其不推荐的做法：\",\"TestMapper mapper = session.getMapper(TestMapper.class); List<User> users = List.of(new User(\\\"小美\\\", 17), new User(\\\"小张\\\", 18), new User(\\\"小刘\\\", 19)); for (User user : users) { mapper.insertUser(user); } \",\"实际上这种操作完全可以浓缩为一个SQL语句：\",\"INSERT INTO user (name, age) VALUES ('小美', 17), ('小张', 18), ('小刘', 19); \",\"那这时又可以直接使用咱们的动态SQL来完成操作了：\",\"<insert id=\\\"insertAllUser\\\"> insert into user (name, age) values <foreach collection=\\\"list\\\" item=\\\"item\\\" separator=\\\",\\\"> (#{item.name}, #{item.age}) </foreach> </insert> \",\"alt text\",\"通过使用动态SQL语句，我们基本上可以解决大部分的SQL查询和批量处理场景了。\"]},\"695\":{\"c\":[\"code\"]},\"696\":{\"c\":[\"javaweb\",\"mybatis\"]},\"697\":{\"h\":\"javaweb - Mybatis8\"},\"698\":{\"h\":\"Mybatis详解6\"},\"699\":{\"h\":\"缓存机制\",\"t\":[\"其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。\",\"Mybatis为了查询效率，同样内置了一个缓存机制，我们在查询时，如果Mybatis缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求，节省性能开销。\",\"alt text\",\"Mybatis的缓存机制有些复杂，存在一级缓存(本地缓存)和二级缓存\"]},\"700\":{\"h\":\"一级缓存 (作用在 )\",\"t\":[\"我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，也就是一级缓存，它仅仅对一个会话中的数据进行缓存（一级缓存强制启用，无法关闭，只能做调整）\",\"也就是每一个SqlSession都有有一个对应的缓存\",\"我们来看看下面这段代码：\",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserById(1)); System.out.println(mapper.selectUserById(1)); //再次获取 \",\"这里我们连续获取了两次ID为1的用户，我们会在日志中惊奇地发现，这里的查询操作实际上只进行了一次：\",\"alt text\",\"我们去掉类上的@Data注解，会发现得到的两个对象实际上就是同一个：\",\"alt text\",\"也就是说我们第二次查询不仅压根就没执行SQL语句，甚至直接没有重新构造对象，而是直接获取之前创建好的。\",\"可见，Mybatis确实存在着缓存机制来进行性能优化。\",\"那么如果我修改了数据库中的内容，缓存还会生效吗：\",\"System.out.println(mapper.selectUserById(1)); mapper.updateAgeById(1, 19); System.out.println(mapper.selectUserById(1)); \",\"此时由于我们更新了数据库中的数据，那么之前缓存的内容也会跟着失效，第二次获取的时候会进行重新查询。\",\"也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。\",\"但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。\",\"因此， 一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，我们可以来试验一下：\",\"try(SqlSession s1 = MybatisUtils.openSession(true); SqlSession s2 = MybatisUtils.openSession(true)) { TestMapper m1 = s1.getMapper(TestMapper.class); TestMapper m2 = s2.getMapper(TestMapper.class); System.out.println(m1.selectUserById(1)); m2.updateAgeById(1, 19); System.out.println(m1.selectUserById(1)); } \",\"可以看到，会话1在重复查询数据时，即使会话2已经修改了数据，但是依然没有影响会话1之中的缓存。\",\"这导致尽管会话2更新了数据，但是会话1中的数据是从缓存得到的，没有更新。\",\"一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，无论哪个会话对于数据的查询缓存都可以直接被所有会话使用。\"]},\"701\":{\"h\":\"二级缓存 (作用在 )\",\"t\":[\"我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加：\",\"<cache/> \",\"二级缓存是Mapper级别的，只要是使用这个Mapper的会话，都会关联到这个二级缓存\",\"无论哪个会话失效，它之前查询的缓存依然会存在于二级缓存中，依然可以被其他会话直接使用。\",\"我们可以对cache标签进行一些配置：\",\"<cache eviction=\\\"FIFO\\\" flushInterval=\\\"60000\\\" size=\\\"512\\\" readOnly=\\\"true\\\"/> \",\"其中，size表示最大的缓存对象数量，当缓存达到上限时，会根据eviction配置的策略进行清理：\",\"LRU – 最近最少使用：移除最长时间不被使用的对象。\",\"FIFO – 先进先出：按对象进入缓存的顺序来移除它们。\",\"SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。\",\"WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\",\"flushInterval用于控制缓存刷新时间，当到达指定时间时会自动清理所有缓存，默认情况下如果不配置此项则不会进行定时清理。\",\"readOnly（只读）属性可以被设置为 true 或 false，只读的缓存会给所有调用者返回相同的缓存对象，且对象不能被修改。这就提供了可观的性能提升。\",\"而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。\",\"注意： 二级缓存是事务性的，这意味着，当 SqlSession 结束并提交时，或是结束并回滚，而且没有执行 flushCache=true 的 insert/delete/update 语句时，二级缓存才会被更新。\",\"即：\",\"try(SqlSession session = MybatisUtil.getSession(true); SqlSession session2 = MybatisUtil.getSession(true) ){ TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectStuById(1)); session2.commit(); TestMapper mapper2 = session2.getMapper(TestMapper.class); System.out.println(mapper2.selectStuById(1)); } \",\"只有commit了，才会保存在二级缓存，这样用mapper2时，才不会重新读取，如果没有commit，就会重新读取，因为并没有保存在缓存中\",\"开启二级缓存后，再次执行我们之前的操作，就可以直接在二级缓存中命中了：\",\"alt text\"]},\"702\":{\"h\":\"查找顺序\",\"t\":[\"实际上，添加了二级缓存之后，Mybatis会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库。\"]},\"703\":{\"h\":\"单独配置取消二级缓存\",\"t\":[\"当我们开启二级缓存后，默认情况下一个Mapper中所有的操作都会使用二级缓存\",\"我们也可以单独配置其不使用二级缓存，只需要修改useCache属性即可：\",\"<select id=\\\"selectUserById\\\" useCache=\\\"false\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"704\":{\"h\":\"操作结束，清除所有缓存\",\"t\":[\"有些操作可能比较特殊，比如我们希望某个操作执行完成后，直接清除所有缓存，无论是一级缓存还是二级缓存，那么此时就可以开启flushCache属性：\",\"<select id=\\\"selectUserById\\\" flushCache=\\\"true\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \",\"开启此选项后，调用此操作将直接导致一级和二级缓存被清除。\"]},\"705\":{\"h\":\"缓存一致性问题\",\"t\":[\"虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题\",\"当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题。\",\"alt text\",\"而Mybatis也会这样，我们来看看这个例子：\",\"TestMapper mapper = session.getMapper(TestMapper.class); while (true){ Thread.sleep(3000); System.out.println(mapper.selectUserById(1)); } \",\"我们现在循环地每三秒读取一次，而在这个过程中，我们使用其他软件手动修改数据库中的数据，将1号用户的ID改成100，那么理想情况下，下一次读取将直接无法获取到这行数据，因为ID已经发生变化了。\",\"但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的\",\"因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题\",\"我们只能关闭所有二级缓存，并且在Mybatis每个操作都配置flushCache为true来保证刷新。\",\"只不过这种操作实际上是治标不治本的，实现多服务器缓存共用才是最终解决方案，也就是让所有的Mybatis都使用同一个缓存进行数据存取\",\"在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。\"]},\"706\":{\"c\":[\"code\"]},\"707\":{\"c\":[\"javaweb\",\"mybatis\"]},\"708\":{\"h\":\"javaweb - Mybatis9\"},\"709\":{\"h\":\"Mybatis详解7\"},\"710\":{\"h\":\"使用注解开发\",\"t\":[\"在之前的学习中，我们已经体验到Mybatis为我们带来的便捷了\",\"我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。\",\"那么，能否实现无需XML映射器配置，而是直接使用注解在接口上进行配置呢？\",\"我们可以直接删除掉所有的Mapper.xml文件了，只保留Mapper相关的接口。\",\"现在，我们来尝试以全注解的形式重现编写咱们的SQL语句映射\"]},\"711\":{\"h\":\"调整\",\"t\":[\"还是以查询所有的用户为例，既然现在不需要配置Mapper.xml文件了，那么我们现在需要重写在Mybatis的配置文件中进行mapper的配置\",\"因为现在只需要使用接口来进行配置\",\"所以使用package标签来指定一个包，包下所有的接口都将直接作为Mapper配置接口：\",\"<mappers> <package name=\\\"com.test.mapper\\\"/> </mappers> \",\"或者还是mapper标签通过class属性来指定具体的接口：\",\"<mappers> <mapper class=\\\"com.test.mapper.TestMapper\\\"/> </mappers> \"]},\"712\":{\"h\":\"修改对应接口+注解\",\"t\":[\"现在我们还是在Mapper中添加一个对应的方法用于执行：\",\"public interface TestMapper { List<User> selectAllUser(); } \",\"之前我们需要像这样编写：\",\"<select id=\\\"selectAllUser\\\" resultType=\\\"com.test.User\\\"> select * from user </select> \"]},\"713\":{\"h\":\"举例\",\"t\":[\"现在只需要一个注解即可，Mybatis为我们提供了丰富的注解用于表示不同SQL语句类型\",\"这里的@Select代表的就是select标签，我们只需要直接在其中编写SQL语句即可，而返回类型Mybatis会自动根据方法的返回值进行判断：\",\"public interface TestMapper { @Select(\\\"select * from user\\\") List<User> selectAllUser(); } \",\"QQ_1724143033753\",\"包括一些SQL语句参数的使用也是和之前完全一样，比如插入一个用户：\",\"@Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \"]},\"714\":{\"h\":\"配置这些额外的参数\",\"t\":[\"虽然Mybatis为我们提供了之前XML配置中各种操作的对应注解，但是我们发现，这些注解并不能像之前XML那样直接修改一些属性\",\"比如我们希望配置useGeneratedKeys来得到自动生成的主键，从而修改我们对应的实体类\",\"需要配置这些额外的参数，我们可以使用@Options注解：\",\"@Options(useGeneratedKeys = true, keyColumn = \\\"id\\\", keyProperty = \\\"id\\\") @Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \",\"<insert id=\\\"insertUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这两种写法效果是完全一样的，Mybatis在插入后，会将我们当前的实体类对象的id修改为得到的id\",\"Student student = new Student().setName(\\\"abc\\\").setSex(\\\"女\\\"); mapper.insertStudent(student); System.out.println(student); \",\"alt text\",\"所以我们通过Mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置。\"]},\"715\":{\"h\":\"实体类字段名称与数据库不同\",\"t\":[\"假如现在我们的实体类字段名称与数据库不同，此时该如何像之前一样配置resultMap呢？\",\"public class User { int uid; String username; int age; } \",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"我们可以使用@Results注解来实现这种操作，它的使用方式与resultMap几乎没什么区别：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"uid\\\"), @Result(column = \\\"name\\\", property = \\\"username\\\") }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"716\":{\"h\":\"结合 配置\",\"t\":[\"当然，如果你还是觉得这种方式配置起来不如之前方便，那么你也可以单独在XML中配置一个resultMap\",\"然后直接通过注解的形式引用：\",\"@ResultMap(\\\"test\\\") @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"717\":{\"h\":\"指定构造方法\",\"t\":[\"那么现在如果我们需要指定使用的构造方法怎么办呢？就像我们之前在使用constrator标签一样\",\"Mybatis为我们提供了@ConstructorArgs注解，配置方式和之前几乎一致：\",\"public class User { int id; String name; int age; public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; } } \",\"@ConstructorArgs({ @Arg(id = true, column = \\\"id\\\", javaType = int.class), @Arg(column = \\\"name\\\", javaType = String.class), @Arg(column = \\\"age\\\", javaType = int.class) }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \",\"这与我们之前的XML配置完全一致：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> <arg column=\\\"age\\\" javaType=\\\"_int\\\"/> </constructor> \"]},\"718\":{\"h\":\"关联查询 (注解只支持嵌套查询)\",\"t\":[\"我们再来看看之前在resultMap中配置的关联查询该如何编写，Mybatis也为我们提供了丰富的注解用于处理这类问题，我们首先来看看一对一查询：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"id\\\"), @Result(column = \\\"id\\\", property = \\\"detail\\\", one = @One(select = \\\"selectDetailById\\\")) }) @Select(\\\"select * from user where id = #{id};\\\") User selectUserById(int id); @Select(\\\"select * from user_detail where id = #{id}\\\") UserDetail selectDetailById(int id); \",\"我们在配置@Result注解时，只需要将one或是many参数进行填写即可，它们分别代表一对一关联和一对多关联\",\"使用@One和@Many注解来指定其他查询语句进行嵌套查询，就像是我们之前使用association和collection那样。\",\"不过很遗憾的是，我们无法完全通过注解来实现之前的联合查询解析（这是因为 Java 注解不允许循环引用）\",\"只能使用这种嵌套查询来完成复杂查询操作，因此，如果对这种复杂查询有着一定需求的话，建议使用之前的XML方式进行配置。\"]},\"719\":{\"h\":\"动态 配置 ( 注解)\",\"t\":[\"我们还可以使用注解进行动态SQL的配置\",\"比如现在我们想要实现之前的这个奇葩需求：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"Mybatis针对于所有的SQL操作都提供了对应的Provider注解，用于配置动态SQL\",\"我们需要先创建一个类编写我们的动态SQL操作：\",\"public class TestSqlBuilder { public static String buildGetUserById(int id) { return new SQL(){{ //SQL类中提供了常见的SELECT、FORM、WHERE等操作 SELECT(\\\"*\\\"); FROM(\\\"user\\\"); WHERE(\\\"id = #{id}\\\"); if (id > 3) { WHERE(\\\"age > 18\\\"); } }}.toString(); } } \",\"详细的SQL语句构建器语法文档：https://mybatis.org/mybatis-3/zh_CN/statement-builders.html\",\"构建完成后，接着我们就可以使用@SelectProvider来引用这边编写好的动态SQL操作：\",\"@SelectProvider(type = TestSqlBuilder.class, method = \\\"buildGetUserById\\\") User selectUserById(int id); \",\"效果和之前我们编写XML形式的动态SQL一致\",\"当然，如果遇到了多个参数的情况，我们同样需要使用@Param来指定参数名称，包括TestSqlBuilder中编写的方法也需要添加，否则必须保证形参列表与这边接口一致。\",\"虽然这样可以实现和之前差不多的效果，但是这实在是太过复杂了，我们还需要单独编写一个类来做这种事情\",\"实际上我们也可以直接在@Select中编写一个XML配置动态SQL，Mybatis同样可以正常解析：\",\"@Select(\\\"\\\"\\\" <script> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </script> \\\"\\\"\\\") User selectUserById(int id); \",\"这里只需要包括一个script标签我们就能像之前XML那样编写动态SQL了，只不过由于IDEA不支持这种语法的识别，可能会出现一些莫名其妙的红标，但是是可以正常运行的。\"]},\"720\":{\"h\":\"二级缓存配置\",\"t\":[\"最后我们来看一下二级缓存相关的配置，使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用：\",\"@CacheNamespace(size = 512, readWrite = false) public interface TestMapper {} \",\"我们如果需要控制单个方法的缓存，同样可以使用@Option来进行配置：\",\"@Options(flushCache = Options.FlushCachePolicy.TRUE, useCache = false) @Select(\\\"select * from user where id = #{id}\\\") User selectUserById(int id); \"]},\"721\":{\"h\":\"\",\"t\":[\"这里我们不如再做的更加极致一点，咱们把配置文件也给变成代码配置，彻底抛弃XML配置\",\"实际上我们的XML配置中所有配置项都可以以Configuration对象的形式进行配置，最后在构造SqlSessionFactory时也可以通过此对象进行创建：\",\"sqlSessionFactory = new SqlSessionFactoryBuilder().build(initConfiguration()); private static Configuration initConfiguration() { Configuration configuration = new Configuration(); PooledDataSource dataSource = new PooledDataSource( \\\"com.mysql.cj.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/web_study\\\", \\\"test\\\", \\\"123456\\\"); Environment environment = new Environment(\\\"development\\\", new JdbcTransactionFactory(), dataSource); configuration.setEnvironment(environment); configuration.getTypeAliasRegistry().registerAliases(\\\"com.test.entity\\\"); configuration.setLogImpl(StdOutImpl.class); configuration.addMappers(\\\"com.test.mapper\\\"); return configuration; } \",\"有关Mybatis的基本使用，我们就暂时介绍到这里。\"]},\"722\":{\"c\":[\"code\"]},\"723\":{\"c\":[\"javaweb\",\"mybatis\"]},\"724\":{\"h\":\"javaweb - JUL日志1\"},\"725\":{\"h\":\"JUL日志系统\",\"t\":[\"JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单：\",\"public class Main { public static void main(String[] args) { // 首先获取日志打印器，名称随意 Logger logger = Logger.getLogger(\\\"test\\\"); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\\\"我是普通的日志\\\"); } } \",\"我们可以在主类中使用日志打印，得到日志的打印结果：\",\"十一月 15, 2021 12:55:37 下午 com.test.Main main 信息: 我是普通的日志 \",\"我们发现，通过日志输出的结果会更加规范，在后续的学习中，日志将时刻伴随我们左右。\"]},\"726\":{\"h\":\"JUL基本使用\",\"t\":[\"日志的打印并不是简单的输出，有些时候我们可以会打印一些比较重要的日志信息，或是一些非常紧急的日志信息，根据不同类型的信息进行划分\"]},\"727\":{\"h\":\"级别划分\",\"t\":[\"日志一般分为7个级别，详细信息我们可以在Level类中查看：\",\"public class Level implements java.io.Serializable { ... //出现严重故障的消息级别，值为1000，也是可用的日志级别中最大的 public static final Level SEVERE = new Level(\\\"SEVERE\\\",1000, defaultBundle); //存在潜在问题的消息级别，比如边充电边打电话就是个危险操作，虽然手机爆炸的概率很小，但是还是会有人警告你最好别这样做，这是日志级别中倒数第二大的 public static final Level WARNING = new Level(\\\"WARNING\\\", 900, defaultBundle); //所有常规提示日志信息都以INFO级别进行打印 public static final Level INFO = new Level(\\\"INFO\\\", 800, defaultBundle); //以下日志级别依次降低，不太常用 public static final Level CONFIG = new Level(\\\"CONFIG\\\", 700, defaultBundle); public static final Level FINE = new Level(\\\"FINE\\\", 500, defaultBundle); public static final Level FINER = new Level(\\\"FINER\\\", 400, defaultBundle); public static final Level FINEST = new Level(\\\"FINEST\\\", 300, defaultBundle); ... } \",\"之前通过info方法直接输出的结果就是使用的默认级别的日志，实际上每个级别都有一个对应的方法用于打印：\",\"public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.severe(\\\"severe\\\"); //最高日志级别 logger.warning(\\\"warning\\\"); logger.info(\\\"info\\\"); //默认日志级别 logger.config(\\\"config\\\"); logger.fine(\\\"fine\\\"); logger.finer(\\\"finer\\\"); logger.finest(\\\"finest\\\"); //最低日志级别 } \"]},\"728\":{\"h\":\"自定义级别设置\",\"t\":[\"当然，如果需要更加灵活地控制日志级别\",\"我们也可以通过log方法来主动设定该条日志的输出级别：\",\"Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \\\"严重的错误\\\", new NullPointerException(\\\"祝你明天就遇到我\\\")); logger.log(Level.WARNING, \\\"警告的内容\\\"); logger.log(Level.INFO, \\\"普通的信息\\\"); logger.log(Level.CONFIG, \\\"级别低于普通信息\\\"); \",\"Logger默认情况下只会打印INFO级别以上的日志，而INFO级别以下的日志则会直接省略，我们可以通过配置来进行调整。\"]},\"729\":{\"h\":\"修改日志的默认打印级别\",\"t\":[\"我们知道日志的默认打印级别为INFO，此时低于INFO的所有日志都是被屏蔽的，而要修改日志的默认打印级别，我们需要同时调整Handler和Logger的level属性：\",\"handler.setLevel(Level.FINEST); //注意，填写的日志打印级别是什么，高于等于此级别的所有日志都会被打印 logger.setLevel(Level.FINEST); logger.fine(\\\"Hello World\\\"); \",\"现在我们再次打印低于INFO级别的日志就可以正确得到结果了。\",\"Logger类还为我们提供了两个比较特殊的日志级别，它们专门用于配置特殊情况：\",\"//表示直接关闭所有日志信息，值为int的最大值 public static final Level OFF = new Level(\\\"OFF\\\",Integer.MAX_VALUE, defaultBundle); //表示开启所有日志信息，无论是什么级别都进行打印 public static final Level ALL = new Level(\\\"ALL\\\", Integer.MIN_VALUE, defaultBundle); \",\"因为这这里OFF的值为int的最大值，也就是说没有任何日志级别的值大于它，因此，如果将打印等级配置为OFF，那么所有类型的日志信息都不会被打印了，而ALL则相反。\"]},\"730\":{\"c\":[\"code\"]},\"731\":{\"c\":[\"javaweb\",\"JUL\"]},\"732\":{\"h\":\"javaweb - JUL日志2\"},\"733\":{\"h\":\"JUL日志系统2\"},\"734\":{\"h\":\"日志核心内容\"},\"735\":{\"h\":\"核心部分\",\"t\":[\"日志打印的核心部分：Handler，它用于处理我们的日志内容打印\",\"ConsoleHandler | FileHandler | SocketHandler\",\"JDK为我们提供了很多种类的Handler用于多种不同类型的日志打印，比较常见的就是打印到控制台，当然我们也可以打印到一个日志文件中，名字一般为xxx.log这种格式。\",\"常用的Handler实现有：\",\"ConsoleHandler: 将日志通过System. err打印到控制台，现在默认就是使用的这个。\",\"FileHandler: 将日志直接写入到指定的文件中。\",\"SocketHandler: 将日志利用Socket通过网络发送到另一个主机。\",\"当然，一个Logger中可以包含多个Handler用于同时向不同的地方打印日志，我们可以通过getHandlers方法来获取Logger对象中已经配置的Handler对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(Arrays.toString(logger.getHandlers())); \",\"此时打印的列表中不存在任何Handler对象，可见，我们创建的Logger默认是不带任何Handler对象的\",\"那么我们之前的日志是怎么打印出来的呢？这实际上是Logger的父级提供的，这里我们先暂时不介绍继承关系。\",\"我们使用setUseParentHandlers方法来屏蔽所有父级提供的日志处理器：\",\"logger.setUseParentHandlers(false); \",\"现在由于Logger没有配置任何Handler处理器，因此我们打印日志就不会有任何效果。\"]},\"736\":{\"h\":\"\",\"t\":[\"我们可以来尝试自己配置一个用于控制台打印的Handler处理器，这里直接创建一个新的ConsoleHandler对象：\",\"ConsoleHandler handler = new ConsoleHandler(); logger.addHandler(handler); logger.info(\\\"Hello World\\\"); \",\"现在我们打印日志就可以出现想要的结果了：\",\"8月 28, 2024 12:12:37 上午 com.test.Main main 信息: Hello World \"]},\"737\":{\"h\":\"\",\"t\":[\"我们接着来尝试将日志记录到我们本地的文件中，这里使用FileHandler类型：\",\"FileHandler handler = new FileHandler(\\\"test.log\\\", true); //第二个参数开启后会续写已有的日志，如果不开启会直接覆盖重写 logger.addHandler(handler); \",\"最后我们就可以得到一个日志文件了，默认是以XML格式进行写入的：\",\"alt text\",\"这种格式有助于程序的日志读取，但是对于我们人来说，非常难以阅读，那有没有什么办法将文件的日志打印变成控制台那种格式呢？\"]},\"738\":{\"h\":\"修改输出格式\",\"t\":[\"实际上每一个Handler都有一个Formatter对象，它用于控制日志的格式，默认情况下，ConsoleHandler会配置一个SimpleFormatter对象，格式为：\",\"时间 类名 方法 日志级别: 日志内容 \",\"我们刚刚在FileHandler中见到的是默认生成的XMLFormatter，它会将日志以XML的形式进行打印，现在我们也可以手动修改它为SimpleFormatter类型：\",\"Handler handler = new FileHandler(\\\"test.log\\\"); handler.setFormatter(new SimpleFormatter()); \",\"此时日志文件中写入的内容就是简单的日志格式了\\n\"]},\"739\":{\"c\":[\"code\"]},\"740\":{\"c\":[\"javaweb\",\"JUL\"]},\"741\":{\"h\":\"javaweb - JUL日志3\"},\"742\":{\"h\":\"JUL日志系统3\"},\"743\":{\"h\":\"日志继承关系\"},\"744\":{\"h\":\"\",\"t\":[\"JUL中Logger之间存在父子关系，这种父子关系类似于继承，我们可以通过Logger的getParent方法来获取其父Logger对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent()); \",\"这里我们会得到一个：\",\"java.util.logging.LogManager$RootLogger@24d46ca6 \",\"这个RootLogger对象为所有日志记录器的最顶层父级对象，它包含一个默认的ConsoleHandler处理器用于进行控制台打印，而日志在打印时，子Logger会继承父Logger提供的所有Handler进行日志处理，因此我们在默认情况下才能正常使用日志打印：\",\"Logger logger = Logger.getLogger(\\\"test\\\"); Logger parent = logger.getParent(); System.out.println(Arrays.toString(parent.getHandlers())); \"]},\"745\":{\"h\":\"修改默认情况下的打印等级\",\"t\":[\"Handler是属于对应的Logger的，即继承的子Logger不能直接修改父Logger的Handler\",\"根据我们上节课学习的知识，在默认情况下如果我们需要修改日志打印等级，那么同时也需要将父级的Handler也进行日志等级配置：\",\"parent.getHandlers()[0].setLevel(Level.ALL); logger.setLevel(Level.ALL); logger.finest(\\\"test\\\"); \"]},\"746\":{\"h\":\"重复 问题\",\"t\":[\"当然，如果我们在不屏蔽父级Handler的情况下为子级配置一个Handler，那么此时两个Handler都会生效\",\"顺序：先子Logger, 再父Logger\",\"logger.addHandler(new ConsoleHandler()); logger.info(\\\"你干嘛\\\"); \",\"日志中出现了两次：\",\"8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 \",\"不过需要注意一下顺序，当父级和子级都配置时，那么子级的Handler优先进行处理，接着才是父级。\"]},\"747\":{\"h\":\"名称分级，自动构建继承关系\",\"t\":[\"除了默认的RootLogger作为父类，实际上Logger还会通过名称进行分级，自动构建一个继承关系，比如下面：\",\"Logger logger1 = Logger.getLogger(\\\"com\\\"); Logger logger2 = Logger.getLogger(\\\"com.test\\\"); Logger logger3 = Logger.getLogger(\\\"com.test.inner1\\\"); Logger logger4 = Logger.getLogger(\\\"com.test.inner2\\\"); System.out.println(logger4.getParent() == logger2); //全true System.out.println(logger3.getParent() == logger2); System.out.println(logger2.getParent() == logger1); \",\"就像包名一样，日志的名称会按照包的分级，进行自动继承，就像下面这个图一样：\",\"alt text\"]},\"748\":{\"c\":[\"code\"]},\"749\":{\"c\":[\"javaweb\",\"JUL\"]},\"750\":{\"h\":\"javaweb - JUL日志4\"},\"751\":{\"h\":\"JUL日志系统4\"},\"752\":{\"h\":\"日志默认配置\"},\"753\":{\"h\":\"格式\",\"t\":[\"Properties格式的文件是Java的一种配置文件，我们之前在学习Mybatis的时候学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？\",\"此时就可以使用Properties文件，它的格式如下：\",\"name=Test desc=Description \",\"该文件配置很简单，格式类似于我们Java中的Map键值对，中间使用等号进行连接。\",\"当然，键的名称我们也可以分为多级进行配置，每一级使用.进行划分，比如我们现在要配置数据库的连接信息，就可以编写为这种形式：\",\"jdbc.datasource.driver=com.cj.mysql.Driver jdbc.datasource.url=jdbc:mysql://localhost:3306/test jdbc.datasource.username=test jdbc.datasource.password=123456 \"]},\"754\":{\"h\":\"JAVA读取\",\"t\":[\"JDK为我们提供了一个叫做Properties的类型，它继承自Hashtable类（是HashMap的同步加锁版）\",\"使用起来和HashMap是差不多的：\",\"public class Properties extends Hashtable<Object,Object> {} \",\"相关操作：\",\"Properties properties = new Properties(); properties.load(new FileReader(\\\"test.properties\\\")); //使用load方法读取本地文件中的所有配置到Map中 System.out.println(properties); properties.get(xxx); \"]},\"755\":{\"h\":\"获取系统数据\",\"t\":[\"实际上，我们也可以通过这种方式来获取我们的一些系统属性\",\"System类中有一个getProperties方法用于存储所有系统相关的属性值，这里我们打印一下系统名称和版本：\",\"Properties properties = System.getProperties(); System.out.println(properties.get(\\\"os.name\\\")); System.out.println(properties.get(\\\"os.version\\\")); \",\"当然，程序中的Properties对象也可以快速保存为一个对应的.properties文件：\",\"Properties properties = System.getProperties(); properties.store(new FileWriter(\\\"system.properties\\\"), \\\"系统属性\\\"); \"]},\"756\":{\"h\":\"JUL设置默认配置\",\"t\":[\"实际上JUL也可以通过进行配置文件来规定日志打印器的一些默认值\",\"比如我们现在想配置默认的日志打印级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"接着我们需要在程序开始之前加载这里的配置：\",\"LogManager manager = LogManager.getLogManager(); //获取LogManager读取配置文件 manager.readConfiguration(new FileInputStream(\\\"test.properties\\\")); Logger logger = Logger.getLogger(\\\"test\\\"); logger.config(\\\"Hello World\\\"); \",\"这样就可以通过配置文件的形式修改一些功能的默认属性了，而不需要我们再使用代码进行配置。\",\"实际上在JUL的这类内部也有着对应的配置处理操作，如果发现有默认配置优先使用配置里面的，比如Handler的构造方法：\",\"Handler(Level defaultLevel, Formatter defaultFormatter, Formatter specifiedFormatter) { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); final Level level = manager.getLevelProperty(cname + \\\".level\\\", defaultLevel); final Filter filter = manager.getFilterProperty(cname + \\\".filter\\\", null); final Formatter formatter = specifiedFormatter == null ? manager.getFormatterProperty(cname + \\\".formatter\\\", defaultFormatter) : specifiedFormatter; final String encoding = manager.getStringProperty(cname + \\\".encoding\\\", null); ... } \",\"关于使用配置文件的形式修改JUL部分内容的默认值就先讲解到这里。\"]},\"757\":{\"c\":[\"code\"]},\"758\":{\"c\":[\"javaweb\",\"JUL\"]},\"759\":{\"h\":\"javaweb - JUL日志5\"},\"760\":{\"h\":\"JUL日志系统5\"},\"761\":{\"h\":\"自定义日志格式\",\"t\":[\"新建一个类，来继承Formatter，通过修改对应的format函数来实现自定义\",\"每一个Handler都可以配置一个对应的Formatter来决定日志打印的格式，除了官方为我们提供的两种默认格式外，我们也可以自定义我们想要的日志打印格式。\",\"我们只需要继承Formatter类，就可以创建一个自定义的日志格式处理逻辑了：\",\"public class MyFormatter extends Formatter { @Override public String format(LogRecord record) { return \\\"我是自定义日志格式\\\"; } } \",\"其中参数为LogRecord，它提供了当前日志记录的相关信息，比如：\",\"@Override public String format(LogRecord record) { System.out.println(\\\"所在类: \\\" + record.getSourceClassName()); System.out.println(\\\"方法名称: \\\" + record.getSourceMethodName()); System.out.println(\\\"日志级别: \\\" + record.getLevel().getLocalizedName()); return \\\"我是自定义日志格式\\\"; } \"]},\"762\":{\"h\":\"修改对应\"},\"763\":{\"h\":\"手动修改\",\"t\":[\"Logger logger = Logger.getLogger(\\\"com.test\\\"); logger.getParent().getHandlers()[0].setFormatter(new MyFormatter()); \"]},\"764\":{\"h\":\"配置文件修改\",\"t\":[\"直接把ConsoleHandler的默认Formatter配置为我们自己的类：\",\"java.util.logging.ConsoleHandler.formatter=com.test.MyFormatter \"]},\"765\":{\"h\":\"自定义例子\",\"t\":[\"因此，我们也可以利用这些属性来编写一个类似于的SimpleFormatter的日志格式，比如这里包含类名、时间等，类似于下面图中的日志格式：\",\"alt text\",\"我们来尝试编写一下：\",\"public String format(LogRecord record) { StringBuilder builder = new StringBuilder(); //日期 Date date = new Date(record.getMillis()); SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss.SSS\\\"); builder.append(dateFormat.format(date)); //级别 builder.append(\\\" \\\").append(record.getLevel()); builder.append(\\\" --- \\\"); //线程名称 builder.append('[').append(Thread.currentThread().getName()).append(']'); //类名称 builder.append(\\\" \\\").append(String.format(\\\"%-15s\\\", record.getSourceClassName())); //消息内容 builder.append(\\\" : \\\").append(record.getMessage()); return builder.toString(); } \"]},\"766\":{\"h\":\"第三方框架兼容性\",\"t\":[\"我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？\",\"前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter\"]},\"767\":{\"h\":\"日志注解\",\"t\":[\"同样的，Logger也是可以使用Lombok快速生成的。\",\"@Log public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \",\"只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。\",\"我们也可以手动指定名称：\",\"@Log(topic = \\\"打工是不可能打工的\\\") public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \"]},\"768\":{\"h\":\"日志\",\"t\":[\"我们接着来看Mybatis，经过前面的学习，我们知道，Mybatis也有日志系统，它详细记录了所有的数据库操作等，要开启日志系统，我们需要进行配置：\",\"<setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\" /> \",\"logImpl包括很多种配置项 包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\",\"而默认情况下是未配置，也就是说不打印。\",\"将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台\",\"现在我们也可以将其设置为JDK提供的日志框架：\",\"<setting name=\\\"logImpl\\\" value=\\\"JDK_LOGGING\\\" /> \",\"将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低\",\"因此我们需要设置一下logging.properties默认的日志级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"这样，Mybatis就可以正确使用JDK的日志框架进行日志打印了，只不过格式稍微有点炸裂，可能还是得我们自己编写一个自定义的Formatter才行。\"]},\"769\":{\"c\":[\"code\"]},\"770\":{\"c\":[\"javaweb\",\"JUL\"]},\"771\":{\"h\":\"javaweb - JUnit1\"},\"772\":{\"h\":\"JUnit单元测试1\"},\"773\":{\"h\":\"单元测试\",\"t\":[\"在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目，比如：\",\"public class Main { public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); func1(); func2(); func3(); } private static void func1() { System.out.println(\\\"我是第一个功能\\\"); } private static void func2() { System.out.println(\\\"我是第二个功能\\\"); } private static void func3() { System.out.println(\\\"我是第三个功能\\\"); } } \",\"如果现在我们想单独测试某一个功能的对应方法，而不是让整个项目完全跑起来，这就非常麻烦了。\",\"而单元测试则可以针对某一个方法直接进行测试执行，无需完整启动项目。\",\"alt text\",\"同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。\",\"我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。\"]},\"774\":{\"h\":\"JUnit使用\"},\"775\":{\"h\":\"导入依赖\",\"t\":[\"现在用的是JUnit5, 感觉没学到maven，找jar包花了点时间\",\"alt text\",\"同时IDEA需要安装JUnit插件（终极版默认是已经捆绑安装的，因此无需多余配置），安装好之后，我们就可以直接上手使用了\"]},\"776\":{\"h\":\"使用- 注解\",\"t\":[\"使用方式很简单，只需添加一个@Test注解即可快速创建新的测试用例，这里我们尝试新建一个类用于单元测试：\",\"public class MainTest { } \",\"接着就可以编写我们的测试用例了，现在我们需要创建一个public的无参无返回值方法（不能是静态方法）并在方法内编写我们的需要进行测试的代码：\",\"public void test1(){ Main.func1(); } \",\"最后在方法上添加@Test注解，此时IDEA会提示我们可以运行，旁边出现运行按钮：\",\"alt text\",\"接着点击运行，就可以直接执行我们的测试方法了，然后可以在控制台看到当前的测试用例耗时以及状态：\",\"alt text\",\"一个测试类中可以同时有多个测试案例：\",\"public class MainTest { @Test public void test1(){ Main.func1(); } @Test public void test2(){ Main.func2(); } @Test public void test3(){ Main.func3(); } } \",\"我们只需要点击类旁边的运行按钮，就可以直接执行当前类中所有的测试案例\"]},\"777\":{\"h\":\"跳过某个测试 -\",\"t\":[\"有些时候，可能我们并不想开启其中某个测试用例，我们也可以使用@Disable来关闭某一个测试用例：\",\"@Test @Disabled public void test2(){ } \",\"此时再次全部运行，将忽略二号测试案例进行测试\",\"alt text\"]},\"778\":{\"h\":\"测试自定义名称 -\",\"t\":[\"我们还可以为测试案例添加一个自定义的名称，不然测试案例一多我们就分不清楚到底哪个案例是干嘛的\",\"我们需要使用@DisplayName注解来为其命名：\",\"@Test @DisplayName(\\\"一只企鹅\\\") public void test1(){} \",\"这样我们的控制台也可以看到对应的名称：\",\"alt text\"]},\"779\":{\"h\":\"预设的名称生成器 -\",\"t\":[\"Junit还提供了一些预设的名称生成器，按照一定规则进行名称处理，可以通过@DisplayNameGeneration注解来配置使用，列表如下：\",\"显示名称生成器\",\"行为\",\"Standard\",\"方法名称作为测试名称。\",\"Simple\",\"同上，但是会删除无参数方法的尾随括号。\",\"ReplaceUnderscores\",\"同上，但是会用空格替换方法名称中的下划线。\",\"IndicativeSentences\",\"包含类名和方法名称连接之后的名称。\"]},\"780\":{\"h\":\"判断测试是否成功 — 断言\",\"t\":[\"当然，对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过，我们可以通过断言工具类Assertions来对结果进行判定：\",\"@Test public void test1(){ Random random = new Random(); int value = random.nextInt() % 2; //生成一个随机数，进行对2取余操作 Assertions.assertEquals(1, value); //如果是单数则匹配成功，如果不是则匹配失败 } \",\"当测试案例失败时，控制台会出现应该AssertionFailedError错误，同时IDEA也会提示我们测试失败\",\"alt text\"]},\"781\":{\"c\":[\"code\"]},\"782\":{\"c\":[\"javaweb\",\"JUL\"]},\"783\":{\"h\":\"javaweb - JUnit2\"},\"784\":{\"h\":\"JUnit单元测试2\"},\"785\":{\"h\":\"断言工具\",\"t\":[\"JUnit提供了非常多的断言操作，相比JUnit 4，它们都被封装在一个新的Assertions类中\",\"这些断言操作基本上都是用于判断某个测试结果是否符合我们的预期情况\"]},\"786\":{\"h\":\"值判断\",\"t\":[\"其中最简单的就是判断结果是否等于某个值\",\"Assertions.assertEquals(expected, actual, message)\",\"@Test public void test1(){ int a = 10, b = 5; int c = a + b; //判断结果是否相等，前面的是预期结果，后面的就是实际结果 Assertions.assertEquals(15, c); } \",\"当断言操作发现实际结果与预期不符时，会直接抛出异常告诉我们这个测试案例没有通过，并最终以失败状态结束。我们也可以为本次断言添加一个message来助于我们快速了解是什么类型的测试结果出现问题：\",\"Assertions.assertEquals(14, c, \\\"计算结果验证\\\"); \",\"此时控制台就会得到：\",\"alt text\"]},\"787\":{\"h\":\"真假判断\",\"t\":[\"Assertions.assertTure(condition, message)\",\"除了使用值进行比较外，我们也可以直接对某个boolean类型的结果快速进行判断，使用assertTrue方法：\",\"Assertions.assertTrue(14 == c, \\\"计算结果验证\\\"); \"]},\"788\":{\"h\":\"对象判断\",\"t\":[\"与其相似的还有两个相同对象的判断：\",\"Assertions.assertSame(999, 999); //判断两个值是否为同一个对象 \"]},\"789\":{\"h\":\"复杂判断\",\"t\":[\"如果判断流程比较复杂，我们也可以使用Java8的Lambda来编写结果判断逻辑，提供一个BooleanSupplier对象：\",\"Assertions.assertTrue(() -> { if(c < 10) return true; if(c > 20) return false; return c == 15; }, \\\"计算结果验证\\\"); \",\"对于更加复杂的组合结果判断，我们还可以使用assertAll来包含多个判断操作：\",\"Assertions.assertAll(\\\"整体测试\\\", () -> Assertions.assertTrue(c == 14), () -> Assertions.assertTrue(c > 10), () -> Assertions.assertTrue(c < 20) ); \",\"进行整体测试时，所有的测试结果将合并到一起输出。\"]},\"790\":{\"h\":\"异常判断\",\"t\":[\"除了我们上面提到的真假判断外，还有很多不同类型的结果判断，比如异常判断，我们希望这个案例抛出指定的异常：\",\"Assertions.assertThrows(IOException.class, () -> { System.out.println(1/0); }, \\\"此测试案例并未抛出指定异常\\\"); \",\"由于此时抛出的是一个ArithmeticException并不是我们需要的IOException或是其子类，所以说断言失败：\",\"alt text\",\"除了上述例子中出现的断言方法之外，JUnit还提供了上百种断言方法供大家使用，这里就不挨个介绍了。\"]},\"791\":{\"h\":\"假设工具\",\"t\":[\"除了断言工具外，对于一些不影响结果的测试\",\"我们可以使用“假设”工具来实现对结果的判断但不作为测试结果的判断依据，它通常在执行给定测试没有意义时使用。\",\"public void test1(){ Assumptions.assumeTrue(1 == 3); } \",\"测试结果中会将其显示为已忽略，而不是失败：\",\"alt text\"]},\"792\":{\"h\":\"条件测试和执行\",\"t\":[\"有些时候我们可能需要配置各种条件来执行某些测试案例\",\"比如某些测试案例必须在指定JDK版本执行，或是某些案例只需要在某个特定操作系统执行\",\"Junit支持我们就为测试案例设置条件来实现这些功能。\"]},\"793\":{\"h\":\"指定操作系统 -\",\"t\":[\"比如，我们要限制某个测试案例只在指定操作系统下进行，那么就可以使用@EnabledOnOs来指定：\",\"@Test @EnabledOnOs(OS.MAC) public void test1(){ System.out.println(\\\"我是只在Mac下执行的测试案例\\\"); } @Test @EnabledOnOs(OS.WINDOWS) //@DisabledOnOs(OS.MAC) 或是使用相反注解来为指定操作系统关闭此用例 public void test2(){ System.out.println(\\\"我是只在Windows下执行的测试案例\\\"); } \",\"这样，当我们在指定操作系统下执行时，此测试案例才会启动，否则会直接忽略：\",\"alt text\"]},\"794\":{\"h\":\"指定JDK版本\",\"t\":[\"同样的，如果我们要指定在某个JDK版本执行测试案例，也可以使用@EnabledOnJre来进行指定：\",\"@Test @EnabledOnJre(JRE.JAVA_8) //@DisabledOnJre(JRE.JAVA_8) 或是使用相反的注解来为指定JDK关闭 public void test1(){ System.out.println(\\\"我是只在Java8下执行的测试案例\\\"); } @Test @EnabledOnJre(JRE.JAVA_17) public void test2(){ System.out.println(\\\"我是只在Java17下执行的测试案例\\\"); } \"]},\"795\":{\"h\":\"指定JDK版本范围\",\"t\":[\"或是一个指定的JDK版本范围：\",\"@Test @EnabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_17) public void test1(){ System.out.println(\\\"我是只在Java8-17下执行的测试案例\\\"); } \",\"除了这种简单判断外，我们还可以直接从系统属性中获取我们需要的参数来进行判断。\",\"使用System.getProperties()来获取所有的系统属性，包括系统的架构、版本、名称等信息。下面注解主要就是利用这个函数来进行判断\"]},\"796\":{\"h\":\"系统属性判断\",\"t\":[\"使用@EnabledIfSystemProperty来对系统属性进行判断：\",\"@Test @EnabledIfSystemProperty(named = \\\"os.arch\\\", matches = \\\"aarch64\\\") //其中matches参数支持正则表达式 public void test1(){ System.out.println(\\\"我是只在arm64架构下做的测试\\\"); } \",\"当然，有时候为了方便，我们也可以直接读取环境变量：\",\"@Test @EnabledIfEnvironmentVariable(named = \\\"TEST_STR\\\", matches = \\\"666\\\") public void test1(){ System.out.println(\\\"我是只在环境变量: TEST_STR = 666\\\"); } \"]},\"797\":{\"h\":\"自定义方法\",\"t\":[\"如果你认为这还不够灵活，你还可以直接声明一个自定义方法来进行判断：\",\"@Test @EnabledIf(\\\"testCondition\\\") public void test1(){ System.out.println(\\\"我是自定义的测试条件\\\"); } public boolean testCondition() { return 1 > 0; } \",\"条件方法可以位于测试类之外。在这种情况下，它必须用其完全限定的名称来引用\",\"@EnabledIf(\\\"example.ExternalCondition#customCondition\\\") \",\"class ExternalCondition { /** * 在几种情况下，条件方法需要static： * 当@EnabledIf或@DisabledIf在类上使用时 * 当@EnabledIf或@DisabledIf用于@ParameterizedTest或@TestTemplate方法时 * 当条件方法位于外部类中时 */ static boolean customCondition() { return true; } } \"]},\"798\":{\"c\":[\"code\"]},\"799\":{\"c\":[\"javaweb\",\"JUL\"]},\"800\":{\"h\":\"javaweb - JUnit2\"},\"801\":{\"h\":\"JUnit单元测试3\"},\"802\":{\"h\":\"生命周期\",\"t\":[\"@BeforeAll@AferAll@BeforeEach@AfterEach\",\"其中 @BeforeAll 必须是static方法\",\"我们可以自由设定某些操作在测试开始之前或之后执行，比如测试前的准备工作或是测试后的收尾工作：\",\"@Test public void test1() { System.out.println(\\\"我是测试方法1\\\"); } @BeforeAll //使用BeforeAll必须为static方法 public static void start() { System.out.println(\\\"我是测试前必须要执行的准备工作\\\"); } \",\"其中，@BeforeAll表示此准备工作在所有测试用例执行之前执行，这样，当测试开始前，会优先进行指定的准备工作，防止准备不足导致的测试失败。\",\"相反的，@AfterAll则会在所有测试用例完成之后执行。\",\"除了在所有方法执行前后插入准备工作，我们也可以为所有的方法单个插入准备工作：\",\"@BeforeEach //使用BeforeEach不能为static方法 public void start() { System.out.println(\\\"我是测试前必须要执行的准备工作\\\"); } \",\"这样，在每个测试用例执行之前，都会执行一次这里的准备工作\"]},\"803\":{\"h\":\"测试类的生命周期\",\"t\":[\"我们接着来了解一下测试类的生命周期。\",\"默认情况下，执行测试实际上也会对类进行实例化，并通过实例化对象来调用其中的测试方法，并且，每一个测试用例执行之前，都会创建一个新的对象，而不是直接执行：\",\"public class TestMain { public TestMain() { System.out.println(\\\"构造函数\\\"); } @Test public void test() { System.out.println(\\\"Test1\\\"); } @Test public void test1() { System.out.println(\\\"Test2\\\"); } } \",\"像这样，我们可以得到这样的输出结果：\",\"alt text\",\"每次执行测试用例都会创建一个新的对象来执行，这在某些场景下可能会显得不太方便，比如初始化类需要花费大量时间或是执行非常费时的IO操作时，这会导致我们要花费大量时间来等待每次测试用例的初始化操作。\",\"我们也可以手动修改测试类的初始化行为，默认情况下为PER_METHOD模式：\",\"@TestInstance(TestInstance.Lifecycle.PER_CLASS) public class MainTest {} \",\"将其修改为PER_CLASS模式后，初始化操作只会执行一次，因为现在是以类为单位：\",\"alt text\",\"当然，如果依然对测试用例执行前后有其他准备工作需求，也可以使用之前的@BeforeEach和@AfterEach来实现灵活控制。\"]},\"804\":{\"h\":\"测试顺序控制\",\"t\":[\"有些时候我们可能需要控制某些测试案例的顺序\",\"默认情况下，所有的测试案例都是按照方法的名称顺序来进行的，比如：\",\"@Test public void test3() { //按照名称顺序，虽然这里是第一个定义的，但是它是第三个 System.out.println(\\\"我是测试用例3\\\"); } @Test public void test1() { System.out.println(\\\"我是测试用例1\\\"); } @Test public void test2() { System.out.println(\\\"我是测试用例2\\\"); } \",\"除了默认的名称顺序之外，JUnit提供了以下顺序：\",\"MethodOrderer.DisplayName：根据显示名称对测试方法进行字母数字排序（请参阅显示名称生成优先级规则）\",\"MethodOrderer.MethodName：根据测试方法的名称和形式参数列表，以字母数字排序\",\"MethodOrderer.OrderAnnotation：根据通过@Order注释指定的值对测试方法进行数值排序\",\"MethodOrderer.Random：伪随机排序测试方法，并支持自定义种子的配置\",\"其中，注解顺序可以由我们自己通过注解来手动定义执行顺序：\",\"@Test @Order(1) void nullValues() { // perform assertions against null values } \"]},\"805\":{\"h\":\"嵌套测试 -\",\"t\":[\"有些时候我们可能需要对测试用例进行进一步的分层，比如用户相关的测试全部归为一个组，而管理相关的测试全部归为一个组\",\"此时我们可以使用嵌套测试，通过在类中定义多个内部类来完成：\",\"public class MainTest { @Test public void test() { System.out.println(\\\"我是外部测试类型\\\"); } @Nested class Test1 { @Test public void test1_1() { System.out.println(\\\"我是内部测试类型1-1\\\"); } @Test public void test1_2() { System.out.println(\\\"我是内部测试类型1-2\\\"); } } @Nested class Test2 { @Test public void test2_1() { System.out.println(\\\"我是内部测试类型2-1\\\"); } @Test public void test2_2() { System.out.println(\\\"我是内部测试类型2-2\\\"); } } } \",\"此时测试的结果展示也是嵌套的样式：\",\"alt text\",\"注意，当我们在嵌套测试中使用诸如@BeforeEach、@BeforeAll这种注解时(就是写到里面)，它仅会作用于所属内部类中的所有测试用例，而不是包含外部类中和其他内部类中的全部测试用例，写到外面还是全部\",\"嵌套类的执行同样可以通过@TestClassOrder来控制嵌套类的执行顺序。\"]},\"806\":{\"h\":\"重复和参数化测试\",\"t\":[\"对于某些存在随机性的测试案例，我们可能需要多次执行才能确定其是否存在某些问题\"]},\"807\":{\"h\":\"重复测试\",\"t\":[\"比如某个案例存在一个BUG，导致其10次里面会有1次出现错误，现在我们想要保证其10次都不会出现问题才算通过，此时我们就可以使用重复测试案例来使其多次执行：\",\"@RepeatedTest(10) public void test1() { Random random = new Random(); if (random.nextInt(10) == 0) { throw new IllegalStateException(); } } \",\"此时会重复执行10次此案例，并且当每一次执行都没有出现问题时，才会正常通过.\"]},\"808\":{\"h\":\"参数化测试 +\",\"t\":[\"某些测试可能并不是固定单个输入参数，有时我们可能也需要对多个输入参数进行测试，来做到全方面的问题排查。\",\"它与重复测试比较类似，但是参数可以由我们自己决定，并且每个参数都会进行一次测试：\",\"@ParameterizedTest //使用此注解来表示此测试是一个参数化测试 @ValueSource(strings = { \\\"aa\\\", \\\"bb\\\", \\\"ccc\\\" }) //指定参数列表 public void test1(String str) { //需要添加一个参数 if (str.length() == 3) { throw new IllegalStateException(); } } \",\"这里我们使用@ValueSource来进行参数来源设定，也就是需要进行测试的参数列表\",\"接着下面会根据参数挨个执行此测试用例，保证每一种情况都正常执行\",\"这里的@ValueSource是最简单的一种参数设定，我们可以直接设置一系列值，支持以下类型：\",\"short、byte、int、long、float、double、char、boolean、java.lang.String、java.lang.Class\"]},\"809\":{\"h\":\"空值\",\"t\":[\"除了直接设置指定类型常量值，我们也可以传入空值或是一些为空的字符串、数组等：\",\"@ParameterizedTest @NullSource //将值设置为null进行测试 public void test1(String str) {} \",\"@ParameterizedTest @EmptySource //将值设置为空进行测试，如空字符串、空数组、空集合等 public void test1(int[] arr) {} \",\"@NullAndEmptySource：结合了@NullSource和@EmptySource两个注解的功能。\"]},\"810\":{\"h\":\"枚举值\",\"t\":[\"我们也可以使用枚举值来进行测试，比如我们希望测试某个枚举类型下所有的枚举作为参数进行测试：\",\"enum Type { SMALL, MEDIUM, LARGE } @ParameterizedTest @EnumSource(Type.class) //这将依次测试枚举类中的所有枚举 public void test1(Type type) { System.out.println(type); } \",\"或是指定某些枚举常量：\",\"@ParameterizedTest //模式默认为INCLUDE，即使用指定的枚举常量进行测试 @EnumSource(mode = EnumSource.Mode.INCLUDE, names = { \\\"SMALL\\\", \\\"LARGE\\\" }) public void test1(Type type) { System.out.println(type); } \"]},\"811\":{\"h\":\"特定的方法来生成参数\",\"t\":[\"除了以上方式获取参数，我们也可以使用特定的方法来生成我们需要的测试参数，只需要添加@MethodSource注解即可指定方法：\",\"@ParameterizedTest @MethodSource(\\\"stringProvider\\\") public void test1(String str) { System.out.println(str); } static List<String> stringProvider() { return List.of(\\\"apple\\\", \\\"banana\\\"); } \",\"方法的返回值可以是任何可迭代（Iterable）内容，如数组、集合类、Stream等。同样的，对于其他类中的方法，需要和之前一样使用完全限定的方法名称来引用。\"]},\"812\":{\"h\":\"字段\",\"t\":[\"和方法一样，字段同样可以作为参数的来源，但它必须是静态的：\",\"static List<String> list = List.of(\\\"AAA\\\", \\\"BBB\\\"); @ParameterizedTest @FieldSource(\\\"list\\\") public void test1(String str) { System.out.println(str); } \",\"不仅仅是一个普通的集合或是数组可以作为字段参数来源，如Supplier这种懒加载的数据，也可以作为参数来源：\",\"static Supplier<List<String>> list = () -> List.of(\\\"AAA\\\", \\\"BBB\\\"); @ParameterizedTest @FieldSource(\\\"list\\\") public void test1(String str) { System.out.println(str); } \",\"当然，JUnit还支持从CSV表格中导入或自定义参数提供器等，这里就不做详细介绍了\",\"官方文档：https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-ArgumentsSource\"]},\"813\":{\"c\":[\"code\"]},\"814\":{\"c\":[\"javaweb\",\"JUL\"]},\"815\":{\"h\":\"Maven1 - 简介与项目结构\"},\"816\":{\"h\":\"Maven1 - 简介与项目结构\"},\"817\":{\"h\":\"简介\",\"t\":[\"Maven 翻译为\\\"专家\\\"、\\\"内行\\\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\",\"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。\",\"Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\",\"通过Maven，可以帮助我们做：\",\"项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。\",\"依赖管理，项目使用到哪些依赖，可以快速完成导入，不需要手动导入jar包。\",\"Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装。\"]},\"818\":{\"h\":\"Maven项目结构\",\"t\":[\"Maven就很好地解决了这个问题，我们可以先来看一下，一个Maven项目和我们普通的项目有什么区别：\",\"alt text\",\"其中src目录下存放我们的源代码和测试代码，分别位于main和test目录下\",\"而test和main目录下又具有java、resources目录，它们分别用于存放Java源代码、静态资源（如配置文件、图片等），测试代码不会打包到项目里面，只仅用于测试。\",\"很多JavaWeb项目可能还会用到webapp目录。\"]},\"819\":{\"h\":\"核心配置\",\"t\":[\"而下面的pom.xml则是Maven的核心配置，也是整个项目的所有依赖、插件、以及各种配置的集合，它也是使用XML格式编写的，一个标准的pom配置长这样：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.test</groupId> <artifactId>HelloWorld</artifactId> <version>1.0-SNAPSHOT</version> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> </project> \",\"我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。\"]},\"820\":{\"h\":\"项目标识\",\"t\":[\"groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目\",\"别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标\",\"所有的项目一般都有自己的Maven坐标\",\"因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入：\",\"groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。\",\"artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。\",\"version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）\",\"properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为17，同时下面的源代码编码格式为UTF-8，无需进行修改。\"]},\"821\":{\"c\":[\"code\"]},\"822\":{\"c\":[\"javaweb\",\"Maven\"]},\"823\":{\"h\":\"Maven2 - 依赖导入\"},\"824\":{\"h\":\"Maven2\"},\"825\":{\"h\":\"Maven依赖导入\",\"t\":[\"我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？\",\"我们可以创建一个dependencies节点：\",\"<dependencies> //里面填写的就是所有的依赖 </dependencies> \",\"那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？\",\"我们可以在：https://central.sonatype.com 进行查询\",\"直接搜索Lombok即可，打开后可以看到已经给我们写出了依赖的坐标：\",\"<dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.36</version> </dependency> \",\"我们直接将其添加到dependencies节点中即可\",\"现在我们来编写一个测试用例看看依赖导入成功了没有：\",\"public class Main { public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18); System.out.println(student); } } \",\"@Data @AllArgsConstructor public class Student { String name; int age; } \",\"项目运行成功，表示成功导入了依赖。\"]},\"826\":{\"h\":\"Maven依赖管理原理\",\"t\":[\"那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程：\",\"alt text\",\"通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（可以自行搭建私服）\",\"几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（因此Maven第一次导入依赖是需要联网的，否则无法下载）\",\"远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题。\",\"在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。\"]},\"827\":{\"h\":\"修改国内镜像源\",\"t\":[\"注意： 因为中心仓库服务器位于国外，下载速度缓慢，可能在导入依赖时会出现卡顿等问题，我们需要使用国内的镜像仓库服务器来加速访问（镜像仓库与中心仓库自动同步所有依赖，访问速度更快）有两种方式配置：\",\"可以配置IDEA自带的Maven插件远程仓库镜像地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑，找到mirros标签，添加以下内容：\",\"<mirror> <id>aliyunmaven</id> <mirrorOf>central</mirrorOf> <name>阿里云公共仓库</name> <url>https://maven.aliyun.com/repository/public</url> </mirror> \",\"自行前往Maven官网并下载最新版的Maven安装，然后将IDEA的Maven配置为我们自行安装的位置（好处是IDEA更新后不需要重新配置）可以一直使用，镜像配置方式同第1步。\",\"这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了）\"]},\"828\":{\"c\":[\"code\"]},\"829\":{\"c\":[\"javaweb\",\"Maven\"]},\"830\":{\"h\":\"Maven3 - 依赖作用域\"},\"831\":{\"h\":\"Maven3 - 依赖作用域\"},\"832\":{\"h\":\"Maven依赖作用域\",\"t\":[\"除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：\",\"type：依赖的类型，对于项目坐标定义的packaging。 大部分情况下，该元素不必声明，其默认值为jar\",\"scope：依赖的范围（作用域，着重讲解）\",\"optional：标记依赖是否可选\",\"exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）\"]},\"833\":{\"h\":\"属性\",\"t\":[\"我们着重来讲解一下scope属性，它决定了依赖的作用域范围：\",\"compile ：默认的依赖有效范围，如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围，此范围表示在编译、运行、测试时均有效。\",\"provided ：仅在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖 比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。\",\"runtime ：在运行、测试时有效，但是在编译代码时无效。 比如JDBC驱动就是典型的只需要运行时使用，因为JDBC驱动由数据库厂商开发，我们使用的始终是JDK中提供的接口，不需要直接使用特定驱动中的类或是方法，因此只需在运行时包含即可。\",\"test ：只在测试时有效 例如：JUnit框架，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，所以这个选项非常适合测试相关的框架。\"]},\"834\":{\"h\":\"测试导入\",\"t\":[\"这里我们来测试一下JUnit，我们可以在网站上搜索JUnit的依赖，我们这里导入最新的JUnit5作为依赖：\",\"<dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> \",\"我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用：\",\"public class MainTest { @Test public void test(){ System.out.println(\\\"测试\\\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); } } \",\"因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖：\",\"<dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> \",\"我们发现，Maven还给我们提供了一个resource目标，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <settings> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/> <setting name=\\\"cacheEnabled\\\" value=\\\"true\\\"/> <setting name=\\\"logImpl\\\" value=\\\"JDK_LOGGING\\\" /> </settings> <!-- 需要在environments的上方 --> <typeAliases> <package name=\\\"com.test.entity\\\"/> </typeAliases> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.cj.jdbc.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/web_study\\\"/> <property name=\\\"username\\\" value=\\\"test\\\"/> <property name=\\\"password\\\" value=\\\"123456\\\"/> </dataSource> </environment> </environments> <mappers> <mapper class=\\\"com.test.mapper.TestMapper\\\"/> </mappers> </configuration> \",\"现在我们创建一下测试用例，顺便带大家回顾一下JUnit5的使用：\",\"public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\\\"mybatis.xml\\\")); } @DisplayName(\\\"Mybatis数据库测试\\\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } } } \"]},\"835\":{\"h\":\"第四个作用域 - 导入本地jar包\",\"t\":[\"那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？\",\"我们可以使用第四种作用域：\",\"system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包。\",\"<dependency> <groupId>javax.jntm</groupId> <artifactId>lbwnb</artifactId> <version>2.0</version> <scope>system</scope> <systemPath>C://学习资料/4K高清无码/test.jar</systemPath> </dependency> \",\"比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。\"]},\"836\":{\"c\":[\"code\"]},\"837\":{\"c\":[\"javaweb\",\"Maven\"]},\"838\":{\"h\":\"Maven4 - 导入本地依赖\"},\"839\":{\"h\":\"Maven4 - 导入本地依赖\"},\"840\":{\"h\":\"Maven项目导入自己项目\",\"t\":[\"如何在其他项目中引入我们自己编写的Maven项目作为依赖使用。\",\"这里我们创建一个用于测试的简单项目：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.0-SNAPSHOT</version> ... </project> \",\"public class TestUtils { public static void test() { System.out.println(\\\"抛开事实不谈，你们就没有一点错吗？\\\"); } } \",\"接着我们点击右上角的Maven选项\",\"然后执行install或直接在命令行中输入mvn install来安装我们自己的项目到本地Maven仓库中。\",\"接着我们就可以在需要使用此项目作为依赖的其他项目中使用它了，只需要填写和这边一样的坐标：\",\"<dependency> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"接着我们就可以在项目中直接使用了：\",\"public static void main(String[] args) { TestUtils.test(); } \"]},\"841\":{\"h\":\"依赖传递\",\"t\":[\"注意，如果我们的旧项目中引入了一些其他的依赖，那么此依赖是会一起被传递的\",\"比如这里我们添加了MyBatis的依赖到原项目中：\",\"<dependencies> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.16</version> </dependency> </dependencies> \",\"此时在引入此项目的其他项目中，此依赖也被一起传递\",\"也就是说，当我们的项目依赖于其他内容时，为了保证完整性，默认情况下会一并引入所有此项目包含的依赖项。\"]},\"842\":{\"h\":\"可选依赖\",\"t\":[\"作用在被导入的项目中\",\"在某些情况下，可能我们并不希望某些依赖直接被项目连带引入，因此，当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的\",\"默认在导入依赖时，不会导入可选的依赖：\",\"<optional>true</optional> \",\"比如Mybatis的POM文件中，就存在大量的可选依赖：\",\"<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.30</version> <optional>true</optional> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.7.30</version> <optional>true</optional> </dependency> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.17</version> <optional>true</optional> </dependency> ... \",\"由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。\"]},\"843\":{\"h\":\"排除依赖中的不必要依赖\",\"t\":[\"作用在我们自己的项目中\",\"现在我们可以让使用此项目作为依赖的项目不使用可选依赖，但是如果别人的项目中没有将我们不希望的依赖作为可选依赖，这就导致我们还是会连带引入这些依赖\",\"这个时候我们就可以通过排除依赖来防止添加不必要的依赖，只需添加exclusion标签即可：\",\"<dependency> <groupId>com.test</groupId> <artifactId>TestMaven</artifactId> <version>1.1-SNAPSHOT</version> <exclusions> <exclusion> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <!-- 可以不指定版本号，只需要组名和项目名称 --> </exclusion> </exclusions> </dependency> \",\"此时我们通过这种方式手动排除了Test项目中包含的MyBatis依赖，这样项目中就不会包含此依赖了。\"]},\"844\":{\"c\":[\"code\"]},\"845\":{\"c\":[\"javaweb\",\"Maven\"]},\"846\":{\"h\":\"Maven5 - 继承和多模块 + 测试和打包\"},\"847\":{\"h\":\"Maven5 - 继承、多模块 + 测试和打包\"},\"848\":{\"h\":\"Maven继承和多模块\"},\"849\":{\"h\":\"继承\",\"t\":[\"一个Maven项目可以继承自另一个Maven项目\",\"比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。\",\"在我们学习到SpringBoot或是SpringCloud开发时，很多项目往往都会采用这种多模块子项目的形式的去编写，来更加合理地对项目中代码进行职责划分。\",\"(在一个项目内部在创建一个项目就行) 要创建一个子项目非常简单，我们只需右键左侧栏，新建模块，来创建一个子项目：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <parent> <artifactId>MavenTest</artifactId> <groupId>org.example</groupId> <version>1.0-SNAPSHOT</version> </parent> <modelVersion>4.0.0</modelVersion> <artifactId>ChildModel</artifactId> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> </properties> </project> \",\"我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目\",\"子项目直接继承父项目的groupId，子项目会继承父项目的所有依赖，我们来编写一个测试用例尝试一下:\",\"import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\\\"我是日志信息\\\"); } } \",\"可以看到，子项目也成功继承了Lombok依赖。\"]},\"850\":{\"h\":\"多模块\",\"t\":[\"我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理\",\"我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。\",\"<dependencyManagement> <dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.22</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> </dependencies> </dependencyManagement> \",\"我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可：\",\"<dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <scope>provided</scope> </dependency> </dependencies> \",\"当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承：\",\"<dependencies> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.1</version> <scope>test</scope> </dependency> </dependencies> <dependencyManagement> <dependencies> ... \"]},\"851\":{\"h\":\"Maven测试和打包\",\"t\":[\"我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期\",\"实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：\",\"clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。\",\"validate命令可以验证项目的可用性。\",\"compile命令可以将项目编译为.class文件。\",\"install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用\",\"verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等）\",\"所有的命令在执行完成之后都会显示BUILD SUCCESS，否则就是在执行过程中出现了什么错误。\"]},\"852\":{\"h\":\"命令\",\"t\":[\"除了上述介绍的几种命令外，我们还可以通过使用test命令，一键测试所有位于test目录下的测试案例，但是请注意默认的test命令有以下要求：\",\"测试类的名称必须是以Test结尾，比如MainTest\",\"测试方法上必须标注@Test注解或是其他标记JUnit测试案例的注解\",\"public class MainTest { @Test public void test() { System.out.println(\\\"我是测试\\\"); } } \"]},\"853\":{\"h\":\"命令\",\"t\":[\"我们接着来看package命令，它用于将我们的项目打包为jar文件，以供其他项目作为依赖引入，或是作为一个可执行的Java应用程序运行。\",\"我们可以直接点击package来进行打包操作。\",\"注意，在使用package命令打包之前也会自动执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过\",\"选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true来以跳过测试的方式进行打包。\",\"接着在target目录下会出现我们打包完成的jar包，在JavaSE中我们就给大家介绍过\",\"一个jar包实际上就是对我们生成的字节码文件进行的压缩打包，因此，我们也可以使用常见的压缩工具打开jar包查看其内部文件。\",\"alt text\",\"此时jar包中已经包含了我们项目中编写的类了，可以直接被其他项目导入使用。\"]},\"854\":{\"h\":\"打包成可执行文件\",\"t\":[\"当然，以上方式存在一定的问题，比如这里并没有包含项目中用到的一些其他依赖，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们提供的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包：\",\"<build> <plugins> <plugin> <artifactId>maven-assembly-plugin</artifactId> <version>3.1.0</version> <configuration> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> <archive> <manifest> <addClasspath>true</addClasspath> <mainClass>com.test.Main</mainClass> </manifest> </archive> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin> </plugins> </build> \",\"导入插件后，我们可以重新进行一次打包任务，等待打包完成即可得到我们的Jar文件，此时会出现两个文件\",\"其中一个是之前的正常打包得到的jar文件，还有一个就是包含了所有依赖以及配置了主类的jar文件。\",\"我们只需要执行java -jar命令即可运行打包好的Java程序\"]},\"855\":{\"h\":\"多模块测试打包\",\"t\":[\"对父项目执行的任何操作除了作用于本身，还会作用于他的所有子项目。\",\"多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom (此时父项目不会打包成 jar)\",\"<packaging>pom</packaging> \",\"packing默认是jar类型，如果不作配置，maven会将该项目打成jar包：\",\"作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build直到所有任务都完成。\"]},\"856\":{\"c\":[\"code\"]},\"857\":{\"c\":[\"javaweb\",\"Maven\"]},\"858\":{\"h\":\"Content - 网络基础1\"},\"859\":{\"h\":\"网络基础1\",\"t\":[\"在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：\",\"万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用链接的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档，在一个客户程序主窗口上显示出的万维网文档称为页面。\",\"URL的格式为：\",\"<协议>://<主机>:<端口>/<路径>\",\"协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。\",\"主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问）\",\"端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。\",\"路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。\",\"接着了解一下什么是HTTP协议：\",\"HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。\",\"HTTP的传输原理：\",\"HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。\",\"HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理：\",\"点击查看源网页\",\"TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。\",\"而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。\",\"点击查看源网页\",\"HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？\",\"我们来看一下HTTP的传输过程：\",\"点击查看源网页\",\"用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。 当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。 服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。\",\"因此，我们的浏览器请求一个页面，需要两倍的往返时间。\",\"最后，我们再来了解一下HTTP的报文结构：\",\"image-20230306164008613\",\"由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。\"]},\"860\":{\"c\":[\"code\"]},\"861\":{\"c\":[\"javaweb\"]},\"862\":{\"h\":\"Content - Tomact\"},\"863\":{\"h\":\"网络基础2\"},\"864\":{\"h\":\"Tomact 安装\",\"t\":[\"Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。\",\"那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：https://tomcat.apache.org/download-10.cgi\",\"下载：64-bit Windows zip\",\"下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开高级系统设置，打开环境变量，添加一个新的系统变量，变量名称为JRE_HOME，填写JDK的安装目录+/jre，比如Zulujdk默认就是：C:\\\\Program Files\\\\Zulu\\\\zulu-8\\\\jre\",\"设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。\",\"如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开conf文件夹，找到logging.properties文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式：\",\"java.util.logging.ConsoleHandler.encoding = GBK \",\"现在重新启动服务器，就可以正常显示中文了。\",\"服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：http://localhost:8080/\",\"Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。\",\"整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹：\",\"lib目录：Tomcat服务端运行的一些依赖，不用关心。\",\"logs目录：所有的日志信息都在这里。\",\"temp目录：存放运行时产生的一些临时文件，不用关心。\",\"work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及）\",\"webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：\",\"我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。\",\"我们也可以访问example项目，只需要在后面填写路径即可：http://localhost:8080/examples/\",\"或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/\",\"Tomcat还自带管理页面，我们打开：http://localhost:8080/manager\",\"提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容：\",\"You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp.\",\"For example, to add the manager-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above.\",\"<role rolename=\\\"manager-gui\\\"/> <user username=\\\"tomcat\\\" password=\\\"s3cret\\\" roles=\\\"manager-gui\\\"/> \",\"Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single manager role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.\",\"manager-gui - allows access to the HTML GUI and the status pages\",\"manager-script - allows access to the text interface and the status pages\",\"manager-jmx - allows access to the JMX proxy and the status pages\",\"manager-status - allows access to the status pages only\",\"The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:\",\"Users with the manager-gui role should not be granted either the manager-script or manager-jmx roles.\",\"If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.\",\"For more information - please see the Manager App How-To.\",\"现在我们按照上面的提示，去配置文件中进行修改：\",\" <role rolename=\\\"manager-gui\\\"/> <user username=\\\"admin\\\" password=\\\"admin\\\" roles=\\\"manager-gui\\\"/> \",\"现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。\",\"同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。\",\"我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。\",\"我们可以直接通过 http://localhost:8080/test/ 来进行访问。\"]},\"865\":{\"h\":\"IDEA MAVEN 构建 web 项目\",\"t\":[\"新建项目，选择 Java Enterprise 项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。\"]},\"866\":{\"c\":[\"code\"]},\"867\":{\"c\":[\"javaweb\"]},\"868\":{\"h\":\"Content - Servlet1\"},\"869\":{\"h\":\"网络基础3\"},\"870\":{\"h\":\"Servlet\",\"t\":[\"Servlet 是 Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的 Servlet。\",\"我们可以通过实现 Servlet 来进行动态网页响应，使用Servlet，不再是直接由Tomcat 服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java 代码进行动态拼接的结果，它能够很好地实现动态网页的返回。\",\"当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于 HTTP。\"]},\"871\":{\"h\":\"创建Servlet\",\"t\":[\"那么如何创建一个Servlet呢，非常简单，我们只需要实现Servlet类即可，并添加注解@WebServlet来进行注册。\",\"@WebServlet(\\\"/test\\\") public class TestServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return \\\"\\\"; } @Override public void destroy() { } } \",\"除了直接编写一个类，我们也可以在web.xml中进行注册，现将类上@WebServlet的注解去掉：\",\"<servlet> <servlet-name>test</servlet-name> <servlet-class>com.example.webtest.TestServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>test</servlet-name> <url-pattern>/test</url-pattern> </servlet-mapping> \",\"这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。\",\"实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中：\",\"<!-- The mapping for the default servlet --> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> <!-- The mappings for the JSP servlet --> <servlet-mapping> <servlet-name>jsp</servlet-name> <url-pattern>*.jsp</url-pattern> <url-pattern>*.jspx</url-pattern> </servlet-mapping> \",\"我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。\",\"我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。\"]},\"872\":{\"h\":\"Servlet 的生命周期\",\"t\":[\"我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是service方法，因此，一个Servlet的生命周期为：\",\"首先执行构造方法完成 Servlet 初始化\",\"Servlet 初始化后调用 init () 方法。\",\"Servlet 调用 service() 方法来处理客户端的请求。\",\"Servlet 销毁前调用 destroy() 方法。\",\"最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\",\"现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次service方法，来让我们处理用户的请求，并将结果响应给用户。\"]},\"873\":{\"h\":\"方法\",\"t\":[\"每次访问对应的 url 时，都会单独创建一个线程来处理执行 sevice 函数。\",\"在 service 方法 中，还有两个参数，ServletRequest和ServletResponse\",\"实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个ServletRequest对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，我们可以从 ServletRequest 获取所有的请求内容。\",\"HTTP请求报文中的所有内容，都可以从ServletRequest对象中获取，同理，ServletResponse就是我们需要返回给浏览器的HTTP响应报文实体类封装。\"]},\"874\":{\"h\":\"内容\",\"t\":[\"对应用户发起的请求信息，我们可以获取请求的一些信息：\",\"@Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现） HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getProtocol()); //获取协议版本 System.out.println(request.getRemoteAddr()); //获取访问者的IP地址 System.out.println(request.getMethod()); //获取请求方法 //获取头部信息 Enumeration<String> enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()){ String name = enumeration.nextElement(); System.out.println(name + \\\": \\\" + request.getHeader(name)); } } \",\"我们发现，整个HTTP请求报文中的所有内容，都可以通过HttpServletRequest对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。\"]},\"875\":{\"h\":\"内容\",\"t\":[\"用来传回信息给用户\",\"再来看看ServletResponse，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：\",\"//转换为HttpServletResponse（同上） HttpServletResponse response = (HttpServletResponse) servletResponse; //设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输） response.setHeader(\\\"Content-type\\\", \\\"text/html;charset=UTF-8\\\"); //获取Writer直接写入内容 response.getWriter().write(\\\"我是响应内容！\\\"); //所有内容写入完成之后，再发送给浏览器 \",\"现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。\",\"点击查看源网页\",\"首先 tomcat 里面有许多 servlet 容器，客户端会请求对应的容器中的某些资源或者实例，如果该容器找到了对应的需要的实例就会采用该服务然后返回\"]},\"876\":{\"h\":\"\",\"t\":[\"首先Servlet有一个直接实现抽象类GenericServlet\",\"这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作\",\"接着来看HttpServlet，它是遵循HTTP协议的一种Servlet，继承自GenericServlet，它根据HTTP协议的规则，完善了service方法。\",\"对应的 service 方法，先看对应请求是否支持Http协议的实现，是的话进行转化 HttpServletRequest 以及 HttpServletResponse，然后去 this.service 来实现具体对应方法的请求，我们只需要重写这些具体方法就行\",\"public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { if (req instanceof HttpServletRequest && res instanceof HttpServletResponse) { HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)res; this.service(request, response); } else { throw new ServletException(\\\"non-HTTP request or response\\\"); } } protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(\\\"GET\\\")) { long lastModified = this.getLastModified(req); if (lastModified == -1L) { this.doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(\\\"If-Modified-Since\\\"); if (ifModifiedSince < lastModified) { this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); } else { resp.setStatus(304); } } } else if (method.equals(\\\"HEAD\\\")) { long lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); } else if (method.equals(\\\"POST\\\")) { this.doPost(req, resp); } else if (method.equals(\\\"PUT\\\")) { this.doPut(req, resp); } else if (method.equals(\\\"DELETE\\\")) { this.doDelete(req, resp); } else if (method.equals(\\\"OPTIONS\\\")) { this.doOptions(req, resp); } else if (method.equals(\\\"TRACE\\\")) { this.doTrace(req, resp); } else if (method.equals(\\\"PATCH\\\")) { this.doPatch(req, resp); } else { String errMsg = lStrings.getString(\\\"http.method_not_implemented\\\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); } } \",\"在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。\",\"在 HttpServlet 源码中已经配置好了对应的 Get, Post, Put 等操作函数和代码，只不过并没有写具体操作，如果直接调用是默认提示没有支持该方法的\",\"以 doGet 为例\",\"在 HttpServlet 源码中\",\"protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String protocol = req.getProtocol(); String msg = lStrings.getString(\\\"http.method_get_not_supported\\\"); resp.sendError(this.getMethodNotSupportedCode(protocol), msg); } \",\"显然表示此时不支持，现在，我们只需要在对应的 Servlet 中重写对应的请求方式，就可以快速完成Servlet的编写。\",\"@Log @WebServlet(\\\"/test\\\") public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"<h1>恭喜你解锁了全新玩法</h1>\\\"); } } \"]},\"877\":{\"h\":\"@WebServlet注解详解\",\"t\":[\"我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。\"]},\"878\":{\"h\":\"不同路径配置\",\"t\":[\"首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配：\",\"@WebServlet(\\\"/test/*\\\") \",\"上面的路径表示，所有匹配/test/随便什么的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。\",\"也可以进行某个扩展名称的匹配：\",\"@WebServlet(\\\"*.js\\\") \",\"这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。\"]},\"879\":{\"h\":\"替换默认路径\",\"t\":[\"那么如果我们的路径为/呢？\",\"@WebServlet(\\\"/\\\") \",\"此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的\",\"此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么就会使用此Servlet进行处理。\"]},\"880\":{\"h\":\"配置多个访问路径\",\"t\":[\"我们还可以为一个Servlet配置多个访问路径：\",\"@WebServlet({\\\"/test1\\\", \\\"/test2\\\"}) \"]},\"881\":{\"h\":\"属性\",\"t\":[\"我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet\",\"默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。\",\"@Log @WebServlet(value = \\\"/test\\\", loadOnStartup = 1) public class TestServlet extends HttpServlet { @Override public void init() throws ServletException { super.init(); log.info(\\\"我被初始化了！\\\"); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"<h1>恭喜你解锁了全新玩法</h1>\\\"); } } \"]},\"882\":{\"c\":[\"code\"]},\"883\":{\"c\":[\"javaweb\"]},\"884\":{\"h\":\"Content - Servlet2\"},\"885\":{\"h\":\"Servlet2\"},\"886\":{\"h\":\"使用POST请求完成登陆\",\"t\":[\"一般通过 Post 操作来向服务器传输数据\",\"我们需要修改一下我们的Servlet，让其能够接收一个POST请求：\",\"@WebServlet(\\\"/login\\\") public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getParameterMap().forEach((k, v) -> { System.out.println(k + \\\": \\\" + Arrays.toString(v)); }); } } \",\"ParameterMap存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。\",\"对应的前端用 form 来进行提交：\",\"<body> <h1>登录到系统</h1> <form method=\\\"post\\\" action=\\\"login\\\"> <hr> <div> <label> <input type=\\\"text\\\" placeholder=\\\"用户名\\\" name=\\\"username\\\"> </label> </div> <div> <label> <input type=\\\"password\\\" placeholder=\\\"密码\\\" name=\\\"password\\\"> </label> </div> <div> <button>登录</button> </div> </form> </body> \",\"通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login（注意不同路径的写法），也就是我们上面编写的Servlet路径。\",\"运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。\"]},\"887\":{\"h\":\"实现简单登录功能\",\"t\":[\"根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作\"]},\"888\":{\"h\":\"Mybatis 配置\",\"t\":[\"去数据库里创建一个表作为测试\",\"在 pom.xml 中装好 mybatis 以及 数据库驱动 mysql\",\" <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.27</version> </dependency> \",\"在 Resources 文件夹写 mybatis-config.xml 配置文件 其中，驱动名就是对应的 com.mysql.jc.jdbc.Driver，其他就很好找的\",\" <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"再去编写对应逻辑，创建一个实体类以及Mapper来进行用户信息查询： Mapper创在对应的Mapper文件夹下，然后去mybatis-config.xml填写对应mapper的配置\",\"@Data public class User { String username; String password; } \",\"public interface UserMapper { @Select(\\\"select * from users where username = #{username} and password = #{password}\\\") User getUser(@Param(\\\"username\\\") String username, @Param(\\\"password\\\") String password); } \",\"<mappers> <mapper class=\\\"com.example.dao.UserMapper\\\"/> </mappers> \"]},\"889\":{\"h\":\"实现登录功能\",\"t\":[\"初始化得到 mybatis 配置连接数据库\",\"在 doPost 中写对应的登录逻辑\",\"@WebServlet(value = \\\"/login\\\", loadOnStartup = 1) public class LoginServlet extends HttpServlet { SqlSessionFactory factory; @Override public void init() throws ServletException { try { factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\\\"mybatis-config.xml\\\")); } catch (IOException e) { throw new RuntimeException(e); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //首先设置一下响应类型 resp.setContentType(\\\"text/html;charset=UTF-8\\\"); //获取POST请求携带的表单数据 Map<String, String[]> map = req.getParameterMap(); //判断表单是否完整 if(map.containsKey(\\\"username\\\") && map.containsKey(\\\"password\\\")) { String username = req.getParameter(\\\"username\\\"); String password = req.getParameter(\\\"password\\\"); try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); //判断用户是否登陆成功，若查询到信息则表示存在此用户 if(user != null){ System.out.println(user.toString()); resp.getWriter().write(\\\"登陆成功！\\\"); }else { resp.getWriter().write(\\\"登陆失败，请验证您的用户名或密码！\\\"); } } }else { resp.getWriter().write(\\\"错误，您的表单数据不完整！\\\"); } } } \"]},\"890\":{\"h\":\"上传和下载文件\"},\"891\":{\"h\":\"下载\",\"t\":[\"首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载：\",\"@WebServlet(\\\"/file\\\") public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\\\"image/png\\\"); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(\\\"icon.png\\\"); } } \",\"为了更加快速地编写IO代码，我们可以引入一个工具库 commons-io：\",\"<dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>2.6</version> </dependency> \",\"使用此类库可以快速完成IO操作：\",\"resp.setContentType(\\\"image/png\\\"); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(\\\"icon.png\\\"); //直接使用copy方法完成转换 IOUtils.copy(inputStream, outputStream); \",\"现在我们在前端页面添加一个链接，用于下载此文件：\",\"<hr> <a href=\\\"file\\\" download=\\\"icon.png\\\">点我下载高清资源</a> \"]},\"892\":{\"h\":\"上传\",\"t\":[\"首先我们编写前端部分：\",\"<form method=\\\"post\\\" action=\\\"file\\\" enctype=\\\"multipart/form-data\\\"> <div> <input type=\\\"file\\\" name=\\\"test-file\\\"> </div> <div> <button>上传文件</button> </div> </form> \",\"注意必须添加enctype=\\\"multipart/form-data\\\"，来表示此表单用于文件传输。\",\"现在我们来修改一下Servlet代码：\",\"@MultipartConfig @WebServlet(\\\"/file\\\") public class FileServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try(FileOutputStream stream = new FileOutputStream(\\\"xxxx\\\")){ Part part = req.getPart(\\\"test-file\\\"); IOUtils.copy(part.getInputStream(), stream); resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(\\\"文件上传成功！\\\"); } } } \",\"part 为网站中上传的内容，将其copy到stream中\",\"注意，必须添加@MultipartConfig注解来表示此Servlet用于处理文件上传请求。\",\"现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。\"]},\"893\":{\"h\":\"使用XHR请求数据\",\"t\":[\"现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。\",\"这个时候就需要我们在网页展示时向后端发起请求，并根据后端响应的结果，动态地更新页面中的内容\",\"要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新：\",\"function updateTime() { let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { document.getElementById(\\\"time\\\").innerText = xhr.responseText } }; xhr.open('GET', 'time', true); xhr.send(); } \",\"接着修改一下前端页面，添加一个时间显示区域：\",\"<hr> <div id=\\\"time\\\"></div> <br> <button onclick=\\\"updateTime()\\\">更新数据</button> <script> updateTime() </script> \",\"最后创建一个Servlet用于处理时间更新请求：\",\"@WebServlet(\\\"/time\\\") public class TimeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy年MM月dd日 HH:mm:ss\\\"); String date = dateFormat.format(new Date()); resp.setContentType(\\\"text/html;charset=UTF-8\\\"); resp.getWriter().write(date); } } \",\"GET请求也能传递参数, 后面跟 ? 就行\"]},\"894\":{\"c\":[\"code\"]},\"895\":{\"c\":[\"javaweb\"]},\"896\":{\"h\":\"Content - Servlet3\"},\"897\":{\"h\":\"Servlet3\"},\"898\":{\"h\":\"重定向与请求转发\"},\"899\":{\"h\":\"重定向 302\",\"t\":[\"当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。\",\"当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。\",\"实现重定向很简单，只需要调用一个方法即可\",\"resp.sendRedirect(\\\"time\\\"); \",\"调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。\",\"现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。\",\"除了用写好的 resp.sendRedircet() 来进行重定向操作外，我们可以直接发送 302 + 定义 Location 的位置即可\",\"resp.setStatus(302); resp.setHeader(\\\"Location\\\", \\\"xxxx\\\"); \"]},\"900\":{\"h\":\"请求转发\",\"t\":[\"请求转发可以携带数据，重定向无法携带数据\",\"那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面\",\"而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。\",\"req.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。\",\"现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。\",\"那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。\",\"现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理：\",\"@Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } \",\"再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。\",\"请求转发可以携带数据！\",\"req.setAttribute(\\\"test\\\", \\\"我是请求转发前的数据\\\"); req.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"System.out.println(req.getAttribute(\\\"test\\\")); \",\"通过setAttribute方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。\",\"重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？\",\"我们可以使用即将要介绍的ServletContext对象。\",\"最后总结，两者的区别为：\",\"请求转发是一次请求，重定向是两次请求\",\"请求转发地址栏不会发生改变， 重定向地址栏会发生改变\",\"请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了\",\"请求转发只能转发给内部的Servlet\"]},\"901\":{\"h\":\"ServletContext对象 - 全局存储通信\",\"t\":[\"ServletContext全局唯一，它是属于整个Web应用程序的\",\"可以通过getServletContext()来获取到此对象。\",\"此对象也能设置附加值：\",\"ServletContext context = getServletContext(); context.setAttribute(\\\"test\\\", \\\"我是重定向之前的数据\\\"); resp.sendRedirect(\\\"time\\\"); \",\"System.out.println(getServletContext().getAttribute(\\\"test\\\")); \",\"因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。\",\"它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：\",\"context.getRequestDispatcher(\\\"/time\\\").forward(req, resp); \",\"它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）\",\"contest.getResourceAsStream() \"]},\"902\":{\"h\":\"初始化参数\",\"t\":[\"初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。\",\"我们可以给一个Servlet添加一些初始化参数：\",\"@WebServlet(value = \\\"/login\\\", initParams = { @WebInitParam(name = \\\"test\\\", value = \\\"我是一个默认的初始化参数\\\") }) \",\"它也是以键值对形式保存的，我们可以直接通过Servlet的getInitParameter方法获取：\",\"System.out.println(getInitParameter(\\\"test\\\")); \"]},\"903\":{\"h\":\"全局定义初始化参数\",\"t\":[\"但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可：\",\"<context-param> <param-name>lbwnb</param-name> <param-value>我是全局初始化参数</param-value> </context-param> \",\"我们需要使用ServletContext来读取全局初始化参数：\",\"ServletContext context = getServletContext(); System.out.println(context.getInitParameter(\\\"lbwnb\\\")); \",\"有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。\"]},\"904\":{\"c\":[\"code\"]},\"905\":{\"c\":[\"javaweb\"]},\"906\":{\"h\":\"Content - Cookie + Session\"},\"907\":{\"h\":\"Cookie\",\"t\":[\"Cookie, 可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。\"]},\"908\":{\"h\":\"简单使用\",\"t\":[\"在服务器端发送 Cookie 的请求头\",\"Cookie cookie = new Cookie(\\\"test\\\", \\\"yyds\\\"); resp.addCookie(cookie); resp.sendRedirect(\\\"time\\\"); \",\"对应的服务器响应头就会包含 Set-Cookie：\",\"HTTP/1.1 302 Set-Cookie: test=123 Location: time Content-Type: text/html;charset=UTF-8 Content-Length: 0 Date: Thu, 24 Jul 2025 07:09:50 GMT Keep-Alive: timeout=20 Connection: keep-alive \",\"之后网页收到服务器的响应请求后就会存储对应 Cookie 在本地, 当满足条件时，网页发送的请求就会携带所有的 Cookie, 服务器端可以进行获取\",\"for (Cookie cookie : req.getCookies()) { System.out.println(cookie.getName() + \\\": \\\" + cookie.getValue()); } \",\"对应的用户请求头就会包含 Cookie\",\"GET /WebTest_war_exploded/time HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Cache-Control: max-age=0 Connection: keep-alive Cookie: test=123 Host: localhost:8081 Referer: http://localhost:8081/WebTest_war_exploded/ Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0 \",\"alt text\"]},\"909\":{\"h\":\"属性\",\"t\":[\"一个Cookie包含信息：\",\"name - Cookie的名称，Cookie一旦创建，名称便不可更改\",\"value - Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码\",\"maxAge - Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。\",\"secure - 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。\",\"path - Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。\",\"domain - 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。\",\"comment - 该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。\",\"version - Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范\",\"我们发现，最关键的其实是name、value、maxAge、domain属性。\",\"尝试修改一下maxAge来看看失效时间：\",\"cookie.setMaxAge(20); \",\"设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。\"]},\"910\":{\"h\":\"应用\",\"t\":[\"可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中\",\"如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。\",\"那么首先，我们先在前端页面的表单中添加一个勾选框：\",\"<div> <label> <input type=\\\"checkbox\\\" placeholder=\\\"记住我\\\" name=\\\"remember-me\\\"> 记住我 </label> </div> \",\"接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地：\",\"if(map.containsKey(\\\"remember-me\\\")){ //若勾选了勾选框，那么会此表单信息 Cookie cookie_username = new Cookie(\\\"username\\\", username); cookie_username.setMaxAge(30); Cookie cookie_password = new Cookie(\\\"password\\\", password); cookie_password.setMaxAge(30); resp.addCookie(cookie_username); resp.addCookie(cookie_password); } \",\"然后，我们修改一下默认的请求地址，现在一律通过http://localhost:8080/yyds/login进行登陆，那么我们需要添加GET请求的相关处理：\",\"@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie[] cookies = req.getCookies(); if(cookies != null){ String username = null; String password = null; for (Cookie cookie : cookies) { if(cookie.getName().equals(\\\"username\\\")) username = cookie.getValue(); if(cookie.getName().equals(\\\"password\\\")) password = cookie.getValue(); } if(username != null && password != null){ //登陆校验 try (SqlSession sqlSession = factory.openSession(true)){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); if(user != null){ resp.sendRedirect(\\\"time\\\"); return; //直接返回 } } } } req.getRequestDispatcher(\\\"/\\\").forward(req, resp); //正常情况还是转发给默认的Servlet帮我们返回静态页面 } \",\"现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。\",\"现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。\"]},\"911\":{\"h\":\"Session\",\"t\":[\"Session 是基于 Cookie 设计的\",\"由于HTTP是无连接的，所以无法辨别当前的请求是来自哪个用户发起，而 Session 就是用来处理这种问题的\",\"每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。\"]},\"912\":{\"h\":\"原理\",\"t\":[\"Session实际上是基于Cookie实现的，它会给浏览器设定一个叫做JSESSIONID的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。\",\"具体内容是保存在服务器端的 Session 对象里，网页端只是保存了JSESSIONID来识别\",\"alt text\"]},\"913\":{\"h\":\"应用\",\"t\":[\"那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从HttpSession中读取到存储在会话中的数据：\",\"在登录界面，服务端发出响应请求时，加入 Session:\",\"HttpSession session = req.getSession(); session.setAttribute(\\\"user\\\", user); \",\"对应用户会收到相应请求，Set-Cookie:\",\"HTTP/1.1 302 Set-Cookie: JSESSIONID=84ABDD94FB965F266818B9DBB6172807; Path=/WebTest_war_exploded; HttpOnly Location: time Content-Type: text/html;charset=UTF-8 Content-Length: 0 Date: Thu, 24 Jul 2025 09:54:07 GMT Keep-Alive: timeout=20 Connection: keep-alive \",\"在主页界面(\\\\time)，服务端处理请求时，根据 Session 来判断是否登录：\",\"如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：\",\"HttpSession session = req.getSession(); User user = (User) session.getAttribute(\\\"user\\\"); if(user == null) { resp.sendRedirect(\\\"login\\\"); return; } \",\"对应，用户的发送请求会携带对应的Cookie，包含 JSESSIONID\",\"GET /WebTest_war_exploded/time HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Cache-Control: max-age=0 Connection: keep-alive Cookie: test=123; JSESSIONID=84ABDD94FB965F266818B9DBB6172807 Host: localhost:8081 Referer: http://localhost:8081/WebTest_war_exploded/login Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0 sec-ch-ua: \\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Microsoft Edge\\\";v=\\\"138\\\" \"]},\"914\":{\"h\":\"配置\",\"t\":[\"Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件 web.xml 中修改过期时间：\",\"<session-config> <session-timeout>1</session-timeout> </session-config> \",\"我们也可以在代码中使用invalidate方法来使Session立即失效：\",\"session.invalidate(); \",\"现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。\"]},\"915\":{\"c\":[\"code\"]},\"916\":{\"c\":[\"javaweb\"]},\"917\":{\"h\":\"Content - Filter + Listener\"},\"918\":{\"h\":\"Filter\",\"t\":[\"有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？\",\"过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet\",\"而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。\",\"alt text\"]},\"919\":{\"h\":\"添加过滤器\",\"t\":[\"添加一个过滤器非常简单，只需要实现Filter接口，并添加@WebFilter注解即可：\",\"@WebFilter(\\\"/*\\\") //路径的匹配规则和Servlet一致，这里表示匹配所有请求 public class TestFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { } } \",\"这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器：\",\"HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getRequestURL()); \",\"我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。\"]},\"920\":{\"h\":\"允许请求通过\",\"t\":[\"那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句：\",\"filterChain.doFilter(servletRequest, servletResponse); \",\"由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果：\",\"@WebFilter(\\\"/*\\\") public class TestFilter2 implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是2号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); } } \",\"由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。\",\"我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。\",\"alt text\",\"实际上，当doFilter方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下：\",\"@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是2号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\\\"我是2号过滤器，处理后\\\"); } \",\"@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"我是1号过滤器\\\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\\\"我是1号过滤器，处理后\\\"); } \",\"即，在 filterChain.doFilter 之后的语句需要等处理完，再倒回来处理\",\"alt text\"]},\"921\":{\"h\":\"接口\",\"t\":[\"同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写：\",\"public abstract class HttpFilter extends GenericFilter { private static final long serialVersionUID = 7478463438252262094L; public HttpFilter() { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { if (req instanceof HttpServletRequest && res instanceof HttpServletResponse) { this.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain); } else { throw new ServletException(\\\"non-HTTP request or response\\\"); } } protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { chain.doFilter(req, res); } } \",\"那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻：\",\"@WebFilter(\\\"/*\\\") public class MainFilter extends HttpFilter { @Override protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { String url = req.getRequestURL().toString(); //判断是否为静态资源 if(!url.endsWith(\\\".js\\\") && !url.endsWith(\\\".css\\\") && !url.endsWith(\\\".png\\\")){ HttpSession session = req.getSession(); User user = (User) session.getAttribute(\\\"user\\\"); //判断是否未登陆 if(user == null && !url.endsWith(\\\"login\\\")){ res.sendRedirect(\\\"login\\\"); return; } } //交给过滤链处理 chain.doFilter(req, res); } } \",\"现在，我们的页面已经基本完善为我们想要的样子了。\"]},\"922\":{\"h\":\"Listener\",\"t\":[\"监听器并不是我们学习的重点内容，那么什么是监听器呢？\",\"如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。\",\"alt text\",\"默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可：\",\"@WebListener public class TestListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(\\\"有一个Session被创建了\\\"); } } \"]},\"923\":{\"c\":[\"code\"]},\"924\":{\"c\":[\"javaweb\"]},\"925\":{\"h\":\"Content - Tomact类加载机制\"},\"926\":{\"h\":\"Tomcat类加载机制\",\"t\":[\"Tomcat到底是如何加载和运行我们的Web应用程序的。\",\"Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离\",\"也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问\",\"而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。\",\"img\",\"首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：\",\"Common ClassLoader：Tomcat最基本的类加载器，该加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。\",\"Catalina ClassLoader：Tomcat容器私有的类加载器，该加载路径中的class对于Web应用程序不可见。\",\"Shared ClassLoader：各个Web应用程序共享的类加载器，该加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。\",\"Webapp ClassLoader：各个Web应用程序私有的类加载器，该加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。\",\"JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。\",\"通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的双亲委派机制（即每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。）\",\"比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？\",\"难道Tomcat的开发团队没有考虑到这个问题吗？\",\"alt text\",\"实际上，WebAppClassLoader的加载机制是这样的：\",\"WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。\",\"这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。\"]},\"927\":{\"c\":[\"code\"]},\"928\":{\"c\":[\"javaweb\"]},\"929\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"930\":{\"h\":\"Daily\"},\"931\":{\"h\":\"Java\"},\"932\":{\"h\":\"Code\"},\"933\":{\"h\":\"Java 9 17\"},\"934\":{\"h\":\"Java Hint\"},\"935\":{\"h\":\"UAV\"},\"936\":{\"h\":\"Academic\"},\"937\":{\"h\":\"强化学习\"},\"938\":{\"h\":\"1 Socket\"},\"939\":{\"h\":\"Javaweb\"},\"940\":{\"h\":\"2 数据库\"},\"941\":{\"h\":\"3 Lombok\"},\"942\":{\"h\":\"4 Mybatis\"},\"943\":{\"h\":\"5 JUL\"},\"944\":{\"h\":\"6 JUnit\"},\"945\":{\"h\":\"7 Maven\"},\"946\":{\"h\":\"8 网络内容\"}},\"dirtCount\":0,\"index\":[[\"绕开了\",{\"1\":{\"926\":1}}],[\"岂不是就出问题了\",{\"1\":{\"926\":1}}],[\"破坏了jdk的双亲委派机制\",{\"1\":{\"926\":1}}],[\"带着诸多问题\",{\"1\":{\"926\":1}}],[\"带初始值的初始化\",{\"1\":{\"371\":1}}],[\"亦或是在request对象创建的时候进行一些操作\",{\"1\":{\"922\":1}}],[\"监听器并不是我们学习的重点内容\",{\"1\":{\"922\":1}}],[\"交给过滤链处理\",{\"1\":{\"921\":1}}],[\"交给上一级函数\",{\"1\":{\"267\":1}}],[\"告诉用户\",{\"1\":{\"913\":1}}],[\"记住我\",{\"1\":{\"910\":2}}],[\"记录在\",{\"1\":{\"455\":1}}],[\"记录\",{\"1\":{\"344\":1}}],[\"记录类型在java\",{\"1\":{\"344\":1}}],[\"记录类型\",{\"0\":{\"344\":1}}],[\"记录当前数组元素数的\",{\"1\":{\"25\":1}}],[\"安全协议有https\",{\"1\":{\"909\":1}}],[\"安全协议\",{\"1\":{\"909\":1}}],[\"安装\",{\"0\":{\"864\":1},\"1\":{\"817\":1}}],[\"安装好之后\",{\"1\":{\"775\":1}}],[\"两者的区别为\",{\"1\":{\"900\":1}}],[\"两个算法迭代过程十分类似\",{\"1\":{\"444\":1}}],[\"两个参数\",{\"1\":{\"364\":1}}],[\"两个参数对应\",{\"1\":{\"295\":1}}],[\"两个属性都是一模一样的\",{\"1\":{\"344\":1}}],[\"两个方法同时在运行或者是两个计算同时在进行\",{\"1\":{\"138\":1}}],[\"两个对象只有\",{\"1\":{\"84\":1}}],[\"两个需要比较的数会在这里给出\",{\"1\":{\"14\":1}}],[\"旁边有一个按钮\",{\"1\":{\"893\":1}}],[\"旁边出现运行按钮\",{\"1\":{\"776\":1}}],[\"您的表单数据不完整\",{\"1\":{\"889\":1}}],[\"驱动名就是对应的\",{\"1\":{\"888\":1}}],[\"驱动类\",{\"1\":{\"641\":1,\"888\":1}}],[\"呢\",{\"1\":{\"879\":1}}],[\"替换默认路径\",{\"0\":{\"879\":1}}],[\"容器\",{\"1\":{\"875\":1}}],[\"响应头为我们设定了20秒的过期时间\",{\"1\":{\"909\":1}}],[\"响应头部分\",{\"1\":{\"875\":1}}],[\"响应的状态码会被设置为302\",{\"1\":{\"899\":1}}],[\"响应中断\",{\"1\":{\"144\":1}}],[\"销毁前调用\",{\"1\":{\"872\":1}}],[\"老的版本是不支持的哦\",{\"1\":{\"871\":1}}],[\"点击按钮就可以刷新当前时间\",{\"1\":{\"893\":1}}],[\"点击下一步即可\",{\"1\":{\"865\":1}}],[\"点击查看源网页\",{\"1\":{\"859\":3,\"875\":1}}],[\"展示给我们的是一个图形化界面\",{\"1\":{\"864\":1}}],[\"登录后\",{\"1\":{\"864\":1}}],[\"登陆之后畅行无阻\",{\"1\":{\"921\":1}}],[\"登陆校验\",{\"1\":{\"910\":1}}],[\"登陆失败\",{\"1\":{\"889\":1}}],[\"登陆成功\",{\"1\":{\"621\":2,\"622\":1,\"889\":1}}],[\"登陆用户\",{\"0\":{\"590\":1}}],[\"页面中出现如下内容\",{\"1\":{\"864\":1}}],[\"填写jdk的安装目录+\",{\"1\":{\"864\":1}}],[\"填写的日志打印级别是什么\",{\"1\":{\"729\":1}}],[\"汤姆猫\",{\"1\":{\"864\":1}}],[\"双方随时可以互相发送数据\",{\"1\":{\"859\":1}}],[\"双端队列既可以当做普通队列使用\",{\"1\":{\"44\":1}}],[\"双端队列\",{\"0\":{\"44\":1}}],[\"声音和图像\",{\"1\":{\"859\":1}}],[\"声明一个私有方法\",{\"1\":{\"317\":1}}],[\"声明此模块提供了test的实现类\",{\"1\":{\"310\":1}}],[\"超文本\",{\"1\":{\"859\":1}}],[\"超过一个时间\",{\"1\":{\"538\":1}}],[\"端口是当前服务器上web应用程序开启的端口\",{\"1\":{\"859\":1}}],[\"协议是指采用什么协议来访问服务器\",{\"1\":{\"859\":1}}],[\"服务器就会通过cookie的值进行辨别\",{\"1\":{\"912\":1}}],[\"服务器端可以进行获取\",{\"1\":{\"908\":1}}],[\"服务器发送我们编写好的静态网页内容\",{\"1\":{\"870\":1}}],[\"服务器配置文件目录\",{\"1\":{\"864\":1}}],[\"服务器启动成功之后\",{\"1\":{\"864\":1}}],[\"服务器则正常启动\",{\"1\":{\"864\":1}}],[\"服务器收到http请求报文后\",{\"1\":{\"859\":1}}],[\"服务器程序向客户程序送回客户所要的万维网文档\",{\"1\":{\"859\":1}}],[\"服务端处理请求时\",{\"1\":{\"913\":1}}],[\"服务端发出响应请求时\",{\"1\":{\"913\":1}}],[\"服务端不仅仅只可以让一个客户端进行连接\",{\"1\":{\"536\":1}}],[\"服务端和客户端之间就可以相互发送数据\",{\"1\":{\"536\":1}}],[\"服务端连接失败\",{\"1\":{\"536\":1,\"537\":1,\"543\":1}}],[\"服务端\",{\"1\":{\"536\":1}}],[\"客户程序向服务器程序发出请求\",{\"1\":{\"859\":1}}],[\"客户端会请求对应的容器中的某些资源或者实例\",{\"1\":{\"875\":1}}],[\"客户端\",{\"1\":{\"536\":1}}],[\"客户端已连接\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"英文简称web\",{\"1\":{\"859\":1}}],[\"万维网客户就把http请求报文作为建立tcp连接的三报文握手中的第三个报文的数据\",{\"1\":{\"859\":1}}],[\"万维网文档所驻留的主机则运行服务器程序\",{\"1\":{\"859\":1}}],[\"万维网以客户服务器的方式工作\",{\"1\":{\"859\":1}}],[\"万维网用链接的方法\",{\"1\":{\"859\":1}}],[\"万维网是一个大规模的联机式信息储藏所\",{\"1\":{\"859\":1}}],[\"万维网\",{\"1\":{\"859\":1}}],[\"万一给进来的str是null呢\",{\"1\":{\"297\":1}}],[\"谢希仁\",{\"1\":{\"859\":1}}],[\"命令\",{\"0\":{\"852\":1,\"853\":1}}],[\"命名规则一般和包名一致\",{\"1\":{\"820\":1}}],[\"排除依赖中的不必要依赖\",{\"0\":{\"843\":1}}],[\"排序查询\",{\"0\":{\"581\":1}}],[\"排序sorted\",{\"1\":{\"358\":1}}],[\"排序\",{\"1\":{\"71\":1}}],[\"顺便带大家回顾一下junit5的使用\",{\"1\":{\"834\":1}}],[\"顺序\",{\"1\":{\"746\":1}}],[\"顺序执行\",{\"1\":{\"354\":1}}],[\"顺序就同我们的插入顺序一致\",{\"1\":{\"61\":1}}],[\"着重讲解\",{\"1\":{\"832\":1}}],[\"国外\",{\"1\":{\"827\":1}}],[\"镜像配置方式同第1步\",{\"1\":{\"827\":1}}],[\"镜像仓库与中心仓库自动同步所有依赖\",{\"1\":{\"827\":1}}],[\"远程仓库中下载之后\",{\"1\":{\"826\":1}}],[\"插件\",{\"1\":{\"819\":1}}],[\"插入的其中任意一种操作\",{\"1\":{\"682\":1}}],[\"插入\",{\"0\":{\"678\":1}}],[\"插入数据\",{\"0\":{\"571\":1}}],[\"插入新的元素到当前待遍历元素之前\",{\"1\":{\"37\":1}}],[\"插入元素默认是插入到尾部\",{\"1\":{\"24\":1}}],[\"部署等操作\",{\"1\":{\"817\":1}}],[\"软件基金会主持的独立\",{\"1\":{\"817\":1}}],[\"软引用\",{\"1\":{\"701\":1}}],[\"曾是\",{\"1\":{\"817\":1}}],[\"项目模板选择web应用程序\",{\"1\":{\"865\":1}}],[\"项目名称随便\",{\"1\":{\"865\":1}}],[\"项目在打包时会将资源文件夹中文件一起打包的jar中\",{\"1\":{\"834\":1}}],[\"项目在运行时\",{\"1\":{\"833\":1}}],[\"项目运行成功\",{\"1\":{\"825\":1}}],[\"项目标识\",{\"0\":{\"820\":1}}],[\"项目使用到哪些依赖\",{\"1\":{\"817\":1}}],[\"项目的自动构建\",{\"1\":{\"817\":1}}],[\"项目的子项目\",{\"1\":{\"817\":1}}],[\"项目\",{\"0\":{\"865\":1},\"1\":{\"817\":1}}],[\"项目进行构建\",{\"1\":{\"817\":1}}],[\"项目中代码量非常之大\",{\"1\":{\"280\":1}}],[\"报告和文档等步骤\",{\"1\":{\"817\":1}}],[\"缩写\",{\"1\":{\"817\":1}}],[\"翻译为\",{\"1\":{\"817\":1}}],[\"翻译过来就是\",{\"1\":{\"173\":1}}],[\"模式默认为include\",{\"1\":{\"810\":1}}],[\"模块需要使用到\",{\"1\":{\"310\":1}}],[\"模块化机制提供了另一个级别的java代码可见性\",{\"1\":{\"304\":1}}],[\"模块名称随便起一个就可以\",{\"1\":{\"304\":2}}],[\"模块可以由一个或者多个在一起的\",{\"1\":{\"303\":1}}],[\"模块机制\",{\"0\":{\"300\":1,\"302\":1}}],[\"某些测试可能并不是固定单个输入参数\",{\"1\":{\"808\":1}}],[\"某些集合不支持这种操作\",{\"1\":{\"32\":1}}],[\"伪随机排序测试方法\",{\"1\":{\"804\":1}}],[\"伪代码\",{\"0\":{\"406\":1,\"438\":1,\"441\":1,\"498\":1,\"518\":1},\"1\":{\"490\":1}}],[\"防止准备不足导致的测试失败\",{\"1\":{\"802\":1}}],[\"真假判断\",{\"0\":{\"787\":1}}],[\"真正有用的那一部分代码\",{\"1\":{\"289\":1}}],[\"断言工具\",{\"0\":{\"785\":1}}],[\"断言\",{\"0\":{\"780\":1}}],[\"断言表达式\",{\"0\":{\"268\":1}}],[\"预设的名称生成器\",{\"0\":{\"779\":1}}],[\"预设注解\",{\"0\":{\"204\":1}}],[\"跳过某个测试\",{\"0\":{\"777\":1}}],[\"跳过了一个字节\",{\"1\":{\"91\":1}}],[\"感觉没学到maven\",{\"1\":{\"775\":1}}],[\"牵一发而动全身\",{\"1\":{\"773\":1}}],[\"难道tomcat的开发团队没有考虑到这个问题吗\",{\"1\":{\"926\":1}}],[\"难道取1000还可能吐2000出来吗\",{\"1\":{\"154\":1}}],[\"难免会涉及到一些原有代码的修改\",{\"1\":{\"773\":1}}],[\"打开conf文件夹\",{\"1\":{\"864\":1}}],[\"打开环境变量\",{\"1\":{\"864\":1}}],[\"打开高级系统设置\",{\"1\":{\"864\":1}}],[\"打开编辑\",{\"1\":{\"827\":1}}],[\"打开后可以看到已经给我们写出了依赖的坐标\",{\"1\":{\"825\":1}}],[\"打包成可执行文件\",{\"0\":{\"854\":1}}],[\"打包将无法完成\",{\"1\":{\"853\":1}}],[\"打包\",{\"1\":{\"817\":1}}],[\"打工是不可能打工的\",{\"1\":{\"767\":1}}],[\"打印查看一下最终执行的\",{\"1\":{\"622\":1}}],[\"打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"打印当前线程名称\",{\"1\":{\"166\":1}}],[\"打印\",{\"1\":{\"142\":1,\"275\":1}}],[\"打印流其实我们从一开始就在使用了\",{\"1\":{\"127\":1}}],[\"打印流\",{\"0\":{\"127\":1}}],[\"打印集合类\",{\"1\":{\"25\":1}}],[\"消息内容\",{\"1\":{\"765\":1}}],[\"消费者可以从货架上拿走商品\",{\"1\":{\"174\":1}}],[\"消费者也在不断的消费\",{\"1\":{\"174\":1}}],[\"日期\",{\"1\":{\"765\":1}}],[\"日志\",{\"0\":{\"768\":1}}],[\"日志注解\",{\"0\":{\"767\":1}}],[\"日志默认配置\",{\"0\":{\"752\":1}}],[\"日志的名称会按照包的分级\",{\"1\":{\"747\":1}}],[\"日志的打印并不是简单的输出\",{\"1\":{\"726\":1}}],[\"日志中出现了两次\",{\"1\":{\"746\":1}}],[\"日志继承关系\",{\"0\":{\"743\":1}}],[\"日志内容\",{\"1\":{\"738\":1}}],[\"日志级别\",{\"1\":{\"738\":1,\"761\":1}}],[\"日志打印的核心部分\",{\"1\":{\"735\":1}}],[\"日志核心内容\",{\"0\":{\"734\":1}}],[\"日志一般分为7个级别\",{\"1\":{\"727\":1}}],[\"日志将时刻伴随我们左右\",{\"1\":{\"725\":1}}],[\"格式类似于我们java中的map键值对\",{\"1\":{\"753\":1}}],[\"格式\",{\"0\":{\"753\":1}}],[\"格式为\",{\"1\":{\"738\":1}}],[\"比较常见的就是打印到控制台\",{\"1\":{\"735\":1}}],[\"比如webapp\",{\"1\":{\"926\":1}}],[\"比如请求转发\",{\"1\":{\"901\":1}}],[\"比如网页上有一个时间\",{\"1\":{\"893\":1}}],[\"比如zulujdk默认就是\",{\"1\":{\"864\":1}}],[\"比如maintest\",{\"1\":{\"852\":1}}],[\"比如mybatis的pom文件中\",{\"1\":{\"842\":1}}],[\"比如多个子项目都需要父项目的依赖\",{\"1\":{\"849\":1}}],[\"比如配置文件\",{\"1\":{\"834\":1}}],[\"比如jdbc驱动就是典型的只需要运行时使用\",{\"1\":{\"833\":1}}],[\"比如某个案例存在一个bug\",{\"1\":{\"807\":1}}],[\"比如某些测试案例必须在指定jdk版本执行\",{\"1\":{\"792\":1}}],[\"比如用户相关的测试全部归为一个组\",{\"1\":{\"805\":1}}],[\"比如初始化类需要花费大量时间或是执行非常费时的io操作时\",{\"1\":{\"803\":1}}],[\"比如测试前的准备工作或是测试后的收尾工作\",{\"1\":{\"802\":1}}],[\"比如异常判断\",{\"1\":{\"790\":1}}],[\"比如这里并没有包含项目中用到的一些其他依赖\",{\"1\":{\"854\":1}}],[\"比如这里我们添加了mybatis的依赖到原项目中\",{\"1\":{\"841\":1}}],[\"比如这里包含类名\",{\"1\":{\"765\":1}}],[\"比如这里就是通过空格分隔\",{\"1\":{\"244\":1}}],[\"比如handler的构造方法\",{\"1\":{\"756\":1}}],[\"比如下面\",{\"1\":{\"747\":1}}],[\"比如下面的这个例子\",{\"1\":{\"343\":1}}],[\"比如边充电边打电话就是个危险操作\",{\"1\":{\"727\":1}}],[\"比如插入一个用户\",{\"1\":{\"713\":1}}],[\"比如每个用户现在都有一个小组\",{\"1\":{\"672\":1}}],[\"比如每个同学的学号都是不一样的\",{\"1\":{\"550\":1}}],[\"比如小于\",{\"1\":{\"653\":1}}],[\"比如转换为一个map对象\",{\"1\":{\"650\":1}}],[\"比如类中的哪个字段对应数据库中的哪个字段\",{\"1\":{\"643\":1}}],[\"比如类的成员变量\",{\"1\":{\"328\":1}}],[\"比如根节点下就囊括了所有的节点\",{\"1\":{\"636\":1}}],[\"比如要根据id修改用户的年龄\",{\"1\":{\"680\":1}}],[\"比如要依次删除很多个表的数据\",{\"1\":{\"599\":1}}],[\"比如要共享某些数据\",{\"1\":{\"138\":1}}],[\"比如在insert操作时\",{\"1\":{\"598\":1}}],[\"比如现在有一个存储所有用户的表\",{\"1\":{\"586\":1}}],[\"比如现在我们希望在查询用户时\",{\"1\":{\"691\":1}}],[\"比如现在我们有一个这样的构造方法\",{\"1\":{\"658\":1}}],[\"比如现在我们有一个abcd\",{\"1\":{\"331\":1}}],[\"比如现在我们写了这些类\",{\"1\":{\"347\":1}}],[\"比如现在我们想要实现之前的这个奇葩需求\",{\"1\":{\"719\":1}}],[\"比如现在我们想要批量插入一些用户到数据库里面\",{\"1\":{\"694\":1}}],[\"比如现在我们想要让数据从大到小排列\",{\"1\":{\"14\":1}}],[\"比如现在我们想去批量下载某个网站的壁纸\",{\"1\":{\"333\":1}}],[\"比如现在我们想执行\",{\"1\":{\"323\":1}}],[\"比如现在我们创建了一个新的maven项目\",{\"1\":{\"311\":1}}],[\"比如性别只能是男或是女\",{\"1\":{\"550\":1}}],[\"比如失败的情况只需要code和message\",{\"1\":{\"366\":1}}],[\"比如一个老师可以教很多个学生\",{\"1\":{\"550\":1}}],[\"比如一个学生的特征包括姓名\",{\"1\":{\"550\":1}}],[\"比如一个api结果返回值的类result\",{\"1\":{\"366\":1}}],[\"比如一些集合允许重复的元素\",{\"1\":{\"21\":1}}],[\"比如双引号等\",{\"1\":{\"341\":1}}],[\"比如需要的服务等\",{\"1\":{\"310\":1}}],[\"比如runnable接口需要一个方法体对它的run\",{\"1\":{\"289\":1}}],[\"比如是因为什么原因导致的异常\",{\"1\":{\"266\":1}}],[\"比如object类中定义的clone方法\",{\"1\":{\"264\":1}}],[\"比如数组越界异常\",{\"1\":{\"264\":1}}],[\"比如字符串的裁剪\",{\"1\":{\"244\":1}}],[\"比如之前悬念中的value变量\",{\"1\":{\"154\":1}}],[\"比如string\",{\"1\":{\"648\":1}}],[\"比如scanner获取输入的文本\",{\"1\":{\"142\":1}}],[\"比如system\",{\"1\":{\"127\":1}}],[\"比如com\",{\"1\":{\"120\":1}}],[\"比如键盘发送的信号\",{\"1\":{\"108\":1}}],[\"比如筛选\",{\"1\":{\"71\":1}}],[\"比如上面的例子\",{\"1\":{\"835\":1}}],[\"比如上面的type=\",{\"1\":{\"634\":1}}],[\"比如上面的学生信息\",{\"1\":{\"56\":1}}],[\"比如上我们定义的是类型\",{\"1\":{\"14\":1}}],[\"比如我们的数据库连接相关信息\",{\"1\":{\"902\":1}}],[\"比如我们在这里编写一个mybatis的配置文件\",{\"1\":{\"834\":1}}],[\"比如我们上面的lombok\",{\"1\":{\"833\":1}}],[\"比如我们上面用的\",{\"1\":{\"306\":1}}],[\"比如我们这里使用的是org\",{\"1\":{\"820\":1}}],[\"比如我们希望测试某个枚举类型下所有的枚举作为参数进行测试\",{\"1\":{\"810\":1}}],[\"比如我们希望配置usegeneratedkeys来得到自动生成的主键\",{\"1\":{\"714\":1}}],[\"比如我们希望某个操作执行完成后\",{\"1\":{\"704\":1}}],[\"比如我们希望在根据id查询用户时\",{\"1\":{\"690\":1}}],[\"比如我们希望在读取到某个元素时截断\",{\"1\":{\"322\":1}}],[\"比如我们要估计某个随机变量x的\",{\"1\":{\"473\":1}}],[\"比如我们从数据库中查询的账户信息\",{\"1\":{\"344\":1}}],[\"比如我们来做一个简单的计算\",{\"1\":{\"316\":1}}],[\"比如我们现在想配置默认的日志打印级别\",{\"1\":{\"756\":1}}],[\"比如我们现在要配置数据库的连接信息\",{\"1\":{\"753\":1}}],[\"比如我们现在需要对一个数组进行排序\",{\"1\":{\"292\":1}}],[\"比如我们现在不希望使用object类中提供的equals方法\",{\"1\":{\"216\":1}}],[\"比如我们之前要重写一个类的equals方法\",{\"1\":{\"342\":1}}],[\"比如我们之前使用的runable类\",{\"1\":{\"290\":1}}],[\"比如我们之前学习的顺序表\",{\"1\":{\"23\":1}}],[\"比如我们想要查询所有年龄大于等于18岁的用户\",{\"1\":{\"653\":1}}],[\"比如我们想要编写一个根据成绩得到等级的方法\",{\"1\":{\"338\":1}}],[\"比如我们想要打印数组\",{\"1\":{\"275\":1}}],[\"比如我们想计算某个学生的所有科目分数之后\",{\"1\":{\"65\":1}}],[\"比如我们可以使用\",{\"1\":{\"316\":1}}],[\"比如我们可以判断变量的值\",{\"1\":{\"268\":1}}],[\"比如我们可以来看看下面这个问题\",{\"1\":{\"154\":1}}],[\"比如我们可以直接当做栈来进行使用\",{\"1\":{\"44\":1}}],[\"比如我们运行qq\",{\"1\":{\"138\":1}}],[\"比如我们经常访问的\",{\"1\":{\"120\":1}}],[\"比如\",{\"1\":{\"23\":1,\"203\":1,\"264\":1,\"288\":1,\"291\":1,\"554\":1,\"580\":1,\"584\":1,\"587\":1,\"660\":1,\"761\":1,\"773\":1,\"793\":1,\"804\":1,\"851\":1}}],[\"比如说\",{\"1\":{\"14\":1,\"219\":1,\"365\":3}}],[\"级别\",{\"1\":{\"765\":1}}],[\"级别低于普通信息\",{\"1\":{\"728\":1}}],[\"级别划分\",{\"0\":{\"727\":1}}],[\"祝你明天就遇到我\",{\"1\":{\"728\":1}}],[\"严重的错误\",{\"1\":{\"728\":1}}],[\"严格等于\",{\"1\":{\"529\":1}}],[\"十一月\",{\"1\":{\"725\":1}}],[\"十六进制哈希值\",{\"1\":{\"215\":1}}],[\"彻底抛弃xml配置\",{\"1\":{\"721\":1}}],[\"彻底封死\",{\"1\":{\"347\":1}}],[\"咱们把配置文件也给变成代码配置\",{\"1\":{\"721\":1}}],[\"构建\",{\"0\":{\"865\":1}}],[\"构建完成后\",{\"1\":{\"719\":1}}],[\"构造函数\",{\"1\":{\"803\":1}}],[\"构造函数或方法上\",{\"1\":{\"368\":1}}],[\"构造函数也不能赋值\",{\"1\":{\"217\":1}}],[\"构造器\",{\"1\":{\"9\":1,\"191\":1}}],[\"构造方法的编写会非常麻烦\",{\"1\":{\"627\":1}}],[\"构造方法直接使用new关键字就行\",{\"1\":{\"296\":1}}],[\"构造方法作为方法引用\",{\"0\":{\"296\":1}}],[\"构造方法也可以被引用\",{\"1\":{\"258\":1}}],[\"构造方法得到字符串\",{\"1\":{\"91\":1}}],[\"构造方法会在new的时候自动执行\",{\"1\":{\"9\":1}}],[\"构造方法会在对象创建时执行\",{\"1\":{\"9\":1}}],[\"构造方法不需要指定返回值\",{\"1\":{\"9\":1}}],[\"构造方法不需要填写返回值\",{\"1\":{\"9\":1}}],[\"构造方法\",{\"0\":{\"9\":1},\"1\":{\"9\":1,\"25\":1,\"344\":1}}],[\"假如现在我们的实体类字段名称与数据库不同\",{\"1\":{\"715\":1}}],[\"假设工具\",{\"0\":{\"791\":1}}],[\"假设仓库管理关系表为storehousemanage\",{\"1\":{\"556\":1}}],[\"假设有\",{\"1\":{\"516\":1}}],[\"假设我们要根据用户的id进行数据的删除\",{\"1\":{\"681\":1}}],[\"假设我们每个用户都有一个自己的详细信息表\",{\"1\":{\"666\":1}}],[\"假设我们现在需要编写一个根据id查询用户的操作\",{\"1\":{\"648\":1}}],[\"假设我们具有\",{\"1\":{\"490\":1}}],[\"假设我们可以得到有关随机变量\",{\"1\":{\"484\":1}}],[\"假设我们需要求解如下方程\",{\"1\":{\"470\":1}}],[\"假设我们有了一系列\",{\"1\":{\"452\":1}}],[\"假设\",{\"1\":{\"468\":1,\"528\":1,\"791\":1}}],[\"假设功率q=qn​\",{\"1\":{\"385\":1}}],[\"假设厨师炒出一个菜的时间为3秒\",{\"1\":{\"174\":1}}],[\"女\",{\"1\":{\"714\":1}}],[\"速度上会慢一些\",{\"1\":{\"701\":1}}],[\"弱引用\",{\"1\":{\"701\":1}}],[\"二级缓存配置\",{\"0\":{\"720\":1}}],[\"二级缓存才会被更新\",{\"1\":{\"701\":1}}],[\"二级缓存是事务性的\",{\"1\":{\"701\":1}}],[\"二级缓存是mapper级别的\",{\"1\":{\"701\":1}}],[\"二级缓存默认是关闭状态\",{\"1\":{\"701\":1}}],[\"二级缓存\",{\"0\":{\"701\":1}}],[\"二分搜索\",{\"0\":{\"77\":1}}],[\"极大的简化了我们之前jdbc那样的代码编写模式\",{\"1\":{\"710\":1}}],[\"极大地提升了sql语句编写的的灵活性\",{\"1\":{\"689\":1}}],[\"极大简化了之前的流程\",{\"1\":{\"642\":1}}],[\"批处理\",{\"0\":{\"688\":1}}],[\"批量插入\",{\"0\":{\"694\":1}}],[\"批量删除\",{\"0\":{\"693\":1}}],[\"批量获取\",{\"1\":{\"333\":1}}],[\"批量操作\",{\"1\":{\"56\":1}}],[\"像极了爱情\",{\"1\":{\"918\":1}}],[\"像这样\",{\"1\":{\"803\":1}}],[\"像这种一对一查询该怎么实现呢\",{\"1\":{\"666\":1}}],[\"像这种只有一个方法需要实现的接口\",{\"1\":{\"14\":1}}],[\"像\",{\"1\":{\"679\":1}}],[\"改\",{\"1\":{\"677\":1}}],[\"改进的\",{\"0\":{\"319\":1}}],[\"删\",{\"1\":{\"677\":1}}],[\"删除操作则更为简单\",{\"1\":{\"681\":1}}],[\"删除\",{\"0\":{\"681\":1},\"1\":{\"613\":1}}],[\"删除数据\",{\"0\":{\"573\":1}}],[\"删除表\",{\"0\":{\"569\":1}}],[\"删除2到4这个范围内的字符\",{\"1\":{\"245\":1}}],[\"删除就完事\",{\"1\":{\"25\":1}}],[\"删除的是另一个对象\",{\"1\":{\"25\":1}}],[\"删除的是下标为10的元素\",{\"1\":{\"25\":1}}],[\"删除所有元素\",{\"1\":{\"23\":1}}],[\"们可以在查询user表的时候\",{\"1\":{\"668\":1}}],[\"嵌套类的执行同样可以通过\",{\"1\":{\"805\":1}}],[\"嵌套测试\",{\"0\":{\"805\":1}}],[\"嵌套\",{\"0\":{\"668\":1},\"1\":{\"666\":1}}],[\"嵌套结果映射\",{\"0\":{\"667\":1},\"1\":{\"666\":1}}],[\"嵌套查询来解决\",{\"1\":{\"671\":1}}],[\"嵌套查询\",{\"0\":{\"587\":1,\"671\":1}}],[\"名称便不可更改\",{\"1\":{\"909\":1}}],[\"名称等信息\",{\"1\":{\"795\":1}}],[\"名称分级\",{\"0\":{\"747\":1}}],[\"名称随意\",{\"1\":{\"725\":1}}],[\"名称随便\",{\"1\":{\"648\":1}}],[\"名称最好和数据库字段名称保持一致\",{\"1\":{\"643\":1}}],[\"名字一般为xxx\",{\"1\":{\"735\":1}}],[\"名字\",{\"1\":{\"4\":1}}],[\"配置连接数据库\",{\"1\":{\"889\":1}}],[\"配置多个访问路径\",{\"0\":{\"880\":1}}],[\"配置很简单\",{\"1\":{\"865\":1}}],[\"配置为国内的阿里云仓库地址了\",{\"1\":{\"827\":1}}],[\"配置文件\",{\"1\":{\"888\":1}}],[\"配置文件修改\",{\"0\":{\"764\":1}}],[\"配置文件完成后\",{\"1\":{\"641\":1}}],[\"配置consolehandler的默认level\",{\"1\":{\"756\":1,\"768\":1}}],[\"配置方式和之前几乎一致\",{\"1\":{\"717\":1}}],[\"配置\",{\"0\":{\"716\":1,\"719\":1,\"888\":1,\"914\":1}}],[\"配置这些额外的参数\",{\"0\":{\"714\":1}}],[\"配置完成后\",{\"1\":{\"652\":1,\"667\":1,\"865\":1}}],[\"配置lombok\",{\"0\":{\"628\":1}}],[\"含包名\",{\"1\":{\"641\":1,\"888\":1}}],[\"含噪声\",{\"1\":{\"478\":1}}],[\"含噪音\",{\"1\":{\"471\":1}}],[\"$proxy4\",{\"1\":{\"659\":1}}],[\"$\",{\"1\":{\"641\":4,\"888\":4}}],[\"初始化参数类似于初始化配置需要的一些值\",{\"1\":{\"902\":1}}],[\"初始化参数\",{\"0\":{\"902\":1}}],[\"初始化得到\",{\"1\":{\"889\":1}}],[\"初始化后调用\",{\"1\":{\"872\":1}}],[\"初始化\",{\"1\":{\"872\":1}}],[\"初始化操作只会执行一次\",{\"1\":{\"803\":1}}],[\"初始容量为16\",{\"1\":{\"59\":1}}],[\"初次使用\",{\"0\":{\"641\":1}}],[\"节省性能开销\",{\"1\":{\"699\":1}}],[\"节点可以是一个带有内容的标签\",{\"1\":{\"636\":1}}],[\"节所述\",{\"1\":{\"453\":1}}],[\"解压\",{\"1\":{\"864\":1}}],[\"解析xml文件\",{\"0\":{\"636\":1}}],[\"解决方案\",{\"0\":{\"386\":1}}],[\"区分大小写\",{\"1\":{\"634\":1}}],[\"区别于贝尔曼公式\",{\"1\":{\"430\":1}}],[\"避免了几乎所有的\",{\"1\":{\"633\":1}}],[\"合理地使用这些技术\",{\"1\":{\"633\":1}}],[\"合格\",{\"1\":{\"280\":1}}],[\"放入到这个文件夹中\",{\"1\":{\"834\":1}}],[\"放入缓冲区再经过转换流输出到给定的输出流上\",{\"1\":{\"127\":1}}],[\"放在项目目录下直接导入就行了\",{\"1\":{\"628\":1}}],[\"炸\",{\"1\":{\"627\":1}}],[\"爆\",{\"1\":{\"627\":1}}],[\"长\",{\"1\":{\"627\":1}}],[\"长度不固定\",{\"1\":{\"563\":1}}],[\"长度不超过\",{\"1\":{\"71\":1}}],[\"长度是在一开始创建数组的时候就确定好的\",{\"1\":{\"236\":1}}],[\"撤销前面全部操作\",{\"1\":{\"623\":2}}],[\"乍一看好像没啥问题\",{\"1\":{\"621\":1}}],[\"行为\",{\"1\":{\"779\":1}}],[\"行\",{\"1\":{\"613\":1}}],[\"行不行\",{\"1\":{\"245\":2}}],[\"了解了一对多\",{\"1\":{\"672\":1}}],[\"了解了以上的相关知识后\",{\"1\":{\"311\":1}}],[\"了解即可\",{\"1\":{\"652\":1}}],[\"了解statement\",{\"0\":{\"608\":1}}],[\"了解connection\",{\"0\":{\"607\":1}}],[\"`group`\",{\"1\":{\"672\":1}}],[\"`groups`\",{\"1\":{\"672\":2}}],[\"`com\",{\"1\":{\"605\":2}}],[\"``\",{\"1\":{\"192\":1}}],[\"连接的url如果记不住格式\",{\"1\":{\"605\":1}}],[\"连接示例\",{\"0\":{\"536\":1}}],[\"释放资源\",{\"1\":{\"605\":1}}],[\"又依次返回到最前面的filter\",{\"1\":{\"920\":1}}],[\"又要挨个进行修改\",{\"1\":{\"627\":1}}],[\"又兼备存储的优势\",{\"1\":{\"604\":1}}],[\"又比如每个同学都有一个学号与其唯一对应\",{\"1\":{\"550\":1}}],[\"根本上说jdbc是一种规范\",{\"1\":{\"604\":1}}],[\"根据已有的基础\",{\"1\":{\"887\":1}}],[\"根据通过\",{\"1\":{\"804\":1}}],[\"根据测试方法的名称和形式参数列表\",{\"1\":{\"804\":1}}],[\"根据显示名称对测试方法进行字母数字排序\",{\"1\":{\"804\":1}}],[\"根据我们上节课学习的知识\",{\"1\":{\"745\":1}}],[\"根据不同类型的信息进行划分\",{\"1\":{\"726\":1}}],[\"根据不同的分支\",{\"1\":{\"340\":1}}],[\"根据这个式子我们就可以通过\",{\"1\":{\"529\":1}}],[\"根据梯度下降的公式\",{\"1\":{\"516\":1}}],[\"根据策略\",{\"1\":{\"452\":1}}],[\"根据策略π\",{\"1\":{\"422\":1}}],[\"根据对应的\",{\"1\":{\"440\":1}}],[\"根据\",{\"1\":{\"427\":2,\"436\":1,\"437\":1,\"440\":1,\"442\":1,\"487\":1,\"913\":1}}],[\"根据一个\",{\"1\":{\"416\":1}}],[\"根据所给定的用户划分情况\",{\"1\":{\"387\":1}}],[\"根据遗传算法找到cn​个最优个体作为簇的中心\",{\"1\":{\"387\":1}}],[\"根据n个用户\",{\"1\":{\"387\":1}}],[\"根据mos数值\",{\"1\":{\"384\":1}}],[\"根据香农定理\",{\"1\":{\"383\":1}}],[\"根据字符串中的\",{\"1\":{\"331\":2}}],[\"根据上面的推导\",{\"1\":{\"60\":1}}],[\"根据给定的策略\",{\"1\":{\"486\":1}}],[\"根据给定的键\",{\"1\":{\"56\":1}}],[\"根据给定的predicate条件进行元素移除操作\",{\"1\":{\"23\":1}}],[\"根据初始化大小\",{\"1\":{\"25\":1}}],[\"官方已经给我们预设了一些项目了\",{\"1\":{\"864\":1}}],[\"官方文档\",{\"1\":{\"812\":1}}],[\"官方解释它主要用于惰性获取数据\",{\"1\":{\"653\":1}}],[\"官方解释它是java编程语言和广泛的数据库之间独立于数据库的连接标准的java\",{\"1\":{\"604\":1}}],[\"官方提供的模块\",{\"1\":{\"306\":1}}],[\"回滚到回滚点\",{\"1\":{\"623\":1}}],[\"回滚到指定回滚点\",{\"1\":{\"599\":1}}],[\"回滚之前的内容都没了\",{\"1\":{\"623\":2}}],[\"回滚\",{\"1\":{\"623\":1}}],[\"回滚点\",{\"1\":{\"599\":2}}],[\"回滚事务\",{\"1\":{\"599\":1}}],[\"回到mark时的位置\",{\"1\":{\"108\":1}}],[\"持久性\",{\"1\":{\"599\":1}}],[\"读提交\",{\"1\":{\"599\":1}}],[\"读取实体类肯定需要一个映射规则\",{\"1\":{\"643\":1}}],[\"读取后直接得到一个字符串\",{\"1\":{\"112\":1}}],[\"读取一个少一个\",{\"1\":{\"91\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"599\":1}}],[\"隔离性\",{\"1\":{\"599\":1}}],[\"隔开即可\",{\"1\":{\"219\":1}}],[\"串联性以及后续数据库可以自发性地完成预定的工作\",{\"1\":{\"599\":1}}],[\"事务相关操作非常简单\",{\"1\":{\"682\":1}}],[\"事务操作\",{\"0\":{\"682\":1}}],[\"事务等\",{\"1\":{\"604\":1}}],[\"事务处理结束后\",{\"1\":{\"599\":1}}],[\"事务隔离分为不同级别\",{\"1\":{\"599\":1}}],[\"事务在执行过程中发生错误\",{\"1\":{\"599\":1}}],[\"事务具有以下特性\",{\"1\":{\"599\":1}}],[\"事务\",{\"0\":{\"599\":1}}],[\"旧的内容会被移到old表中\",{\"1\":{\"598\":2}}],[\"旧容量不大于0只可能是还没初始化\",{\"1\":{\"60\":1}}],[\"触发器名称\",{\"1\":{\"598\":2}}],[\"触发器所依附的表称为基本表\",{\"1\":{\"598\":1}}],[\"触发器显得更加灵活\",{\"1\":{\"598\":1}}],[\"触发器通常用于检查内容的安全性\",{\"1\":{\"598\":1}}],[\"触发器就像其名字一样\",{\"1\":{\"598\":1}}],[\"触发器\",{\"0\":{\"598\":1}}],[\"能够直接访问webapp目录下的静态页面\",{\"1\":{\"871\":1}}],[\"能够非常方便地从互联网上的一个站点访问另一个站点\",{\"1\":{\"859\":1}}],[\"能够大大提高我们的查询效率\",{\"1\":{\"597\":1}}],[\"能否一次性地过滤掉没有登录验证的用户呢\",{\"1\":{\"918\":1}}],[\"能否简化一下这个流程呢\",{\"1\":{\"766\":1}}],[\"能否实现无需xml映射器配置\",{\"1\":{\"710\":1}}],[\"能匹配\",{\"1\":{\"246\":2}}],[\"索引为我们带来高速查询效率的同时\",{\"1\":{\"597\":1}}],[\"索引方法\",{\"1\":{\"597\":1}}],[\"索引类型包括\",{\"1\":{\"597\":1}}],[\"索引名称\",{\"1\":{\"597\":2}}],[\"索引\",{\"0\":{\"597\":1}}],[\"子项目只需要使用即可\",{\"1\":{\"850\":1}}],[\"子项目需要什么再拿什么即可\",{\"1\":{\"850\":1}}],[\"子项目的依赖失效了\",{\"1\":{\"850\":1}}],[\"子项目可以选取需要的作为依赖\",{\"1\":{\"850\":1}}],[\"子项目也成功继承了lombok依赖\",{\"1\":{\"849\":1}}],[\"子项目会继承父项目的所有依赖\",{\"1\":{\"849\":1}}],[\"子项目直接继承父项目的groupid\",{\"1\":{\"849\":1}}],[\"子logger会继承父logger提供的所有handler进行日志处理\",{\"1\":{\"744\":1}}],[\"子查询语句\",{\"1\":{\"596\":1}}],[\"子类也可以定义\",{\"1\":{\"218\":1}}],[\"子类对应必须是\",{\"1\":{\"218\":1}}],[\"子类必须要实现抽象类所有的抽象方法\",{\"1\":{\"218\":1}}],[\"子类\",{\"1\":{\"218\":1,\"347\":2}}],[\"子类是\",{\"1\":{\"214\":1}}],[\"子类实现了父类所有非私有化的属性和方法\",{\"1\":{\"212\":1}}],[\"子类我们会在下一章介绍\",{\"1\":{\"121\":1}}],[\"子类初始化时\",{\"1\":{\"118\":1}}],[\"代表项目版本\",{\"1\":{\"820\":1}}],[\"代表为所有的数据库和表都授权\",{\"1\":{\"591\":1}}],[\"代码进行动态拼接的结果\",{\"1\":{\"870\":1}}],[\"代码和手动设置参数以及获取结果集\",{\"1\":{\"633\":1}}],[\"代码的健壮性有所欠缺\",{\"1\":{\"280\":1}}],[\"代码语句\",{\"1\":{\"257\":1,\"289\":1,\"290\":1}}],[\"代码块\",{\"1\":{\"155\":1}}],[\"代码块中的内容会在对象创建时仅执行一次\",{\"1\":{\"9\":1}}],[\"代码块同样会在对象构造之前进行\",{\"1\":{\"9\":1}}],[\"权限2\",{\"1\":{\"591\":2}}],[\"密码等\",{\"1\":{\"641\":1}}],[\"密码\",{\"1\":{\"589\":1,\"621\":1,\"622\":1,\"623\":4,\"641\":1,\"886\":1,\"888\":1}}],[\"密封类型有以下要求\",{\"1\":{\"347\":1}}],[\"密封类型可以说是java\",{\"1\":{\"346\":1}}],[\"密封类型\",{\"0\":{\"346\":1}}],[\"庞大的数据库不可能由一个人来管理\",{\"1\":{\"588\":1}}],[\"起始位置\",{\"1\":{\"583\":1}}],[\"约束条件\",{\"1\":{\"583\":1}}],[\"约束要求该列的每一行必须有一个非空值\",{\"1\":{\"564\":1}}],[\"统计某列的值总和\",{\"1\":{\"582\":1}}],[\"统计所有的行数\",{\"1\":{\"582\":1}}],[\"聚集函数一般用作统计\",{\"1\":{\"582\":1}}],[\"聚集函数\",{\"0\":{\"582\":1}}],[\"聚合max\",{\"1\":{\"358\":1}}],[\"聚合等\",{\"1\":{\"71\":1}}],[\"别名2\",{\"1\":{\"585\":1}}],[\"别名1\",{\"1\":{\"585\":1}}],[\"别名\",{\"0\":{\"649\":1},\"1\":{\"579\":1}}],[\"别人如果需要将我们编写的代码作为依赖\",{\"1\":{\"820\":1}}],[\"别人将某个方法设置为private一定有他的理由\",{\"1\":{\"192\":1}}],[\"别人来调用我们的实现\",{\"1\":{\"14\":1}}],[\"警告的内容\",{\"1\":{\"728\":1}}],[\"警告\",{\"1\":{\"572\":1}}],[\"条件方法需要static\",{\"1\":{\"797\":1}}],[\"条件方法可以位于测试类之外\",{\"1\":{\"797\":1}}],[\"条件测试和执行\",{\"0\":{\"792\":1}}],[\"条件判断\",{\"0\":{\"690\":1}}],[\"条件\",{\"1\":{\"572\":1,\"573\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":2,\"584\":1,\"587\":1}}],[\"条件转换掉\",{\"1\":{\"459\":1}}],[\"列的下标是从1开始的\",{\"1\":{\"616\":1}}],[\"列的值必须大于或等于\",{\"1\":{\"564\":1}}],[\"列的值是唯一的\",{\"1\":{\"564\":1}}],[\"列1\",{\"1\":{\"591\":2}}],[\"列名=值\",{\"1\":{\"572\":1}}],[\"列名2\",{\"1\":{\"571\":2,\"581\":1}}],[\"列名1\",{\"1\":{\"571\":2,\"581\":1}}],[\"列名\",{\"1\":{\"567\":2,\"568\":2,\"579\":4,\"581\":1,\"582\":6,\"583\":2,\"587\":2,\"596\":1,\"597\":1}}],[\"列不能为\",{\"1\":{\"564\":1}}],[\"列在未指定值时默认值为\",{\"1\":{\"564\":1}}],[\"列\",{\"1\":{\"564\":1}}],[\"列是外键\",{\"1\":{\"564\":1}}],[\"列是主键\",{\"1\":{\"564\":1}}],[\"列级约束有六种\",{\"1\":{\"564\":1}}],[\"列级约束条件\",{\"0\":{\"564\":1},\"1\":{\"567\":2,\"568\":1}}],[\"列表如下\",{\"1\":{\"779\":1}}],[\"列表中允许存在相同元素\",{\"1\":{\"25\":1}}],[\"列表中允许存在重复元素\",{\"1\":{\"24\":1}}],[\"列表\",{\"0\":{\"24\":1},\"1\":{\"24\":1,\"84\":1}}],[\"负责对数据库对象运行数据访问工作的指令集\",{\"1\":{\"561\":1}}],[\"负载因子默认为0\",{\"1\":{\"60\":1}}],[\"负载因子\",{\"1\":{\"58\":1}}],[\"→\",{\"1\":{\"556\":4}}],[\"管理事务\",{\"0\":{\"623\":1}}],[\"管理员id\",{\"1\":{\"556\":6}}],[\"管理和操作我们的数据而存在的\",{\"1\":{\"21\":1}}],[\"仓库id\",{\"1\":{\"556\":6}}],[\"书籍\",{\"1\":{\"555\":1}}],[\"书籍作者\",{\"1\":{\"555\":2}}],[\"书籍名称\",{\"1\":{\"555\":2}}],[\"书籍编号\",{\"1\":{\"555\":3}}],[\"借阅编号\",{\"1\":{\"555\":2}}],[\"借用\",{\"1\":{\"475\":1}}],[\"满足第三范式\",{\"1\":{\"555\":1}}],[\"满足第一范式是关系型数据库最基本的要求\",{\"1\":{\"553\":1}}],[\"满足f\",{\"1\":{\"432\":1}}],[\"手机号码\",{\"1\":{\"553\":1}}],[\"手动修改\",{\"0\":{\"763\":1}}],[\"手动调用connect方法进行连接\",{\"1\":{\"538\":1}}],[\"手动调用wait\",{\"1\":{\"143\":1}}],[\"手动编译一个\",{\"1\":{\"199\":1}}],[\"座机号码\",{\"1\":{\"553\":1}}],[\"电话号码实际上包括了家用座机电话和移动电话\",{\"1\":{\"553\":1}}],[\"电话号码\",{\"1\":{\"553\":1}}],[\"授课\",{\"1\":{\"551\":1}}],[\"授课表\",{\"1\":{\"551\":1}}],[\"教师号\",{\"1\":{\"551\":2}}],[\"教师\",{\"1\":{\"551\":1}}],[\"教师表\",{\"1\":{\"551\":1}}],[\"姓名和性别都会因此发生改变\",{\"1\":{\"554\":1}}],[\"姓名\",{\"1\":{\"551\":2,\"553\":2,\"554\":1}}],[\"专家\",{\"1\":{\"817\":1}}],[\"专业等\",{\"1\":{\"550\":1}}],[\"专门创建一个独属于某个线程的变量\",{\"1\":{\"162\":1}}],[\"专门用于表示一个文件或文件夹\",{\"1\":{\"98\":1}}],[\"专门用于处理文本数据\",{\"1\":{\"88\":1}}],[\"年级\",{\"1\":{\"550\":1}}],[\"年龄\",{\"1\":{\"4\":1,\"9\":1,\"550\":1}}],[\"免费\",{\"1\":{\"549\":1}}],[\"探测双方的tcp\",{\"1\":{\"538\":1}}],[\"看系统内核参数配置\",{\"1\":{\"538\":1}}],[\"看看如何使用模块机制\",{\"1\":{\"307\":1}}],[\"看看是否还有下一个元素\",{\"1\":{\"32\":1}}],[\"省略\",{\"1\":{\"536\":1}}],[\"梯度上升算法的本质就是最大化目标函数\",{\"1\":{\"530\":1}}],[\"梯度上升算法\",{\"0\":{\"530\":1}}],[\"梯度下降\",{\"1\":{\"510\":1}}],[\"梯度下降法\",{\"1\":{\"475\":1}}],[\"近似\",{\"1\":{\"529\":1}}],[\"概念\",{\"1\":{\"817\":1}}],[\"概念上的定义\",{\"1\":{\"4\":1}}],[\"概率分布\",{\"1\":{\"524\":1}}],[\"确实向服务器发起了一个post请求\",{\"1\":{\"886\":1}}],[\"确保某列的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"565\":1}}],[\"确保列中的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"564\":1}}],[\"确保列中的每个值都是唯一的\",{\"1\":{\"564\":2}}],[\"确保根是存在且唯一的\",{\"1\":{\"472\":1}}],[\"确定\",{\"1\":{\"522\":1}}],[\"经过前面的学习\",{\"1\":{\"768\":1}}],[\"经验回放\",{\"0\":{\"517\":1}}],[\"经常遇到空指针异常\",{\"1\":{\"343\":1}}],[\"复杂判断\",{\"0\":{\"789\":1}}],[\"复杂查询\",{\"0\":{\"665\":1}}],[\"复制一份即可\",{\"1\":{\"605\":1}}],[\"复制到\",{\"1\":{\"516\":1}}],[\"复位中断标记\",{\"1\":{\"144\":2}}],[\"固定不动\",{\"1\":{\"516\":1}}],[\"固定\",{\"1\":{\"516\":1}}],[\"≥0\",{\"1\":{\"509\":1,\"524\":1,\"529\":1}}],[\"≥vπ​\",{\"1\":{\"427\":1}}],[\"认为所有状态都是同等重要的\",{\"1\":{\"508\":1}}],[\"寻找一个最优的参数w\",{\"1\":{\"506\":1}}],[\"版本号也会不断更新\",{\"1\":{\"820\":1}}],[\"版本\",{\"0\":{\"499\":1,\"500\":1},\"1\":{\"795\":1}}],[\"版本要求\",{\"1\":{\"371\":1}}],[\"≐e\",{\"1\":{\"529\":1}}],[\"≐g\",{\"1\":{\"484\":1}}],[\"≐w−x\",{\"1\":{\"473\":1}}],[\"≐w−e\",{\"1\":{\"473\":1}}],[\"ω=e\",{\"1\":{\"484\":1}}],[\"期望的情况\",{\"1\":{\"479\":1}}],[\"∇w​f\",{\"1\":{\"478\":2}}],[\"往往可以转化为导数为\",{\"1\":{\"478\":1}}],[\"=\",{\"1\":{\"490\":1,\"494\":1}}],[\"=e\",{\"1\":{\"478\":1}}],[\"=n\",{\"1\":{\"382\":1,\"385\":1,\"387\":1}}],[\"视图名\",{\"1\":{\"598\":1}}],[\"视图名称\",{\"1\":{\"596\":1}}],[\"视图本质就是一个查询的结果\",{\"1\":{\"596\":1}}],[\"视图\",{\"0\":{\"596\":1}}],[\"视图一起删除\",{\"1\":{\"568\":1}}],[\"视为一个特殊情况下的\",{\"1\":{\"478\":1}}],[\"视为\",{\"1\":{\"478\":1,\"516\":1}}],[\"视频等二进制数据\",{\"1\":{\"88\":1}}],[\"⇓wk+1​=wk​−αk​▽w​f\",{\"1\":{\"478\":1}}],[\"转义字符\",{\"0\":{\"635\":1}}],[\"转化为\",{\"1\":{\"477\":1}}],[\"转换\",{\"0\":{\"650\":1}}],[\"转换到\",{\"1\":{\"504\":1}}],[\"转换到状态s\",{\"1\":{\"394\":1}}],[\"转换为httpservletresponse\",{\"1\":{\"875\":1}}],[\"转换为\",{\"1\":{\"432\":1,\"450\":1,\"451\":1,\"522\":1}}],[\"转换为数字666\",{\"1\":{\"228\":1}}],[\"转换流\",{\"0\":{\"126\":1,\"365\":1}}],[\"▽w​q^​\",{\"1\":{\"516\":2}}],[\"▽w​qt​^​\",{\"1\":{\"513\":1,\"514\":1}}],[\"▽w​vt​^​\",{\"1\":{\"510\":1,\"511\":1,\"512\":1}}],[\"▽w​v^\",{\"1\":{\"510\":1}}],[\"▽w​\",{\"1\":{\"510\":1}}],[\"▽w​j​=e\",{\"1\":{\"516\":1}}],[\"▽w​j\",{\"1\":{\"478\":1,\"510\":1}}],[\"▽w​f\",{\"1\":{\"475\":2,\"478\":10}}],[\"▽θ​π\",{\"1\":{\"529\":1}}],[\"▽θ​lnπ\",{\"1\":{\"529\":6,\"530\":1}}],[\"▽θ​ln\",{\"1\":{\"400\":3}}],[\"▽θ​j\",{\"1\":{\"400\":1,\"529\":3}}],[\"⋅▽w​q^​\",{\"1\":{\"516\":1}}],[\"⋅\",{\"1\":{\"475\":1,\"484\":1}}],[\"η\",{\"1\":{\"473\":2,\"478\":2,\"484\":1,\"529\":1}}],[\"ηk2​∣hk​\",{\"1\":{\"472\":1}}],[\"ηk​∣hk​\",{\"1\":{\"472\":1}}],[\"ηk​\",{\"1\":{\"471\":3,\"473\":1,\"478\":1,\"484\":1}}],[\"问题\",{\"0\":{\"746\":1},\"1\":{\"477\":1,\"478\":1,\"484\":1}}],[\"问题转化\",{\"0\":{\"477\":1}}],[\"问题引入\",{\"0\":{\"470\":1,\"475\":1}}],[\"问题进行研究\",{\"1\":{\"466\":1}}],[\"针对\",{\"1\":{\"466\":1}}],[\"针对于string类的方法增强\",{\"0\":{\"331\":1}}],[\"针对于这些特性\",{\"1\":{\"24\":1}}],[\"找到logging\",{\"1\":{\"864\":1}}],[\"找到mirros标签\",{\"1\":{\"827\":1}}],[\"找到settings\",{\"1\":{\"827\":1}}],[\"找到安装根目录\",{\"1\":{\"827\":1}}],[\"找到尾部\",{\"1\":{\"59\":1}}],[\"找jar包花了点时间\",{\"1\":{\"775\":1}}],[\"找的是在所有可能策略中的最优策略\",{\"1\":{\"462\":1}}],[\"ϵ−greedy\",{\"1\":{\"499\":1}}],[\"ϵ∈\",{\"1\":{\"461\":1}}],[\"ϵ\",{\"1\":{\"461\":2}}],[\"足够长的情况下\",{\"1\":{\"460\":1}}],[\"据目前而言\",{\"1\":{\"458\":1}}],[\"均是随机变量\",{\"1\":{\"484\":1,\"515\":1}}],[\"均值估计\",{\"1\":{\"477\":1}}],[\"均收集完\",{\"1\":{\"456\":1}}],[\"均为非负整数\",{\"1\":{\"246\":1}}],[\"缺点\",{\"1\":{\"456\":1}}],[\"估计了q\",{\"1\":{\"456\":1}}],[\"估计中\",{\"1\":{\"455\":2}}],[\"什么时候更新策略也是一个影响效率的因素\",{\"1\":{\"456\":1}}],[\"什么都不写\",{\"1\":{\"121\":1}}],[\"迭代\",{\"1\":{\"453\":1}}],[\"迭代器的使用是一次性的\",{\"1\":{\"34\":1}}],[\"迭代器\",{\"0\":{\"30\":1,\"33\":1},\"1\":{\"30\":1}}],[\"迭代器我们会在下一个部分讲解\",{\"1\":{\"24\":2}}],[\"≈▽θ​lnπ\",{\"1\":{\"529\":1}}],[\"≈vπ​\",{\"1\":{\"505\":1}}],[\"≈n1​i=1∑n​▽w​f\",{\"1\":{\"475\":1}}],[\"≈n1​i=1∑n​g\",{\"1\":{\"452\":1}}],[\"≈xˉ\",{\"1\":{\"468\":1}}],[\"≈xˉ=n1​j=1∑n​xj​\",{\"1\":{\"449\":1}}],[\"已连接到服务端\",{\"1\":{\"536\":1,\"537\":1}}],[\"已知的情况\",{\"1\":{\"470\":1}}],[\"已知\",{\"1\":{\"451\":1}}],[\"已经可以成功使用此用户进行登陆了\",{\"1\":{\"864\":1}}],[\"已经封死了\",{\"1\":{\"347\":1}}],[\"已经超过了readlimit\",{\"1\":{\"108\":1}}],[\"样本\",{\"1\":{\"516\":1}}],[\"样本必须是独立同分布\",{\"1\":{\"449\":1}}],[\"样本采样\",{\"1\":{\"449\":1}}],[\"蒙特卡洛方法\",{\"0\":{\"449\":1}}],[\"⋮\",{\"1\":{\"444\":4}}],[\"方言\",{\"1\":{\"561\":1}}],[\"方便后续比较\",{\"1\":{\"444\":1}}],[\"方法必须是static\",{\"1\":{\"834\":1}}],[\"方法二\",{\"1\":{\"366\":1}}],[\"方法一\",{\"1\":{\"366\":1}}],[\"方法2\",{\"1\":{\"366\":1,\"456\":1}}],[\"方法1\",{\"1\":{\"366\":1,\"456\":1}}],[\"方法设置\",{\"1\":{\"366\":1}}],[\"方法将元素收集到一个可以用分隔符指定的字符串中\",{\"1\":{\"365\":1}}],[\"方法将元素收集到一个新的\",{\"1\":{\"365\":2}}],[\"方法将其转换成新的集合\",{\"1\":{\"365\":1}}],[\"方法和\",{\"1\":{\"365\":1}}],[\"方法接收的是一个\",{\"1\":{\"362\":1}}],[\"方法创建集合的流后\",{\"1\":{\"365\":1}}],[\"方法创建并发流\",{\"1\":{\"359\":1}}],[\"方法创建流\",{\"1\":{\"359\":1}}],[\"方法内部其实调用了arrays\",{\"1\":{\"359\":1}}],[\"方法内部本质上也是迭代器在处理\",{\"1\":{\"35\":1}}],[\"方法会返回该对象\",{\"1\":{\"355\":1}}],[\"方法会返回true\",{\"1\":{\"355\":1}}],[\"方法会暂时使得此线程进入等待状态\",{\"1\":{\"161\":1}}],[\"方法连接两个\",{\"1\":{\"354\":1}}],[\"方法执行操作\",{\"1\":{\"353\":1}}],[\"方法仅做成员字段之间的值比较\",{\"1\":{\"344\":1}}],[\"方法快速替换为另一个optional类\",{\"1\":{\"323\":1}}],[\"方法抛出的异常\",{\"1\":{\"289\":1}}],[\"方法在内的所有内容\",{\"1\":{\"289\":1}}],[\"方法中实现\",{\"1\":{\"288\":1}}],[\"方法转换字符串\",{\"1\":{\"275\":1}}],[\"方法引用其实本质上就相当于将其他方法的实现\",{\"1\":{\"258\":1}}],[\"方法引用\",{\"0\":{\"258\":1,\"291\":1,\"292\":1},\"1\":{\"258\":2}}],[\"方法名与该参数名相同\",{\"1\":{\"368\":1}}],[\"方法名\",{\"1\":{\"253\":1,\"258\":4}}],[\"方法名称作为测试名称\",{\"1\":{\"779\":1}}],[\"方法名称\",{\"1\":{\"5\":2,\"291\":1,\"761\":1}}],[\"方法名称同样可以随便起\",{\"1\":{\"5\":1}}],[\"方法参数的name\",{\"1\":{\"251\":1}}],[\"方法等实现\",{\"1\":{\"344\":1}}],[\"方法等\",{\"1\":{\"251\":1}}],[\"方法重写\",{\"0\":{\"216\":1}}],[\"方法上的标记是不是也可以通过这种方式获取注解\",{\"1\":{\"208\":1}}],[\"方法定义为\",{\"1\":{\"198\":1}}],[\"方法为某个对象\",{\"1\":{\"193\":1}}],[\"方法可以将流转换成数组\",{\"1\":{\"365\":1}}],[\"方法可以将当前线程进入休眠\",{\"1\":{\"143\":1}}],[\"方法可以找到类中的非public构造方法\",{\"1\":{\"191\":1}}],[\"方法用于获取可拆分迭代器\",{\"1\":{\"173\":1}}],[\"方法暂时处于等待状态\",{\"1\":{\"167\":1}}],[\"方法后\",{\"1\":{\"156\":1,\"161\":1}}],[\"方法是让该线程从\",{\"1\":{\"161\":1}}],[\"方法是强制终止线程\",{\"1\":{\"144\":1}}],[\"方法是语句的集合\",{\"1\":{\"5\":1}}],[\"方法强行停止\",{\"1\":{\"143\":1}}],[\"方法能够终止此线程\",{\"1\":{\"142\":1}}],[\"方法来处理客户端的请求\",{\"1\":{\"872\":1}}],[\"方法来看看实现类是个什么\",{\"1\":{\"659\":1}}],[\"方法来执行一个dml或是ddl语句\",{\"1\":{\"608\":1}}],[\"方法来执行select语句\",{\"1\":{\"608\":1}}],[\"方法来防止此类情况发生\",{\"1\":{\"538\":1}}],[\"方法来设定io超时时间\",{\"1\":{\"538\":1}}],[\"方法来获取一个类定义的指定字段\",{\"1\":{\"193\":1}}],[\"方法来获取类的权限为\",{\"1\":{\"191\":1}}],[\"方法来创建对应类型的实例\",{\"1\":{\"191\":1}}],[\"方法来使用单线程维持原本的顺序\",{\"1\":{\"173\":1}}],[\"方法来关闭它的工作线程\",{\"1\":{\"167\":1}}],[\"方法来实现线程的加入\",{\"1\":{\"148\":1}}],[\"方法来将当前资源让位给其他同优先级线程\",{\"1\":{\"147\":1}}],[\"方法来强行终止此线程\",{\"1\":{\"142\":1}}],[\"方法来让当前线程休眠一段时间\",{\"1\":{\"142\":1}}],[\"方法来运行此线程\",{\"1\":{\"140\":1}}],[\"方法得到一个字符串\",{\"1\":{\"127\":1}}],[\"方法进行求解\",{\"1\":{\"510\":1}}],[\"方法进行实现\",{\"1\":{\"289\":1}}],[\"方法进行错误检查\",{\"1\":{\"127\":1}}],[\"方法进行判断的\",{\"1\":{\"84\":1}}],[\"方法时\",{\"1\":{\"84\":1,\"143\":1}}],[\"方法也相同\",{\"1\":{\"84\":1}}],[\"方法判断相同时\",{\"1\":{\"84\":1}}],[\"方法判断相同后\",{\"1\":{\"84\":1}}],[\"方法判断的\",{\"1\":{\"84\":1}}],[\"方法判定为\",{\"1\":{\"24\":1}}],[\"方法比较的是地址\",{\"1\":{\"84\":1}}],[\"方法\",{\"0\":{\"59\":1,\"60\":1,\"140\":1,\"141\":1,\"142\":1,\"161\":1,\"236\":1,\"397\":1,\"873\":1},\"1\":{\"35\":1,\"60\":1,\"66\":1,\"84\":2,\"91\":3,\"92\":1,\"127\":1,\"144\":1,\"191\":1,\"192\":2,\"198\":1,\"199\":2,\"208\":1,\"215\":1,\"294\":1,\"295\":1,\"343\":1,\"359\":1,\"362\":1,\"365\":1,\"368\":3,\"451\":1,\"529\":1,\"538\":1,\"623\":1,\"629\":1,\"738\":1,\"872\":2,\"873\":1,\"876\":1}}],[\"方法体\",{\"1\":{\"5\":1}}],[\"方法的返回值可以是任何可迭代\",{\"1\":{\"811\":1}}],[\"方法的返回类型\",{\"1\":{\"8\":1}}],[\"方法的源码\",{\"1\":{\"365\":1}}],[\"方法的主要作用是把\",{\"1\":{\"364\":1}}],[\"方法的具体实现\",{\"1\":{\"289\":1}}],[\"方法的名称等内容\",{\"1\":{\"192\":1}}],[\"方法的权限修饰符改为private后\",{\"1\":{\"192\":1}}],[\"方法的内容\",{\"1\":{\"138\":1}}],[\"方法的重载是为某个方法提供更多种类\",{\"1\":{\"216\":1}}],[\"方法的重载\",{\"0\":{\"8\":1}}],[\"方法的进阶使用\",{\"0\":{\"6\":1}}],[\"方法的调用\",{\"1\":{\"5\":1}}],[\"方法的定义如下\",{\"1\":{\"5\":1}}],[\"方法的创建与使用\",{\"0\":{\"5\":1}}],[\"步骤类似\",{\"1\":{\"453\":1}}],[\"步骤中\",{\"1\":{\"442\":2}}],[\"步来求解\",{\"1\":{\"445\":1}}],[\"步\",{\"1\":{\"437\":1}}],[\"动态地更新页面中的内容\",{\"1\":{\"893\":1}}],[\"动态\",{\"0\":{\"719\":1},\"1\":{\"689\":1}}],[\"动态sql在执行时可以进行各种条件判断以及循环拼接等操作\",{\"1\":{\"689\":1}}],[\"动态sql介绍\",{\"0\":{\"689\":1}}],[\"动态sql\",{\"0\":{\"687\":1}}],[\"动态规划\",{\"0\":{\"435\":1}}],[\"动作\",{\"1\":{\"393\":1,\"516\":1}}],[\"动作空间包含两个部分\",{\"1\":{\"388\":1}}],[\"动作空间\",{\"1\":{\"387\":1}}],[\"选择\",{\"1\":{\"865\":1}}],[\"选择执行maven目标来手动执行maven命令\",{\"1\":{\"853\":1}}],[\"选择判断\",{\"0\":{\"691\":1}}],[\"选择对应的动作\",{\"1\":{\"458\":1}}],[\"选择移动方向和选择关联用户\",{\"1\":{\"388\":1}}],[\"选取当前状态下最大的\",{\"1\":{\"444\":2}}],[\"选取状态中最大的\",{\"1\":{\"427\":1}}],[\"唯一约束允许有空值\",{\"1\":{\"564\":1}}],[\"唯一约束保证列中所有的非空数据都是唯一的\",{\"1\":{\"564\":1}}],[\"唯一\",{\"1\":{\"427\":1,\"564\":1,\"565\":1}}],[\"唯一遗憾的是依然不支持区间匹配\",{\"1\":{\"340\":1}}],[\"贝尔曼最优公式\",{\"0\":{\"426\":1},\"1\":{\"435\":1}}],[\"贝尔曼公式\",{\"0\":{\"410\":1}}],[\"收钱的\",{\"1\":{\"549\":2}}],[\"收到服务器返回\",{\"1\":{\"537\":1}}],[\"收敛性情况\",{\"1\":{\"490\":1}}],[\"收敛性分析\",{\"0\":{\"472\":1}}],[\"收集完毕才能进行一次迭代\",{\"1\":{\"475\":1}}],[\"收集collect\",{\"1\":{\"358\":1}}],[\"收益最大\",{\"1\":{\"422\":1}}],[\"采取动作\",{\"1\":{\"452\":1}}],[\"采取一个指定的action可以得到的平均return\",{\"1\":{\"422\":1}}],[\"采用梯度下降\",{\"1\":{\"516\":1}}],[\"采用\",{\"1\":{\"453\":1,\"510\":1}}],[\"采用的是the\",{\"1\":{\"388\":1}}],[\"采用q\",{\"1\":{\"387\":1}}],[\"采用基于遗传算法的gak\",{\"1\":{\"387\":1}}],[\"采用mos作为用户qos衡量的标准\",{\"1\":{\"384\":1}}],[\"整体测试\",{\"1\":{\"789\":1}}],[\"整合\",{\"1\":{\"420\":1}}],[\"整个http请求报文中的所有内容\",{\"1\":{\"874\":1}}],[\"整个tomcat目录下\",{\"1\":{\"864\":1}}],[\"整个报文全部是以文本形式发送的\",{\"1\":{\"859\":1}}],[\"整个idea程序都是由java编写的\",{\"1\":{\"605\":1}}],[\"整个内部类中都处于静态上下文\",{\"1\":{\"252\":1}}],[\"整个arraylist体系由于我们的反射操作\",{\"1\":{\"193\":1}}],[\"整个过程都是反射在代替进行操作\",{\"1\":{\"192\":1}}],[\"求一列的最小值\",{\"1\":{\"582\":1}}],[\"求一列的最大值\",{\"1\":{\"582\":1}}],[\"求一列的平均值\",{\"1\":{\"582\":1}}],[\"求一列的和\",{\"1\":{\"582\":1}}],[\"求一个数的算术平方根\",{\"1\":{\"274\":1}}],[\"求均值的方法\",{\"0\":{\"468\":1}}],[\"求在策略πk​下所有的\",{\"1\":{\"453\":1}}],[\"求解梯度还是很好求的\",{\"1\":{\"516\":1}}],[\"求解给定策略\",{\"1\":{\"485\":1}}],[\"求解当前策略的\",{\"1\":{\"444\":1}}],[\"求解下一步的vk+1​\",{\"1\":{\"437\":1}}],[\"求解方法\",{\"1\":{\"432\":1}}],[\"求解\",{\"0\":{\"432\":1},\"1\":{\"423\":1}}],[\"求解bellman\",{\"1\":{\"419\":1}}],[\"求出其对应状态的\",{\"1\":{\"421\":1}}],[\"求\",{\"1\":{\"415\":1}}],[\"另一种表达\",{\"0\":{\"525\":1,\"528\":1}}],[\"另一种问题描述方法\",{\"0\":{\"479\":1}}],[\"另一些则频繁被访问\",{\"1\":{\"508\":1}}],[\"另一分布下\",{\"1\":{\"403\":1}}],[\"另外\",{\"1\":{\"359\":1}}],[\"证明了\",{\"1\":{\"900\":1}}],[\"证明\",{\"1\":{\"400\":1}}],[\"θt+1​=θt​+α▽θ​lnπ\",{\"1\":{\"530\":2}}],[\"θt+1​=θt​+α▽θ​j\",{\"1\":{\"522\":1}}],[\"θt+1​​=θt​+α▽θ​j\",{\"1\":{\"530\":1}}],[\"θt​\",{\"1\":{\"522\":1,\"530\":3}}],[\"θ∈rm表示参数向量\",{\"1\":{\"522\":1}}],[\"θ\",{\"1\":{\"400\":4,\"522\":2,\"525\":1,\"529\":20,\"530\":2}}],[\"θkn​​\",{\"1\":{\"383\":1}}],[\"核心配置\",{\"0\":{\"819\":1}}],[\"核心部分\",{\"0\":{\"735\":1}}],[\"核心内容\",{\"0\":{\"411\":1}}],[\"核心思想\",{\"1\":{\"399\":1,\"450\":1}}],[\"核心方法是accept\",{\"1\":{\"353\":1}}],[\"策略梯度法\",{\"0\":{\"521\":1}}],[\"策略梯度上升\",{\"1\":{\"397\":1}}],[\"策略了\",{\"1\":{\"499\":1}}],[\"策略求解\",{\"1\":{\"444\":2}}],[\"策略提升\",{\"1\":{\"440\":1}}],[\"策略评估\",{\"1\":{\"440\":1}}],[\"策略更新\",{\"1\":{\"403\":1,\"456\":1}}],[\"策略为贪心策略\",{\"1\":{\"387\":1}}],[\"∣\",{\"1\":{\"461\":1}}],[\"∣−1action\",{\"1\":{\"461\":1}}],[\"∣−1\",{\"1\":{\"461\":1}}],[\"∣a\",{\"1\":{\"461\":3}}],[\"∣ϵ​\",{\"1\":{\"461\":2}}],[\"∣∣≤δ\",{\"1\":{\"440\":1}}],[\"∣∣≤γ∣∣x1​−x2​∣∣\",{\"1\":{\"432\":1}}],[\"∣∣vπk+1​\",{\"1\":{\"440\":1}}],[\"∣∣f\",{\"1\":{\"432\":1}}],[\"∣st​=s\",{\"1\":{\"493\":1}}],[\"∣s=s\",{\"1\":{\"487\":2}}],[\"∣s\",{\"1\":{\"394\":1,\"415\":1,\"418\":4,\"419\":3,\"420\":1,\"422\":2,\"429\":1,\"437\":2,\"440\":2,\"449\":1,\"451\":3,\"487\":1,\"489\":1}}],[\"∣kn​∣为第n个簇的用户总数\",{\"1\":{\"388\":1}}],[\"控制台会出现应该assertionfailederror错误\",{\"1\":{\"780\":1}}],[\"控制其一直待在target\",{\"1\":{\"393\":1}}],[\"控制符\",{\"0\":{\"217\":1}}],[\"γa∑​π\",{\"1\":{\"419\":1}}],[\"γ\",{\"1\":{\"413\":1,\"422\":1,\"484\":1}}],[\"γ接近1\",{\"1\":{\"393\":1}}],[\"γ∈\",{\"1\":{\"393\":1}}],[\"γkn​\",{\"1\":{\"385\":1,\"387\":1}}],[\"γkn​​\",{\"1\":{\"383\":1}}],[\"γk0​σ2μlos​pmax​​\",{\"1\":{\"383\":1}}],[\"π2\",{\"1\":{\"444\":1}}],[\"π2​=argmaxπ​\",{\"1\":{\"444\":1}}],[\"π1​=argmaxπ​\",{\"1\":{\"444\":2}}],[\"π180​θkn​​−ζ\",{\"1\":{\"383\":1}}],[\"π0​\",{\"1\":{\"444\":1}}],[\"π0​pe​vπ0​​pi​π1​pe​vπ1​​pi​π2​pe​vπ2​​pi​\",{\"1\":{\"439\":1,\"444\":1}}],[\"πk​的\",{\"1\":{\"442\":1}}],[\"πk​\",{\"1\":{\"440\":2,\"452\":1}}],[\"πk+1​=πargmax​\",{\"1\":{\"440\":1,\"444\":2}}],[\"πk+1​=argmaxπ​\",{\"1\":{\"437\":1,\"451\":1}}],[\"πk+1​\",{\"1\":{\"437\":2,\"440\":2,\"442\":1,\"453\":2}}],[\"π∗\",{\"1\":{\"427\":2}}],[\"π\",{\"1\":{\"393\":1,\"394\":1,\"414\":1,\"415\":1,\"418\":1,\"419\":1,\"422\":1,\"427\":1,\"431\":1,\"461\":1,\"485\":1,\"486\":1,\"487\":2,\"509\":1,\"522\":2,\"526\":3,\"529\":1}}],[\"训练阶段\",{\"1\":{\"388\":1}}],[\"基于项目对象模型\",{\"1\":{\"817\":1}}],[\"基于垃圾回收器状态和软引用规则移除对象\",{\"1\":{\"701\":1}}],[\"基于函数表示的策略\",{\"1\":{\"522\":1}}],[\"基于函数的\",{\"1\":{\"504\":1}}],[\"基于策略\",{\"1\":{\"509\":1}}],[\"基于给定策略下\",{\"1\":{\"508\":1}}],[\"基于表格的\",{\"1\":{\"504\":1}}],[\"基于q\",{\"1\":{\"388\":1}}],[\"基本结构是由select子句\",{\"1\":{\"561\":1}}],[\"基本思路\",{\"0\":{\"522\":1}}],[\"基本形式\",{\"0\":{\"429\":1}}],[\"基本概念\",{\"0\":{\"391\":1,\"393\":1}}],[\"基本设置\",{\"0\":{\"382\":1}}],[\"基本上不会用到\",{\"1\":{\"253\":1}}],[\"基本类型是不支持的\",{\"1\":{\"281\":1}}],[\"基本类型\",{\"1\":{\"243\":1}}],[\"基本类型包装类\",{\"0\":{\"226\":1}}],[\"基本类型的比较跟之前一样\",{\"1\":{\"216\":1}}],[\"基本数据类型也有对应的class对象\",{\"1\":{\"183\":1}}],[\"基本数据类型的\",{\"0\":{\"183\":1}}],[\"基本示例\",{\"1\":{\"57\":1}}],[\"基本定义是\",{\"1\":{\"253\":1}}],[\"基本定义\",{\"0\":{\"56\":1}}],[\"右连接类似\",{\"1\":{\"586\":1}}],[\"右连接right\",{\"1\":{\"586\":1}}],[\"右\",{\"1\":{\"388\":1}}],[\"右转\",{\"1\":{\"387\":1}}],[\"需考虑用户的移动性\",{\"1\":{\"388\":1}}],[\"需要为字符编码\",{\"1\":{\"909\":1}}],[\"需要重定向到哪一个网址\",{\"1\":{\"899\":1}}],[\"需要两倍的往返时间\",{\"1\":{\"859\":1}}],[\"需要用到很多种不同的日志框架\",{\"1\":{\"842\":1}}],[\"需要和之前一样使用完全限定的方法名称来引用\",{\"1\":{\"811\":1}}],[\"需要添加一个参数\",{\"1\":{\"808\":1}}],[\"需要添加表名前缀来指明是哪一个表的数据\",{\"1\":{\"584\":1}}],[\"需要配置这些额外的参数\",{\"1\":{\"714\":1}}],[\"需要解决这个问题\",{\"1\":{\"705\":1}}],[\"需要在environments的上方\",{\"1\":{\"834\":1}}],[\"需要在mybatis中开启批处理\",{\"1\":{\"688\":1}}],[\"需要在类的最上面添加package关键字来指明当前类所处的包\",{\"1\":{\"120\":1}}],[\"需要自动携带他们的小组\",{\"1\":{\"672\":1}}],[\"需要完整的包名+类名才可以\",{\"1\":{\"648\":1}}],[\"需要使用关联查询将用户的详细信息一并获取\",{\"1\":{\"667\":1}}],[\"需要使用\",{\"1\":{\"648\":1}}],[\"需要使用逗号隔开\",{\"1\":{\"340\":1}}],[\"需要编写大量的get\",{\"1\":{\"627\":1}}],[\"需要考虑怎样对状态进行平均\",{\"1\":{\"507\":1}}],[\"需要求解一个优化问题\",{\"1\":{\"475\":1}}],[\"需要从\",{\"1\":{\"451\":1}}],[\"需要初始化猜测的\",{\"1\":{\"444\":1}}],[\"需要初始化策略π0​\",{\"1\":{\"444\":1}}],[\"需要确定几件事\",{\"1\":{\"427\":1}}],[\"需要通过采样解决\",{\"1\":{\"419\":1}}],[\"需要通过关键字\",{\"1\":{\"120\":2}}],[\"需要推导e\",{\"1\":{\"416\":1}}],[\"需要调整相应无人机的高度\",{\"1\":{\"383\":1}}],[\"需要合理选择无人机n的垂直高度hn​\",{\"1\":{\"383\":1}}],[\"需要清理对应的换行符\",{\"1\":{\"374\":1}}],[\"需要等到执行终止操作的时候才会进行实际的计算\",{\"1\":{\"357\":1}}],[\"需要指定由哪些类继承\",{\"1\":{\"347\":1}}],[\"需要先进行登录才可以访问\",{\"1\":{\"913\":1}}],[\"需要先进行导入才可以\",{\"1\":{\"120\":1}}],[\"需要先创建一个map对象\",{\"1\":{\"318\":1}}],[\"需要由子类来完成\",{\"1\":{\"218\":1}}],[\"需要进行大小限制\",{\"1\":{\"25\":1}}],[\"需要接受的参数类型并不确定时\",{\"1\":{\"14\":1}}],[\"∑s∈s​d\",{\"1\":{\"524\":1}}],[\"∑s∈s​dπ​\",{\"1\":{\"509\":1}}],[\"∑k=1∞​ak2​=∞\",{\"1\":{\"472\":1}}],[\"∑k=1∞​ak2​<∞\",{\"1\":{\"472\":1}}],[\"∑k=1∞​ak​=∞\",{\"1\":{\"472\":1}}],[\"∑kn​=1kn​​pkn​​\",{\"1\":{\"385\":1,\"387\":1}}],[\"∑i=1k−1​xi​+xk​\",{\"1\":{\"468\":1}}],[\"∑​pπ​\",{\"1\":{\"420\":1}}],[\"∑​p\",{\"1\":{\"418\":2,\"419\":2,\"422\":1,\"429\":1,\"437\":1,\"440\":2,\"451\":1,\"487\":1}}],[\"∑​vπ​\",{\"1\":{\"418\":2}}],[\"∑​e\",{\"1\":{\"418\":3}}],[\"∑n=1n​∣kn​∣是总用户数\",{\"1\":{\"388\":1}}],[\"应该是无人机最终停的位置即是部署的最佳位置\",{\"1\":{\"387\":1}}],[\"应用\",{\"0\":{\"910\":1,\"913\":1}}],[\"应用于\",{\"0\":{\"473\":1}}],[\"应用程序模块无法访问这些类\",{\"1\":{\"306\":1}}],[\"应用程序模块\",{\"1\":{\"306\":1}}],[\"应用现有的方法函数作为方法体\",{\"0\":{\"291\":1}}],[\"算法是用来解决\",{\"1\":{\"493\":1}}],[\"算法是用来求解一个\",{\"1\":{\"487\":1}}],[\"算法如下来进行估计\",{\"1\":{\"490\":1}}],[\"算法同样是来求解\",{\"1\":{\"489\":1}}],[\"算法其目的是用于直接估计\",{\"1\":{\"489\":1}}],[\"算法分析\",{\"0\":{\"487\":1}}],[\"算法所需的数据\",{\"1\":{\"486\":1}}],[\"算法为\",{\"1\":{\"484\":1}}],[\"算法进行求解\",{\"1\":{\"484\":1}}],[\"算法进行求解g\",{\"1\":{\"478\":1}}],[\"算法\",{\"0\":{\"488\":1,\"531\":1},\"1\":{\"478\":2,\"479\":1,\"510\":1}}],[\"算法来进行求解\",{\"1\":{\"473\":1}}],[\"算法就可以用来求解当\",{\"1\":{\"471\":1}}],[\"算法介绍\",{\"0\":{\"471\":1}}],[\"算法流程\",{\"0\":{\"463\":1}}],[\"算法中\",{\"0\":{\"462\":1},\"1\":{\"512\":1}}],[\"算法的统一形式和总结\",{\"0\":{\"501\":1}}],[\"算法的比较\",{\"0\":{\"488\":1}}],[\"算法的问题描述中\",{\"1\":{\"479\":1}}],[\"算法的核心是\",{\"1\":{\"451\":1}}],[\"算法的基础上\",{\"1\":{\"397\":1}}],[\"算法思路\",{\"0\":{\"451\":1}}],[\"算法比较\",{\"0\":{\"444\":1}}],[\"算法描述\",{\"0\":{\"440\":1,\"486\":1}}],[\"算法迭代示意图\",{\"1\":{\"439\":1}}],[\"算法1\",{\"1\":{\"387\":1}}],[\"算术异常等\",{\"1\":{\"264\":1}}],[\"奖励\",{\"1\":{\"387\":1,\"393\":1}}],[\"静止\",{\"1\":{\"387\":1}}],[\"静态资源\",{\"1\":{\"818\":1}}],[\"静态内部类编译特性\",{\"0\":{\"254\":1}}],[\"静态内部类由于是静态的\",{\"1\":{\"252\":1}}],[\"静态内部类的类名同样是之前的格式\",{\"1\":{\"252\":1}}],[\"静态内部类就像静态方法和静态变量一样\",{\"1\":{\"252\":1}}],[\"静态内部类\",{\"0\":{\"252\":1}}],[\"静态\",{\"1\":{\"249\":1}}],[\"静态初始化\",{\"1\":{\"235\":1}}],[\"静态导入test方法\",{\"1\":{\"121\":1}}],[\"静态导入\",{\"1\":{\"121\":1}}],[\"静态方法作为方法引用时\",{\"1\":{\"295\":1}}],[\"静态方法使用\",{\"1\":{\"258\":1}}],[\"静态方法甚至是类指定访问权限\",{\"1\":{\"121\":1}}],[\"静态方法同样是属于类的\",{\"1\":{\"117\":1}}],[\"静态变量\",{\"1\":{\"121\":1}}],[\"静态变量初始化\",{\"0\":{\"118\":1}}],[\"静态变量和静态方法\",{\"0\":{\"117\":1}}],[\"静态的内容\",{\"1\":{\"117\":1}}],[\"前\",{\"1\":{\"388\":1}}],[\"前进\",{\"1\":{\"387\":1}}],[\"前面的是预期结果\",{\"1\":{\"786\":1}}],[\"前面我们学习了lombok\",{\"1\":{\"766\":1}}],[\"前面我们介绍了查询操作\",{\"1\":{\"677\":1}}],[\"前面我们已经了解如何使用泛型\",{\"1\":{\"16\":1}}],[\"前面说不推荐使用\",{\"1\":{\"156\":1}}],[\"左转\",{\"1\":{\"387\":1}}],[\"个样本\",{\"1\":{\"516\":1}}],[\"个人推导\",{\"1\":{\"418\":1}}],[\"个人感觉是这个\",{\"1\":{\"387\":1}}],[\"个人理解\",{\"1\":{\"387\":1,\"393\":1}}],[\"个\",{\"1\":{\"387\":1}}],[\"个类型的实参\",{\"1\":{\"241\":1}}],[\"×\",{\"1\":{\"387\":2}}],[\"智能体\",{\"1\":{\"387\":1}}],[\"目的是最小化目标函数\",{\"1\":{\"515\":1}}],[\"目标函数梯度求解\",{\"0\":{\"529\":1}}],[\"目标函数定义\",{\"0\":{\"523\":1}}],[\"目标\",{\"1\":{\"506\":1}}],[\"目标是获得无人机的最佳3d位置\",{\"1\":{\"387\":1}}],[\"目前的优化算法只是在估计给定策略的\",{\"1\":{\"510\":1}}],[\"目前各位小伙伴就暂时理解为会返回对象存放的内存地址\",{\"1\":{\"215\":1}}],[\"目前暂时不会用到\",{\"1\":{\"215\":3}}],[\"目前\",{\"1\":{\"50\":1}}],[\"划分完毕\",{\"1\":{\"387\":1}}],[\"水平位置和高度\",{\"1\":{\"385\":1}}],[\"总结\",{\"0\":{\"423\":1}}],[\"总用户的mos取决于无人机的发射功率\",{\"1\":{\"385\":1}}],[\"总分\",{\"1\":{\"65\":1}}],[\"∀\",{\"1\":{\"490\":1,\"494\":1}}],[\"∀s\",{\"1\":{\"489\":1,\"493\":1}}],[\"∀s=st​\",{\"1\":{\"486\":1}}],[\"∀s∈s​\",{\"1\":{\"429\":1}}],[\"∀s∈s=πmax​a∑​π\",{\"1\":{\"429\":1}}],[\"∀s∈s\",{\"1\":{\"419\":1,\"432\":1}}],[\"∀kn​\",{\"1\":{\"385\":3,\"387\":3}}],[\"∀t\",{\"1\":{\"385\":4,\"387\":4}}],[\"∀n\",{\"1\":{\"385\":2,\"387\":2}}],[\"发送给万维网服务器\",{\"1\":{\"859\":1}}],[\"发送端的时间\",{\"1\":{\"384\":1}}],[\"发现在该位置静止是最优的\",{\"1\":{\"387\":1}}],[\"发现对于\",{\"1\":{\"218\":1}}],[\"共两步\",{\"1\":{\"506\":1}}],[\"共分为\",{\"1\":{\"437\":1}}],[\"共考虑7个方向\",{\"1\":{\"387\":1}}],[\"共划分5个等级\",{\"1\":{\"384\":1}}],[\"共有三种方法\",{\"1\":{\"182\":1}}],[\"高于等于此级别的所有日志都会被打印\",{\"1\":{\"729\":1}}],[\"高效地更新\",{\"0\":{\"456\":1}}],[\"高度h=hn​\",{\"1\":{\"385\":1}}],[\"高度的上界是最大发射功率pmax​的函数\",{\"1\":{\"383\":1}}],[\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问\",{\"1\":{\"154\":1}}],[\"≤c2​\",{\"1\":{\"472\":1}}],[\"≤pmax​\",{\"1\":{\"385\":1,\"387\":1}}],[\"≤hmax​\",{\"1\":{\"385\":1,\"387\":1}}],[\"≤hn​\",{\"1\":{\"383\":1}}],[\"≤\",{\"1\":{\"383\":1}}],[\"ζ2​是系数\",{\"1\":{\"384\":1}}],[\"ζ1​\",{\"1\":{\"384\":1}}],[\"ζ+em\",{\"1\":{\"383\":1}}],[\"ζ是由环境决定的常数\",{\"1\":{\"383\":1}}],[\"信息\",{\"1\":{\"725\":1,\"736\":1,\"746\":2}}],[\"信道容量c=b∗log\",{\"1\":{\"383\":1}}],[\"信号模型\",{\"0\":{\"383\":1}}],[\"μnlos​\",{\"1\":{\"383\":1}}],[\"μnlos​是表示los和nlos链路的衰减因子\",{\"1\":{\"383\":1}}],[\"μlos​−μnlos​\",{\"1\":{\"383\":1}}],[\"μlos​\",{\"1\":{\"383\":1}}],[\"α是表示路径损耗指数\",{\"1\":{\"383\":1}}],[\"​≐a∈a∑​π\",{\"1\":{\"527\":1}}],[\"​≐g\",{\"1\":{\"473\":1}}],[\"​q^​\",{\"1\":{\"516\":3}}],[\"​tderrorδt​​\",{\"1\":{\"486\":1}}],[\"​forthegreedyaction\",{\"1\":{\"461\":1}}],[\"​vu​u2​pu​\",{\"1\":{\"444\":1}}],[\"​vu​u1​pu​π2\",{\"1\":{\"444\":1}}],[\"​p\",{\"1\":{\"422\":1}}],[\"​​−αt​\",{\"1\":{\"486\":1}}],[\"​​=currentestimatevt​\",{\"1\":{\"486\":1}}],[\"​​=a∑​qπ​\",{\"1\":{\"422\":1}}],[\"​​+η∇w​f\",{\"1\":{\"478\":1}}],[\"​​π\",{\"1\":{\"422\":1}}],[\"​​\",{\"1\":{\"419\":1,\"440\":1,\"478\":2,\"486\":1}}],[\"​=π\",{\"1\":{\"529\":1}}],[\"​=πmax​a∑​π\",{\"1\":{\"429\":1}}],[\"​=▽w​e\",{\"1\":{\"510\":1}}],[\"​=qt​\",{\"1\":{\"490\":1,\"494\":1}}],[\"​=vt​\",{\"1\":{\"486\":1}}],[\"​=∇w​f\",{\"1\":{\"478\":1}}],[\"​=w−e\",{\"1\":{\"484\":1}}],[\"​=w−x​=w−x+e\",{\"1\":{\"473\":1}}],[\"​=wk​−k1​\",{\"1\":{\"468\":1}}],[\"​=argmaxπ​\",{\"1\":{\"444\":1}}],[\"​=a∑​π\",{\"1\":{\"417\":1,\"418\":1}}],[\"​=rπk​​+γpπk​​vπk​\",{\"1\":{\"442\":1}}],[\"​=s∈s∑​d\",{\"1\":{\"529\":1}}],[\"​=s∈s∑​η\",{\"1\":{\"529\":1}}],[\"​=s\",{\"1\":{\"418\":1}}],[\"​=e\",{\"1\":{\"416\":1,\"419\":1}}],[\"​=es∼η\",{\"1\":{\"400\":1}}],[\"​=ϕ\",{\"1\":{\"382\":1,\"385\":1,\"387\":1}}],[\"​ifmosnew​>mosold​ifmosnew​=mosold​ifmosnew​<mosold​​\",{\"1\":{\"387\":1}}],[\"​≥0\",{\"1\":{\"385\":1,\"387\":1}}],[\"​≥γkn​​\",{\"1\":{\"385\":1,\"387\":1}}],[\"​−μlos​−μnlos​μnlos​​​s\",{\"1\":{\"383\":1}}],[\"​\",{\"1\":{\"383\":3,\"384\":1,\"385\":1,\"387\":1,\"400\":1,\"416\":1,\"418\":2,\"419\":1,\"420\":1,\"422\":2,\"429\":1,\"437\":1,\"440\":5,\"442\":1,\"451\":1,\"455\":2,\"461\":1,\"468\":1,\"478\":2,\"486\":1,\"490\":1,\"494\":1,\"510\":1,\"516\":1,\"527\":1,\"529\":2,\"530\":1}}],[\"​hn​\",{\"1\":{\"383\":1}}],[\"−2\",{\"1\":{\"516\":2}}],[\"−q^​\",{\"1\":{\"513\":1,\"514\":1,\"515\":1,\"516\":3}}],[\"−v^\",{\"1\":{\"507\":1,\"508\":2,\"509\":2,\"510\":4,\"512\":1}}],[\"−vπk​\",{\"1\":{\"440\":1}}],[\"−tdtargetvt​ˉ​\",{\"1\":{\"486\":1}}],[\"−αt​\",{\"1\":{\"486\":1,\"490\":1,\"494\":1}}],[\"−\",{\"1\":{\"484\":1,\"486\":1,\"490\":1,\"494\":1}}],[\"−x\",{\"1\":{\"473\":1}}],[\"−xkn​​\",{\"1\":{\"382\":1}}],[\"−e\",{\"1\":{\"473\":1,\"478\":2}}],[\"−f\",{\"1\":{\"432\":1}}],[\"−b\",{\"1\":{\"400\":1}}],[\"−0\",{\"1\":{\"387\":1}}],[\"−1rπk​​\",{\"1\":{\"442\":1}}],[\"−1rπ​\",{\"1\":{\"421\":1}}],[\"−1rπ​​\",{\"1\":{\"421\":1}}],[\"−1\",{\"1\":{\"383\":1,\"384\":2,\"387\":4}}],[\"−ykn​​\",{\"1\":{\"382\":1}}],[\"∈\",{\"1\":{\"382\":1}}],[\"飞行速度恒定\",{\"1\":{\"382\":1}}],[\"考虑能否仅用一次\",{\"1\":{\"475\":1}}],[\"考虑一个复杂的均值估计问题\",{\"1\":{\"484\":1}}],[\"考虑一个\",{\"1\":{\"455\":1}}],[\"考虑\",{\"1\":{\"444\":2}}],[\"考虑用户在每个时隙移动的情况\",{\"1\":{\"388\":1}}],[\"考虑以下场景\",{\"1\":{\"387\":1}}],[\"考虑无人机辅助无线网络的下行链路传输\",{\"1\":{\"382\":1}}],[\"考虑qoe\",{\"1\":{\"378\":1}}],[\"更积极地基于垃圾收集器状态和弱引用规则移除对象\",{\"1\":{\"701\":1}}],[\"更推荐使用批处理来优化这种情况\",{\"1\":{\"688\":1}}],[\"更不用说如果我还需要进行实体类映射\",{\"1\":{\"633\":1}}],[\"更新\",{\"1\":{\"613\":1,\"682\":1}}],[\"更新与删除\",{\"1\":{\"561\":1}}],[\"更新一定次数后\",{\"1\":{\"516\":1}}],[\"更新策略的步骤就是选择此时\",{\"1\":{\"451\":1}}],[\"更加高效利用\",{\"1\":{\"454\":1}}],[\"更注重长远的reward\",{\"1\":{\"393\":1}}],[\"更远视\",{\"1\":{\"393\":1}}],[\"更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署\",{\"1\":{\"378\":1}}],[\"更简洁\",{\"1\":{\"371\":1}}],[\"清除所有缓存\",{\"0\":{\"704\":1}}],[\"清除输入缓冲区的换行符\",{\"1\":{\"374\":1}}],[\"清空缓冲区\",{\"1\":{\"113\":1}}],[\"清空整个map\",{\"1\":{\"56\":1}}],[\"清空整个集合\",{\"1\":{\"23\":1}}],[\"块里的内容都会被执行\",{\"1\":{\"374\":1}}],[\"遇到异常\",{\"1\":{\"374\":1}}],[\"遇到\",{\"1\":{\"374\":1}}],[\"遇到过这种问题的扣个1吧\",{\"1\":{\"343\":1}}],[\"里是正常结束\",{\"1\":{\"374\":1}}],[\"里面有许多\",{\"1\":{\"875\":1}}],[\"里面的内依赖依然是直接继承\",{\"1\":{\"850\":1}}],[\"里面的该咋写咋写\",{\"1\":{\"347\":1}}],[\"里面填写的就是所有的依赖\",{\"1\":{\"825\":1}}],[\"里面条件为\",{\"1\":{\"71\":1}}],[\"换行符仍然留在输入缓冲区中\",{\"1\":{\"374\":1}}],[\"换句话说\",{\"1\":{\"351\":1}}],[\"较繁琐\",{\"1\":{\"371\":1}}],[\"便于链式调用\",{\"1\":{\"368\":1}}],[\"便于我们去使用的类\",{\"1\":{\"272\":1}}],[\"称为key\",{\"1\":{\"550\":1}}],[\"称为\",{\"1\":{\"487\":1}}],[\"称为策略评估\",{\"1\":{\"419\":1}}],[\"称为构建器\",{\"1\":{\"368\":1}}],[\"称之为\",{\"1\":{\"154\":1}}],[\"叫做建造者模式\",{\"1\":{\"367\":1}}],[\"叫子类\",{\"1\":{\"212\":1}}],[\"建议使用之前的xml方式进行配置\",{\"1\":{\"718\":1}}],[\"建议在最后执行一次刷新操作\",{\"1\":{\"92\":1}}],[\"建议在finally中进行\",{\"1\":{\"90\":1}}],[\"建造者模式\",{\"0\":{\"367\":1}}],[\"王\",{\"1\":{\"361\":1}}],[\"王力宏\",{\"1\":{\"361\":1,\"362\":1,\"365\":1}}],[\"林俊杰\",{\"1\":{\"361\":1,\"362\":1,\"365\":1}}],[\"陶喆\",{\"1\":{\"361\":1,\"362\":1,\"365\":1}}],[\"周杰伦\",{\"1\":{\"361\":1,\"362\":1,\"365\":1}}],[\"源码中\",{\"1\":{\"876\":1}}],[\"源码中已经配置好了对应的\",{\"1\":{\"876\":1}}],[\"源码的话\",{\"1\":{\"359\":1}}],[\"源码定义\",{\"0\":{\"32\":1}}],[\"世界加油\",{\"1\":{\"358\":2}}],[\"武汉加油\",{\"1\":{\"358\":1}}],[\"规约reduce\",{\"1\":{\"358\":1}}],[\"终极版默认是已经捆绑安装的\",{\"1\":{\"775\":1}}],[\"终端操作会产生一个新的集合或值\",{\"1\":{\"358\":1}}],[\"终端操作结束后流无法再次使用\",{\"1\":{\"358\":1}}],[\"终端操作\",{\"1\":{\"358\":1}}],[\"终于是支持了\",{\"1\":{\"330\":1}}],[\"筛选filter\",{\"1\":{\"358\":1}}],[\"惰性求值\",{\"1\":{\"357\":1}}],[\"毕竟peek方法可以修改流中元素\",{\"1\":{\"357\":1}}],[\"执行后会清理整个target文件夹\",{\"1\":{\"851\":1}}],[\"执行测试实际上也会对类进行实例化\",{\"1\":{\"803\":1}}],[\"执行批处理操作\",{\"0\":{\"615\":1}}],[\"执行dql操作会返回一个resultset对象\",{\"1\":{\"614\":1}}],[\"执行dql操作\",{\"0\":{\"614\":1}}],[\"执行dml操作\",{\"0\":{\"613\":1}}],[\"执行sql语句\",{\"1\":{\"605\":1}}],[\"执行的数据库查询\",{\"1\":{\"356\":1}}],[\"执行一个延时任务\",{\"1\":{\"166\":1}}],[\"形式下的贝尔曼最优公式\",{\"1\":{\"493\":1}}],[\"形式来声明\",{\"1\":{\"207\":1}}],[\"形成一个新的consumer\",{\"1\":{\"354\":1}}],[\"链式操作\",{\"1\":{\"354\":1}}],[\"杂项\",{\"0\":{\"538\":1}}],[\"杂\",{\"0\":{\"350\":1}}],[\"到事务开始前的状态\",{\"1\":{\"599\":1}}],[\"到\",{\"1\":{\"374\":1,\"478\":1,\"627\":1}}],[\"到此为止\",{\"1\":{\"347\":1}}],[\"到最后编译完成后还是会变成具体类型的\",{\"1\":{\"328\":1}}],[\"任何一种\",{\"1\":{\"529\":1}}],[\"任何类都可以继承\",{\"1\":{\"347\":1}}],[\"任何类不能再继承当前类\",{\"1\":{\"347\":1}}],[\"任何方法都可以通过方法引用作为实现\",{\"1\":{\"258\":1}}],[\"保留意见\",{\"1\":{\"357\":1}}],[\"保存的是一些不可变数据\",{\"1\":{\"344\":1}}],[\"保证了数据的可靠传输\",{\"1\":{\"859\":1}}],[\"保证每一种情况都正常执行\",{\"1\":{\"808\":1}}],[\"保证\",{\"1\":{\"472\":2}}],[\"保证选取最大的\",{\"1\":{\"431\":1}}],[\"保证在传输过程中的安全性\",{\"1\":{\"199\":1}}],[\"保证两个线程执行完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"保证数据的安全性\",{\"1\":{\"154\":1}}],[\"保证当两个对象通过\",{\"1\":{\"84\":1}}],[\"旨在方便我们编写复杂字符串\",{\"1\":{\"341\":1}}],[\"三引号\",{\"0\":{\"341\":1}}],[\"文档类型定义\",{\"1\":{\"641\":1}}],[\"文档网站\",{\"1\":{\"641\":1}}],[\"文本块表达式在java\",{\"1\":{\"341\":1}}],[\"文本块\",{\"0\":{\"341\":1}}],[\"文件上传成功\",{\"1\":{\"892\":1}}],[\"文件夹写\",{\"1\":{\"888\":1}}],[\"文件其实就是我们编写的一个类\",{\"1\":{\"118\":1}}],[\"文件丢给\",{\"1\":{\"118\":1}}],[\"文件字符流\",{\"0\":{\"95\":1}}],[\"文件字节流\",{\"0\":{\"89\":1}}],[\"文件拷贝操作实现\",{\"0\":{\"94\":1}}],[\"文件读取\",{\"0\":{\"91\":1}}],[\"传输文件\",{\"0\":{\"543\":1}}],[\"传递的参数都是一样的不会被上一个影响\",{\"1\":{\"354\":1}}],[\"传统的\",{\"1\":{\"340\":1}}],[\"传入分数\",{\"1\":{\"338\":1}}],[\"传入的string对象可能为null\",{\"1\":{\"323\":1}}],[\"传入的如果是对象\",{\"1\":{\"155\":1}}],[\"传入fileinputstream\",{\"1\":{\"105\":1}}],[\"详细信息我们可以在level类中查看\",{\"1\":{\"727\":1}}],[\"详细的sql语句构建器语法文档\",{\"1\":{\"719\":1}}],[\"详细了解\",{\"1\":{\"690\":1}}],[\"详细规则\",{\"0\":{\"340\":1}}],[\"详细过程就不介绍了\",{\"1\":{\"60\":1}}],[\"貌似还是和之前是一样的\",{\"1\":{\"339\":1}}],[\"貌似和之前没啥区别\",{\"1\":{\"304\":1}}],[\"寄\",{\"1\":{\"338\":1}}],[\"及以上\",{\"1\":{\"371\":2}}],[\"及格\",{\"1\":{\"338\":2,\"339\":1}}],[\"及其子类\",{\"1\":{\"88\":2}}],[\"范围在\",{\"1\":{\"563\":3}}],[\"范围\",{\"1\":{\"338\":1}}],[\"拿到输入流和文件输出流\",{\"1\":{\"333\":1}}],[\"知道图片在哪里直接字符串截取\",{\"1\":{\"333\":1}}],[\"网页端只是保存了jsessionid来识别\",{\"1\":{\"912\":1}}],[\"网页发送的请求就会携带所有的\",{\"1\":{\"908\":1}}],[\"网页中的部分内容\",{\"1\":{\"893\":1}}],[\"网络内容\",{\"0\":{\"946\":1}}],[\"网络基础3\",{\"0\":{\"869\":1}}],[\"网络基础2\",{\"0\":{\"863\":1}}],[\"网络基础1\",{\"0\":{\"858\":1,\"859\":1}}],[\"网络的输入包括\",{\"1\":{\"516\":1}}],[\"网站地址\",{\"1\":{\"333\":1}}],[\"网易云音乐等软件\",{\"1\":{\"138\":1}}],[\"局部变量类型推断\",{\"0\":{\"328\":1}}],[\"局部内部类直接使用类名就行\",{\"1\":{\"253\":1}}],[\"局部内部类名\",{\"1\":{\"253\":1}}],[\"局部内部类就像局部变量一样\",{\"1\":{\"253\":1}}],[\"局部内部类\",{\"0\":{\"253\":1}}],[\"却还是要我们自己填类型\",{\"1\":{\"323\":1}}],[\"单位秒\",{\"1\":{\"909\":1}}],[\"单元测试\",{\"0\":{\"773\":1}}],[\"单独配置取消二级缓存\",{\"0\":{\"703\":1}}],[\"单独丢进try中\",{\"1\":{\"323\":1}}],[\"单表查询是最简单的一种查询\",{\"1\":{\"579\":1}}],[\"单表查询\",{\"0\":{\"579\":1}}],[\"单走\",{\"1\":{\"66\":4}}],[\"参照\",{\"1\":{\"564\":1}}],[\"参考一下\",{\"1\":{\"321\":1}}],[\"参数化测试\",{\"0\":{\"808\":1}}],[\"参数化类型中可以获取到泛型在定义过程中的参数类型\",{\"1\":{\"186\":1}}],[\"参数也可以是字符串类型的\",{\"1\":{\"648\":1}}],[\"参数\",{\"1\":{\"355\":1}}],[\"参数一样\",{\"1\":{\"258\":1}}],[\"参数直接写成lambda表达式\",{\"1\":{\"257\":1}}],[\"参数名称要与实体类参数对应\",{\"1\":{\"678\":1}}],[\"参数名称\",{\"1\":{\"241\":1,\"257\":1,\"290\":1}}],[\"参数类型\",{\"1\":{\"241\":1,\"257\":1,\"290\":1}}],[\"参数类型可能会多种多样\",{\"1\":{\"8\":1}}],[\"参数上\",{\"1\":{\"203\":1}}],[\"好处是idea更新后不需要重新配置\",{\"1\":{\"827\":1}}],[\"好了\",{\"1\":{\"333\":2}}],[\"好耶\",{\"1\":{\"318\":1}}],[\"好比说一个银行\",{\"1\":{\"154\":1}}],[\"环境配置完成后\",{\"1\":{\"316\":1}}],[\"指导agent在当前状态下选择哪个动作\",{\"1\":{\"393\":1}}],[\"指定参数列表\",{\"1\":{\"808\":1}}],[\"指定jdk版本范围\",{\"0\":{\"795\":1}}],[\"指定jdk版本\",{\"0\":{\"794\":1}}],[\"指定操作系统\",{\"0\":{\"793\":1}}],[\"指定构造方法后\",{\"1\":{\"658\":1}}],[\"指定构造方法\",{\"0\":{\"658\":1,\"717\":1}}],[\"指定查询某一列数据\",{\"1\":{\"579\":1}}],[\"指定b继承a\",{\"1\":{\"347\":1}}],[\"指定实现\",{\"0\":{\"310\":1}}],[\"指示编译器去忽略注解中声明的警告\",{\"1\":{\"204\":1}}],[\"开发的开源项目\",{\"1\":{\"817\":1}}],[\"开启此选项后\",{\"1\":{\"704\":1}}],[\"开启二级缓存后\",{\"1\":{\"701\":1}}],[\"开启批处理后\",{\"1\":{\"688\":1}}],[\"开启时把之前的事务模式下的内容给提交了\",{\"1\":{\"623\":1}}],[\"开启事务只有当commit后才能在真正的数据库里看到\",{\"1\":{\"599\":1}}],[\"开启反射\",{\"0\":{\"309\":1}}],[\"开源数据库\",{\"1\":{\"549\":1}}],[\"开始事务\",{\"1\":{\"599\":1}}],[\"开始支持\",{\"1\":{\"204\":2,\"205\":1}}],[\"开始唤醒\",{\"1\":{\"161\":1}}],[\"开始等待\",{\"1\":{\"161\":1}}],[\"岁\",{\"1\":{\"307\":1}}],[\"岁了\",{\"1\":{\"5\":1}}],[\"例子\",{\"0\":{\"307\":1}}],[\"例如拼接时要确保不能忘记添加必要的空格\",{\"1\":{\"689\":1}}],[\"例如将成绩在平均成绩之上的元组定义成一个视图good\",{\"1\":{\"596\":1}}],[\"例如\",{\"1\":{\"246\":8,\"817\":1,\"833\":1}}],[\"例如当向printstream流中写入一个字节数组后自动调用flush\",{\"1\":{\"127\":1}}],[\"未能访问\",{\"1\":{\"458\":1}}],[\"未命名模块默认可以使用其他所有模块提供的类\",{\"1\":{\"311\":1}}],[\"未命名模块只能默认暴露给其他未命名的模块和自动模块\",{\"1\":{\"306\":1}}],[\"未命名模块同样可以访问所有其他模块提供的类\",{\"1\":{\"306\":1}}],[\"未命名模块\",{\"1\":{\"306\":1}}],[\"未知时的情况\",{\"1\":{\"471\":1}}],[\"未知\",{\"1\":{\"9\":1,\"451\":1,\"470\":1}}],[\"系统属性判断\",{\"0\":{\"796\":1}}],[\"系统属性\",{\"1\":{\"755\":1}}],[\"系统结构\",{\"0\":{\"381\":1}}],[\"系统模块\",{\"1\":{\"306\":1}}],[\"系统输入流\",{\"1\":{\"128\":1}}],[\"尝试修改一下maxage来看看失效时间\",{\"1\":{\"909\":1}}],[\"尝试自己写的http相应时\",{\"1\":{\"544\":1}}],[\"尝试将\",{\"1\":{\"516\":1}}],[\"尝试通过反射获取jdk提供的类中的字段\",{\"1\":{\"305\":1}}],[\"尝试获取threadlocal中存放的变量\",{\"1\":{\"162\":1}}],[\"全局定义初始化参数\",{\"0\":{\"903\":1}}],[\"全局存储通信\",{\"0\":{\"901\":1}}],[\"全true\",{\"1\":{\"747\":1}}],[\"全称为超文本传输协议\",{\"1\":{\"544\":1}}],[\"全新的httpclient使用\",{\"0\":{\"332\":1}}],[\"全新的模块机制\",{\"1\":{\"301\":1}}],[\"全部不再需要\",{\"1\":{\"289\":1}}],[\"全部拷贝为一个新的对象\",{\"1\":{\"220\":1}}],[\"于是\",{\"1\":{\"296\":1,\"303\":1}}],[\"举例\",{\"0\":{\"292\":1,\"713\":1}}],[\"且对象不能被修改\",{\"1\":{\"701\":1}}],[\"且该列的值不能为空\",{\"1\":{\"565\":1}}],[\"且不能为空且唯一\",{\"1\":{\"564\":1}}],[\"且不能是匿名内部类或是lambda的形式\",{\"1\":{\"347\":1}}],[\"且有一个管理员只在一个仓库工作\",{\"1\":{\"556\":1}}],[\"且其他的属性必须完全依赖于主键\",{\"1\":{\"554\":1}}],[\"且需要被求解出来\",{\"1\":{\"470\":1}}],[\"且最终会收敛到最优策略v∗\",{\"1\":{\"442\":1}}],[\"且\",{\"1\":{\"427\":1,\"461\":1,\"472\":2,\"509\":1,\"518\":1}}],[\"且ζ1​+ζ2​=1\",{\"1\":{\"384\":1}}],[\"且传输率永远都不可能超过信道容量c\",{\"1\":{\"383\":1}}],[\"且无人机向关联用户的发射功率是恒定的\",{\"1\":{\"383\":1}}],[\"且一旦参数较多\",{\"1\":{\"366\":1}}],[\"且此构造方法需要一个string类型的对象\",{\"1\":{\"296\":1}}],[\"且接受一个int类型参数\",{\"1\":{\"290\":1}}],[\"且没有参数\",{\"1\":{\"290\":1}}],[\"且同样不能使用\",{\"1\":{\"218\":1}}],[\"符合函数式接口定义\",{\"1\":{\"290\":1}}],[\"间接说明编译之后lambda并不是以匿名内部类的形式存在的\",{\"1\":{\"289\":1}}],[\"间隔1秒\",{\"1\":{\"162\":1}}],[\"间隔2秒\",{\"1\":{\"162\":1}}],[\"率\",{\"1\":{\"280\":1}}],[\"显示名称生成器\",{\"1\":{\"779\":1}}],[\"显示声明了会抛出一个interruptedexception异常\",{\"1\":{\"143\":1}}],[\"显然表示此时不支持\",{\"1\":{\"876\":1}}],[\"显然map用起来更便捷一些\",{\"1\":{\"651\":1}}],[\"显然是\",{\"1\":{\"524\":1}}],[\"显然是可以通过一个\",{\"1\":{\"440\":1}}],[\"显然我们仍然可以通过\",{\"1\":{\"484\":1}}],[\"显然我们可以将\",{\"1\":{\"478\":1}}],[\"显然ϵ=0\",{\"1\":{\"461\":1}}],[\"显然其核心关键就是在\",{\"1\":{\"451\":1}}],[\"显然在现实运行算法中是无法做到的\",{\"1\":{\"445\":1}}],[\"显然\",{\"1\":{\"393\":1,\"397\":1,\"437\":1,\"445\":1,\"452\":1,\"460\":1,\"470\":1,\"478\":1}}],[\"显然无法在编译期确定类型是否安全\",{\"1\":{\"280\":1}}],[\"取值范围从1−4\",{\"1\":{\"384\":1}}],[\"取值只能进行强制类型转换\",{\"1\":{\"280\":1}}],[\"取消这些不必要保存的属性\",{\"1\":{\"133\":1}}],[\"良好\",{\"1\":{\"280\":1,\"338\":2,\"339\":1}}],[\"课程成绩\",{\"1\":{\"280\":1}}],[\"课程号\",{\"1\":{\"280\":1}}],[\"常用的handler实现有\",{\"1\":{\"735\":1}}],[\"常用\",{\"0\":{\"580\":1}}],[\"常用工具类\",{\"0\":{\"273\":1}}],[\"常见的数据库有很多种\",{\"1\":{\"549\":1}}],[\"常数\",{\"1\":{\"383\":1}}],[\"常规优先级\",{\"1\":{\"145\":1}}],[\"永远都不会被捕获\",{\"1\":{\"267\":2}}],[\"捕获到异常\",{\"1\":{\"267\":1}}],[\"捕获异常\",{\"1\":{\"264\":1}}],[\"抛开事实不谈\",{\"1\":{\"840\":1}}],[\"抛出\",{\"1\":{\"371\":1}}],[\"抛出异常\",{\"0\":{\"266\":1},\"1\":{\"355\":1}}],[\"抛给上一级\",{\"1\":{\"267\":1}}],[\"明确会抛出ioexception\",{\"1\":{\"267\":1}}],[\"处理后\",{\"1\":{\"920\":2}}],[\"处理\",{\"1\":{\"267\":1}}],[\"处理单位\",{\"1\":{\"88\":3}}],[\"给定的策略\",{\"1\":{\"528\":1}}],[\"给定策略\",{\"1\":{\"487\":1}}],[\"给\",{\"1\":{\"267\":1}}],[\"函数\",{\"1\":{\"873\":1}}],[\"函数和存储过程并没有包含在我们的教程当中\",{\"1\":{\"599\":1}}],[\"函数调用方必须要对抛出的这个异常进行对应的处理才可以\",{\"1\":{\"266\":1}}],[\"函数的\",{\"0\":{\"242\":1}}],[\"空数组\",{\"1\":{\"809\":1}}],[\"空值\",{\"0\":{\"809\":1},\"1\":{\"564\":1}}],[\"空指针异常的改进\",{\"0\":{\"343\":1}}],[\"空指针异常\",{\"1\":{\"264\":1}}],[\"空集合等\",{\"1\":{\"809\":1}}],[\"空集合\",{\"0\":{\"79\":1}}],[\"卡布奇诺今犹在\",{\"1\":{\"258\":1}}],[\"待实现的求和方法\",{\"1\":{\"258\":1}}],[\"今天学会了\",{\"1\":{\"257\":5}}],[\"今年\",{\"1\":{\"5\":1}}],[\"匿名类只能访问其父类的属性或方法\",{\"1\":{\"255\":1}}],[\"匿名对象通常不能直接给属性赋值\",{\"1\":{\"255\":1}}],[\"匿名对象的类是在创建时匿名生成的\",{\"1\":{\"255\":1}}],[\"匿名对象本身不能定义新的属性\",{\"1\":{\"255\":1}}],[\"匿名内部类是没办法使用钻石运算符进行自动类型推断的\",{\"1\":{\"323\":1}}],[\"匿名内部类是我们使用频率非常高的一种内部类\",{\"1\":{\"255\":1}}],[\"匿名内部类会在编译时创建一个单独的class文件\",{\"1\":{\"289\":1}}],[\"匿名内部类特性\",{\"0\":{\"256\":1}}],[\"匿名内部类中同样可以使用类中的属性\",{\"1\":{\"255\":1}}],[\"匿名内部类\",{\"0\":{\"255\":1,\"288\":1},\"1\":{\"256\":1}}],[\"匿名内部类在java8无法使用钻石运算符\",{\"1\":{\"25\":1}}],[\"把一个流中的元素转化成新的流中的元素\",{\"1\":{\"362\":1}}],[\"把图片取到\",{\"1\":{\"333\":1}}],[\"把图片的地址提取出来\",{\"1\":{\"333\":1}}],[\"把未实现的方法实现了\",{\"1\":{\"255\":1}}],[\"把对象的属性和方法结合成一个独立的整体\",{\"1\":{\"212\":1}}],[\"依赖项使用默认即可\",{\"1\":{\"865\":1}}],[\"依赖的范围\",{\"1\":{\"832\":1}}],[\"依赖的类型\",{\"1\":{\"832\":1}}],[\"依赖的下载速度就会快起来了\",{\"1\":{\"827\":1}}],[\"依赖还可以添加以下属性\",{\"1\":{\"832\":1}}],[\"依赖作用域\",{\"0\":{\"830\":1,\"831\":1}}],[\"依赖导入\",{\"0\":{\"823\":1}}],[\"依赖导入完成后\",{\"1\":{\"641\":1}}],[\"依赖管理\",{\"1\":{\"817\":2}}],[\"依赖于当前状态和所采取的动作\",{\"1\":{\"393\":1}}],[\"依赖此模块的模块也会自动进行依赖\",{\"1\":{\"308\":1}}],[\"依赖传递\",{\"0\":{\"308\":1,\"841\":1}}],[\"依然可以被其他会话直接使用\",{\"1\":{\"701\":1}}],[\"依然会被反射赋值\",{\"1\":{\"658\":1}}],[\"依然返回自己\",{\"1\":{\"323\":1}}],[\"依然采用\",{\"1\":{\"294\":1}}],[\"依然使用泛型\",{\"1\":{\"282\":1}}],[\"依然是就近原则\",{\"1\":{\"251\":1}}],[\"依附任何对象我们可以直接创建使用\",{\"1\":{\"252\":1}}],[\"依附于b创建的对象\",{\"1\":{\"251\":1}}],[\"依附于a创建的对象\",{\"1\":{\"251\":1}}],[\"依次打印\",{\"1\":{\"71\":1}}],[\"套娃了属于是\",{\"1\":{\"251\":1}}],[\"套壳实现的\",{\"1\":{\"67\":1}}],[\"外连接有三种方式\",{\"1\":{\"586\":1}}],[\"外连接就是专门用于联合查询情景的\",{\"1\":{\"586\":1}}],[\"外连接查询\",{\"0\":{\"586\":1}}],[\"外键约束用于在两个表之间建立参照完整性关系\",{\"1\":{\"565\":1}}],[\"外键\",{\"1\":{\"564\":1,\"565\":2}}],[\"外\",{\"1\":{\"429\":1}}],[\"外部类初始化\",{\"1\":{\"254\":2}}],[\"外部类父类的tostring方法\",{\"1\":{\"251\":1}}],[\"外部类的tosrting方法\",{\"1\":{\"251\":1}}],[\"外部是无法访问到这个内部类的\",{\"1\":{\"251\":1}}],[\"外层\",{\"1\":{\"251\":1}}],[\"属性\",{\"0\":{\"833\":1,\"881\":1,\"909\":1}}],[\"属性可以被设置为\",{\"1\":{\"701\":1}}],[\"属性则是通过反射进行赋值\",{\"1\":{\"658\":1}}],[\"属性的值由单引号或双引号包括\",{\"1\":{\"634\":1}}],[\"属性取值可以有一定的约束\",{\"1\":{\"550\":1}}],[\"属性不可再分\",{\"1\":{\"550\":1}}],[\"属性具有以下特点\",{\"1\":{\"550\":1}}],[\"属性默认就是这个值\",{\"1\":{\"9\":1}}],[\"属于\",{\"0\":{\"251\":1,\"252\":1},\"1\":{\"249\":2}}],[\"下载完成后\",{\"1\":{\"864\":1}}],[\"下载\",{\"0\":{\"891\":1},\"1\":{\"864\":1}}],[\"下载速度缓慢\",{\"1\":{\"827\":1}}],[\"下午\",{\"1\":{\"725\":1}}],[\"下一次读取将直接无法获取到这行数据\",{\"1\":{\"705\":1}}],[\"下次需要获取数据时\",{\"1\":{\"699\":1}}],[\"下面注解主要就是利用这个函数来进行判断\",{\"1\":{\"795\":1}}],[\"下面这种情况\",{\"1\":{\"652\":1}}],[\"下面具体保存过程的不用我多说了吧\",{\"1\":{\"333\":1}}],[\"下同\",{\"1\":{\"582\":1}}],[\"下的一个纯\",{\"1\":{\"817\":1}}],[\"下的\",{\"1\":{\"509\":1,\"526\":1}}],[\"下行\",{\"1\":{\"387\":1}}],[\"下划线\",{\"1\":{\"246\":1}}],[\"下界限定就像这样\",{\"1\":{\"15\":1}}],[\"下界\",{\"1\":{\"15\":1}}],[\"非空\",{\"1\":{\"564\":1}}],[\"非空白符\",{\"1\":{\"246\":1}}],[\"非指定的模块即使导入也无法使用\",{\"1\":{\"307\":1}}],[\"非静态方法作为方法引用\",{\"0\":{\"293\":1}}],[\"非常简单\",{\"1\":{\"871\":1}}],[\"非常难以阅读\",{\"1\":{\"737\":1}}],[\"非常智能\",{\"1\":{\"678\":1}}],[\"非常鸡肋\",{\"1\":{\"652\":1}}],[\"非常耗时\",{\"1\":{\"138\":1}}],[\"非常方便\",{\"1\":{\"25\":1}}],[\"^\",{\"1\":{\"246\":1}}],[\"^aeiou\",{\"1\":{\"246\":1}}],[\"^abc\",{\"1\":{\"246\":1}}],[\"请求头中会携带这些信息\",{\"1\":{\"907\":1}}],[\"请求转发只能转发给内部的servlet\",{\"1\":{\"900\":1}}],[\"请求转发可以共享请求参数\",{\"1\":{\"900\":1}}],[\"请求转发可以携带数据\",{\"1\":{\"900\":2}}],[\"请求转发地址栏不会发生改变\",{\"1\":{\"900\":1}}],[\"请求转发是一次请求\",{\"1\":{\"900\":1}}],[\"请求转发其实是一种服务器内部的跳转机制\",{\"1\":{\"900\":1}}],[\"请求转发\",{\"0\":{\"900\":1}}],[\"请求地址为当前地址+\",{\"1\":{\"886\":1}}],[\"请验证您的用户名或密码\",{\"1\":{\"889\":1}}],[\"请参阅显示名称生成优先级规则\",{\"1\":{\"804\":1}}],[\"请输入要发送给服务端的内容\",{\"1\":{\"537\":1}}],[\"请调用方处理好\",{\"1\":{\"266\":1}}],[\"请注意在逗号和两个数之间不能有空格\",{\"1\":{\"246\":1}}],[\"请将\",{\"1\":{\"198\":1}}],[\"至少匹配n\",{\"1\":{\"246\":1}}],[\"至于为什么默认是0\",{\"1\":{\"60\":1}}],[\"至于为什么要这样设计\",{\"1\":{\"31\":1}}],[\"次的观测值\",{\"1\":{\"471\":1}}],[\"次方程根的估计\",{\"1\":{\"471\":1}}],[\"次且最多匹配\",{\"1\":{\"246\":1}}],[\"次\",{\"1\":{\"246\":4}}],[\"匹配find\",{\"1\":{\"358\":1}}],[\"匹配值可以存在多个\",{\"1\":{\"340\":1}}],[\"匹配值\",{\"1\":{\"340\":3}}],[\"匹配字母\",{\"1\":{\"246\":1}}],[\"匹配字符串\",{\"1\":{\"246\":2}}],[\"匹配所有\",{\"1\":{\"246\":1}}],[\"匹配所有大写字母\",{\"1\":{\"246\":1}}],[\"匹配除换行符\",{\"1\":{\"246\":1}}],[\"匹配除了\",{\"1\":{\"246\":1}}],[\"匹配\",{\"0\":{\"363\":1},\"1\":{\"246\":1}}],[\"匹配确定的\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式零次或一次\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式零次或多次\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式一次或多次\",{\"1\":{\"246\":1}}],[\"匹配成功返回true\",{\"1\":{\"246\":1}}],[\"描述如下\",{\"1\":{\"387\":1}}],[\"描述\",{\"1\":{\"246\":2}}],[\"描述了一种字符串匹配的模式\",{\"1\":{\"246\":1}}],[\"限定符表如下\",{\"1\":{\"246\":1}}],[\"汉堡\",{\"1\":{\"245\":2}}],[\"汉堡做滴彳亍不彳亍\",{\"1\":{\"113\":1}}],[\"弥补了字符串不能修改的不足\",{\"1\":{\"245\":1}}],[\"裁剪等操作\",{\"1\":{\"245\":1}}],[\"哥们在这跟你说唱\",{\"1\":{\"241\":1}}],[\"哥们这瓜多少钱一斤\",{\"1\":{\"199\":2}}],[\"答案是可以的\",{\"1\":{\"240\":1}}],[\"允许请求通过\",{\"0\":{\"920\":1}}],[\"允许便捷式访问底层数据库\",{\"1\":{\"604\":1}}],[\"允许列中的某些行没有值\",{\"1\":{\"564\":1}}],[\"允许包含\",{\"1\":{\"371\":1}}],[\"允许传递为\",{\"1\":{\"355\":1}}],[\"允许\",{\"1\":{\"239\":1}}],[\"允许在任何地方被访问\",{\"1\":{\"121\":1}}],[\"肯定是继承自object的\",{\"1\":{\"235\":1}}],[\"肯定的啊\",{\"1\":{\"15\":1}}],[\"面向对象高级篇\",{\"0\":{\"233\":1,\"262\":1,\"272\":1}}],[\"面向对象高级篇1\",{\"0\":{\"225\":1}}],[\"精确到小数点后100位\",{\"1\":{\"229\":1}}],[\"浮点类型精度有限\",{\"1\":{\"229\":1}}],[\"乘法\",{\"1\":{\"229\":1}}],[\"轻轻松松\",{\"1\":{\"229\":1}}],[\"轻松地就实现了\",{\"1\":{\"67\":1}}],[\"特定的方法来生成参数\",{\"0\":{\"811\":1}}],[\"特点\",{\"0\":{\"357\":1}}],[\"特性\",{\"0\":{\"238\":1},\"1\":{\"371\":1}}],[\"特殊包装类\",{\"0\":{\"229\":1}}],[\"特别注意一下\",{\"1\":{\"25\":1}}],[\"内行\",{\"1\":{\"817\":1}}],[\"内层查询中涉及的表也是sc\",{\"1\":{\"596\":1}}],[\"内嵌迭代算法求解\",{\"1\":{\"444\":1}}],[\"内加入一个\",{\"1\":{\"367\":1}}],[\"内置了一系列收集器实现\",{\"1\":{\"365\":1}}],[\"内置了很多\",{\"1\":{\"333\":1}}],[\"内存占用已经超出限制\",{\"1\":{\"264\":1}}],[\"内存也会消耗更多\",{\"1\":{\"227\":1}}],[\"内容\",{\"0\":{\"874\":1,\"875\":1},\"1\":{\"253\":1,\"811\":1}}],[\"内部的内容都是子节点\",{\"1\":{\"636\":1}}],[\"内部的数据结构\",{\"1\":{\"67\":1}}],[\"内部有实现\",{\"1\":{\"606\":1}}],[\"内部类静态方法\",{\"1\":{\"254\":2}}],[\"内部类初始化\",{\"1\":{\"254\":2}}],[\"内部类父类的tostring方法\",{\"1\":{\"251\":1}}],[\"内部类自己的tostring方法\",{\"1\":{\"251\":1}}],[\"内部类名称\",{\"1\":{\"251\":1}}],[\"内部类也是类\",{\"1\":{\"251\":1}}],[\"内部类顾名思义\",{\"1\":{\"250\":1}}],[\"内部类\",{\"0\":{\"249\":1,\"250\":1}}],[\"内部什么都没有\",{\"1\":{\"245\":1}}],[\"内部使用结点\",{\"1\":{\"58\":1}}],[\"内部使用的结点类\",{\"1\":{\"25\":1}}],[\"覆盖原有构造方法\",{\"1\":{\"221\":1}}],[\"覆盖之后\",{\"1\":{\"59\":1}}],[\"枚举值\",{\"0\":{\"810\":1}}],[\"枚举\",{\"1\":{\"344\":1}}],[\"枚举的成员变量\",{\"1\":{\"221\":1}}],[\"枚举类型是普通的类\",{\"1\":{\"221\":1}}],[\"枚举类型使用起来就非常方便了\",{\"1\":{\"221\":1}}],[\"枚举类的语法稍微有一些不一样\",{\"1\":{\"221\":1}}],[\"枚举类\",{\"0\":{\"221\":1}}],[\"睡觉\",{\"1\":{\"221\":2}}],[\"睡觉这三个之中的其中一种\",{\"1\":{\"221\":1}}],[\"学号为\",{\"1\":{\"616\":1}}],[\"学号发生改变就代表学生发生改变\",{\"1\":{\"554\":1}}],[\"学号是每个学生的唯一标识\",{\"1\":{\"554\":1}}],[\"学号\",{\"1\":{\"550\":1,\"551\":2,\"554\":1}}],[\"学习资料\",{\"1\":{\"835\":1}}],[\"学习和使用xml只是为了更好地去认识mybatis的工作原理\",{\"1\":{\"636\":1}}],[\"学习厉害的框架或是厉害的技术\",{\"1\":{\"633\":1}}],[\"学习\",{\"1\":{\"221\":2}}],[\"学生学号\",{\"1\":{\"555\":2}}],[\"学生借书情况\",{\"1\":{\"555\":2}}],[\"学生表\",{\"1\":{\"551\":1}}],[\"学生\",{\"1\":{\"219\":1,\"220\":1,\"551\":1,\"553\":2,\"554\":1}}],[\"学生和老师来说\",{\"1\":{\"219\":1}}],[\"深拷贝会将引用类型的所有内容\",{\"1\":{\"220\":1}}],[\"深拷贝\",{\"1\":{\"220\":1}}],[\"拷贝个基莫\",{\"1\":{\"220\":1}}],[\"浅拷贝\",{\"1\":{\"220\":1}}],[\"克隆实现\",{\"1\":{\"220\":1}}],[\"克隆操作可以完全复制一个对象的所有属性\",{\"1\":{\"220\":1}}],[\"克隆出来的与原来的对象不是一个对象\",{\"1\":{\"220\":1}}],[\"克隆方法\",{\"0\":{\"220\":1}}],[\"克隆当前对象\",{\"1\":{\"215\":1}}],[\"顶多说是多继承的一种替代方案\",{\"1\":{\"219\":1}}],[\"逗号\",{\"1\":{\"219\":1}}],[\"甚至直接没有重新构造对象\",{\"1\":{\"700\":1}}],[\"甚至当字段变得很多时\",{\"1\":{\"627\":1}}],[\"甚至连名字都没有\",{\"1\":{\"255\":1}}],[\"甚至还可以查看当前的web应用程序有没有出现内存泄露\",{\"1\":{\"864\":1}}],[\"甚至还可以继续套娃一个成员内部类\",{\"1\":{\"251\":1}}],[\"甚至还能获取到泛型\",{\"1\":{\"179\":1}}],[\"甚至都不是一个类了\",{\"1\":{\"219\":1}}],[\"甚至都不是一个类\",{\"1\":{\"219\":1}}],[\"他能在编译时自动生成getter和setter\",{\"1\":{\"344\":1}}],[\"他只代表某个确切的功能\",{\"1\":{\"219\":1}}],[\"他们编写在conf目录下的web\",{\"1\":{\"871\":1}}],[\"他们可以添加到类或是字段上\",{\"1\":{\"629\":1}}],[\"他们可能会做不同的事情\",{\"1\":{\"120\":1}}],[\"他们都继承自\",{\"1\":{\"264\":1}}],[\"他们都具有学习这个能力\",{\"1\":{\"219\":1}}],[\"他们其实都是异常类型\",{\"1\":{\"264\":1}}],[\"他们其实是需要配合synchronized来使用的\",{\"1\":{\"161\":1}}],[\"他们存储了方法的信息\",{\"1\":{\"192\":1}}],[\"抽象成接口来进行使用\",{\"1\":{\"219\":1}}],[\"抽象方法的访问权限不能为\",{\"1\":{\"218\":1}}],[\"抽象方法是指\",{\"1\":{\"218\":1}}],[\"抽象方法\",{\"1\":{\"218\":2}}],[\"抽象类中可以具有抽象方法\",{\"1\":{\"218\":1}}],[\"抽象类的子类也可以是一个抽象类\",{\"1\":{\"218\":1}}],[\"抽象类的实现\",{\"1\":{\"186\":1}}],[\"抽象类一般只用作继承使用\",{\"1\":{\"218\":1}}],[\"抽象类具有\",{\"1\":{\"218\":1}}],[\"抽象类\",{\"0\":{\"218\":1},\"1\":{\"218\":1,\"282\":1,\"347\":1}}],[\"加载类的时候\",{\"1\":{\"926\":1}}],[\"加入\",{\"1\":{\"913\":1}}],[\"加权均值\",{\"1\":{\"422\":1}}],[\"加上它们在参数列表中的位置来命名\",{\"1\":{\"660\":1}}],[\"加上\",{\"1\":{\"422\":1}}],[\"加\",{\"1\":{\"217\":1}}],[\"做滴\",{\"1\":{\"245\":2}}],[\"做题我并不擅长\",{\"1\":{\"216\":1,\"218\":1}}],[\"做传输媒介\",{\"1\":{\"94\":1}}],[\"重定向之后\",{\"1\":{\"900\":1}}],[\"重定向地址栏会发生改变\",{\"1\":{\"900\":1}}],[\"重定向是两次请求\",{\"1\":{\"900\":1}}],[\"重定向属于2次请求\",{\"1\":{\"900\":1}}],[\"重定向会使得浏览器去重新请求一个页面\",{\"1\":{\"900\":1}}],[\"重定向无法携带数据\",{\"1\":{\"900\":1}}],[\"重定向\",{\"0\":{\"899\":1}}],[\"重定向与请求转发\",{\"0\":{\"898\":1}}],[\"重启服务器\",{\"1\":{\"864\":1}}],[\"重启idea\",{\"1\":{\"628\":1}}],[\"重要性采样\",{\"0\":{\"404\":1},\"1\":{\"403\":1}}],[\"重复测试\",{\"0\":{\"807\":1}}],[\"重复和参数化测试\",{\"0\":{\"806\":1}}],[\"重复\",{\"0\":{\"746\":1}}],[\"重复步骤\",{\"1\":{\"387\":1}}],[\"重复字符串\",{\"1\":{\"71\":1}}],[\"重新开启自动提交\",{\"1\":{\"623\":1}}],[\"重新开放为普通类\",{\"1\":{\"347\":1}}],[\"重新修改为\",{\"1\":{\"420\":1}}],[\"重新输入\",{\"1\":{\"374\":1}}],[\"重写方法可以添加\",{\"1\":{\"216\":1}}],[\"重写方法要求与父类的定义完全一致\",{\"1\":{\"216\":2}}],[\"垃圾\",{\"1\":{\"215\":1}}],[\"完善了service方法\",{\"1\":{\"876\":1}}],[\"完成整个tcp通信\",{\"1\":{\"859\":1}}],[\"完成自我介绍需要执行的所有代码就在这个花括号中编写\",{\"1\":{\"5\":1}}],[\"完整类名\",{\"1\":{\"215\":1}}],[\"父项目如果还存在dependencies节点的话\",{\"1\":{\"850\":1}}],[\"父类\",{\"1\":{\"347\":2}}],[\"父类型在前\",{\"1\":{\"267\":1}}],[\"父类是\",{\"1\":{\"214\":1}}],[\"父加载器\",{\"1\":{\"198\":1}}],[\"正式发布项目一般只带版本号\",{\"1\":{\"820\":1}}],[\"正在等待客户端连接\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"正确性和收敛性分析\",{\"0\":{\"478\":1}}],[\"正好匹配了接口中的\",{\"1\":{\"296\":1}}],[\"正好匹配了compareto方法\",{\"1\":{\"294\":1}}],[\"正好可以匹配\",{\"1\":{\"246\":1}}],[\"正则表达式并不是只有java才支持\",{\"1\":{\"246\":1}}],[\"正则表达式\",{\"0\":{\"232\":1,\"246\":1},\"1\":{\"246\":2}}],[\"正是这三大特性\",{\"1\":{\"212\":1}}],[\"正常情况还是转发给默认的servlet帮我们返回静态页面\",{\"1\":{\"910\":1}}],[\"正常情况下是不会出错的\",{\"1\":{\"264\":1}}],[\"正常情况下\",{\"1\":{\"186\":1,\"255\":1}}],[\"正常实例化方法是无法创造抽象类的实例\",{\"1\":{\"218\":1}}],[\"正常插入键值对返回值为null\",{\"1\":{\"59\":1}}],[\"隐藏实现细节\",{\"1\":{\"212\":1}}],[\"隐式加载\",{\"1\":{\"118\":1}}],[\"封装和安全性得到了改进\",{\"1\":{\"305\":1}}],[\"封装成一个类\",{\"1\":{\"227\":1}}],[\"封装\",{\"0\":{\"212\":1,\"213\":1},\"1\":{\"212\":2}}],[\"现将类上\",{\"1\":{\"871\":1}}],[\"现为由\",{\"1\":{\"817\":1}}],[\"现阶段作为初学者\",{\"1\":{\"208\":1}}],[\"现在已经离我们理想的页面越来越接近了\",{\"1\":{\"910\":1}}],[\"现在一律通过http\",{\"1\":{\"910\":1}}],[\"现在再次进行登陆操作\",{\"1\":{\"900\":1}}],[\"现在再次打开管理页面\",{\"1\":{\"864\":1}}],[\"现在重新启动服务器\",{\"1\":{\"864\":1}}],[\"现在用的是junit5\",{\"1\":{\"775\":1}}],[\"现在由于logger没有配置任何handler处理器\",{\"1\":{\"735\":1}}],[\"现在默认就是使用的这个\",{\"1\":{\"735\":1}}],[\"现在执行以下操作\",{\"1\":{\"693\":1}}],[\"现在要求把下面所有用户都插入到数据库中\",{\"1\":{\"688\":1}}],[\"现在来一个新的表\",{\"1\":{\"670\":1}}],[\"现在将变为我们手动提交\",{\"1\":{\"623\":4}}],[\"现在图片地址也可以批量拿到了\",{\"1\":{\"333\":1}}],[\"现在接口中可以存在私有方法了\",{\"1\":{\"317\":1}}],[\"现在就可以使用了\",{\"1\":{\"308\":1}}],[\"现在main类中有一个刚好匹配的方法\",{\"1\":{\"295\":1}}],[\"现在只需要一个注解即可\",{\"1\":{\"713\":1}}],[\"现在只需要一个简短的lambda表达式即可\",{\"1\":{\"289\":1}}],[\"现在只会进行追加写入\",{\"1\":{\"93\":1}}],[\"现在的问题就是\",{\"1\":{\"280\":1}}],[\"现在我们发起的所有请求\",{\"1\":{\"919\":1}}],[\"现在我们发现\",{\"1\":{\"872\":1}}],[\"现在我们给此servlet添加post请求处理\",{\"1\":{\"900\":1}}],[\"现在我们再运行服务器\",{\"1\":{\"892\":1}}],[\"现在我们再次打印低于info级别的日志就可以正确得到结果了\",{\"1\":{\"729\":1}}],[\"现在我们在前端页面添加一个链接\",{\"1\":{\"891\":1}}],[\"现在我们在浏览器中打开此页面\",{\"1\":{\"875\":1}}],[\"现在我们点击登录按钮\",{\"1\":{\"886\":1}}],[\"现在我们按照上面的提示\",{\"1\":{\"864\":1}}],[\"现在我们可以让使用此项目作为依赖的项目不使用可选依赖\",{\"1\":{\"843\":1}}],[\"现在我们可以直接通过sqlsession获取我们编写接口的实现类\",{\"1\":{\"659\":1}}],[\"现在我们创建一下测试用例\",{\"1\":{\"834\":1}}],[\"现在我们来修改一下servlet代码\",{\"1\":{\"892\":1}}],[\"现在我们来编写一个测试用例看看依赖导入成功了没有\",{\"1\":{\"825\":1}}],[\"现在我们来进行一个转换\",{\"1\":{\"616\":1}}],[\"现在我们需要创建一个public的无参无返回值方法\",{\"1\":{\"776\":1}}],[\"现在我们需要一个参数为string返回值为string的实现\",{\"1\":{\"296\":1}}],[\"现在我们也可以将其设置为jdk提供的日志框架\",{\"1\":{\"768\":1}}],[\"现在我们也可以手动修改它为simpleformatter类型\",{\"1\":{\"738\":1}}],[\"现在我们打印日志就可以出现想要的结果了\",{\"1\":{\"736\":1}}],[\"现在我们还是在mapper中添加一个对应的方法用于执行\",{\"1\":{\"712\":1}}],[\"现在我们只需要在main方法中这样写即可查询结果了\",{\"1\":{\"647\":1}}],[\"现在我们只需要通过一个对象就能完成数据库交互了\",{\"1\":{\"642\":1}}],[\"现在我们只需要构造一个http请求实体\",{\"1\":{\"333\":1}}],[\"现在我们执行的数据库操作日志会在控制台实时打印\",{\"1\":{\"606\":1}}],[\"现在我们想要保证其10次都不会出现问题才算通过\",{\"1\":{\"807\":1}}],[\"现在我们想要使用switch来实现这个功能\",{\"1\":{\"338\":1}}],[\"现在我们想新建一个线程来做事情\",{\"1\":{\"289\":2}}],[\"现在我们想新建一个线程来搞事情\",{\"1\":{\"288\":1}}],[\"现在我们使用var关键字来自动进行类型推断\",{\"1\":{\"328\":1}}],[\"现在我们希望\",{\"1\":{\"893\":1}}],[\"现在我们希望查询user时\",{\"1\":{\"666\":1}}],[\"现在我们希望按照全新的模块化开发模式来进行开发\",{\"1\":{\"311\":1}}],[\"现在我们希望能够自己处理出现的问题\",{\"1\":{\"267\":1}}],[\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了\",{\"1\":{\"616\":1}}],[\"现在我们就可以把请求发送出去了\",{\"1\":{\"333\":1}}],[\"现在我们就可以在main类中使用模块module\",{\"1\":{\"307\":1}}],[\"现在我们就可以对此类进行操作了\",{\"1\":{\"199\":1}}],[\"现在我们要实现一个方法\",{\"1\":{\"297\":1}}],[\"现在\",{\"1\":{\"199\":1,\"710\":1,\"876\":1,\"899\":1,\"900\":1,\"910\":1,\"914\":1,\"921\":1}}],[\"现在线程才是程序执行流的最小单元\",{\"1\":{\"138\":1}}],[\"现在是按字符进行读取\",{\"1\":{\"96\":1}}],[\"现在跳过的是一个字符\",{\"1\":{\"96\":1}}],[\"现在没有\",{\"1\":{\"15\":1}}],[\"现在有一个新的需求\",{\"1\":{\"15\":1}}],[\"丝毫get不到这玩意的用处\",{\"1\":{\"208\":1}}],[\"多模块下父项目存在一个packing打包类型标签\",{\"1\":{\"855\":1}}],[\"多模块测试打包\",{\"0\":{\"855\":1}}],[\"多模块\",{\"0\":{\"847\":1,\"850\":1}}],[\"多\",{\"0\":{\"672\":2}}],[\"多对一查询\",{\"0\":{\"672\":1}}],[\"多参数表示\",{\"0\":{\"660\":1}}],[\"多参数查询\",{\"0\":{\"651\":1}}],[\"多表查询会通过连接转换为单表查询\",{\"1\":{\"584\":1}}],[\"多表查询是同时查询的两个或两个以上的表\",{\"1\":{\"584\":1}}],[\"多表查询\",{\"0\":{\"584\":1}}],[\"多重条件连接查询\",{\"1\":{\"580\":1}}],[\"多维数组\",{\"0\":{\"240\":1},\"1\":{\"275\":1}}],[\"多个会话之间不相通\",{\"1\":{\"700\":1}}],[\"多个子类使用逗号隔开\",{\"1\":{\"346\":1}}],[\"多个参数时需要\",{\"1\":{\"290\":1}}],[\"多个类型变量使用逗号隔开\",{\"1\":{\"281\":1}}],[\"多个异常使用逗号隔开\",{\"1\":{\"266\":1}}],[\"多个不同的对象对同一消息作出响应\",{\"1\":{\"212\":1}}],[\"多个值时就使用花括号括起来\",{\"1\":{\"207\":1}}],[\"多态\",{\"1\":{\"212\":1}}],[\"多线程4\",{\"0\":{\"171\":1}}],[\"多线程3\",{\"0\":{\"160\":1}}],[\"多线程下java内存管理\",{\"0\":{\"154\":1}}],[\"多线程2\",{\"0\":{\"152\":1}}],[\"多线程与反射4\",{\"0\":{\"170\":1}}],[\"多线程与反射3\",{\"0\":{\"159\":1}}],[\"多线程与反射2\",{\"0\":{\"151\":1}}],[\"多线程与反射1\",{\"0\":{\"136\":1}}],[\"多线程\",{\"0\":{\"137\":1}}],[\"该类加载器才会尝试去加载\",{\"1\":{\"926\":1}}],[\"该加载路径中的class只对当前web应用程序可见\",{\"1\":{\"926\":1}}],[\"该加载路径中的class对于所有web应用程序可见\",{\"1\":{\"926\":1}}],[\"该加载路径中的class对于web应用程序不可见\",{\"1\":{\"926\":1}}],[\"该加载路径中的class可以被tomcat容器本身以及各个web应用程序访问\",{\"1\":{\"926\":1}}],[\"该cookie的用处说明\",{\"1\":{\"909\":1}}],[\"该cookie是否仅被使用安全协议传输\",{\"1\":{\"909\":1}}],[\"该cookie为临时cookie\",{\"1\":{\"909\":1}}],[\"该请求包括请求参数也一起被传递了\",{\"1\":{\"900\":1}}],[\"该元素不必声明\",{\"1\":{\"832\":1}}],[\"该算法中\",{\"1\":{\"496\":1,\"497\":1}}],[\"该算法是\",{\"1\":{\"443\":1}}],[\"该步骤是根据\",{\"1\":{\"440\":1}}],[\"该步骤是用来计算当前策略\",{\"1\":{\"440\":1}}],[\"该式子针对状态空间中的所有状态均成立\",{\"1\":{\"419\":1}}],[\"该论文中在精度和模型复杂型上作出平衡\",{\"1\":{\"387\":1}}],[\"该问题依然是np\",{\"1\":{\"387\":1}}],[\"该优化问题是一个non\",{\"1\":{\"385\":1}}],[\"该文件配置很简单\",{\"1\":{\"753\":1}}],[\"该文中不同集群所利用的频谱是不同的\",{\"1\":{\"383\":1}}],[\"该文中表示为\",{\"1\":{\"383\":1}}],[\"该文提出的算法具较快的收敛性\",{\"1\":{\"379\":1}}],[\"该文基于q\",{\"1\":{\"379\":1}}],[\"该文设计的是3d部署\",{\"1\":{\"378\":1}}],[\"该框架将无人机部署在三维空间内\",{\"1\":{\"379\":1}}],[\"该方法成立的数学依据是\",{\"1\":{\"449\":1}}],[\"该方法允许将两个consumer连接在一起\",{\"1\":{\"354\":1}}],[\"该方法接受一个参数\",{\"1\":{\"353\":1}}],[\"该方法接受一个参数并且不返回任何结果\",{\"1\":{\"351\":1}}],[\"该方法参数为参数2\",{\"1\":{\"295\":1}}],[\"该方法是否是重写方法\",{\"1\":{\"204\":1}}],[\"该咋写咋写\",{\"1\":{\"257\":1}}],[\"该怎么处理\",{\"1\":{\"229\":1}}],[\"该注解由\",{\"1\":{\"206\":1}}],[\"元注解是作用于注解上的注解\",{\"1\":{\"205\":1}}],[\"元注解\",{\"0\":{\"205\":1}}],[\"元素中的\",{\"1\":{\"84\":1}}],[\"元素流在管道中经过\",{\"1\":{\"71\":1}}],[\"忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告\",{\"1\":{\"204\":1}}],[\"标签\",{\"0\":{\"678\":1,\"680\":1,\"690\":1}}],[\"标签中可以存在属性\",{\"1\":{\"634\":1}}],[\"标注下划线的属性\",{\"1\":{\"551\":1}}],[\"标准的声明格式如下\",{\"1\":{\"347\":1}}],[\"标准格式为\",{\"1\":{\"257\":1,\"290\":1}}],[\"标识某注解可以在同一个声明上使用多次\",{\"1\":{\"205\":1}}],[\"标识这个注解怎么保存\",{\"1\":{\"205\":1}}],[\"标识一个匿名函数或函数式接口\",{\"1\":{\"204\":1}}],[\"标记依赖是否可选\",{\"1\":{\"832\":1}}],[\"标记这个注解是继承于哪个注解类\",{\"1\":{\"205\":1}}],[\"标记这个注解应该是哪种\",{\"1\":{\"205\":1}}],[\"标记这些注解是否包含在用户文档中\",{\"1\":{\"205\":1}}],[\"标记过时方法\",{\"1\":{\"204\":1}}],[\"标记为native的方法是本地方法\",{\"1\":{\"215\":1}}],[\"标记为公共的内容\",{\"1\":{\"121\":1}}],[\"标记为受保护的内容可以能被类本身和同包中的其他类访问\",{\"1\":{\"121\":1}}],[\"标记为私有的内容无法被除当前类以外的任何位置访问\",{\"1\":{\"121\":1}}],[\"标记位置\",{\"1\":{\"108\":1}}],[\"检查约束通常用于限制某些特定的数值范围或模式\",{\"1\":{\"564\":1}}],[\"检查\",{\"1\":{\"204\":1,\"564\":1,\"565\":1}}],[\"作用域和provided是一样的\",{\"1\":{\"835\":1}}],[\"作用域\",{\"1\":{\"832\":1}}],[\"作用在我们自己的项目中\",{\"1\":{\"843\":1}}],[\"作用在被导入的项目中\",{\"1\":{\"842\":1}}],[\"作用在\",{\"0\":{\"700\":1,\"701\":1}}],[\"作用\",{\"1\":{\"400\":1}}],[\"作用于代码\",{\"1\":{\"204\":1}}],[\"作为父级项目\",{\"1\":{\"855\":1}}],[\"作为用户id的逻辑外键\",{\"1\":{\"666\":1}}],[\"作为内部资源后\",{\"1\":{\"659\":1}}],[\"作为内部资源\",{\"1\":{\"659\":1}}],[\"作为占位符\",{\"1\":{\"622\":1}}],[\"作为key\",{\"1\":{\"551\":1}}],[\"作为下一步的\",{\"1\":{\"427\":1}}],[\"作为后缀去匹配位置\",{\"1\":{\"333\":1}}],[\"作为前缀去匹配位置\",{\"1\":{\"333\":1}}],[\"作为lambda表达式的方法体实现\",{\"1\":{\"291\":1}}],[\"作为附加功能存在\",{\"1\":{\"219\":1}}],[\"作为结果\",{\"1\":{\"57\":1}}],[\"作为返回值\",{\"1\":{\"14\":1}}],[\"作为参数\",{\"1\":{\"14\":1}}],[\"注释内容\",{\"1\":{\"634\":1}}],[\"注重近期的reward\",{\"1\":{\"393\":1}}],[\"注解顺序可以由我们自己通过注解来手动定义执行顺序\",{\"1\":{\"804\":1}}],[\"注解不允许循环引用\",{\"1\":{\"718\":1}}],[\"注解只支持嵌套查询\",{\"0\":{\"718\":1}}],[\"注解只有成员变量\",{\"1\":{\"207\":1}}],[\"注解之后的又一新类型\",{\"1\":{\"344\":1}}],[\"注解的成员变量在注解的定义中以\",{\"1\":{\"207\":1}}],[\"注解的属性也叫做成员变量\",{\"1\":{\"207\":1}}],[\"注解的使用\",{\"0\":{\"207\":1}}],[\"注解并没有继承于任何子类\",{\"1\":{\"205\":1}}],[\"注解本质上也是一个类\",{\"1\":{\"203\":1}}],[\"注解也可以选择是否保留到运行时\",{\"1\":{\"203\":1}}],[\"注解可以通过反射在运行时获取\",{\"1\":{\"203\":1}}],[\"注解可以被标注在任意地方\",{\"1\":{\"203\":1}}],[\"注解定义上等\",{\"1\":{\"203\":1}}],[\"注解\",{\"0\":{\"202\":1,\"203\":1,\"719\":1,\"776\":1},\"1\":{\"216\":1}}],[\"注意第一个字符必须为\",{\"1\":{\"909\":1}}],[\"注意最后一个字符必须为\",{\"1\":{\"909\":1}}],[\"注意是webapp根目录下的\",{\"1\":{\"901\":1}}],[\"注意必须添加enctype=\",{\"1\":{\"892\":1}}],[\"注意必须是数字类型\",{\"1\":{\"582\":1}}],[\"注意必须是数字类型的\",{\"1\":{\"582\":1}}],[\"注意不同路径的写法\",{\"1\":{\"886\":1}}],[\"注意在when中不允许使用<或是>这种模糊匹配的条件\",{\"1\":{\"691\":1}}],[\"注意返回类型必须是int或是long这类数字类型\",{\"1\":{\"678\":1}}],[\"注意返回值是class<\",{\"1\":{\"182\":1}}],[\"注意sql语句中一些字段存在歧义\",{\"1\":{\"672\":1}}],[\"注意send方法后面参数\",{\"1\":{\"333\":1}}],[\"注意set中元素顺序并不一定你的添加顺序\",{\"1\":{\"318\":1}}],[\"注意接口的参数和返回值必须正确对应\",{\"1\":{\"659\":1}}],[\"注意参数的顺序\",{\"1\":{\"658\":1}}],[\"注意全参构造必须与查询结果字段参数一一对应\",{\"1\":{\"658\":1}}],[\"注意由于这里是xml配置\",{\"1\":{\"653\":1}}],[\"注意key的名称需要与我们编写的sql语句中占位符一致\",{\"1\":{\"651\":1}}],[\"注意静态字段不会生成\",{\"1\":{\"629\":1}}],[\"注意前两步都放在try\",{\"1\":{\"605\":1}}],[\"注意一定要换行再写\",{\"1\":{\"544\":1}}],[\"注意需要添加\",{\"1\":{\"537\":1}}],[\"注意子类格式为\",{\"1\":{\"347\":1}}],[\"注意处理完成后需要返回最终结果\",{\"1\":{\"340\":1}}],[\"注意私有方法必须要提供方法体\",{\"1\":{\"317\":1}}],[\"注意只是相当于外部来说\",{\"1\":{\"252\":1}}],[\"注意传参\",{\"1\":{\"192\":1}}],[\"注意它会抛出instantiationexception和illegalaccessexception异常\",{\"1\":{\"191\":1}}],[\"注意此class对象只会存在一个\",{\"1\":{\"180\":1}}],[\"注意这里的路径规则和之前的不同\",{\"1\":{\"900\":1}}],[\"注意这里调用的不是静态方法\",{\"1\":{\"294\":1}}],[\"注意这是一个泛型类\",{\"1\":{\"162\":1}}],[\"注意这个是一个抽象类\",{\"1\":{\"166\":1}}],[\"注意这个填充是对集合中已有的元素进行覆盖\",{\"1\":{\"78\":1}}],[\"注意这个接口是集合接口的父接口\",{\"1\":{\"36\":1}}],[\"注意\",{\"1\":{\"9\":1,\"25\":2,\"34\":1,\"71\":1,\"77\":1,\"90\":1,\"91\":2,\"92\":1,\"120\":1,\"129\":1,\"130\":1,\"148\":1,\"161\":1,\"183\":1,\"199\":1,\"241\":1,\"243\":1,\"251\":1,\"266\":1,\"267\":2,\"340\":2,\"341\":1,\"342\":1,\"344\":1,\"537\":1,\"572\":1,\"584\":1,\"605\":1,\"616\":1,\"623\":2,\"682\":1,\"701\":1,\"729\":1,\"805\":1,\"827\":1,\"841\":1,\"853\":1,\"892\":1}}],[\"想之前一样的话\",{\"1\":{\"304\":1}}],[\"想破解你代码有的是方法\",{\"1\":{\"199\":1}}],[\"想要了解优先级队列的具体是原理\",{\"1\":{\"46\":1}}],[\"华强\",{\"1\":{\"199\":1}}],[\"成功得到结果\",{\"1\":{\"900\":1}}],[\"成功加载外部class文件\",{\"1\":{\"199\":1}}],[\"成比例等于\",{\"1\":{\"529\":1}}],[\"成绩可能是string类型\",{\"1\":{\"280\":1}}],[\"成员变量一样\",{\"1\":{\"251\":1}}],[\"成员变量的初始化\",{\"1\":{\"9\":1}}],[\"成员内部类的name\",{\"1\":{\"251\":2}}],[\"成员内部类的类型名称就是\",{\"1\":{\"251\":1}}],[\"成员内部类可以访问到外部的成员变量\",{\"1\":{\"251\":1}}],[\"成员内部类也可以使用访问权限控制\",{\"1\":{\"251\":1}}],[\"成员内部类和成员方法\",{\"1\":{\"251\":1}}],[\"成员内部类其实在某些情况下使用起来比较麻烦\",{\"1\":{\"251\":1}}],[\"成员内部类\",{\"0\":{\"251\":1}}],[\"成员\",{\"1\":{\"205\":1,\"249\":1}}],[\"成员属性上\",{\"1\":{\"203\":1}}],[\"成员方法也可以让对象本身不成为参与的那一方\",{\"1\":{\"295\":1}}],[\"成员方法因为需要具体对象使用\",{\"1\":{\"258\":1}}],[\"成员方法只能通过\",{\"1\":{\"258\":1}}],[\"成员方法中不能用\",{\"1\":{\"216\":1}}],[\"成员方法\",{\"1\":{\"121\":1}}],[\"爷爷加载器\",{\"1\":{\"198\":1}}],[\"错误的类型转换\",{\"1\":{\"616\":1}}],[\"错误\",{\"1\":{\"198\":1,\"264\":1,\"268\":1,\"889\":1}}],[\"既然它是依靠tcp协议进行数据传输\",{\"1\":{\"859\":1}}],[\"既然现在不需要配置mapper\",{\"1\":{\"711\":1}}],[\"既然我们现在可以从数据库中获取数据了\",{\"1\":{\"616\":1}}],[\"既然我们的注解可以保留到运行时\",{\"1\":{\"208\":1}}],[\"既然视图本质就是一个查询的结果\",{\"1\":{\"596\":1}}],[\"既然了解了属性和联系\",{\"1\":{\"551\":1}}],[\"既然了解了元注解的使用和注解的定义方式\",{\"1\":{\"206\":1}}],[\"既然使用的是http连接\",{\"1\":{\"544\":1}}],[\"既然分数段都是整数\",{\"1\":{\"338\":1,\"339\":1}}],[\"既然是在方法中声明的类\",{\"1\":{\"253\":1}}],[\"既然数组可以是任何类型的\",{\"1\":{\"240\":1}}],[\"既然数组操作都这么方便了\",{\"1\":{\"75\":1}}],[\"既然能装箱\",{\"1\":{\"227\":1}}],[\"既然都有\",{\"1\":{\"219\":1}}],[\"既然通过classloader就可以加载类\",{\"1\":{\"199\":1}}],[\"既然说class对象和加载的类唯一对应\",{\"1\":{\"198\":1}}],[\"思考\",{\"1\":{\"198\":1}}],[\"淦\",{\"1\":{\"193\":1,\"281\":1}}],[\"瞎移除都不带报错的\",{\"1\":{\"193\":1}}],[\"大部分的web服务器都支持此标准\",{\"1\":{\"870\":1}}],[\"大部分情况下\",{\"1\":{\"832\":1}}],[\"大于符号\",{\"1\":{\"653\":1}}],[\"大于0表示大于\",{\"1\":{\"14\":1}}],[\"大型数据库系统\",{\"1\":{\"549\":1}}],[\"大数定理\",{\"1\":{\"449\":1}}],[\"大大提高工作效率\",{\"1\":{\"599\":1}}],[\"大大提升开发效\",{\"1\":{\"280\":1}}],[\"大大降低依赖库的规模\",{\"1\":{\"303\":1}}],[\"大体内容其实普通类差不多\",{\"1\":{\"218\":1}}],[\"大小直接变成11\",{\"1\":{\"193\":1}}],[\"几乎所有的依赖都被放到了中央仓库中\",{\"1\":{\"826\":1}}],[\"几乎能够无视一切阻拦\",{\"1\":{\"193\":1}}],[\"几乎都在操作内部维护的一个hashmap\",{\"1\":{\"67\":1}}],[\"强化学习\",{\"0\":{\"937\":1},\"2\":{\"396\":1,\"409\":1,\"425\":1,\"434\":1,\"448\":1,\"465\":1,\"482\":1,\"503\":1,\"520\":1,\"533\":1}}],[\"强化学习框架图\",{\"0\":{\"392\":1}}],[\"强行设置值\",{\"1\":{\"193\":1}}],[\"强制类型转换\",{\"1\":{\"184\":1,\"219\":1}}],[\"强制写入\",{\"1\":{\"92\":1}}],[\"~modifier\",{\"1\":{\"193\":1}}],[\"尤其是仅比较子类属性\",{\"1\":{\"629\":1}}],[\"尤其是在类进行类内部成员字段封装时\",{\"1\":{\"627\":1}}],[\"尤其是在网络i\",{\"1\":{\"91\":1}}],[\"尤其是我们提到的越权访问\",{\"1\":{\"192\":1}}],[\"q=0\",{\"1\":{\"544\":6,\"908\":7,\"913\":7}}],[\"q^​\",{\"1\":{\"516\":5}}],[\"qt​\",{\"1\":{\"490\":2,\"494\":1,\"530\":1}}],[\"qt+1​\",{\"1\":{\"490\":2,\"494\":2}}],[\"qπk​​\",{\"1\":{\"440\":1,\"451\":2,\"452\":2,\"453\":1}}],[\"qπ​\",{\"1\":{\"400\":2,\"422\":3,\"423\":1,\"449\":1,\"489\":1,\"529\":8,\"530\":4}}],[\"qac\",{\"0\":{\"398\":1},\"1\":{\"399\":1}}],[\"q\",{\"0\":{\"494\":1,\"498\":1,\"514\":1,\"515\":1},\"1\":{\"379\":2,\"385\":1,\"387\":2,\"388\":1,\"397\":1,\"423\":1,\"429\":1,\"431\":1,\"432\":1,\"451\":1,\"453\":1,\"455\":2,\"493\":2,\"494\":1,\"497\":1,\"498\":1,\"504\":1,\"515\":1}}],[\"qoe\",{\"1\":{\"378\":1}}],[\"quality\",{\"0\":{\"384\":1},\"1\":{\"378\":1}}],[\"querying\",{\"1\":{\"658\":1}}],[\"query\",{\"1\":{\"561\":2}}],[\"queue\",{\"1\":{\"43\":5,\"45\":1,\"46\":14,\"167\":11,\"174\":8}}],[\"queue<object>\",{\"1\":{\"174\":1}}],[\"queue<integer>\",{\"1\":{\"46\":2}}],[\"queue<string>\",{\"1\":{\"43\":1,\"45\":1}}],[\"queue<e>\",{\"1\":{\"43\":1,\"44\":1}}],[\"quene\",{\"0\":{\"42\":1,\"43\":1}}],[\"qq\",{\"1\":{\"192\":1,\"713\":1}}],[\"组合\",{\"0\":{\"364\":1},\"1\":{\"192\":1}}],[\"过去研究主要考虑的是2d部署\",{\"1\":{\"378\":1}}],[\"过去研究大多没有基于用户的移动\",{\"1\":{\"378\":1}}],[\"过多的使用反射\",{\"1\":{\"192\":1}}],[\"过滤器相当于在所有访问前加了一堵墙\",{\"1\":{\"918\":1}}],[\"过滤换行符之类的内容\",{\"1\":{\"636\":1}}],[\"过滤等\",{\"1\":{\"358\":1}}],[\"过滤和映射数据等操作\",{\"1\":{\"356\":1}}],[\"过滤\",{\"0\":{\"361\":1},\"1\":{\"71\":2}}],[\"萨日朗\",{\"1\":{\"191\":1}}],[\"仍然是获取不到具体的\",{\"1\":{\"186\":1}}],[\"哪些变量等等\",{\"1\":{\"180\":1}}],[\"与其相似的还有两个相同对象的判断\",{\"1\":{\"788\":1}}],[\"与其说lambda是匿名内部类的语法糖\",{\"1\":{\"289\":1}}],[\"与主键类似\",{\"1\":{\"564\":1}}],[\"与策略\",{\"1\":{\"526\":2}}],[\"与\",{\"0\":{\"415\":1,\"444\":1,\"488\":1},\"1\":{\"415\":1,\"442\":1,\"453\":1,\"498\":1}}],[\"与基于q\",{\"1\":{\"388\":1}}],[\"与k\",{\"1\":{\"379\":1}}],[\"与加载的类唯一对应\",{\"1\":{\"180\":1}}],[\"与迭代器作用相同\",{\"1\":{\"23\":1}}],[\"堆内存\",{\"1\":{\"180\":1}}],[\"慎重使用\",{\"1\":{\"179\":1}}],[\"继类\",{\"1\":{\"344\":1}}],[\"继续编写throws往上一级抛\",{\"1\":{\"267\":1}}],[\"继续读取会导致mark失效\",{\"1\":{\"108\":1}}],[\"继承和多模块\",{\"0\":{\"846\":1}}],[\"继承和多态是面向对象编程的三大特性\",{\"1\":{\"212\":1}}],[\"继承和多态\",{\"0\":{\"212\":1}}],[\"继承的子类必须显式标记为final\",{\"1\":{\"347\":1}}],[\"继承也是同样的\",{\"1\":{\"282\":1}}],[\"继承自genericservlet\",{\"1\":{\"876\":1}}],[\"继承自servletrequest\",{\"1\":{\"874\":1}}],[\"继承自\",{\"1\":{\"264\":1}}],[\"继承自number类\",{\"1\":{\"227\":1}}],[\"继承自哪个类\",{\"1\":{\"179\":1}}],[\"继承\",{\"0\":{\"214\":1,\"847\":1,\"849\":1},\"1\":{\"212\":1,\"264\":1}}],[\"反映客观事物间的本质联系\",{\"1\":{\"549\":1}}],[\"反正只要是符合接口中方法的定义的\",{\"1\":{\"258\":1}}],[\"反正作为新手\",{\"1\":{\"60\":1}}],[\"反射获取注解\",{\"0\":{\"208\":1}}],[\"反射3\",{\"0\":{\"196\":1,\"197\":1}}],[\"反射非常暴力\",{\"1\":{\"193\":1}}],[\"反射非常强大\",{\"1\":{\"192\":1}}],[\"反射可以无视权限修饰符访问类的内容\",{\"1\":{\"191\":1}}],[\"反射2\",{\"0\":{\"189\":1,\"190\":1}}],[\"反射操作可能需要用到\",{\"1\":{\"183\":1}}],[\"反射就是把java类中的各个成分映射成一个个的java对象\",{\"1\":{\"179\":1}}],[\"反射\",{\"0\":{\"179\":1},\"1\":{\"305\":1,\"605\":1}}],[\"反射1\",{\"0\":{\"177\":1,\"178\":1}}],[\"顾客3\",{\"1\":{\"174\":1}}],[\"顾客2\",{\"1\":{\"174\":1}}],[\"顾客1\",{\"1\":{\"174\":1}}],[\"顾客吃掉菜品的时间为4秒\",{\"1\":{\"174\":1}}],[\"厨师2\",{\"1\":{\"174\":1}}],[\"厨师1\",{\"1\":{\"174\":1}}],[\"通常也称为\",{\"1\":{\"509\":1}}],[\"通常是具有有限步长的trajectory\",{\"1\":{\"393\":1}}],[\"通常为\",{\"1\":{\"371\":2}}],[\"通俗点说\",{\"1\":{\"358\":1}}],[\"通俗的讲\",{\"1\":{\"174\":1}}],[\"通配符\",{\"1\":{\"281\":1}}],[\"通过这样进行划分\",{\"1\":{\"926\":1}}],[\"通过这种方式创建的map和通过arrays创建的list比较类似\",{\"1\":{\"318\":1}}],[\"通过这种方式\",{\"1\":{\"199\":1,\"573\":1}}],[\"通过修改form标签的属性\",{\"1\":{\"886\":1}}],[\"通过修改对应的format函数来实现自定义\",{\"1\":{\"761\":1}}],[\"通过运行tomcat服务器\",{\"1\":{\"864\":1}}],[\"通过流程图我们得知\",{\"1\":{\"826\":1}}],[\"通过modules标签将项目的所有子项目引用进来\",{\"1\":{\"855\":1}}],[\"通过maven\",{\"1\":{\"817\":1}}],[\"通过method对象的invoke方法来调用方法\",{\"1\":{\"192\":2}}],[\"通过在类中定义多个内部类来完成\",{\"1\":{\"805\":1}}],[\"通过日志输出的结果会更加规范\",{\"1\":{\"725\":1}}],[\"通过序列化\",{\"1\":{\"701\":1}}],[\"通过执行另外一个\",{\"1\":{\"666\":1}}],[\"通过namespace来将各种操作绑定到一个接口上\",{\"1\":{\"659\":1}}],[\"通过前面的学习\",{\"1\":{\"658\":1}}],[\"通过进行配置\",{\"1\":{\"641\":1}}],[\"通过一个xml文件去配置\",{\"1\":{\"641\":1}}],[\"通过invoker为传入的实体类对象赋值\",{\"1\":{\"658\":1}}],[\"通过idea我们可以使用ctrl+\",{\"1\":{\"634\":1}}],[\"通过isinterrupted\",{\"1\":{\"144\":1}}],[\"通过开启事务\",{\"1\":{\"623\":1}}],[\"通过直接将我们的内容进行替换的方式来填写数据\",{\"1\":{\"622\":1}}],[\"通过drivermanager来获得数据库连接\",{\"1\":{\"605\":1}}],[\"通过drop来删除一个视图\",{\"1\":{\"596\":1}}],[\"通过drop来删除一个列\",{\"1\":{\"568\":1}}],[\"通过java如何去使用数据库来帮助我们存储数据\",{\"1\":{\"603\":1}}],[\"通过javac命令\",{\"1\":{\"199\":1}}],[\"通过学习它们能够让你的数据库管理能力更上一层楼\",{\"1\":{\"599\":1}}],[\"通过下面的命令来查看触发器\",{\"1\":{\"598\":1}}],[\"通过构建一个er图\",{\"1\":{\"550\":1}}],[\"通过构造函数来构建\",{\"1\":{\"366\":1}}],[\"通过访问\",{\"1\":{\"544\":1}}],[\"通过session\",{\"1\":{\"914\":1}}],[\"通过setattribute方法来给当前请求添加一个附加数据\",{\"1\":{\"900\":1}}],[\"通过sqlsession进行事务提交\",{\"1\":{\"682\":1}}],[\"通过socket对象\",{\"1\":{\"537\":1}}],[\"通过socket技术\",{\"1\":{\"535\":1}}],[\"通过string\",{\"1\":{\"91\":1}}],[\"通过梯度的算法来最小化对应的损失函数\",{\"1\":{\"516\":1}}],[\"通过采取\",{\"1\":{\"459\":1}}],[\"通过迭代算法求解\",{\"1\":{\"451\":1}}],[\"通过求解\",{\"1\":{\"422\":1}}],[\"通过k\",{\"1\":{\"387\":1}}],[\"通过gak\",{\"1\":{\"379\":1}}],[\"通过getfield\",{\"1\":{\"193\":1}}],[\"通过get方法返回得到的值\",{\"1\":{\"71\":1}}],[\"通过优化无人机的部署和动态移动来解决总用户mos最大化问题\",{\"1\":{\"379\":1}}],[\"通过yield指定返回结果\",{\"1\":{\"340\":1}}],[\"通过过滤器过滤\",{\"1\":{\"319\":1}}],[\"通过它大大方便了我们的编程\",{\"1\":{\"319\":1}}],[\"通过将这些包分出不同的模块\",{\"1\":{\"303\":1}}],[\"通过具体对象\",{\"1\":{\"295\":1}}],[\"通过自动装箱转换的integer对象\",{\"1\":{\"227\":1}}],[\"通过添加abstract关键字\",{\"1\":{\"218\":1}}],[\"通过反射机制\",{\"1\":{\"208\":1}}],[\"通过反射可以直接将final修饰符直接去除\",{\"1\":{\"193\":1}}],[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值\",{\"1\":{\"193\":1}}],[\"通过方法名和形参类型获取类中的方法\",{\"1\":{\"192\":2}}],[\"通过调用getmethod\",{\"1\":{\"192\":1}}],[\"通过调用sleep\",{\"1\":{\"143\":1}}],[\"通过调用start\",{\"1\":{\"140\":1}}],[\"通过获取类的构造方法\",{\"1\":{\"191\":1}}],[\"通过实例对象获取\",{\"1\":{\"182\":1}}],[\"通过包名\",{\"1\":{\"182\":1}}],[\"通过类名获取\",{\"1\":{\"182\":1}}],[\"通过classloader将类加载\",{\"1\":{\"180\":1}}],[\"通过多线程编程\",{\"1\":{\"174\":1}}],[\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了\",{\"1\":{\"155\":1}}],[\"通过使用空格和换行来完成分段\",{\"1\":{\"859\":1}}],[\"通过使用这些工具\",{\"1\":{\"705\":1}}],[\"通过使用动态sql语句\",{\"1\":{\"694\":1}}],[\"通过使用left\",{\"1\":{\"586\":1}}],[\"通过使用group\",{\"1\":{\"583\":1}}],[\"通过使用select语句来进行单表查询\",{\"1\":{\"579\":1}}],[\"通过使用setpriority方法来设定优先级\",{\"1\":{\"145\":1}}],[\"通过使用inner\",{\"1\":{\"586\":1}}],[\"通过使用insert\",{\"1\":{\"571\":1}}],[\"通过使用ifpresentorelse\",{\"1\":{\"323\":1}}],[\"通过使用drop\",{\"1\":{\"566\":1}}],[\"通过使用\",{\"1\":{\"561\":1,\"627\":1,\"629\":2,\"648\":1}}],[\"通过使用关系型数据库\",{\"1\":{\"550\":1}}],[\"通过使用一个函数来进行拟合\",{\"1\":{\"505\":1}}],[\"通过使用opens关键字来为其他模块开放反射权限\",{\"1\":{\"309\":1}}],[\"通过使用newinstance\",{\"1\":{\"191\":1}}],[\"通过使用yield\",{\"1\":{\"147\":1}}],[\"通过使用迭代器\",{\"1\":{\"31\":1}}],[\"通过创建索引\",{\"1\":{\"597\":1}}],[\"通过创建thread对象来创建一个新的线程\",{\"1\":{\"139\":1}}],[\"通过创建泛型接口的匿名内部类\",{\"1\":{\"14\":1}}],[\"通过file对象\",{\"1\":{\"98\":2}}],[\"通过while循环来一次性读完内容\",{\"1\":{\"91\":1}}],[\"通过\",{\"1\":{\"84\":1,\"365\":1,\"367\":1,\"403\":1,\"419\":1,\"421\":1,\"444\":1,\"449\":1,\"456\":1,\"544\":1}}],[\"通过观察\",{\"1\":{\"67\":1}}],[\"通过resize方法初始化底层哈希表\",{\"1\":{\"59\":1}}],[\"通过给定的键\",{\"1\":{\"56\":1}}],[\"通过给设定泛型上限\",{\"1\":{\"15\":1}}],[\"生命周期\",{\"0\":{\"802\":1}}],[\"生效了\",{\"1\":{\"613\":1}}],[\"生产者此时等待货架出现空位\",{\"1\":{\"174\":1}}],[\"生产者要生产产品\",{\"1\":{\"174\":1}}],[\"生产者与消费者\",{\"0\":{\"174\":1}}],[\"生成一个随机数\",{\"1\":{\"780\":1}}],[\"生成一个匿名的iterator对象\",{\"1\":{\"36\":1}}],[\"生成流\",{\"1\":{\"71\":1}}],[\"生成\",{\"1\":{\"71\":1}}],[\"生成反向迭代器\",{\"1\":{\"44\":1}}],[\"生成当前集合的迭代器\",{\"1\":{\"36\":1}}],[\"生成当前集合的并行流\",{\"1\":{\"23\":1}}],[\"生成当前集合的流\",{\"1\":{\"23\":1}}],[\"效率会更高\",{\"1\":{\"699\":1}}],[\"效率会截然不同\",{\"1\":{\"688\":1}}],[\"效率就会提升很多\",{\"1\":{\"688\":1}}],[\"效率非常低\",{\"1\":{\"688\":1}}],[\"效率过低\",{\"1\":{\"450\":1}}],[\"效率更高\",{\"1\":{\"173\":1}}],[\"效果和之前我们编写xml形式的动态sql一致\",{\"1\":{\"719\":1}}],[\"效果和第一种方法是一样的\",{\"1\":{\"668\":1}}],[\"效果和上面是一模一样\",{\"1\":{\"292\":1}}],[\"效果是一样的\",{\"1\":{\"323\":1}}],[\"效果是完全一样的\",{\"1\":{\"34\":1}}],[\"效果跟上面是一样的\",{\"1\":{\"14\":1}}],[\"程序中的properties对象也可以快速保存为一个对应的\",{\"1\":{\"755\":1}}],[\"程序可以正常运行\",{\"1\":{\"304\":1}}],[\"程序继续正常运行\",{\"1\":{\"267\":1}}],[\"程序正常运行中\",{\"1\":{\"172\":2}}],[\"程序编译之后的样子是什么样的\",{\"1\":{\"16\":1}}],[\"守护进程在后台运行运行\",{\"1\":{\"172\":1}}],[\"守护线程自动结束\",{\"1\":{\"172\":2}}],[\"守护线程\",{\"0\":{\"172\":1}}],[\"结尾的域名都可以访问该cookie\",{\"1\":{\"909\":1}}],[\"结合了\",{\"1\":{\"809\":1}}],[\"结合\",{\"0\":{\"716\":1}}],[\"结合去寻找最优策略\",{\"1\":{\"485\":1}}],[\"结构化查询语言\",{\"1\":{\"561\":1}}],[\"结果会自动进行遍历并依次执行我们传入的lambda表达式\",{\"1\":{\"653\":1}}],[\"结果肯定是空\",{\"1\":{\"366\":1}}],[\"结果是\",{\"1\":{\"254\":1}}],[\"结果依然是删除成功\",{\"1\":{\"25\":1}}],[\"结束并提交时\",{\"1\":{\"701\":1}}],[\"结束\",{\"1\":{\"167\":1}}],[\"循环间隔\",{\"1\":{\"166\":1}}],[\"循环定时任务等\",{\"1\":{\"166\":1}}],[\"延迟\",{\"1\":{\"166\":1}}],[\"定时器\",{\"0\":{\"164\":1}}],[\"定义目标函数\",{\"1\":{\"506\":1}}],[\"定义了agent与环境的交互行为\",{\"1\":{\"393\":1}}],[\"定义了一个名为accept的抽象方法\",{\"1\":{\"351\":1}}],[\"定义为ξ=\",{\"1\":{\"387\":1}}],[\"定义接口\",{\"1\":{\"219\":1}}],[\"定义\",{\"0\":{\"206\":1,\"235\":1},\"1\":{\"219\":1,\"422\":1,\"899\":1}}],[\"定义一个自己的classloader\",{\"1\":{\"199\":1}}],[\"定义可以先放在try外部\",{\"1\":{\"90\":1}}],[\"定义中提到\",{\"1\":{\"84\":1}}],[\"定义的全部功能\",{\"1\":{\"67\":1}}],[\"设计的\",{\"1\":{\"911\":1}}],[\"设计一种基于\",{\"1\":{\"379\":2}}],[\"设\",{\"1\":{\"509\":1,\"511\":1}}],[\"设无人机总数为n\",{\"1\":{\"388\":1}}],[\"设置完成后\",{\"1\":{\"864\":1}}],[\"设置为\",{\"1\":{\"401\":1}}],[\"设置为守护线程\",{\"1\":{\"172\":2}}],[\"设置初始值\",{\"1\":{\"163\":1}}],[\"设定为20秒\",{\"1\":{\"909\":1}}],[\"设定内容类型以及编码格式\",{\"1\":{\"875\":1}}],[\"设定此属性的值\",{\"1\":{\"193\":1}}],[\"设定上界为number\",{\"1\":{\"16\":1}}],[\"设定类型参数上界\",{\"1\":{\"15\":1}}],[\"唤醒所有等待当前对象锁的线程\",{\"1\":{\"215\":1}}],[\"唤醒一个等待当前对象锁的线程\",{\"1\":{\"215\":1}}],[\"唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\",{\"1\":{\"161\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"161\":1}}],[\"态\",{\"1\":{\"161\":1}}],[\"平常环境下是无法使用的\",{\"1\":{\"161\":1}}],[\"分组和分页查询\",{\"0\":{\"583\":1}}],[\"分析随机变量\",{\"1\":{\"507\":1}}],[\"分析\",{\"0\":{\"476\":1}}],[\"分数\",{\"1\":{\"338\":1}}],[\"分为多个字符串\",{\"1\":{\"331\":2}}],[\"分别位于main和test目录下\",{\"1\":{\"818\":1}}],[\"分别是user表和user\",{\"1\":{\"669\":1}}],[\"分别是wait\",{\"1\":{\"161\":1}}],[\"分别执行两个选择语句\",{\"1\":{\"668\":1}}],[\"分别需要使用\",{\"1\":{\"653\":1}}],[\"分别代表插入\",{\"1\":{\"561\":1}}],[\"分别设为1\",{\"1\":{\"384\":1}}],[\"分别适用于快速创建包含0~10对键值对的map\",{\"1\":{\"318\":1}}],[\"分割字符串\",{\"1\":{\"244\":1}}],[\"分割字符串并生成新的流\",{\"1\":{\"71\":1}}],[\"分割操作\",{\"1\":{\"244\":1}}],[\"然后去mybatis\",{\"1\":{\"888\":1}}],[\"然后去\",{\"1\":{\"876\":1}}],[\"然后点击完成\",{\"1\":{\"865\":1}}],[\"然后设置tomcat主目录即可\",{\"1\":{\"865\":1}}],[\"然后依次build直到所有任务都完成\",{\"1\":{\"855\":1}}],[\"然后执行install或直接在命令行中输入mvn\",{\"1\":{\"840\":1}}],[\"然后可以在控制台看到当前的测试用例耗时以及状态\",{\"1\":{\"776\":1}}],[\"然后直接通过注解的形式引用\",{\"1\":{\"716\":1}}],[\"然后这里我们传入的参数直接写成对应的类型即可\",{\"1\":{\"678\":1}}],[\"然后配置关联查询相关信息\",{\"1\":{\"667\":1}}],[\"然后将idea的maven配置为我们自行安装的位置\",{\"1\":{\"827\":1}}],[\"然后将这些参数添加到map中进行传递\",{\"1\":{\"660\":1}}],[\"然后将我们的参数填写到后面\",{\"1\":{\"649\":1}}],[\"然后通过反射进行赋值\",{\"1\":{\"658\":1}}],[\"然后查询得到的实体对象作为value\",{\"1\":{\"653\":1}}],[\"然后得到的结果作为value的map\",{\"1\":{\"653\":1}}],[\"然后就能够正确查询了\",{\"1\":{\"652\":1}}],[\"然后就在标签中写入我们的查询语句即可\",{\"1\":{\"643\":1}}],[\"然后就是响应内容\",{\"1\":{\"544\":1}}],[\"然后生成了一个\",{\"1\":{\"528\":1}}],[\"然后我们需要配置web应用程序服务器\",{\"1\":{\"865\":1}}],[\"然后我们可以通过使用\",{\"1\":{\"720\":1}}],[\"然后我们要安装一下lombok插件\",{\"1\":{\"628\":1}}],[\"然后我们通过cmd去登陆mysql\",{\"1\":{\"590\":1}}],[\"然后我们通过\",{\"1\":{\"516\":1}}],[\"然后我们导入了lombok框架的依赖\",{\"1\":{\"311\":1}}],[\"然后在javac进行编译的时候\",{\"1\":{\"628\":1}}],[\"然后在更新了一定次数之后\",{\"1\":{\"516\":1}}],[\"然后在项目b使用\",{\"1\":{\"307\":1}}],[\"然后进行迭代\",{\"1\":{\"453\":1}}],[\"然后进行不断迭代\",{\"1\":{\"421\":1}}],[\"然后根据属性调用对应的方法进行修改\",{\"1\":{\"367\":1}}],[\"然后使用方法的形式来表示\",{\"1\":{\"659\":1}}],[\"然后使用的时候\",{\"1\":{\"367\":1}}],[\"然后使用相应接口的抽象方参数列表的第一个作为目标对象\",{\"1\":{\"294\":1}}],[\"然后用\",{\"1\":{\"366\":1}}],[\"然后类型转换\",{\"1\":{\"342\":1}}],[\"然后前后截取\",{\"1\":{\"333\":1}}],[\"然后再添加数据\",{\"1\":{\"318\":1}}],[\"然后定义c并得到a+b的结果\",{\"1\":{\"316\":1}}],[\"然后声明我们提供了实现类\",{\"1\":{\"310\":1}}],[\"然后创建子类对象\",{\"1\":{\"255\":1}}],[\"然后编写一个我们自己的classloader\",{\"1\":{\"199\":1}}],[\"然后\",{\"1\":{\"156\":1,\"910\":1}}],[\"然后继续做我们的事情\",{\"1\":{\"144\":1}}],[\"首次调用会移动到第一行\",{\"1\":{\"614\":1}}],[\"首先在js中编写我们的xhr请求\",{\"1\":{\"893\":1}}],[\"首先将我们的icon\",{\"1\":{\"891\":1}}],[\"首先将其转换为httpservletrequest\",{\"1\":{\"874\":1}}],[\"首先设置一下响应类型\",{\"1\":{\"889\":1}}],[\"首先name属性就是servlet名称\",{\"1\":{\"878\":1}}],[\"首先servlet有一个直接实现抽象类genericservlet\",{\"1\":{\"876\":1}}],[\"首先\",{\"1\":{\"875\":1}}],[\"首先执行构造方法完成\",{\"1\":{\"872\":1}}],[\"首先点击新建\",{\"1\":{\"865\":1}}],[\"首先获取日志打印器\",{\"1\":{\"725\":1}}],[\"首先还是关联查询的sql语句\",{\"1\":{\"670\":1}}],[\"首先来看最简单的一对一查询\",{\"1\":{\"666\":1}}],[\"首先编写实体类\",{\"1\":{\"643\":1}}],[\"首先是关联查询的sql语句\",{\"1\":{\"667\":1}}],[\"首先是传统方式\",{\"1\":{\"627\":1}}],[\"首先是响应头\",{\"1\":{\"544\":1}}],[\"首先要通过connection对象调用setautocommit\",{\"1\":{\"623\":1}}],[\"首先要明确\",{\"1\":{\"614\":1}}],[\"首先定义我们的实体类\",{\"1\":{\"616\":1}}],[\"首先需要添加一个环境变量\",{\"1\":{\"590\":1}}],[\"首先我们要知道\",{\"1\":{\"926\":1}}],[\"首先我们要明确\",{\"1\":{\"551\":1}}],[\"首先我们编写前端部分\",{\"1\":{\"892\":1}}],[\"首先我们来看看比较简单的下载文件\",{\"1\":{\"891\":1}}],[\"首先我们需要指定select操作的id\",{\"1\":{\"648\":1}}],[\"首先我们需要导入lombok的jar依赖\",{\"1\":{\"628\":1}}],[\"首先我们在项目a中\",{\"1\":{\"307\":1}}],[\"首先初始化一个随机的策略π0​\",{\"1\":{\"453\":1}}],[\"首先随机设计一个初始的策略π0​\",{\"1\":{\"440\":1}}],[\"首先判断是否为student类型\",{\"1\":{\"342\":1}}],[\"首先模块具有四种类型\",{\"1\":{\"306\":1}}],[\"首先方法参数类型是可以省略的\",{\"1\":{\"290\":1}}],[\"首先实现cloneable接口\",{\"1\":{\"220\":1}}],[\"首先利用jps找到我们的java进程号\",{\"1\":{\"156\":1}}],[\"首字母不是大写字母\",{\"1\":{\"71\":1}}],[\"导出视图good\",{\"1\":{\"596\":1}}],[\"导出其他的视图\",{\"1\":{\"596\":1}}],[\"导入插件后\",{\"1\":{\"854\":1}}],[\"导入本地依赖\",{\"0\":{\"838\":1,\"839\":1}}],[\"导入本地jar包\",{\"0\":{\"835\":1}}],[\"导入依赖\",{\"0\":{\"775\":1}}],[\"导入项目a的模块\",{\"1\":{\"310\":1}}],[\"导入我们需要使用的类\",{\"1\":{\"120\":1}}],[\"导致其10次里面会有1次出现错误\",{\"1\":{\"807\":1}}],[\"导致mybatis无法确定具体哪个参数交什么名字\",{\"1\":{\"660\":1}}],[\"导致一方还持有连接\",{\"1\":{\"538\":1}}],[\"导致被破坏\",{\"1\":{\"193\":1}}],[\"导致程序卡住\",{\"1\":{\"156\":1}}],[\"死锁是指两个线程相互持有对方需要的锁\",{\"1\":{\"156\":1}}],[\"死锁\",{\"0\":{\"156\":1}}],[\"引言\",{\"0\":{\"467\":1}}],[\"引入两个网络\",{\"1\":{\"516\":1}}],[\"引入随机变量后对应的discounted\",{\"1\":{\"413\":1}}],[\"引入discount\",{\"1\":{\"393\":1}}],[\"引入\",{\"0\":{\"462\":1,\"484\":1,\"505\":1},\"1\":{\"155\":1,\"422\":1}}],[\"引用了一个方法过来\",{\"1\":{\"291\":1}}],[\"引用尾结点\",{\"1\":{\"25\":1}}],[\"引用首结点\",{\"1\":{\"25\":1}}],[\"缓存还会生效吗\",{\"1\":{\"700\":1}}],[\"缓存的概念在我们后续的学习中还会经常遇见\",{\"1\":{\"699\":1}}],[\"缓存机制\",{\"0\":{\"699\":1}}],[\"缓存一致性问题\",{\"0\":{\"705\":1}}],[\"缓存一致性\",{\"1\":{\"154\":1}}],[\"缓冲字符输出流\",{\"0\":{\"113\":1}}],[\"缓冲字符读取流\",{\"0\":{\"112\":1}}],[\"缓冲字符流\",{\"0\":{\"111\":1}}],[\"缓冲字节输出流\",{\"0\":{\"110\":1}}],[\"缓冲字节读取流\",{\"0\":{\"105\":1}}],[\"缓冲字节流\",{\"0\":{\"104\":1}}],[\"缓冲机制\",{\"0\":{\"108\":1}}],[\"缓冲区\",{\"1\":{\"103\":1}}],[\"缓冲流可以叠加\",{\"0\":{\"109\":1}}],[\"缓冲流特性\",{\"0\":{\"106\":1}}],[\"缓冲流\",{\"0\":{\"103\":1}}],[\"写到外面还是全部\",{\"1\":{\"805\":1}}],[\"写法\",{\"1\":{\"340\":1}}],[\"写共享变量的副本\",{\"1\":{\"154\":1}}],[\"写入的是二进制数据\",{\"1\":{\"129\":1}}],[\"写入对应长度的数据到输出流\",{\"1\":{\"94\":1}}],[\"本文目的是优化无人机在每个时隙的位置\",{\"1\":{\"385\":1}}],[\"本地缓存\",{\"1\":{\"699\":1}}],[\"本地方法不是我们se中需要学习的内容\",{\"1\":{\"215\":1}}],[\"本地内存\",{\"1\":{\"154\":1}}],[\"本来应该进行2次自增操作\",{\"1\":{\"154\":1}}],[\"本质是\",{\"1\":{\"291\":1}}],[\"本质就是调用的构造方法\",{\"1\":{\"221\":1}}],[\"本质上还是类的实例进行调用\",{\"1\":{\"192\":1}}],[\"本质上是一个intstream\",{\"1\":{\"71\":1}}],[\"本质和普通进程类似\",{\"1\":{\"172\":1}}],[\"本质也是reader和writer\",{\"1\":{\"126\":1}}],[\"再使用appclassloader进行加载\",{\"1\":{\"926\":1}}],[\"再倒回来处理\",{\"1\":{\"920\":1}}],[\"再去编写对应逻辑\",{\"1\":{\"888\":1}}],[\"再发送给浏览器\",{\"1\":{\"875\":1}}],[\"再父logger\",{\"1\":{\"746\":1}}],[\"再次访问\",{\"1\":{\"900\":1}}],[\"再次向此地址发出请求\",{\"1\":{\"899\":1}}],[\"再次执行我们之前的操作\",{\"1\":{\"701\":1}}],[\"再次获取\",{\"1\":{\"700\":1}}],[\"再次出现\",{\"1\":{\"455\":1}}],[\"再次强调\",{\"1\":{\"193\":1,\"633\":1}}],[\"再将\",{\"1\":{\"451\":1}}],[\"再将用户划分给距离最近的无人机\",{\"1\":{\"387\":1}}],[\"再求平均值\",{\"1\":{\"415\":1}}],[\"再根据欧几里得距离重新划分\",{\"1\":{\"387\":1}}],[\"再找到新的簇的各中心\",{\"1\":{\"387\":1}}],[\"再找好我们要截取的屁股后面紧接着的位置\",{\"1\":{\"333\":1}}],[\"再通过sqlsession来执行对应的方法\",{\"1\":{\"659\":1}}],[\"再通过这些经验来不断改进更新另一个策略\",{\"1\":{\"497\":1}}],[\"再通过\",{\"1\":{\"365\":1}}],[\"再也不用arrays了\",{\"1\":{\"318\":1}}],[\"再来调用此方法\",{\"1\":{\"199\":1}}],[\"再来看看servletresponse\",{\"1\":{\"875\":1}}],[\"再来看\",{\"1\":{\"67\":1}}],[\"再写回主内存后\",{\"1\":{\"154\":1}}],[\"再继续执行的线程2内容\",{\"1\":{\"148\":1}}],[\"尽可能减少\",{\"1\":{\"552\":1}}],[\"尽可能多的在执行线程2的内容\",{\"1\":{\"147\":1}}],[\"尽可能的扬长避短\",{\"1\":{\"25\":1}}],[\"观察结果\",{\"1\":{\"147\":1}}],[\"yyds\",{\"1\":{\"908\":1,\"910\":1}}],[\"yyyy年mm月dd日\",{\"1\":{\"893\":1}}],[\"yyyy\",{\"1\":{\"765\":1}}],[\"year存储年份\",{\"1\":{\"563\":1}}],[\"yt​\",{\"1\":{\"516\":1}}],[\"yt​≐r+γmaxa∈a\",{\"1\":{\"516\":1}}],[\"yt​−q^​\",{\"1\":{\"516\":2}}],[\"y≐r+γmaxa∈a\",{\"1\":{\"516\":1}}],[\"yuser​\",{\"1\":{\"388\":2}}],[\"yuav​\",{\"1\":{\"387\":2,\"388\":2}}],[\"yd​+1\",{\"1\":{\"387\":1}}],[\"yd​\",{\"1\":{\"387\":1}}],[\"yn​\",{\"1\":{\"382\":2}}],[\"ykn​​\",{\"1\":{\"382\":1}}],[\"your\",{\"1\":{\"864\":1}}],[\"you\",{\"1\":{\"341\":3,\"864\":5}}],[\"yoni\",{\"1\":{\"65\":3}}],[\"y\",{\"1\":{\"292\":3}}],[\"yield\",{\"1\":{\"147\":1,\"340\":3}}],[\"获得reward\",{\"1\":{\"394\":1}}],[\"获得并行流\",{\"1\":{\"173\":1}}],[\"获得cpu资源的概率会越大\",{\"1\":{\"145\":1}}],[\"获取post请求携带的表单数据\",{\"1\":{\"889\":1}}],[\"获取任何以js结尾的文件\",{\"1\":{\"878\":1}}],[\"获取writer直接写入内容\",{\"1\":{\"875\":1}}],[\"获取头部信息\",{\"1\":{\"874\":1}}],[\"获取请求方法\",{\"1\":{\"874\":1}}],[\"获取访问者的ip地址\",{\"1\":{\"874\":1}}],[\"获取协议版本\",{\"1\":{\"874\":1}}],[\"获取所有的请求内容\",{\"1\":{\"873\":1}}],[\"获取logmanager读取配置文件\",{\"1\":{\"756\":1}}],[\"获取系统数据\",{\"0\":{\"755\":1}}],[\"获取一个新的会话\",{\"1\":{\"647\":1}}],[\"获取首个\",{\"1\":{\"636\":1}}],[\"获取参数列表\",{\"1\":{\"616\":1}}],[\"获取值\",{\"1\":{\"355\":1}}],[\"获取成绩需要进行强制类型转换\",{\"1\":{\"280\":1}}],[\"获取成员变量\",{\"1\":{\"199\":1}}],[\"获取异常的错误信息\",{\"1\":{\"267\":1}}],[\"获取长度\",{\"1\":{\"244\":1}}],[\"获取封装的成员变量\",{\"1\":{\"221\":1}}],[\"获取对象的哈希值\",{\"1\":{\"215\":1}}],[\"获取对应下标位置上的元素\",{\"1\":{\"24\":1}}],[\"获取我们在注解中写入的内容\",{\"1\":{\"208\":2}}],[\"获取我们定义的test\",{\"1\":{\"199\":2}}],[\"获取类型\",{\"1\":{\"208\":2}}],[\"获取类名称\",{\"1\":{\"184\":1}}],[\"获取返回值类型\",{\"1\":{\"192\":1}}],[\"获取方法名称\",{\"1\":{\"192\":1}}],[\"获取非public方法并调用\",{\"1\":{\"192\":1}}],[\"获取父类的原始类型的type\",{\"1\":{\"186\":1}}],[\"获取它的类加载器\",{\"1\":{\"184\":1}}],[\"获取相应类的class对象\",{\"0\":{\"182\":1}}],[\"获取到的servletcontext始终是同一个对象\",{\"1\":{\"901\":1}}],[\"获取到的是不同的锁\",{\"1\":{\"155\":1}}],[\"获取到类的一些属性\",{\"1\":{\"179\":1}}],[\"获取线程名称\",{\"1\":{\"140\":1}}],[\"获取文件的绝对路径\",{\"1\":{\"98\":1}}],[\"获取文件的大小\",{\"1\":{\"98\":1}}],[\"获取平均值\",{\"1\":{\"71\":1}}],[\"获取数量\",{\"1\":{\"71\":1}}],[\"获取语法统计实例\",{\"1\":{\"71\":1}}],[\"获取键值对的值\",{\"1\":{\"56\":1}}],[\"获取键值对的键\",{\"1\":{\"56\":1}}],[\"获取当前的类型class对象\",{\"1\":{\"215\":1}}],[\"获取当前线程对象\",{\"1\":{\"140\":1,\"142\":1}}],[\"获取当前存储的键值对数量\",{\"1\":{\"56\":1}}],[\"获取当前集合中的元素数量\",{\"1\":{\"23\":1}}],[\"获取队尾元素\",{\"1\":{\"44\":1}}],[\"获取队首元素\",{\"1\":{\"44\":1}}],[\"休眠后再运行\",{\"1\":{\"165\":2}}],[\"休眠3秒\",{\"1\":{\"144\":1}}],[\"休眠时间\",{\"1\":{\"142\":1}}],[\"由官方定义了一系列接口\",{\"1\":{\"870\":1}}],[\"由客户端向服务端发送是报文称为请求报文\",{\"1\":{\"859\":1}}],[\"由驱动程序转交给应用程序负责\",{\"1\":{\"623\":1}}],[\"由无人机的位置和它们在最后时隙采取的动作决定\",{\"1\":{\"388\":1}}],[\"由用户的初始位置和运动模型决定\",{\"1\":{\"388\":1}}],[\"由此进行迭代\",{\"1\":{\"440\":1}}],[\"由此可以根据contraction\",{\"1\":{\"432\":1}}],[\"由此可以推导出一个多步的trajectory\",{\"1\":{\"413\":1}}],[\"由此\",{\"1\":{\"383\":1}}],[\"由线程来响应此中断并进行相应的处理\",{\"1\":{\"144\":1}}],[\"由于该类并不是jdk内部或是扩展类\",{\"1\":{\"926\":1}}],[\"由于过滤器的过滤顺序是按照类名的自然排序进行的\",{\"1\":{\"920\":1}}],[\"由于我们整个应用程序可能存在多个过滤器\",{\"1\":{\"920\":1}}],[\"由于http是无连接的\",{\"1\":{\"911\":1}}],[\"由于此servlet不支持post请求\",{\"1\":{\"900\":1}}],[\"由于此时抛出的是一个arithmeticexception并不是我们需要的ioexception或是其子类\",{\"1\":{\"790\":1}}],[\"由于不知道是什么\",{\"1\":{\"864\":1}}],[\"由于不同用户对于传输速率的需求是不同的\",{\"1\":{\"384\":1}}],[\"由于不同集群的频谱不同\",{\"1\":{\"383\":1}}],[\"由于mybatis要支持多种类型的日志\",{\"1\":{\"842\":1}}],[\"由于mybatis默认情况下直接通过无参构造来创建实体类对象\",{\"1\":{\"658\":1}}],[\"由于返回的结果是一个列表\",{\"1\":{\"653\":1}}],[\"由于这里我们需要通过一个参数来查询\",{\"1\":{\"648\":1}}],[\"由于这里只有一句打印\",{\"1\":{\"297\":1}}],[\"由于sqlsessionfactory一般只需要创建一次\",{\"1\":{\"647\":1}}],[\"由于string类的构造方法返回的肯定是一个string类型的对象\",{\"1\":{\"296\":1}}],[\"由于string的构造方法在创建对象时也会得到一个string类型的结果\",{\"1\":{\"258\":1}}],[\"由于idea默认都安装了lombok的插件\",{\"1\":{\"628\":1}}],[\"由于存在如下决定关系\",{\"1\":{\"556\":1}}],[\"由于继承了autocloseble\",{\"1\":{\"536\":1}}],[\"由于πk+1​是\",{\"1\":{\"437\":1}}],[\"由于\",{\"1\":{\"422\":1,\"437\":1}}],[\"由于用户在每个时隙都处于漫游状态\",{\"1\":{\"388\":1}}],[\"由于gak\",{\"1\":{\"387\":1}}],[\"由于特定用户的mos与该用户与无人机之间的距离有关\",{\"1\":{\"387\":1}}],[\"由于java版本的更新迭代速度自java\",{\"1\":{\"337\":1}}],[\"由于没有使用java\",{\"1\":{\"306\":1}}],[\"由于仅有返回语句这一行\",{\"1\":{\"290\":1}}],[\"由于只有一个参数\",{\"1\":{\"290\":1}}],[\"由于是private访问权限\",{\"1\":{\"305\":1}}],[\"由于是\",{\"1\":{\"280\":1}}],[\"由于基本数据类型和引用类型不同\",{\"1\":{\"238\":1}}],[\"由于类本身都是继承\",{\"1\":{\"219\":1}}],[\"由于类型擦除机制\",{\"1\":{\"186\":1}}],[\"由于泛型中未定义\",{\"1\":{\"186\":1}}],[\"由于泛型机制上的一些漏洞\",{\"1\":{\"80\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"156\":1}}],[\"由于每个进程都有一个自己的内存空间\",{\"1\":{\"138\":1}}],[\"由于默认导入了系统自带的string类\",{\"1\":{\"120\":1}}],[\"由于外部i\",{\"1\":{\"103\":1}}],[\"由于底层采用哈希表实现\",{\"1\":{\"48\":1}}],[\"被包装的元素为null\",{\"1\":{\"323\":1}}],[\"被包装的元素为\",{\"1\":{\"323\":1}}],[\"被除数不能为0\",{\"1\":{\"266\":2}}],[\"被挂起的线程才能继续\",{\"1\":{\"156\":1}}],[\"被\",{\"1\":{\"143\":1}}],[\"阻塞态\",{\"1\":{\"161\":1}}],[\"阻塞\",{\"1\":{\"143\":1}}],[\"状态s时可以得到的平均reward\",{\"1\":{\"527\":1}}],[\"状态转换\",{\"1\":{\"393\":1}}],[\"状态转换模型\",{\"1\":{\"387\":1}}],[\"状态除了要考虑无人机的3d位置外\",{\"1\":{\"388\":1}}],[\"状态空间\",{\"1\":{\"387\":1,\"393\":1}}],[\"状态\",{\"1\":{\"143\":1,\"221\":1,\"387\":1,\"393\":1,\"509\":1,\"516\":1}}],[\"或其它类似的框架\",{\"1\":{\"689\":1}}],[\"或注解来配置和映射原生信息\",{\"1\":{\"633\":1}}],[\"或\",{\"1\":{\"623\":1,\"701\":1}}],[\"或是session创建的时候\",{\"1\":{\"922\":1}}],[\"或是docs项目\",{\"1\":{\"864\":1}}],[\"或是作为一个可执行的java应用程序运行\",{\"1\":{\"853\":1}}],[\"或是指定某些枚举常量\",{\"1\":{\"810\":1}}],[\"或是一些其他的配置项\",{\"1\":{\"902\":1}}],[\"或是一些非常紧急的日志信息\",{\"1\":{\"726\":1}}],[\"或是一个指定的jdk版本范围\",{\"1\":{\"795\":1}}],[\"或是使用相反的注解来为指定jdk关闭\",{\"1\":{\"794\":1}}],[\"或是使用相反注解来为指定操作系统关闭此用例\",{\"1\":{\"793\":1}}],[\"或是某些案例只需要在某个特定操作系统执行\",{\"1\":{\"792\":1}}],[\"或是结束并回滚\",{\"1\":{\"701\":1}}],[\"或是具有同样参数的实体类来传递\",{\"1\":{\"651\":1}}],[\"或是$\",{\"1\":{\"648\":1}}],[\"或是getupdatecount\",{\"1\":{\"608\":1}}],[\"或是\",{\"1\":{\"544\":1,\"561\":1}}],[\"或是继续使用此泛型让具体创建的对象来确定类型\",{\"1\":{\"282\":1}}],[\"或是调用sleep\",{\"1\":{\"142\":1}}],[\"或者还是mapper标签通过class属性来指定具体的接口\",{\"1\":{\"711\":1}}],[\"或者仅仅保存null\",{\"1\":{\"355\":1}}],[\"或者\",{\"1\":{\"237\":1,\"256\":1,\"359\":1,\"397\":1,\"440\":1,\"505\":1,\"530\":1}}],[\"或者是继续摆烂\",{\"1\":{\"282\":1}}],[\"或者是false\",{\"1\":{\"235\":1}}],[\"或者是在运行时可以通过反射访问\",{\"1\":{\"205\":1}}],[\"或者是引用的接口中并没有该方法时\",{\"1\":{\"204\":1}}],[\"或者为静态变量赋值\",{\"1\":{\"118\":1}}],[\"始终都是依次进行的\",{\"1\":{\"138\":1}}],[\"运用到\",{\"1\":{\"403\":1}}],[\"运用了封装的思想\",{\"1\":{\"227\":1}}],[\"运行服务器\",{\"1\":{\"886\":1}}],[\"运行\",{\"1\":{\"833\":1}}],[\"运行时出现错误\",{\"1\":{\"658\":1}}],[\"运行时异常只需要继承\",{\"1\":{\"265\":1}}],[\"运行时异常\",{\"1\":{\"264\":1}}],[\"运行后发现\",{\"1\":{\"652\":1}}],[\"运行函数\",{\"1\":{\"166\":1}}],[\"运行态\",{\"1\":{\"161\":1}}],[\"运行main\",{\"1\":{\"138\":1}}],[\"运算符\",{\"1\":{\"5\":1}}],[\"线程名称\",{\"1\":{\"765\":1}}],[\"线程会阻塞\",{\"1\":{\"536\":1,\"537\":1}}],[\"线程池\",{\"1\":{\"359\":1}}],[\"线程a和线程b都需要对方的锁\",{\"1\":{\"156\":1}}],[\"线程锁\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"线程锁和线程同步\",{\"0\":{\"153\":1}}],[\"线程之间的共享变量\",{\"1\":{\"154\":1}}],[\"线程之间是同时运行的\",{\"1\":{\"139\":1}}],[\"线程2变量值已设定\",{\"1\":{\"162\":1}}],[\"线程2\",{\"1\":{\"156\":1}}],[\"线程2完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"线程2等待线程1待执行的内容全部执行完成之后\",{\"1\":{\"148\":1}}],[\"线程2开始运行\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程1读取变量值\",{\"1\":{\"162\":1}}],[\"线程1变量值已设定\",{\"1\":{\"162\":1}}],[\"线程1\",{\"1\":{\"156\":1}}],[\"线程1完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"线程1加入后\",{\"1\":{\"148\":1}}],[\"线程1加入到此线程\",{\"1\":{\"148\":1}}],[\"线程1结束\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程1开始运行\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程优先级\",{\"0\":{\"145\":1}}],[\"线程被中断了\",{\"1\":{\"144\":1}}],[\"线程开始运行\",{\"1\":{\"144\":1,\"145\":1}}],[\"线程的加入只是等待另一个线程的完成\",{\"1\":{\"148\":1}}],[\"线程的礼让和加入\",{\"0\":{\"146\":1}}],[\"线程的优先级一般分为以下三种\",{\"1\":{\"145\":1}}],[\"线程的下一个状态会出现以下情况\",{\"1\":{\"143\":1}}],[\"线程的休眠和中断\",{\"0\":{\"143\":1}}],[\"线程的创建和启动\",{\"0\":{\"139\":1}}],[\"线程和进程差不多\",{\"1\":{\"142\":1}}],[\"线程是程序执行中一个单一的顺序控制流程\",{\"1\":{\"138\":1}}],[\"线程横空出世\",{\"1\":{\"138\":1}}],[\"线性表支持随机访问\",{\"1\":{\"24\":1}}],[\"线性表\",{\"1\":{\"24\":1}}],[\"浏览器显示cookie信息的时候显示该说明\",{\"1\":{\"909\":1}}],[\"浏览器也不会以任何形式保存该cookie\",{\"1\":{\"909\":1}}],[\"浏览器也是可以直接打开xml文件的\",{\"1\":{\"634\":1}}],[\"浏览器只发起了一次请求\",{\"1\":{\"900\":1}}],[\"浏览器发送了什么数据\",{\"1\":{\"886\":1}}],[\"浏览器就是安装在用户主机上的万维网客户程序\",{\"1\":{\"859\":1}}],[\"浏览器会显示无法访问\",{\"1\":{\"544\":1}}],[\"浏览器\",{\"1\":{\"138\":1}}],[\"进而补货\",{\"1\":{\"174\":1}}],[\"进入等待状态并释放锁\",{\"1\":{\"161\":1}}],[\"进程之间的通信就变得非常麻烦\",{\"1\":{\"138\":1}}],[\"进程是拥有资源和独立运行的最小单位\",{\"1\":{\"138\":1}}],[\"进程是程序执行的实体\",{\"1\":{\"138\":1}}],[\"进程与线程概念\",{\"0\":{\"138\":1}}],[\"进行查询\",{\"1\":{\"825\":1}}],[\"进行整体测试时\",{\"1\":{\"789\":1}}],[\"进行对2取余操作\",{\"1\":{\"780\":1}}],[\"进行划分\",{\"1\":{\"753\":1}}],[\"进行自动继承\",{\"1\":{\"747\":1}}],[\"进行回滚操作\",{\"1\":{\"682\":1}}],[\"进行处理\",{\"1\":{\"628\":1}}],[\"进行结尾\",{\"1\":{\"561\":1}}],[\"进行优化\",{\"1\":{\"522\":1}}],[\"进行训练\",{\"1\":{\"516\":1}}],[\"进行赋值\",{\"1\":{\"516\":1}}],[\"进行固定求解\",{\"1\":{\"516\":1}}],[\"进行生成数据\",{\"1\":{\"499\":1}}],[\"进行更新即可\",{\"1\":{\"489\":1}}],[\"进行的采样\",{\"1\":{\"458\":1}}],[\"进行估计\",{\"1\":{\"452\":1,\"468\":1}}],[\"进行了无穷多步来进行了真实的求解\",{\"1\":{\"445\":1}}],[\"进行迭代\",{\"1\":{\"444\":1,\"475\":1}}],[\"进行求解\",{\"1\":{\"421\":1,\"440\":1,\"477\":1}}],[\"进行限制的话\",{\"1\":{\"321\":1}}],[\"进行缩减\",{\"1\":{\"289\":1}}],[\"进行类型比较又会导致额外的开销和增加代码量\",{\"1\":{\"280\":1}}],[\"进行异常捕获\",{\"1\":{\"267\":1}}],[\"进行捕获\",{\"1\":{\"267\":1}}],[\"进行拼接操作\",{\"1\":{\"245\":1}}],[\"进行加密\",{\"1\":{\"199\":1}}],[\"进行数据转换就会很麻烦\",{\"1\":{\"126\":1}}],[\"进行判断\",{\"1\":{\"84\":1}}],[\"进行判断来删除元素\",{\"1\":{\"84\":1}}],[\"进行判断的\",{\"1\":{\"84\":1}}],[\"进行分割\",{\"1\":{\"71\":1}}],[\"进行倒序排列\",{\"1\":{\"71\":1}}],[\"使其符合我们指定构造方法的定义\",{\"1\":{\"658\":1}}],[\"使得用户能够随意登陆别人的账号\",{\"1\":{\"621\":1}}],[\"使得v^\",{\"1\":{\"506\":1}}],[\"使得java能够更好的体现面向对象的思想\",{\"1\":{\"226\":1}}],[\"使得持有当前对象锁的线程进入等待状态\",{\"1\":{\"215\":1}}],[\"使得整个过程被模糊了\",{\"1\":{\"192\":1}}],[\"使得线程处于等待状态一段时间\",{\"1\":{\"143\":1}}],[\"使得某些属性不参与序列化\",{\"1\":{\"133\":1}}],[\"使用xhr请求数据\",{\"0\":{\"893\":1}}],[\"使用此类库可以快速完成io操作\",{\"1\":{\"891\":1}}],[\"使用此注解来表示此测试是一个参数化测试\",{\"1\":{\"808\":1}}],[\"使用post请求完成登陆\",{\"0\":{\"886\":1}}],[\"使用put方法添加键值对\",{\"1\":{\"57\":1}}],[\"使用beforeeach不能为static方法\",{\"1\":{\"802\":1}}],[\"使用beforeall必须为static方法\",{\"1\":{\"802\":1}}],[\"使用方式很简单\",{\"1\":{\"776\":1}}],[\"使用方法同输入流一样\",{\"1\":{\"92\":1}}],[\"使用load方法读取本地文件中的所有配置到map中\",{\"1\":{\"754\":1}}],[\"使用lombok之后\",{\"1\":{\"627\":1}}],[\"使用lombok\",{\"0\":{\"629\":1},\"1\":{\"344\":1}}],[\"使用lombok提供的注解\",{\"1\":{\"311\":1}}],[\"使用起来和hashmap是差不多的\",{\"1\":{\"754\":1}}],[\"使用起来非常简单\",{\"1\":{\"725\":1}}],[\"使用起来也是非常方便\",{\"1\":{\"344\":1}}],[\"使用注解开发\",{\"0\":{\"710\":1}}],[\"使用注解的时候可以不用传入属性值\",{\"1\":{\"207\":1}}],[\"使用foreach来完成它就很简单了\",{\"1\":{\"693\":1}}],[\"使用for循环来一个一个执行insert语句\",{\"1\":{\"688\":1}}],[\"使用循环操作执行数据库相关操作实际上非常耗费资源\",{\"1\":{\"688\":1}}],[\"使用嵌套的结果映射来处理连接结果的重复子集\",{\"1\":{\"666\":1}}],[\"使用map类型变量进行接受\",{\"1\":{\"650\":1}}],[\"使用main类的成员方法\",{\"1\":{\"295\":1}}],[\"使用哪个账号进行登陆了\",{\"1\":{\"641\":1}}],[\"使用原生方式和小辣椒方式编写类的区别\",{\"1\":{\"627\":1}}],[\"使用原始类型接收一个integer类型的arraylist\",{\"1\":{\"80\":1}}],[\"使用这种方式\",{\"1\":{\"622\":1}}],[\"使用反射的好处是\",{\"1\":{\"616\":1}}],[\"使用java读取xml内容不要求掌握\",{\"1\":{\"636\":1}}],[\"使用jdbc连接数据库\",{\"0\":{\"605\":1}}],[\"使用jconsole也可以进行监测\",{\"1\":{\"156\":1}}],[\"使用浏览器访问socket服务器\",{\"0\":{\"544\":1}}],[\"使用空的构造函数加setter函数赋值\",{\"1\":{\"366\":1}}],[\"使用全量的构造函数\",{\"1\":{\"366\":1}}],[\"使用新增的ofnullable方法\",{\"1\":{\"320\":1}}],[\"使用uses指定\",{\"1\":{\"310\":1}}],[\"使用transitive来向其他模块传递此依赖\",{\"1\":{\"308\":1}}],[\"使用throws关键字告知调用方此方法会抛出哪些异常\",{\"1\":{\"266\":1}}],[\"使用throw关键字来抛出异常\",{\"1\":{\"266\":1}}],[\"使用exports将com\",{\"1\":{\"308\":2}}],[\"使用equals判断\",{\"1\":{\"71\":1}}],[\"使用钻石运算符可以省略其中的类型\",{\"1\":{\"281\":1}}],[\"使用object类型作为引用\",{\"1\":{\"280\":1}}],[\"使用泛型的原因\",{\"0\":{\"280\":1}}],[\"使用运行时异常同样可以捕获到\",{\"1\":{\"267\":1}}],[\"使用new表示\",{\"1\":{\"258\":1}}],[\"使用newline进行换行\",{\"1\":{\"113\":1}}],[\"使用双冒号来进行方法引用\",{\"1\":{\"258\":1}}],[\"使用外部静态变量\",{\"1\":{\"254\":1}}],[\"使用频率很低\",{\"1\":{\"253\":1}}],[\"使用频率极高\",{\"1\":{\"21\":1}}],[\"使用servlet\",{\"1\":{\"870\":1}}],[\"使用system\",{\"1\":{\"795\":1}}],[\"使用synchronized关键字创建同步代码块\",{\"1\":{\"155\":1}}],[\"使用socket进行数据传输\",{\"0\":{\"537\":1}}],[\"使用stream\",{\"1\":{\"356\":1}}],[\"使用split方法进行字符串分割\",{\"1\":{\"244\":1}}],[\"使用就像对象的参数一样\",{\"1\":{\"221\":1}}],[\"使用枚举类也非常方便\",{\"1\":{\"221\":1}}],[\"使用desc表示降序排序\",{\"1\":{\"581\":1}}],[\"使用default关键字为接口中的方法添加默认实现\",{\"1\":{\"219\":1}}],[\"使用datainputstream可以读取\",{\"1\":{\"129\":1}}],[\"使用implements关键字来实现接口\",{\"1\":{\"219\":1}}],[\"使用import关键字导入其他包中的类\",{\"1\":{\"120\":1}}],[\"使用interface表示这是一个接口\",{\"1\":{\"219\":1}}],[\"使用value则无需填入\",{\"1\":{\"207\":1}}],[\"使用getdeclaredconstructor\",{\"1\":{\"191\":1}}],[\"使用get方法根据键获取对应的值\",{\"1\":{\"57\":1}}],[\"使用class类静态方法forname\",{\"1\":{\"182\":1}}],[\"使用class关键字\",{\"1\":{\"182\":1}}],[\"使用copyof快速将内容拷贝到扩容后的新数组中并设定为新的elementdata底层数组\",{\"1\":{\"25\":1}}],[\"使用多线程进行并行排序\",{\"1\":{\"173\":1}}],[\"使用\",{\"0\":{\"289\":1,\"622\":1,\"776\":1},\"1\":{\"155\":1,\"267\":1,\"291\":1,\"340\":1,\"353\":1,\"354\":1,\"368\":1,\"629\":5,\"718\":1,\"720\":1,\"796\":1}}],[\"使用的是系统提供的输入流\",{\"1\":{\"128\":1}}],[\"使用长度为10的byte\",{\"1\":{\"94\":1}}],[\"使用asserttrue方法\",{\"1\":{\"787\":1}}],[\"使用asc表示升序排序\",{\"1\":{\"581\":1}}],[\"使用arg标签来代表每一个参数\",{\"1\":{\"658\":1}}],[\"使用available方法能查看当前可读的剩余字节数量\",{\"1\":{\"91\":1}}],[\"使用add添加元素\",{\"1\":{\"25\":1}}],[\"使用resulthandler来处理结果\",{\"1\":{\"653\":1}}],[\"使用resulttype属性来指定\",{\"1\":{\"648\":1}}],[\"使用read可以直接读取一个字节的数据\",{\"1\":{\"91\":1}}],[\"使用reduce方法\",{\"1\":{\"71\":1}}],[\"使用一种类似用\",{\"1\":{\"71\":1}}],[\"使用即可\",{\"1\":{\"50\":1}}],[\"使用示例\",{\"0\":{\"34\":1}}],[\"使用匿名内部类\",{\"1\":{\"25\":1}}],[\"使用接口的引用来操作具体的集合类实现\",{\"1\":{\"25\":1}}],[\"使用时\",{\"1\":{\"15\":1}}],[\"秘制小汉堡\",{\"1\":{\"128\":1}}],[\"❌\",{\"1\":{\"121\":6,\"371\":3}}],[\"✅\",{\"1\":{\"121\":10,\"371\":4}}],[\"公共\",{\"1\":{\"121\":1}}],[\"受保护\",{\"1\":{\"121\":1}}],[\"受限制的始终是底层哈希表的长度\",{\"1\":{\"60\":1}}],[\"私有\",{\"1\":{\"121\":1}}],[\"之间存在什么关系\",{\"1\":{\"442\":1}}],[\"之外的任何单个字符\",{\"1\":{\"246\":1}}],[\"之外\",{\"1\":{\"236\":1}}],[\"之前通过info方法直接输出的结果就是使用的默认级别的日志\",{\"1\":{\"727\":1}}],[\"之前通过创建一个映射器来将结果快速转换为实体类\",{\"1\":{\"659\":1}}],[\"之前我们需要像这样编写\",{\"1\":{\"712\":1}}],[\"之前我们定义变量必须指定类型\",{\"1\":{\"328\":1}}],[\"之前被删除的数据回来了\",{\"1\":{\"682\":1}}],[\"之前的操作也就不会生效\",{\"1\":{\"623\":1}}],[\"之前的写法是\",{\"1\":{\"338\":1}}],[\"之前介绍的方法都是\",{\"1\":{\"521\":1}}],[\"之前执行\",{\"1\":{\"156\":1}}],[\"之前使用的scanner\",{\"1\":{\"128\":1}}],[\"之前就是直接使用的\",{\"1\":{\"120\":1}}],[\"之后的语句需要等处理完\",{\"1\":{\"920\":1}}],[\"之后网页收到服务器的响应请求后就会存储对应\",{\"1\":{\"908\":1}}],[\"之后会讲解文件传输\",{\"1\":{\"875\":1}}],[\"之后idea会自动帮助我们创建maven项目\",{\"1\":{\"865\":1}}],[\"之后就是http\",{\"1\":{\"859\":1}}],[\"之后进行迭代\",{\"1\":{\"444\":1}}],[\"之后\",{\"1\":{\"50\":1,\"108\":2}}],[\"随便什么的路径名称\",{\"1\":{\"878\":1}}],[\"随着我们项目的开发和改进\",{\"1\":{\"820\":1}}],[\"随着我们的程序不断变大\",{\"1\":{\"120\":1}}],[\"随着无人机与用户之间距离和发射功率的变化\",{\"1\":{\"383\":1}}],[\"随机变量\",{\"1\":{\"479\":1}}],[\"随机梯度下降\",{\"1\":{\"475\":1}}],[\"随机近似理论与随机梯度下降算法\",{\"0\":{\"466\":1}}],[\"随机数生成\",{\"1\":{\"274\":1}}],[\"随机int型数字\",{\"1\":{\"71\":1}}],[\"随时都认为有其他线程在对数据进行修改\",{\"1\":{\"155\":1}}],[\"包含\",{\"1\":{\"913\":1}}],[\"包含类名和方法名称连接之后的名称\",{\"1\":{\"779\":1}}],[\"包含会抛出\",{\"1\":{\"371\":1}}],[\"包下所有的接口都将直接作为mapper配置接口\",{\"1\":{\"711\":1}}],[\"包组成\",{\"1\":{\"303\":1}}],[\"包装类支持字符串直接转换\",{\"1\":{\"228\":1}}],[\"包装类的方法\",{\"0\":{\"228\":1}}],[\"包装类实际上就是将我们的基本数据类型\",{\"1\":{\"227\":1}}],[\"包装类型支持自动装箱\",{\"1\":{\"227\":1}}],[\"包装类型的自动装箱和拆箱机制\",{\"1\":{\"227\":1}}],[\"包装类型都有一个type\",{\"1\":{\"183\":1}}],[\"包延时任务\",{\"1\":{\"166\":1}}],[\"包其实就是用来区分类位置的东西\",{\"1\":{\"120\":1}}],[\"包的命名规则同样是英文和数字的组合\",{\"1\":{\"120\":1}}],[\"包的声明和导入\",{\"0\":{\"120\":1}}],[\"包的访问与控制\",{\"0\":{\"119\":1}}],[\"包括tomcat\",{\"1\":{\"870\":1}}],[\"包括testsqlbuilder中编写的方法也需要添加\",{\"1\":{\"719\":1}}],[\"包括html文件\",{\"1\":{\"864\":1}}],[\"包括已经在运行的web应用程序\",{\"1\":{\"864\":1}}],[\"包括启动和关闭服务器的脚本\",{\"1\":{\"864\":1}}],[\"包括版本号等\",{\"1\":{\"850\":1}}],[\"包括代码的编译\",{\"1\":{\"817\":1}}],[\"包括系统的架构\",{\"1\":{\"795\":1}}],[\"包括一些sql语句参数的使用也是和之前完全一样\",{\"1\":{\"713\":1}}],[\"包括url\",{\"1\":{\"641\":1}}],[\"包括后面的spring等众多框架都会用到xml来作为框架的配置文件\",{\"1\":{\"636\":1}}],[\"包括读未提交\",{\"1\":{\"599\":1}}],[\"包括=\",{\"1\":{\"580\":1}}],[\"包括但不限于\",{\"1\":{\"549\":1}}],[\"包括我们自己也是没办法实现继承的\",{\"1\":{\"346\":1}}],[\"包括双引号等\",{\"1\":{\"341\":1}}],[\"包括jdk官方库\",{\"1\":{\"303\":1}}],[\"包括接口\",{\"1\":{\"282\":1}}],[\"包括课程名称\",{\"1\":{\"280\":1}}],[\"包括返回值\",{\"1\":{\"257\":1,\"290\":1}}],[\"包括对方法的调用和super关键字的使用\",{\"1\":{\"251\":1}}],[\"包括对象内部的所有成员变量\",{\"1\":{\"220\":1}}],[\"包括对象的各个属性\",{\"1\":{\"215\":1}}],[\"包括换行\",{\"1\":{\"246\":1}}],[\"包括引用类型和基本类型\",{\"1\":{\"234\":1}}],[\"包括三种策略\",{\"1\":{\"206\":1}}],[\"包括方法上\",{\"1\":{\"203\":1}}],[\"包括方法的形式参数列表\",{\"1\":{\"192\":1}}],[\"包括void\",{\"1\":{\"183\":1}}],[\"包括类里面有哪些方法\",{\"1\":{\"180\":1}}],[\"包括类里面有哪些字段\",{\"1\":{\"179\":1}}],[\"包括文本\",{\"1\":{\"88\":1}}],[\"包括\",{\"1\":{\"66\":1,\"561\":1,\"582\":1,\"768\":1}}],[\"包括列表\",{\"1\":{\"21\":1}}],[\"包括数组复制方法\",{\"1\":{\"14\":1}}],[\"优秀\",{\"1\":{\"280\":1,\"281\":2,\"338\":2,\"339\":1,\"340\":2}}],[\"优化方法\",{\"0\":{\"516\":1}}],[\"优化算法\",{\"0\":{\"510\":1}}],[\"优化目标函数的算法\",{\"1\":{\"506\":1}}],[\"优化问题\",{\"1\":{\"477\":1}}],[\"优化问题建立\",{\"0\":{\"385\":1}}],[\"优化\",{\"1\":{\"118\":1}}],[\"优先使用cpu资源\",{\"1\":{\"145\":1}}],[\"优先使用作用域最接近的\",{\"1\":{\"7\":1}}],[\"优先级越高的线程\",{\"1\":{\"145\":2}}],[\"优先级队列只能保证出队顺序是按照优先级进行的\",{\"1\":{\"46\":1}}],[\"优先级队列并不是队列中所有的元素都是按照优先级排放的\",{\"1\":{\"46\":1}}],[\"优先级队列可以根据每一个元素的优先级\",{\"1\":{\"46\":1}}],[\"优先级队列\",{\"0\":{\"46\":1},\"1\":{\"45\":1}}],[\"关于使用配置文件的形式修改jul部分内容的默认值就先讲解到这里\",{\"1\":{\"756\":1}}],[\"关于对象类型的变量\",{\"1\":{\"4\":1}}],[\"关联查询\",{\"0\":{\"718\":1}}],[\"关闭浏览器即失效\",{\"1\":{\"909\":1}}],[\"关闭自动提交\",{\"1\":{\"623\":4}}],[\"关闭自动提交后相当于开启事务\",{\"1\":{\"623\":1}}],[\"关闭输入方向的流\",{\"1\":{\"538\":1}}],[\"关闭输出方向的流\",{\"1\":{\"538\":1}}],[\"关键元素\",{\"1\":{\"394\":1}}],[\"关键\",{\"1\":{\"374\":1}}],[\"关键字推荐使用大写\",{\"1\":{\"561\":1}}],[\"关键字\",{\"0\":{\"133\":1},\"1\":{\"216\":1,\"235\":1}}],[\"关键字来声明一个变量或一个方法为静态的\",{\"1\":{\"117\":1}}],[\"则清理浏览器中的cookie\",{\"1\":{\"910\":1}}],[\"则所有以\",{\"1\":{\"909\":1}}],[\"则本域名下contextpath都可以访问该cookie\",{\"1\":{\"909\":1}}],[\"则只有contextpath为\",{\"1\":{\"909\":1}}],[\"则只是进行一次带入求解\",{\"1\":{\"444\":1}}],[\"则该cookie在maxage秒后失效\",{\"1\":{\"909\":1}}],[\"则需要使用base64编码\",{\"1\":{\"909\":1}}],[\"则默认采用该依赖有效范围\",{\"1\":{\"833\":1}}],[\"则默认值不会生效\",{\"1\":{\"564\":1}}],[\"则会变成事务操作\",{\"1\":{\"647\":1}}],[\"则会使用默认值\",{\"1\":{\"564\":1}}],[\"则不允许对此视图执行insert和update操作\",{\"1\":{\"596\":1}}],[\"则此视图不允许更新\",{\"1\":{\"596\":5}}],[\"则用空格填充\",{\"1\":{\"563\":1}}],[\"则用户的关联动作数为2n∑n=1n​∣kn​∣\",{\"1\":{\"388\":1}}],[\"则是对多个\",{\"1\":{\"415\":1}}],[\"则是让处于\",{\"1\":{\"161\":1}}],[\"则总动作空间的大小为7+2n∑n=1n​∣kn​∣会导致动作空间过大\",{\"1\":{\"388\":1}}],[\"则无人机将获得正奖励\",{\"1\":{\"387\":1}}],[\"则无需再去请求外部设备\",{\"1\":{\"103\":1}}],[\"则构造函数冗长\",{\"1\":{\"366\":1}}],[\"则返回\",{\"1\":{\"363\":2}}],[\"则等价于\",{\"1\":{\"246\":1}}],[\"则表示只能赋一次值\",{\"1\":{\"217\":1}}],[\"则表示永久等待\",{\"1\":{\"161\":1}}],[\"则主动唤醒自己\",{\"1\":{\"161\":1}}],[\"则可以先让出一部分资源\",{\"1\":{\"145\":1}}],[\"则必须实现serializable接口才能被序列化\",{\"1\":{\"131\":1}}],[\"则之后的内容不会被保留\",{\"1\":{\"108\":1}}],[\"主机可以是一个域名\",{\"1\":{\"859\":1}}],[\"主机接收了就没了\",{\"1\":{\"108\":1}}],[\"主键可以使用idarg来表示\",{\"1\":{\"658\":1}}],[\"主键约束保证表中的每一行数据都有唯一的标识符\",{\"1\":{\"565\":1}}],[\"主键列的值用来唯一标识每一行数据\",{\"1\":{\"564\":1}}],[\"主键\",{\"1\":{\"564\":1,\"565\":2}}],[\"主线程停止1秒\",{\"1\":{\"154\":1,\"155\":2}}],[\"主动让出cpu资源\",{\"0\":{\"147\":1}}],[\"主方法的string参数是java\",{\"1\":{\"120\":1}}],[\"主要是可以设定编码格式\",{\"1\":{\"634\":1}}],[\"主要掌握几种流之间的操作\",{\"1\":{\"543\":1}}],[\"主要框架\",{\"1\":{\"392\":1}}],[\"主要内容\",{\"0\":{\"380\":1,\"603\":1}}],[\"主要贡献\",{\"0\":{\"379\":1}}],[\"主要动机\",{\"0\":{\"378\":1}}],[\"主要就两个方法\",{\"1\":{\"352\":1}}],[\"主要区别\",{\"1\":{\"88\":1}}],[\"主要类\",{\"1\":{\"88\":2}}],[\"主要方法\",{\"1\":{\"32\":1}}],[\"暂时不需要了解\",{\"1\":{\"107\":1}}],[\"暂时不做讲解\",{\"1\":{\"36\":1}}],[\"装饰着模式\",{\"0\":{\"107\":1}}],[\"提示需要用户名和密码\",{\"1\":{\"864\":1}}],[\"提交事务\",{\"1\":{\"599\":1,\"623\":2}}],[\"提高性能\",{\"1\":{\"653\":1}}],[\"提高泛化能力\",{\"1\":{\"505\":1}}],[\"提高安全性\",{\"0\":{\"305\":1}}],[\"提升采样的效率\",{\"1\":{\"399\":1}}],[\"提升clone方法的访问权限\",{\"1\":{\"220\":1}}],[\"提出解决总用户mos最大化问题的三步骤\",{\"1\":{\"379\":1}}],[\"提出了一个理想的由qoe驱动的多无人机协助通信框架\",{\"1\":{\"379\":1}}],[\"提前将部分内容存入内存\",{\"1\":{\"103\":1}}],[\"提供一个booleansupplier对象\",{\"1\":{\"789\":1}}],[\"提供了一种特殊的语法\",{\"1\":{\"255\":1}}],[\"提供了一个支持\",{\"1\":{\"35\":1}}],[\"提供的方法进行计算\",{\"1\":{\"229\":1}}],[\"提供的迭代器生成方法\",{\"1\":{\"36\":1}}],[\"很多项目往往都会采用这种多模块子项目的形式的去编写\",{\"1\":{\"849\":1}}],[\"很多javaweb项目可能还会用到webapp目录\",{\"1\":{\"818\":1}}],[\"很多的类仅仅只是充当一个实体类罢了\",{\"1\":{\"344\":1}}],[\"很有可能出现改了代码导致之前的功能出现问题\",{\"1\":{\"773\":1}}],[\"很有可能造成程序反应迟钝\",{\"1\":{\"103\":1}}],[\"很明显是自动生成的\",{\"1\":{\"289\":1}}],[\"很容易出现以下的情况\",{\"1\":{\"280\":1}}],[\"很遗憾\",{\"1\":{\"236\":1}}],[\"很简单\",{\"1\":{\"25\":1}}],[\"虽然手机爆炸的概率很小\",{\"1\":{\"727\":1}}],[\"虽然mybatis为我们提供了之前xml配置中各种操作的对应注解\",{\"1\":{\"714\":1}}],[\"虽然缓存机制给我们提供了很大的性能提升\",{\"1\":{\"705\":1}}],[\"虽然这里是第一个定义的\",{\"1\":{\"804\":1}}],[\"虽然这样可以实现和之前差不多的效果\",{\"1\":{\"719\":1}}],[\"虽然这样看似非常完美\",{\"1\":{\"688\":1}}],[\"虽然这两种列表的实现不同\",{\"1\":{\"33\":1}}],[\"虽然日志中已经提示生效1行\",{\"1\":{\"682\":1}}],[\"虽然没有干什么事情\",{\"1\":{\"641\":1}}],[\"虽然我们能够通过jdbc来连接和操作数据库\",{\"1\":{\"633\":1}}],[\"虽然我们目前还没有学习数组\",{\"1\":{\"227\":1}}],[\"虽然添加索引后会使得查询效率更高\",{\"1\":{\"597\":1}}],[\"虽然此用户能够成功登录\",{\"1\":{\"590\":1}}],[\"虽然放在类上和放在构造函数上这两种模式是最常见的用例\",{\"1\":{\"368\":1}}],[\"虽然空指针异常告诉我们问题出现在这一行\",{\"1\":{\"343\":1}}],[\"虽然并不是一开始的类型\",{\"1\":{\"280\":1}}],[\"虽然是继承于\",{\"1\":{\"236\":1}}],[\"虽然a和b的值相同\",{\"1\":{\"227\":1}}],[\"虽然java语言是一个面向对象的语言\",{\"1\":{\"226\":1}}],[\"虽然拥有了创世主的能力\",{\"1\":{\"193\":1}}],[\"虽然任务执行完成了\",{\"1\":{\"167\":1}}],[\"虽然stop\",{\"1\":{\"142\":1}}],[\"虽然能得到对象\",{\"1\":{\"133\":1}}],[\"虽然给定的是fileinputstream\",{\"1\":{\"126\":1}}],[\"虽然给定的是fileoutputstream\",{\"1\":{\"126\":1}}],[\"虽然普通的文件流读取文件数据非常便捷\",{\"1\":{\"103\":1}}],[\"刷新\",{\"1\":{\"97\":1}}],[\"牛\",{\"1\":{\"97\":2}}],[\"支持以下类型\",{\"1\":{\"808\":1}}],[\"支持实现接口\",{\"1\":{\"344\":1}}],[\"支持c语言样式\",{\"1\":{\"235\":1}}],[\"支持载入外部class文件\",{\"1\":{\"199\":1}}],[\"支持参数\",{\"1\":{\"161\":1}}],[\"支持\",{\"1\":{\"108\":1,\"371\":1}}],[\"支持获取编码\",{\"1\":{\"97\":1}}],[\"支持泛型的数组转换\",{\"1\":{\"23\":1}}],[\"追加操作\",{\"0\":{\"93\":1}}],[\"操作来向服务器传输数据\",{\"1\":{\"886\":1}}],[\"操作结束\",{\"0\":{\"704\":1}}],[\"操作是同样的\",{\"1\":{\"671\":1}}],[\"操作流\",{\"0\":{\"360\":1}}],[\"操作出现在suspend\",{\"1\":{\"156\":1}}],[\"操作的都是同一个目标\",{\"1\":{\"117\":1}}],[\"操作和原来的流是一样的\",{\"1\":{\"105\":1}}],[\"操作\",{\"0\":{\"358\":1,\"677\":1},\"1\":{\"92\":1,\"108\":1,\"112\":1}}],[\"操作而是write\",{\"1\":{\"92\":1}}],[\"操作就是相同的\",{\"1\":{\"84\":1}}],[\"输入mvn\",{\"1\":{\"853\":1}}],[\"输入密码后即可登陆此用户\",{\"1\":{\"590\":1}}],[\"输入序列\",{\"1\":{\"471\":1}}],[\"输入的不是数字\",{\"1\":{\"374\":1}}],[\"输入help来查看命令列表\",{\"1\":{\"316\":1}}],[\"输入流会以某种方式保留之后读取的readlimit\",{\"1\":{\"108\":1}}],[\"输入流\",{\"0\":{\"90\":1,\"128\":1}}],[\"输出节点名称\",{\"1\":{\"636\":1}}],[\"输出为标量\",{\"1\":{\"475\":1}}],[\"输出为\",{\"1\":{\"254\":1}}],[\"输出流没有read\",{\"1\":{\"92\":1}}],[\"输出流也需要在最后调用close\",{\"1\":{\"92\":1}}],[\"输出流\",{\"0\":{\"92\":1}}],[\"第264页\",{\"1\":{\"859\":1}}],[\"第七版\",{\"1\":{\"859\":1}}],[\"第四个作用域\",{\"0\":{\"835\":1}}],[\"第三方框架兼容性\",{\"0\":{\"766\":1}}],[\"第三范式\",{\"0\":{\"555\":1}}],[\"第三个参数是读取流中的字节数\",{\"1\":{\"91\":1}}],[\"第二次获取的时候会进行重新查询\",{\"1\":{\"700\":1}}],[\"第二范式要求表中必须存在主键\",{\"1\":{\"554\":1}}],[\"第二范式\",{\"0\":{\"554\":1}}],[\"第二种\",{\"1\":{\"468\":1}}],[\"第二种情况是如果为null的情况\",{\"1\":{\"323\":1}}],[\"第二个是\",{\"1\":{\"354\":1}}],[\"第二个参数开启后会续写已有的日志\",{\"1\":{\"737\":1}}],[\"第二个参数值存在\",{\"1\":{\"355\":1}}],[\"第二个参数排前面\",{\"1\":{\"292\":1}}],[\"第二个参数是从给定数组的哪个位置开始放入内容\",{\"1\":{\"91\":1}}],[\"第一范式是指数据库的每一列都是不可分割的基本数据项\",{\"1\":{\"553\":1}}],[\"第一范式\",{\"0\":{\"553\":1}}],[\"第一种\",{\"1\":{\"468\":1}}],[\"第一种情况和ifpresent是一样的\",{\"1\":{\"323\":1}}],[\"第一个参数值存在\",{\"1\":{\"355\":1}}],[\"第一个参数是种子\",{\"1\":{\"321\":1}}],[\"第一个参数排前面\",{\"1\":{\"292\":1}}],[\"无需进行修改\",{\"1\":{\"820\":1}}],[\"无需再下载jar文件\",{\"1\":{\"820\":1}}],[\"无需再编写finally语句块\",{\"1\":{\"90\":1}}],[\"无需完整启动项目\",{\"1\":{\"773\":1}}],[\"无关\",{\"1\":{\"526\":1}}],[\"无记忆性\",{\"1\":{\"418\":1}}],[\"无人机需要进行移动\",{\"1\":{\"388\":1}}],[\"无人机的动态移动设计\",{\"0\":{\"388\":1}}],[\"无人机的位置初始化也是随机部署的\",{\"1\":{\"387\":1}}],[\"无人机的3d部署\",{\"0\":{\"387\":1}}],[\"无人机3d部署算法\",{\"1\":{\"387\":1}}],[\"无人机\",{\"1\":{\"387\":1}}],[\"无人机n以可变高度悬停在用户上方\",{\"1\":{\"387\":1}}],[\"无人机n的高度需满足\",{\"1\":{\"383\":1}}],[\"无人机n与用户kn​在时间t的距离表示为\",{\"1\":{\"382\":1}}],[\"无人机往往有更高的los链接概率\",{\"1\":{\"383\":1}}],[\"无参构造方法被覆盖\",{\"1\":{\"221\":1}}],[\"无形参的方法\",{\"1\":{\"207\":1}}],[\"无限循环等待客户端连接\",{\"1\":{\"536\":1}}],[\"无限循环执行\",{\"1\":{\"165\":1}}],[\"无限循环\",{\"1\":{\"144\":1}}],[\"无论什么时间\",{\"1\":{\"901\":1}}],[\"无论什么类型都可以通过我们的方法来进行实体类型映射\",{\"1\":{\"616\":1}}],[\"无论哪个会话失效\",{\"1\":{\"701\":1}}],[\"无论哪个会话对于数据的查询缓存都可以直接被所有会话使用\",{\"1\":{\"700\":1}}],[\"无论哪行进行指定操作都会执行触发器\",{\"1\":{\"598\":1}}],[\"无论哪种方法所获取到的\",{\"1\":{\"182\":1}}],[\"无论是什么级别都进行打印\",{\"1\":{\"729\":1}}],[\"无论是一级缓存还是二级缓存\",{\"1\":{\"704\":1}}],[\"无论是否登陆\",{\"1\":{\"910\":1}}],[\"无论是否处于事务模式下\",{\"1\":{\"688\":1}}],[\"无论是否出现异常\",{\"1\":{\"267\":1}}],[\"无论是\",{\"1\":{\"466\":1}}],[\"无论是基本类型还是引用类型\",{\"1\":{\"220\":1}}],[\"无论是方法\",{\"1\":{\"208\":1}}],[\"无论是静态方法还是成员方法\",{\"1\":{\"14\":1}}],[\"无论你是调用方法\",{\"1\":{\"138\":1}}],[\"无法关闭\",{\"1\":{\"700\":1}}],[\"无法查到\",{\"1\":{\"682\":1}}],[\"无法代表其原本的意思\",{\"1\":{\"653\":1}}],[\"无法继续申请内存了\",{\"1\":{\"264\":1}}],[\"无法显式定义构造函数或初始化块\",{\"1\":{\"255\":1}}],[\"无法直接定义新的属性\",{\"1\":{\"255\":1}}],[\"无法进行修改\",{\"1\":{\"243\":1}}],[\"无法表示一个非常大的数\",{\"1\":{\"229\":1}}],[\"无法使用lambda表达式简化\",{\"1\":{\"166\":1}}],[\"无法使用this关键字\",{\"1\":{\"117\":1}}],[\"无法获取成员变量的值\",{\"1\":{\"117\":1}}],[\"无法reset\",{\"1\":{\"108\":1}}],[\"路径的匹配规则和servlet一致\",{\"1\":{\"919\":1}}],[\"路径就是我们希望去访问此服务器上的某个文件\",{\"1\":{\"859\":1}}],[\"路径\",{\"1\":{\"90\":2}}],[\"减少了字节到字符的转换时间\",{\"1\":{\"88\":1}}],[\"性质\",{\"0\":{\"239\":1}}],[\"性能就大大提高了\",{\"1\":{\"358\":1}}],[\"性能\",{\"1\":{\"88\":1}}],[\"性别呢\",{\"1\":{\"9\":1}}],[\"性别\",{\"1\":{\"4\":1,\"551\":1,\"554\":1}}],[\"字段同样可以作为参数的来源\",{\"1\":{\"812\":1}}],[\"字段\",{\"0\":{\"812\":1}}],[\"字母的所有字母\",{\"1\":{\"246\":1}}],[\"字母\",{\"1\":{\"246\":1}}],[\"字符模糊匹配\",{\"1\":{\"580\":1}}],[\"字符\",{\"1\":{\"246\":2}}],[\"字符数组转字符串\",{\"1\":{\"244\":1}}],[\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组\",{\"1\":{\"244\":1}}],[\"字符串支持使用\",{\"1\":{\"245\":1}}],[\"字符串类中提供了很多方便我们操作的方法\",{\"1\":{\"244\":1}}],[\"字符串类是一个比较特殊的类\",{\"1\":{\"243\":1}}],[\"字符串的内容比较\",{\"1\":{\"244\":1}}],[\"字符串中的字符一旦确定\",{\"1\":{\"243\":1}}],[\"字符串\",{\"0\":{\"232\":1,\"243\":1}}],[\"字符串转integer有多个方法\",{\"1\":{\"228\":1}}],[\"字符串内容的比较\",{\"1\":{\"216\":1}}],[\"字符流只支持char\",{\"1\":{\"96\":1}}],[\"字符流是以一个具体的字符进行读取\",{\"1\":{\"96\":1}}],[\"字符流不同于字节\",{\"1\":{\"96\":1}}],[\"字符流在处理文本数据时通常更高效\",{\"1\":{\"88\":1}}],[\"字符流自动处理字符编码转换\",{\"1\":{\"88\":1}}],[\"字符流仅适用于文本数据\",{\"1\":{\"88\":1}}],[\"字符流以字符为单位\",{\"1\":{\"88\":1}}],[\"字符流\",{\"1\":{\"88\":1}}],[\"字节流不处理字符编码\",{\"1\":{\"88\":1}}],[\"字节流适用于所有类型的数据\",{\"1\":{\"88\":1}}],[\"字节流以字节为单位\",{\"1\":{\"88\":1}}],[\"字节流\",{\"1\":{\"88\":1}}],[\"编写好后\",{\"1\":{\"643\":1}}],[\"编写mybatis的配置文件\",{\"1\":{\"641\":1}}],[\"编写适用于自己数据库的实现类\",{\"1\":{\"604\":1}}],[\"编译完成后\",{\"1\":{\"833\":1}}],[\"编译阶段处理\",{\"1\":{\"628\":1}}],[\"编译时异常的子类有很多很多\",{\"1\":{\"265\":1}}],[\"编译时异常只需要继承\",{\"1\":{\"265\":1}}],[\"编译时异常明确指出可能会出现的异常\",{\"1\":{\"264\":1}}],[\"编译时异常\",{\"1\":{\"264\":1}}],[\"编译器是很聪明的\",{\"1\":{\"245\":1}}],[\"编译器不知道到底我们想用的是哪一个string类\",{\"1\":{\"120\":1}}],[\"编译后\",{\"1\":{\"199\":1,\"368\":1}}],[\"编译出来就自带\",{\"1\":{\"9\":1}}],[\"编码处理\",{\"1\":{\"88\":3}}],[\"音频\",{\"1\":{\"88\":1}}],[\"图片等\",{\"1\":{\"818\":1}}],[\"图片\",{\"1\":{\"88\":1}}],[\"适用于windows\",{\"1\":{\"549\":1}}],[\"适用于中小型\",{\"1\":{\"549\":1}}],[\"适用于处理文本文件\",{\"1\":{\"88\":1}}],[\"适用于处理所有类型的数据\",{\"1\":{\"88\":1}}],[\"适用范围\",{\"1\":{\"88\":1}}],[\"适用场景\",{\"1\":{\"88\":2}}],[\"为网站中上传的内容\",{\"1\":{\"892\":1}}],[\"为例\",{\"1\":{\"876\":1}}],[\"为一个函数方程\",{\"1\":{\"470\":1}}],[\"为状态\",{\"1\":{\"461\":1}}],[\"为什么不去求\",{\"1\":{\"453\":1}}],[\"为什么考虑\",{\"1\":{\"449\":1}}],[\"为什么这个迭代算法最终可以找到最优策略\",{\"1\":{\"442\":1}}],[\"为什么会找不到此方法呢\",{\"1\":{\"198\":1}}],[\"为discounted\",{\"1\":{\"413\":1}}],[\"为t时刻的mos评分\",{\"1\":{\"384\":1}}],[\"为指标\",{\"1\":{\"379\":1}}],[\"为\",{\"1\":{\"362\":1,\"383\":1,\"416\":2,\"420\":1,\"452\":1,\"522\":1}}],[\"为子线程的\",{\"1\":{\"163\":1}}],[\"为单位进行读写操作\",{\"1\":{\"88\":2}}],[\"为了更加快速地编写io代码\",{\"1\":{\"891\":1}}],[\"为了保证完整性\",{\"1\":{\"841\":1}}],[\"为了保证所有用户都能连接到网络\",{\"1\":{\"383\":1}}],[\"为了能够支持中文\",{\"1\":{\"566\":1}}],[\"为了让右边取到最大值的情况\",{\"1\":{\"431\":1}}],[\"为了进行\",{\"1\":{\"421\":1}}],[\"为了应对具有无限步的trajectory的return=∞的情况\",{\"1\":{\"393\":1}}],[\"为了满足不同用户传输速率要求\",{\"1\":{\"383\":1}}],[\"为了在los信道概率和路径损耗之间取得平衡\",{\"1\":{\"383\":1}}],[\"为了在创建匿名对象时进行属性初始化\",{\"1\":{\"255\":1}}],[\"为了方便\",{\"1\":{\"354\":1}}],[\"为了提高性能\",{\"1\":{\"305\":1}}],[\"为了解决以上问题\",{\"1\":{\"280\":1}}],[\"为了统计学生成绩\",{\"1\":{\"280\":1}}],[\"为了优化效率\",{\"1\":{\"244\":1}}],[\"为了避免上面的这个现象\",{\"1\":{\"155\":1}}],[\"为了使得线程资源分配更加合理\",{\"1\":{\"145\":1}}],[\"为了防止意外将之前的键值对覆盖掉\",{\"1\":{\"57\":1}}],[\"为了简便\",{\"1\":{\"34\":1}}],[\"为了兼容之前的java版本\",{\"1\":{\"16\":1}}],[\"为了支持小数加法\",{\"1\":{\"8\":1}}],[\"位于此目录下的内容不会在最后被打包到项目中\",{\"1\":{\"834\":1}}],[\"位于java\",{\"1\":{\"725\":1}}],[\"位\",{\"1\":{\"88\":2}}],[\"值是一个随机的排列组合\",{\"1\":{\"912\":1}}],[\"值判断\",{\"0\":{\"786\":1}}],[\"值为int的最大值\",{\"1\":{\"729\":1}}],[\"值为1000\",{\"1\":{\"727\":1}}],[\"值为0\",{\"1\":{\"58\":1}}],[\"值3\",{\"1\":{\"571\":1}}],[\"值2\",{\"1\":{\"571\":5}}],[\"值1\",{\"1\":{\"571\":5}}],[\"值函数近似\",{\"0\":{\"504\":1}}],[\"值迭代和策略迭代\",{\"0\":{\"435\":1}}],[\"值的估计通过一个网络来进行描述\",{\"1\":{\"397\":1}}],[\"值\",{\"1\":{\"387\":1}}],[\"值需要存在\",{\"1\":{\"355\":1}}],[\"值还是可以修改\",{\"1\":{\"239\":1}}],[\"值也相同\",{\"1\":{\"84\":1}}],[\"以上方式存在一定的问题\",{\"1\":{\"854\":1}}],[\"以上的方法虽然很好地解决了多种类型存储问题\",{\"1\":{\"280\":1}}],[\"以供其他项目作为依赖引入\",{\"1\":{\"853\":1}}],[\"以供其他项目导入作为依赖使用\",{\"1\":{\"851\":1}}],[\"以致于如此便捷的导入依赖\",{\"1\":{\"826\":1}}],[\"以灵活地应对需要解决的问题\",{\"1\":{\"633\":1}}],[\"以下日志级别依次降低\",{\"1\":{\"727\":1}}],[\"以下数据类型用于存储时间\",{\"1\":{\"563\":1}}],[\"以下数据类型用于存储数字\",{\"1\":{\"563\":1}}],[\"以下的数据类型用于字符串存储\",{\"1\":{\"563\":1}}],[\"以insert\",{\"1\":{\"561\":1}}],[\"以向用户提供可靠的服务\",{\"1\":{\"383\":1}}],[\"以\",{\"1\":{\"379\":1,\"876\":1}}],[\"以内的int值都是自动包装好\",{\"1\":{\"374\":1}}],[\"以毫秒为单位\",{\"1\":{\"142\":1}}],[\"以某种格式保存对象\",{\"1\":{\"130\":1}}],[\"以操作writer的样子写入outputstream\",{\"1\":{\"126\":1}}],[\"以字母数字排序\",{\"1\":{\"804\":1}}],[\"以字符\",{\"1\":{\"88\":1}}],[\"以字节\",{\"1\":{\"88\":1}}],[\"以及conf目录\",{\"1\":{\"864\":1}}],[\"以及各种配置的集合\",{\"1\":{\"819\":1}}],[\"以及如何使用xml来作为mybatis的配置文件\",{\"1\":{\"636\":1}}],[\"以及标签内部的文本\",{\"1\":{\"636\":1}}],[\"以及是否可以到最后优化的成果\",{\"1\":{\"475\":1}}],[\"以及模块内的包名也得是唯一的\",{\"1\":{\"304\":1}}],[\"以及object的方法\",{\"1\":{\"219\":1}}],[\"以及notifyall\",{\"1\":{\"161\":1}}],[\"以及\",{\"1\":{\"84\":1,\"246\":2,\"443\":1,\"462\":1,\"529\":1,\"876\":1,\"888\":1}}],[\"以set形式返回\",{\"1\":{\"56\":1}}],[\"判断用户是否登陆成功\",{\"1\":{\"889\":1}}],[\"判断表单是否完整\",{\"1\":{\"889\":1}}],[\"判断结果是否相等\",{\"1\":{\"786\":1}}],[\"判断测试是否成功\",{\"0\":{\"780\":1}}],[\"判断值是否存在\",{\"1\":{\"355\":1}}],[\"判断字符串是否为空或者仅包含空格\",{\"1\":{\"331\":1}}],[\"判断当前对象和给定对象是否相等\",{\"1\":{\"215\":1}}],[\"判断是否未登陆\",{\"1\":{\"921\":1}}],[\"判断是否为静态资源\",{\"1\":{\"921\":1}}],[\"判断是否为子类或是接口\",{\"1\":{\"186\":1}}],[\"判断是否存在中断标志\",{\"1\":{\"144\":1}}],[\"判断相同\",{\"1\":{\"84\":1}}],[\"判断修改成根据\",{\"1\":{\"84\":1}}],[\"判断两个值是否为同一个对象\",{\"1\":{\"788\":1}}],[\"判断两个元素是否相同\",{\"1\":{\"84\":1}}],[\"判断两个键值对是否相等\",{\"1\":{\"56\":1}}],[\"判断两个集合是否相等\",{\"1\":{\"23\":1}}],[\"等\",{\"1\":{\"660\":1}}],[\"等候时间过长\",{\"1\":{\"456\":1}}],[\"等均未知\",{\"1\":{\"449\":1}}],[\"等操作函数和代码\",{\"1\":{\"876\":1}}],[\"等操作\",{\"1\":{\"371\":1}}],[\"等于比较完就强制转换\",{\"1\":{\"342\":1}}],[\"等级\",{\"1\":{\"338\":1}}],[\"等待打包完成即可得到我们的jar文件\",{\"1\":{\"854\":1}}],[\"等待结束\",{\"1\":{\"161\":1}}],[\"等待态的线程变为\",{\"1\":{\"161\":1}}],[\"等待\",{\"1\":{\"161\":1}}],[\"等待下一次获得cpu资源\",{\"1\":{\"143\":1}}],[\"等待通知\",{\"1\":{\"142\":1}}],[\"等方法\",{\"1\":{\"84\":1,\"344\":1}}],[\"等价于\",{\"1\":{\"59\":1,\"246\":6}}],[\"快速排查导致程序运行缓慢的问题\",{\"1\":{\"773\":1}}],[\"快速地进行空格去除操作\",{\"1\":{\"331\":1}}],[\"快速生成一组0~19的int数据\",{\"1\":{\"321\":1}}],[\"快速取最小值\",{\"1\":{\"274\":1}}],[\"快速取最大值\",{\"1\":{\"274\":1}}],[\"快速获取文件夹下的文件名称列表\",{\"1\":{\"98\":1}}],[\"快速获取最大值\",{\"1\":{\"71\":1}}],[\"快速填充\",{\"0\":{\"78\":1}}],[\"汇成新的list\",{\"1\":{\"71\":1}}],[\"变参数实际上就是一个数组\",{\"1\":{\"192\":1}}],[\"变成独立的6个元素\",{\"1\":{\"71\":1}}],[\"变量默认是\",{\"1\":{\"290\":1}}],[\"变量名称为jre\",{\"1\":{\"864\":1}}],[\"变量名称\",{\"1\":{\"235\":4}}],[\"变量的值就是当前对象的存放值\",{\"1\":{\"5\":1}}],[\"变量的类型就是对应的类名\",{\"1\":{\"4\":1}}],[\"变量使用之前需要先赋值\",{\"1\":{\"4\":1}}],[\"没啥意义\",{\"1\":{\"229\":1}}],[\"没错\",{\"1\":{\"80\":1,\"258\":1,\"296\":1,\"341\":1}}],[\"没想到吧\",{\"1\":{\"71\":1}}],[\"没有明确指定依赖有效范围的话\",{\"1\":{\"833\":1}}],[\"没有更新\",{\"1\":{\"700\":1}}],[\"没有进行任何的dml操作\",{\"1\":{\"682\":1}}],[\"没有手动配置的字段会按照之前默认的方式进行赋值\",{\"1\":{\"652\":1}}],[\"没有任何关联\",{\"1\":{\"642\":1}}],[\"没有任何一处需要引用到对象的实际类型\",{\"1\":{\"192\":1}}],[\"没有commit也成功了\",{\"1\":{\"623\":1}}],[\"没有起始值\",{\"1\":{\"364\":1}}],[\"没有方法体\",{\"1\":{\"218\":1}}],[\"没有方法\",{\"1\":{\"207\":1}}],[\"没有的话就暂时处于休眠状态\",{\"1\":{\"167\":1}}],[\"没有使用哈希表\",{\"1\":{\"62\":1}}],[\"没有返回值\",{\"1\":{\"5\":1}}],[\"接着\",{\"1\":{\"910\":1}}],[\"接着修改一下前端页面\",{\"1\":{\"893\":1}}],[\"接着来看httpservlet\",{\"1\":{\"876\":1}}],[\"接着了解一下什么是http协议\",{\"1\":{\"859\":1}}],[\"接着在target目录下会出现我们打包完成的jar包\",{\"1\":{\"853\":1}}],[\"接着下面会根据参数挨个执行此测试用例\",{\"1\":{\"808\":1}}],[\"接着点击运行\",{\"1\":{\"776\":1}}],[\"接着就可以编写我们的测试用例了\",{\"1\":{\"776\":1}}],[\"接着就是xml编写了\",{\"1\":{\"672\":1}}],[\"接着就是编写sql映射\",{\"1\":{\"672\":1}}],[\"接着就是java这边进行调用了\",{\"1\":{\"649\":1}}],[\"接着才是父级\",{\"1\":{\"746\":1}}],[\"接着是实体类设计\",{\"1\":{\"672\":1}}],[\"接着是我们需要进行查询的参数\",{\"1\":{\"648\":1}}],[\"接着将mapper文件的命名空间修改为我们的接口完整名称\",{\"1\":{\"659\":1}}],[\"接着我们编写一个servlet用于处理文件下载\",{\"1\":{\"891\":1}}],[\"接着我们编写一下项目a的模块设置\",{\"1\":{\"307\":1}}],[\"接着我们就可以在项目中直接使用了\",{\"1\":{\"840\":1}}],[\"接着我们就可以在需要使用此项目作为依赖的其他项目中使用它了\",{\"1\":{\"840\":1}}],[\"接着我们就可以使用\",{\"1\":{\"719\":1}}],[\"接着我们点击右上角的maven选项\",{\"1\":{\"840\":1}}],[\"接着我们什么都不需要做\",{\"1\":{\"679\":1}}],[\"接着我们需要在程序开始之前加载这里的配置\",{\"1\":{\"756\":1}}],[\"接着我们需要在resultmap编写好对应关系\",{\"1\":{\"667\":1}}],[\"接着我们需要配置一下constructor里面的内容\",{\"1\":{\"658\":1}}],[\"接着我们需要来观察一下网站的html具体怎么写的\",{\"1\":{\"333\":1}}],[\"接着我们现在想要在项目b中使用项目a的user类\",{\"1\":{\"307\":1}}],[\"接着我们来创建一个主类\",{\"1\":{\"304\":1}}],[\"接着我们对三个属性挨个进行比较\",{\"1\":{\"216\":1}}],[\"接收到客户端数据\",{\"1\":{\"537\":1,\"544\":1}}],[\"接收端\",{\"1\":{\"384\":1}}],[\"接受一个输入参数\",{\"1\":{\"362\":1}}],[\"接受一个参数\",{\"1\":{\"297\":1}}],[\"接下来需要配置一下环境变量\",{\"1\":{\"864\":1}}],[\"接下来就是编写我们的sql语句了\",{\"1\":{\"648\":1}}],[\"接下来\",{\"1\":{\"71\":1}}],[\"接口绑定\",{\"0\":{\"659\":1}}],[\"接口声明\",{\"0\":{\"352\":1}}],[\"接口再次得到强化\",{\"1\":{\"317\":1}}],[\"接口类型\",{\"1\":{\"290\":1}}],[\"接口内部必须有且仅有一个抽象方法\",{\"1\":{\"257\":1,\"290\":1}}],[\"接口也可以通过这种匿名内部类的形式\",{\"1\":{\"255\":1}}],[\"接口同样支持向下转型\",{\"1\":{\"219\":1}}],[\"接口跟抽象类一样\",{\"1\":{\"219\":1}}],[\"接口定义\",{\"1\":{\"219\":1}}],[\"接口支持多继承\",{\"1\":{\"219\":1}}],[\"接口是可以继承\",{\"1\":{\"219\":1}}],[\"接口不同于类\",{\"1\":{\"219\":1}}],[\"接口的private方法等\",{\"1\":{\"301\":1}}],[\"接口的默认方法是保底的\",{\"1\":{\"219\":1}}],[\"接口的继承相当于是对接口功能的融合罢了\",{\"1\":{\"219\":1}}],[\"接口的使用和继承的概念有一定的出入\",{\"1\":{\"219\":1}}],[\"接口的类\",{\"1\":{\"77\":1}}],[\"接口可以实现很多个\",{\"1\":{\"219\":1}}],[\"接口里只能定义对应的抽象方法\",{\"1\":{\"219\":1}}],[\"接口包含了一些列方法的定义\",{\"1\":{\"219\":1}}],[\"接口一般只代表某些功能的抽象\",{\"1\":{\"219\":1}}],[\"接口甚至比抽象类还抽象\",{\"1\":{\"219\":1}}],[\"接口中方法的默认实现可以直接调用接口中的私有方法\",{\"1\":{\"317\":1}}],[\"接口中\",{\"1\":{\"317\":1,\"359\":1}}],[\"接口中的方法默认是\",{\"1\":{\"317\":1}}],[\"接口中的方法可以存在默认实现\",{\"1\":{\"219\":1}}],[\"接口中的private方法\",{\"0\":{\"317\":1}}],[\"接口中的定义\",{\"1\":{\"291\":1}}],[\"接口中可以存在让抽象方法的默认实现\",{\"1\":{\"219\":1}}],[\"接口中只能定义访问权限为public抽象方法\",{\"1\":{\"219\":1}}],[\"接口中如果定义了与\",{\"1\":{\"219\":1}}],[\"接口中不允许存在成员变量和成员方法\",{\"1\":{\"219\":1}}],[\"接口中并没有定义支持指定下标位置访问的添加和删除操作\",{\"1\":{\"48\":1}}],[\"接口中定义的静态方法也只能是public的\",{\"1\":{\"219\":1}}],[\"接口中定义的静态变量只能是public\",{\"1\":{\"219\":1}}],[\"接口中定义的操作\",{\"1\":{\"56\":1}}],[\"接口中定义的\",{\"1\":{\"35\":1}}],[\"接口中定义的方法都是\",{\"1\":{\"47\":1}}],[\"接口中定义的方法\",{\"1\":{\"24\":1}}],[\"接口\",{\"0\":{\"219\":1,\"921\":1},\"1\":{\"24\":1,\"219\":1,\"255\":1,\"344\":1,\"347\":2}}],[\"工作目录\",{\"1\":{\"864\":1}}],[\"工作内存中存储了该线程以读\",{\"1\":{\"154\":1}}],[\"工具来实现对结果的判断但不作为测试结果的判断依据\",{\"1\":{\"791\":1}}],[\"工具类一般都会内置大量的静态方法\",{\"1\":{\"272\":1}}],[\"工具类就是专门为一些特定场景编写的\",{\"1\":{\"272\":1}}],[\"工具类\",{\"0\":{\"74\":1,\"75\":1,\"271\":1}}],[\"工具类中\",{\"1\":{\"25\":1}}],[\"工人\",{\"1\":{\"218\":1}}],[\"工厂的机器才会按照预定的流程启动\",{\"1\":{\"71\":1}}],[\"zstd\",{\"1\":{\"908\":1,\"913\":1}}],[\"zulu\",{\"1\":{\"864\":2}}],[\"zip\",{\"1\":{\"864\":1}}],[\"zh\",{\"1\":{\"544\":2,\"641\":1,\"719\":1,\"908\":2,\"913\":2}}],[\"z0\",{\"1\":{\"246\":1}}],[\"za\",{\"1\":{\"246\":1}}],[\"zo+\",{\"1\":{\"246\":1}}],[\"zoo\",{\"1\":{\"246\":2}}],[\"zo\",{\"1\":{\"246\":2}}],[\"z\",{\"1\":{\"71\":1,\"246\":5}}],[\"去数据库里创建一个表作为测试\",{\"1\":{\"888\":1}}],[\"去配置文件中进行修改\",{\"1\":{\"864\":1}}],[\"去挂起线程的原因\",{\"1\":{\"156\":1}}],[\"去执行的\",{\"1\":{\"118\":1}}],[\"去重组合skip\",{\"1\":{\"358\":1}}],[\"去重\",{\"1\":{\"71\":2,\"319\":1}}],[\"去除尾部空格\",{\"1\":{\"331\":1}}],[\"去除首部空格\",{\"1\":{\"331\":1}}],[\"去除首尾空格\",{\"1\":{\"331\":1}}],[\"去除final标记\",{\"1\":{\"193\":1}}],[\"去除\",{\"1\":{\"71\":1}}],[\"x64\",{\"1\":{\"908\":1,\"913\":1}}],[\"xhr\",{\"1\":{\"893\":7}}],[\"xhtml+xml\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"xsd\",{\"1\":{\"819\":2,\"840\":2,\"849\":2}}],[\"xsi\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"xsi=\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"xss\",{\"1\":{\"71\":1}}],[\"xi​\",{\"1\":{\"475\":2}}],[\"xk+1​=f\",{\"1\":{\"432\":1}}],[\"xk​→x∗\",{\"1\":{\"432\":1}}],[\"xk​\",{\"1\":{\"432\":2,\"475\":1,\"478\":1,\"484\":1}}],[\"xkn​​\",{\"1\":{\"382\":1}}],[\"x∗\",{\"1\":{\"432\":1}}],[\"x=f\",{\"1\":{\"432\":1}}],[\"x2​\",{\"1\":{\"432\":1,\"449\":1}}],[\"x1​\",{\"1\":{\"432\":1}}],[\"xuser​\",{\"1\":{\"388\":2}}],[\"xuav​\",{\"1\":{\"387\":1,\"388\":2}}],[\"xt​=⎩⎨⎧​1\",{\"1\":{\"387\":1}}],[\"xd​+1\",{\"1\":{\"387\":1}}],[\"xd​\",{\"1\":{\"387\":1}}],[\"xn​\",{\"1\":{\"382\":2,\"449\":1}}],[\"x$0\",{\"1\":{\"365\":2}}],[\"xml编写即可\",{\"1\":{\"903\":1}}],[\"xmlhttprequest\",{\"1\":{\"893\":1}}],[\"xml填写对应mapper的配置\",{\"1\":{\"888\":1}}],[\"xml中\",{\"1\":{\"871\":1}}],[\"xml中进行注册\",{\"1\":{\"871\":1}}],[\"xml中参数名改为\",{\"1\":{\"660\":1}}],[\"xmlschema\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"xmlns\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"xmlns=\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"xml则是maven的核心配置\",{\"1\":{\"819\":1}}],[\"xml文件\",{\"1\":{\"827\":1}}],[\"xml文件了\",{\"1\":{\"710\":1,\"711\":1}}],[\"xml文件也可以使用注释\",{\"1\":{\"634\":1}}],[\"xml配置sql操作\",{\"1\":{\"648\":1}}],[\"xml的文件作为我们的映射器\",{\"1\":{\"643\":1}}],[\"xml的文件\",{\"1\":{\"641\":1}}],[\"xml语言发明最初是用于数据的存储和传输\",{\"1\":{\"634\":1}}],[\"xml语言\",{\"0\":{\"634\":1}}],[\"xml\",{\"1\":{\"323\":1,\"544\":1,\"633\":1,\"634\":2,\"636\":1,\"641\":2,\"643\":3,\"647\":1,\"658\":1,\"659\":1,\"819\":1,\"834\":2,\"840\":1,\"849\":1,\"864\":1,\"888\":3,\"889\":1,\"908\":1,\"913\":1,\"914\":1}}],[\"x\",{\"1\":{\"292\":3,\"432\":2,\"449\":1,\"468\":1,\"473\":10,\"475\":6,\"478\":17,\"484\":9,\"544\":1}}],[\"x之内的随机数\",{\"1\":{\"274\":1}}],[\"xxx\",{\"1\":{\"584\":1,\"586\":3,\"648\":4,\"754\":1}}],[\"xxxx\",{\"1\":{\"567\":1,\"892\":1,\"899\":1}}],[\"xxxxx\",{\"1\":{\"242\":1,\"635\":1}}],[\"xxxinputstream\",{\"1\":{\"543\":1}}],[\"xxxoutputstream\",{\"1\":{\"543\":1}}],[\"xxxexception\",{\"1\":{\"267\":2}}],[\"xx\",{\"1\":{\"71\":1,\"660\":1}}],[\"得到对应的session对象\",{\"1\":{\"912\":1}}],[\"得到日志的打印结果\",{\"1\":{\"725\":1}}],[\"得到含有噪音的观测值序列\",{\"1\":{\"471\":1}}],[\"得到\",{\"1\":{\"442\":1}}],[\"得到true\",{\"1\":{\"344\":1}}],[\"得到最终的图片地址\",{\"1\":{\"333\":1}}],[\"得到一个样本序列x1​\",{\"1\":{\"449\":1}}],[\"得到一个字符串数组\",{\"1\":{\"244\":1}}],[\"得到一个克隆的对象\",{\"1\":{\"220\":1}}],[\"得到一个class文件\",{\"1\":{\"199\":1}}],[\"得到一个method对象\",{\"1\":{\"192\":1}}],[\"得到的类名称很奇怪class\",{\"1\":{\"659\":1}}],[\"得到的class也是string类型\",{\"1\":{\"328\":1}}],[\"得到的会是同一个对象\",{\"1\":{\"227\":1}}],[\"得到的是包名+类名的完整名称\",{\"1\":{\"184\":1}}],[\"得到的\",{\"1\":{\"84\":1,\"458\":1}}],[\"得到结果是一样的\",{\"1\":{\"668\":1}}],[\"得到结果\",{\"1\":{\"71\":1,\"585\":1}}],[\"得到前面处理的结果\",{\"1\":{\"71\":1}}],[\"得益于泛型的类型擦除机制\",{\"1\":{\"80\":1}}],[\"得益于\",{\"1\":{\"36\":1}}],[\"最关键的其实是name\",{\"1\":{\"909\":1}}],[\"最低日志级别\",{\"1\":{\"727\":1}}],[\"最低优先级\",{\"1\":{\"145\":1}}],[\"最高日志级别\",{\"1\":{\"727\":1}}],[\"最高优先级\",{\"1\":{\"145\":1}}],[\"最近最少使用\",{\"1\":{\"701\":1}}],[\"最近的是参数\",{\"1\":{\"251\":1}}],[\"最优的策略\",{\"1\":{\"522\":1}}],[\"最优策略\",{\"0\":{\"431\":1}}],[\"最优策略是\",{\"1\":{\"427\":1}}],[\"最优策略是否唯一\",{\"1\":{\"427\":1}}],[\"最优策略是否存在\",{\"1\":{\"427\":1}}],[\"最优策略的定义\",{\"1\":{\"427\":1}}],[\"最接近真实的vπ​\",{\"1\":{\"506\":1}}],[\"最简单的示例算法\",{\"1\":{\"450\":1}}],[\"最好的\",{\"0\":{\"401\":1}}],[\"最好是一个域名的格式\",{\"1\":{\"120\":1}}],[\"最终的结果依然是被赋值为数据库中的结果\",{\"1\":{\"658\":1}}],[\"最终的图片地址就有了\",{\"1\":{\"333\":1}}],[\"最终只需要将resulttype改为resultmap并指定对应id即可\",{\"1\":{\"652\":1}}],[\"最终会达到一个平稳的状态\",{\"1\":{\"509\":1}}],[\"最终优化的策略\",{\"1\":{\"495\":1}}],[\"最终可以证明\",{\"1\":{\"421\":1}}],[\"最终输出结果\",{\"1\":{\"387\":1}}],[\"最终输出的结果\",{\"1\":{\"387\":1}}],[\"最终到\",{\"1\":{\"267\":1}}],[\"最终操作\",{\"1\":{\"71\":1}}],[\"最少匹配\",{\"1\":{\"246\":1}}],[\"最方便的是\",{\"1\":{\"127\":1}}],[\"最小\",{\"0\":{\"76\":1}}],[\"最大的\",{\"1\":{\"451\":1,\"453\":1}}],[\"最大的q\",{\"1\":{\"387\":1}}],[\"最大的不同是它支持基本数据类型的直接读取\",{\"1\":{\"129\":1}}],[\"最大\",{\"0\":{\"76\":1}}],[\"最后总结\",{\"1\":{\"900\":1}}],[\"最后创建一个servlet用于处理时间更新请求\",{\"1\":{\"893\":1}}],[\"最后交给web服务器\",{\"1\":{\"870\":1}}],[\"最后我们就可以得到一个日志文件了\",{\"1\":{\"737\":1}}],[\"最后我们来看一下二级缓存相关的配置\",{\"1\":{\"720\":1}}],[\"最后我们查询到结果后\",{\"1\":{\"648\":1}}],[\"最后实际执行的sql为\",{\"1\":{\"693\":1}}],[\"最后实际上只有一个成功插入了\",{\"1\":{\"48\":1}}],[\"最后再由mybatis将其结果合并\",{\"1\":{\"668\":1}}],[\"最后再提一下\",{\"1\":{\"266\":1}}],[\"最后还有一个普通的select方法\",{\"1\":{\"653\":1}}],[\"最后一个参数为我们希望作为key的属性\",{\"1\":{\"653\":1}}],[\"最后在方法上添加\",{\"1\":{\"776\":1}}],[\"最后在构造sqlsessionfactory时也可以通过此对象进行创建\",{\"1\":{\"721\":1}}],[\"最后在程序中使用我们定义好的mapper即可\",{\"1\":{\"643\":1}}],[\"最后在后续版本中正式开放使用\",{\"1\":{\"337\":1}}],[\"最后\",{\"1\":{\"628\":1,\"859\":1,\"872\":1}}],[\"最后需要\",{\"1\":{\"537\":1}}],[\"最后使用\",{\"1\":{\"367\":1}}],[\"最后通过\",{\"1\":{\"365\":1}}],[\"最后会被映射为一个实体类\",{\"1\":{\"344\":1}}],[\"最后会返回一个值作为i的新值\",{\"1\":{\"321\":1}}],[\"最后才能使用的方式\",{\"1\":{\"342\":1}}],[\"最后比对属性是否一样\",{\"1\":{\"342\":1}}],[\"最后打印\",{\"1\":{\"319\":1}}],[\"最后面分号可以不打\",{\"1\":{\"221\":1}}],[\"最后也得不到我们想要的结果\",{\"1\":{\"155\":1}}],[\"最后由mybatis来对查询的结果进行处理即可\",{\"1\":{\"667\":1}}],[\"最后由\",{\"1\":{\"71\":1}}],[\"最后哈希表就长这样了\",{\"1\":{\"58\":1}}],[\"最后得到的结果并不是我们插入顺序\",{\"1\":{\"50\":1}}],[\"流才开始真正地遍历\",{\"1\":{\"358\":1}}],[\"流在中间处理过程中\",{\"1\":{\"357\":1}}],[\"流在管道中传输\",{\"1\":{\"71\":1}}],[\"流的内容是有限的\",{\"1\":{\"91\":1}}],[\"流stream\",{\"1\":{\"71\":1}}],[\"简称sql\",{\"1\":{\"561\":1}}],[\"简化了我们手动转换的步骤\",{\"1\":{\"342\":1}}],[\"简洁一些了\",{\"1\":{\"333\":1}}],[\"简洁的代码\",{\"1\":{\"71\":1}}],[\"简单来说\",{\"1\":{\"689\":1}}],[\"简单说它就是java与数据库的连接的桥梁或者插件\",{\"1\":{\"604\":1}}],[\"简单使用\",{\"0\":{\"311\":1,\"908\":1}}],[\"简单理解为\",{\"1\":{\"180\":1}}],[\"简而言之\",{\"1\":{\"179\":1,\"549\":1,\"552\":1}}],[\"简介与项目结构\",{\"0\":{\"815\":1,\"816\":1}}],[\"简介\",{\"0\":{\"31\":1,\"303\":1,\"549\":1,\"817\":1}}],[\"干净\",{\"1\":{\"71\":1}}],[\"语句时\",{\"1\":{\"701\":1}}],[\"语句有多痛苦\",{\"1\":{\"689\":1}}],[\"语句\",{\"0\":{\"561\":1},\"1\":{\"561\":1}}],[\"语句块进行异常的捕获\",{\"1\":{\"267\":1}}],[\"语句块来处理\",{\"1\":{\"267\":1}}],[\"语句从数据库查询数据的直观方式来提供一种对\",{\"1\":{\"71\":1}}],[\"语法与java比较相似\",{\"1\":{\"690\":1}}],[\"语法树会被分析并转化成类文件\",{\"1\":{\"628\":1}}],[\"语法那是相当的简洁\",{\"1\":{\"339\":1}}],[\"语法\",{\"1\":{\"30\":1,\"36\":1}}],[\"利用动态\",{\"1\":{\"689\":1}}],[\"利用全新的客户端\",{\"1\":{\"333\":1}}],[\"利用\",{\"0\":{\"321\":1}}],[\"利用反射之后\",{\"1\":{\"192\":1}}],[\"利用了\",{\"1\":{\"67\":1}}],[\"利用这种特性\",{\"1\":{\"44\":1}}],[\"才可以顺利地到达对应的servlet\",{\"1\":{\"918\":1}}],[\"才可以访问一些页面\",{\"1\":{\"918\":1}}],[\"才可以进行数据交换\",{\"1\":{\"859\":1}}],[\"才不会重新读取\",{\"1\":{\"701\":1}}],[\"才进行更新\",{\"1\":{\"456\":1}}],[\"才进行替换\",{\"1\":{\"66\":1}}],[\"才能与servlet相拥\",{\"1\":{\"918\":1}}],[\"才能理解\",{\"1\":{\"903\":1}}],[\"才能进行\",{\"1\":{\"456\":1}}],[\"才能进行比较\",{\"1\":{\"216\":1}}],[\"才能去\",{\"1\":{\"251\":1}}],[\"才能用这三个方法\",{\"1\":{\"161\":1}}],[\"才会到达我们的servlet中\",{\"1\":{\"920\":1}}],[\"才会到达对应的servlet进行处理\",{\"1\":{\"920\":1}}],[\"才会正常通过\",{\"1\":{\"807\":1}}],[\"才会请求数据库\",{\"1\":{\"702\":1}}],[\"才会从一级缓存中获取\",{\"1\":{\"702\":1}}],[\"才会保存在二级缓存\",{\"1\":{\"701\":1}}],[\"才会初始化外部类\",{\"1\":{\"254\":1}}],[\"才会让appclassloader来加载\",{\"1\":{\"198\":1}}],[\"才会转换\",{\"1\":{\"161\":1}}],[\"才会依次进行\",{\"1\":{\"71\":1}}],[\"才正确\",{\"1\":{\"155\":1}}],[\"才认为这两个元素是相同的\",{\"1\":{\"84\":1}}],[\"才是灵魂\",{\"1\":{\"67\":1}}],[\"你们就没有一点错吗\",{\"1\":{\"840\":1}}],[\"你还可以直接声明一个自定义方法来进行判断\",{\"1\":{\"797\":1}}],[\"你干嘛\",{\"1\":{\"746\":3}}],[\"你应该能理解根据不同条件拼接\",{\"1\":{\"689\":1}}],[\"你也可以认为这就是之前jdbc中的statement对象\",{\"1\":{\"642\":1}}],[\"你看\",{\"1\":{\"245\":2}}],[\"你会发现\",{\"1\":{\"359\":1}}],[\"你会发现它更像一个sql语句\",{\"1\":{\"71\":1}}],[\"你会发现所有的方法全是替身攻击\",{\"1\":{\"67\":1}}],[\"你只需要坐着等别人写好然后你自己拿去交差就行了\",{\"1\":{\"67\":1}}],[\"你没看错\",{\"1\":{\"67\":1}}],[\"玛卡\",{\"1\":{\"66\":1}}],[\"巴卡\",{\"1\":{\"66\":1}}],[\"计算结果验证\",{\"1\":{\"786\":1,\"787\":1,\"789\":1}}],[\"计算\",{\"1\":{\"484\":1}}],[\"计算机网络\",{\"1\":{\"281\":2}}],[\"计算10\",{\"1\":{\"229\":1}}],[\"计算的话也只能通过\",{\"1\":{\"229\":1}}],[\"计算规则为\",{\"1\":{\"71\":1}}],[\"计算并将键值对放入map中\",{\"1\":{\"64\":1}}],[\"计算当前整个集合对象的哈希值\",{\"1\":{\"23\":1}}],[\"存在潜在问题的消息级别\",{\"1\":{\"727\":1}}],[\"存在一级缓存\",{\"1\":{\"699\":1}}],[\"存在不动点x∗\",{\"1\":{\"432\":1}}],[\"存在\",{\"1\":{\"427\":1}}],[\"存在lemma1\",{\"1\":{\"383\":1}}],[\"存在时存在则计算并赋予新的值\",{\"1\":{\"64\":1}}],[\"存放运行时产生的一些临时文件\",{\"1\":{\"864\":1}}],[\"存放参数\",{\"1\":{\"616\":1}}],[\"存放在元空间中\",{\"1\":{\"180\":1}}],[\"存放数据的底层数组\",{\"1\":{\"25\":1}}],[\"存储过程以及高级映射\",{\"1\":{\"633\":1}}],[\"存储过程\",{\"1\":{\"604\":1}}],[\"存储物品id\",{\"1\":{\"556\":5}}],[\"存储类型为我们要存放的变量类型\",{\"1\":{\"162\":1}}],[\"存储在主内存\",{\"1\":{\"154\":1}}],[\"存储本地读取字节数\",{\"1\":{\"94\":1}}],[\"若超过此时间\",{\"1\":{\"914\":1}}],[\"若勾选了勾选框\",{\"1\":{\"910\":1}}],[\"若查询到信息则表示存在此用户\",{\"1\":{\"889\":1}}],[\"若没问题\",{\"1\":{\"864\":1}}],[\"若此字段被填入了构造方法作为参数\",{\"1\":{\"658\":1}}],[\"若此文件不存在\",{\"1\":{\"92\":1}}],[\"若视图定义中有嵌套查询\",{\"1\":{\"596\":1}}],[\"若视图定义中含有distinct短语\",{\"1\":{\"596\":1}}],[\"若视图定义中含有group\",{\"1\":{\"596\":1}}],[\"若视图的字段来自集函数\",{\"1\":{\"596\":1}}],[\"若视图的字段来自字段表达式或常数\",{\"1\":{\"596\":1}}],[\"若视图是由两个以上基本表导出的\",{\"1\":{\"596\":1}}],[\"若有一系列\",{\"1\":{\"449\":1}}],[\"若不存在则计算并插入新的值\",{\"1\":{\"64\":1}}],[\"若key不存在\",{\"1\":{\"64\":1}}],[\"若\",{\"1\":{\"64\":1}}],[\"具有\",{\"1\":{\"61\":1}}],[\"具体内容是保存在服务器端的\",{\"1\":{\"912\":1}}],[\"具体推导过程\",{\"1\":{\"529\":1}}],[\"具体解决如下\",{\"1\":{\"471\":1}}],[\"具体求解方法\",{\"1\":{\"453\":1}}],[\"具体算法\",{\"0\":{\"453\":1}}],[\"具体步骤\",{\"0\":{\"437\":1}}],[\"具体分两步\",{\"1\":{\"430\":1}}],[\"具体代码\",{\"1\":{\"387\":1}}],[\"具体表述如下\",{\"1\":{\"385\":1}}],[\"具体如下\",{\"1\":{\"384\":1,\"516\":1}}],[\"具体操作\",{\"1\":{\"368\":1}}],[\"具体示例\",{\"1\":{\"353\":1}}],[\"具体请回顾一下javase篇视频教程\",{\"1\":{\"296\":1}}],[\"具体规范\",{\"0\":{\"290\":1}}],[\"具体的实现逻辑\",{\"1\":{\"288\":1}}],[\"具体的实现由\",{\"1\":{\"218\":1}}],[\"具体类型不同的泛型类变量\",{\"1\":{\"281\":1}}],[\"具体类型只能是我们指定的上界类型或是上界类型的子类\",{\"1\":{\"15\":1}}],[\"具体使用\",{\"1\":{\"281\":1}}],[\"具体实现克隆\",{\"1\":{\"220\":1}}],[\"具体而言\",{\"1\":{\"5\":1}}],[\"原理\",{\"0\":{\"912\":1}}],[\"原子性\",{\"1\":{\"599\":1}}],[\"原本java应该这样写\",{\"1\":{\"694\":1}}],[\"原本需要完整编写包括类\",{\"1\":{\"289\":1}}],[\"原本就有的\",{\"1\":{\"37\":3}}],[\"原因很多\",{\"1\":{\"60\":1}}],[\"阈值为负载因子乘以默认容量\",{\"1\":{\"60\":1}}],[\"出现严重故障的消息级别\",{\"1\":{\"727\":1}}],[\"出现重名时\",{\"1\":{\"7\":1}}],[\"出发的\",{\"1\":{\"456\":1,\"511\":1}}],[\"出发\",{\"1\":{\"452\":2,\"458\":1}}],[\"出来的时候\",{\"1\":{\"60\":1}}],[\"新建项目\",{\"1\":{\"865\":1}}],[\"新建模块\",{\"1\":{\"849\":1}}],[\"新建一个类\",{\"1\":{\"761\":1}}],[\"新建名为testmapper\",{\"1\":{\"643\":1}}],[\"新建module\",{\"1\":{\"304\":1}}],[\"新文件也要进行编译\",{\"1\":{\"628\":1}}],[\"新数据类型\",{\"1\":{\"568\":1}}],[\"新列名\",{\"1\":{\"568\":1}}],[\"新增的一个函数式接口\",{\"1\":{\"362\":1}}],[\"新增操作\",{\"1\":{\"57\":1}}],[\"新语法\",{\"0\":{\"339\":1}}],[\"新特性\",{\"0\":{\"337\":1,\"345\":1}}],[\"新的内容会出现在new表中\",{\"1\":{\"598\":1}}],[\"新的内容会被插入到new表中\",{\"1\":{\"598\":1}}],[\"新的流中的内容被修改为对应字符串的长度\",{\"1\":{\"362\":1}}],[\"新的instanceof语法在java\",{\"1\":{\"342\":1}}],[\"新的instanceof语法\",{\"0\":{\"342\":1}}],[\"新的switch语法\",{\"0\":{\"338\":1}}],[\"新的api支持最新的http2和websocket协议\",{\"1\":{\"332\":1}}],[\"新的容量直接等于默认容量16\",{\"1\":{\"60\":1}}],[\"新的容量等于旧容量的2倍\",{\"1\":{\"60\":1}}],[\"新的阈值也提升到原来的两倍\",{\"1\":{\"60\":1}}],[\"先看对应请求是否支持http协议的实现\",{\"1\":{\"876\":1}}],[\"先子logger\",{\"1\":{\"746\":1}}],[\"先进先出\",{\"1\":{\"701\":1}}],[\"先根据当前策略计算出各个状态的\",{\"1\":{\"451\":1}}],[\"先找好我们要截取的前面一段\",{\"1\":{\"333\":1}}],[\"先来10个\",{\"1\":{\"333\":1}}],[\"先不要一次性获取太多\",{\"1\":{\"333\":1}}],[\"先定义一个a=10和b=10\",{\"1\":{\"316\":1}}],[\"先实现未实现的方法\",{\"1\":{\"255\":1}}],[\"先转换为当前类型\",{\"1\":{\"216\":1}}],[\"先写好我们定义的类\",{\"1\":{\"199\":1}}],[\"先加载\",{\"1\":{\"180\":1}}],[\"先完成线程1的内容\",{\"1\":{\"148\":1}}],[\"先把下面这几个旧的东西保存一下\",{\"1\":{\"60\":1}}],[\"先初始化\",{\"1\":{\"59\":1}}],[\"此加载器可能会存在多个实例\",{\"1\":{\"926\":1}}],[\"此加载器可能存在多个实例\",{\"1\":{\"926\":1}}],[\"此对象也能设置附加值\",{\"1\":{\"901\":1}}],[\"此属性表示\",{\"1\":{\"899\":1}}],[\"此属性决定了是否在tomcat启动时就加载此servlet\",{\"1\":{\"881\":1}}],[\"此路径的意思为\",{\"1\":{\"879\":1}}],[\"此路径和tomcat默认为我们提供的servlet冲突\",{\"1\":{\"879\":1}}],[\"此依赖也被一起传递\",{\"1\":{\"841\":1}}],[\"此范围表示在编译\",{\"1\":{\"833\":1}}],[\"此测试案例才会启动\",{\"1\":{\"793\":1}}],[\"此测试案例并未抛出指定异常\",{\"1\":{\"790\":1}}],[\"此缓冲区大小为\",{\"1\":{\"538\":1}}],[\"此模块暴露了com\",{\"1\":{\"310\":1}}],[\"此方法返回给我们一个resultset对象\",{\"1\":{\"608\":1}}],[\"此方法返回值为void\",{\"1\":{\"290\":1}}],[\"此方法会直接终止此线程\",{\"1\":{\"142\":1}}],[\"此注解在编译时会被自动丢弃\",{\"1\":{\"203\":1}}],[\"此外也可以用\",{\"1\":{\"671\":1}}],[\"此外\",{\"1\":{\"186\":1}}],[\"此外在每次扩容时会调用\",{\"1\":{\"60\":1}}],[\"此文件是否存在\",{\"1\":{\"98\":1}}],[\"此时父项目不会打包成\",{\"1\":{\"855\":1}}],[\"此时会出现两个文件\",{\"1\":{\"854\":1}}],[\"此时会重复执行10次此案例\",{\"1\":{\"807\":1}}],[\"此时jar包中已经包含了我们项目中编写的类了\",{\"1\":{\"853\":1}}],[\"此时在引入此项目的其他项目中\",{\"1\":{\"841\":1}}],[\"此时测试的结果展示也是嵌套的样式\",{\"1\":{\"805\":1}}],[\"此时控制台就会得到\",{\"1\":{\"786\":1}}],[\"此时再次全部运行\",{\"1\":{\"777\":1}}],[\"此时再调用next将不能再得到下一个元素\",{\"1\":{\"31\":1}}],[\"此时idea会提示我们可以运行\",{\"1\":{\"776\":1}}],[\"此时日志文件中写入的内容就是简单的日志格式了\",{\"1\":{\"738\":1}}],[\"此时日志中可以看到mybatis在尽可能优化我们的sql操作\",{\"1\":{\"688\":1}}],[\"此时打印的列表中不存在任何handler对象\",{\"1\":{\"735\":1}}],[\"此时低于info的所有日志都是被屏蔽的\",{\"1\":{\"729\":1}}],[\"此时该如何像之前一样配置resultmap呢\",{\"1\":{\"715\":1}}],[\"此时该trajectory的return=0+0+0+1+1+⋯=∞\",{\"1\":{\"393\":1}}],[\"此时动态sql就能很轻松实现这个操作\",{\"1\":{\"690\":1}}],[\"此时我们通过这种方式手动排除了test项目中包含的mybatis依赖\",{\"1\":{\"843\":1}}],[\"此时我们就可以使用重复测试案例来使其多次执行\",{\"1\":{\"807\":1}}],[\"此时我们可以使用嵌套测试\",{\"1\":{\"805\":1}}],[\"此时我们查询所有用户信息的时候\",{\"1\":{\"672\":1}}],[\"此时我们怎么去明确要使用的是哪一个\",{\"1\":{\"251\":1}}],[\"此时由于我们更新了数据库中的数据\",{\"1\":{\"700\":1}}],[\"此时由于数据被删除\",{\"1\":{\"682\":1}}],[\"此时由于出现了多行数据\",{\"1\":{\"670\":1}}],[\"此时由于类中存在多个构造方法\",{\"1\":{\"658\":1}}],[\"此时由于三个属性完全一致\",{\"1\":{\"216\":1}}],[\"此时可以分析每一个状态在这个策略下的概率\",{\"1\":{\"509\":1}}],[\"此时也可以是\",{\"1\":{\"498\":1}}],[\"此时就可以使用properties文件\",{\"1\":{\"753\":1}}],[\"此时就是随机策略\",{\"1\":{\"461\":1}}],[\"此时就不会使用默认的情况\",{\"1\":{\"295\":1}}],[\"此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​\",{\"1\":{\"393\":1}}],[\"此时的mos模型定义如下\",{\"1\":{\"384\":1}}],[\"此时返回的类型和起始值类型一致\",{\"1\":{\"364\":1}}],[\"此时返回\",{\"1\":{\"364\":1}}],[\"此时参数\",{\"1\":{\"362\":1}}],[\"此时\",{\"1\":{\"294\":1,\"420\":1,\"451\":1,\"499\":1}}],[\"此时发生异常再往上抛出的话\",{\"1\":{\"267\":1}}],[\"此时这里创建出来的student对象\",{\"1\":{\"255\":1}}],[\"此时消费者在等待生产者往货架上生产产品\",{\"1\":{\"174\":1}}],[\"此时获取键为3的值\",{\"1\":{\"57\":1}}],[\"此时元素成功被移除\",{\"1\":{\"25\":1}}],[\"此时虽然使用的是通配符\",{\"1\":{\"15\":1}}],[\"此时this\",{\"1\":{\"9\":1}}],[\"此时变量没有引用任何对象\",{\"1\":{\"4\":1}}],[\"键的名称我们也可以分为多级进行配置\",{\"1\":{\"753\":1}}],[\"键值对size计数自增\",{\"1\":{\"59\":1}}],[\"键也相同\",{\"1\":{\"59\":1}}],[\"达到了阈值\",{\"1\":{\"59\":1}}],[\"普通html文本使用text\",{\"1\":{\"875\":1}}],[\"普通的信息\",{\"1\":{\"728\":1}}],[\"普通的\",{\"1\":{\"633\":1}}],[\"普通的类也可以\",{\"1\":{\"255\":1}}],[\"普通的list只需要一个方法就可以直接转换到方便好用的intstream了\",{\"1\":{\"71\":1}}],[\"普通链表就直接在链表尾部插入\",{\"1\":{\"59\":1}}],[\"普通队列中从队尾入队\",{\"1\":{\"44\":1}}],[\"说明编码格式配置有问题\",{\"1\":{\"864\":1}}],[\"说明哪个模块导入的依赖只能哪个模块用\",{\"1\":{\"308\":1}}],[\"说明这种情况下\",{\"1\":{\"254\":1}}],[\"说明这个链表已经升级为红黑树了\",{\"1\":{\"59\":1}}],[\"说明外部希望当前线程立即停止\",{\"1\":{\"144\":1}}],[\"说明已经存放了相同键的键值对了\",{\"1\":{\"59\":1}}],[\"后四个方向\",{\"1\":{\"388\":1}}],[\"后退\",{\"1\":{\"387\":1}}],[\"后续可能是未知的\",{\"1\":{\"419\":1}}],[\"后续参数作为目标对象成员方法的参数\",{\"1\":{\"294\":1}}],[\"后续参数作为目标对象成员方法的参数来尝试调用\",{\"1\":{\"294\":1}}],[\"后续会根据情况扩容\",{\"1\":{\"59\":1}}],[\"后\",{\"1\":{\"186\":1,\"422\":1,\"456\":2}}],[\"后处于等待的线程\",{\"1\":{\"161\":1}}],[\"后面跟\",{\"1\":{\"893\":1}}],[\"后面会一一讲解\",{\"1\":{\"874\":1}}],[\"后面加上花括号\",{\"1\":{\"255\":1}}],[\"后面在juc中我们还会讲到乐观锁\",{\"1\":{\"155\":1}}],[\"后面的就是实际结果\",{\"1\":{\"786\":1}}],[\"后面的表达式判断结果为\",{\"1\":{\"268\":1}}],[\"后面的\",{\"1\":{\"120\":1}}],[\"后面的元素就被挤到后面去了\",{\"1\":{\"24\":1}}],[\"后保存的读取内容是取readlimit和bufferedinputstream类的缓冲区大小两者中的最大值\",{\"1\":{\"108\":1}}],[\"哈希表的大小并不是一直不变的\",{\"1\":{\"58\":1}}],[\"哈希表可能会出现哈希冲突\",{\"1\":{\"58\":1}}],[\"哈希表\",{\"1\":{\"58\":1}}],[\"备胎\",{\"1\":{\"57\":1}}],[\"khtml\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"keep\",{\"1\":{\"544\":1,\"908\":3,\"913\":3}}],[\"keycolumn\",{\"1\":{\"714\":1}}],[\"keycolumn为数据库中自增的字段名称\",{\"1\":{\"679\":1}}],[\"keycolumn=\",{\"1\":{\"679\":1,\"714\":1}}],[\"keyproperty\",{\"1\":{\"714\":1}}],[\"keyproperty设置为user类中的需要获取自增结果的属性名\",{\"1\":{\"679\":1}}],[\"keyproperty=\",{\"1\":{\"679\":1,\"714\":1}}],[\"key为string类型\",{\"1\":{\"650\":1}}],[\"keyset\",{\"1\":{\"56\":1,\"67\":1}}],[\"key\",{\"1\":{\"56\":4,\"58\":1,\"59\":15,\"61\":2,\"64\":3,\"65\":1,\"67\":2,\"564\":4,\"565\":4}}],[\"k→0∑k=1∞​ak​=∞\",{\"1\":{\"472\":1}}],[\"k→∞\",{\"1\":{\"421\":1,\"432\":1,\"478\":1}}],[\"k−1\",{\"1\":{\"468\":1}}],[\"k=2\",{\"1\":{\"468\":1}}],[\"k=1∑n​rt+k​\",{\"1\":{\"528\":1}}],[\"k=1∑n​rt+k​∣st​=s0​\",{\"1\":{\"528\":1}}],[\"k=1\",{\"1\":{\"436\":1,\"468\":1,\"471\":1}}],[\"kth\",{\"1\":{\"453\":1}}],[\"kn​∩kn\",{\"1\":{\"382\":1,\"385\":1,\"387\":1}}],[\"kn​\",{\"1\":{\"382\":1,\"383\":2}}],[\"killed\",{\"1\":{\"167\":1}}],[\"k\",{\"1\":{\"56\":3,\"58\":1,\"59\":8,\"61\":1,\"64\":3,\"65\":2,\"471\":2,\"886\":2}}],[\"体系下的接口\",{\"1\":{\"55\":1}}],[\"映射语句来加载期望的复杂类型\",{\"1\":{\"666\":1}}],[\"映射成数据库中的记录\",{\"1\":{\"633\":1}}],[\"映射\",{\"0\":{\"362\":1}}],[\"映射map\",{\"1\":{\"358\":1}}],[\"映射指两个元素的之间相互\",{\"1\":{\"55\":1}}],[\"映射等数据结构\",{\"1\":{\"21\":1}}],[\"底层c++写的\",{\"1\":{\"235\":1}}],[\"底层是由c++实现的\",{\"1\":{\"215\":1}}],[\"底层是直接用\",{\"1\":{\"67\":1}}],[\"底层直接用\",{\"1\":{\"67\":1}}],[\"底层哈希表的长度永远是2的n次方\",{\"1\":{\"59\":1}}],[\"底层实现\",{\"0\":{\"58\":1,\"67\":1}}],[\"底层采用哈希表实现\",{\"1\":{\"57\":2}}],[\"底层维护的不再是一个\",{\"1\":{\"49\":1}}],[\"底层就是采用数组实现的\",{\"1\":{\"25\":1}}],[\"篇视频教程中学习大顶堆和小顶堆\",{\"1\":{\"46\":1}}],[\"按对象进入缓存的顺序来移除它们\",{\"1\":{\"701\":1}}],[\"按照名称顺序\",{\"1\":{\"804\":1}}],[\"按照一定规则进行名称处理\",{\"1\":{\"779\":1}}],[\"按照官方文档给定的提示\",{\"1\":{\"641\":1}}],[\"按照所给定策略j来执行一个动作at​∈a从而获得奖励rt​以及下一个状态st+1​\",{\"1\":{\"387\":1}}],[\"按照从大到小顺序出队\",{\"1\":{\"46\":1}}],[\"按从小到大的顺序排列\",{\"1\":{\"292\":1}}],[\"按行读取\",{\"1\":{\"112\":1}}],[\"按顺序从前往后存放\",{\"1\":{\"24\":1}}],[\"栈相关操作已经帮助我们定义好了\",{\"1\":{\"44\":1}}],[\"队首出队\",{\"1\":{\"44\":1}}],[\"队列中继承下来的方法操作是一样的\",{\"1\":{\"44\":1}}],[\"队列的添加操作\",{\"1\":{\"43\":1}}],[\"队列\",{\"0\":{\"43\":1,\"45\":1},\"1\":{\"21\":1}}],[\"仅在编译\",{\"1\":{\"833\":1}}],[\"仅用作估计\",{\"1\":{\"455\":1}}],[\"仅需要考虑无人机的7个移动方向即可\",{\"1\":{\"388\":1}}],[\"仅支持接口\",{\"1\":{\"257\":1}}],[\"仅仅引用方法\",{\"1\":{\"295\":1}}],[\"仅仅是se中就有700多个\",{\"1\":{\"265\":1}}],[\"仅仅是检查\",{\"1\":{\"204\":1}}],[\"仅仅编译器阶段\",{\"1\":{\"204\":1}}],[\"仅使用默认类加载器\",{\"1\":{\"180\":1}}],[\"仅获取队首元素\",{\"1\":{\"43\":1}}],[\"仅适用于通配符\",{\"1\":{\"15\":1}}],[\"除非抛出的异常是一个运行时异常\",{\"1\":{\"267\":1}}],[\"除非我们手动重载一个无参构造\",{\"1\":{\"9\":1}}],[\"除了用写好的\",{\"1\":{\"899\":1}}],[\"除了上述介绍的几种命令外\",{\"1\":{\"852\":1}}],[\"除了上述例子中出现的断言方法之外\",{\"1\":{\"790\":1}}],[\"除了三个基本的属性用于定位坐标外\",{\"1\":{\"832\":1}}],[\"除了以上方式获取参数\",{\"1\":{\"811\":1}}],[\"除了直接编写一个类\",{\"1\":{\"871\":1}}],[\"除了直接设置指定类型常量值\",{\"1\":{\"809\":1}}],[\"除了直接运行我们写进去的代码之外\",{\"1\":{\"316\":1}}],[\"除了默认的名称顺序之外\",{\"1\":{\"804\":1}}],[\"除了默认的rootlogger作为父类\",{\"1\":{\"747\":1}}],[\"除了在所有方法执行前后插入准备工作\",{\"1\":{\"802\":1}}],[\"除了在不为空时执行的操作外\",{\"1\":{\"297\":1}}],[\"除了这种简单判断外\",{\"1\":{\"795\":1}}],[\"除了断言工具外\",{\"1\":{\"791\":1}}],[\"除了我们上面提到的真假判断外\",{\"1\":{\"790\":1}}],[\"除了我们手动编写接口中抽象方法的方法体之外\",{\"1\":{\"291\":1}}],[\"除了使用值进行比较外\",{\"1\":{\"787\":1}}],[\"除了使用批处理之外\",{\"1\":{\"689\":1}}],[\"除了官方为我们提供的两种默认格式外\",{\"1\":{\"761\":1}}],[\"除了if操作之外\",{\"1\":{\"691\":1}}],[\"除了需要求解\",{\"1\":{\"429\":1}}],[\"除了map之外\",{\"1\":{\"318\":1}}],[\"除了jdk的一些常用包之外\",{\"1\":{\"304\":1}}],[\"除了clone\",{\"1\":{\"236\":1}}],[\"除了linkedlist实现了队列接口之外\",{\"1\":{\"45\":1}}],[\"除了可以直接当做列表使用之外\",{\"1\":{\"42\":1}}],[\"和其他语言编写的项目\",{\"1\":{\"817\":1}}],[\"和方法一样\",{\"1\":{\"812\":1}}],[\"和二级缓存\",{\"1\":{\"699\":1}}],[\"和jdbc其实都差不多\",{\"1\":{\"682\":1}}],[\"和jdbc依赖是一样的\",{\"1\":{\"628\":1}}],[\"和之前insert一样\",{\"1\":{\"680\":1}}],[\"和之前一样\",{\"1\":{\"678\":1}}],[\"和串行化\",{\"1\":{\"599\":1}}],[\"和动作\",{\"1\":{\"422\":1}}],[\"和e\",{\"1\":{\"416\":1}}],[\"和上面相反\",{\"1\":{\"322\":1}}],[\"和上面效果依然是一样的\",{\"1\":{\"294\":1}}],[\"和匿名内部类不同\",{\"1\":{\"257\":1,\"290\":1}}],[\"和iterator一样\",{\"1\":{\"173\":1}}],[\"和reset\",{\"1\":{\"112\":1}}],[\"和\",{\"0\":{\"42\":1,\"161\":1},\"1\":{\"84\":2,\"88\":4,\"108\":1,\"126\":1,\"229\":1,\"245\":1,\"246\":1,\"371\":1,\"422\":1,\"456\":1,\"461\":1,\"475\":1,\"479\":1,\"496\":1,\"497\":1,\"516\":2,\"543\":1,\"556\":1,\"653\":1}}],[\"增\",{\"1\":{\"677\":1}}],[\"增量式的迭代算法\",{\"1\":{\"468\":1}}],[\"增加了更多方便的操作\",{\"1\":{\"37\":1}}],[\"增强版switch语法\",{\"1\":{\"339\":1,\"340\":2}}],[\"增强\",{\"1\":{\"30\":1}}],[\"测试后发现\",{\"1\":{\"886\":1}}],[\"测试方法上必须标注\",{\"1\":{\"852\":1}}],[\"测试类的名称必须是以test结尾\",{\"1\":{\"852\":1}}],[\"测试类的生命周期\",{\"0\":{\"803\":1}}],[\"测试和打包\",{\"0\":{\"846\":1,\"847\":1}}],[\"测试导入\",{\"0\":{\"834\":1}}],[\"测试时有效\",{\"1\":{\"833\":2}}],[\"测试时均有效\",{\"1\":{\"833\":1}}],[\"测试代码不会打包到项目里面\",{\"1\":{\"818\":1}}],[\"测试顺序控制\",{\"0\":{\"804\":1}}],[\"测试结果中会将其显示为已忽略\",{\"1\":{\"791\":1}}],[\"测试自定义名称\",{\"0\":{\"778\":1}}],[\"测试阶段\",{\"1\":{\"388\":1}}],[\"测试\",{\"1\":{\"36\":1,\"193\":1,\"817\":1,\"834\":1}}],[\"让其能够接收一个post请求\",{\"1\":{\"886\":1}}],[\"让其实现iterable接口\",{\"1\":{\"36\":1}}],[\"让mybatis对配置文件进行读取并得到一个sqlsessionfactory对象\",{\"1\":{\"641\":1}}],[\"让\",{\"1\":{\"478\":1}}],[\"让字符串重复拼接\",{\"1\":{\"331\":1}}],[\"让子类继续为一个泛型类\",{\"1\":{\"282\":1}}],[\"让程序继续运行下去\",{\"1\":{\"267\":1}}],[\"让程序员写出高效率\",{\"1\":{\"71\":1}}],[\"让类来使用这个接口\",{\"1\":{\"219\":1}}],[\"让我们使用switch语句更加的灵活\",{\"1\":{\"338\":1}}],[\"让我们的java程序更加生动形象\",{\"1\":{\"212\":1}}],[\"让我看看\",{\"1\":{\"117\":1}}],[\"让线程1加入\",{\"1\":{\"148\":1}}],[\"让线程自行处理后续\",{\"1\":{\"144\":1}}],[\"让位\",{\"1\":{\"147\":1}}],[\"让p等于e一会覆盖就行了\",{\"1\":{\"59\":1}}],[\"让当前对象的name变量值等于参数传入的值\",{\"1\":{\"7\":1}}],[\"介绍\",{\"0\":{\"36\":1,\"37\":1,\"306\":1}}],[\"调整\",{\"0\":{\"711\":1}}],[\"调整为限制的大小\",{\"1\":{\"25\":1}}],[\"调用后\",{\"1\":{\"899\":1}}],[\"调用info来输出一个普通的信息\",{\"1\":{\"725\":1}}],[\"调用此操作将直接导致一级和二级缓存被清除\",{\"1\":{\"704\":1}}],[\"调用此方法\",{\"1\":{\"368\":1}}],[\"调用此方法时也会获取锁\",{\"1\":{\"155\":1}}],[\"调用此方法后\",{\"1\":{\"144\":1}}],[\"调用此方法来开始执行此线程\",{\"1\":{\"140\":1}}],[\"调用注解处理器\",{\"1\":{\"628\":1}}],[\"调用无参构造不会自动连接\",{\"1\":{\"538\":1}}],[\"调用无参构造方法不会自动连接\",{\"1\":{\"538\":1}}],[\"调用get\",{\"1\":{\"355\":1}}],[\"调用\",{\"1\":{\"258\":1,\"872\":1}}],[\"调用clone方法\",{\"1\":{\"220\":1}}],[\"调用consumer的accept来对每一个元素进行消费\",{\"1\":{\"35\":1}}],[\"调用父类的实现\",{\"1\":{\"216\":1}}],[\"调用protected方法\",{\"1\":{\"199\":1}}],[\"调用类方法\",{\"0\":{\"192\":1}}],[\"调用类的静态方法\",{\"1\":{\"118\":1}}],[\"调用方法\",{\"1\":{\"191\":1}}],[\"调用t的interrupt方法\",{\"1\":{\"144\":1}}],[\"调用时的位置\",{\"1\":{\"108\":1}}],[\"调用resize进行扩容\",{\"1\":{\"59\":1}}],[\"调用的另一个方法进行映射关系存放\",{\"1\":{\"59\":1}}],[\"自然也需要运行别人的代码\",{\"1\":{\"854\":1}}],[\"自行前往maven官网并下载最新版的maven安装\",{\"1\":{\"827\":1}}],[\"自行阅读官方文档\",{\"1\":{\"641\":1}}],[\"自增主键id\",{\"0\":{\"679\":1}}],[\"自身连接\",{\"1\":{\"585\":1}}],[\"自身连接查询\",{\"0\":{\"585\":1}}],[\"自身存在一个\",{\"1\":{\"35\":1}}],[\"自从有了stream\",{\"1\":{\"319\":1}}],[\"自jdk9后\",{\"1\":{\"305\":1}}],[\"自动执行多次测试\",{\"1\":{\"834\":1}}],[\"自动生成的logger名称\",{\"1\":{\"767\":2}}],[\"自动生成了构造方法和成员字段的公共get方法\",{\"1\":{\"344\":1}}],[\"自动构建一个继承关系\",{\"1\":{\"747\":1}}],[\"自动构建继承关系\",{\"0\":{\"747\":1}}],[\"自动起别名\",{\"1\":{\"649\":1}}],[\"自动模块\",{\"1\":{\"306\":1}}],[\"自动装箱|拆箱机制\",{\"1\":{\"229\":1}}],[\"自动处理字符编码转换\",{\"1\":{\"88\":1}}],[\"自其他接口的\",{\"1\":{\"219\":1}}],[\"自定义测试名称\",{\"1\":{\"834\":1}}],[\"自定义方法\",{\"0\":{\"797\":1}}],[\"自定义例子\",{\"0\":{\"765\":1}}],[\"自定义日志格式\",{\"0\":{\"761\":1}}],[\"自定义级别设置\",{\"0\":{\"728\":1}}],[\"自定义运行时异常\",{\"1\":{\"265\":1}}],[\"自定义编译时异常\",{\"1\":{\"265\":1}}],[\"自定义异常\",{\"0\":{\"265\":1}}],[\"自定义的注解需要定义1个\",{\"1\":{\"206\":1}}],[\"自定义线程名称\",{\"1\":{\"140\":1}}],[\"自己编译的类加载到\",{\"0\":{\"199\":1}}],[\"自己定义的定时器\",{\"0\":{\"165\":1}}],[\"自己定义的类要序列化保存\",{\"1\":{\"131\":1}}],[\"自我介绍需要用到当前对象的名字和年龄\",{\"1\":{\"5\":1}}],[\"自我介绍只需要完成就行\",{\"1\":{\"5\":1}}],[\"表明它可以获取迭代器或是直接使用foreach来遍历\",{\"1\":{\"653\":1}}],[\"表\",{\"1\":{\"591\":2}}],[\"表2\",{\"1\":{\"584\":2}}],[\"表1\",{\"1\":{\"584\":2}}],[\"表名\",{\"1\":{\"567\":1,\"568\":1,\"569\":1,\"571\":3,\"572\":1,\"573\":2,\"579\":5,\"581\":2,\"582\":1,\"583\":4,\"585\":2,\"587\":2,\"597\":2,\"598\":1}}],[\"表级约束有四种\",{\"1\":{\"565\":1}}],[\"表级约束条件\",{\"0\":{\"565\":1},\"1\":{\"567\":1}}],[\"表的\",{\"1\":{\"564\":1}}],[\"表中的唯一非关键字段为数量\",{\"1\":{\"556\":1}}],[\"表达式要求必须涵盖所有的可能\",{\"1\":{\"340\":1}}],[\"表达式\",{\"0\":{\"287\":1}}],[\"表达式的\",{\"1\":{\"35\":1}}],[\"表示删除该cookie\",{\"1\":{\"909\":1}}],[\"表示不在启动时加载\",{\"1\":{\"881\":1}}],[\"表示此maven项目是父maven项目的子项目\",{\"1\":{\"849\":1}}],[\"表示此类为密封类型\",{\"1\":{\"346\":1}}],[\"表示成功导入了依赖\",{\"1\":{\"825\":1}}],[\"表示开启所有日志信息\",{\"1\":{\"729\":1}}],[\"表示直接关闭所有日志信息\",{\"1\":{\"729\":1}}],[\"表示生效的行数\",{\"1\":{\"678\":1}}],[\"表示这本书是谁借的\",{\"1\":{\"670\":1}}],[\"表示这个类具有克隆的功能\",{\"1\":{\"220\":1}}],[\"表示这个类是一个抽象类\",{\"1\":{\"218\":1}}],[\"表示这个类不能再被继承了\",{\"1\":{\"217\":1}}],[\"表示对应用户的详细信息\",{\"1\":{\"666\":1}}],[\"表示对于对应\",{\"1\":{\"458\":1}}],[\"表示对于每一个\",{\"1\":{\"458\":1}}],[\"表示我们的查询结果直接使用指定的构造方法来处理\",{\"1\":{\"658\":1}}],[\"表示我们无权去调用默认构造方法\",{\"1\":{\"191\":1}}],[\"表示将数据库结果映射为student类\",{\"1\":{\"643\":1}}],[\"表示添加一个select操作\",{\"1\":{\"643\":1}}],[\"表示执行后受影响的行数\",{\"1\":{\"608\":1}}],[\"表示针对每一行都会生效\",{\"1\":{\"598\":1}}],[\"表示匹配所有的ip地址\",{\"1\":{\"589\":1}}],[\"表示03开头\",{\"1\":{\"580\":1}}],[\"表示任意内容\",{\"1\":{\"580\":1}}],[\"表示如果此列作为其他表的约束或视图引用到此列时\",{\"1\":{\"568\":1}}],[\"表示是\",{\"1\":{\"509\":1}}],[\"表示是一种长时间的交互行为\",{\"1\":{\"509\":1}}],[\"表示是最佳部署位置\",{\"1\":{\"387\":1}}],[\"表示状态转移矩阵\",{\"1\":{\"420\":1}}],[\"表示为\",{\"1\":{\"414\":1,\"526\":3}}],[\"表示为rkn​​\",{\"1\":{\"383\":1}}],[\"表示在单步情况下\",{\"1\":{\"527\":1}}],[\"表示在策略π下\",{\"1\":{\"527\":1}}],[\"表示在一个\",{\"1\":{\"511\":1}}],[\"表示在各状态执行各动作的概率\",{\"1\":{\"394\":1}}],[\"表示在状态s下采取动作a\",{\"1\":{\"394\":2}}],[\"表示\",{\"1\":{\"384\":1,\"509\":1,\"516\":1,\"529\":1,\"564\":6}}],[\"表示round\",{\"1\":{\"384\":1}}],[\"表示无人机与用户之间的仰角\",{\"1\":{\"383\":1}}],[\"表示只有不为空才进行调用\",{\"1\":{\"323\":1}}],[\"表示什么时候结束生成\",{\"1\":{\"321\":1}}],[\"表示所有小写字母\",{\"1\":{\"246\":1}}],[\"表示一个函数\",{\"1\":{\"484\":1}}],[\"表示一个给定的策略\",{\"1\":{\"419\":1}}],[\"表示一个区间\",{\"1\":{\"246\":1}}],[\"表示一个键值对\",{\"1\":{\"56\":1}}],[\"表示abc这几个字符可以出现\",{\"1\":{\"246\":1}}],[\"表示当前数组长度\",{\"1\":{\"236\":1}}],[\"表示long的最大值\",{\"1\":{\"229\":1}}],[\"表示类支持接口代表的功能\",{\"1\":{\"219\":1}}],[\"表示类具有的属性\",{\"1\":{\"4\":1}}],[\"表示导入这个包中全部的类\",{\"1\":{\"120\":1}}],[\"表示integer这个类型\",{\"1\":{\"80\":1}}],[\"用来传回信息给用户\",{\"1\":{\"875\":1}}],[\"用来排除传递性依赖\",{\"1\":{\"832\":1}}],[\"用来描述所有状态的state\",{\"1\":{\"416\":1}}],[\"用注解\",{\"1\":{\"660\":1}}],[\"用java代码就能操作数据库的增删改查\",{\"1\":{\"604\":1}}],[\"用的最多的\",{\"1\":{\"549\":1}}],[\"用的就是\",{\"1\":{\"67\":1}}],[\"用户在未登录情况下\",{\"1\":{\"921\":1}}],[\"用户在点击鼠标链接某个万维网文档时\",{\"1\":{\"859\":1}}],[\"用户的发送请求会携带对应的cookie\",{\"1\":{\"913\":1}}],[\"用户的速度设为\",{\"1\":{\"388\":1}}],[\"用户发起的http请求\",{\"1\":{\"873\":1}}],[\"用户可以通过自己输入用户名和密码来登陆\",{\"1\":{\"621\":1}}],[\"用户\",{\"1\":{\"591\":2}}],[\"用户授权\",{\"0\":{\"591\":1}}],[\"用户名\",{\"1\":{\"589\":2,\"590\":1,\"621\":1,\"622\":1,\"623\":4,\"641\":2,\"886\":1,\"888\":1}}],[\"用户漫游模型\",{\"1\":{\"388\":1}}],[\"用户区域划分算法\",{\"1\":{\"387\":1}}],[\"用户关联策略\",{\"1\":{\"387\":1}}],[\"用户是保持静态的\",{\"1\":{\"387\":1}}],[\"用户rkn​​在一段时间ts​内的mos总和为\",{\"1\":{\"384\":1}}],[\"用\",{\"1\":{\"368\":1}}],[\"用|隔开每种类型即可\",{\"1\":{\"267\":1}}],[\"用于下载此文件\",{\"1\":{\"891\":1}}],[\"用于一台主机搭建多个web站点\",{\"1\":{\"864\":1}}],[\"用于唯一区别每个项目\",{\"1\":{\"820\":1}}],[\"用于唯一区分不同实体的的属性\",{\"1\":{\"550\":1}}],[\"用于配置动态sql\",{\"1\":{\"719\":1}}],[\"用于实现分页效果\",{\"1\":{\"652\":1}}],[\"用于定义列是否可以为空\",{\"1\":{\"564\":1}}],[\"用于定义列的值必须满足某些条件\",{\"1\":{\"564\":1}}],[\"用于为列指定默认值\",{\"1\":{\"564\":1}}],[\"用于建立和维护两表之间的关系\",{\"1\":{\"564\":1}}],[\"用于区别于其他实体数据的唯一标记\",{\"1\":{\"551\":1}}],[\"用于存放用户借阅的图书\",{\"1\":{\"670\":1}}],[\"用于存放教师与学生的授课信息\",{\"1\":{\"551\":1}}],[\"用于存放所有教师的数据\",{\"1\":{\"551\":1}}],[\"用于存放所有学生的数据\",{\"1\":{\"551\":1}}],[\"用于解释\",{\"1\":{\"450\":1}}],[\"用于映射\",{\"1\":{\"358\":1}}],[\"用于取代之前比较老旧的httpurlconnection类\",{\"1\":{\"332\":1}}],[\"用于lambda的形参局部变量语法\",{\"0\":{\"330\":1}}],[\"用于便捷操作数组\",{\"1\":{\"275\":1}}],[\"用于规定给定组件必须要出现多少次才能满足匹配的\",{\"1\":{\"246\":1}}],[\"用于计算超大数字\",{\"1\":{\"229\":1}}],[\"用于表示此枚举的作用域\",{\"1\":{\"206\":1}}],[\"用于我们编写自定义的注解\",{\"1\":{\"205\":1}}],[\"用于写入基本数据类型\",{\"1\":{\"129\":1}}],[\"用于指定当前类所处的包的\",{\"1\":{\"120\":1}}],[\"用于简化这样的写法\",{\"1\":{\"90\":1}}],[\"用于记录数组的长\",{\"1\":{\"25\":1}}],[\"用了之后就不能用了\",{\"1\":{\"34\":1}}],[\"遍历foreach\",{\"1\":{\"358\":1}}],[\"遍历打印数组中每一个元素\",{\"1\":{\"241\":1}}],[\"遍历方式也不同\",{\"1\":{\"33\":1}}],[\"遍历当前元素\",{\"1\":{\"32\":1}}],[\"向客户端发请求\",{\"1\":{\"537\":1}}],[\"向map中添加新的映射关系\",{\"1\":{\"56\":1}}],[\"向后继续寻找结点\",{\"1\":{\"33\":1}}],[\"向集合中添加元素\",{\"1\":{\"23\":1}}],[\"移动指针\",{\"1\":{\"33\":1}}],[\"移除最长时间不被使用的对象\",{\"1\":{\"701\":1}}],[\"移除\",{\"1\":{\"84\":1}}],[\"移除其映射关系\",{\"1\":{\"56\":1}}],[\"移除队首元素\",{\"1\":{\"43\":1}}],[\"移除上一个被遍历的元素\",{\"1\":{\"32\":1}}],[\"移除指定位置上的元素\",{\"1\":{\"24\":1}}],[\"移除给定集合中出现的所有元素\",{\"1\":{\"23\":1}}],[\"移除成功返回true\",{\"1\":{\"23\":3}}],[\"实体类字段名称与数据库不同\",{\"0\":{\"715\":1}}],[\"实体类中定义的属性名称和我们数据库中的名称不一样\",{\"1\":{\"652\":1}}],[\"实体属性为实体类\",{\"1\":{\"670\":1}}],[\"实体属性为列表\",{\"1\":{\"670\":1}}],[\"实体或是属性之间可以具有一定的联系\",{\"1\":{\"550\":1}}],[\"实现重定向很简单\",{\"1\":{\"899\":1}}],[\"实现登录功能\",{\"0\":{\"889\":1}}],[\"实现登陆与sql注入攻击\",{\"0\":{\"621\":1}}],[\"实现简单登录功能\",{\"0\":{\"887\":1}}],[\"实现多服务器缓存共用才是最终解决方案\",{\"1\":{\"705\":1}}],[\"实现批量处理\",{\"0\":{\"692\":1}}],[\"实现包的分离管理\",{\"0\":{\"304\":1}}],[\"实现一个consumer\",{\"1\":{\"297\":1}}],[\"实现接口时\",{\"1\":{\"219\":1}}],[\"实现接口\",{\"1\":{\"219\":1}}],[\"实现的\",{\"1\":{\"58\":1}}],[\"实现用例\",{\"0\":{\"33\":1}}],[\"实际运行好像是可以的\",{\"1\":{\"691\":1}}],[\"实际不常用\",{\"1\":{\"442\":1}}],[\"实际意义的解释\",{\"1\":{\"422\":1}}],[\"实际意义是\",{\"1\":{\"422\":1}}],[\"实际返回的\",{\"1\":{\"371\":1}}],[\"实际上http的内容会作为tcp协议的报文被封装\",{\"1\":{\"859\":1}}],[\"实际上域名最后会被解析为ip地址进行访问\",{\"1\":{\"859\":1}}],[\"实际上已经转换为对应的代码了\",{\"1\":{\"833\":1}}],[\"实际上jul也可以通过进行配置文件来规定日志打印器的一些默认值\",{\"1\":{\"756\":1}}],[\"实际上java\",{\"1\":{\"321\":1}}],[\"实际上logger还会通过名称进行分级\",{\"1\":{\"747\":1}}],[\"实际上每一个handler都有一个formatter对象\",{\"1\":{\"738\":1}}],[\"实际上每个级别都有一个对应的方法用于打印\",{\"1\":{\"727\":1}}],[\"实际上mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象\",{\"1\":{\"658\":1}}],[\"实际上mybatis也是通过preparedstatement首先进行一次预编译\",{\"1\":{\"648\":1}}],[\"实际上main就是一个函数\",{\"1\":{\"5\":1}}],[\"实际上idea就是一个java程序\",{\"1\":{\"605\":1}}],[\"实际上书籍编号依赖于借阅编号\",{\"1\":{\"555\":1}}],[\"实际上会有一个缓冲区用于数据的发送和接收\",{\"1\":{\"538\":1}}],[\"实际上会直接使用默认的类型\",{\"1\":{\"16\":1}}],[\"实际上它就是一个tcp连接的建立过程\",{\"1\":{\"536\":1}}],[\"实际上它就是被作为一个模块单独存在\",{\"1\":{\"304\":1}}],[\"实际上我们的xml配置中所有配置项都可以以configuration对象的形式进行配置\",{\"1\":{\"721\":1}}],[\"实际上我们的集合类都是支持使用foreach语法\",{\"1\":{\"30\":1}}],[\"实际上我们也可以直接在\",{\"1\":{\"719\":1}}],[\"实际上我们可以把用不到的类库排除掉\",{\"1\":{\"303\":1}}],[\"实际上很多功能我们并不会用到\",{\"1\":{\"303\":1}}],[\"实际上是main类中的lambda$main$0\",{\"1\":{\"289\":1}}],[\"实际上正则表达式内容非常多\",{\"1\":{\"246\":1}}],[\"实际上实现接口更像是一个类的功能列表\",{\"1\":{\"219\":1}}],[\"实际上接口的目标就是将类所具有某些的行为抽象出来\",{\"1\":{\"219\":1}}],[\"实际上类最开始是由bootstarpclassloader进行加载\",{\"1\":{\"198\":1}}],[\"实际上类锁也是对象锁\",{\"1\":{\"155\":1}}],[\"实际上锁就是依附于对象存在的\",{\"1\":{\"161\":1}}],[\"实际上synchronized是一种悲观锁\",{\"1\":{\"155\":1}}],[\"实际上只执行了一次\",{\"1\":{\"154\":1}}],[\"实际上只要是实现了迭代器接口的类\",{\"1\":{\"36\":1}}],[\"实际上一个java程序启动后\",{\"1\":{\"138\":1}}],[\"实际上这些是maven的一些插件\",{\"1\":{\"851\":1}}],[\"实际上这些内容都是http协议规定的请求头内容\",{\"1\":{\"544\":1}}],[\"实际上这种操作完全可以浓缩为一个sql语句\",{\"1\":{\"694\":1}}],[\"实际上这种模式是父类filterinputstream提供的规范\",{\"1\":{\"107\":1}}],[\"实际上这里跟我们之前的一对一非常类似\",{\"1\":{\"672\":1}}],[\"实际上这里面就是方法体\",{\"1\":{\"257\":1}}],[\"实际上这是classloader的双亲委派机制在保护java程序的正常运行\",{\"1\":{\"198\":1}}],[\"实际上这个表就是一个存放头结点的数组+若干结点\",{\"1\":{\"58\":1}}],[\"实际上进行i\",{\"1\":{\"107\":1}}],[\"实际上在web应用程序运行时\",{\"1\":{\"872\":1}}],[\"实际上在jul的这类内部也有着对应的配置处理操作\",{\"1\":{\"756\":1}}],[\"实际上在java中并不是真的有泛型类型\",{\"1\":{\"16\":1}}],[\"实际上在上述的第二阶段\",{\"1\":{\"628\":1}}],[\"实际上在之前我们如果不希望别人继承我们的类\",{\"1\":{\"346\":1}}],[\"实际上在我们的开发中\",{\"1\":{\"80\":1}}],[\"实际上对应类型的集合类有可能会存放其他类型的值\",{\"1\":{\"80\":1}}],[\"实际上最后只要是object的实现类都可以保存到集合类中\",{\"1\":{\"80\":1}}],[\"实际上\",{\"1\":{\"71\":1,\"142\":1,\"154\":2,\"193\":1,\"294\":1,\"550\":1,\"616\":1,\"702\":1,\"755\":1,\"859\":1,\"871\":1,\"873\":1,\"920\":1,\"926\":1}}],[\"实际上用的就是我们的\",{\"1\":{\"67\":1}}],[\"实际上底层大致结构跟我们之前学习的差不多\",{\"1\":{\"58\":1}}],[\"实际上就跟浏览器访问类似\",{\"1\":{\"333\":1}}],[\"实际上就是我们之前的开发模式\",{\"1\":{\"311\":1}}],[\"实际上就是我们对run\",{\"1\":{\"289\":1}}],[\"实际上就是传统java\",{\"1\":{\"306\":1}}],[\"实际上就是存放的映射关系\",{\"1\":{\"58\":1}}],[\"实际上就像这样\",{\"1\":{\"15\":1}}],[\"实际上编译之后会修改为\",{\"1\":{\"30\":1}}],[\"实际上泛型方法在很多工具类中也有\",{\"1\":{\"14\":1}}],[\"实际传入的参数是一个字符串类型的值\",{\"1\":{\"14\":1}}],[\"||\",{\"1\":{\"59\":4,\"84\":2}}],[\"|\",{\"0\":{\"76\":1,\"232\":2,\"495\":1},\"1\":{\"32\":2,\"111\":1,\"131\":1,\"133\":1,\"155\":1,\"161\":1,\"186\":1,\"267\":2,\"275\":3,\"616\":1,\"735\":2,\"768\":6}}],[\"可选依赖\",{\"0\":{\"842\":1}}],[\"可见单元测试对于开发的重要性\",{\"1\":{\"773\":1}}],[\"可见\",{\"1\":{\"688\":1,\"700\":1,\"735\":1}}],[\"可见性\",{\"1\":{\"121\":1}}],[\"可重复读\",{\"1\":{\"599\":1}}],[\"可知\",{\"1\":{\"383\":1}}],[\"可变\",{\"1\":{\"371\":1}}],[\"可变长参数\",{\"0\":{\"241\":1}}],[\"可访问性的控制\",{\"1\":{\"304\":1}}],[\"可是消费者消费的产品是生产者生产的\",{\"1\":{\"174\":1}}],[\"可拆分迭代器\",{\"1\":{\"173\":1}}],[\"可运行\",{\"1\":{\"143\":1}}],[\"可写可不写\",{\"1\":{\"120\":1}}],[\"可能我们并不希望某些依赖直接被项目连带引入\",{\"1\":{\"842\":1}}],[\"可能我们并不想开启其中某个测试用例\",{\"1\":{\"777\":1}}],[\"可能在导入依赖时会出现卡顿等问题\",{\"1\":{\"827\":1}}],[\"可能还是得我们自己编写一个自定义的formatter才行\",{\"1\":{\"768\":1}}],[\"可能有很多个名字为test的标签\",{\"1\":{\"636\":1}}],[\"可能有些库并不是java\",{\"1\":{\"306\":1}}],[\"可能并不是所有的类我们都希望能够被继承\",{\"1\":{\"346\":1}}],[\"可能给进来的a或是b为null\",{\"1\":{\"343\":1}}],[\"可能字符串中包含了很多需要转义的字符\",{\"1\":{\"341\":1}}],[\"可能高等数学这门课是以数字成绩进行结算\",{\"1\":{\"280\":1}}],[\"可能会一个一个地提交\",{\"1\":{\"688\":1}}],[\"可能会同时拿到同样的值\",{\"1\":{\"154\":1}}],[\"可能会创建各种各样的类\",{\"1\":{\"120\":1}}],[\"可能会出现一些莫名其妙的红标\",{\"1\":{\"719\":1}}],[\"可能会出现各自的缓存内容不同步的问题\",{\"1\":{\"705\":1}}],[\"可能会出现无法预知的错误\",{\"1\":{\"192\":1}}],[\"可能会出现\",{\"1\":{\"90\":1}}],[\"可能会是乱序的\",{\"1\":{\"57\":1}}],[\"可能是链式存储\",{\"1\":{\"31\":1}}],[\"可以访问该cookie的域名\",{\"1\":{\"909\":1}}],[\"可以访问所有其他模块提供的类\",{\"1\":{\"306\":1}}],[\"可以动态显示\",{\"1\":{\"893\":1}}],[\"可以一直使用\",{\"1\":{\"827\":1}}],[\"可以一次直接读取全部数据\",{\"1\":{\"91\":1}}],[\"可以配置idea自带的maven插件远程仓库镜像地址\",{\"1\":{\"827\":1}}],[\"可以自行搭建私服\",{\"1\":{\"826\":1}}],[\"可以自由更换\",{\"1\":{\"629\":1}}],[\"可以快速完成导入\",{\"1\":{\"817\":1}}],[\"可以帮助我们做\",{\"1\":{\"817\":1}}],[\"可以实现批量操作\",{\"1\":{\"692\":1}}],[\"可以彻底摆脱这种痛苦\",{\"1\":{\"689\":1}}],[\"可以嵌套但不能交叉嵌套\",{\"1\":{\"634\":1}}],[\"可以但不必须包含一个头部声明\",{\"1\":{\"634\":1}}],[\"可以理解在标题栏\",{\"1\":{\"614\":1}}],[\"可以理解为\",{\"1\":{\"219\":1}}],[\"可以用接口来简化\",{\"1\":{\"659\":1}}],[\"可以用java来写不同类型的可执行文件\",{\"1\":{\"604\":1}}],[\"可以用来衡量一个状态的价值\",{\"1\":{\"414\":1}}],[\"可以用来检查一个串是否含有某种子串\",{\"1\":{\"246\":1}}],[\"可以叠着使用\",{\"1\":{\"586\":1}}],[\"可以存储任意字符串\",{\"1\":{\"563\":1}}],[\"可以存在多个case\",{\"1\":{\"340\":1}}],[\"可以根据对各个状态的重要程度进行选择\",{\"1\":{\"526\":1}}],[\"可以最大化一个确定的常数指标\",{\"1\":{\"522\":1}}],[\"可以最开始均初始化为\",{\"1\":{\"421\":1}}],[\"可以描述为\",{\"1\":{\"522\":1}}],[\"可以写成\",{\"1\":{\"508\":1}}],[\"可以写入多个\",{\"1\":{\"94\":1}}],[\"可以提高存储效率\",{\"1\":{\"505\":1}}],[\"可以参考\",{\"1\":{\"478\":1}}],[\"可以平衡\",{\"1\":{\"461\":1}}],[\"可以拆分为多个\",{\"1\":{\"455\":1}}],[\"可以互相转化\",{\"1\":{\"422\":1}}],[\"可以得到一个cursor对象\",{\"1\":{\"653\":1}}],[\"可以得到一个序列v0​\",{\"1\":{\"421\":1}}],[\"可以得到一个非常规范的结果\",{\"1\":{\"25\":1}}],[\"可以求解\",{\"1\":{\"419\":1}}],[\"可以粗步衡量一个策略的好坏\",{\"1\":{\"393\":1}}],[\"可以忽略\",{\"1\":{\"384\":1}}],[\"可以表示为\",{\"1\":{\"383\":1,\"509\":1}}],[\"可以表示同样的一组元素\",{\"1\":{\"22\":1}}],[\"可以减轻无人机对用户接收到的干扰\",{\"1\":{\"383\":1}}],[\"可以使用简单的\",{\"1\":{\"633\":1}}],[\"可以使用\",{\"1\":{\"359\":1,\"371\":1}}],[\"可以使用方括号\",{\"1\":{\"246\":1}}],[\"可以执行非常复杂的查找\",{\"1\":{\"356\":1}}],[\"可以基于普通类\",{\"1\":{\"347\":1}}],[\"可以说极大地方便了我们的编码\",{\"1\":{\"340\":1}}],[\"可以不指定版本号\",{\"1\":{\"843\":1}}],[\"可以不用一次一次地提交\",{\"1\":{\"615\":1}}],[\"可以不用添加小括号\",{\"1\":{\"290\":1}}],[\"可以不加分号\",{\"1\":{\"316\":1}}],[\"可以正常运行\",{\"1\":{\"311\":1}}],[\"可以由我们自己指定排序规则\",{\"1\":{\"292\":1}}],[\"可以将查询结果以一个map的形式表示\",{\"1\":{\"653\":1}}],[\"可以将其视为之前匿名内部类写法的一种缩短\",{\"1\":{\"289\":1}}],[\"可以将复制一个完全一样的对象出来\",{\"1\":{\"215\":1}}],[\"可以对\",{\"1\":{\"275\":1,\"817\":1}}],[\"可以对列表中每个元素都进行处理\",{\"1\":{\"24\":1}}],[\"可以简写为\",{\"1\":{\"267\":1}}],[\"可以只跟\",{\"1\":{\"267\":1}}],[\"可以交给\",{\"1\":{\"267\":1}}],[\"可以有限\",{\"1\":{\"393\":1}}],[\"可以有多个\",{\"1\":{\"358\":1}}],[\"可以有多个方法\",{\"1\":{\"257\":1,\"290\":1}}],[\"可以有其他方式判断类型\",{\"1\":{\"186\":1}}],[\"可以通过使用cookie来实现记住我功能\",{\"1\":{\"910\":1}}],[\"可以通过getservletcontext\",{\"1\":{\"901\":1}}],[\"可以通过它来判断dml语句是否执行成功\",{\"1\":{\"608\":1}}],[\"可以通过连接对象来创建一个statement用于执行sql语句\",{\"1\":{\"607\":1}}],[\"可以通过\",{\"1\":{\"440\":1,\"779\":1}}],[\"可以通过contraction\",{\"1\":{\"432\":1}}],[\"可以通过class对象来创建对象\",{\"1\":{\"191\":1}}],[\"可以通过设置将episodic\",{\"1\":{\"393\":1}}],[\"可以通过反编译字节码看看它到底是什么\",{\"1\":{\"365\":1}}],[\"可以通过这个成员内部类又创建出更多对象\",{\"1\":{\"251\":1}}],[\"可以到\",{\"1\":{\"246\":1}}],[\"可以匹配\",{\"1\":{\"246\":1}}],[\"可以保存一个2字节的unicode字符\",{\"1\":{\"243\":1}}],[\"可以传入\",{\"1\":{\"241\":1}}],[\"可以是\",{\"1\":{\"529\":1}}],[\"可以是标量\",{\"1\":{\"475\":1}}],[\"可以是跑步\",{\"1\":{\"221\":1}}],[\"可以是相对路径\",{\"1\":{\"98\":1}}],[\"可以获取到父类的class对象\",{\"1\":{\"186\":1}}],[\"可以给他传一个时间参数进去的\",{\"1\":{\"161\":1}}],[\"可以判断线程是否存在中断标志\",{\"1\":{\"144\":1}}],[\"可以节省数据空间占用以及减少序列化时间\",{\"1\":{\"133\":1}}],[\"可以返回之前标记过的位置\",{\"1\":{\"108\":1}}],[\"可以返回一个备选的返回值\",{\"1\":{\"57\":1}}],[\"可以更好地管理和操作硬盘上的文件\",{\"1\":{\"98\":1}}],[\"可以直接被其他项目导入使用\",{\"1\":{\"853\":1}}],[\"可以直接添加final关键字\",{\"1\":{\"346\":1}}],[\"可以直接通过\",{\"1\":{\"275\":1}}],[\"可以直接使用此注解来快速注册一个servlet\",{\"1\":{\"877\":1}}],[\"可以直接使用其名称\",{\"1\":{\"648\":1}}],[\"可以直接使用\",{\"1\":{\"359\":1,\"371\":1}}],[\"可以直接使用一个\",{\"1\":{\"280\":1}}],[\"可以直接使用一个while循环来完成\",{\"1\":{\"91\":1}}],[\"可以直接使用lambda表达式\",{\"1\":{\"258\":1}}],[\"可以直接省去花括号和return关键字\",{\"1\":{\"257\":1}}],[\"可以直接写入一个字符串\",{\"1\":{\"113\":1}}],[\"可以直接写入内容\",{\"1\":{\"92\":1}}],[\"可以直接将file作为参数传入字节流或是字符流\",{\"1\":{\"98\":1}}],[\"可以跳过指定数量的字节\",{\"1\":{\"91\":1}}],[\"可以极大提高java程序员的生产力\",{\"1\":{\"71\":1}}],[\"可以让你以一种声明的方式处理数据\",{\"1\":{\"71\":1}}],[\"可以在浏览器中保存一些信息\",{\"1\":{\"907\":1}}],[\"可以在配置文件中修改\",{\"1\":{\"864\":1}}],[\"可以在这里进行下载\",{\"1\":{\"628\":1}}],[\"可以在方法中定义\",{\"1\":{\"253\":1}}],[\"可以在\",{\"1\":{\"46\":1,\"367\":1}}],[\"可以看到这里一共执行了两次sql语句\",{\"1\":{\"669\":1}}],[\"可以看到这个map中确实使用的是id作为key\",{\"1\":{\"653\":1}}],[\"可以看到mybatis确实调用了我们的无参构造方法来构建对象\",{\"1\":{\"658\":1}}],[\"可以看到它本身是实现了iterable接口的\",{\"1\":{\"653\":1}}],[\"可以看到它不仅仅实现了list接口\",{\"1\":{\"42\":1}}],[\"可以看到还是非常方便的\",{\"1\":{\"316\":1}}],[\"可以看到system\",{\"1\":{\"127\":1}}],[\"可以看到跟我们之前的写法是一样的\",{\"1\":{\"58\":1}}],[\"可以看到\",{\"1\":{\"15\":1,\"24\":1,\"25\":2,\"46\":1,\"48\":1,\"58\":1,\"242\":1,\"289\":1,\"303\":1,\"308\":1,\"341\":1,\"677\":1,\"700\":1,\"849\":1}}],[\"可以相同\",{\"1\":{\"8\":1}}],[\"直到有一方主动关闭连接\",{\"1\":{\"859\":1}}],[\"直到有客户端连接为止\",{\"1\":{\"536\":1,\"537\":1}}],[\"直到客户端主动关闭连接\",{\"1\":{\"536\":1}}],[\"直到设置的收敛条件为止\",{\"1\":{\"440\":1}}],[\"直到各个簇的成员没有太大变化\",{\"1\":{\"387\":1}}],[\"直到对应的线程执行resume\",{\"1\":{\"156\":1}}],[\"直到读取完成为止\",{\"1\":{\"94\":1}}],[\"直到完成每一个元素的遍历\",{\"1\":{\"31\":1}}],[\"直接先使用\",{\"1\":{\"926\":1}}],[\"直接转交给get请求处理\",{\"1\":{\"900\":1}}],[\"直接转换打印一气呵成\",{\"1\":{\"297\":1}}],[\"直接跳转到网站的首页\",{\"1\":{\"899\":1}}],[\"直接搜索lombok即可\",{\"1\":{\"825\":1}}],[\"直接填写字符串即可\",{\"1\":{\"725\":1}}],[\"直接清除所有缓存\",{\"1\":{\"704\":1}}],[\"直接得到用户所属的所有书籍信息\",{\"1\":{\"670\":1}}],[\"直接获取实现类\",{\"1\":{\"659\":1}}],[\"直接获取这些图片然后保存到本地吧\",{\"1\":{\"333\":1}}],[\"直接读取实体类\",{\"0\":{\"643\":1}}],[\"直接读取到char\",{\"1\":{\"96\":1}}],[\"直接运行会产生报错\",{\"1\":{\"641\":1}}],[\"直接运行即可\",{\"1\":{\"641\":1}}],[\"直接这样查询会得到两张表的笛卡尔积\",{\"1\":{\"584\":1}}],[\"直接估计的是\",{\"1\":{\"494\":1}}],[\"直接通过\",{\"1\":{\"468\":1}}],[\"直接把consolehandler的默认formatter配置为我们自己的类\",{\"1\":{\"764\":1}}],[\"直接把字段写在括号中\",{\"1\":{\"344\":1}}],[\"直接把要close的变量放进来就行\",{\"1\":{\"333\":1}}],[\"直接写变量名字\",{\"1\":{\"342\":1}}],[\"直接写每个状态的名字即可\",{\"1\":{\"221\":1}}],[\"直接定位\",{\"1\":{\"333\":1}}],[\"直接一句搞定\",{\"1\":{\"318\":1}}],[\"直接输入\",{\"1\":{\"316\":1}}],[\"直接添加open关键字开放整个模块的反射权限\",{\"1\":{\"309\":1}}],[\"直接\",{\"1\":{\"304\":1,\"456\":1}}],[\"直接缩写\",{\"1\":{\"294\":1}}],[\"直接指定一手\",{\"1\":{\"292\":1}}],[\"直接指定值和大小\",{\"1\":{\"235\":1}}],[\"直接作为接口中抽象方法的实现\",{\"1\":{\"258\":2}}],[\"直接判断引用的对象是不是teacher类型\",{\"1\":{\"219\":1}}],[\"直接判断是否为test\",{\"1\":{\"208\":2}}],[\"直接判断是否为这个类型\",{\"1\":{\"186\":1}}],[\"直接int\",{\"1\":{\"219\":1}}],[\"直接==\",{\"1\":{\"216\":1}}],[\"直接编写逻辑\",{\"1\":{\"140\":1}}],[\"直接使用copy方法完成转换\",{\"1\":{\"891\":1}}],[\"直接使用lombok\",{\"1\":{\"643\":1}}],[\"直接使用integer为我们通过好的求和方法\",{\"1\":{\"258\":1}}],[\"直接使用就可以\",{\"1\":{\"121\":1}}],[\"直接使用即可\",{\"1\":{\"120\":1}}],[\"直接做参数\",{\"1\":{\"98\":1}}],[\"直接在mapper中添加\",{\"1\":{\"652\":1}}],[\"直接在方法中创建局部内部类\",{\"1\":{\"253\":1}}],[\"直接在try\",{\"1\":{\"90\":1}}],[\"直接在类中定义变量\",{\"1\":{\"4\":1}}],[\"直接处理原始字节数据\",{\"1\":{\"88\":1}}],[\"直接构造一个默认大小为16负载因子0\",{\"1\":{\"67\":1}}],[\"直接替换为新的\",{\"1\":{\"66\":1}}],[\"直接给予一个比较规则即可\",{\"1\":{\"62\":1}}],[\"直接将本次请求转发给其他servlet进行处理\",{\"1\":{\"900\":1}}],[\"直接将字符串的666\",{\"1\":{\"228\":1}}],[\"直接将数据读取为任意基本数据类型\",{\"1\":{\"129\":1}}],[\"直接将新的容量变成旧的阈值\",{\"1\":{\"60\":1}}],[\"直接将对应位置上的元素替换为给定元素\",{\"1\":{\"24\":1}}],[\"直接结束\",{\"1\":{\"59\":2}}],[\"直接创建一个新的httpclient\",{\"1\":{\"333\":1}}],[\"直接创建一个匿名的接口实现类\",{\"1\":{\"255\":1}}],[\"直接创建文件对象\",{\"1\":{\"98\":1}}],[\"直接创建新的结点连在后面\",{\"1\":{\"59\":1}}],[\"直接创建就行了\",{\"1\":{\"25\":1}}],[\"直接继承过来的方法\",{\"1\":{\"47\":1}}],[\"直接继承自前面介绍的\",{\"1\":{\"24\":1}}],[\"直接返回\",{\"1\":{\"910\":1}}],[\"直接返回true\",{\"1\":{\"36\":1}}],[\"直接返回指针所指元素\",{\"1\":{\"33\":1}}],[\"直接认为就是要删除的对象\",{\"1\":{\"25\":1}}],[\"直接安排了\",{\"1\":{\"14\":1}}],[\"直接赋值\",{\"1\":{\"9\":1}}],[\"各个web应用程序私有的类加载器\",{\"1\":{\"926\":1}}],[\"各个web应用程序共享的类加载器\",{\"1\":{\"926\":1}}],[\"各个线程之间共享程序的内存空间\",{\"1\":{\"138\":1}}],[\"各项操作的结果也是一样的\",{\"1\":{\"25\":1}}],[\"各种属性都是默认值\",{\"1\":{\"9\":1}}],[\"还必须保证应用程序之间的类无法相互访问\",{\"1\":{\"926\":1}}],[\"还原为最开始的http数据\",{\"1\":{\"859\":1}}],[\"还会作用于他的所有子项目\",{\"1\":{\"855\":1}}],[\"还要注意去掉列表最后一个列名的逗号\",{\"1\":{\"689\":1}}],[\"还支持很多种类型的文件\",{\"1\":{\"634\":1}}],[\"还存在preparedstatement\",{\"1\":{\"607\":1}}],[\"还能在视图的基础上\",{\"1\":{\"596\":1}}],[\"还与los的概率有关\",{\"1\":{\"387\":1}}],[\"还需要求解最优策略π\",{\"1\":{\"429\":1}}],[\"还需要考虑所有用户的2d位置\",{\"1\":{\"388\":1}}],[\"还需要一个响应体处理器\",{\"1\":{\"333\":1}}],[\"还需要判断\",{\"1\":{\"84\":1}}],[\"还请各位小伙伴自行探索了\",{\"1\":{\"296\":1}}],[\"还没学异常\",{\"1\":{\"220\":1}}],[\"还体会不到注解带来的快乐\",{\"1\":{\"208\":1}}],[\"还是太过复杂\",{\"1\":{\"918\":1}}],[\"还是以查询所有的用户为例\",{\"1\":{\"711\":1}}],[\"还是同一张q\",{\"1\":{\"387\":1}}],[\"还是\",{\"1\":{\"280\":1,\"427\":1,\"449\":1,\"466\":1}}],[\"还是字段\",{\"1\":{\"208\":1}}],[\"还是编入class文件中\",{\"1\":{\"205\":1}}],[\"还是进行计算\",{\"1\":{\"138\":1}}],[\"还是很方便的\",{\"1\":{\"43\":1}}],[\"还有两个参数\",{\"1\":{\"873\":1}}],[\"还有很多不同类型的结果判断\",{\"1\":{\"790\":1}}],[\"还有很多地方都可以\",{\"1\":{\"296\":1}}],[\"还有数据库的额外开销\",{\"1\":{\"688\":1}}],[\"还有\",{\"1\":{\"321\":1}}],[\"还有我们前面演示的反射\",{\"1\":{\"309\":1}}],[\"还有几个同名的\",{\"1\":{\"208\":1}}],[\"还有一个虚拟主机管理页面\",{\"1\":{\"864\":1}}],[\"还有一个重要的属性\",{\"1\":{\"855\":1}}],[\"还有一个就是包含了所有依赖以及配置了主类的jar文件\",{\"1\":{\"854\":1}}],[\"还有一个比较特殊的选择操作是selectcursor\",{\"1\":{\"653\":1}}],[\"还有一个append方法\",{\"1\":{\"97\":1}}],[\"还有一张用户详细信息的表\",{\"1\":{\"586\":1}}],[\"还有一种就是\",{\"1\":{\"280\":1}}],[\"还有一种set叫做treeset\",{\"1\":{\"50\":1}}],[\"还有其他的实现类\",{\"1\":{\"45\":1}}],[\"还可以做一些其他的事情\",{\"1\":{\"901\":1}}],[\"还可以进行通配符匹配\",{\"1\":{\"878\":1}}],[\"还可以通过alter来修改此列的属性\",{\"1\":{\"568\":1}}],[\"还可以估计q\",{\"1\":{\"455\":1}}],[\"还可以直接从optional中获取被包装的对象\",{\"1\":{\"297\":1}}],[\"还可以获取文件夹内部的文件列表等内容\",{\"1\":{\"98\":1}}],[\"还可以当做其他的数据结构使用\",{\"1\":{\"42\":1}}],[\"还可以定义一些方法来描述同一类的行为\",{\"1\":{\"5\":1}}],[\"还保存指向上一个结点的引用\",{\"1\":{\"25\":1}}],[\"异常判断\",{\"0\":{\"790\":1}}],[\"异常错误信息\",{\"1\":{\"267\":1}}],[\"异常处理\",{\"1\":{\"267\":1}}],[\"异常的处理\",{\"0\":{\"267\":1}}],[\"异常的抛出同样需要创建一个异常对象出来\",{\"1\":{\"266\":1}}],[\"异常对象携带了我们抛出异常时的一些信息\",{\"1\":{\"266\":1}}],[\"异常其实就两大类\",{\"1\":{\"265\":1}}],[\"异常就是不同寻常\",{\"1\":{\"264\":1}}],[\"异常类型\",{\"0\":{\"264\":1}}],[\"异常机制\",{\"0\":{\"263\":1}}],[\"异常\",{\"0\":{\"261\":1},\"1\":{\"25\":1}}],[\"哟唉嘛干你\",{\"1\":{\"25\":2}}],[\"那有没有什么办法将文件的日志打印变成控制台那种格式呢\",{\"1\":{\"737\":1}}],[\"那这时又可以直接使用咱们的动态sql来完成操作了\",{\"1\":{\"694\":1}}],[\"那这接口怎么就出现了一个实现类呢\",{\"1\":{\"659\":1}}],[\"那如果我输入的是以下内容呢\",{\"1\":{\"621\":1}}],[\"那如果我们手动创建一个与jdk包名一样\",{\"1\":{\"198\":1}}],[\"那太简单了吧\",{\"1\":{\"297\":1}}],[\"那作用范围也就只能在方法中了\",{\"1\":{\"253\":1}}],[\"那肯定有人好奇\",{\"1\":{\"659\":1}}],[\"那肯定不相等\",{\"1\":{\"216\":1}}],[\"那肯定是没有的\",{\"1\":{\"57\":1}}],[\"那必须的\",{\"1\":{\"75\":1}}],[\"那就是modules\",{\"1\":{\"855\":1}}],[\"那就是参数了\",{\"1\":{\"251\":1}}],[\"那就直接整除10\",{\"1\":{\"338\":1,\"339\":1}}],[\"那就直接放一个新的结点\",{\"1\":{\"59\":1}}],[\"那就返回supplier提供的另一个optional包装\",{\"1\":{\"323\":1}}],[\"那就执行覆盖操作\",{\"1\":{\"59\":1}}],[\"那要是我们就是想要使用维持顺序的set集合呢\",{\"1\":{\"49\":1}}],[\"那要是此时我们删除对象呢\",{\"1\":{\"25\":1}}],[\"那要是这样写呢\",{\"1\":{\"25\":1}}],[\"那么什么是监听器呢\",{\"1\":{\"922\":1}}],[\"那么添加一句打印语句看看\",{\"1\":{\"919\":1}}],[\"那么也就是说\",{\"1\":{\"900\":1}}],[\"那么服务器会发送给我们一个重定向响应\",{\"1\":{\"899\":1}}],[\"那么首先\",{\"1\":{\"864\":1,\"910\":1}}],[\"那么为什么说它本身是无连接的呢\",{\"1\":{\"859\":1}}],[\"那么为空时\",{\"1\":{\"343\":1}}],[\"那么我不仅需要将自己编写的类打包到jar中\",{\"1\":{\"854\":1}}],[\"那么我们将发送一个重定向请求\",{\"1\":{\"913\":1}}],[\"那么我们接着来看请求转发\",{\"1\":{\"900\":1}}],[\"那么我们接着来看其他的文件夹\",{\"1\":{\"864\":1}}],[\"那么我们来想细看看此注解还有什么其他的玩法\",{\"1\":{\"877\":1}}],[\"那么我们来看看\",{\"1\":{\"208\":2}}],[\"那么我们需要添加get请求的相关处理\",{\"1\":{\"910\":1}}],[\"那么我们需要添加一个systempath来指定jar文件的位置\",{\"1\":{\"835\":1}}],[\"那么我们需要在xml中手动编写配置\",{\"1\":{\"658\":1}}],[\"那么我们如何知道每个依赖的坐标呢\",{\"1\":{\"825\":1}}],[\"那么我们如何去检测死锁呢\",{\"1\":{\"156\":1}}],[\"那么我们之前的日志是怎么打印出来的呢\",{\"1\":{\"735\":1}}],[\"那么我们现在需要重写在mybatis的配置文件中进行mapper的配置\",{\"1\":{\"711\":1}}],[\"那么我们原有的sql语句结构就遭到了破坏\",{\"1\":{\"621\":1}}],[\"那么我们原本的sql语句会变为\",{\"1\":{\"621\":1}}],[\"那么我们就可以直接为用户进行登陆\",{\"1\":{\"910\":1}}],[\"那么我们就可以直接从缓存中获取\",{\"1\":{\"699\":1}}],[\"那么我们就可以将学习这个能力\",{\"1\":{\"219\":1}}],[\"那么我们就可以将其重写了\",{\"1\":{\"216\":1}}],[\"那么我们就来尝试创建一个数据库\",{\"1\":{\"551\":1}}],[\"那么我们这边会发送一个ack探测包发到对方\",{\"1\":{\"538\":1}}],[\"那么我们能否创建数组类型的数组呢\",{\"1\":{\"240\":1}}],[\"那么我们也可以给枚举类型添加独有的成员方法\",{\"1\":{\"221\":1}}],[\"那么我们可以尝试获取以下post请求的参数\",{\"1\":{\"900\":1}}],[\"那么我们可以对\",{\"1\":{\"452\":1}}],[\"那么我们可以继续踢皮球\",{\"1\":{\"267\":1}}],[\"那么我们可以将匿名内部类简写为lambda表达式\",{\"1\":{\"257\":1}}],[\"那么我们可以自己手动将class文件加载到jvm中吗\",{\"1\":{\"199\":1}}],[\"那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用\",{\"1\":{\"121\":1}}],[\"那么我们可以使用emptyxxx来快速生成一个只读的空集合\",{\"1\":{\"79\":1}}],[\"那么此依赖是会一起被传递的\",{\"1\":{\"841\":1}}],[\"那么此时两个handler都会生效\",{\"1\":{\"746\":1}}],[\"那么此时就可以开启flushcache属性\",{\"1\":{\"704\":1}}],[\"那么此时就出现了歧义\",{\"1\":{\"120\":1}}],[\"那么此时的\",{\"1\":{\"509\":1}}],[\"那么如何让请求可以顺利地到达对应的servlet\",{\"1\":{\"920\":1}}],[\"那么如何创建一个servlet呢\",{\"1\":{\"871\":1}}],[\"那么如何使用maven来管理依赖呢\",{\"1\":{\"825\":1}}],[\"那么如果我们的路径为\",{\"1\":{\"879\":1}}],[\"那么如果我们并不是能够马上返回\",{\"1\":{\"340\":1}}],[\"那么如果我修改了数据库中的内容\",{\"1\":{\"700\":1}}],[\"那么如果内部类中也定义了同名的变量\",{\"1\":{\"251\":1}}],[\"那么能否有一种简单一点的配置文件呢\",{\"1\":{\"753\":1}}],[\"那么能否实现在对象创建时就为其指定名字\",{\"1\":{\"9\":1}}],[\"那么子级的handler优先进行处理\",{\"1\":{\"746\":1}}],[\"那么同时也需要将父级的handler也进行日志等级配置\",{\"1\":{\"745\":1}}],[\"那么同样可以使用\",{\"1\":{\"216\":1}}],[\"那么你也可以单独在xml中配置一个resultmap\",{\"1\":{\"716\":1}}],[\"那么理想情况下\",{\"1\":{\"705\":1}}],[\"那么之前的缓存就全部失效了\",{\"1\":{\"700\":1}}],[\"那么之前缓存的内容也会跟着失效\",{\"1\":{\"700\":1}}],[\"那么必须同时要满足大于18岁这个条件\",{\"1\":{\"690\":1}}],[\"那么必须告知函数的调用方我们会抛出某个异常\",{\"1\":{\"266\":1}}],[\"那么调用commit方法则不会进行提交\",{\"1\":{\"682\":1}}],[\"那么多对一又该如何查询\",{\"1\":{\"672\":1}}],[\"那么mybatis会选择可用的构造方法来进行构造\",{\"1\":{\"658\":1}}],[\"那么传入的参数就是一个int类型的参数\",{\"1\":{\"648\":1}}],[\"那么所有类型的日志信息都不会被打印了\",{\"1\":{\"729\":1}}],[\"那么所有的操作都会丢失\",{\"1\":{\"623\":1}}],[\"那么所有在方法中可能会抛出的异常都需要注明\",{\"1\":{\"266\":1}}],[\"那么现在\",{\"1\":{\"913\":1,\"921\":1}}],[\"那么现在我们再来添加jdbc和mybatis的依赖\",{\"1\":{\"834\":1}}],[\"那么现在我们来看看\",{\"1\":{\"642\":1}}],[\"那么现在就可以向节点中填写依赖了\",{\"1\":{\"825\":1}}],[\"那么现在就可以将这些数据转换为一个类来进行操作\",{\"1\":{\"616\":1}}],[\"那么现在如果我们需要指定使用的构造方法怎么办呢\",{\"1\":{\"717\":1}}],[\"那么现在执行所有的操作如果在最后不进行commit\",{\"1\":{\"623\":1}}],[\"那么现在该如何去设计这样的一个\",{\"1\":{\"280\":1}}],[\"那么它本身就是一个虚表\",{\"1\":{\"596\":1}}],[\"那么它们的\",{\"1\":{\"84\":1}}],[\"那么被授权的用户还能将已获得的授权继续授权给其他用户\",{\"1\":{\"591\":1}}],[\"那么是否可以等到我们想要的时候再去连接\",{\"1\":{\"538\":1}}],[\"那么是不相等的\",{\"1\":{\"227\":1}}],[\"那么只要求解\",{\"1\":{\"473\":1}}],[\"那么这行代码的意思实际上是将此请求继续传递给下一个过滤器\",{\"1\":{\"920\":1}}],[\"那么这个时候\",{\"1\":{\"899\":1,\"922\":1}}],[\"那么这个测试就应该没有成功通过\",{\"1\":{\"780\":1}}],[\"那么这个自增的主键值我们该如何获取到呢\",{\"1\":{\"679\":1}}],[\"那么这称为\",{\"1\":{\"458\":1}}],[\"那么这些类如果都放在一起的话\",{\"1\":{\"120\":1}}],[\"那么\",{\"1\":{\"442\":1,\"468\":1,\"472\":1,\"710\":1,\"826\":1,\"900\":1,\"910\":1}}],[\"那么无论是谁\",{\"1\":{\"346\":1}}],[\"那么无法重写\",{\"1\":{\"216\":1}}],[\"那么怎么样才可以使用反射呢\",{\"1\":{\"309\":1}}],[\"那么将无法导入\",{\"1\":{\"307\":1}}],[\"那么其他模块是不允许使用反射进行修改的\",{\"1\":{\"305\":1}}],[\"那么其他的对象读取的就是被改变的值\",{\"1\":{\"117\":1}}],[\"那么在使用时\",{\"1\":{\"281\":1}}],[\"那么由于类型不确定\",{\"1\":{\"281\":1}}],[\"那么泛型就变成对应的类型了\",{\"1\":{\"281\":1}}],[\"那么泛型到底是如何实现的呢\",{\"1\":{\"16\":1}}],[\"那么当发生这个异常时\",{\"1\":{\"267\":1}}],[\"那么使用时候\",{\"1\":{\"258\":1}}],[\"那么需要在前面添加外部类型名称\",{\"1\":{\"251\":1}}],[\"那么需要在前面添加外部类型名称test\",{\"1\":{\"251\":1}}],[\"那么需要重新生成一个迭代器对象\",{\"1\":{\"34\":1}}],[\"那么中间就需要产生4个字符串对象出来\",{\"1\":{\"245\":1}}],[\"那么始终都是同一个对象\",{\"1\":{\"244\":1}}],[\"那么始终都会得到同一个对象\",{\"1\":{\"227\":1}}],[\"那么可以省略列名\",{\"1\":{\"571\":1}}],[\"那么可以省去小括号\",{\"1\":{\"257\":1}}],[\"那么可以不用明确\",{\"1\":{\"282\":1}}],[\"那么可以直接明确对应类型\",{\"1\":{\"282\":1}}],[\"那么可以使用\",{\"1\":{\"281\":1}}],[\"那么可以使用this关键字\",{\"1\":{\"7\":1}}],[\"那么可变长参数只能放在最后\",{\"1\":{\"241\":1}}],[\"那么自动装箱的呢\",{\"1\":{\"227\":1}}],[\"那么实现类中不强制要求进行实现\",{\"1\":{\"219\":1}}],[\"那么实际上只是传递了对象的引用\",{\"1\":{\"4\":1}}],[\"那么还有必要去重新加载吗\",{\"1\":{\"926\":1}}],[\"那么还有什么意义呢\",{\"1\":{\"218\":1}}],[\"那么还需要将旧的数组中所有元素全部搬到新的里面去\",{\"1\":{\"60\":1}}],[\"那么对应的xml配置编写为\",{\"1\":{\"658\":1}}],[\"那么对应的损失函数求解为\",{\"1\":{\"516\":1}}],[\"那么对应返回的就是确定的类型\",{\"1\":{\"186\":1}}],[\"那么对于随机变量x的估计可以为\",{\"1\":{\"449\":1}}],[\"那么对象构造好之后\",{\"1\":{\"9\":1}}],[\"那么对象的属性都会存在初始值\",{\"1\":{\"4\":1}}],[\"那么有可能两个线程同一时间都执行同一个方法\",{\"1\":{\"173\":1}}],[\"那么有没有下界呢\",{\"1\":{\"15\":1}}],[\"那么线程将一直处于挂起状态\",{\"1\":{\"156\":1}}],[\"那么通过这个类创建的所有对象\",{\"1\":{\"117\":1}}],[\"那么fill操作不会生效\",{\"1\":{\"78\":1}}],[\"那么直接给到\",{\"1\":{\"60\":1}}],[\"那么直接扩容到最小的大小\",{\"1\":{\"25\":1}}],[\"那么就讲cookie存储到本地\",{\"1\":{\"910\":1}}],[\"那么就有人提问了\",{\"1\":{\"835\":1}}],[\"那么就必须要实现不同应用程序之间的隔离\",{\"1\":{\"926\":1}}],[\"那么就必须通过这三个元素来定位我们的项目\",{\"1\":{\"820\":1}}],[\"那么就必须逐一进行修改\",{\"1\":{\"556\":1}}],[\"那么就不会再去远程仓库下载了\",{\"1\":{\"826\":1}}],[\"那么就不拼接里面的内容到原本的sql中\",{\"1\":{\"690\":1}}],[\"那么就不能修改了\",{\"1\":{\"281\":1}}],[\"那么就会使用此servlet进行处理\",{\"1\":{\"879\":1}}],[\"那么就会告诉我们找不到合适的构造方法\",{\"1\":{\"658\":1}}],[\"那么就会出现这种情况\",{\"1\":{\"80\":1}}],[\"那么就需要一起下载我们项目的依赖\",{\"1\":{\"832\":1}}],[\"那么就需要在每个类都去编写获取logger的代码\",{\"1\":{\"766\":1}}],[\"那么就需要按照http协议的规则\",{\"1\":{\"544\":1}}],[\"那么就需要创造一个对象\",{\"1\":{\"251\":1}}],[\"那么就类型转换\",{\"1\":{\"342\":1}}],[\"那么就相当于到顶层了\",{\"1\":{\"267\":1}}],[\"那么就是一个未命名模块\",{\"1\":{\"311\":1}}],[\"那么就是b的\",{\"1\":{\"251\":1}}],[\"那么就是a的\",{\"1\":{\"251\":1}}],[\"那么就是不同的对象了\",{\"1\":{\"244\":1}}],[\"那么就像我们把成员变量访问权限变成私有一样\",{\"1\":{\"251\":1}}],[\"那么就可以使用\",{\"1\":{\"793\":1}}],[\"那么就可以像这样\",{\"1\":{\"65\":1}}],[\"那么就可以直接使用迭代器来完成\",{\"1\":{\"33\":1}}],[\"那么就进行扩容\",{\"1\":{\"60\":1}}],[\"那么就开始扩容\",{\"1\":{\"60\":1}}],[\"那么就转换为红黑树来存放\",{\"1\":{\"59\":1}}],[\"那么键就是integer类型的\",{\"1\":{\"56\":1}}],[\"那么会此表单信息\",{\"1\":{\"910\":1}}],[\"那么会不会传递给依赖于模块module\",{\"1\":{\"308\":1}}],[\"那么会按照未命名模块进行处理\",{\"1\":{\"306\":1}}],[\"那么会直接返回已经提前创建好的对象\",{\"1\":{\"227\":1}}],[\"那么会直接抛出类型转换异常\",{\"1\":{\"80\":1}}],[\"那么会覆盖掉之前的\",{\"1\":{\"57\":1}}],[\"那么会失败\",{\"1\":{\"47\":1}}],[\"那么会抛出异常\",{\"1\":{\"43\":2}}],[\"那么会从默认类型变成上界定义的类型\",{\"1\":{\"16\":1}}],[\"那么集合中就是相同的两个对象\",{\"1\":{\"25\":1}}],[\"那么忽略这个元素\",{\"1\":{\"23\":1}}],[\"那么编译之后\",{\"1\":{\"16\":1}}],[\"那么限定了上界后\",{\"1\":{\"15\":1}}],[\"那么既然泛型有上界\",{\"1\":{\"15\":1}}],[\"那么肯定应该排在前面\",{\"1\":{\"14\":1}}],[\"那么t就会自动变成\",{\"1\":{\"14\":1}}],[\"那么默认会认为这个变量是一个\",{\"1\":{\"281\":1}}],[\"那么默认情况下可以不使用this关键字来明确表示当前对象\",{\"1\":{\"7\":1}}],[\"那么默认是null\",{\"1\":{\"4\":1}}],[\"那么默认是统一为0\",{\"1\":{\"4\":1}}],[\"那么创建对象之后能否直接访问呢\",{\"1\":{\"4\":1}}],[\"时间等\",{\"1\":{\"765\":1}}],[\"时间\",{\"1\":{\"738\":1}}],[\"时mybatis就会自动调用类中对应的get方法来获取结果\",{\"1\":{\"678\":1}}],[\"时的平均reward\",{\"1\":{\"527\":1}}],[\"时wk​→w∗\",{\"1\":{\"478\":1}}],[\"时\",{\"1\":{\"25\":1,\"61\":1,\"215\":1,\"622\":1,\"873\":1}}],[\"上传\",{\"0\":{\"892\":1}}],[\"上传和下载文件\",{\"0\":{\"890\":1}}],[\"上面的路径表示\",{\"1\":{\"878\":1}}],[\"上午\",{\"1\":{\"736\":1,\"746\":2}}],[\"上行\",{\"1\":{\"387\":1}}],[\"上来就是截断状态\",{\"1\":{\"322\":1}}],[\"上\",{\"1\":{\"217\":1}}],[\"上下文切换速度也高于进程\",{\"1\":{\"138\":1}}],[\"上头啊\",{\"1\":{\"25\":1}}],[\"上界number\",{\"1\":{\"16\":1}}],[\"上界\",{\"1\":{\"15\":1}}],[\"科技与狠活\",{\"1\":{\"25\":1}}],[\"<label>\",{\"1\":{\"886\":2,\"910\":1}}],[\"<hr>\",{\"1\":{\"886\":1,\"891\":1,\"893\":1}}],[\"<h1>登录到系统<\",{\"1\":{\"886\":1}}],[\"<h1>恭喜你解锁了全新玩法<\",{\"1\":{\"876\":1,\"881\":1}}],[\"<form\",{\"1\":{\"886\":1,\"892\":1}}],[\"<foreach\",{\"1\":{\"693\":1,\"694\":1}}],[\"<br>\",{\"1\":{\"893\":1}}],[\"<button\",{\"1\":{\"893\":1}}],[\"<button>上传文件<\",{\"1\":{\"892\":1}}],[\"<button>登录<\",{\"1\":{\"886\":1}}],[\"<build>\",{\"1\":{\"854\":1}}],[\"<body>\",{\"1\":{\"886\":1}}],[\"<role\",{\"1\":{\"864\":2}}],[\"<result\",{\"1\":{\"652\":2,\"667\":5,\"668\":2,\"670\":3,\"671\":2,\"672\":5,\"715\":1}}],[\"<resultmap\",{\"1\":{\"652\":1,\"658\":1,\"666\":1,\"667\":1,\"668\":1,\"670\":1,\"671\":1,\"672\":2,\"715\":1}}],[\"<路径>\",{\"1\":{\"859\":1}}],[\"<端口>\",{\"1\":{\"859\":1}}],[\"<主机>\",{\"1\":{\"859\":1}}],[\"<协议>\",{\"1\":{\"859\":1}}],[\"<goal>single<\",{\"1\":{\"854\":1}}],[\"<goals>\",{\"1\":{\"854\":1}}],[\"<groupid>log4j<\",{\"1\":{\"842\":1}}],[\"<groupid>javax\",{\"1\":{\"835\":1}}],[\"<groupid>mysql<\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"<groupid>org\",{\"1\":{\"825\":1,\"834\":2,\"841\":1,\"842\":2,\"843\":1,\"849\":1,\"850\":5,\"888\":1}}],[\"<groupid>commons\",{\"1\":{\"891\":1}}],[\"<groupid>com\",{\"1\":{\"819\":1,\"840\":2,\"843\":1}}],[\"<execution>\",{\"1\":{\"854\":1}}],[\"<executions>\",{\"1\":{\"854\":1}}],[\"<exclusion>\",{\"1\":{\"843\":1}}],[\"<exclusions>\",{\"1\":{\"843\":1}}],[\"<environment\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"<environments\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"<version>2\",{\"1\":{\"835\":1,\"891\":1}}],[\"<version>3\",{\"1\":{\"834\":1,\"841\":1,\"850\":1,\"854\":1,\"888\":1}}],[\"<version>8\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"<version>5\",{\"1\":{\"834\":1,\"850\":2}}],[\"<version>1\",{\"1\":{\"819\":1,\"825\":1,\"840\":2,\"842\":3,\"843\":1,\"849\":1,\"850\":1}}],[\"<url\",{\"1\":{\"871\":4}}],[\"<url>https\",{\"1\":{\"827\":1}}],[\"<user\",{\"1\":{\"864\":2}}],[\"<update\",{\"1\":{\"680\":1}}],[\"<mirrorof>central<\",{\"1\":{\"827\":1}}],[\"<mirror>\",{\"1\":{\"827\":1}}],[\"<mainclass>com\",{\"1\":{\"854\":1}}],[\"<manifest>\",{\"1\":{\"854\":1}}],[\"<maven\",{\"1\":{\"819\":2,\"849\":2}}],[\"<mappers>\",{\"1\":{\"643\":1,\"659\":1,\"711\":2,\"834\":1,\"888\":1}}],[\"<mapper\",{\"1\":{\"643\":2,\"659\":2,\"711\":1,\"834\":1,\"888\":1}}],[\"<modelversion>4\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"<systempath>c\",{\"1\":{\"835\":1}}],[\"<scope>provided<\",{\"1\":{\"850\":2}}],[\"<scope>system<\",{\"1\":{\"835\":1}}],[\"<scope>test<\",{\"1\":{\"834\":1,\"850\":2}}],[\"<script>\",{\"1\":{\"719\":1,\"893\":1}}],[\"<session\",{\"1\":{\"914\":2}}],[\"<servlet\",{\"1\":{\"871\":8}}],[\"<servlet>\",{\"1\":{\"871\":1}}],[\"<setting\",{\"1\":{\"669\":1,\"768\":2,\"834\":3}}],[\"<settings>\",{\"1\":{\"669\":1,\"834\":1}}],[\"<select\",{\"1\":{\"643\":1,\"648\":4,\"650\":1,\"651\":1,\"652\":1,\"653\":2,\"658\":1,\"659\":3,\"660\":1,\"666\":1,\"668\":2,\"671\":2,\"672\":3,\"690\":1,\"691\":1,\"703\":1,\"704\":1,\"712\":1,\"719\":1}}],[\"<sex>男<\",{\"1\":{\"634\":1}}],[\"<optional>true<\",{\"1\":{\"842\":4}}],[\"<otherwise>\",{\"1\":{\"691\":1}}],[\"<outer>\",{\"1\":{\"634\":1}}],[\"<when\",{\"1\":{\"691\":2}}],[\"<cache\",{\"1\":{\"701\":2}}],[\"<choose>\",{\"1\":{\"691\":1}}],[\"<collection\",{\"1\":{\"670\":1,\"671\":1}}],[\"<context\",{\"1\":{\"903\":1}}],[\"<constructor>\",{\"1\":{\"658\":2,\"717\":1}}],[\"<configuration>\",{\"1\":{\"641\":1,\"834\":1,\"854\":1,\"888\":1}}],[\"<code>run<\",{\"1\":{\"139\":2}}],[\"<code>runnable<\",{\"1\":{\"139\":1}}],[\"<if\",{\"1\":{\"690\":1,\"719\":2}}],[\"<input\",{\"1\":{\"886\":2,\"892\":1,\"910\":1}}],[\"<insert\",{\"1\":{\"678\":1,\"679\":1,\"694\":1,\"714\":1}}],[\"<inner\",{\"1\":{\"634\":1}}],[\"<id>make\",{\"1\":{\"854\":1}}],[\"<id>aliyunmaven<\",{\"1\":{\"827\":1}}],[\"<id\",{\"1\":{\"667\":2,\"668\":1,\"670\":2,\"671\":1,\"672\":3,\"715\":1}}],[\"<idarg\",{\"1\":{\"658\":1,\"717\":1}}],[\"<phase>package<\",{\"1\":{\"854\":1}}],[\"<plugin>\",{\"1\":{\"854\":1}}],[\"<plugins>\",{\"1\":{\"854\":1}}],[\"<param\",{\"1\":{\"903\":2}}],[\"<parent>\",{\"1\":{\"849\":1}}],[\"<packaging>pom<\",{\"1\":{\"855\":1}}],[\"<package\",{\"1\":{\"649\":1,\"711\":1,\"834\":1}}],[\"<properties>\",{\"1\":{\"819\":1,\"849\":1}}],[\"<property\",{\"1\":{\"641\":4,\"834\":4,\"888\":4}}],[\"<project\",{\"1\":{\"819\":2,\"840\":1,\"849\":1}}],[\"<p>\",{\"1\":{\"139\":1}}],[\"<div\",{\"1\":{\"893\":1}}],[\"<div>\",{\"1\":{\"886\":3,\"892\":2,\"910\":1}}],[\"<descriptorref>jar\",{\"1\":{\"854\":1}}],[\"<descriptorrefs>\",{\"1\":{\"854\":1}}],[\"<desc>怎么又在玩电动啊<\",{\"1\":{\"634\":1}}],[\"<dependencymanagement>\",{\"1\":{\"850\":2}}],[\"<dependency>\",{\"1\":{\"825\":1,\"834\":3,\"835\":1,\"840\":1,\"841\":1,\"842\":3,\"843\":1,\"850\":6,\"888\":2,\"891\":1}}],[\"<dependencies>\",{\"1\":{\"825\":1,\"841\":1,\"850\":4}}],[\"<delete\",{\"1\":{\"681\":1,\"693\":1}}],[\"<datasource\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"<name>阿里云公共仓库<\",{\"1\":{\"827\":1}}],[\"<name>阿伟<\",{\"1\":{\"634\":1}}],[\"<name><\",{\"1\":{\"635\":1}}],[\"<∞\",{\"1\":{\"472\":1}}],[\"<addclasspath>true<\",{\"1\":{\"854\":1}}],[\"<archive>\",{\"1\":{\"854\":1}}],[\"<artifactid>commons\",{\"1\":{\"891\":1}}],[\"<artifactid>childmodel<\",{\"1\":{\"849\":1}}],[\"<artifactid>maven\",{\"1\":{\"854\":1}}],[\"<artifactid>maventest<\",{\"1\":{\"849\":1}}],[\"<artifactid>mybatis<\",{\"1\":{\"834\":1,\"841\":1,\"843\":1,\"850\":1,\"888\":1}}],[\"<artifactid>mysql\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"<artifactid>slf4j\",{\"1\":{\"842\":2}}],[\"<artifactid>testmaven<\",{\"1\":{\"840\":2,\"843\":1}}],[\"<artifactid>log4j<\",{\"1\":{\"842\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"825\":1,\"850\":2}}],[\"<artifactid>lbwnb<\",{\"1\":{\"835\":1}}],[\"<artifactid>junit\",{\"1\":{\"834\":1,\"850\":2}}],[\"<artifactid>helloworld<\",{\"1\":{\"819\":1}}],[\"<arg\",{\"1\":{\"658\":1,\"717\":2}}],[\"<association\",{\"1\":{\"667\":1,\"668\":1,\"672\":2}}],[\"<age>10<\",{\"1\":{\"634\":1}}],[\"<a>\",{\"1\":{\"365\":1}}],[\"<a\",{\"1\":{\"333\":1,\"891\":1}}],[\"<==向左的箭头就是得到的结果\",{\"1\":{\"669\":1}}],[\"<====\",{\"1\":{\"669\":3}}],[\"<==\",{\"1\":{\"669\":3}}],[\"<=\",{\"1\":{\"71\":1,\"227\":1,\"246\":1,\"580\":1,\"688\":1,\"693\":1}}],[\"<<\",{\"1\":{\"60\":2}}],[\"<\",{\"1\":{\"25\":2,\"60\":1,\"71\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"161\":1,\"172\":2,\"186\":3,\"237\":1,\"274\":1,\"292\":1,\"321\":2,\"322\":2,\"323\":1,\"333\":3,\"580\":1,\"616\":1,\"634\":5,\"635\":2,\"636\":1,\"641\":7,\"643\":6,\"648\":4,\"649\":2,\"650\":1,\"651\":1,\"652\":3,\"653\":2,\"658\":4,\"659\":5,\"660\":1,\"666\":2,\"667\":2,\"668\":3,\"669\":1,\"670\":2,\"671\":3,\"672\":6,\"678\":1,\"679\":1,\"680\":1,\"681\":1,\"690\":2,\"691\":5,\"693\":2,\"694\":2,\"703\":1,\"704\":1,\"711\":2,\"712\":1,\"714\":1,\"715\":1,\"717\":1,\"719\":4,\"789\":2,\"819\":3,\"825\":2,\"827\":1,\"834\":13,\"835\":1,\"840\":3,\"841\":2,\"842\":3,\"843\":4,\"849\":4,\"850\":10,\"854\":10,\"871\":7,\"876\":1,\"886\":7,\"888\":9,\"891\":1,\"892\":3,\"893\":1,\"903\":1,\"910\":2,\"914\":1}}],[\"<typealias\",{\"1\":{\"649\":1}}],[\"<typealiases>\",{\"1\":{\"649\":2,\"834\":1}}],[\"<transactionmanager\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"<test>\",{\"1\":{\"635\":1}}],[\"<t\",{\"1\":{\"16\":1}}],[\"<t>\",{\"1\":{\"14\":2,\"16\":1,\"23\":1,\"47\":1,\"186\":1,\"616\":1}}],[\"扩展与增强\",{\"1\":{\"346\":1}}],[\"扩展了collection接口中一些额外的操作\",{\"1\":{\"24\":1}}],[\"扩展了大量列表支持的操作\",{\"1\":{\"24\":1}}],[\"扩容规则跟我们之前的是一样的\",{\"1\":{\"25\":1}}],[\"msg\",{\"1\":{\"876\":2}}],[\"mssrkn​​rtt​+1\",{\"1\":{\"384\":1}}],[\"mss\",{\"1\":{\"384\":1}}],[\"mm\",{\"1\":{\"765\":2,\"893\":1}}],[\"m2文件夹\",{\"1\":{\"826\":1}}],[\"m2\",{\"1\":{\"700\":2}}],[\"m1\",{\"1\":{\"700\":3}}],[\"mbgd\",{\"0\":{\"480\":1}}],[\"mc\",{\"0\":{\"450\":1,\"454\":1,\"457\":1,\"459\":1,\"462\":1,\"488\":1},\"1\":{\"450\":1,\"454\":2,\"455\":1,\"456\":1,\"462\":2,\"475\":1,\"497\":1}}],[\"mdp就变为mp\",{\"1\":{\"394\":1}}],[\"mdp\",{\"0\":{\"394\":1}}],[\"more\",{\"1\":{\"864\":1}}],[\"moreover\",{\"1\":{\"432\":1}}],[\"mozilla\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"mobile\",{\"1\":{\"544\":1}}],[\"mobility\",{\"1\":{\"388\":1}}],[\"monkey\",{\"1\":{\"613\":1}}],[\"monro\",{\"1\":{\"472\":2}}],[\"monto\",{\"0\":{\"469\":1}}],[\"monte\",{\"0\":{\"449\":1,\"511\":1},\"1\":{\"449\":1,\"530\":1}}],[\"mos主要是有关传输速率rkn​​的函数\",{\"1\":{\"387\":1}}],[\"mosrkn​​​=t=0∑ts​​moskn​​\",{\"1\":{\"384\":1}}],[\"moskn​​\",{\"1\":{\"384\":3}}],[\"mos\",{\"1\":{\"379\":1}}],[\"movement\",{\"0\":{\"377\":1},\"1\":{\"378\":2}}],[\"modified\",{\"1\":{\"876\":1}}],[\"modifiers\",{\"1\":{\"193\":1}}],[\"modifiersfield\",{\"1\":{\"193\":3}}],[\"mode\",{\"1\":{\"544\":1,\"810\":2,\"908\":1,\"913\":1}}],[\"modelversion>\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"model|environment\",{\"1\":{\"419\":1}}],[\"model\",{\"0\":{\"384\":1,\"449\":1},\"1\":{\"388\":3,\"419\":2,\"450\":1,\"451\":2}}],[\"modles可选择\",{\"1\":{\"388\":1}}],[\"modules命令来列出所有的模块\",{\"1\":{\"306\":1}}],[\"module\",{\"1\":{\"304\":3,\"307\":8,\"308\":6,\"309\":7,\"310\":6,\"311\":2}}],[\"must\",{\"1\":{\"864\":2}}],[\"mutable\",{\"1\":{\"371\":1}}],[\"multipartconfig注解来表示此servlet用于处理文件上传请求\",{\"1\":{\"892\":1}}],[\"multipartconfig\",{\"1\":{\"892\":1}}],[\"multipart\",{\"1\":{\"892\":2}}],[\"multiple\",{\"0\":{\"377\":1},\"1\":{\"378\":1}}],[\"multiply\",{\"1\":{\"229\":1}}],[\"multi\",{\"1\":{\"341\":2}}],[\"myformatter\",{\"1\":{\"761\":1,\"763\":1,\"764\":1}}],[\"mybatis数据库测试\",{\"1\":{\"834\":1}}],[\"mybatis<\",{\"1\":{\"834\":1,\"841\":1,\"843\":1,\"850\":1,\"888\":1}}],[\"mybatis依赖\",{\"1\":{\"825\":1}}],[\"mybatis就可以正确使用jdk的日志框架进行日志打印了\",{\"1\":{\"768\":1}}],[\"mybatis就会自动将对应的结果填入到对象的对应字段上\",{\"1\":{\"643\":1}}],[\"mybatis同样可以正常解析\",{\"1\":{\"719\":1}}],[\"mybatis针对于所有的sql操作都提供了对应的provider注解\",{\"1\":{\"719\":1}}],[\"mybatis在插入后\",{\"1\":{\"714\":1}}],[\"mybatis在执行完查询语句后\",{\"1\":{\"658\":1}}],[\"mybatis9\",{\"0\":{\"708\":1}}],[\"mybatis不知道我们修改了数据\",{\"1\":{\"705\":1}}],[\"mybatis确实存在着缓存机制来进行性能优化\",{\"1\":{\"700\":1}}],[\"mybatis的缓存机制有些复杂\",{\"1\":{\"699\":1}}],[\"mybatis为了查询效率\",{\"1\":{\"699\":1}}],[\"mybatis为我们提供了\",{\"1\":{\"717\":1}}],[\"mybatis为我们提供了丰富的注解用于表示不同sql语句类型\",{\"1\":{\"713\":1}}],[\"mybatis为我们提供了一些参数用于处理这种问题\",{\"1\":{\"679\":1}}],[\"mybatis为我们提供的插入操作非常快捷\",{\"1\":{\"678\":1}}],[\"mybatis为我们的dml操作提供了几个预设方法\",{\"1\":{\"677\":1}}],[\"mybatis8\",{\"0\":{\"697\":1}}],[\"mybatis还针对多分支情况提供了choose操作\",{\"1\":{\"691\":1}}],[\"mybatis还为我们提供了一种更好的方式来处理这种问题\",{\"1\":{\"689\":1}}],[\"mybatis7\",{\"0\":{\"685\":1}}],[\"mybatis6\",{\"0\":{\"675\":1}}],[\"mybatis日志中\",{\"1\":{\"669\":1}}],[\"mybatis日志\",{\"0\":{\"669\":1}}],[\"mybatis一般情况下可以自动完成推断\",{\"1\":{\"667\":1}}],[\"mybatis5\",{\"0\":{\"663\":1}}],[\"mybatis也有日志系统\",{\"1\":{\"768\":1}}],[\"mybatis也为我们提供了丰富的注解用于处理这类问题\",{\"1\":{\"718\":1}}],[\"mybatis也为我们提供了多种转换方案\",{\"1\":{\"650\":1}}],[\"mybatis也能完成自动推断\",{\"1\":{\"678\":1}}],[\"mybatis也不可能提前帮我们写了实现类啊\",{\"1\":{\"659\":1}}],[\"mybatis仅仅是使用这种方式进行对象的构建\",{\"1\":{\"658\":1}}],[\"mybatis会先从二级缓存中查找数据\",{\"1\":{\"702\":1}}],[\"mybatis会选择性拼接我们的sql语句\",{\"1\":{\"690\":1}}],[\"mybatis会从传入的对象中自动获取需要的参数\",{\"1\":{\"680\":1}}],[\"mybatis会在查询完后自动为我们的user对象赋值\",{\"1\":{\"679\":1}}],[\"mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中\",{\"1\":{\"670\":1}}],[\"mybatis会并不能正确获取对应的参数\",{\"1\":{\"660\":1}}],[\"mybatis会出现问题\",{\"1\":{\"658\":1}}],[\"mybatis会自动判断\",{\"1\":{\"648\":1}}],[\"mybatis详解7\",{\"0\":{\"709\":1}}],[\"mybatis详解6\",{\"0\":{\"698\":1}}],[\"mybatis详解5\",{\"0\":{\"686\":1}}],[\"mybatis详解4\",{\"0\":{\"676\":1}}],[\"mybatis详解3\",{\"0\":{\"664\":1}}],[\"mybatis详解2\",{\"0\":{\"657\":1}}],[\"mybatis详解1\",{\"0\":{\"647\":1}}],[\"mybatis4\",{\"0\":{\"656\":1}}],[\"mybatis虽然可以查询到对应的记录\",{\"1\":{\"652\":1}}],[\"mybatisutils\",{\"1\":{\"682\":1,\"700\":2}}],[\"mybatisutil\",{\"1\":{\"647\":2,\"659\":1,\"701\":2}}],[\"mybatis3\",{\"0\":{\"646\":1}}],[\"mybatis非常智能\",{\"1\":{\"643\":1}}],[\"mybatis2\",{\"0\":{\"639\":1,\"640\":1}}],[\"mybatis\",{\"0\":{\"641\":1,\"888\":1,\"942\":1},\"1\":{\"633\":3,\"641\":6,\"642\":1,\"643\":4,\"647\":1,\"666\":1,\"689\":1,\"719\":2,\"834\":4,\"888\":5,\"889\":2},\"2\":{\"638\":1,\"645\":1,\"655\":1,\"662\":1,\"674\":1,\"684\":1,\"696\":1,\"707\":1,\"723\":1}}],[\"mybatis1\",{\"0\":{\"632\":1,\"633\":1}}],[\"mysql实现的驱动会被加载\",{\"1\":{\"606\":1}}],[\"mysql默认采用的是innodb引擎\",{\"1\":{\"599\":1}}],[\"mysql不支持\",{\"1\":{\"564\":1}}],[\"mysql就是一种关系型数据库\",{\"1\":{\"550\":1}}],[\"mysql\",{\"1\":{\"549\":1,\"605\":4,\"613\":1,\"622\":1,\"641\":1,\"669\":1,\"721\":2,\"753\":2,\"834\":2,\"888\":2},\"2\":{\"558\":1,\"575\":1,\"593\":1,\"601\":1,\"610\":1,\"618\":1,\"625\":1}}],[\"mythbusters\",{\"1\":{\"368\":1}}],[\"myclassloader\",{\"1\":{\"199\":3}}],[\"mirror>\",{\"1\":{\"827\":1}}],[\"mirrorof>\",{\"1\":{\"827\":1}}],[\"microsoft\",{\"1\":{\"549\":1,\"913\":1}}],[\"millis\",{\"1\":{\"143\":1}}],[\"mini\",{\"1\":{\"516\":2}}],[\"minisize\",{\"1\":{\"510\":1}}],[\"minimize\",{\"1\":{\"478\":1}}],[\"min\",{\"1\":{\"76\":1,\"145\":2,\"274\":1,\"358\":1,\"582\":1,\"729\":1,\"795\":1}}],[\"mincapacity\",{\"1\":{\"25\":4}}],[\"medium\",{\"1\":{\"810\":1}}],[\"memcache等缓存框架\",{\"1\":{\"705\":1}}],[\"memory\",{\"1\":{\"154\":1}}],[\"metaclass\",{\"1\":{\"658\":1}}],[\"metrics\",{\"1\":{\"522\":2}}],[\"method=\",{\"1\":{\"886\":1,\"892\":1}}],[\"methodname\",{\"1\":{\"804\":1}}],[\"methodorderer\",{\"1\":{\"804\":4}}],[\"method模式\",{\"1\":{\"803\":1}}],[\"methodsource\",{\"1\":{\"811\":1}}],[\"methodsource注解即可指定方法\",{\"1\":{\"811\":1}}],[\"methods\",{\"1\":{\"455\":1}}],[\"method和constructor都和class一样\",{\"1\":{\"192\":1}}],[\"method\",{\"1\":{\"139\":2,\"192\":15,\"199\":6,\"206\":2,\"207\":4,\"208\":1,\"455\":2,\"475\":3,\"530\":1,\"658\":2,\"719\":1,\"876\":12}}],[\"means\",{\"1\":{\"466\":1}}],[\"means来划分各个无人机所管理的用户簇\",{\"1\":{\"387\":1}}],[\"means的优化目标是最小化无人机与对应集群用户的欧氏距离\",{\"1\":{\"387\":1}}],[\"means可以视为获得无人机部署的低复杂度方案\",{\"1\":{\"387\":1}}],[\"means算法\",{\"1\":{\"387\":1}}],[\"means和igk算法比具有较低的复杂度\",{\"1\":{\"379\":1}}],[\"mean算法获得初始单元划分\",{\"1\":{\"379\":1}}],[\"mean\",{\"0\":{\"417\":1,\"418\":1,\"473\":1,\"477\":1},\"1\":{\"379\":1,\"414\":1,\"415\":1,\"449\":1,\"451\":1,\"456\":1,\"466\":1}}],[\"meet\",{\"1\":{\"341\":3}}],[\"messageformat\",{\"1\":{\"876\":1}}],[\"message=\",{\"1\":{\"366\":1}}],[\"message\",{\"1\":{\"265\":4,\"366\":9,\"367\":5,\"786\":1,\"787\":1}}],[\"menu\",{\"1\":{\"174\":1}}],[\"me\",{\"1\":{\"142\":2,\"910\":2}}],[\"merge\",{\"1\":{\"65\":1}}],[\"merge方法可以对重复键的值进行特殊操作\",{\"1\":{\"65\":1}}],[\"merge方法用于处理数据\",{\"1\":{\"65\":1}}],[\"m\",{\"1\":{\"56\":1,\"64\":3,\"246\":4,\"383\":1,\"550\":1}}],[\"maven会将该项目打成jar包\",{\"1\":{\"855\":1}}],[\"maven测试和打包\",{\"0\":{\"851\":1}}],[\"maven继承和多模块\",{\"0\":{\"848\":1}}],[\"maven5\",{\"0\":{\"846\":1,\"847\":1}}],[\"maven项目导入自己项目\",{\"0\":{\"840\":1}}],[\"maven项目结构\",{\"0\":{\"818\":1}}],[\"maven4\",{\"0\":{\"838\":1,\"839\":1}}],[\"maven还给我们提供了一个resource目标\",{\"1\":{\"834\":1}}],[\"maven3\",{\"0\":{\"830\":1,\"831\":1},\"1\":{\"827\":1}}],[\"maven可以直接从中央仓库中下载大部分的依赖\",{\"1\":{\"826\":1}}],[\"maven是如何进行依赖管理呢\",{\"1\":{\"826\":1}}],[\"maven依赖作用域\",{\"0\":{\"832\":1}}],[\"maven依赖管理原理\",{\"0\":{\"826\":1}}],[\"maven依赖导入\",{\"0\":{\"825\":1}}],[\"maven2\",{\"0\":{\"823\":1,\"824\":1}}],[\"maven的配置文件是以project为根节点\",{\"1\":{\"819\":1}}],[\"maven就很好地解决了这个问题\",{\"1\":{\"818\":1}}],[\"maven也需要安装环境\",{\"1\":{\"817\":1}}],[\"maven利用一个中央信息片断能管理一个项目的构建\",{\"1\":{\"817\":1}}],[\"maven\",{\"0\":{\"865\":1,\"945\":1},\"1\":{\"817\":4,\"819\":6,\"827\":2,\"840\":4,\"849\":6},\"2\":{\"822\":1,\"829\":1,\"837\":1,\"845\":1,\"857\":1}}],[\"maven1\",{\"0\":{\"815\":1,\"816\":1}}],[\"make\",{\"1\":{\"606\":1}}],[\"manifest>\",{\"1\":{\"854\":1}}],[\"manipulation\",{\"1\":{\"561\":1}}],[\"many注解来指定其他查询语句进行嵌套查询\",{\"1\":{\"718\":1}}],[\"manual\",{\"1\":{\"605\":1}}],[\"manager\",{\"1\":{\"565\":1,\"756\":7,\"864\":16}}],[\"managerid\",{\"1\":{\"565\":2}}],[\"managementfactory\",{\"1\":{\"138\":1}}],[\"mac\",{\"1\":{\"544\":1,\"793\":2}}],[\"macintosh\",{\"1\":{\"544\":1}}],[\"macos\",{\"1\":{\"544\":1}}],[\"machine\",{\"1\":{\"183\":1}}],[\"matrix\",{\"0\":{\"420\":1},\"1\":{\"420\":1,\"423\":1,\"429\":1}}],[\"matching\",{\"1\":{\"658\":1}}],[\"matches\",{\"1\":{\"246\":2,\"796\":2}}],[\"matches方法用于对给定正则表达式进行匹配\",{\"1\":{\"246\":1}}],[\"match\",{\"1\":{\"246\":1,\"358\":1}}],[\"math也是java\",{\"1\":{\"274\":1}}],[\"math类\",{\"1\":{\"274\":1}}],[\"math\",{\"1\":{\"65\":3,\"229\":3,\"274\":5}}],[\"male\",{\"1\":{\"219\":1}}],[\"maybesetlastmodified\",{\"1\":{\"876\":2}}],[\"may\",{\"1\":{\"139\":1,\"393\":1,\"658\":1}}],[\"markov\",{\"0\":{\"394\":1},\"1\":{\"394\":2,\"509\":1}}],[\"markovian\",{\"1\":{\"388\":1}}],[\"mark已经失效\",{\"1\":{\"108\":1}}],[\"mark\",{\"1\":{\"108\":6}}],[\"mapunderscoretocamelcase\",{\"1\":{\"834\":1}}],[\"mapper创在对应的mapper文件夹下\",{\"1\":{\"888\":1}}],[\"mapper2\",{\"1\":{\"701\":2}}],[\"mapper>\",{\"1\":{\"643\":1,\"659\":1}}],[\"mapper\",{\"1\":{\"643\":3,\"659\":4,\"660\":2,\"682\":8,\"688\":2,\"693\":1,\"694\":2,\"700\":6,\"701\":2,\"705\":2,\"711\":2,\"714\":1,\"721\":1,\"834\":1,\"889\":2,\"910\":2}}],[\"mappers>\",{\"1\":{\"643\":1,\"659\":1,\"711\":2,\"834\":1,\"888\":1}}],[\"mappers\",{\"1\":{\"636\":1,\"643\":1,\"658\":1}}],[\"mappings\",{\"1\":{\"871\":1}}],[\"mapping>\",{\"1\":{\"871\":6}}],[\"mapping\",{\"1\":{\"427\":2,\"432\":5,\"436\":1,\"871\":1}}],[\"mapstreamdemo\",{\"1\":{\"362\":1}}],[\"maptoint\",{\"1\":{\"71\":1}}],[\"map中只有键为1的映射\",{\"1\":{\"57\":1}}],[\"map<test\",{\"1\":{\"84\":1}}],[\"map<string\",{\"1\":{\"65\":1,\"318\":2,\"650\":1,\"653\":1,\"660\":1,\"889\":1}}],[\"map<integer\",{\"1\":{\"57\":4,\"64\":1,\"66\":3}}],[\"map<\",{\"1\":{\"56\":1}}],[\"map<k\",{\"1\":{\"56\":1,\"58\":1}}],[\"map并不是collection体系下的接口\",{\"1\":{\"56\":1}}],[\"map目前只需要记住\",{\"1\":{\"50\":1}}],[\"map\",{\"0\":{\"55\":1,\"56\":1,\"63\":1},\"1\":{\"50\":1,\"55\":2,\"56\":2,\"57\":16,\"58\":1,\"64\":10,\"66\":12,\"67\":6,\"71\":1,\"84\":5,\"318\":7,\"362\":2,\"365\":4,\"651\":2,\"660\":2,\"889\":3,\"910\":1}}],[\"maxage\",{\"1\":{\"909\":2}}],[\"maxa∈a\",{\"1\":{\"516\":1}}],[\"max​q^​\",{\"1\":{\"514\":1,\"515\":1,\"516\":3}}],[\"maximum\",{\"1\":{\"60\":2}}],[\"max\",{\"1\":{\"25\":4,\"60\":2,\"76\":1,\"145\":1,\"229\":1,\"274\":1,\"544\":1,\"582\":1,\"729\":1,\"795\":1,\"908\":1,\"913\":1}}],[\"mainfilter\",{\"1\":{\"921\":1}}],[\"maintain\",{\"1\":{\"864\":1}}],[\"maintest\",{\"1\":{\"776\":2,\"803\":1,\"805\":1,\"834\":2,\"852\":1}}],[\"mainclass>\",{\"1\":{\"854\":1}}],[\"main<\",{\"1\":{\"854\":1}}],[\"mainobject\",{\"1\":{\"295\":2}}],[\"mainloop\",{\"1\":{\"167\":2}}],[\"main\",{\"1\":{\"4\":3,\"5\":1,\"14\":10,\"15\":3,\"16\":1,\"23\":2,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":4,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":1,\"120\":4,\"121\":2,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":2,\"155\":17,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":2,\"172\":2,\"173\":2,\"174\":7,\"182\":1,\"183\":1,\"184\":1,\"186\":10,\"191\":2,\"192\":5,\"193\":3,\"198\":9,\"199\":2,\"206\":2,\"207\":5,\"208\":3,\"219\":3,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":2,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":1,\"254\":2,\"255\":5,\"256\":1,\"257\":3,\"258\":9,\"267\":5,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":4,\"288\":1,\"289\":1,\"291\":2,\"292\":2,\"294\":1,\"295\":3,\"296\":1,\"304\":2,\"305\":1,\"307\":2,\"310\":2,\"311\":2,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":6,\"328\":2,\"330\":1,\"331\":3,\"333\":4,\"347\":1,\"355\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":2,\"516\":4,\"518\":1,\"536\":3,\"537\":2,\"543\":2,\"544\":2,\"613\":2,\"615\":1,\"622\":1,\"623\":4,\"641\":1,\"643\":1,\"647\":1,\"658\":1,\"725\":4,\"727\":2,\"728\":1,\"735\":1,\"736\":2,\"744\":1,\"746\":4,\"767\":4,\"773\":2,\"776\":4,\"825\":2,\"840\":1,\"849\":2}}],[\"gb\",{\"1\":{\"908\":1,\"913\":1}}],[\"gbk\",{\"1\":{\"864\":1}}],[\"gmt\",{\"1\":{\"908\":1,\"913\":1}}],[\"gui\",{\"1\":{\"864\":8}}],[\"guide\",{\"1\":{\"812\":1}}],[\"gname\",{\"1\":{\"672\":3}}],[\"goals>\",{\"1\":{\"854\":1}}],[\"goal>\",{\"1\":{\"854\":1}}],[\"got\",{\"1\":{\"606\":1}}],[\"good\",{\"1\":{\"384\":1,\"596\":1}}],[\"google\",{\"1\":{\"246\":2,\"544\":1,\"909\":2}}],[\"gid\",{\"1\":{\"672\":6}}],[\"git\",{\"1\":{\"599\":1}}],[\"given\",{\"1\":{\"139\":1,\"352\":1}}],[\"gzip\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"g∣s=s\",{\"1\":{\"487\":1}}],[\"g~​\",{\"1\":{\"478\":1,\"484\":1}}],[\"gd\",{\"1\":{\"475\":1,\"478\":1}}],[\"g​\",{\"1\":{\"471\":2,\"473\":2}}],[\"gpi\",{\"1\":{\"456\":1}}],[\"g\",{\"1\":{\"452\":3,\"470\":4,\"471\":2,\"472\":1,\"473\":2,\"478\":1,\"484\":2,\"487\":1,\"864\":1}}],[\"gt\",{\"1\":{\"653\":2}}],[\"gt+1​∣st+1​=s\",{\"1\":{\"418\":2}}],[\"gt+1​∣st​=s\",{\"1\":{\"416\":2,\"418\":5,\"419\":1}}],[\"gt​−v^\",{\"1\":{\"511\":1}}],[\"gt​​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"416\":1}}],[\"gt​∣st​=s\",{\"1\":{\"414\":1,\"416\":1,\"422\":3,\"423\":2,\"449\":2,\"451\":1,\"452\":1}}],[\"gt​\",{\"1\":{\"414\":2,\"416\":1,\"452\":1,\"511\":2}}],[\"gt​也是一个随机变量\",{\"1\":{\"413\":1}}],[\"gt​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"413\":1}}],[\"gt​=e\",{\"1\":{\"387\":1}}],[\"gkn​​\",{\"1\":{\"383\":1}}],[\"gain\",{\"1\":{\"383\":1}}],[\"groupid\",{\"1\":{\"820\":2}}],[\"groupid>\",{\"1\":{\"819\":1,\"825\":1,\"834\":3,\"835\":1,\"840\":2,\"841\":1,\"842\":3,\"843\":2,\"849\":1,\"850\":6,\"888\":2,\"891\":1}}],[\"groups\",{\"1\":{\"672\":4}}],[\"group\",{\"1\":{\"583\":2,\"672\":7}}],[\"grow\",{\"1\":{\"25\":1}}],[\"granted\",{\"1\":{\"864\":1}}],[\"grant\",{\"1\":{\"561\":1,\"591\":3}}],[\"gradient\",{\"0\":{\"474\":1,\"521\":1},\"1\":{\"475\":2,\"522\":1}}],[\"grade\",{\"1\":{\"338\":2,\"339\":1,\"596\":3}}],[\"greedy\",{\"0\":{\"459\":1,\"461\":1,\"462\":1},\"1\":{\"427\":1,\"437\":2,\"440\":1,\"444\":2,\"453\":1,\"461\":3}}],[\"gecko\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"generator\",{\"1\":{\"365\":1}}],[\"generally\",{\"1\":{\"605\":1}}],[\"generalized\",{\"1\":{\"456\":1}}],[\"general\",{\"1\":{\"139\":1,\"566\":1}}],[\"genericfilter\",{\"1\":{\"921\":1}}],[\"generics\",{\"1\":{\"186\":1}}],[\"genericinterface\",{\"1\":{\"186\":2}}],[\"get请求也能传递参数\",{\"1\":{\"893\":1}}],[\"getuser\",{\"1\":{\"888\":1,\"889\":1,\"910\":1}}],[\"getwriter\",{\"1\":{\"875\":1,\"876\":1,\"881\":1,\"889\":3,\"892\":1,\"893\":1}}],[\"getformatterproperty\",{\"1\":{\"756\":1}}],[\"getfilterproperty\",{\"1\":{\"756\":1}}],[\"getfield\",{\"1\":{\"199\":1}}],[\"getfirstchild\",{\"1\":{\"636\":1}}],[\"getfirst\",{\"1\":{\"44\":1}}],[\"getrequesturl\",{\"1\":{\"919\":1,\"921\":1}}],[\"getrequestdispatcher\",{\"1\":{\"900\":2,\"901\":1,\"910\":1}}],[\"getremoteaddr\",{\"1\":{\"874\":1}}],[\"getresultobject\",{\"1\":{\"653\":1}}],[\"getresourceasstream\",{\"1\":{\"641\":1,\"834\":1,\"889\":1,\"891\":2,\"901\":1}}],[\"getreturntype\",{\"1\":{\"192\":1}}],[\"getnodevalue\",{\"1\":{\"636\":1}}],[\"getnodename\",{\"1\":{\"636\":1}}],[\"getnodetype\",{\"1\":{\"636\":1}}],[\"getname\",{\"1\":{\"7\":1,\"65\":2,\"140\":1,\"166\":1,\"167\":1,\"173\":1,\"174\":2,\"184\":1,\"186\":1,\"192\":1,\"199\":1,\"215\":1,\"221\":2,\"606\":3,\"627\":1,\"658\":1,\"727\":1,\"728\":1,\"735\":1,\"744\":1,\"756\":1,\"765\":1,\"767\":2,\"908\":1,\"910\":2}}],[\"getlocalizedname\",{\"1\":{\"761\":1}}],[\"getlogmanager\",{\"1\":{\"756\":2}}],[\"getlogger\",{\"1\":{\"725\":1,\"727\":1,\"728\":1,\"735\":1,\"744\":2,\"747\":4,\"756\":1,\"763\":1}}],[\"getlevel\",{\"1\":{\"761\":1,\"765\":1}}],[\"getlevelproperty\",{\"1\":{\"756\":1}}],[\"getlength\",{\"1\":{\"636\":1}}],[\"getlastmodified\",{\"1\":{\"876\":2}}],[\"getlast\",{\"1\":{\"44\":1}}],[\"getelementbyid\",{\"1\":{\"893\":1}}],[\"getelementsbytagname\",{\"1\":{\"636\":1}}],[\"getencoding\",{\"1\":{\"97\":1}}],[\"getobject\",{\"1\":{\"616\":1}}],[\"getoutputstream\",{\"1\":{\"537\":2,\"543\":1,\"544\":1,\"891\":2}}],[\"getordefault\",{\"1\":{\"57\":2}}],[\"getheader\",{\"1\":{\"874\":1}}],[\"getheadernames\",{\"1\":{\"874\":1}}],[\"gethandlers\",{\"1\":{\"735\":1,\"744\":1,\"745\":1,\"763\":1}}],[\"gethashcode\",{\"1\":{\"344\":1}}],[\"gethostaddress\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"getinitparameter\",{\"1\":{\"902\":1,\"903\":1}}],[\"getint\",{\"1\":{\"616\":1}}],[\"getinterfaces\",{\"1\":{\"186\":1}}],[\"getinputstream\",{\"1\":{\"537\":2,\"543\":1,\"544\":1,\"892\":1}}],[\"getinetaddress\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"getdateheader\",{\"1\":{\"876\":1}}],[\"getdata\",{\"1\":{\"366\":1}}],[\"getdeclaredfield\",{\"1\":{\"193\":4,\"305\":1}}],[\"getdeclaredmethod\",{\"1\":{\"192\":3}}],[\"getdeclaredconstructor\",{\"1\":{\"191\":1}}],[\"getprotocol\",{\"1\":{\"874\":1,\"876\":1}}],[\"getproperties\",{\"1\":{\"755\":2,\"795\":1}}],[\"getprimitiveclass获取的是原始类型\",{\"1\":{\"183\":1}}],[\"getprimitiveclass\",{\"1\":{\"183\":2}}],[\"getpart\",{\"1\":{\"892\":1}}],[\"getparameter\",{\"1\":{\"889\":2}}],[\"getparametermap\",{\"1\":{\"886\":1,\"889\":1}}],[\"getparametertypes\",{\"1\":{\"616\":2}}],[\"getparameters\",{\"1\":{\"192\":1}}],[\"getparent\",{\"1\":{\"198\":3,\"744\":2,\"747\":3,\"763\":1}}],[\"getmillis\",{\"1\":{\"765\":1}}],[\"getmapper\",{\"1\":{\"659\":2,\"660\":1,\"682\":3,\"688\":1,\"694\":1,\"700\":3,\"701\":2,\"705\":1,\"834\":1,\"889\":1,\"910\":1}}],[\"getmax\",{\"1\":{\"71\":1}}],[\"getmessage\",{\"1\":{\"267\":1,\"366\":1,\"765\":1}}],[\"getmethodnotsupportedcode\",{\"1\":{\"876\":1}}],[\"getmethod\",{\"1\":{\"192\":2,\"199\":2,\"208\":1,\"874\":1,\"876\":1}}],[\"getmodifiers\",{\"1\":{\"193\":1}}],[\"getgenericinterfaces\",{\"1\":{\"186\":1}}],[\"getgenericsuperclass\",{\"1\":{\"186\":5}}],[\"getsourcemethodname\",{\"1\":{\"761\":1}}],[\"getsourceclassname\",{\"1\":{\"761\":1,\"765\":1}}],[\"getservletcontext\",{\"1\":{\"901\":2,\"903\":1}}],[\"getservletconfig\",{\"1\":{\"871\":1}}],[\"getservletinfo\",{\"1\":{\"871\":1}}],[\"getsetinvoker\",{\"1\":{\"658\":1}}],[\"getsession\",{\"1\":{\"647\":2,\"701\":2,\"913\":2,\"921\":1}}],[\"getsex\",{\"1\":{\"627\":1}}],[\"getsid\",{\"1\":{\"627\":1}}],[\"getsimplename\",{\"1\":{\"184\":1}}],[\"gets\",{\"1\":{\"606\":1}}],[\"getstudentbysid\",{\"1\":{\"834\":1}}],[\"getstringproperty\",{\"1\":{\"756\":1}}],[\"getstring\",{\"1\":{\"605\":1,\"616\":2,\"621\":1,\"622\":1,\"876\":2}}],[\"getstatus\",{\"1\":{\"221\":2}}],[\"getsuperclass\",{\"1\":{\"186\":2}}],[\"getscore\",{\"1\":{\"65\":2}}],[\"getter和setter\",{\"1\":{\"766\":1}}],[\"getter和\",{\"1\":{\"629\":1}}],[\"getter\",{\"1\":{\"627\":1,\"629\":1}}],[\"getthreadname\",{\"1\":{\"138\":1}}],[\"getthreadinfo\",{\"1\":{\"138\":1}}],[\"getthreadmxbean\",{\"1\":{\"138\":1}}],[\"gettypealiasregistry\",{\"1\":{\"721\":1}}],[\"gettypename\",{\"1\":{\"184\":1,\"186\":1}}],[\"gettype\",{\"1\":{\"65\":1}}],[\"getattribute\",{\"1\":{\"900\":1,\"901\":1,\"913\":1,\"921\":1}}],[\"getannotations\",{\"1\":{\"208\":2}}],[\"getactualtypearguments\",{\"1\":{\"186\":4}}],[\"getallthreadids\",{\"1\":{\"138\":1}}],[\"getabsolutepath\",{\"1\":{\"98\":1}}],[\"getaverage\",{\"1\":{\"71\":1}}],[\"getbytes\",{\"1\":{\"92\":2,\"93\":1,\"110\":1}}],[\"getchildnodes\",{\"1\":{\"636\":1}}],[\"getcallerclass\",{\"1\":{\"606\":1}}],[\"getcookies\",{\"1\":{\"908\":1,\"910\":1}}],[\"getcontextclassloader\",{\"1\":{\"606\":1}}],[\"getconnection\",{\"1\":{\"605\":1,\"606\":7,\"613\":1,\"615\":1,\"621\":1,\"622\":1,\"623\":4}}],[\"getconstructors\",{\"1\":{\"616\":1}}],[\"getconstructor\",{\"1\":{\"191\":2,\"192\":1,\"616\":1}}],[\"getcode\",{\"1\":{\"366\":1}}],[\"getcount\",{\"1\":{\"71\":1}}],[\"getclassloader\",{\"1\":{\"184\":1,\"198\":4,\"606\":1}}],[\"getclass\",{\"1\":{\"84\":4,\"182\":1,\"186\":10,\"215\":2,\"328\":1,\"606\":3,\"616\":2,\"659\":1,\"756\":1}}],[\"getkey\",{\"1\":{\"56\":1}}],[\"get\",{\"1\":{\"24\":1,\"25\":1,\"56\":1,\"57\":3,\"71\":1,\"84\":1,\"110\":1,\"162\":1,\"163\":1,\"193\":1,\"297\":1,\"305\":1,\"323\":1,\"355\":2,\"422\":2,\"544\":1,\"754\":1,\"755\":2,\"876\":3,\"893\":1,\"908\":1,\"913\":1}}],[\"getvalue\",{\"1\":{\"15\":3,\"56\":1,\"908\":1,\"910\":2}}],[\"度\",{\"1\":{\"25\":1}}],[\"jc\",{\"1\":{\"888\":1}}],[\"jmx\",{\"1\":{\"864\":5}}],[\"jntm<\",{\"1\":{\"835\":1}}],[\"jre\",{\"1\":{\"794\":3,\"795\":2,\"864\":2}}],[\"jupiter<\",{\"1\":{\"834\":2,\"850\":4}}],[\"junit框架\",{\"1\":{\"833\":1}}],[\"junit依赖\",{\"1\":{\"825\":1}}],[\"junit5\",{\"1\":{\"812\":1}}],[\"junit\",{\"0\":{\"944\":1},\"1\":{\"812\":1,\"834\":1,\"850\":2}}],[\"junit还支持从csv表格中导入或自定义参数提供器等\",{\"1\":{\"812\":1}}],[\"junit还提供了上百种断言方法供大家使用\",{\"1\":{\"790\":1}}],[\"junit还提供了一些预设的名称生成器\",{\"1\":{\"779\":1}}],[\"junit提供了以下顺序\",{\"1\":{\"804\":1}}],[\"junit提供了非常多的断言操作\",{\"1\":{\"785\":1}}],[\"junit支持我们就为测试案例设置条件来实现这些功能\",{\"1\":{\"792\":1}}],[\"junit单元测试3\",{\"0\":{\"801\":1}}],[\"junit单元测试2\",{\"0\":{\"784\":1}}],[\"junit单元测试1\",{\"0\":{\"772\":1}}],[\"junit2\",{\"0\":{\"783\":1,\"800\":1}}],[\"junit使用\",{\"0\":{\"774\":1}}],[\"junit1\",{\"0\":{\"771\":1}}],[\"jul设置默认配置\",{\"0\":{\"756\":1}}],[\"jul中logger之间存在父子关系\",{\"1\":{\"744\":1}}],[\"jul\",{\"0\":{\"943\":1},\"1\":{\"908\":1,\"913\":1},\"2\":{\"731\":1,\"740\":1,\"749\":1,\"758\":1,\"770\":1,\"782\":1,\"799\":1,\"814\":1}}],[\"jul基本使用\",{\"0\":{\"726\":1}}],[\"jul日志5\",{\"0\":{\"759\":1}}],[\"jul日志4\",{\"0\":{\"750\":1}}],[\"jul日志3\",{\"0\":{\"741\":1}}],[\"jul日志2\",{\"0\":{\"732\":1}}],[\"jul日志系统5\",{\"0\":{\"760\":1}}],[\"jul日志系统4\",{\"0\":{\"751\":1}}],[\"jul日志系统3\",{\"0\":{\"742\":1}}],[\"jul日志系统2\",{\"0\":{\"733\":1}}],[\"jul日志系统\",{\"0\":{\"725\":1}}],[\"jul日志1\",{\"0\":{\"724\":1}}],[\"jul日志模块\",{\"1\":{\"311\":1}}],[\"jasperloader\",{\"1\":{\"926\":1}}],[\"jakarta\",{\"1\":{\"817\":1}}],[\"jar命令即可运行打包好的java程序\",{\"1\":{\"854\":1}}],[\"jar<\",{\"1\":{\"835\":1}}],[\"jar\",{\"1\":{\"606\":1,\"855\":1}}],[\"java<\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"java读取\",{\"0\":{\"754\":1}}],[\"javatype\",{\"1\":{\"717\":3}}],[\"javatype=\",{\"1\":{\"658\":2,\"667\":1,\"668\":1,\"672\":1,\"717\":3}}],[\"java对象\",{\"1\":{\"633\":1}}],[\"java的编译过程可以分成三个阶段\",{\"1\":{\"628\":1}}],[\"java的内存模型也是这样类似设计的\",{\"1\":{\"154\":1}}],[\"java与数据库3\",{\"0\":{\"619\":1}}],[\"java与数据库2\",{\"0\":{\"611\":1}}],[\"java与数据库1\",{\"0\":{\"602\":1}}],[\"java应用程序\",{\"1\":{\"604\":1}}],[\"java数据库连接\",{\"1\":{\"604\":1}}],[\"javaweb\",{\"0\":{\"534\":1,\"541\":1,\"547\":1,\"559\":1,\"576\":1,\"594\":1,\"602\":1,\"611\":1,\"619\":1,\"626\":1,\"632\":1,\"639\":1,\"646\":1,\"656\":1,\"663\":1,\"675\":1,\"685\":1,\"697\":1,\"708\":1,\"724\":1,\"732\":1,\"741\":1,\"750\":1,\"759\":1,\"771\":1,\"783\":1,\"800\":1,\"939\":1},\"2\":{\"540\":1,\"546\":1,\"558\":1,\"575\":1,\"593\":1,\"601\":1,\"610\":1,\"618\":1,\"625\":1,\"631\":1,\"638\":1,\"645\":1,\"655\":1,\"662\":1,\"674\":1,\"684\":1,\"696\":1,\"707\":1,\"723\":1,\"731\":1,\"740\":1,\"749\":1,\"758\":1,\"770\":1,\"782\":1,\"799\":1,\"814\":1,\"822\":1,\"829\":1,\"837\":1,\"845\":1,\"857\":1,\"861\":1,\"867\":1,\"883\":1,\"895\":1,\"905\":1,\"916\":1,\"924\":1,\"928\":1}}],[\"java13也带了这样的特性\",{\"1\":{\"341\":1}}],[\"java12\",{\"1\":{\"337\":1}}],[\"java11\",{\"0\":{\"329\":1}}],[\"java10\",{\"0\":{\"326\":1,\"327\":1}}],[\"java17版本的string类\",{\"1\":{\"305\":1}}],[\"java文件\",{\"1\":{\"311\":2}}],[\"java文件表示此项目采用模块管理机制\",{\"1\":{\"304\":1}}],[\"java为我们提供的logging相关日志库\",{\"1\":{\"304\":1}}],[\"java9\",{\"0\":{\"300\":1,\"301\":1,\"314\":1,\"315\":1}}],[\"java新特性\",{\"2\":{\"299\":1,\"313\":1,\"325\":1,\"335\":1,\"349\":1,\"370\":1}}],[\"java提供的基本类型包装类\",{\"1\":{\"226\":1}}],[\"java并不是纯面向对象的语言\",{\"1\":{\"226\":1}}],[\"javac\",{\"1\":{\"199\":1}}],[\"java高版本不行\",{\"1\":{\"193\":1}}],[\"java中也可以使用这样的三引号来表示字符串\",{\"1\":{\"341\":1}}],[\"java中也有些使用并行来进行操作的\",{\"1\":{\"173\":1}}],[\"java中接口的方法默认是\",{\"1\":{\"290\":1}}],[\"java中没有字符串这种基本类型\",{\"1\":{\"243\":1}}],[\"java中的基本类型\",{\"1\":{\"226\":1}}],[\"java中所有的线程都执行完毕后\",{\"1\":{\"172\":1}}],[\"java中引入了访问权限控制\",{\"1\":{\"121\":1}}],[\"java采用的是抢占式调度方式\",{\"1\":{\"145\":1}}],[\"java程序中的每个线程并不是平均分配cpu时间的\",{\"1\":{\"145\":1}}],[\"java会默认导入java\",{\"1\":{\"120\":1}}],[\"java8tester\",{\"1\":{\"355\":5}}],[\"java8只能像这样生成无限的流\",{\"1\":{\"321\":1}}],[\"java8回顾\",{\"0\":{\"285\":1}}],[\"java8开始\",{\"1\":{\"219\":1}}],[\"java8新增操作\",{\"1\":{\"57\":1}}],[\"java8新增方法\",{\"1\":{\"23\":1,\"36\":1}}],[\"java8\",{\"0\":{\"286\":1},\"1\":{\"35\":1,\"57\":1,\"356\":1}}],[\"java\",{\"0\":{\"3\":1,\"12\":1,\"19\":1,\"28\":1,\"40\":1,\"53\":1,\"70\":1,\"74\":1,\"83\":1,\"87\":1,\"101\":1,\"116\":1,\"124\":1,\"136\":1,\"151\":1,\"159\":1,\"170\":1,\"177\":1,\"180\":1,\"189\":1,\"196\":1,\"202\":1,\"211\":1,\"224\":1,\"232\":1,\"249\":1,\"261\":1,\"271\":1,\"278\":1,\"336\":1,\"337\":1,\"345\":1,\"350\":1,\"931\":1,\"933\":1,\"934\":1},\"1\":{\"23\":2,\"24\":1,\"25\":2,\"42\":1,\"67\":1,\"71\":2,\"95\":2,\"118\":1,\"120\":1,\"139\":1,\"173\":1,\"182\":1,\"186\":3,\"192\":4,\"198\":2,\"199\":2,\"204\":2,\"205\":2,\"208\":6,\"220\":1,\"221\":3,\"229\":3,\"242\":1,\"255\":2,\"274\":2,\"275\":1,\"296\":1,\"297\":1,\"301\":1,\"303\":2,\"304\":4,\"305\":2,\"306\":1,\"308\":2,\"311\":2,\"316\":1,\"327\":1,\"329\":1,\"337\":1,\"345\":1,\"355\":1,\"362\":1,\"365\":2,\"371\":5,\"374\":1,\"537\":2,\"538\":1,\"543\":2,\"604\":3,\"606\":4,\"613\":2,\"633\":2,\"658\":3,\"660\":1,\"718\":1,\"727\":1,\"744\":1,\"756\":1,\"764\":1,\"768\":1,\"794\":3,\"795\":2,\"808\":2,\"817\":2,\"849\":1,\"864\":1,\"865\":1,\"870\":1},\"2\":{\"11\":1,\"18\":1,\"27\":1,\"39\":1,\"52\":1,\"69\":1,\"73\":1,\"82\":1,\"86\":1,\"100\":1,\"115\":1,\"123\":1,\"135\":1,\"150\":1,\"158\":1,\"169\":1,\"176\":1,\"188\":1,\"195\":1,\"201\":1,\"210\":1,\"223\":1,\"231\":1,\"248\":1,\"260\":1,\"270\":1,\"277\":1,\"284\":1,\"373\":1,\"376\":1}}],[\"jdbctransactionfactory\",{\"1\":{\"721\":1}}],[\"jdbc很方便\",{\"1\":{\"633\":1}}],[\"jdbc默认的事务处理行为是自动提交\",{\"1\":{\"623\":1}}],[\"jdbc英文名为\",{\"1\":{\"604\":1}}],[\"jdbc\",{\"0\":{\"604\":1,\"612\":1,\"620\":1},\"1\":{\"605\":4,\"606\":1,\"613\":1,\"622\":1,\"633\":1,\"641\":2,\"669\":3,\"689\":1,\"721\":2,\"753\":4,\"834\":3,\"888\":2}}],[\"jdk自带了一个java\",{\"1\":{\"604\":1}}],[\"jdk为我们提供了一个叫做properties的类型\",{\"1\":{\"754\":1}}],[\"jdk为我们提供了一个自带的日志框架\",{\"1\":{\"725\":1}}],[\"jdk为我们提供了很多种类的handler用于多种不同类型的日志打印\",{\"1\":{\"735\":1}}],[\"jdk为我们提供的某些框架不见了\",{\"1\":{\"304\":1}}],[\"jdk为我们内置了一个叫做org\",{\"1\":{\"636\":1}}],[\"jdk为我们准备的\",{\"1\":{\"75\":1}}],[\"jdk\",{\"1\":{\"280\":1,\"659\":1,\"768\":2,\"834\":1}}],[\"jdk预设了以下注解\",{\"1\":{\"204\":1}}],[\"jdk提供的string类也是\",{\"1\":{\"198\":1}}],[\"jdk1\",{\"1\":{\"180\":1,\"183\":1}}],[\"j+1\",{\"1\":{\"440\":2,\"442\":1}}],[\"j++\",{\"1\":{\"155\":6}}],[\"job\",{\"1\":{\"368\":2}}],[\"join同理\",{\"1\":{\"586\":1}}],[\"joining\",{\"1\":{\"365\":2}}],[\"join\",{\"1\":{\"148\":1,\"586\":5,\"667\":1,\"670\":1,\"672\":2}}],[\"jpg\",{\"1\":{\"333\":1}}],[\"jsessionid\",{\"1\":{\"913\":1}}],[\"jsessionid=84abdd94fb965f266818b9dbb6172807\",{\"1\":{\"913\":2}}],[\"jsp类加载器\",{\"1\":{\"926\":1}}],[\"jspx<\",{\"1\":{\"871\":1}}],[\"jsp<\",{\"1\":{\"871\":1}}],[\"jsp\",{\"1\":{\"871\":1}}],[\"jsp等\",{\"1\":{\"604\":1}}],[\"js\",{\"1\":{\"864\":1,\"878\":1,\"921\":1}}],[\"jshell交互式编程\",{\"0\":{\"316\":1}}],[\"jstack自动帮助我们找到了一个死锁\",{\"1\":{\"156\":1}}],[\"jstack\",{\"1\":{\"156\":1}}],[\"j\",{\"1\":{\"155\":12,\"440\":2,\"442\":1,\"452\":1,\"475\":1,\"478\":1,\"507\":1,\"508\":1,\"509\":1,\"510\":1,\"515\":1,\"516\":3,\"522\":1,\"525\":1,\"529\":1,\"530\":1}}],[\"jvm发现任何异常都会立即终止程序运行\",{\"1\":{\"267\":1}}],[\"jvm会加载这个类吗\",{\"1\":{\"198\":1}}],[\"jvm会将一部分类\",{\"1\":{\"180\":1}}],[\"jvm\",{\"0\":{\"199\":1},\"1\":{\"118\":2,\"267\":2,\"872\":1}}],[\"jvm都c++实现中\",{\"1\":{\"25\":1}}],[\"创建servlet\",{\"0\":{\"871\":1}}],[\"创建documentbuilder对象\",{\"1\":{\"636\":1}}],[\"创建documentbuilderfactory对象\",{\"1\":{\"636\":1}}],[\"创建回滚点\",{\"1\":{\"623\":1}}],[\"创建索引\",{\"1\":{\"597\":1}}],[\"创建后\",{\"1\":{\"596\":1}}],[\"创建用户\",{\"0\":{\"589\":1}}],[\"创建表\",{\"0\":{\"567\":1}}],[\"创建流\",{\"0\":{\"359\":1},\"1\":{\"359\":1}}],[\"创建请求\",{\"1\":{\"333\":1}}],[\"创建一个实体类以及mapper来进行用户信息查询\",{\"1\":{\"888\":1}}],[\"创建一个实现runnable的匿名内部类\",{\"1\":{\"288\":1}}],[\"创建一个用于执行sql的statement对象\",{\"1\":{\"605\":1}}],[\"创建一个无参的default构造函数\",{\"1\":{\"368\":1}}],[\"创建一个变量指代我们刚刚创建好的对象\",{\"1\":{\"4\":1}}],[\"创建random对象\",{\"1\":{\"274\":1}}],[\"创建出来的数组每个位置上都有默认值\",{\"1\":{\"235\":1}}],[\"创建出学生对象\",{\"1\":{\"192\":2}}],[\"创建对象越多\",{\"1\":{\"227\":1}}],[\"创建枚举需要添加参数\",{\"1\":{\"221\":1}}],[\"创建类对象\",{\"0\":{\"191\":1}}],[\"创建类的实例\",{\"1\":{\"118\":1}}],[\"创建定时器对象\",{\"1\":{\"166\":1}}],[\"创建并启动此定时任务\",{\"1\":{\"165\":2}}],[\"创建好后\",{\"1\":{\"140\":1}}],[\"创建当前列表\",{\"1\":{\"25\":1}}],[\"中修改过期时间\",{\"1\":{\"914\":1}}],[\"中写对应的登录逻辑\",{\"1\":{\"889\":1}}],[\"中装好\",{\"1\":{\"888\":1}}],[\"中重写对应的请求方式\",{\"1\":{\"876\":1}}],[\"中取出一定数量的样本\",{\"1\":{\"516\":1}}],[\"中采用一个\",{\"1\":{\"516\":1}}],[\"中直接根据\",{\"1\":{\"489\":1}}],[\"中直接继承的\",{\"1\":{\"47\":1}}],[\"中不断切换\",{\"1\":{\"456\":1}}],[\"中不存在时\",{\"1\":{\"57\":1}}],[\"中第一次出现的\",{\"1\":{\"455\":1}}],[\"中求解\",{\"1\":{\"442\":1}}],[\"中涉及的\",{\"1\":{\"436\":1}}],[\"中国加油\",{\"1\":{\"358\":1}}],[\"中处理集合的关键抽象概念\",{\"1\":{\"356\":1}}],[\"中间使用等号进行连接\",{\"1\":{\"753\":1}}],[\"中间可以添加一个断言\",{\"1\":{\"321\":1}}],[\"中间操作不会立即执行\",{\"1\":{\"358\":1}}],[\"中间操作\",{\"1\":{\"71\":1,\"358\":1}}],[\"中导入\",{\"1\":{\"304\":1}}],[\"中方法\",{\"1\":{\"255\":1}}],[\"中除了\",{\"1\":{\"246\":1}}],[\"中字符的所有字符\",{\"1\":{\"246\":1}}],[\"中所有的\",{\"1\":{\"246\":1}}],[\"中的元素组合起来\",{\"1\":{\"364\":1}}],[\"中的前三个\",{\"1\":{\"246\":1}}],[\"中的所有操作\",{\"1\":{\"599\":1}}],[\"中的所有字符\",{\"1\":{\"246\":1}}],[\"中的所有\",{\"1\":{\"246\":1}}],[\"中的两个\",{\"1\":{\"246\":1}}],[\"中的\",{\"0\":{\"368\":1},\"1\":{\"246\":3,\"462\":1,\"516\":2}}],[\"中的某个对象\",{\"1\":{\"48\":1}}],[\"中找不到\",{\"1\":{\"198\":1}}],[\"中途是不允许转换的\",{\"1\":{\"172\":2}}],[\"中断\",{\"0\":{\"144\":1}}],[\"中使用一个类之前\",{\"1\":{\"118\":1}}],[\"中定义的\",{\"1\":{\"218\":1}}],[\"中定义的差不多\",{\"1\":{\"47\":1}}],[\"中定义要在完成之后释放的资源\",{\"1\":{\"90\":1}}],[\"中无法添加相同的键\",{\"1\":{\"57\":1}}],[\"中存取元素\",{\"1\":{\"48\":1}}],[\"中\",{\"0\":{\"199\":1,\"473\":1},\"1\":{\"25\":1,\"56\":1,\"96\":1,\"154\":1,\"229\":1,\"242\":1,\"255\":1,\"256\":1,\"274\":1,\"275\":1,\"365\":2,\"374\":1,\"403\":1,\"445\":1,\"451\":1,\"462\":1,\"466\":1,\"511\":1,\"516\":1,\"605\":1,\"679\":1,\"859\":1,\"873\":1}}],[\"中已经帮我们将常用的集合类型都实现好了\",{\"1\":{\"23\":1}}],[\"lstrings\",{\"1\":{\"876\":2}}],[\"lru\",{\"1\":{\"701\":1}}],[\"lt\",{\"1\":{\"653\":1,\"691\":1}}],[\"lnπ\",{\"1\":{\"529\":1}}],[\"l2​=log2​\",{\"1\":{\"384\":1}}],[\"l2​\",{\"1\":{\"384\":1}}],[\"l1​=log2​\",{\"1\":{\"384\":1}}],[\"l1​\",{\"1\":{\"384\":1}}],[\"l=min\",{\"1\":{\"384\":1}}],[\"let\",{\"1\":{\"864\":1,\"893\":1}}],[\"level=all\",{\"1\":{\"756\":2,\"768\":2}}],[\"level\",{\"1\":{\"727\":15,\"728\":4,\"729\":6,\"745\":2,\"756\":4}}],[\"left\",{\"1\":{\"586\":1,\"667\":1,\"670\":1,\"672\":2}}],[\"learning是优化长期目标\",{\"1\":{\"387\":1}}],[\"learning的部署算法不同的是\",{\"1\":{\"388\":1}}],[\"learning的移动算法\",{\"1\":{\"388\":1}}],[\"learning的优化目标是最大化长期收益\",{\"1\":{\"387\":1}}],[\"learning的方案来解决无人机的np\",{\"1\":{\"379\":1}}],[\"learning算法\",{\"1\":{\"387\":1}}],[\"learning\",{\"0\":{\"377\":1,\"483\":1,\"485\":1,\"489\":1,\"493\":1,\"494\":1,\"498\":1,\"511\":1,\"512\":1,\"514\":1,\"515\":1},\"1\":{\"379\":2,\"493\":1,\"494\":1,\"497\":1,\"498\":1,\"515\":1}}],[\"length方法可以求字符串长度\",{\"1\":{\"244\":1}}],[\"length属性是int类型的值\",{\"1\":{\"236\":1}}],[\"length\",{\"1\":{\"25\":1,\"59\":2,\"60\":1,\"71\":1,\"98\":1,\"199\":1,\"236\":2,\"237\":1,\"244\":2,\"333\":1,\"340\":1,\"343\":4,\"362\":2,\"365\":3,\"616\":2,\"808\":1,\"908\":1,\"913\":1}}],[\"length字段\",{\"1\":{\"25\":2}}],[\"location\",{\"1\":{\"565\":3,\"899\":2,\"908\":1,\"913\":1}}],[\"localhost\",{\"1\":{\"536\":1,\"537\":1,\"538\":1,\"543\":1,\"544\":1,\"605\":1,\"613\":1,\"721\":1,\"753\":1,\"834\":1,\"864\":5,\"908\":2,\"910\":1,\"913\":2}}],[\"local\",{\"1\":{\"162\":4,\"163\":4}}],[\"loss\",{\"1\":{\"515\":1}}],[\"logs目录\",{\"1\":{\"864\":1}}],[\"log4j12<\",{\"1\":{\"842\":1}}],[\"log4j2\",{\"1\":{\"768\":1}}],[\"log4j\",{\"1\":{\"768\":1}}],[\"log注解即可\",{\"1\":{\"767\":1}}],[\"logrecord\",{\"1\":{\"761\":2,\"765\":1}}],[\"logmanager\",{\"1\":{\"756\":4}}],[\"logmanager$rootlogger\",{\"1\":{\"744\":1}}],[\"log这种格式\",{\"1\":{\"735\":1}}],[\"logger也是可以使用lombok快速生成的\",{\"1\":{\"767\":1}}],[\"logger4\",{\"1\":{\"747\":2}}],[\"logger3\",{\"1\":{\"747\":2}}],[\"logger2\",{\"1\":{\"747\":4}}],[\"logger1\",{\"1\":{\"747\":2}}],[\"logger类还为我们提供了两个比较特殊的日志级别\",{\"1\":{\"729\":1}}],[\"logger默认情况下只会打印info级别以上的日志\",{\"1\":{\"728\":1}}],[\"logger\",{\"1\":{\"725\":4,\"727\":10,\"728\":7,\"729\":2,\"735\":5,\"736\":2,\"737\":1,\"744\":9,\"745\":2,\"746\":2,\"747\":8,\"756\":4,\"763\":4}}],[\"logging表示使用jul进行日志打印\",{\"1\":{\"768\":1}}],[\"logging表示直接使用标准输出将日志信息打印到控制台\",{\"1\":{\"768\":1}}],[\"logging包下\",{\"1\":{\"725\":1}}],[\"logging相关模块后\",{\"1\":{\"304\":1}}],[\"logging\",{\"1\":{\"304\":1,\"308\":2,\"311\":1,\"669\":1,\"744\":1,\"756\":2,\"764\":1,\"768\":8,\"834\":1,\"864\":1}}],[\"loggin\",{\"1\":{\"304\":1}}],[\"logimpl包括很多种配置项\",{\"1\":{\"768\":1}}],[\"logimpl\",{\"1\":{\"669\":1,\"768\":2,\"834\":1}}],[\"login进行登陆\",{\"1\":{\"910\":1}}],[\"loginservlet\",{\"1\":{\"886\":1,\"889\":1}}],[\"login\",{\"1\":{\"590\":1,\"886\":3,\"889\":1,\"902\":1,\"913\":2,\"921\":2}}],[\"log\",{\"1\":{\"311\":3,\"728\":4,\"737\":1,\"738\":1,\"767\":4,\"849\":3,\"876\":1,\"881\":2}}],[\"lombok依赖\",{\"1\":{\"825\":1}}],[\"lombok1\",{\"0\":{\"626\":1,\"627\":1}}],[\"lombok可以说是简化代码的神器了\",{\"1\":{\"344\":1}}],[\"lombok的噩梦来了\",{\"1\":{\"344\":1}}],[\"lombok模块\",{\"1\":{\"311\":1}}],[\"lombok\",{\"0\":{\"941\":1},\"1\":{\"311\":2,\"368\":1,\"627\":1,\"628\":2,\"643\":1,\"849\":1},\"2\":{\"631\":1}}],[\"lowercaseprinter\",{\"1\":{\"354\":2}}],[\"lowercase\",{\"1\":{\"323\":1}}],[\"low\",{\"1\":{\"227\":2}}],[\"loop\",{\"1\":{\"167\":1}}],[\"looptime\",{\"1\":{\"165\":5}}],[\"lol\",{\"1\":{\"138\":1}}],[\"long\",{\"1\":{\"132\":1,\"133\":1,\"138\":1,\"143\":1,\"165\":4,\"215\":2,\"227\":3,\"229\":1,\"358\":1,\"509\":1,\"648\":1,\"808\":1,\"876\":3,\"921\":1}}],[\"loadonstartup\",{\"1\":{\"881\":1,\"889\":1}}],[\"loaded\",{\"1\":{\"606\":2}}],[\"loading\",{\"1\":{\"605\":2,\"606\":1}}],[\"load\",{\"1\":{\"58\":1,\"60\":1,\"606\":1,\"754\":1}}],[\"loadfactor\",{\"1\":{\"58\":2}}],[\"lbw\",{\"1\":{\"133\":1}}],[\"lbwnb\",{\"1\":{\"92\":2,\"126\":1,\"163\":1,\"242\":1,\"258\":2,\"281\":1,\"903\":1}}],[\"lb\",{\"1\":{\"93\":1}}],[\"label>\",{\"1\":{\"886\":2,\"910\":1}}],[\"large\",{\"1\":{\"449\":1,\"810\":2}}],[\"law\",{\"1\":{\"449\":1}}],[\"language\",{\"1\":{\"544\":1,\"561\":5,\"908\":1,\"913\":1}}],[\"lang包下的类\",{\"1\":{\"274\":1}}],[\"lang包下的\",{\"1\":{\"120\":1}}],[\"lang\",{\"1\":{\"120\":1,\"139\":1,\"182\":1,\"198\":2,\"208\":4,\"220\":1,\"221\":2,\"344\":1,\"658\":3,\"808\":2}}],[\"lang这个包下的所有类\",{\"1\":{\"120\":1}}],[\"lambda仅支持接口\",{\"1\":{\"290\":1}}],[\"lambda表达式简化\",{\"1\":{\"353\":1}}],[\"lambda表达式的具体规范\",{\"1\":{\"257\":1,\"290\":1}}],[\"lambda表达式\",{\"0\":{\"257\":1}}],[\"lambda\",{\"0\":{\"287\":1,\"289\":1,\"290\":1},\"1\":{\"35\":1,\"256\":1,\"257\":1,\"291\":1,\"294\":1}}],[\"lastmodified\",{\"1\":{\"876\":6}}],[\"lastreturned\",{\"1\":{\"33\":1}}],[\"lastret\",{\"1\":{\"33\":1}}],[\"last\",{\"1\":{\"25\":1}}],[\"lastindexof\",{\"1\":{\"24\":1}}],[\"lib目录\",{\"1\":{\"864\":1}}],[\"lib\",{\"1\":{\"827\":1}}],[\"lifecycle\",{\"1\":{\"803\":1}}],[\"like\",{\"1\":{\"544\":1,\"580\":2,\"908\":1,\"913\":1}}],[\"link\",{\"1\":{\"382\":1}}],[\"linkedmap\",{\"1\":{\"67\":1}}],[\"linkedset\",{\"1\":{\"67\":1}}],[\"linkedhashmap中的结点实现\",{\"1\":{\"61\":1}}],[\"linkedhashmap\",{\"0\":{\"61\":1},\"1\":{\"49\":1,\"57\":1,\"61\":2}}],[\"linkedhashset<>\",{\"1\":{\"49\":1}}],[\"linkedhashset\",{\"0\":{\"49\":1},\"1\":{\"49\":2}}],[\"linkedlist<e>\",{\"1\":{\"25\":1,\"42\":1}}],[\"linkedlist<>\",{\"1\":{\"25\":2,\"43\":1,\"44\":1,\"174\":1}}],[\"linkedlist\",{\"1\":{\"25\":3,\"33\":1,\"42\":1,\"43\":1}}],[\"line\",{\"1\":{\"341\":2}}],[\"lines\",{\"1\":{\"112\":1,\"331\":2}}],[\"limiting\",{\"1\":{\"509\":1}}],[\"limit\",{\"1\":{\"71\":3,\"112\":1,\"321\":1,\"322\":2,\"358\":1,\"583\":2}}],[\"li\",{\"1\":{\"24\":4}}],[\"listener\",{\"0\":{\"917\":1,\"922\":1}}],[\"listed\",{\"1\":{\"864\":1}}],[\"listn\",{\"1\":{\"371\":1}}],[\"list初始化\",{\"0\":{\"371\":1}}],[\"list2\",{\"1\":{\"365\":2}}],[\"list1\",{\"1\":{\"365\":3,\"371\":1}}],[\"listfiles\",{\"1\":{\"98\":1}}],[\"list<book>\",{\"1\":{\"670\":1}}],[\"list<user>\",{\"1\":{\"653\":2,\"694\":1,\"712\":1,\"713\":1,\"715\":1,\"716\":1,\"717\":1}}],[\"list<test>\",{\"1\":{\"84\":1}}],[\"list<student>\",{\"1\":{\"65\":1,\"371\":1,\"643\":1,\"647\":1,\"659\":2}}],[\"list<string>\",{\"1\":{\"25\":6,\"30\":2,\"34\":2,\"35\":1,\"71\":2,\"186\":1,\"193\":1,\"318\":1,\"358\":1,\"361\":1,\"362\":1,\"365\":2,\"371\":2,\"688\":1,\"811\":1,\"812\":1}}],[\"list<list<string>>\",{\"1\":{\"25\":1}}],[\"list<integer>\",{\"1\":{\"25\":2,\"71\":3,\"76\":1,\"77\":1,\"78\":1,\"79\":3,\"80\":1,\"173\":1,\"364\":1,\"365\":2}}],[\"list<e>\",{\"1\":{\"24\":2,\"25\":2,\"42\":1}}],[\"listiterator\",{\"1\":{\"24\":4}}],[\"listiterator<e>\",{\"1\":{\"24\":4,\"37\":1}}],[\"list中可插入重复元素\",{\"1\":{\"24\":1}}],[\"list是一个有序的集合类\",{\"1\":{\"24\":1}}],[\"list\",{\"0\":{\"24\":1},\"1\":{\"23\":2,\"24\":3,\"25\":30,\"30\":4,\"34\":4,\"35\":2,\"71\":31,\"76\":3,\"77\":2,\"78\":3,\"79\":4,\"80\":12,\"84\":4,\"98\":1,\"173\":2,\"186\":2,\"306\":1,\"318\":2,\"358\":6,\"361\":6,\"362\":6,\"364\":5,\"365\":12,\"371\":7,\"606\":1,\"688\":1,\"693\":2,\"694\":2,\"811\":1,\"812\":6}}],[\"ruby\",{\"1\":{\"817\":1}}],[\"runable的的匿名内部类实现\",{\"1\":{\"290\":1}}],[\"runoob\",{\"1\":{\"246\":3}}],[\"running\",{\"1\":{\"221\":5}}],[\"runnable\",{\"1\":{\"139\":3,\"165\":8,\"288\":1,\"290\":3,\"344\":1}}],[\"runtime\",{\"1\":{\"206\":1,\"207\":4,\"208\":1,\"833\":1}}],[\"runtimeexceptionruntimeexception\",{\"1\":{\"264\":1}}],[\"runtimeexception\",{\"1\":{\"110\":1,\"174\":1,\"264\":1,\"265\":3,\"266\":2,\"267\":2,\"537\":1,\"543\":1,\"613\":1,\"889\":1}}],[\"run方法\",{\"1\":{\"141\":1}}],[\"run\",{\"1\":{\"139\":2,\"165\":2,\"166\":1,\"167\":2,\"288\":1,\"290\":1,\"344\":1,\"509\":1}}],[\"right\",{\"1\":{\"586\":1}}],[\"rˉπ​\",{\"1\":{\"529\":1}}],[\"rˉπ​​\",{\"1\":{\"528\":1}}],[\"rˉπ​=s∈s∑​dπ​\",{\"1\":{\"527\":1}}],[\"r1​\",{\"1\":{\"486\":1}}],[\"rk​+γv\",{\"1\":{\"484\":1}}],[\"rkn​​mss​\",{\"1\":{\"384\":1}}],[\"rkn​​\",{\"1\":{\"384\":3}}],[\"r→r\",{\"1\":{\"470\":1}}],[\"rm\",{\"0\":{\"469\":1},\"1\":{\"471\":1,\"473\":1,\"478\":3,\"484\":2}}],[\"roles\",{\"1\":{\"864\":3}}],[\"roles=\",{\"1\":{\"864\":2}}],[\"rolename=\",{\"1\":{\"864\":2}}],[\"role\",{\"1\":{\"864\":4}}],[\"rollback\",{\"1\":{\"599\":3,\"623\":3,\"682\":1}}],[\"row\",{\"1\":{\"598\":2,\"669\":2}}],[\"robbins\",{\"0\":{\"469\":1},\"1\":{\"472\":2}}],[\"rootlogger\",{\"1\":{\"756\":2,\"768\":2}}],[\"rootnode\",{\"1\":{\"636\":2}}],[\"root\",{\"1\":{\"466\":1,\"472\":1,\"478\":1,\"484\":1,\"605\":1,\"613\":1}}],[\"roundingmode是舍入模式\",{\"1\":{\"229\":1}}],[\"roundingmode\",{\"1\":{\"229\":1}}],[\"r+s\",{\"1\":{\"440\":2}}],[\"r+γa∈a\",{\"1\":{\"515\":1,\"516\":3}}],[\"r+γqπ​\",{\"1\":{\"489\":1}}],[\"r+γg∣s=s\",{\"1\":{\"487\":1}}],[\"r+γv\",{\"1\":{\"484\":6}}],[\"r+γ∑s\",{\"1\":{\"422\":1}}],[\"r+γs\",{\"1\":{\"419\":1,\"422\":1,\"429\":1,\"437\":1}}],[\"rπ​+γpπ​v1​\",{\"1\":{\"444\":1}}],[\"rπ​+γpπ​vπ1​​\",{\"1\":{\"444\":1}}],[\"rπ​+γpπ​vπ0​​\",{\"1\":{\"444\":2}}],[\"rπ​+γpπ​vπk​​\",{\"1\":{\"440\":1,\"444\":1,\"451\":1}}],[\"rπ​+γpπ​vk​\",{\"1\":{\"436\":1,\"437\":1,\"444\":1}}],[\"rπ​+γpπ​v\",{\"1\":{\"429\":1,\"432\":1,\"435\":1}}],[\"rπ​\",{\"1\":{\"420\":2,\"527\":4,\"528\":1}}],[\"rπ​=\",{\"1\":{\"420\":1}}],[\"r​​+mean\",{\"1\":{\"419\":1}}],[\"r​\",{\"1\":{\"417\":1}}],[\"r∑​p\",{\"1\":{\"417\":1,\"419\":2,\"422\":1,\"429\":1,\"437\":1,\"440\":2}}],[\"rl9\",{\"0\":{\"521\":1}}],[\"rl8\",{\"0\":{\"504\":1}}],[\"rl7\",{\"0\":{\"483\":1}}],[\"rl\",{\"1\":{\"466\":1}}],[\"rl6\",{\"0\":{\"466\":1}}],[\"rl5\",{\"0\":{\"449\":1}}],[\"rl4\",{\"0\":{\"435\":1}}],[\"rl3\",{\"0\":{\"426\":1}}],[\"rl2\",{\"0\":{\"410\":1}}],[\"rl10\",{\"0\":{\"397\":1}}],[\"rl1\",{\"0\":{\"391\":1}}],[\"r∣s\",{\"1\":{\"394\":1,\"415\":1,\"417\":1,\"419\":3,\"422\":2,\"429\":1,\"437\":2,\"440\":2,\"449\":1,\"451\":3,\"527\":2}}],[\"r=1∣s1​\",{\"1\":{\"393\":1}}],[\"rt\",{\"1\":{\"606\":1}}],[\"rt+2​\",{\"1\":{\"528\":1}}],[\"rt+2​+γrt+3​+\",{\"1\":{\"416\":1}}],[\"rt+1​+rt+2​+⋯+rt+n​∣st​=s0​\",{\"1\":{\"528\":1}}],[\"rt+1​+γq^​\",{\"1\":{\"513\":1}}],[\"rt+1​+γqt​\",{\"1\":{\"490\":1}}],[\"rt+1​+γv^\",{\"1\":{\"512\":2}}],[\"rt+1​+γvt​\",{\"1\":{\"486\":2}}],[\"rt+1​+γa∈a\",{\"1\":{\"514\":1}}],[\"rt+1​+γa∈amax​qt​\",{\"1\":{\"494\":1}}],[\"rt+1​+γamax​q\",{\"1\":{\"493\":1}}],[\"rt+1​+γgt+1​∣st​=s\",{\"1\":{\"416\":1}}],[\"rt+1​\",{\"1\":{\"486\":2,\"490\":1,\"528\":1}}],[\"rt+1​∣st​=s\",{\"1\":{\"416\":2,\"417\":2,\"419\":1}}],[\"rt+1​∣at+1​\",{\"1\":{\"394\":1}}],[\"rt​∣st​\",{\"1\":{\"387\":1}}],[\"rtt\",{\"1\":{\"384\":1}}],[\"r\",{\"1\":{\"246\":2,\"362\":1,\"394\":3,\"484\":3,\"515\":1,\"516\":1,\"527\":3,\"544\":2}}],[\"raised\",{\"1\":{\"606\":1}}],[\"rate\",{\"1\":{\"393\":1,\"413\":1,\"432\":1}}],[\"random是一个随机数工具类\",{\"1\":{\"71\":1}}],[\"random支持直接生成随机数的流\",{\"1\":{\"71\":1}}],[\"random\",{\"1\":{\"71\":8,\"274\":6,\"388\":2,\"416\":1,\"780\":4,\"804\":1,\"807\":4}}],[\"randomaccess\",{\"1\":{\"25\":1}}],[\"rawtypes\",{\"1\":{\"24\":1,\"60\":1}}],[\"req\",{\"1\":{\"876\":20,\"881\":1,\"886\":2,\"889\":4,\"891\":1,\"892\":2,\"893\":1,\"900\":8,\"901\":1,\"908\":1,\"910\":4,\"913\":2,\"921\":9}}],[\"requests\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"request\",{\"1\":{\"333\":4,\"874\":6,\"876\":3,\"919\":2,\"921\":1}}],[\"required\",{\"1\":{\"864\":2}}],[\"requiredargsconstructor\",{\"1\":{\"629\":1}}],[\"requiredargsconstructor来快速生成参数只包含final或被标记为\",{\"1\":{\"629\":1}}],[\"requires\",{\"1\":{\"304\":2,\"307\":1,\"308\":2,\"310\":1,\"311\":2}}],[\"requirenonnull\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1,\"352\":1}}],[\"reraise\",{\"1\":{\"606\":1}}],[\"remember\",{\"1\":{\"606\":1,\"910\":2}}],[\"removing\",{\"1\":{\"167\":1}}],[\"removelastoccurrence\",{\"1\":{\"44\":1}}],[\"removelast\",{\"1\":{\"44\":1}}],[\"removefirstoccurrence\",{\"1\":{\"44\":1}}],[\"removefirst\",{\"1\":{\"44\":1}}],[\"removed\",{\"1\":{\"23\":3}}],[\"removeif\",{\"1\":{\"23\":1}}],[\"removeall\",{\"1\":{\"23\":1,\"47\":1}}],[\"remove\",{\"1\":{\"23\":2,\"24\":1,\"25\":4,\"32\":3,\"37\":1,\"43\":1,\"47\":1,\"48\":1,\"56\":1,\"66\":2,\"84\":2,\"193\":1,\"371\":2}}],[\"revoke\",{\"1\":{\"591\":1}}],[\"revoke等\",{\"1\":{\"561\":1}}],[\"receiver\",{\"1\":{\"537\":1}}],[\"record抽象类\",{\"1\":{\"344\":1}}],[\"record\",{\"1\":{\"344\":3,\"761\":5,\"765\":5}}],[\"reinforce\",{\"0\":{\"530\":1,\"531\":1},\"1\":{\"530\":1}}],[\"reinforcement\",{\"0\":{\"377\":1}}],[\"rewards\",{\"0\":{\"417\":1,\"418\":1},\"1\":{\"394\":1,\"419\":2,\"528\":1}}],[\"reward\",{\"1\":{\"387\":1,\"393\":2,\"394\":2,\"489\":1,\"528\":1}}],[\"reason\",{\"1\":{\"606\":6}}],[\"reaction\",{\"1\":{\"368\":1}}],[\"readystate\",{\"1\":{\"893\":1}}],[\"readconfiguration\",{\"1\":{\"756\":1}}],[\"readwrite\",{\"1\":{\"720\":1}}],[\"readonly\",{\"1\":{\"701\":1}}],[\"readonly=\",{\"1\":{\"701\":1}}],[\"readobject\",{\"1\":{\"131\":1,\"133\":1}}],[\"readboolean\",{\"1\":{\"129\":1}}],[\"readline\",{\"1\":{\"112\":1,\"537\":3}}],[\"readlimit\",{\"1\":{\"108\":2}}],[\"read\",{\"1\":{\"91\":5,\"94\":1,\"96\":2,\"105\":1,\"108\":8,\"112\":1,\"126\":1,\"199\":1,\"323\":1,\"333\":1,\"538\":1,\"543\":2,\"544\":1,\"599\":3}}],[\"reader\",{\"1\":{\"88\":1,\"96\":5,\"112\":6,\"113\":4,\"126\":2,\"537\":4}}],[\"relayed\",{\"1\":{\"352\":1}}],[\"registeraliases\",{\"1\":{\"721\":1}}],[\"register=fri\",{\"1\":{\"669\":1}}],[\"register\",{\"1\":{\"606\":1,\"666\":1,\"667\":2,\"669\":1}}],[\"registerdriver\",{\"1\":{\"606\":2}}],[\"registereddrivers\",{\"1\":{\"606\":3}}],[\"registered\",{\"1\":{\"605\":1}}],[\"registernatives\",{\"1\":{\"215\":2}}],[\"regexp\",{\"1\":{\"246\":2}}],[\"regular\",{\"1\":{\"246\":1}}],[\"referer\",{\"1\":{\"908\":1,\"913\":1}}],[\"references\",{\"1\":{\"167\":1,\"564\":1,\"565\":1}}],[\"refers\",{\"1\":{\"466\":1}}],[\"reflection\",{\"1\":{\"606\":1}}],[\"reflectiveoperationexception\",{\"1\":{\"192\":2,\"193\":2,\"616\":1}}],[\"reflectiveobjects\",{\"1\":{\"186\":1}}],[\"reflect\",{\"1\":{\"186\":1}}],[\"repository\",{\"1\":{\"827\":1}}],[\"replay\",{\"0\":{\"517\":1},\"1\":{\"516\":1}}],[\"replaceunderscores\",{\"1\":{\"779\":1}}],[\"replace\",{\"1\":{\"66\":2}}],[\"replace方法可以快速替换某个映射的值\",{\"1\":{\"66\":1}}],[\"replaceall\",{\"1\":{\"24\":1}}],[\"representation\",{\"1\":{\"504\":2}}],[\"representing\",{\"1\":{\"183\":1}}],[\"repeatedtest\",{\"1\":{\"807\":1,\"834\":1}}],[\"repeat\",{\"1\":{\"331\":2}}],[\"repeatable\",{\"1\":{\"205\":1,\"599\":1}}],[\"re\",{\"1\":{\"167\":1}}],[\"restrict|cascade\",{\"1\":{\"568\":1,\"569\":1}}],[\"resp\",{\"1\":{\"876\":19,\"881\":3,\"886\":1,\"889\":5,\"891\":5,\"892\":3,\"893\":3,\"899\":4,\"900\":4,\"901\":2,\"908\":2,\"910\":5,\"913\":1}}],[\"respect\",{\"1\":{\"393\":1}}],[\"responsetext\",{\"1\":{\"893\":1}}],[\"response\",{\"1\":{\"333\":5,\"875\":3,\"876\":3,\"921\":1}}],[\"res\",{\"1\":{\"338\":6,\"340\":3,\"621\":3,\"622\":3,\"876\":3,\"921\":8}}],[\"reserve\",{\"1\":{\"295\":2}}],[\"reset\",{\"1\":{\"108\":5}}],[\"result注解时\",{\"1\":{\"718\":1}}],[\"results\",{\"1\":{\"715\":1,\"718\":1}}],[\"results注解来实现这种操作\",{\"1\":{\"715\":1}}],[\"resultset\",{\"1\":{\"605\":1,\"616\":1,\"621\":1,\"622\":1}}],[\"resultmap\",{\"1\":{\"716\":1}}],[\"resultmap>\",{\"1\":{\"652\":1,\"658\":1,\"666\":1,\"667\":1,\"668\":1,\"670\":1,\"671\":1,\"672\":2,\"715\":1}}],[\"resultmap=\",{\"1\":{\"652\":1,\"658\":1,\"666\":1,\"668\":1,\"671\":1,\"672\":2}}],[\"resulttype无需设置为list这种类型\",{\"1\":{\"653\":1}}],[\"resulttype指定为我们刚刚定义的实体类\",{\"1\":{\"643\":1}}],[\"resulttype=\",{\"1\":{\"643\":1,\"648\":1,\"650\":1,\"651\":1,\"653\":2,\"659\":3,\"660\":1,\"668\":1,\"671\":1,\"672\":1,\"690\":1,\"691\":1,\"703\":1,\"704\":1,\"712\":1,\"719\":1}}],[\"resulting\",{\"1\":{\"393\":1}}],[\"result4\",{\"1\":{\"367\":1}}],[\"result3\",{\"1\":{\"367\":1}}],[\"result2\",{\"1\":{\"366\":4}}],[\"result1\",{\"1\":{\"366\":1}}],[\"result<>\",{\"1\":{\"366\":2}}],[\"result<string>\",{\"1\":{\"366\":2,\"367\":2}}],[\"result<t>\",{\"1\":{\"366\":1}}],[\"result\",{\"1\":{\"245\":2,\"366\":3,\"367\":6,\"715\":2,\"718\":2}}],[\"resource=\",{\"1\":{\"659\":1}}],[\"resources目录\",{\"1\":{\"818\":1}}],[\"resources\",{\"1\":{\"641\":1,\"834\":1,\"888\":1,\"889\":1,\"891\":2}}],[\"resource\",{\"1\":{\"92\":1,\"641\":2}}],[\"resource语法会自动帮助我们close\",{\"1\":{\"605\":1}}],[\"resource语法现在不需要再完整的声明一个变量了\",{\"1\":{\"323\":1}}],[\"resource语法\",{\"1\":{\"90\":1}}],[\"resize\",{\"0\":{\"60\":1},\"1\":{\"59\":2,\"60\":2}}],[\"reduce1\",{\"1\":{\"364\":2}}],[\"reducestreamdemo\",{\"1\":{\"364\":1}}],[\"reduce\",{\"1\":{\"71\":1,\"364\":9}}],[\"retrieve\",{\"1\":{\"561\":1}}],[\"retry\",{\"1\":{\"107\":1}}],[\"retention和1\",{\"1\":{\"206\":1}}],[\"retention表示此注解的保留策略\",{\"1\":{\"206\":1}}],[\"retentionpolicy\",{\"1\":{\"206\":2,\"207\":4,\"208\":2}}],[\"retention\",{\"1\":{\"205\":1,\"206\":2,\"207\":4,\"208\":2}}],[\"retainall\",{\"1\":{\"23\":1,\"47\":1}}],[\"returned\",{\"1\":{\"669\":1}}],[\"returning\",{\"1\":{\"606\":1}}],[\"return为\",{\"1\":{\"413\":1}}],[\"return的描述\",{\"1\":{\"413\":1}}],[\"return越短视\",{\"1\":{\"393\":1}}],[\"returns\",{\"1\":{\"352\":1,\"415\":1}}],[\"return\",{\"0\":{\"415\":1,\"527\":1},\"1\":{\"7\":1,\"8\":2,\"14\":3,\"15\":1,\"23\":4,\"25\":3,\"33\":2,\"36\":4,\"47\":1,\"59\":3,\"60\":1,\"64\":3,\"65\":3,\"67\":3,\"84\":7,\"107\":1,\"173\":1,\"183\":1,\"199\":1,\"215\":2,\"216\":3,\"220\":1,\"221\":2,\"227\":2,\"257\":2,\"258\":1,\"266\":2,\"282\":2,\"290\":3,\"291\":1,\"292\":2,\"294\":3,\"295\":1,\"307\":1,\"323\":1,\"338\":2,\"339\":1,\"342\":4,\"352\":2,\"355\":1,\"359\":1,\"365\":1,\"366\":4,\"367\":4,\"368\":5,\"374\":2,\"393\":2,\"413\":1,\"415\":3,\"416\":1,\"422\":2,\"452\":1,\"456\":1,\"487\":1,\"511\":1,\"606\":2,\"616\":2,\"627\":3,\"647\":2,\"719\":1,\"721\":1,\"761\":2,\"765\":1,\"789\":3,\"797\":2,\"811\":1,\"871\":2,\"910\":1,\"913\":1,\"921\":1}}],[\"us\",{\"1\":{\"908\":1,\"913\":1}}],[\"usecache\",{\"1\":{\"720\":1}}],[\"usecache=\",{\"1\":{\"703\":1}}],[\"usegeneratedkeys\",{\"1\":{\"714\":1}}],[\"usegeneratedkeys=\",{\"1\":{\"679\":1,\"714\":1}}],[\"use\",{\"1\":{\"567\":1,\"864\":2}}],[\"uses\",{\"1\":{\"310\":1,\"456\":1}}],[\"usermapper\",{\"1\":{\"888\":2,\"889\":2,\"910\":2}}],[\"userdetail\",{\"1\":{\"666\":2,\"667\":1,\"668\":2,\"718\":1}}],[\"user>\",{\"1\":{\"653\":1}}],[\"user类型或是map类型\",{\"1\":{\"653\":1}}],[\"user来创建用户\",{\"1\":{\"589\":1}}],[\"users\",{\"1\":{\"378\":2,\"688\":2,\"693\":1,\"694\":2,\"864\":2,\"888\":1}}],[\"userbuilder\",{\"1\":{\"368\":7}}],[\"username+\",{\"1\":{\"621\":1,\"622\":1}}],[\"username=test\",{\"1\":{\"753\":1}}],[\"username=\",{\"1\":{\"368\":1,\"621\":2,\"622\":2,\"864\":2}}],[\"username\",{\"1\":{\"344\":3,\"368\":12,\"621\":1,\"622\":1,\"641\":1,\"652\":2,\"715\":3,\"834\":1,\"886\":1,\"888\":6,\"889\":4,\"910\":10}}],[\"user\",{\"1\":{\"307\":7,\"368\":10,\"544\":2,\"589\":2,\"606\":4,\"615\":2,\"621\":2,\"622\":2,\"623\":11,\"648\":3,\"649\":5,\"650\":3,\"651\":4,\"652\":5,\"653\":11,\"658\":9,\"660\":6,\"666\":2,\"667\":6,\"668\":3,\"669\":3,\"670\":5,\"672\":6,\"678\":4,\"679\":2,\"680\":3,\"681\":1,\"688\":3,\"690\":2,\"691\":2,\"693\":1,\"694\":8,\"703\":2,\"704\":2,\"712\":2,\"713\":4,\"714\":5,\"715\":3,\"716\":1,\"717\":3,\"718\":3,\"719\":6,\"720\":2,\"812\":1,\"864\":1,\"888\":2,\"889\":4,\"908\":2,\"910\":3,\"913\":9,\"921\":5}}],[\"used\",{\"1\":{\"139\":1}}],[\"uid\",{\"1\":{\"652\":2,\"670\":1,\"671\":1,\"715\":3}}],[\"url的格式为\",{\"1\":{\"859\":1}}],[\"url>\",{\"1\":{\"827\":1}}],[\"url=jdbc\",{\"1\":{\"753\":1}}],[\"url=\",{\"1\":{\"643\":1}}],[\"url\",{\"1\":{\"606\":9,\"621\":1,\"622\":1,\"623\":4,\"641\":1,\"834\":1,\"871\":4,\"873\":1,\"888\":1,\"921\":5}}],[\"uri\",{\"1\":{\"333\":6}}],[\"urisyntaxexception\",{\"1\":{\"333\":4}}],[\"utf\",{\"1\":{\"634\":2,\"641\":1,\"643\":1,\"819\":1,\"834\":1,\"840\":1,\"849\":1,\"888\":1}}],[\"utf8\",{\"1\":{\"566\":2}}],[\"util包下定义的\",{\"1\":{\"23\":1}}],[\"util\",{\"1\":{\"23\":1,\"274\":2,\"275\":1,\"304\":1,\"351\":1,\"355\":1,\"365\":2,\"606\":3,\"725\":1,\"744\":1,\"756\":2,\"764\":1,\"768\":2,\"864\":1}}],[\"uc\",{\"1\":{\"565\":1}}],[\"ua\",{\"1\":{\"544\":3,\"913\":1}}],[\"uavn\",{\"1\":{\"387\":1}}],[\"uavs\",{\"1\":{\"378\":1,\"379\":1}}],[\"uav\",{\"0\":{\"377\":1,\"935\":1},\"1\":{\"378\":1},\"2\":{\"390\":1}}],[\"u0​pu​π1\",{\"1\":{\"444\":1}}],[\"u\",{\"1\":{\"246\":2,\"590\":1}}],[\"upgrade\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"updatetime\",{\"1\":{\"893\":3}}],[\"updateagebyid\",{\"1\":{\"700\":2}}],[\"update>\",{\"1\":{\"680\":1}}],[\"update\",{\"1\":{\"397\":1,\"437\":3,\"444\":2,\"561\":2,\"572\":1,\"598\":2,\"613\":1,\"677\":2,\"680\":1,\"701\":1}}],[\"uppercaseprinter\",{\"1\":{\"354\":2}}],[\"up\",{\"1\":{\"191\":1,\"192\":1}}],[\"unwrapthrowable\",{\"1\":{\"658\":1}}],[\"unnecessary\",{\"1\":{\"605\":1}}],[\"uncommitted\",{\"1\":{\"599\":1}}],[\"unchained\",{\"1\":{\"368\":1}}],[\"unchecked\",{\"1\":{\"24\":1,\"60\":1,\"183\":1}}],[\"und\",{\"1\":{\"544\":1}}],[\"unique\",{\"1\":{\"564\":2,\"565\":1,\"597\":1}}],[\"uniqueness\",{\"1\":{\"432\":1}}],[\"uniform\",{\"0\":{\"508\":1}}],[\"unmanned\",{\"1\":{\"378\":1}}],[\"unmodifiablelist\",{\"1\":{\"79\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"25\":1,\"32\":1,\"289\":1,\"371\":2}}],[\"unaryoperator<e>\",{\"1\":{\"24\":1}}],[\"跟jdbc是一样的\",{\"1\":{\"647\":1}}],[\"跟随一个\",{\"1\":{\"528\":1}}],[\"跟随策略π\",{\"1\":{\"455\":1}}],[\"跟对象成员变量的默认值是一样的\",{\"1\":{\"235\":1}}],[\"跟普通的类一样\",{\"1\":{\"219\":1}}],[\"跟普通方法是一样的\",{\"1\":{\"9\":1}}],[\"跟之前的\",{\"1\":{\"62\":1}}],[\"跟next相反\",{\"1\":{\"37\":1}}],[\"跟我们之前不一样\",{\"1\":{\"58\":1}}],[\"跟我们之前的顺序表思路差不多\",{\"1\":{\"25\":1}}],[\"跟我们之前顺序表的插入是一样的\",{\"1\":{\"24\":1}}],[\"将用户对象添加到session中\",{\"1\":{\"913\":1}}],[\"将我们的tomcat服务器集成到idea中\",{\"1\":{\"865\":1}}],[\"将我们的项目从未命名模块改进为应用程序模块\",{\"1\":{\"311\":1}}],[\"将我们之前编写的前端代码全部放入其中\",{\"1\":{\"864\":1}}],[\"将consolehandler的默认编码格式修改为gbk编码格式\",{\"1\":{\"864\":1}}],[\"将cpu资源让位给其他线程\",{\"1\":{\"147\":1}}],[\"将值设置为空进行测试\",{\"1\":{\"809\":1}}],[\"将值设置为null进行测试\",{\"1\":{\"809\":1}}],[\"将忽略二号测试案例进行测试\",{\"1\":{\"777\":1}}],[\"将日志利用socket通过网络发送到另一个主机\",{\"1\":{\"735\":1}}],[\"将日志直接写入到指定的文件中\",{\"1\":{\"735\":1}}],[\"将日志通过system\",{\"1\":{\"735\":1}}],[\"将1号用户的id改成100\",{\"1\":{\"705\":1}}],[\"将不会通过反射给字段单独赋值\",{\"1\":{\"658\":1}}],[\"将不会执行commit\",{\"1\":{\"623\":1}}],[\"将所有的子标签全部包含\",{\"1\":{\"634\":1}}],[\"将所有状态的\",{\"1\":{\"420\":1}}],[\"将接口和\",{\"1\":{\"633\":1}}],[\"将数据转换为我们可以直接操作的实体类型\",{\"1\":{\"633\":1}}],[\"将startup\",{\"1\":{\"864\":1}}],[\"将str包装进optional\",{\"1\":{\"297\":2}}],[\"将sql语句的提交\",{\"1\":{\"623\":1}}],[\"将查询结果映射为对象\",{\"0\":{\"616\":1}}],[\"将删除表中全部数据\",{\"1\":{\"573\":1}}],[\"将使得整个表中此列的所有数据都被修改\",{\"1\":{\"572\":1}}],[\"将服务端创建在端口8080上\",{\"1\":{\"536\":2,\"544\":1}}],[\"将基于表格表示的策略\",{\"1\":{\"522\":1}}],[\"将该网络的\",{\"1\":{\"516\":1}}],[\"将\",{\"1\":{\"432\":1,\"459\":1,\"516\":2}}],[\"将处于\",{\"1\":{\"403\":1}}],[\"将对于\",{\"1\":{\"397\":1}}],[\"将对应的轨迹所获得的所有reward的总和\",{\"1\":{\"393\":1}}],[\"将上述优化问题简化\",{\"1\":{\"387\":1}}],[\"将上一个已遍历元素修改为新的元素\",{\"1\":{\"37\":1}}],[\"将其copy到stream中\",{\"1\":{\"892\":1}}],[\"将其与数据库打通\",{\"1\":{\"887\":1}}],[\"将其修改为per\",{\"1\":{\"803\":1}}],[\"将其配置为jdk\",{\"1\":{\"768\":1}}],[\"将其设定为stdout\",{\"1\":{\"768\":1}}],[\"将其平均分配给其∣kn​∣个关联用户\",{\"1\":{\"383\":1}}],[\"将其映射为字符串长度的一个新流\",{\"1\":{\"365\":1}}],[\"将其中的抽象方法实现\",{\"1\":{\"255\":1}}],[\"将无法删除\",{\"1\":{\"568\":1}}],[\"将无法通过编译\",{\"1\":{\"264\":1,\"281\":1}}],[\"将无人机部署在每个中心内\",{\"1\":{\"387\":1}}],[\"将无限生成下去\",{\"1\":{\"321\":1}}],[\"将传入的字符串转换为小写并打印\",{\"1\":{\"297\":1}}],[\"将抛出\",{\"1\":{\"268\":1}}],[\"将匹配\",{\"1\":{\"246\":1}}],[\"将匹配的子串替换或者从某个串中取出符合某个条件的子串等\",{\"1\":{\"246\":1}}],[\"将这些值提前做成包装类放在数组中存放\",{\"1\":{\"227\":1}}],[\"将int类型值作为包装类型使用\",{\"1\":{\"227\":1}}],[\"将当前对象转换为string的形式\",{\"1\":{\"215\":1}}],[\"将test\",{\"1\":{\"192\":1}}],[\"将变量的值给予threadlocal\",{\"1\":{\"162\":2}}],[\"将文件内容作为输入流进行扫描\",{\"1\":{\"128\":1}}],[\"将它们以字符串的形式写入到输出流\",{\"1\":{\"127\":1}}],[\"将main类放到com\",{\"1\":{\"120\":1}}],[\"将缓冲区大小设置为1\",{\"1\":{\"108\":1}}],[\"将每一个元素映射为integer类型\",{\"1\":{\"71\":1}}],[\"将会无限进行下去\",{\"1\":{\"71\":1}}],[\"将底层数组变成新的扩容之后的数组\",{\"1\":{\"60\":1}}],[\"将另一个map中的所有键值对添加到当前map中\",{\"1\":{\"56\":1}}],[\"将元素从栈顶出栈\",{\"1\":{\"44\":1}}],[\"将元素推向栈顶\",{\"1\":{\"44\":1}}],[\"将给定集合中所有元素插入到当前结合的给定位置上\",{\"1\":{\"24\":1}}],[\"将集合转换为数组的形式\",{\"1\":{\"23\":1}}],[\"功能还会更多一些\",{\"1\":{\"24\":1}}],[\"相反的\",{\"1\":{\"802\":1}}],[\"相关操作\",{\"1\":{\"754\":1}}],[\"相关的逻辑需要我们在run\",{\"1\":{\"288\":1}}],[\"相应的算法是\",{\"1\":{\"486\":1}}],[\"相应的\",{\"1\":{\"478\":1,\"484\":1}}],[\"相信各位小伙伴在调试代码时\",{\"1\":{\"343\":1}}],[\"相信各位就能感受到注解带来的魅力了\",{\"1\":{\"208\":1}}],[\"相等于\",{\"1\":{\"246\":1}}],[\"相当于在程序运行过程中动态生成了一个实现类\",{\"1\":{\"659\":1}}],[\"相当于没有启动事务\",{\"1\":{\"623\":1}}],[\"相当于没有头结点的链表\",{\"1\":{\"58\":1}}],[\"相当于一个指针\",{\"1\":{\"596\":1}}],[\"相当于\",{\"1\":{\"219\":1}}],[\"相比junit\",{\"1\":{\"785\":1}}],[\"相比java\",{\"1\":{\"327\":1}}],[\"相比直接添加约束\",{\"1\":{\"598\":1}}],[\"相比reader更方便的是\",{\"1\":{\"112\":1}}],[\"相比之前的collection接口定义\",{\"1\":{\"24\":1}}],[\"相同之处\",{\"1\":{\"22\":1}}],[\"其默认值为jar\",{\"1\":{\"832\":1}}],[\"其求解梯度比较难求\",{\"1\":{\"516\":1}}],[\"其定义都是一个均值\",{\"1\":{\"466\":1}}],[\"其探索性就很强\",{\"1\":{\"461\":1}}],[\"其属于\",{\"1\":{\"461\":1}}],[\"其原始定义都是从期望出发的\",{\"1\":{\"449\":1}}],[\"其核心思想是\",{\"1\":{\"449\":1}}],[\"其策略π表示的是最优策略\",{\"1\":{\"429\":1}}],[\"其目标也应该不一样\",{\"1\":{\"387\":1}}],[\"其状态为其3d坐标\",{\"1\":{\"387\":1}}],[\"其高度的下界是距离dkn​​\",{\"1\":{\"383\":1}}],[\"其每个用户带宽表示为\",{\"1\":{\"383\":1}}],[\"其可用带宽为bn​\",{\"1\":{\"383\":1}}],[\"其水平坐标表示为qn​\",{\"1\":{\"382\":1}}],[\"其垂直高度表示为hn​\",{\"1\":{\"382\":1}}],[\"其坐标表示为wkn​​=\",{\"1\":{\"382\":1}}],[\"其在代码中频繁被使用\",{\"1\":{\"366\":1}}],[\"其子类的对应的方法的访问权限需要高于抽象类中的方法\",{\"1\":{\"218\":1}}],[\"其返回值定义了该成员变量的类型\",{\"1\":{\"207\":1}}],[\"其方法名定义了该成员变量的名字\",{\"1\":{\"207\":1}}],[\"其对应的\",{\"1\":{\"186\":1,\"437\":1}}],[\"其实我们只需要继承httpservlet来编写我们的servlet就可以了\",{\"1\":{\"876\":1}}],[\"其实我们可以看到\",{\"1\":{\"133\":1}}],[\"其实缓存机制我们在之前学习io流的时候已经提及过了\",{\"1\":{\"699\":1}}],[\"其实idea本质也是使用的jdbc\",{\"1\":{\"605\":1}}],[\"其实自身连接查询和前面的是一样的\",{\"1\":{\"585\":1}}],[\"其实本质上都差不多\",{\"1\":{\"543\":1}}],[\"其实本质上是定义在对应的包装类中的\",{\"1\":{\"183\":1}}],[\"其实是一种设计模式\",{\"1\":{\"367\":1}}],[\"其实这就是一种方法引用\",{\"1\":{\"291\":1}}],[\"其实枚举类型的本质就是一个普通的类\",{\"1\":{\"221\":1}}],[\"其实不是\",{\"1\":{\"208\":1}}],[\"其实也就是基本类型的class\",{\"1\":{\"183\":1}}],[\"其实就是一个多线程执行的流\",{\"1\":{\"173\":1}}],[\"其实就是编写要在另一个线程执行的内容逻辑\",{\"1\":{\"139\":1}}],[\"其实system\",{\"1\":{\"127\":1}}],[\"其实和bufferedinputstream原理差不多\",{\"1\":{\"110\":1}}],[\"其实mark\",{\"1\":{\"108\":1}}],[\"其实功能和write一样\",{\"1\":{\"97\":1}}],[\"其他就很好找的\",{\"1\":{\"888\":1}}],[\"其他人使用我们的项目作为依赖时\",{\"1\":{\"820\":1}}],[\"其他情况的必须满足大于18岁\",{\"1\":{\"691\":1}}],[\"其他情况e都是null\",{\"1\":{\"59\":1}}],[\"其他小型变动\",{\"0\":{\"323\":1}}],[\"其他的算法\",{\"1\":{\"530\":1}}],[\"其他的集合类都有相应的of方法\",{\"1\":{\"318\":1}}],[\"其他的情况会在讲到反射时介绍\",{\"1\":{\"118\":1}}],[\"其他很多语言比如javascript\",{\"1\":{\"246\":1}}],[\"其他定义方法\",{\"1\":{\"235\":1}}],[\"其他地方不能修改\",{\"1\":{\"217\":1}}],[\"其他线程都无法访问被它占用的锁\",{\"1\":{\"156\":1}}],[\"其他视图操作\",{\"1\":{\"56\":1}}],[\"其他集合类实现\",{\"0\":{\"45\":1}}],[\"其他遍历\",{\"0\":{\"35\":1}}],[\"其他元素一律移除\",{\"1\":{\"23\":1}}],[\"其中一个是之前的正常打包得到的jar文件\",{\"1\":{\"854\":1}}],[\"其中一些字符被用作标签表示\",{\"1\":{\"653\":1}}],[\"其中src目录下存放我们的源代码和测试代码\",{\"1\":{\"818\":1}}],[\"其中st​是随机变量s的一个样本\",{\"1\":{\"510\":1}}],[\"其中matches参数支持正则表达式\",{\"1\":{\"796\":1}}],[\"其中最简单的就是判断结果是否等于某个值\",{\"1\":{\"786\":1}}],[\"其中最突出的就是直接根据下标位置进行的增删改查操作\",{\"1\":{\"24\":1}}],[\"其中参数为logrecord\",{\"1\":{\"761\":1}}],[\"其中test属性就是我们需要填写的判断条件\",{\"1\":{\"690\":1}}],[\"其中uid作为用户id的逻辑外键\",{\"1\":{\"670\":1}}],[\"其中book表设计如下\",{\"1\":{\"670\":1}}],[\"其中property就是需要进行一对一处理的对象\",{\"1\":{\"667\":1}}],[\"其中public和abstract关键字可以省略\",{\"1\":{\"219\":1}}],[\"其中namespace就是命名空间\",{\"1\":{\"643\":1}}],[\"其中restrict和cascade上面的效果一致\",{\"1\":{\"569\":1}}],[\"其中w∈rm是参数向量\",{\"1\":{\"505\":1}}],[\"其中hk​=wk​\",{\"1\":{\"472\":1}}],[\"其中all代表授予所有权限\",{\"1\":{\"591\":1}}],[\"其中ak∗​=argmaxa​qπk​​\",{\"1\":{\"453\":1}}],[\"其中ak∗​\",{\"1\":{\"437\":1}}],[\"其中a∗表示在该状态下计算出来的最大\",{\"1\":{\"431\":1}}],[\"其中vk​是给定的\",{\"1\":{\"437\":1}}],[\"其中f\",{\"1\":{\"432\":1}}],[\"其中cmax​表示用户的最大速度\",{\"1\":{\"388\":1}}],[\"其中σ2=bkn​​n0​\",{\"1\":{\"383\":1}}],[\"其中θkn​​\",{\"1\":{\"383\":1}}],[\"其中k0​=\",{\"1\":{\"383\":1}}],[\"其中kn​表示划分到集群n的用户\",{\"1\":{\"382\":1}}],[\"其中k就是键的类型\",{\"1\":{\"56\":1}}],[\"其中用户表示为k=k1​\",{\"1\":{\"382\":1}}],[\"其中比较关键的是用于lambda的形参局部变量语法\",{\"1\":{\"329\":1}}],[\"其中比较突出的就是局部变量类型推断了\",{\"1\":{\"327\":1}}],[\"其中o1和o2都是integer类型的\",{\"1\":{\"294\":1}}],[\"其中存放的每一个数据称为数组的一个元素\",{\"1\":{\"234\":1}}],[\"其中能够表示数字的基本类型包装类\",{\"1\":{\"227\":1}}],[\"其中的\",{\"1\":{\"120\":1}}],[\"其中\",{\"1\":{\"42\":1,\"246\":1,\"383\":1,\"384\":2,\"420\":1,\"440\":1,\"461\":1,\"470\":1,\"471\":1,\"475\":1,\"484\":1,\"486\":1,\"487\":1,\"490\":1,\"509\":1,\"515\":1,\"522\":1,\"527\":1,\"529\":1,\"551\":1,\"605\":1,\"693\":1,\"701\":1,\"802\":2,\"804\":1,\"875\":1,\"888\":1}}],[\"其中很多地方重新定义了一次\",{\"1\":{\"24\":1}}],[\"其变量名存储的是对象的引用\",{\"1\":{\"4\":1}}],[\"h1>\",{\"1\":{\"876\":1,\"881\":1,\"886\":1}}],[\"how\",{\"1\":{\"864\":1}}],[\"home\",{\"1\":{\"864\":1}}],[\"host\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"hh\",{\"1\":{\"765\":1,\"893\":1}}],[\"head\",{\"1\":{\"876\":1}}],[\"headquarters\",{\"1\":{\"565\":1}}],[\"here\",{\"1\":{\"606\":2}}],[\"hello\",{\"1\":{\"5\":2,\"14\":2,\"110\":1,\"244\":6,\"253\":1,\"288\":1,\"289\":1,\"297\":4,\"304\":1,\"311\":1,\"328\":3,\"353\":1,\"354\":1,\"729\":1,\"736\":2,\"756\":1,\"773\":1}}],[\"hybrid\",{\"1\":{\"388\":1}}],[\"humans\",{\"1\":{\"864\":1}}],[\"huav​\",{\"1\":{\"387\":2,\"388\":2}}],[\"hugecapacity\",{\"1\":{\"25\":1}}],[\"hmax​−hmin​+1\",{\"1\":{\"387\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​moskn​​\",{\"1\":{\"387\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​∑t=0ts​​moskn​​\",{\"1\":{\"385\":1}}],[\"hmax​\",{\"1\":{\"382\":1,\"387\":1}}],[\"hmin​≤hn​\",{\"1\":{\"385\":1,\"387\":1}}],[\"hmin​\",{\"1\":{\"382\":1,\"387\":1}}],[\"handlers=java\",{\"1\":{\"756\":1,\"768\":1}}],[\"handler是属于对应的logger的\",{\"1\":{\"745\":1}}],[\"handler\",{\"1\":{\"729\":1,\"735\":1,\"736\":2,\"737\":2,\"738\":3,\"756\":1}}],[\"have\",{\"1\":{\"606\":1,\"864\":1}}],[\"having\",{\"1\":{\"583\":1}}],[\"hard问题\",{\"1\":{\"387\":1}}],[\"hard\",{\"1\":{\"379\":1}}],[\"hasmoreelements\",{\"1\":{\"874\":1}}],[\"has\",{\"1\":{\"432\":1,\"606\":1}}],[\"hashtable<object\",{\"1\":{\"754\":1}}],[\"hash\",{\"1\":{\"58\":1,\"59\":13,\"61\":2,\"84\":1,\"296\":2,\"597\":1}}],[\"hashmap的一个链表长度过大时\",{\"1\":{\"60\":1}}],[\"hashmap并不是只使用简单的链地址法\",{\"1\":{\"58\":1}}],[\"hashmap支持自动扩容\",{\"1\":{\"58\":1}}],[\"hashmap<e\",{\"1\":{\"67\":1}}],[\"hashmap<k\",{\"1\":{\"58\":1}}],[\"hashmap<>\",{\"1\":{\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"67\":1,\"84\":1,\"318\":1}}],[\"hashmap\",{\"0\":{\"57\":1,\"58\":1,\"650\":1},\"1\":{\"48\":1,\"49\":1,\"57\":1,\"58\":2,\"61\":3,\"67\":3,\"650\":1,\"651\":1}}],[\"hashset<e>\",{\"1\":{\"67\":1}}],[\"hashset<>\",{\"1\":{\"48\":3}}],[\"hashset\",{\"0\":{\"48\":1,\"67\":1},\"1\":{\"48\":1,\"67\":5}}],[\"hashcode\",{\"1\":{\"23\":1,\"47\":1,\"56\":1,\"84\":7,\"215\":3}}],[\"hasprevious\",{\"1\":{\"37\":1}}],[\"hasnext\",{\"1\":{\"23\":1,\"24\":1,\"30\":1,\"32\":3,\"34\":1,\"36\":1,\"37\":1}}],[\"hint2\",{\"0\":{\"374\":1}}],[\"hint\",{\"0\":{\"371\":1,\"934\":1},\"2\":{\"373\":1,\"376\":1}}],[\"high\",{\"1\":{\"227\":1}}],[\"href=\",{\"1\":{\"333\":1,\"891\":1}}],[\"httpfilter\",{\"1\":{\"921\":3}}],[\"httponly\",{\"1\":{\"913\":1}}],[\"http请求报文中的所有内容\",{\"1\":{\"873\":1}}],[\"http请求是基于tcp协议\",{\"1\":{\"544\":1}}],[\"http协议首先要和服务器建立tcp连接\",{\"1\":{\"859\":1}}],[\"http协议默认使用80端口\",{\"1\":{\"859\":1}}],[\"http使用tcp协议是为了使得数据传输更加可靠\",{\"1\":{\"859\":1}}],[\"http使用了面向连接的tcp作为运输层协议\",{\"1\":{\"859\":1}}],[\"http虽然使用了tcp连接\",{\"1\":{\"859\":1}}],[\"http不必考虑数据在传输过程中被丢弃后又怎样被重传\",{\"1\":{\"859\":1}}],[\"http不仅传送完成超文本跳转所需的必须信息\",{\"1\":{\"859\":1}}],[\"http的传输原理\",{\"1\":{\"859\":1}}],[\"http是基于tcp进行通信的\",{\"1\":{\"859\":1}}],[\"http是面向事务的应用层协议\",{\"1\":{\"859\":1}}],[\"http是一种应用层协议\",{\"1\":{\"544\":1}}],[\"http\",{\"1\":{\"544\":5,\"641\":1,\"643\":1,\"819\":4,\"834\":1,\"840\":4,\"849\":4,\"864\":5,\"870\":1,\"876\":3,\"888\":1,\"908\":3,\"913\":3,\"921\":1}}],[\"httpresponse<inputstream>\",{\"1\":{\"333\":1}}],[\"httpresponse<string>\",{\"1\":{\"333\":2}}],[\"httpresponse\",{\"1\":{\"333\":3}}],[\"httprequest\",{\"1\":{\"333\":6}}],[\"httpclient\",{\"1\":{\"333\":8}}],[\"httpsessionevent\",{\"1\":{\"922\":1}}],[\"httpsessionlistener\",{\"1\":{\"922\":1}}],[\"httpsession\",{\"1\":{\"913\":2,\"921\":1}}],[\"httpservlet\",{\"1\":{\"876\":3,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1}}],[\"httpservletresponse\",{\"1\":{\"875\":2,\"876\":7,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"921\":4}}],[\"httpservletrequest\",{\"1\":{\"874\":2,\"876\":7,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":2,\"921\":4}}],[\"https\",{\"1\":{\"246\":1,\"333\":5,\"628\":1,\"641\":1,\"669\":1,\"690\":1,\"719\":1,\"812\":1,\"825\":1,\"864\":1}}],[\"html文件\",{\"1\":{\"870\":1}}],[\"html主要用于通过编排来展示数据\",{\"1\":{\"634\":1}}],[\"html\",{\"1\":{\"246\":1,\"333\":10,\"544\":1,\"641\":1,\"719\":1,\"864\":2,\"875\":2,\"876\":1,\"881\":1,\"889\":1,\"892\":1,\"893\":1,\"908\":2,\"913\":2}}],[\"h\",{\"1\":{\"229\":2}}],[\"w3\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"w3c的xml解析库\",{\"1\":{\"636\":1}}],[\"writing\",{\"1\":{\"812\":1}}],[\"writeobject\",{\"1\":{\"131\":1,\"133\":1}}],[\"writeboolean\",{\"1\":{\"129\":1}}],[\"write\",{\"1\":{\"92\":3,\"93\":1,\"94\":1,\"97\":1,\"110\":1,\"113\":1,\"126\":1,\"333\":1,\"537\":3,\"543\":2,\"544\":3,\"875\":1,\"876\":1,\"881\":1,\"889\":3,\"892\":1,\"893\":1}}],[\"writer不会主动加\",{\"1\":{\"537\":1}}],[\"writer除了write方法外\",{\"1\":{\"97\":1}}],[\"writer\",{\"1\":{\"88\":1,\"97\":5,\"126\":2,\"537\":7,\"544\":5}}],[\"wrapexception\",{\"1\":{\"660\":1}}],[\"were\",{\"1\":{\"864\":1}}],[\"weblistener\",{\"1\":{\"922\":1}}],[\"webfilter\",{\"1\":{\"919\":1,\"920\":1,\"921\":1}}],[\"webfilter注解即可\",{\"1\":{\"919\":1}}],[\"webinitparam\",{\"1\":{\"902\":1}}],[\"webtest\",{\"1\":{\"871\":1,\"908\":2,\"913\":3}}],[\"webservlet注解详解\",{\"0\":{\"877\":1}}],[\"webservlet的注解去掉\",{\"1\":{\"871\":1}}],[\"webservlet\",{\"1\":{\"871\":1,\"876\":1,\"878\":2,\"879\":1,\"880\":1,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1,\"902\":1}}],[\"webservlet来进行注册\",{\"1\":{\"871\":1}}],[\"webappclassloader\",{\"1\":{\"926\":1}}],[\"webappclassloader的加载机制是这样的\",{\"1\":{\"926\":1}}],[\"webapp\",{\"1\":{\"864\":1,\"926\":1}}],[\"webapp目录\",{\"1\":{\"864\":1}}],[\"web\",{\"0\":{\"865\":1},\"1\":{\"721\":1,\"834\":1,\"859\":1,\"914\":1}}],[\"webp\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"weak\",{\"1\":{\"701\":1}}],[\"we\",{\"1\":{\"606\":3}}],[\"wt+1​=wt​+αt​n1​i=1∑n​\",{\"1\":{\"516\":1}}],[\"wt​=w\",{\"1\":{\"516\":1}}],[\"wt​\",{\"1\":{\"510\":2,\"511\":2,\"512\":4,\"513\":3,\"514\":3,\"516\":10}}],[\"w−e\",{\"1\":{\"473\":1,\"484\":1}}],[\"w∗\",{\"1\":{\"472\":2}}],[\"w∈r\",{\"1\":{\"470\":1}}],[\"wk−1​\",{\"1\":{\"472\":1}}],[\"wk​−\",{\"1\":{\"484\":1}}],[\"wk​−xk​\",{\"1\":{\"468\":2,\"473\":1}}],[\"wk​\",{\"1\":{\"471\":6,\"472\":1,\"473\":1,\"475\":6,\"478\":12,\"484\":1,\"510\":1}}],[\"wk​+xk​\",{\"1\":{\"468\":1}}],[\"wk​=k−11​i=1∑k−1​xi​\",{\"1\":{\"468\":1}}],[\"wk+1​=wk​+αk​\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"514\":1}}],[\"wk+1​=wk​−αk​g~​\",{\"1\":{\"484\":1}}],[\"wk+1​=wk​−αk​g​\",{\"1\":{\"473\":1,\"478\":1}}],[\"wk+1​=wk​−αk​e\",{\"1\":{\"478\":1}}],[\"wk+1​=wk​−αk​▽w​j\",{\"1\":{\"510\":1}}],[\"wk+1​=wk​−αk​▽w​f\",{\"1\":{\"475\":1}}],[\"wk+1​=wk​−αk​▽w​e\",{\"1\":{\"475\":1}}],[\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f\",{\"1\":{\"475\":1}}],[\"wk+1​=wk​−ak​g​\",{\"1\":{\"471\":1}}],[\"wk+1​=wk​−k1​\",{\"1\":{\"468\":1}}],[\"wk+1​=k1​i=1∑k​xi​\",{\"1\":{\"468\":1}}],[\"wk+1​​=k1​∑i=1k​xi​​=k1​\",{\"1\":{\"468\":1}}],[\"wk+1​可以由wk​推导出来\",{\"1\":{\"468\":1}}],[\"win64\",{\"1\":{\"908\":1,\"913\":1}}],[\"windows\",{\"1\":{\"793\":1,\"864\":1,\"908\":1,\"913\":1}}],[\"wish\",{\"1\":{\"864\":1}}],[\"wide\",{\"1\":{\"859\":1}}],[\"wireless\",{\"1\":{\"378\":1}}],[\"will\",{\"1\":{\"352\":1,\"864\":1}}],[\"with\",{\"0\":{\"511\":1,\"512\":1,\"513\":1,\"514\":1},\"1\":{\"90\":1,\"92\":1,\"167\":1,\"310\":1,\"323\":1,\"384\":1,\"393\":2,\"472\":1,\"591\":1,\"596\":2,\"605\":1,\"606\":1,\"854\":1,\"864\":2}}],[\"w\",{\"1\":{\"246\":1,\"470\":3,\"471\":2,\"472\":3,\"473\":5,\"475\":5,\"478\":15,\"484\":4,\"505\":1,\"506\":1,\"507\":2,\"508\":3,\"509\":3,\"510\":6,\"515\":3,\"516\":21}}],[\"work目录\",{\"1\":{\"864\":1}}],[\"worker\",{\"1\":{\"218\":2}}],[\"world\",{\"1\":{\"14\":1,\"244\":6,\"288\":1,\"289\":1,\"304\":1,\"311\":1,\"328\":3,\"353\":1,\"354\":2,\"729\":1,\"736\":2,\"756\":1,\"773\":1,\"859\":1}}],[\"which\",{\"1\":{\"606\":1}}],[\"while\",{\"1\":{\"23\":1,\"24\":1,\"30\":1,\"32\":1,\"34\":1,\"91\":1,\"94\":1,\"107\":1,\"144\":1,\"165\":1,\"167\":1,\"172\":2,\"174\":3,\"333\":1,\"536\":1,\"543\":2,\"544\":3,\"605\":1,\"614\":1,\"616\":2,\"621\":1,\"622\":1,\"705\":1,\"874\":1}}],[\"why\",{\"0\":{\"421\":1}}],[\"where等操作\",{\"1\":{\"719\":1}}],[\"where子句组成的查询块\",{\"1\":{\"561\":1}}],[\"where\",{\"1\":{\"420\":1,\"432\":1,\"572\":1,\"573\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":2,\"584\":2,\"587\":2,\"596\":1,\"598\":1,\"613\":2,\"621\":2,\"622\":2,\"648\":2,\"650\":1,\"651\":1,\"652\":1,\"653\":1,\"658\":1,\"659\":2,\"660\":2,\"667\":1,\"668\":2,\"669\":2,\"670\":1,\"671\":2,\"672\":1,\"680\":1,\"681\":1,\"690\":1,\"691\":1,\"693\":2,\"703\":1,\"704\":1,\"718\":2,\"719\":4,\"720\":1,\"888\":1}}],[\"when>\",{\"1\":{\"691\":2}}],[\"when\",{\"1\":{\"139\":1,\"167\":1,\"393\":1,\"606\":1}}],[\"what\",{\"1\":{\"191\":1,\"192\":1}}],[\"whatsoever\",{\"1\":{\"139\":1}}],[\"www\",{\"1\":{\"120\":1,\"246\":1,\"333\":1,\"669\":2,\"819\":1,\"840\":1,\"849\":1}}],[\"war\",{\"1\":{\"908\":2,\"913\":3}}],[\"warning\",{\"1\":{\"727\":4,\"728\":1}}],[\"wargmin​j\",{\"1\":{\"475\":1}}],[\"walk\",{\"1\":{\"388\":2,\"606\":1}}],[\"waiting\",{\"1\":{\"161\":1}}],[\"wait需要捕获\",{\"1\":{\"161\":1}}],[\"wait\",{\"1\":{\"161\":6,\"167\":2,\"174\":1,\"215\":3}}],[\"was\",{\"1\":{\"107\":1}}],[\"wang\",{\"1\":{\"65\":3}}],[\"fk\",{\"1\":{\"565\":1}}],[\"fetch\",{\"1\":{\"544\":4,\"908\":4,\"913\":4}}],[\"fulltest\",{\"1\":{\"597\":1}}],[\"future\",{\"0\":{\"418\":1},\"1\":{\"419\":1}}],[\"func3\",{\"1\":{\"773\":2,\"776\":1}}],[\"func2\",{\"1\":{\"773\":2,\"776\":1}}],[\"func1\",{\"1\":{\"773\":2,\"776\":2}}],[\"functionality\",{\"1\":{\"864\":1}}],[\"functionalinterface\",{\"1\":{\"139\":1,\"204\":1,\"290\":2}}],[\"function包中\",{\"1\":{\"351\":1}}],[\"function\",{\"0\":{\"504\":1,\"507\":1,\"511\":1,\"512\":1,\"513\":1,\"514\":1},\"1\":{\"241\":1,\"296\":1,\"362\":1,\"414\":1,\"432\":1,\"504\":1,\"508\":2,\"509\":1,\"510\":1,\"515\":1,\"516\":1,\"521\":1,\"522\":1,\"893\":2}}],[\"fundamental\",{\"1\":{\"426\":1}}],[\"fun\",{\"1\":{\"323\":2}}],[\"fs\",{\"1\":{\"384\":1}}],[\"fs​+l\",{\"1\":{\"384\":1}}],[\"fc​是载波频率\",{\"1\":{\"383\":1}}],[\"free\",{\"0\":{\"449\":1},\"1\":{\"419\":1,\"450\":1,\"451\":1}}],[\"framework\",{\"1\":{\"378\":1}}],[\"francisco\",{\"1\":{\"368\":1}}],[\"from子句\",{\"1\":{\"561\":1}}],[\"from\",{\"1\":{\"167\":1,\"221\":1,\"415\":1,\"422\":2,\"573\":2,\"579\":5,\"581\":2,\"582\":1,\"583\":4,\"584\":3,\"585\":1,\"586\":2,\"587\":2,\"591\":1,\"596\":2,\"597\":1,\"598\":1,\"605\":1,\"606\":1,\"613\":1,\"621\":2,\"622\":2,\"643\":1,\"648\":2,\"650\":1,\"651\":1,\"652\":1,\"653\":2,\"658\":1,\"659\":3,\"660\":2,\"667\":1,\"668\":2,\"669\":2,\"670\":1,\"671\":2,\"672\":4,\"681\":1,\"690\":1,\"691\":1,\"693\":2,\"703\":1,\"704\":1,\"712\":1,\"713\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":2,\"719\":3,\"720\":1,\"864\":1,\"888\":1}}],[\"fromindex\",{\"1\":{\"24\":1}}],[\"four\",{\"1\":{\"864\":1}}],[\"found\",{\"1\":{\"606\":2,\"658\":1,\"660\":1,\"929\":1}}],[\"foem\",{\"1\":{\"429\":1}}],[\"following\",{\"1\":{\"393\":1,\"864\":2}}],[\"followed\",{\"1\":{\"352\":2}}],[\"fooooood\",{\"1\":{\"246\":1}}],[\"foooood\",{\"1\":{\"246\":1}}],[\"food\",{\"1\":{\"246\":1}}],[\"forward\",{\"1\":{\"900\":2,\"901\":1,\"910\":1}}],[\"foreign\",{\"1\":{\"564\":2,\"565\":1}}],[\"foreach>\",{\"1\":{\"693\":1,\"694\":1}}],[\"foreach操作\",{\"1\":{\"692\":1}}],[\"foreach操作的顺序\",{\"1\":{\"173\":1}}],[\"foreach语法遍历每一个元素\",{\"1\":{\"35\":1}}],[\"foreach\",{\"1\":{\"35\":5,\"36\":2,\"65\":2,\"71\":1,\"112\":1,\"173\":1,\"237\":1,\"319\":1,\"320\":2,\"321\":2,\"322\":2,\"331\":1,\"361\":1,\"362\":1,\"643\":1,\"647\":1,\"659\":1,\"886\":1}}],[\"foreachremaining\",{\"1\":{\"32\":1}}],[\"forallw\",{\"1\":{\"472\":1}}],[\"foralls∈s\",{\"1\":{\"453\":1}}],[\"fortheother∣a\",{\"1\":{\"461\":1}}],[\"form>\",{\"1\":{\"886\":1,\"892\":1}}],[\"format\",{\"1\":{\"761\":2,\"765\":3,\"876\":1,\"893\":1}}],[\"formatter=com\",{\"1\":{\"764\":1}}],[\"formatter\",{\"1\":{\"756\":5,\"761\":1}}],[\"formulation\",{\"0\":{\"479\":1}}],[\"form\",{\"0\":{\"420\":1},\"1\":{\"420\":1,\"421\":1,\"423\":2,\"429\":1,\"432\":1,\"437\":1,\"440\":2,\"719\":1,\"886\":1,\"892\":2}}],[\"forkjoinpool\",{\"1\":{\"359\":1}}],[\"forname\",{\"1\":{\"182\":1,\"192\":3,\"605\":1}}],[\"for\",{\"1\":{\"24\":1,\"25\":1,\"30\":2,\"34\":1,\"35\":1,\"36\":1,\"59\":1,\"98\":1,\"138\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"161\":1,\"167\":1,\"172\":2,\"183\":1,\"186\":5,\"192\":1,\"208\":2,\"237\":3,\"241\":1,\"242\":1,\"244\":1,\"274\":1,\"321\":1,\"323\":1,\"333\":3,\"378\":2,\"394\":1,\"427\":2,\"432\":1,\"565\":1,\"598\":2,\"606\":4,\"616\":1,\"636\":1,\"653\":1,\"688\":2,\"693\":1,\"694\":1,\"864\":6,\"871\":2,\"908\":1,\"910\":1}}],[\"flushcachepolicy\",{\"1\":{\"720\":1}}],[\"flushcache\",{\"1\":{\"720\":1}}],[\"flushcache=\",{\"1\":{\"704\":1}}],[\"flushcache=true\",{\"1\":{\"701\":1}}],[\"flushinterval用于控制缓存刷新时间\",{\"1\":{\"701\":1}}],[\"flushinterval=\",{\"1\":{\"701\":1}}],[\"flushstatements\",{\"1\":{\"688\":1}}],[\"flush\",{\"1\":{\"92\":1,\"93\":1,\"97\":1,\"113\":1,\"131\":1,\"133\":1,\"537\":2,\"543\":2,\"544\":1}}],[\"flatmap\",{\"1\":{\"71\":1}}],[\"float用于存储单精度小数\",{\"1\":{\"563\":1}}],[\"float\",{\"1\":{\"58\":1,\"227\":2,\"808\":1}}],[\"f\",{\"1\":{\"71\":1,\"98\":2,\"432\":4,\"475\":3,\"478\":1,\"615\":1}}],[\"fast\",{\"1\":{\"432\":1}}],[\"fastremove\",{\"1\":{\"25\":1}}],[\"failed\",{\"1\":{\"606\":1}}],[\"failure\",{\"1\":{\"367\":2}}],[\"fair\",{\"1\":{\"384\":1}}],[\"factory\",{\"1\":{\"636\":2,\"688\":1,\"834\":3,\"889\":3,\"910\":1}}],[\"factor\",{\"1\":{\"58\":1,\"60\":1}}],[\"false\",{\"1\":{\"23\":2,\"25\":1,\"59\":1,\"84\":2,\"129\":1,\"139\":1,\"167\":1,\"216\":2,\"268\":1,\"342\":2,\"363\":2,\"623\":5,\"682\":2,\"701\":2,\"703\":1,\"720\":2,\"735\":1,\"789\":1}}],[\"fifo\",{\"1\":{\"701\":2}}],[\"finest\",{\"1\":{\"727\":4,\"729\":2,\"745\":1}}],[\"finer\",{\"1\":{\"727\":4}}],[\"fine\",{\"1\":{\"727\":4,\"729\":1}}],[\"finding\",{\"1\":{\"466\":1,\"478\":1,\"484\":1}}],[\"final字段无法生成set方法\",{\"1\":{\"629\":1}}],[\"final类型\",{\"1\":{\"236\":1,\"347\":1}}],[\"final的status类型成员变量\",{\"1\":{\"221\":1}}],[\"final的\",{\"1\":{\"219\":1}}],[\"finalize\",{\"1\":{\"215\":1}}],[\"finally\",{\"1\":{\"90\":1,\"167\":1,\"267\":1,\"374\":4}}],[\"final\",{\"1\":{\"15\":3,\"23\":1,\"24\":1,\"25\":2,\"58\":3,\"59\":1,\"60\":1,\"65\":3,\"67\":1,\"127\":1,\"132\":1,\"133\":1,\"167\":2,\"174\":1,\"183\":1,\"193\":1,\"215\":6,\"217\":2,\"221\":5,\"239\":1,\"251\":2,\"252\":1,\"253\":1,\"256\":3,\"290\":1,\"305\":2,\"342\":2,\"346\":1,\"347\":2,\"367\":1,\"727\":7,\"729\":2,\"756\":4,\"921\":1}}],[\"fix\",{\"1\":{\"432\":1}}],[\"fieldsource\",{\"1\":{\"812\":2}}],[\"field\",{\"1\":{\"193\":13,\"199\":3,\"305\":4}}],[\"filehandler\",{\"1\":{\"735\":2,\"737\":2,\"738\":1}}],[\"fileservlet\",{\"1\":{\"891\":1,\"892\":1}}],[\"files\",{\"1\":{\"110\":1,\"323\":1,\"864\":2}}],[\"file\",{\"1\":{\"98\":19,\"636\":1,\"643\":1,\"658\":1,\"864\":3,\"891\":2,\"892\":5}}],[\"filenotfoundexception\",{\"1\":{\"90\":1,\"128\":1,\"266\":2,\"641\":1,\"643\":1,\"647\":1}}],[\"filewriter\",{\"1\":{\"88\":1,\"95\":1,\"97\":2,\"113\":1,\"755\":1}}],[\"filereader\",{\"1\":{\"88\":1,\"95\":1,\"96\":4,\"112\":3,\"754\":1}}],[\"fileoutputstream\",{\"1\":{\"88\":1,\"92\":4,\"93\":2,\"94\":2,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"333\":2,\"543\":5,\"892\":2}}],[\"fileinputstream\",{\"1\":{\"88\":1,\"90\":4,\"91\":6,\"94\":2,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"126\":1,\"128\":1,\"129\":1,\"131\":1,\"133\":1,\"199\":2,\"543\":4,\"643\":1,\"647\":1,\"756\":1}}],[\"fill\",{\"1\":{\"78\":1,\"107\":1,\"275\":1}}],[\"filter也有对应的httpfilter专用类\",{\"1\":{\"921\":1}}],[\"filterchain\",{\"1\":{\"919\":2,\"920\":11,\"921\":3}}],[\"filterstreamdemo\",{\"1\":{\"361\":1}}],[\"filter\",{\"0\":{\"917\":1,\"918\":1},\"1\":{\"23\":3,\"71\":4,\"319\":1,\"361\":1,\"756\":3,\"919\":1,\"920\":1}}],[\"first\",{\"1\":{\"25\":1,\"455\":1,\"606\":1}}],[\"添加过滤器\",{\"0\":{\"919\":1}}],[\"添加一个过滤器非常简单\",{\"1\":{\"919\":1}}],[\"添加一个时间显示区域\",{\"1\":{\"893\":1}}],[\"添加一个新的系统变量\",{\"1\":{\"864\":1}}],[\"添加一个user类\",{\"1\":{\"307\":1}}],[\"添加以下内容\",{\"1\":{\"827\":1}}],[\"添加后\",{\"1\":{\"767\":1}}],[\"添加了二级缓存之后\",{\"1\":{\"702\":1}}],[\"添加了此注解的接口\",{\"1\":{\"290\":1}}],[\"添加每一条批处理语句\",{\"1\":{\"615\":1}}],[\"添加\",{\"1\":{\"613\":1}}],[\"添加回滚点\",{\"1\":{\"599\":1}}],[\"添加final关键字后\",{\"1\":{\"346\":1}}],[\"添加点内容的话\",{\"1\":{\"242\":1}}],[\"添加元素只有在当前set集合中不存在此元素时才会成功\",{\"1\":{\"47\":1}}],[\"添加的是一个对象\",{\"1\":{\"25\":1}}],[\"添加integer的值10\",{\"1\":{\"25\":1}}],[\"添加成功返回true\",{\"1\":{\"23\":1}}],[\"添加给定集合中所有的元素\",{\"1\":{\"23\":1}}],[\"从这章开始时基于\",{\"1\":{\"521\":1}}],[\"从\",{\"1\":{\"478\":1}}],[\"从给定的\",{\"1\":{\"456\":1}}],[\"从状态\",{\"1\":{\"452\":1,\"511\":1}}],[\"从状态st​到st+1​\",{\"1\":{\"387\":1}}],[\"从指定的\",{\"1\":{\"452\":1}}],[\"从此可以发现\",{\"1\":{\"451\":1}}],[\"从而主动地按需求获取丰富的信息\",{\"1\":{\"859\":1}}],[\"从而修改我们对应的实体类\",{\"1\":{\"714\":1}}],[\"从而满足第三范式\",{\"1\":{\"555\":1}}],[\"从而可以进行近似求解\",{\"1\":{\"529\":1}}],[\"从而可以在\",{\"1\":{\"489\":1}}],[\"从而方便计算\",{\"1\":{\"516\":1}}],[\"从而使得算法可行\",{\"1\":{\"510\":1}}],[\"从而生成经验数据的策略\",{\"1\":{\"495\":1}}],[\"从而引入\",{\"1\":{\"479\":1}}],[\"从而转换为一个\",{\"1\":{\"478\":1}}],[\"从而进行多次利用\",{\"1\":{\"455\":1}}],[\"从而选择每个状态下最大的\",{\"1\":{\"451\":1}}],[\"从而减小方差\",{\"1\":{\"399\":1}}],[\"从而最大化所有用户的总mos值\",{\"1\":{\"385\":1}}],[\"从而其它被阻塞在这个锁的线程才可以继续执行\",{\"1\":{\"156\":1}}],[\"从无人机n到用户kn​的信道功率增益\",{\"1\":{\"383\":1}}],[\"从java8开始\",{\"1\":{\"219\":1}}],[\"从已知的一个类中派生出一个新的类\",{\"1\":{\"212\":1}}],[\"从队列中删除最后一个出现的指定元素\",{\"1\":{\"44\":1}}],[\"从队列中删除第一个出现的指定元素\",{\"1\":{\"44\":1}}],[\"从数学角度来说\",{\"1\":{\"23\":4}}],[\"从集合中移除某个元素\",{\"1\":{\"23\":1}}],[\"同servlet一样\",{\"1\":{\"921\":1}}],[\"同学\",{\"1\":{\"658\":1}}],[\"同父类\",{\"1\":{\"347\":1}}],[\"同名的方法\",{\"1\":{\"219\":1}}],[\"同一无人机通过fdma同时为同一集群中的多个用户提供服务\",{\"1\":{\"382\":1}}],[\"同一消息根据不同的对象而采用各种不同的方法\",{\"1\":{\"212\":1}}],[\"同一个包下的类\",{\"1\":{\"121\":1}}],[\"同构造方法一样\",{\"1\":{\"192\":1}}],[\"同步代码块内部\",{\"1\":{\"161\":1}}],[\"同理\",{\"1\":{\"96\":1,\"103\":1,\"393\":1,\"873\":1}}],[\"同read一样\",{\"1\":{\"92\":1}}],[\"同时每个应用程序都有自己的依赖\",{\"1\":{\"926\":1}}],[\"同时每次打印也是不同的线程在执行\",{\"1\":{\"173\":1}}],[\"同时还需要将依赖也一并打包到jar中\",{\"1\":{\"854\":1}}],[\"同时还能获取到注解中填入的值\",{\"1\":{\"208\":1}}],[\"同时子项目无需指定版本\",{\"1\":{\"850\":1}}],[\"同时下面的源代码编码格式为utf\",{\"1\":{\"820\":1}}],[\"同时idea也会提示我们测试失败\",{\"1\":{\"780\":1}}],[\"同时idea需要安装junit插件\",{\"1\":{\"775\":1}}],[\"同时id作为操作的名称\",{\"1\":{\"643\":1}}],[\"同时\",{\"1\":{\"773\":1}}],[\"同时查询user\",{\"1\":{\"668\":1}}],[\"同时将用户的详细信息包含在内\",{\"1\":{\"666\":1}}],[\"同时如果字段名称发生改变\",{\"1\":{\"627\":1}}],[\"同时数据库能够为我们提供高效的访问性能\",{\"1\":{\"549\":1}}],[\"同时告知上一级方法执行出现了问题\",{\"1\":{\"266\":1}}],[\"同时也会占用磁盘资源\",{\"1\":{\"597\":1}}],[\"同时也会生成一个tostring\",{\"1\":{\"368\":1}}],[\"同时也会生成一个class对象存放在内存\",{\"1\":{\"180\":1}}],[\"同时也使得基本类型能够支持对象操作\",{\"1\":{\"226\":1}}],[\"同时具体实现还需要由主体来实现\",{\"1\":{\"219\":1}}],[\"同时此注解可以作用于方法或是类上\",{\"1\":{\"206\":1}}],[\"同时类名也保持一致\",{\"1\":{\"198\":1}}],[\"同时我们需要向其中填入参数\",{\"1\":{\"191\":1}}],[\"同时会释放当前代码块持有的锁\",{\"1\":{\"161\":1}}],[\"同时一直占用锁\",{\"1\":{\"156\":1}}],[\"同时runnable只有一个未实现方法\",{\"1\":{\"139\":1}}],[\"同时保存了插入顺序\",{\"1\":{\"61\":1}}],[\"同时得益于每一个节点都是一个双向链表\",{\"1\":{\"61\":1}}],[\"同样内置了一个缓存机制\",{\"1\":{\"699\":1}}],[\"同样地\",{\"1\":{\"422\":1}}],[\"同样\",{\"1\":{\"383\":1,\"473\":1}}],[\"同样不需要break\",{\"1\":{\"340\":1}}],[\"同样不能超过最大值\",{\"1\":{\"60\":1}}],[\"同样可以使用\",{\"1\":{\"720\":1}}],[\"同样可以用条件概率的形式进行描述\",{\"1\":{\"393\":1}}],[\"同样可以作为方法引用传递\",{\"1\":{\"296\":1}}],[\"同样可以捕获到\",{\"1\":{\"267\":1}}],[\"同样可以按照上面的操作进行越权访问\",{\"1\":{\"193\":1}}],[\"同样需要使用resultmap来完成\",{\"1\":{\"658\":1}}],[\"同样需要使用\",{\"1\":{\"235\":1}}],[\"同样需要将接口中所有的抽象方法全部实现\",{\"1\":{\"219\":1}}],[\"同样需要给一个\",{\"1\":{\"46\":1}}],[\"同样采用装饰者模式\",{\"1\":{\"129\":1}}],[\"同样是用于列表查询的\",{\"1\":{\"653\":1}}],[\"同样是一个comparator\",{\"1\":{\"50\":1}}],[\"同样是只能插入那些不重复的元素\",{\"1\":{\"47\":1}}],[\"同样是仅获取队首元素\",{\"1\":{\"43\":1}}],[\"同样是移除队首元素\",{\"1\":{\"43\":1}}],[\"同样是添加操作\",{\"1\":{\"43\":1}}],[\"同样是list的实现类\",{\"1\":{\"25\":1}}],[\"同样的构建过程可以创建不同的表示\",{\"1\":{\"367\":1}}],[\"同样的键只能存在一个\",{\"1\":{\"57\":1}}],[\"同样的\",{\"1\":{\"15\":1,\"23\":1,\"59\":1,\"77\":1,\"117\":2,\"126\":1,\"156\":1,\"227\":1,\"255\":1,\"623\":1,\"767\":1,\"794\":1,\"811\":1,\"864\":1}}],[\"同样的类型\",{\"1\":{\"14\":1}}],[\"同上输入流\",{\"1\":{\"92\":1}}],[\"同上\",{\"1\":{\"23\":1,\"215\":4,\"235\":1,\"779\":2,\"875\":1}}],[\"查找顺序\",{\"0\":{\"702\":1}}],[\"查找位置\",{\"0\":{\"80\":1}}],[\"查看结果\",{\"1\":{\"605\":1}}],[\"查看表中的索引\",{\"1\":{\"597\":1}}],[\"查看浏览器发起的请求\",{\"1\":{\"544\":1}}],[\"查看\",{\"1\":{\"359\":1}}],[\"查看当前类的类加载器\",{\"1\":{\"198\":1}}],[\"查看当前集合是否为空\",{\"1\":{\"23\":1}}],[\"查看map中是否包含指定的值\",{\"1\":{\"56\":1}}],[\"查看map中是否包含指定的键\",{\"1\":{\"56\":1}}],[\"查看前面是否有已经遍历的元素\",{\"1\":{\"37\":1}}],[\"查询一个\",{\"0\":{\"670\":1}}],[\"查询\",{\"0\":{\"668\":1},\"1\":{\"666\":1}}],[\"查询列表时\",{\"1\":{\"653\":1}}],[\"查询列表操作\",{\"0\":{\"653\":1}}],[\"查询操作在xml配置中使用一个select标签进行囊括\",{\"1\":{\"648\":1}}],[\"查询操作\",{\"0\":{\"648\":1}}],[\"查询得到的数据\",{\"1\":{\"608\":1}}],[\"查询条件\",{\"0\":{\"580\":1}}],[\"查询所有的列数据\",{\"1\":{\"579\":1}}],[\"查询相关操作\",{\"1\":{\"56\":1}}],[\"查询某个元素在当前列表中的最后一次出现的下标位置\",{\"1\":{\"24\":1}}],[\"查询某个元素在当前列表中的第一次出现的下标位置\",{\"1\":{\"24\":1}}],[\"查询当前集合是否包含给定集合中所有的元素\",{\"1\":{\"23\":1}}],[\"查询当前集合中是否包含某个元素\",{\"1\":{\"23\":1}}],[\"树脂666\",{\"1\":{\"23\":1}}],[\"所在类\",{\"1\":{\"761\":1}}],[\"所生成的数据\",{\"1\":{\"486\":1}}],[\"所求出的\",{\"1\":{\"440\":1}}],[\"所获得的均值\",{\"1\":{\"422\":1}}],[\"所得到的\",{\"1\":{\"414\":1}}],[\"所谓的生产者消费者模型\",{\"1\":{\"174\":1}}],[\"所处的包和对应的目录是一一对应的\",{\"1\":{\"120\":1}}],[\"所有不会被加载\",{\"1\":{\"926\":1}}],[\"所有人都可以访问\",{\"1\":{\"910\":1}}],[\"所有匹配\",{\"1\":{\"878\":1}}],[\"所有内容写入完成之后\",{\"1\":{\"875\":1}}],[\"所有可执行文件\",{\"1\":{\"864\":1}}],[\"所有可能动作的\",{\"1\":{\"422\":1}}],[\"所有常规提示日志信息都以info级别进行打印\",{\"1\":{\"727\":1}}],[\"所有源文件会被解析成语法树\",{\"1\":{\"628\":1}}],[\"所有此表满足第二范式\",{\"1\":{\"554\":1}}],[\"所有状态的集合\",{\"1\":{\"393\":1}}],[\"所有包装类如下\",{\"0\":{\"227\":1}}],[\"所有其他类都是继承它的\",{\"1\":{\"215\":1}}],[\"所有代码执行结束时\",{\"1\":{\"143\":1}}],[\"所有被标记为静态的内容\",{\"1\":{\"118\":1}}],[\"所有子文件的file对象\",{\"1\":{\"98\":1}}],[\"所有直接覆盖就行\",{\"1\":{\"59\":1}}],[\"所有的web项目都在这里\",{\"1\":{\"864\":1}}],[\"所有的日志信息都在这里\",{\"1\":{\"864\":1}}],[\"所有的父级项目的packing都为pom\",{\"1\":{\"855\":1}}],[\"所有的命令在执行完成之后都会显示build\",{\"1\":{\"851\":1}}],[\"所有的版本全部由父项目决定\",{\"1\":{\"850\":1}}],[\"所有的项目一般都有自己的maven坐标\",{\"1\":{\"820\":1}}],[\"所有的测试案例都是按照方法的名称顺序来进行的\",{\"1\":{\"804\":1}}],[\"所有的测试结果将合并到一起输出\",{\"1\":{\"789\":1}}],[\"所有的标签必须成对出现\",{\"1\":{\"634\":1}}],[\"所有的操作才会被保存\",{\"1\":{\"623\":1}}],[\"所有的操作都有分别对应队首和队尾的\",{\"1\":{\"44\":1}}],[\"所有的属性都不传递依赖于主键\",{\"1\":{\"555\":1}}],[\"所有的运行时异常都继承自\",{\"1\":{\"264\":1}}],[\"所有的集合类最终都是实现自集合根接口的\",{\"1\":{\"23\":1}}],[\"所以无法辨别当前的请求是来自哪个用户发起\",{\"1\":{\"911\":1}}],[\"所以使用package标签来指定一个包\",{\"1\":{\"711\":1}}],[\"所以依然在使用缓存中的数据\",{\"1\":{\"705\":1}}],[\"所以之前缓存的内容可能就不是当前数据库里面最新的内容了\",{\"1\":{\"700\":1}}],[\"所以默认情况下它们将会以\",{\"1\":{\"660\":1}}],[\"所以需要填入一个占位符\",{\"1\":{\"648\":1}}],[\"所以要获取内部的节点\",{\"1\":{\"636\":1}}],[\"所以jdbc需要进行事务管理时\",{\"1\":{\"623\":1}}],[\"所以前面我们执行一个sql语句就会被直接提交\",{\"1\":{\"623\":1}}],[\"所以视图good\",{\"1\":{\"596\":1}}],[\"所以其不符合bcnf范式\",{\"1\":{\"556\":1}}],[\"所以如果没有始终在线\",{\"1\":{\"544\":1}}],[\"所以状态其实共有\",{\"1\":{\"387\":1}}],[\"所以在无人机辅助通信网络中我们需要考虑qoe模型\",{\"1\":{\"384\":1}}],[\"所以在java\",{\"1\":{\"330\":1}}],[\"所以对象都是一个\",{\"1\":{\"374\":1}}],[\"所以很多特性都是一种处于实验性功能\",{\"1\":{\"337\":1}}],[\"所以各个版本之间的更新内容比较少了\",{\"1\":{\"337\":1}}],[\"所以明明有机会进行类型推断\",{\"1\":{\"323\":1}}],[\"所以这个选项非常适合测试相关的框架\",{\"1\":{\"833\":1}}],[\"所以这个8就是存了数组\",{\"1\":{\"25\":1}}],[\"所以这里还是填写com\",{\"1\":{\"653\":1}}],[\"所以这里使用我们前面提到的方法引用的写法\",{\"1\":{\"297\":1}}],[\"所以我们通过mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置\",{\"1\":{\"714\":1}}],[\"所以我们项目的代码级别需要调整到16以上\",{\"1\":{\"342\":1,\"344\":1}}],[\"所以我们项目的代码级别需要调整到15以上\",{\"1\":{\"341\":1}}],[\"所以我们项目的代码级别需要调整到14以上\",{\"1\":{\"340\":1}}],[\"所以我们先创建好module\",{\"1\":{\"311\":1}}],[\"所以我们修改一下\",{\"1\":{\"305\":1}}],[\"所以我们来优化一下\",{\"1\":{\"297\":1}}],[\"所以我们还得判空一下\",{\"1\":{\"297\":1}}],[\"所以可以被变量接收\",{\"1\":{\"340\":1}}],[\"所以可以直接写最终返回的结果\",{\"1\":{\"290\":1}}],[\"所以可能不满足真实需求\",{\"1\":{\"236\":1}}],[\"所以只需要构造一个\",{\"1\":{\"367\":1}}],[\"所以只初始化了内部类\",{\"1\":{\"254\":1}}],[\"所以只要\",{\"1\":{\"84\":1}}],[\"所以相对外部来说\",{\"1\":{\"252\":1}}],[\"所以是需要添加default的\",{\"1\":{\"340\":1}}],[\"所以是\",{\"1\":{\"186\":1}}],[\"所以类锁本质上就是对应的类的\",{\"1\":{\"182\":1}}],[\"所以仍然需要等在运行的线程结束才会转为运行态\",{\"1\":{\"161\":1}}],[\"所以\",{\"1\":{\"156\":1,\"235\":1,\"289\":1,\"291\":1,\"292\":1,\"294\":1,\"296\":1,\"346\":1,\"422\":1,\"556\":1}}],[\"所以自己定义的类要自己重写\",{\"1\":{\"84\":1}}],[\"所以不维护顺序\",{\"1\":{\"57\":1}}],[\"所以它支持两种方向的遍历操作\",{\"1\":{\"37\":1}}],[\"所以添加成功返回true\",{\"1\":{\"23\":1}}],[\"所以说断言失败\",{\"1\":{\"790\":1}}],[\"所以说是可以的\",{\"1\":{\"281\":1}}],[\"所以说具体类型同样会变成\",{\"1\":{\"281\":1}}],[\"所以说静态方法中是不能用对象定义的泛型的\",{\"1\":{\"281\":1}}],[\"所以说静态内容一定会在第一个对象初始化之前完成加载\",{\"1\":{\"118\":1}}],[\"所以说并不能直接判断存储的类型到底是\",{\"1\":{\"280\":1}}],[\"所以说默认就可以直接使用\",{\"1\":{\"274\":1}}],[\"所以说只能使用\",{\"1\":{\"258\":1}}],[\"所以说里面也可以有成员变量\",{\"1\":{\"251\":1}}],[\"所以说int类型的数组时不能被object类型的数组变量接收的\",{\"1\":{\"238\":1}}],[\"所以说可以直接向上转型\",{\"1\":{\"235\":1}}],[\"所以说可以反复使用\",{\"1\":{\"37\":1}}],[\"所以说==判断为假\",{\"1\":{\"227\":1}}],[\"所以说两个不同的对象\",{\"1\":{\"227\":1}}],[\"所以说照着写就行了\",{\"1\":{\"220\":1}}],[\"所以说有些人说接口其实就是java中的多继承\",{\"1\":{\"219\":1}}],[\"所以说不能为私有\",{\"1\":{\"218\":1}}],[\"所以说判断结果为真\",{\"1\":{\"216\":1}}],[\"所以说呢\",{\"1\":{\"208\":1}}],[\"所以说就这样设计了\",{\"1\":{\"161\":1}}],[\"所以说没有包这个概念\",{\"1\":{\"120\":1}}],[\"所以说没必要直接用实现类\",{\"1\":{\"25\":1}}],[\"所以说我们需要明确指定\",{\"1\":{\"120\":1}}],[\"所以说我们在静态方法中\",{\"1\":{\"117\":1}}],[\"所以说我们可以添加两个一模一样的\",{\"1\":{\"25\":1}}],[\"所以说这里我们之间填写之前建好的实体类名称\",{\"1\":{\"648\":1}}],[\"所以说这里就明确了类型\",{\"1\":{\"14\":1}}],[\"所以说这种解决办法虽然可行\",{\"1\":{\"280\":1}}],[\"所以说这个对象当做每一个键值对的共享\",{\"1\":{\"67\":2}}],[\"所以说直接采用红黑树会更好\",{\"1\":{\"62\":1}}],[\"所以说直接就使用了\",{\"1\":{\"7\":1}}],[\"所以说返回null\",{\"1\":{\"57\":1}}],[\"所以说返回正数表示大于\",{\"1\":{\"14\":1}}],[\"所以说值是学生对象类型的\",{\"1\":{\"56\":1}}],[\"所以说最重要的还是\",{\"1\":{\"50\":1}}],[\"所以说无法维持插入元素的顺序\",{\"1\":{\"48\":1}}],[\"所以说\",{\"1\":{\"33\":1,\"67\":1,\"117\":1,\"258\":1}}],[\"所以说一定要注意\",{\"1\":{\"25\":1}}],[\"所以说哪怕是我们不去指定类型也可以直接使用\",{\"1\":{\"16\":1}}],[\"所以说依然是跟之前一样\",{\"1\":{\"15\":1}}],[\"所以说使用void\",{\"1\":{\"5\":1}}],[\"数量\",{\"1\":{\"556\":3,\"583\":2}}],[\"数量和位置\",{\"1\":{\"385\":1}}],[\"数量的内容\",{\"1\":{\"108\":1}}],[\"数学工具类\",{\"0\":{\"274\":1}}],[\"数字\",{\"1\":{\"246\":1,\"333\":1}}],[\"数据实际上还是存放在原来的表中\",{\"1\":{\"596\":1}}],[\"数据类型\",{\"1\":{\"567\":2,\"568\":1}}],[\"数据操纵语言\",{\"1\":{\"561\":1}}],[\"数据查询语言\",{\"1\":{\"561\":1}}],[\"数据模型与现实世界中的模型一样\",{\"1\":{\"550\":1}}],[\"数据模型\",{\"0\":{\"550\":1}}],[\"数据表之间相互关联\",{\"1\":{\"549\":1}}],[\"数据库驱动\",{\"1\":{\"888\":1}}],[\"数据库连接url\",{\"1\":{\"641\":1,\"888\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"599\":1}}],[\"数据库的完整性没有被破坏\",{\"1\":{\"599\":1}}],[\"数据库的规范化\",{\"0\":{\"552\":1}}],[\"数据库4\",{\"0\":{\"594\":1}}],[\"数据库控制语言\",{\"0\":{\"588\":1}}],[\"数据库查询语言\",{\"0\":{\"578\":1}}],[\"数据库3\",{\"0\":{\"576\":1}}],[\"数据库操纵语言\",{\"0\":{\"570\":1}}],[\"数据库操作\",{\"0\":{\"566\":1}}],[\"数据库名\",{\"1\":{\"566\":3}}],[\"数据库定义语言\",{\"0\":{\"562\":1}}],[\"数据库定义语言ddl\",{\"1\":{\"561\":1}}],[\"数据库2\",{\"0\":{\"559\":1}}],[\"数据库创建完成后\",{\"1\":{\"567\":1}}],[\"数据库创建\",{\"0\":{\"551\":1}}],[\"数据库能有效地帮助一个组织或企业科学地管理各类信息资源\",{\"1\":{\"549\":1}}],[\"数据库是数据管理的有效技术\",{\"1\":{\"549\":1}}],[\"数据库\",{\"0\":{\"548\":1,\"560\":1,\"577\":1,\"595\":1,\"940\":1},\"1\":{\"591\":2}}],[\"数据库1\",{\"0\":{\"547\":1}}],[\"数据已发送\",{\"1\":{\"537\":1}}],[\"数据包从发送端\",{\"1\":{\"384\":1}}],[\"数据截断\",{\"0\":{\"322\":1}}],[\"数据流datainputstream也是filterinputstream的子类\",{\"1\":{\"129\":1}}],[\"数据流\",{\"0\":{\"129\":1}}],[\"数据结构与算法基础\",{\"1\":{\"15\":2,\"280\":1}}],[\"数据结构与算法\",{\"1\":{\"15\":1,\"46\":1}}],[\"数组等\",{\"1\":{\"809\":1}}],[\"数组工具类\",{\"0\":{\"275\":1}}],[\"数组同样支持向上转型\",{\"1\":{\"238\":1}}],[\"数组大小\",{\"1\":{\"235\":2}}],[\"数组类型比较特殊\",{\"1\":{\"235\":1}}],[\"数组类型也是一种类型\",{\"1\":{\"184\":1}}],[\"数组可以代表任何相同类型的一组内容\",{\"1\":{\"234\":1}}],[\"数组可以存放基本数据类型\",{\"1\":{\"22\":1}}],[\"数组是相同类型数据的有序集合\",{\"1\":{\"234\":1}}],[\"数组\",{\"0\":{\"232\":1,\"234\":1}}],[\"数组的\",{\"0\":{\"184\":1},\"1\":{\"236\":1}}],[\"数组的大小是固定的\",{\"1\":{\"22\":1}}],[\"数组实现的栈和队列\",{\"1\":{\"45\":1}}],[\"数组存放的类型只能是一种\",{\"1\":{\"22\":1}}],[\"都像是去厨房端菜到客人桌上一样\",{\"1\":{\"688\":1}}],[\"都需要一定的时间开销\",{\"1\":{\"688\":1}}],[\"都需要编写大量的代码\",{\"1\":{\"633\":1}}],[\"都需要有多个\",{\"1\":{\"458\":1}}],[\"都记录\",{\"1\":{\"455\":1}}],[\"都支持lambda表达式\",{\"1\":{\"290\":1}}],[\"都会由我们自己定义的servlet处理\",{\"1\":{\"878\":1}}],[\"都会单独创建一个线程来处理执行\",{\"1\":{\"873\":1}}],[\"都会创建一个线程执行一次service方法\",{\"1\":{\"872\":1}}],[\"都会创建一个新的对象\",{\"1\":{\"803\":1}}],[\"都会执行一次这里的准备工作\",{\"1\":{\"802\":1}}],[\"都会关联到这个二级缓存\",{\"1\":{\"701\":1}}],[\"都会使用反射进行一次赋值\",{\"1\":{\"658\":1}}],[\"都会抛出\",{\"1\":{\"371\":1}}],[\"都会对应创建类似于setter的方法\",{\"1\":{\"368\":1}}],[\"都会在构建器中创建对应属性\",{\"1\":{\"368\":1}}],[\"都会在最后执行任务\",{\"1\":{\"267\":1}}],[\"都会将指针后移一位\",{\"1\":{\"31\":1}}],[\"都可以访问此servlet\",{\"1\":{\"878\":1}}],[\"都可以通过httpservletrequest对象来获取\",{\"1\":{\"874\":1}}],[\"都可以通过实现此接口\",{\"1\":{\"604\":1}}],[\"都可以从servletrequest对象中获取\",{\"1\":{\"873\":1}}],[\"都可以直接进行方法引用\",{\"1\":{\"258\":1}}],[\"都可以使用getannotations\",{\"1\":{\"208\":1}}],[\"都可以使用\",{\"1\":{\"36\":1}}],[\"都在\",{\"1\":{\"229\":1}}],[\"都能调用它的任意一个方法和属性\",{\"1\":{\"179\":1}}],[\"都能够知道这个类所有的属性和方法\",{\"1\":{\"179\":1}}],[\"都能够容纳一组元素\",{\"1\":{\"22\":1}}],[\"都只能获取到当前线程所属的变量\",{\"1\":{\"162\":1}}],[\"都有可选择的动作\",{\"1\":{\"393\":1}}],[\"都有学习的能力\",{\"1\":{\"219\":1}}],[\"都有一个获取原始类型class方法\",{\"1\":{\"183\":1}}],[\"都有一个interrupt\",{\"1\":{\"144\":1}}],[\"都有自己的内存空间\",{\"1\":{\"138\":1}}],[\"都是storehousemanage的候选关键字\",{\"1\":{\"556\":1}}],[\"都是string类型的一个实例对象\",{\"1\":{\"244\":1}}],[\"都是最大的\",{\"1\":{\"522\":1}}],[\"都是hello\",{\"1\":{\"354\":1}}],[\"都是可以支持泛型的\",{\"1\":{\"282\":1}}],[\"都是始终是那一个对象\",{\"1\":{\"180\":1}}],[\"都是根据\",{\"1\":{\"84\":1}}],[\"都是直接使用new关键字就能直接搞定了\",{\"1\":{\"9\":1}}],[\"它没有将类交给父类加载器进行加载\",{\"1\":{\"926\":1}}],[\"它只加载自己的class文件\",{\"1\":{\"926\":1}}],[\"它要做的是去动态加载我们编写的web应用程序中的类\",{\"1\":{\"926\":1}}],[\"它针对http请求进行了专门处理\",{\"1\":{\"921\":1}}],[\"它有着自己的过期时间\",{\"1\":{\"914\":1}}],[\"它有两种用法\",{\"1\":{\"364\":1}}],[\"它不仅仅可以用来进行数据传递\",{\"1\":{\"901\":1}}],[\"它不仅仅可以是一个固定值\",{\"1\":{\"878\":1}}],[\"它不是继承自filterinputstream的\",{\"1\":{\"130\":1}}],[\"它根据http协议的规则\",{\"1\":{\"876\":1}}],[\"它被细分了\",{\"1\":{\"834\":1}}],[\"它决定了依赖的作用域范围\",{\"1\":{\"833\":1}}],[\"它也是以键值对形式保存的\",{\"1\":{\"902\":1}}],[\"它也是使用xml格式编写的\",{\"1\":{\"819\":1}}],[\"它也是现在提高数据获取效率的良好解决方案\",{\"1\":{\"699\":1}}],[\"它与重复测试比较类似\",{\"1\":{\"808\":1}}],[\"它与java中的for类似\",{\"1\":{\"692\":1}}],[\"它仅会作用于所属内部类中的所有测试用例\",{\"1\":{\"805\":1}}],[\"它仅仅对一个会话中的数据进行缓存\",{\"1\":{\"700\":1}}],[\"它必须用其完全限定的名称来引用\",{\"1\":{\"797\":1}}],[\"它通常在执行给定测试没有意义时使用\",{\"1\":{\"791\":1}}],[\"它通过默认的forkjoinpool实现\",{\"1\":{\"173\":1}}],[\"它详细记录了所有的数据库操作等\",{\"1\":{\"768\":1}}],[\"它继承自hashtable类\",{\"1\":{\"754\":1}}],[\"它包含一个默认的consolehandler处理器用于进行控制台打印\",{\"1\":{\"744\":1}}],[\"它用于将我们的项目打包为jar文件\",{\"1\":{\"853\":1}}],[\"它用于控制日志的格式\",{\"1\":{\"738\":1}}],[\"它用于处理我们的日志内容打印\",{\"1\":{\"735\":1}}],[\"它用于保存字符串\",{\"1\":{\"243\":1}}],[\"它之前查询的缓存依然会存在于二级缓存中\",{\"1\":{\"701\":1}}],[\"它类似于java中的switch语句\",{\"1\":{\"691\":1}}],[\"它采用ognl表达式进行编写\",{\"1\":{\"690\":1}}],[\"它代表执行sql后受影响的行数\",{\"1\":{\"677\":1}}],[\"它代表当前类的版本\",{\"1\":{\"132\":1}}],[\"它其实是通过动态代理生成的\",{\"1\":{\"659\":1}}],[\"它适用于单个数据查询或是多行数据查询\",{\"1\":{\"653\":1}}],[\"它返回的map是使用我们想要的属性作为key\",{\"1\":{\"653\":1}}],[\"它提供了当前日志记录的相关信息\",{\"1\":{\"761\":1}}],[\"它提供的接口\",{\"1\":{\"604\":1}}],[\"它提前帮助我们规定了一些标签\",{\"1\":{\"641\":1}}],[\"它内部就还有子节点\",{\"1\":{\"636\":1}}],[\"它更像是一个配置文件\",{\"1\":{\"634\":1}}],[\"它所做的工作就是我们上面所说的\",{\"1\":{\"628\":1}}],[\"它对jdbc进行了深层次的封装\",{\"1\":{\"616\":1}}],[\"它需要结合聚合函数一起使用\",{\"1\":{\"583\":1}}],[\"它保证数据的参照完整性\",{\"1\":{\"564\":1}}],[\"它专门用于数据库的操作\",{\"1\":{\"561\":1}}],[\"它至少要包含一个响应码\",{\"1\":{\"544\":1}}],[\"它本质也是基于tcp协议进行数据传输\",{\"1\":{\"544\":1}}],[\"它本身也是类\",{\"1\":{\"235\":1}}],[\"它位于java\",{\"1\":{\"351\":1}}],[\"它在java\",{\"1\":{\"346\":1}}],[\"它很好的解决了判空问题\",{\"1\":{\"323\":1}}],[\"它还可以获取根目录下的资源文件\",{\"1\":{\"901\":1}}],[\"它还可以用来绑定一个接口\",{\"1\":{\"643\":1}}],[\"它还支持事务的处理\",{\"1\":{\"607\":1}}],[\"它还支持使用命令\",{\"1\":{\"316\":1}}],[\"它还能把每一行内容依次转换为集合类提到的stream流\",{\"1\":{\"112\":1}}],[\"它支持我们使用lambda的形式进行查询结果的处理\",{\"1\":{\"653\":1}}],[\"它支持我们一条一条命令进行操作\",{\"1\":{\"316\":1}}],[\"它支持定制化\",{\"1\":{\"633\":1}}],[\"它支持多行\",{\"1\":{\"561\":1}}],[\"它支持tcp和udp\",{\"1\":{\"535\":1}}],[\"它支持按行读取\",{\"1\":{\"112\":1}}],[\"它是属于整个web应用程序的\",{\"1\":{\"901\":1}}],[\"它是遵循http协议的一种servlet\",{\"1\":{\"876\":1}}],[\"它是万维网上能够可靠交换文件的重要基础\",{\"1\":{\"859\":1}}],[\"它是符合第三范式的\",{\"1\":{\"556\":1}}],[\"它是计算机之间进行通信的一种约定或一种方式\",{\"1\":{\"535\":1}}],[\"它是运行时异常的子类\",{\"1\":{\"267\":1}}],[\"它是局部内部类的简化版\",{\"1\":{\"255\":1}}],[\"它是一个用于操作数组的工具类\",{\"1\":{\"75\":1}}],[\"它就像一个字符串编辑器\",{\"1\":{\"245\":1}}],[\"它相当于我们对某样东西的一个标记\",{\"1\":{\"203\":1}}],[\"它可以长这样\",{\"1\":{\"634\":1}}],[\"它可以指定你希望对集合进行的操作\",{\"1\":{\"356\":1}}],[\"它可以保存类型t的值\",{\"1\":{\"355\":1}}],[\"它可以对给定的对象执行某些操作\",{\"1\":{\"351\":1}}],[\"它可以判断一个对象是否为此接口或是类的实现或是子类\",{\"1\":{\"186\":1}}],[\"它可以提高你的多线程任务的速度\",{\"1\":{\"173\":1}}],[\"它将我们的变量值存储在内部只能存储一个变量\",{\"1\":{\"162\":1}}],[\"它会先将请求转发给父类加载器\",{\"1\":{\"926\":1}}],[\"它会给浏览器设定一个叫做jsessionid的cookie\",{\"1\":{\"912\":1}}],[\"它会将日志以xml的形式进行打印\",{\"1\":{\"738\":1}}],[\"它会将操作后的数据保存到另外一个对象中\",{\"1\":{\"357\":1}}],[\"它会预编译一个sql语句\",{\"1\":{\"622\":1}}],[\"它会返回一个boolean来表示执行结果是一个resultset还是一个int\",{\"1\":{\"608\":1}}],[\"它会返回一个int类型\",{\"1\":{\"608\":1}}],[\"它会在\",{\"1\":{\"456\":1}}],[\"它会在编译时\",{\"1\":{\"344\":1}}],[\"它会在元素插入时进行排序\",{\"1\":{\"50\":1}}],[\"它会直接打印基本数据类型或是调用对象的tostring\",{\"1\":{\"127\":1}}],[\"它同样也支持mark\",{\"1\":{\"112\":1}}],[\"它能够很好地实现动态网页的返回\",{\"1\":{\"870\":1}}],[\"它能够有效地预防sql注入式攻击\",{\"1\":{\"607\":1}}],[\"它能够快速地定位元素存放的位置\",{\"1\":{\"597\":1}}],[\"它能够直接让局部变量自动进行类型推断\",{\"1\":{\"330\":1}}],[\"它能够在编译阶段就检查类型安全\",{\"1\":{\"280\":1}}],[\"它能够在插入数据时利用链表自动维护顺序\",{\"1\":{\"49\":1}}],[\"它能够格式化任意的类型\",{\"1\":{\"127\":1}}],[\"它能够提供一个缓冲\",{\"1\":{\"103\":1}}],[\"它们都被封装在一个新的assertions类中\",{\"1\":{\"785\":1}}],[\"它们都是容器\",{\"1\":{\"22\":1}}],[\"它们专门用于配置特殊情况\",{\"1\":{\"729\":1}}],[\"它们分别用于存放java源代码\",{\"1\":{\"818\":1}}],[\"它们分别代表一对一关联和一对多关联\",{\"1\":{\"718\":1}}],[\"它们分别是\",{\"1\":{\"363\":1}}],[\"它们能够捆绑一组sql语句运行\",{\"1\":{\"599\":1}}],[\"它们通过\",{\"1\":{\"84\":1}}],[\"它给我们提供了大量的工具方法\",{\"1\":{\"75\":1}}],[\"它扩展了大量队列相关操作\",{\"1\":{\"43\":1}}],[\"它的目的是\",{\"1\":{\"900\":1}}],[\"它的目的是用来创建构建器\",{\"1\":{\"368\":1}}],[\"它的默认值为\",{\"1\":{\"881\":1}}],[\"它的作用肯定不仅仅是获取头部信息\",{\"1\":{\"874\":1}}],[\"它的格式如下\",{\"1\":{\"753\":1}}],[\"它的使用方式与resultmap几乎没什么区别\",{\"1\":{\"715\":1}}],[\"它的含义是将一个复杂的对象的构建与它的表示分离\",{\"1\":{\"367\":1}}],[\"它的意义不仅仅体现在语法的精简上\",{\"1\":{\"340\":1}}],[\"它的lambda表达式的实现就可以写为\",{\"1\":{\"290\":1}}],[\"它的权限非常高\",{\"1\":{\"179\":1}}],[\"它的底层其实并不只是简简单单的语法糖替换\",{\"1\":{\"289\":1}}],[\"它的底层很简单\",{\"1\":{\"67\":1}}],[\"它的底层就是采用哈希表实现的\",{\"1\":{\"48\":1}}],[\"它的内部直接维护了一个红黑树\",{\"1\":{\"62\":1}}],[\"它的内部对插入顺序进行了维护\",{\"1\":{\"57\":1}}],[\"它的运作机制大概是\",{\"1\":{\"31\":1}}],[\"它的主要特性有\",{\"1\":{\"24\":1}}],[\"它的祖先就是collection接口\",{\"1\":{\"23\":1}}],[\"它的属性没有进行赋值\",{\"1\":{\"4\":1}}],[\"每当浏览器向服务器发起一个请求时\",{\"1\":{\"872\":1}}],[\"每调用一次next\",{\"1\":{\"614\":1}}],[\"每组列名1相同的数据再按照列名2排序\",{\"1\":{\"581\":1}}],[\"每架无人机的带宽和发射功率都均匀分配给每个用户\",{\"1\":{\"387\":1}}],[\"每次访问对应的\",{\"1\":{\"873\":1}}],[\"每次赛季更新都会有一个大版本更新\",{\"1\":{\"820\":1}}],[\"每次执行测试用例都会创建一个新的对象来执行\",{\"1\":{\"803\":1}}],[\"每次完成代码后都可以跑一遍测试用例\",{\"1\":{\"773\":1}}],[\"每次都是从对应的状态\",{\"1\":{\"458\":1}}],[\"每次迭代都会使得策略进行提升\",{\"1\":{\"442\":1}}],[\"每次无人机会根据当前状态st​∈s\",{\"1\":{\"387\":1}}],[\"每次返回一个新的流\",{\"1\":{\"358\":1}}],[\"每次运算都会生成一个新的对象\",{\"1\":{\"245\":1}}],[\"每次就直接返回一个字符串吧\",{\"1\":{\"36\":1}}],[\"每次循环一定要判断是否还有元素剩余\",{\"1\":{\"34\":1}}],[\"每一级使用\",{\"1\":{\"753\":1}}],[\"每一行必须有值\",{\"1\":{\"564\":1}}],[\"每一种数据库都支持sql\",{\"1\":{\"561\":1}}],[\"每一张表都代表一种实体的数据\",{\"1\":{\"551\":1}}],[\"每一轮都会执行unaryoperator并生成一个新值到流中\",{\"1\":{\"321\":1}}],[\"每一轮循环\",{\"1\":{\"237\":1}}],[\"每一个测试用例执行之前\",{\"1\":{\"803\":1}}],[\"每一个handler都可以配置一个对应的formatter来决定日志打印的格式\",{\"1\":{\"761\":1}}],[\"每一个result标签都可以配置数据库字段和类属性的对应关系\",{\"1\":{\"652\":1}}],[\"每一个标签都作为一个节点\",{\"1\":{\"636\":1}}],[\"每一个学生也可以有多个教师\",{\"1\":{\"550\":1}}],[\"每一个老师不仅可以教多个学生\",{\"1\":{\"550\":1}}],[\"每一个thread对象中\",{\"1\":{\"144\":1}}],[\"每一个进程都是一个应用程序\",{\"1\":{\"138\":1}}],[\"每一个对象我们都可以称其为元素\",{\"1\":{\"21\":1}}],[\"每一次next操作\",{\"1\":{\"31\":1}}],[\"每个jsp文件都有一个自己的类加载器\",{\"1\":{\"926\":1}}],[\"每个web应用程序都有一个自己的类加载器\",{\"1\":{\"926\":1}}],[\"每个文件夹都是一个web应用程序\",{\"1\":{\"864\":1}}],[\"每个插件都有各自的功能\",{\"1\":{\"851\":1}}],[\"每个maven项目都有一个生命周期\",{\"1\":{\"851\":1}}],[\"每个mapper都是唯一的\",{\"1\":{\"643\":1}}],[\"每个会话就相当于我不同的地方登陆一个账号去访问数据库\",{\"1\":{\"642\":1}}],[\"每个基于\",{\"1\":{\"642\":1}}],[\"每个学生都有着不同的学号\",{\"1\":{\"554\":1}}],[\"每个集群中无人机的最优位置也会发生变化\",{\"1\":{\"388\":1}}],[\"每个用户的会话都会有一个自己的session对象\",{\"1\":{\"911\":1}}],[\"每个用户的移动方向均匀分布在左\",{\"1\":{\"388\":1}}],[\"每个用户都需要判断是否与每个无人机关联\",{\"1\":{\"388\":1}}],[\"每个用户只能属于一个集群\",{\"1\":{\"382\":1}}],[\"每个用双引号括起来的字符串\",{\"1\":{\"244\":1}}],[\"每个流只能进行一次终端操作\",{\"1\":{\"358\":1}}],[\"每个对象中都有一个单独的类定义\",{\"1\":{\"251\":1}}],[\"每个对象都有这样的一个类定义\",{\"1\":{\"251\":1}}],[\"每个对象都有一个自己的空间\",{\"1\":{\"4\":1}}],[\"每个对象都应该有针对于锁的一些操作\",{\"1\":{\"161\":1}}],[\"每个类可以创建一个对象\",{\"1\":{\"251\":1}}],[\"每个类都有且只有一个唯一的class对象存放在jvm中\",{\"1\":{\"180\":1}}],[\"每个包装类中\",{\"1\":{\"183\":1}}],[\"每个线程都有一个私有的工作内存\",{\"1\":{\"154\":1}}],[\"每个元素都要执行+1操作\",{\"1\":{\"71\":1}}],[\"每个元素都有一个自己的下标位置\",{\"1\":{\"24\":2}}],[\"集合还可以调用\",{\"1\":{\"359\":1}}],[\"集合操作能不能也安排点高级的玩法呢\",{\"1\":{\"75\":1}}],[\"集合运算和表达的高阶抽象\",{\"1\":{\"71\":1}}],[\"集合只是粗略的进行了讲解\",{\"1\":{\"50\":1}}],[\"集合中基本都是从\",{\"1\":{\"47\":1}}],[\"集合中的每一个元素就是一个集合\",{\"1\":{\"25\":1}}],[\"集合的具体类型\",{\"1\":{\"77\":1}}],[\"集合的各种功能我们都可以来测试一下\",{\"1\":{\"25\":1}}],[\"集合的\",{\"1\":{\"24\":1}}],[\"集合的大小是可变的\",{\"1\":{\"22\":1}}],[\"集合根接口\",{\"0\":{\"23\":1}}],[\"集合跟数组一样\",{\"1\":{\"22\":1}}],[\"集合\",{\"0\":{\"47\":1},\"1\":{\"21\":1}}],[\"集合表示一组对象\",{\"1\":{\"21\":1}}],[\"集合其实与我们数学中的集合是差不多的概念\",{\"1\":{\"21\":1}}],[\"集合类新增工厂方法\",{\"0\":{\"318\":1}}],[\"集合类中有一个东西是java8新增的spliterator接口\",{\"1\":{\"173\":1}}],[\"集合类中并不是通过\",{\"1\":{\"84\":1}}],[\"集合类中继承的方法这里也不多种介绍了\",{\"1\":{\"44\":1}}],[\"集合类对象相等判定\",{\"0\":{\"83\":1,\"84\":1}}],[\"集合类同样支持这种语法\",{\"1\":{\"30\":1}}],[\"集合类是支持嵌套使用的\",{\"1\":{\"25\":1}}],[\"集合类是java中非常重要的存在\",{\"1\":{\"21\":1}}],[\"集合类基本都是在java\",{\"1\":{\"23\":1}}],[\"集合类与数组区别\",{\"0\":{\"22\":1}}],[\"集合类其实就是为了更好地组织\",{\"1\":{\"21\":1}}],[\"集合类\",{\"0\":{\"19\":1,\"20\":1,\"21\":1,\"28\":1,\"29\":1,\"35\":1,\"40\":1,\"41\":1,\"53\":1,\"54\":1,\"173\":1},\"1\":{\"35\":1,\"173\":1,\"811\":1}}],[\"edge\",{\"1\":{\"913\":1}}],[\"edg\",{\"1\":{\"908\":1,\"913\":1}}],[\"ee的一个标准\",{\"1\":{\"870\":1}}],[\"ehcache\",{\"1\":{\"705\":1}}],[\"employeeid\",{\"1\":{\"565\":1}}],[\"employees\",{\"1\":{\"565\":1}}],[\"emptysource两个注解的功能\",{\"1\":{\"809\":1}}],[\"emptysource\",{\"1\":{\"809\":1}}],[\"emptylist\",{\"1\":{\"79\":1}}],[\"empty\",{\"1\":{\"25\":1,\"167\":1}}],[\"email\",{\"1\":{\"564\":2}}],[\"e+γvπ​\",{\"1\":{\"487\":1}}],[\"e+1\",{\"1\":{\"71\":1}}],[\"efficient\",{\"1\":{\"455\":1}}],[\"euqation\",{\"1\":{\"421\":1}}],[\"euqals\",{\"1\":{\"215\":1}}],[\"equation\",{\"0\":{\"416\":1,\"419\":1,\"420\":1,\"428\":1},\"1\":{\"411\":1,\"419\":1,\"420\":2,\"423\":2,\"426\":1,\"432\":1,\"440\":1,\"442\":2,\"444\":1,\"445\":1,\"451\":1,\"487\":3,\"489\":1,\"493\":1}}],[\"equal\",{\"1\":{\"24\":1}}],[\"equalsandhashcode全部注解\",{\"1\":{\"629\":1}}],[\"equalsandhashcode来快速生成比较和哈希值方法\",{\"1\":{\"629\":1}}],[\"equals\",{\"1\":{\"23\":1,\"25\":1,\"47\":1,\"56\":1,\"59\":2,\"84\":16,\"215\":1,\"216\":4,\"244\":1,\"319\":1,\"342\":4,\"344\":3,\"876\":8,\"910\":2}}],[\"every\",{\"1\":{\"455\":2}}],[\"evaluation\",{\"1\":{\"397\":2,\"419\":1,\"421\":1,\"440\":1,\"444\":1,\"453\":1,\"456\":1}}],[\"eviction=\",{\"1\":{\"701\":1}}],[\"evict\",{\"1\":{\"59\":2}}],[\"eplison\",{\"0\":{\"459\":1}}],[\"episodestartingfrom\",{\"1\":{\"455\":4}}],[\"episodes\",{\"1\":{\"452\":1,\"456\":2,\"458\":2}}],[\"episode\",{\"0\":{\"455\":1},\"1\":{\"393\":2,\"452\":2,\"455\":6,\"456\":1,\"458\":1,\"460\":1,\"511\":1}}],[\"ep074512\",{\"1\":{\"15\":3,\"280\":1,\"281\":2}}],[\"errargs\",{\"1\":{\"876\":3}}],[\"errmsg\",{\"1\":{\"876\":4}}],[\"err打印到控制台\",{\"1\":{\"735\":1}}],[\"error\",{\"1\":{\"658\":2}}],[\"error错误比异常更严重\",{\"1\":{\"264\":1}}],[\"err\",{\"1\":{\"374\":1}}],[\"either\",{\"1\":{\"352\":1,\"864\":1}}],[\"ekko\",{\"1\":{\"304\":1}}],[\"estimation\",{\"0\":{\"473\":1,\"477\":1,\"506\":1},\"1\":{\"449\":2,\"451\":1,\"456\":1,\"466\":1}}],[\"es∼η\",{\"1\":{\"400\":1}}],[\"es\",{\"1\":{\"246\":1}}],[\"eat\",{\"1\":{\"174\":1}}],[\"each\",{\"1\":{\"23\":4,\"598\":2}}],[\"extclassloader\",{\"1\":{\"926\":1}}],[\"externalcondition\",{\"1\":{\"797\":2}}],[\"extern\",{\"1\":{\"311\":1,\"849\":1}}],[\"extends关键字\",{\"1\":{\"346\":1}}],[\"extends\",{\"1\":{\"15\":3,\"16\":1,\"23\":2,\"24\":2,\"25\":2,\"37\":1,\"42\":1,\"43\":1,\"44\":1,\"47\":2,\"56\":2,\"58\":1,\"61\":1,\"67\":1,\"186\":1,\"191\":1,\"192\":1,\"199\":1,\"218\":1,\"219\":2,\"220\":1,\"221\":1,\"265\":2,\"282\":1,\"347\":4,\"653\":1,\"754\":1,\"761\":1,\"876\":1,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1,\"921\":2}}],[\"extend\",{\"1\":{\"15\":1}}],[\"ex\",{\"1\":{\"606\":2}}],[\"executions>\",{\"1\":{\"854\":1}}],[\"execution>\",{\"1\":{\"854\":1}}],[\"executing\",{\"1\":{\"139\":1,\"167\":1}}],[\"executortype\",{\"1\":{\"688\":1}}],[\"executorexception\",{\"1\":{\"658\":1}}],[\"executor\",{\"1\":{\"658\":1}}],[\"executebatch\",{\"1\":{\"615\":1}}],[\"executeupdate\",{\"1\":{\"613\":3,\"623\":11,\"688\":1}}],[\"executequery\",{\"1\":{\"605\":1,\"621\":1,\"622\":1}}],[\"exclusion>\",{\"1\":{\"843\":1}}],[\"exclusions>\",{\"1\":{\"843\":1}}],[\"exclusions\",{\"1\":{\"832\":1}}],[\"exchange\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"excellent\",{\"1\":{\"384\":1}}],[\"exceptionfactory\",{\"1\":{\"660\":2}}],[\"exceptions\",{\"1\":{\"658\":1,\"660\":1}}],[\"exceptionutil\",{\"1\":{\"658\":1}}],[\"exception\",{\"1\":{\"199\":2,\"264\":4,\"265\":3,\"266\":3,\"352\":2,\"544\":2,\"606\":1,\"636\":1,\"658\":1}}],[\"exist\",{\"1\":{\"658\":1}}],[\"existence\",{\"1\":{\"432\":1}}],[\"exists\",{\"1\":{\"98\":1,\"566\":1}}],[\"exit退出即可\",{\"1\":{\"316\":1}}],[\"exploded\",{\"1\":{\"908\":2,\"913\":3}}],[\"exploration\",{\"1\":{\"461\":1}}],[\"exploring\",{\"0\":{\"454\":1,\"457\":1,\"458\":1},\"1\":{\"454\":1,\"458\":2,\"459\":1,\"462\":1}}],[\"exploitation\",{\"1\":{\"461\":1}}],[\"exponentially\",{\"1\":{\"432\":1}}],[\"exports\",{\"1\":{\"307\":2,\"308\":2,\"309\":2,\"310\":1}}],[\"expected\",{\"0\":{\"492\":1},\"1\":{\"414\":1,\"786\":1}}],[\"expection\",{\"1\":{\"414\":1,\"487\":1,\"507\":1,\"510\":1}}],[\"experience\",{\"0\":{\"384\":1},\"1\":{\"378\":1,\"454\":1,\"486\":1,\"490\":1}}],[\"expression\",{\"1\":{\"246\":1}}],[\"examine\",{\"1\":{\"864\":1}}],[\"examples\",{\"1\":{\"864\":1}}],[\"example<\",{\"1\":{\"849\":1}}],[\"example\",{\"1\":{\"797\":1,\"820\":1,\"864\":1,\"871\":1,\"888\":1}}],[\"exam\",{\"1\":{\"216\":2,\"218\":2}}],[\"endswith\",{\"1\":{\"921\":4}}],[\"enctype=\",{\"1\":{\"892\":1}}],[\"encoding=\",{\"1\":{\"634\":2,\"641\":1,\"643\":1,\"819\":1,\"834\":1,\"840\":1,\"849\":1,\"888\":1}}],[\"encoding\",{\"1\":{\"544\":1,\"756\":2,\"864\":1,\"908\":1,\"913\":1}}],[\"enabledif或\",{\"1\":{\"797\":2}}],[\"enabledif\",{\"1\":{\"797\":2}}],[\"enabledifenvironmentvariable\",{\"1\":{\"796\":1}}],[\"enabledifsystemproperty\",{\"1\":{\"796\":1}}],[\"enabledifsystemproperty来对系统属性进行判断\",{\"1\":{\"796\":1}}],[\"enabledforjrerange\",{\"1\":{\"795\":1}}],[\"enabledonjre\",{\"1\":{\"794\":2}}],[\"enabledonjre来进行指定\",{\"1\":{\"794\":1}}],[\"enabledonos\",{\"1\":{\"793\":2}}],[\"enabledonos来指定\",{\"1\":{\"793\":1}}],[\"engines\",{\"1\":{\"599\":1}}],[\"english\",{\"1\":{\"65\":3}}],[\"en\",{\"1\":{\"544\":1,\"641\":1,\"643\":1,\"834\":1,\"888\":1,\"908\":3,\"913\":3}}],[\"environments>\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"environment>\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"environment\",{\"1\":{\"393\":2,\"721\":4}}],[\"enumeration\",{\"1\":{\"874\":3}}],[\"enumeration<string>\",{\"1\":{\"874\":1}}],[\"enumsource\",{\"1\":{\"810\":3}}],[\"enum<com\",{\"1\":{\"221\":1}}],[\"enum表示这是一个枚举类\",{\"1\":{\"221\":1}}],[\"enum\",{\"1\":{\"221\":2,\"810\":1}}],[\"enterprise\",{\"1\":{\"865\":1}}],[\"entity\",{\"1\":{\"120\":5,\"121\":1,\"254\":3,\"255\":2,\"643\":1,\"649\":1,\"660\":1,\"666\":1,\"668\":3,\"670\":2,\"671\":2,\"672\":3,\"678\":1,\"679\":1,\"714\":1,\"721\":1,\"834\":1}}],[\"entry\",{\"1\":{\"61\":1}}],[\"entryset\",{\"1\":{\"56\":1}}],[\"entry<k\",{\"1\":{\"56\":2,\"58\":1,\"61\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"25\":1}}],[\"eliminate\",{\"1\":{\"167\":1}}],[\"else\",{\"1\":{\"25\":3,\"59\":3,\"60\":3,\"107\":1,\"266\":1,\"606\":2,\"876\":11,\"889\":2,\"921\":1}}],[\"elementwise\",{\"1\":{\"423\":1,\"429\":1,\"437\":1,\"440\":2}}],[\"elementtype是一个枚举类型\",{\"1\":{\"206\":1}}],[\"elementtype\",{\"1\":{\"206\":2,\"207\":8,\"208\":3}}],[\"elementdata\",{\"1\":{\"25\":9,\"33\":1}}],[\"element\",{\"1\":{\"24\":2,\"25\":2,\"43\":1,\"361\":2,\"636\":1}}],[\"e>\",{\"1\":{\"23\":2,\"24\":2,\"32\":1,\"47\":1}}],[\"e\",{\"1\":{\"23\":2,\"24\":8,\"25\":5,\"32\":1,\"33\":3,\"37\":6,\"43\":8,\"44\":19,\"47\":2,\"59\":11,\"71\":4,\"90\":6,\"91\":6,\"92\":4,\"93\":2,\"94\":2,\"96\":4,\"97\":2,\"98\":2,\"105\":2,\"108\":4,\"110\":2,\"112\":6,\"113\":2,\"126\":4,\"127\":2,\"129\":4,\"131\":2,\"133\":2,\"144\":2,\"148\":2,\"156\":4,\"161\":2,\"162\":2,\"165\":4,\"172\":4,\"174\":4,\"186\":2,\"199\":4,\"246\":2,\"267\":8,\"374\":1,\"417\":2,\"418\":4,\"422\":2,\"449\":1,\"468\":1,\"472\":2,\"473\":3,\"475\":1,\"478\":2,\"484\":1,\"487\":1,\"536\":6,\"537\":4,\"543\":4,\"544\":4,\"605\":2,\"613\":2,\"615\":3,\"616\":2,\"621\":2,\"622\":2,\"623\":8,\"636\":2,\"647\":2,\"864\":1,\"889\":2}}],[\"否则就是在执行过程中出现了什么错误\",{\"1\":{\"851\":1}}],[\"否则无法下载\",{\"1\":{\"826\":1}}],[\"否则必须保证形参列表与这边接口一致\",{\"1\":{\"719\":1}}],[\"否则可能会出现问题\",{\"1\":{\"659\":1}}],[\"否则返回默认值\",{\"1\":{\"355\":1}}],[\"否则返回false\",{\"1\":{\"23\":2,\"246\":1}}],[\"否则鬼知道你要用什么类型\",{\"1\":{\"328\":1}}],[\"否则报错\",{\"1\":{\"267\":1}}],[\"否则我们必须要使用\",{\"1\":{\"267\":1}}],[\"否则会直接忽略\",{\"1\":{\"793\":1}}],[\"否则会导致mybatis无法确认\",{\"1\":{\"658\":1}}],[\"否则会无法通过编译\",{\"1\":{\"218\":1}}],[\"否则会抛出异常\",{\"1\":{\"161\":1}}],[\"否则\",{\"1\":{\"207\":1,\"304\":1,\"387\":1}}],[\"否则资源会被一直占用\",{\"1\":{\"90\":1}}],[\"否则给你当成\",{\"1\":{\"84\":1}}],[\"否则太过死板\",{\"1\":{\"58\":1}}],[\"否则抛出\",{\"1\":{\"25\":1}}],[\"否则false\",{\"1\":{\"23\":3}}],[\"否则一律报错\",{\"1\":{\"15\":1}}],[\"否则要创建这个类的对象\",{\"1\":{\"9\":1}}],[\"不太常用\",{\"1\":{\"727\":1}}],[\"不太一样\",{\"1\":{\"518\":1}}],[\"不使用url而是resource表示是jar内部的文件\",{\"1\":{\"659\":1}}],[\"不满足将无法插入\",{\"1\":{\"596\":1}}],[\"不好\",{\"1\":{\"552\":1}}],[\"不用关心\",{\"1\":{\"864\":2}}],[\"不用手动加载驱动\",{\"1\":{\"605\":1}}],[\"不用进行求导\",{\"1\":{\"516\":1}}],[\"不用多说了吧\",{\"1\":{\"44\":3}}],[\"不记录\",{\"1\":{\"455\":1}}],[\"不动点x∗是唯一的\",{\"1\":{\"432\":1}}],[\"不常用\",{\"1\":{\"421\":1}}],[\"不论\",{\"1\":{\"374\":1}}],[\"不读换行符\",{\"1\":{\"374\":1}}],[\"不可能每次都去完整地启动一个项目来测试某一个功能\",{\"1\":{\"773\":1}}],[\"不可变\",{\"1\":{\"371\":1}}],[\"不可修改\",{\"1\":{\"371\":1}}],[\"不及格\",{\"1\":{\"338\":1,\"339\":1,\"340\":2}}],[\"不再是直接由tomcat\",{\"1\":{\"870\":1}}],[\"不再继续操作后面的元素\",{\"1\":{\"322\":1}}],[\"不再推荐使用newinstance\",{\"1\":{\"191\":1}}],[\"不知道怎么写\",{\"1\":{\"321\":1}}],[\"不然测试案例一多我们就分不清楚到底哪个案例是干嘛的\",{\"1\":{\"778\":1}}],[\"不然可能会映射失败导致查询结果丢失\",{\"1\":{\"643\":1}}],[\"不然会报错\",{\"1\":{\"537\":1}}],[\"不然之前版本的库就用不了了\",{\"1\":{\"306\":1}}],[\"不然就无法通过编译\",{\"1\":{\"267\":1}}],[\"不如说是我们为所需要的接口提供了一个方法作为它的实现\",{\"1\":{\"289\":1}}],[\"不只是类\",{\"1\":{\"282\":1}}],[\"不见当年倒茶人\",{\"1\":{\"258\":1}}],[\"不会导入可选的依赖\",{\"1\":{\"842\":1}}],[\"不会重置其他会话的缓存\",{\"1\":{\"700\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"599\":1}}],[\"不会用空格填充\",{\"1\":{\"563\":1}}],[\"不会保持长久连接\",{\"1\":{\"544\":1}}],[\"不会保存数据\",{\"1\":{\"357\":1}}],[\"不会影响所求的梯度\",{\"1\":{\"400\":1}}],[\"不会修改原来的数据源\",{\"1\":{\"357\":1}}],[\"不会调用外部类的\",{\"1\":{\"254\":1}}],[\"不会终止\",{\"0\":{\"167\":1}}],[\"不包括换行\",{\"1\":{\"246\":1}}],[\"不是resource中的资源\",{\"1\":{\"901\":1}}],[\"不是数据结构\",{\"1\":{\"357\":1}}],[\"不是静态方法\",{\"1\":{\"258\":1}}],[\"不是基本类型\",{\"1\":{\"227\":1}}],[\"不是接口\",{\"1\":{\"166\":1}}],[\"不需要直接使用特定驱动中的类或是方法\",{\"1\":{\"833\":1}}],[\"不需要此依赖\",{\"1\":{\"833\":1}}],[\"不需要手动导入jar包\",{\"1\":{\"817\":1}}],[\"不需要我们做任何事情\",{\"1\":{\"659\":1}}],[\"不需要声明访问权限\",{\"1\":{\"253\":1}}],[\"不需要依附任何对象\",{\"1\":{\"252\":1}}],[\"不需要\",{\"1\":{\"227\":1,\"252\":1}}],[\"不需要和用户交互\",{\"1\":{\"172\":1}}],[\"不保留到运行时\",{\"1\":{\"204\":2}}],[\"不要关闭\",{\"1\":{\"864\":1}}],[\"不要使用\",{\"1\":{\"244\":1}}],[\"不要出现这种死锁的情况\",{\"1\":{\"156\":1}}],[\"不要跟之前的迭代器接口搞混了\",{\"1\":{\"36\":1}}],[\"不过需要注意一下顺序\",{\"1\":{\"746\":1}}],[\"不过很遗憾的是\",{\"1\":{\"718\":1}}],[\"不过建议还是写完整一点\",{\"1\":{\"670\":1}}],[\"不过我们每次都可以通过打开视图来按照我们想要的样子查看数据\",{\"1\":{\"596\":1}}],[\"不过我们可以添加restrict或cascade\",{\"1\":{\"568\":1}}],[\"不过我们发现\",{\"1\":{\"304\":1}}],[\"不过最后编译出来的样子\",{\"1\":{\"339\":1}}],[\"不过貌似可以直接下载文件\",{\"1\":{\"333\":1}}],[\"不过它不支持在lambda中使用\",{\"1\":{\"330\":1}}],[\"不过这样的话流里面就没东西了\",{\"1\":{\"320\":1}}],[\"不过\",{\"1\":{\"306\":1,\"678\":1}}],[\"不过此时当被包装的对象为null时会直接抛出异常\",{\"1\":{\"297\":1}}],[\"不过还可以进行优化\",{\"1\":{\"290\":1}}],[\"不过没必要\",{\"1\":{\"244\":1}}],[\"不过可以省略\",{\"1\":{\"219\":1}}],[\"不过如果子类也是抽象类\",{\"1\":{\"218\":1}}],[\"不过默认是向控制台打印\",{\"1\":{\"127\":1}}],[\"不过上面写法比较繁琐\",{\"1\":{\"90\":1}}],[\"不涉及字符编码转换\",{\"1\":{\"88\":1}}],[\"不支持抽象类\",{\"1\":{\"257\":1,\"290\":1}}],[\"不支持\",{\"1\":{\"79\":2}}],[\"不支持随机访问\",{\"1\":{\"47\":1}}],[\"不存在key时\",{\"1\":{\"64\":1}}],[\"不存在\",{\"1\":{\"64\":1}}],[\"不允许有重复的值和空值\",{\"1\":{\"564\":1}}],[\"不允许对此类继承\",{\"1\":{\"346\":1}}],[\"不允许\",{\"1\":{\"239\":1,\"371\":1}}],[\"不允许进行修改\",{\"1\":{\"236\":1}}],[\"不允许通过下标访问\",{\"1\":{\"47\":1}}],[\"不允许出现重复元素\",{\"1\":{\"47\":1}}],[\"不进行出队操作\",{\"1\":{\"43\":1}}],[\"不仅带来网络上的额外开销\",{\"1\":{\"688\":1}}],[\"不仅仅是一个普通的集合或是数组可以作为字段参数来源\",{\"1\":{\"812\":1}}],[\"不仅仅是mybatis\",{\"1\":{\"636\":1}}],[\"不仅仅适用于xml\",{\"1\":{\"634\":1}}],[\"不仅仅只运行一个主线程\",{\"1\":{\"138\":1}}],[\"不仅会返回两个表满足条件的交集部分\",{\"1\":{\"586\":1}}],[\"不仅代码简短\",{\"1\":{\"340\":1}}],[\"不仅可以一定程度上防止源代码被反编译\",{\"1\":{\"199\":1}}],[\"不仅能从前向后\",{\"1\":{\"37\":1}}],[\"不仅保存指向下一个结点的引用\",{\"1\":{\"25\":1}}],[\"不能转发给其他站点或是其他web应用程序\",{\"1\":{\"900\":1}}],[\"不能一个socket之后就done了\",{\"1\":{\"544\":1}}],[\"不能用同一个q\",{\"1\":{\"387\":1}}],[\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组\",{\"1\":{\"281\":1}}],[\"不能匹配\",{\"1\":{\"246\":2}}],[\"不能随便进行修改\",{\"1\":{\"236\":1}}],[\"不能\",{\"1\":{\"229\":1}}],[\"不能直接通过\",{\"1\":{\"255\":1}}],[\"不能直接创建对象\",{\"1\":{\"219\":1}}],[\"不能直接用10\",{\"1\":{\"25\":1}}],[\"不能使用不同的变量进行接收\",{\"1\":{\"281\":1}}],[\"不能使用默认\",{\"1\":{\"219\":1}}],[\"不能使用==\",{\"1\":{\"216\":1}}],[\"不能是静态方法\",{\"1\":{\"776\":1}}],[\"不能是\",{\"1\":{\"218\":1}}],[\"不能认为每一步是直接依次执行的\",{\"1\":{\"71\":1}}],[\"不能进行修改操作\",{\"1\":{\"25\":1}}],[\"不充足需要扩容\",{\"1\":{\"25\":1}}],[\"不同路径配置\",{\"0\":{\"878\":1}}],[\"不同类型的数据库\",{\"1\":{\"604\":1}}],[\"不同类的重名问题\",{\"1\":{\"120\":1}}],[\"不同于主键\",{\"1\":{\"564\":1}}],[\"不同线程向threadlocal存放数据\",{\"1\":{\"162\":1}}],[\"不同包下的类\",{\"1\":{\"121\":1}}],[\"不同包下的子类\",{\"1\":{\"121\":1}}],[\"不同集合类\",{\"0\":{\"33\":1}}],[\"不同的路径代表访问不同的资源\",{\"1\":{\"859\":1}}],[\"不同的协议决定了服务器返回信息的格式\",{\"1\":{\"859\":1}}],[\"不同的可执行文件都能通过jdbc访问数据库\",{\"1\":{\"604\":1}}],[\"不同的无人机agent的q\",{\"1\":{\"387\":1}}],[\"不同的壁纸似乎都是这样\",{\"1\":{\"333\":1}}],[\"不同的模块会导出不同的包供我们使用\",{\"1\":{\"306\":1}}],[\"不同的线程访问到threadlocal对象时\",{\"1\":{\"162\":1}}],[\"不同的对象代表不同的对象锁\",{\"1\":{\"155\":1}}],[\"不同的访问权限\",{\"1\":{\"121\":1}}],[\"不同的文本文件可能会有不同的编码类型\",{\"1\":{\"97\":1}}],[\"不同的实现有着不同的遍历方式\",{\"1\":{\"31\":1}}],[\"不同的集合类具体实现可能会对插入的元素有要求\",{\"1\":{\"23\":1}}],[\"不同的集合有着不同的性质\",{\"1\":{\"21\":1}}],[\"不同之处\",{\"1\":{\"22\":1}}],[\"不同对象的属性是分开独立存放的\",{\"1\":{\"4\":1}}],[\"不指定具体类型也是可以的\",{\"1\":{\"16\":1}}],[\"不得是其他类型\",{\"1\":{\"15\":1}}],[\"vˉπ0​\",{\"1\":{\"526\":1,\"529\":1}}],[\"vˉπ​=es∼d​\",{\"1\":{\"524\":1}}],[\"vˉπ​=s∈s∑​d\",{\"1\":{\"524\":1}}],[\"vˉπ​\",{\"1\":{\"524\":1,\"526\":1,\"529\":1}}],[\"v^\",{\"1\":{\"505\":1}}],[\"vt​\",{\"1\":{\"486\":3}}],[\"vt+1​\",{\"1\":{\"486\":2}}],[\"vu\",{\"1\":{\"444\":1}}],[\"v0​\",{\"1\":{\"444\":2}}],[\"vπ1​​\",{\"1\":{\"444\":1}}],[\"vπ1​​=rπ1​​+γpπ1​​vπ1​​\",{\"1\":{\"444\":1}}],[\"vπ0​​是通过迭代算法来求的\",{\"1\":{\"444\":1}}],[\"vπ0​​=rπ0​​+γpπ0​​vπ0​​\",{\"1\":{\"444\":1}}],[\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",{\"1\":{\"442\":1}}],[\"vπk​​=\",{\"1\":{\"442\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​policyimprovement\",{\"1\":{\"451\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​\",{\"1\":{\"440\":1,\"444\":1}}],[\"vπk​​\",{\"1\":{\"440\":1,\"442\":1,\"451\":1}}],[\"vπk​\",{\"1\":{\"440\":2,\"442\":1}}],[\"vπ​=\",{\"1\":{\"420\":1,\"421\":1}}],[\"vπ​=rπ​+γpπ​vπ​​\",{\"1\":{\"420\":1}}],[\"vπ​\",{\"1\":{\"401\":1,\"414\":2,\"416\":1,\"418\":1,\"419\":3,\"420\":4,\"422\":5,\"423\":1,\"429\":2,\"431\":1,\"449\":1,\"486\":1,\"487\":4,\"507\":1,\"508\":2,\"509\":2,\"510\":5,\"511\":1,\"512\":1,\"524\":2}}],[\"v=b3\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"v=\",{\"1\":{\"544\":3,\"913\":3}}],[\"v=f\",{\"1\":{\"432\":1,\"435\":1}}],[\"v=πmax​\",{\"1\":{\"429\":1}}],[\"vk​\",{\"1\":{\"436\":1}}],[\"vk​→vπ​=\",{\"1\":{\"421\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​\",{\"1\":{\"444\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​这里的vk​并不是\",{\"1\":{\"437\":1}}],[\"vk+1​=rπ​+γpπ​vk​​\",{\"1\":{\"421\":1}}],[\"vk+1​=f\",{\"1\":{\"436\":1}}],[\"v2​\",{\"1\":{\"421\":1}}],[\"v1​=rπ1​​+γpπ1​​v0​\",{\"1\":{\"444\":1}}],[\"v1​\",{\"1\":{\"421\":1}}],[\"verify命令可以按顺序执行每个默认生命周期阶段\",{\"1\":{\"851\":1}}],[\"version这三个元素合在一起\",{\"1\":{\"820\":1}}],[\"version>\",{\"1\":{\"819\":1,\"825\":1,\"834\":3,\"835\":1,\"840\":2,\"841\":1,\"842\":3,\"843\":1,\"849\":1,\"850\":5,\"854\":1,\"888\":2,\"891\":1}}],[\"version\",{\"1\":{\"755\":1,\"820\":1,\"909\":1}}],[\"version=\",{\"1\":{\"634\":2,\"641\":1,\"643\":1,\"819\":1,\"834\":1,\"840\":1,\"849\":1,\"888\":1}}],[\"very\",{\"1\":{\"384\":1}}],[\"vector\",{\"0\":{\"420\":1},\"1\":{\"420\":1,\"423\":1,\"429\":1}}],[\"vehicles\",{\"1\":{\"378\":1}}],[\"vehicular\",{\"1\":{\"377\":1},\"2\":{\"390\":1}}],[\"vvv\",{\"1\":{\"297\":1}}],[\"view\",{\"1\":{\"596\":3,\"864\":1}}],[\"view来创建视图\",{\"1\":{\"596\":1}}],[\"visit\",{\"1\":{\"455\":4,\"458\":2}}],[\"virtual\",{\"1\":{\"183\":1}}],[\"via\",{\"1\":{\"167\":1,\"605\":1}}],[\"v+\",{\"1\":{\"64\":2}}],[\"v会返回null\",{\"1\":{\"64\":1}}],[\"v\",{\"1\":{\"56\":7,\"58\":1,\"59\":5,\"61\":1,\"64\":3,\"65\":2,\"229\":1,\"432\":5,\"435\":1,\"437\":2,\"484\":1,\"886\":2}}],[\"v>>\",{\"1\":{\"56\":1}}],[\"v>\",{\"1\":{\"56\":3,\"58\":7,\"59\":4,\"60\":4,\"61\":4}}],[\"v就是值的类型\",{\"1\":{\"56\":1}}],[\"validate\",{\"1\":{\"851\":1}}],[\"validate命令可以验证项目的可用性\",{\"1\":{\"851\":1}}],[\"val\",{\"1\":{\"367\":6}}],[\"value>\",{\"1\":{\"903\":1}}],[\"value>我是全局初始化参数<\",{\"1\":{\"903\":1}}],[\"value就是要设置的值\",{\"1\":{\"658\":1}}],[\"value为object类型\",{\"1\":{\"650\":1}}],[\"value=\",{\"1\":{\"641\":4,\"669\":1,\"768\":2,\"834\":7,\"888\":4}}],[\"value与\",{\"1\":{\"629\":1}}],[\"value后\",{\"1\":{\"451\":1}}],[\"value的关系\",{\"1\":{\"416\":1}}],[\"valueof\",{\"1\":{\"221\":1,\"227\":1,\"228\":1,\"229\":4}}],[\"value2\",{\"1\":{\"207\":1,\"355\":4}}],[\"value1\",{\"1\":{\"207\":1,\"355\":4}}],[\"value++\",{\"1\":{\"154\":2,\"155\":3}}],[\"valuesource是最简单的一种参数设定\",{\"1\":{\"808\":1}}],[\"valuesource来进行参数来源设定\",{\"1\":{\"808\":1}}],[\"valuesource\",{\"1\":{\"808\":1}}],[\"values\",{\"1\":{\"56\":1,\"221\":1,\"359\":2,\"505\":2,\"571\":3,\"613\":1,\"615\":2,\"623\":11,\"678\":1,\"679\":1,\"688\":1,\"694\":2,\"713\":1,\"714\":2,\"804\":1}}],[\"value\",{\"0\":{\"412\":1,\"414\":1,\"415\":1,\"421\":1,\"422\":1,\"432\":1,\"436\":1,\"444\":1,\"485\":1,\"489\":1,\"493\":1,\"504\":1,\"506\":1,\"524\":1,\"527\":1},\"1\":{\"15\":5,\"25\":2,\"56\":3,\"58\":1,\"59\":9,\"60\":2,\"61\":2,\"65\":1,\"67\":2,\"154\":2,\"155\":4,\"193\":6,\"207\":3,\"208\":3,\"229\":1,\"280\":3,\"281\":8,\"294\":2,\"296\":2,\"305\":2,\"397\":1,\"411\":1,\"414\":5,\"415\":3,\"416\":1,\"419\":1,\"421\":1,\"422\":10,\"423\":4,\"426\":1,\"427\":1,\"429\":1,\"430\":1,\"431\":2,\"436\":1,\"437\":3,\"440\":3,\"442\":2,\"443\":1,\"444\":12,\"445\":2,\"449\":2,\"451\":6,\"453\":6,\"455\":3,\"456\":2,\"458\":1,\"466\":2,\"485\":1,\"487\":2,\"489\":2,\"490\":1,\"493\":2,\"494\":1,\"504\":1,\"521\":1,\"522\":1,\"524\":1,\"658\":2,\"729\":2,\"780\":2,\"881\":1,\"889\":1,\"902\":2,\"909\":2}}],[\"varchar\",{\"1\":{\"563\":1,\"564\":3,\"565\":2}}],[\"var关键字必须位于有初始值设定的变量上\",{\"1\":{\"328\":1}}],[\"var\",{\"1\":{\"328\":2,\"330\":1,\"331\":1,\"340\":3}}],[\"vars命令来展示当前定义的变量列表\",{\"1\":{\"316\":1}}],[\"various\",{\"1\":{\"167\":1}}],[\"var2\",{\"1\":{\"30\":3}}],[\"void类\",{\"1\":{\"229\":1}}],[\"void\",{\"1\":{\"4\":3,\"5\":2,\"7\":2,\"14\":6,\"15\":3,\"16\":1,\"23\":2,\"24\":3,\"25\":10,\"30\":2,\"32\":2,\"34\":2,\"35\":2,\"36\":1,\"37\":3,\"43\":1,\"44\":4,\"45\":1,\"46\":2,\"47\":1,\"48\":3,\"49\":1,\"50\":2,\"56\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":2,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":2,\"120\":2,\"121\":2,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"139\":1,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":7,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":4,\"166\":2,\"167\":4,\"172\":2,\"173\":2,\"174\":3,\"182\":1,\"183\":1,\"184\":1,\"186\":9,\"191\":4,\"192\":5,\"193\":3,\"198\":3,\"199\":2,\"206\":1,\"207\":3,\"208\":2,\"215\":7,\"216\":1,\"218\":2,\"219\":7,\"220\":2,\"221\":2,\"227\":4,\"228\":1,\"229\":3,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":4,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":6,\"252\":2,\"253\":2,\"254\":3,\"255\":8,\"256\":2,\"257\":4,\"258\":5,\"266\":2,\"267\":6,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":2,\"288\":2,\"289\":1,\"290\":1,\"291\":1,\"292\":2,\"294\":1,\"295\":1,\"296\":1,\"297\":4,\"304\":1,\"305\":1,\"307\":1,\"311\":1,\"317\":3,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":6,\"328\":2,\"330\":1,\"331\":3,\"333\":4,\"343\":1,\"344\":1,\"347\":1,\"352\":1,\"355\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":4,\"536\":3,\"537\":2,\"543\":2,\"544\":2,\"606\":1,\"613\":1,\"615\":1,\"616\":1,\"622\":1,\"623\":4,\"627\":3,\"641\":1,\"643\":1,\"647\":1,\"658\":1,\"725\":1,\"727\":1,\"767\":2,\"773\":4,\"776\":4,\"777\":1,\"778\":1,\"780\":1,\"786\":1,\"791\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":2,\"797\":1,\"802\":3,\"803\":2,\"804\":4,\"805\":5,\"807\":1,\"808\":1,\"809\":2,\"810\":2,\"811\":1,\"812\":2,\"825\":1,\"834\":3,\"840\":2,\"849\":1,\"852\":1,\"871\":3,\"874\":1,\"876\":4,\"881\":2,\"886\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":1,\"920\":3,\"921\":3,\"922\":1}}],[\"icon\",{\"1\":{\"891\":3}}],[\"icon等\",{\"1\":{\"864\":1}}],[\"ibatis\",{\"1\":{\"658\":2,\"660\":2}}],[\"ip连接是否有效\",{\"1\":{\"538\":1}}],[\"ip地址为\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"iid\",{\"1\":{\"449\":1}}],[\"i−γpπk​​\",{\"1\":{\"442\":1}}],[\"i−γpπ​\",{\"1\":{\"421\":2}}],[\"ij​=pπ​\",{\"1\":{\"420\":1}}],[\"i=1n​\",{\"1\":{\"393\":2}}],[\"ieee\",{\"1\":{\"377\":1},\"2\":{\"390\":1}}],[\"immediate\",{\"0\":{\"417\":1},\"1\":{\"419\":1}}],[\"immutablecollections\",{\"1\":{\"371\":1}}],[\"immutable\",{\"1\":{\"371\":1}}],[\"image\",{\"1\":{\"544\":3,\"633\":1,\"635\":1,\"859\":1,\"891\":2,\"908\":3,\"913\":3}}],[\"images\",{\"1\":{\"333\":1}}],[\"imageinput\",{\"1\":{\"333\":3}}],[\"imageresponse\",{\"1\":{\"333\":2}}],[\"imagerequest\",{\"1\":{\"333\":2}}],[\"img\",{\"1\":{\"333\":1,\"627\":1,\"926\":1}}],[\"improvement\",{\"1\":{\"440\":1,\"444\":1,\"453\":1,\"456\":1,\"462\":1,\"485\":1,\"489\":1,\"494\":1}}],[\"impl\",{\"1\":{\"291\":2}}],[\"implemented\",{\"1\":{\"876\":1}}],[\"implementing\",{\"1\":{\"139\":1}}],[\"implements\",{\"1\":{\"25\":2,\"36\":1,\"42\":1,\"58\":2,\"67\":1,\"131\":1,\"132\":1,\"133\":1,\"219\":2,\"220\":1,\"282\":2,\"305\":1,\"310\":1,\"344\":1,\"347\":1,\"727\":1,\"871\":1,\"919\":1,\"920\":1,\"922\":1}}],[\"importance\",{\"0\":{\"404\":1}}],[\"import\",{\"1\":{\"23\":1,\"120\":3,\"121\":1,\"208\":4,\"229\":2,\"254\":1,\"274\":1,\"307\":1,\"310\":1,\"311\":1,\"355\":1,\"613\":2,\"643\":1,\"849\":1}}],[\"i都会更新成数组中下一个元素\",{\"1\":{\"237\":1}}],[\"i+1\",{\"1\":{\"616\":1}}],[\"i+\",{\"1\":{\"237\":1,\"290\":4}}],[\"i++\",{\"1\":{\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":8,\"161\":1,\"172\":2,\"237\":1,\"274\":1,\"321\":1,\"323\":1,\"333\":3,\"616\":1,\"636\":1,\"688\":1,\"693\":1}}],[\"i就是每一个数组中的元素\",{\"1\":{\"237\":1}}],[\"its\",{\"1\":{\"167\":1}}],[\"it\",{\"1\":{\"139\":1,\"172\":2,\"352\":1,\"378\":1,\"455\":1,\"606\":3}}],[\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称\",{\"1\":{\"693\":1}}],[\"item=\",{\"1\":{\"693\":1,\"694\":1}}],[\"item\",{\"1\":{\"25\":2,\"33\":1,\"636\":2,\"693\":2,\"694\":3}}],[\"iteration\",{\"0\":{\"436\":1,\"439\":1,\"443\":1,\"444\":2,\"445\":1,\"446\":1},\"1\":{\"436\":1,\"442\":2,\"443\":2,\"444\":10,\"445\":3,\"450\":1,\"451\":1,\"453\":1,\"456\":1}}],[\"iterative\",{\"1\":{\"421\":1,\"466\":1}}],[\"iterate\",{\"1\":{\"321\":2,\"322\":2}}],[\"iterator<t>\",{\"1\":{\"36\":1}}],[\"iterator<string>\",{\"1\":{\"34\":1,\"36\":2}}],[\"iterator<e>\",{\"1\":{\"23\":2,\"32\":1,\"37\":1,\"44\":1,\"47\":1,\"67\":1}}],[\"iterator\",{\"1\":{\"23\":2,\"30\":3,\"34\":4,\"36\":3,\"47\":1,\"67\":2,\"173\":1}}],[\"iterable<string>\",{\"1\":{\"36\":1}}],[\"iterable<t>\",{\"1\":{\"36\":1,\"653\":1}}],[\"iterable<e>\",{\"1\":{\"23\":1}}],[\"iterable\",{\"1\":{\"35\":1,\"36\":1,\"811\":1}}],[\"isdriverallowed\",{\"1\":{\"606\":1}}],[\"isdirectory\",{\"1\":{\"98\":1}}],[\"ispresent\",{\"1\":{\"355\":3}}],[\"issealed\",{\"1\":{\"347\":1}}],[\"isblank方法用于判断是否字符串为空或者是仅包含空格\",{\"1\":{\"331\":1}}],[\"isblank\",{\"1\":{\"331\":2}}],[\"isinterrupted\",{\"1\":{\"144\":1}}],[\"is\",{\"1\":{\"139\":3,\"167\":1,\"352\":2,\"378\":3,\"393\":1,\"394\":2,\"415\":1,\"427\":1,\"432\":2,\"455\":1,\"460\":2,\"528\":1,\"605\":4,\"606\":3,\"864\":1}}],[\"isempty\",{\"1\":{\"23\":1,\"25\":1,\"47\":1,\"56\":1,\"67\":2,\"167\":2,\"174\":1}}],[\"illegalstateexception\",{\"1\":{\"807\":1,\"808\":1}}],[\"illegalaccessexception\",{\"1\":{\"191\":2,\"192\":1,\"193\":1,\"305\":1}}],[\"illegalargumentexception\",{\"1\":{\"25\":1}}],[\"illegal\",{\"1\":{\"25\":1}}],[\"ioutils\",{\"1\":{\"891\":1,\"892\":1}}],[\"io<\",{\"1\":{\"891\":2}}],[\"io3\",{\"0\":{\"124\":1}}],[\"io流3\",{\"0\":{\"125\":1}}],[\"io流2\",{\"0\":{\"102\":1}}],[\"io流1\",{\"0\":{\"88\":1}}],[\"io2\",{\"0\":{\"101\":1}}],[\"ioexception\",{\"1\":{\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"199\":1,\"267\":6,\"323\":3,\"333\":4,\"536\":3,\"537\":2,\"543\":2,\"790\":1,\"871\":1,\"874\":1,\"876\":4,\"881\":1,\"886\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":1,\"920\":3,\"921\":3}}],[\"io中\",{\"1\":{\"88\":1}}],[\"io1\",{\"0\":{\"87\":1}}],[\"io\",{\"1\":{\"25\":2,\"42\":1,\"67\":1,\"95\":2,\"305\":1,\"613\":1,\"727\":1,\"891\":1}}],[\"i\",{\"1\":{\"24\":3,\"33\":2,\"59\":3,\"71\":4,\"108\":1,\"142\":3,\"147\":5,\"148\":5,\"154\":4,\"155\":12,\"161\":3,\"172\":4,\"173\":1,\"186\":9,\"192\":1,\"193\":12,\"227\":9,\"228\":4,\"229\":6,\"237\":4,\"274\":2,\"282\":2,\"290\":5,\"291\":2,\"321\":8,\"322\":8,\"323\":2,\"333\":7,\"449\":2,\"452\":1,\"543\":5,\"544\":3,\"613\":2,\"616\":7,\"636\":3,\"688\":3,\"693\":3}}],[\"ifmodifiedsince\",{\"1\":{\"876\":2}}],[\"if>\",{\"1\":{\"690\":1,\"719\":2}}],[\"ifpresentorelse\",{\"1\":{\"323\":1}}],[\"ifpresent表示只有对象不为null才会执行里面的逻辑\",{\"1\":{\"297\":1}}],[\"ifpresent\",{\"1\":{\"297\":2,\"323\":2}}],[\"if\",{\"1\":{\"23\":1,\"25\":6,\"59\":10,\"60\":5,\"84\":4,\"90\":1,\"107\":2,\"142\":1,\"144\":1,\"147\":1,\"148\":1,\"167\":2,\"216\":2,\"219\":1,\"227\":1,\"266\":2,\"297\":1,\"342\":2,\"352\":3,\"427\":1,\"432\":1,\"460\":1,\"472\":1,\"544\":1,\"566\":1,\"606\":12,\"616\":2,\"636\":1,\"719\":1,\"789\":2,\"807\":1,\"808\":1,\"864\":2,\"876\":12,\"889\":2,\"893\":1,\"910\":6,\"913\":1,\"921\":3}}],[\"idea\",{\"0\":{\"865\":1}}],[\"idea默认给我们添加了一个parent节点\",{\"1\":{\"849\":1}}],[\"identified\",{\"1\":{\"589\":1}}],[\"identically\",{\"1\":{\"449\":1}}],[\"identity\",{\"1\":{\"364\":1}}],[\"id>\",{\"1\":{\"827\":1,\"854\":1}}],[\"id等于2的必须满足等于18岁\",{\"1\":{\"691\":1}}],[\"id等于1的必须同时要满足小于18岁\",{\"1\":{\"691\":1}}],[\"idle\",{\"1\":{\"384\":1}}],[\"id=1\",{\"1\":{\"669\":2}}],[\"id=\",{\"1\":{\"333\":1,\"641\":1,\"643\":1,\"648\":4,\"650\":1,\"651\":1,\"652\":2,\"653\":2,\"658\":2,\"659\":3,\"660\":1,\"666\":2,\"667\":1,\"668\":3,\"670\":1,\"671\":3,\"672\":5,\"678\":1,\"679\":1,\"680\":1,\"681\":1,\"690\":1,\"691\":1,\"693\":1,\"694\":1,\"703\":1,\"704\":1,\"712\":1,\"714\":1,\"715\":1,\"719\":1,\"834\":1,\"888\":1,\"893\":1}}],[\"ids\",{\"1\":{\"138\":2}}],[\"id一般是int\",{\"1\":{\"56\":1}}],[\"id\",{\"1\":{\"15\":4,\"280\":4,\"281\":4,\"564\":6,\"565\":1,\"648\":4,\"650\":2,\"651\":3,\"652\":3,\"653\":1,\"658\":12,\"659\":1,\"660\":8,\"666\":2,\"667\":9,\"668\":7,\"669\":4,\"670\":6,\"672\":7,\"679\":2,\"680\":4,\"681\":2,\"690\":3,\"691\":4,\"693\":2,\"703\":2,\"704\":2,\"714\":4,\"715\":3,\"717\":7,\"718\":10,\"719\":12,\"720\":3}}],[\"invalidate\",{\"1\":{\"914\":1}}],[\"invoking\",{\"1\":{\"606\":1}}],[\"invoker\",{\"1\":{\"658\":1}}],[\"invoker是mybatis内部编写一个用于反射设置对象属性值的工具\",{\"1\":{\"658\":1}}],[\"invoked\",{\"1\":{\"378\":1}}],[\"invoke不需要对象参数\",{\"1\":{\"192\":1}}],[\"invoke\",{\"1\":{\"192\":3,\"199\":2,\"658\":1}}],[\"invocationtargetexception\",{\"1\":{\"191\":1,\"192\":1,\"193\":1}}],[\"include\",{\"1\":{\"810\":1}}],[\"indicativesentences\",{\"1\":{\"779\":1}}],[\"indirectly\",{\"1\":{\"606\":1}}],[\"independent\",{\"1\":{\"449\":1}}],[\"index=\",{\"1\":{\"693\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"267\":2}}],[\"indexofsublist\",{\"1\":{\"80\":1}}],[\"indexof\",{\"1\":{\"24\":1,\"333\":2}}],[\"index++\",{\"1\":{\"25\":1}}],[\"index\",{\"1\":{\"24\":6,\"25\":4,\"597\":3,\"693\":1}}],[\"installation\",{\"1\":{\"864\":1}}],[\"install命令可以将当前项目安装到本地仓库\",{\"1\":{\"851\":1}}],[\"install来安装我们自己的项目到本地maven仓库中\",{\"1\":{\"840\":1}}],[\"instantiationexception\",{\"1\":{\"191\":2,\"192\":1,\"193\":1}}],[\"instanceof迎来了一波小更新\",{\"1\":{\"342\":1}}],[\"instanceof\",{\"1\":{\"59\":1,\"186\":2,\"208\":2,\"216\":1,\"219\":1,\"342\":2,\"876\":2,\"921\":2}}],[\"instance\",{\"1\":{\"4\":1,\"183\":1,\"192\":4,\"819\":1,\"840\":1,\"849\":1}}],[\"insertstudent\",{\"1\":{\"714\":1}}],[\"insertalluser\",{\"1\":{\"694\":1}}],[\"insertuser\",{\"1\":{\"694\":1,\"713\":1,\"714\":2}}],[\"insert>\",{\"1\":{\"678\":1,\"679\":1,\"694\":1,\"714\":1}}],[\"insert|update|delete\",{\"1\":{\"598\":1}}],[\"insert\",{\"1\":{\"571\":3,\"613\":1,\"615\":2,\"623\":11,\"677\":2,\"678\":1,\"679\":1,\"688\":1,\"694\":2,\"701\":1,\"713\":2,\"714\":3}}],[\"insecure\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"inetsocketaddress\",{\"1\":{\"538\":1}}],[\"innertext\",{\"1\":{\"893\":1}}],[\"inner>\",{\"1\":{\"634\":1}}],[\"inner2\",{\"1\":{\"251\":2,\"747\":1}}],[\"inner1\",{\"1\":{\"251\":2,\"747\":1}}],[\"inner\",{\"1\":{\"251\":12,\"252\":5,\"253\":5,\"254\":3,\"317\":2,\"586\":1}}],[\"inherited\",{\"1\":{\"205\":1}}],[\"inheritablethreadlocal<>\",{\"1\":{\"163\":1}}],[\"inherits\",{\"1\":{\"139\":1}}],[\"initparams\",{\"1\":{\"902\":1}}],[\"initconfiguration\",{\"1\":{\"721\":2}}],[\"init\",{\"1\":{\"139\":1,\"871\":1,\"872\":1,\"881\":2,\"889\":1}}],[\"initial\",{\"1\":{\"60\":3}}],[\"initialcapacity\",{\"1\":{\"25\":5}}],[\"information\",{\"1\":{\"864\":1}}],[\"infos\",{\"1\":{\"138\":2}}],[\"info\",{\"1\":{\"117\":3,\"138\":2,\"304\":2,\"306\":1,\"311\":3,\"606\":6,\"725\":1,\"727\":4,\"728\":1,\"736\":1,\"746\":1,\"767\":2,\"849\":1,\"881\":1}}],[\"in\",{\"0\":{\"377\":1},\"1\":{\"107\":4,\"128\":1,\"139\":1,\"352\":2,\"374\":1,\"378\":1,\"455\":1,\"472\":1,\"493\":1,\"537\":1,\"538\":1,\"544\":2,\"580\":2,\"621\":1,\"622\":1,\"658\":3,\"693\":2,\"864\":1}}],[\"inputmismatchexception\",{\"1\":{\"374\":1}}],[\"input\",{\"1\":{\"107\":3,\"352\":1}}],[\"inputstreamreader\",{\"1\":{\"126\":3,\"537\":2}}],[\"inputstream\",{\"1\":{\"88\":1,\"90\":5,\"91\":9,\"94\":2,\"98\":2,\"107\":1,\"131\":2,\"133\":2,\"323\":4,\"333\":1,\"537\":1,\"543\":3,\"544\":1,\"641\":3,\"891\":5}}],[\"int这样前面添加下划线\",{\"1\":{\"648\":1}}],[\"into\",{\"1\":{\"571\":3,\"613\":1,\"615\":2,\"623\":11,\"678\":1,\"679\":1,\"688\":1,\"694\":2,\"713\":1,\"714\":2}}],[\"into语句来向数据库中插入一条数据\",{\"1\":{\"571\":1}}],[\"int用于存储一般的整数\",{\"1\":{\"563\":1}}],[\"intfunction\",{\"1\":{\"365\":1}}],[\"intfunction<a\",{\"1\":{\"365\":1}}],[\"intsummarystatistics\",{\"1\":{\"71\":1}}],[\"ints\",{\"1\":{\"71\":2,\"364\":2}}],[\"intended\",{\"1\":{\"864\":1}}],[\"intel\",{\"1\":{\"544\":1}}],[\"interacting\",{\"1\":{\"393\":1}}],[\"interrupted\",{\"1\":{\"144\":1}}],[\"interruptedexception终止异常\",{\"1\":{\"161\":1}}],[\"interruptedexception\",{\"1\":{\"142\":1,\"143\":1,\"144\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":3,\"161\":2,\"162\":2,\"165\":2,\"172\":4,\"174\":2,\"215\":3,\"333\":4}}],[\"interrupt\",{\"1\":{\"144\":1}}],[\"interrupt用法\",{\"1\":{\"144\":1}}],[\"intermediate\",{\"1\":{\"71\":1}}],[\"interfaces\",{\"1\":{\"864\":3}}],[\"interface\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"36\":1,\"37\":1,\"43\":1,\"44\":1,\"47\":1,\"56\":2,\"139\":2,\"206\":2,\"207\":4,\"208\":1,\"219\":3,\"220\":1,\"255\":1,\"258\":2,\"282\":1,\"290\":2,\"296\":1,\"310\":1,\"317\":2,\"347\":1,\"352\":1,\"653\":1,\"659\":1,\"678\":1,\"712\":1,\"713\":1,\"720\":1,\"864\":2,\"888\":1}}],[\"integer的缩写\",{\"1\":{\"648\":1}}],[\"integer类中有一个叫做compare的静态方法\",{\"1\":{\"292\":1}}],[\"integercache会默认缓存\",{\"1\":{\"227\":1}}],[\"integercache\",{\"1\":{\"227\":4}}],[\"integer>\",{\"1\":{\"15\":1,\"65\":1,\"84\":1,\"318\":2}}],[\"integer\",{\"1\":{\"14\":7,\"25\":5,\"60\":2,\"65\":1,\"80\":1,\"183\":2,\"184\":1,\"186\":4,\"193\":4,\"215\":1,\"227\":13,\"228\":7,\"238\":1,\"258\":2,\"280\":3,\"281\":1,\"282\":2,\"290\":2,\"291\":2,\"292\":7,\"294\":10,\"295\":4,\"355\":7,\"364\":3,\"616\":2,\"627\":5,\"658\":2,\"669\":2,\"729\":2}}],[\"int\",{\"1\":{\"4\":2,\"5\":1,\"8\":3,\"9\":7,\"14\":2,\"23\":2,\"24\":10,\"25\":9,\"37\":2,\"47\":2,\"56\":2,\"58\":1,\"59\":3,\"60\":4,\"61\":1,\"65\":3,\"67\":1,\"71\":1,\"84\":1,\"91\":1,\"94\":1,\"117\":1,\"121\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":3,\"155\":14,\"161\":1,\"172\":2,\"173\":2,\"183\":2,\"186\":1,\"191\":1,\"192\":3,\"215\":2,\"218\":3,\"219\":1,\"220\":1,\"227\":3,\"235\":2,\"236\":2,\"237\":5,\"238\":4,\"239\":1,\"240\":1,\"241\":3,\"256\":1,\"258\":3,\"266\":4,\"267\":4,\"268\":1,\"274\":1,\"275\":2,\"292\":4,\"294\":3,\"295\":1,\"307\":2,\"321\":1,\"323\":1,\"333\":4,\"338\":2,\"339\":1,\"343\":1,\"364\":2,\"366\":4,\"367\":2,\"543\":2,\"544\":1,\"564\":2,\"565\":2,\"613\":2,\"616\":1,\"636\":1,\"643\":1,\"648\":4,\"652\":2,\"658\":6,\"659\":2,\"660\":4,\"666\":3,\"670\":3,\"671\":1,\"672\":3,\"677\":6,\"678\":1,\"680\":4,\"688\":1,\"693\":1,\"713\":1,\"714\":1,\"715\":2,\"717\":8,\"718\":2,\"719\":3,\"720\":1,\"780\":1,\"786\":2,\"808\":1,\"809\":1,\"825\":1,\"834\":2}}],[\"必须添加\",{\"1\":{\"892\":1}}],[\"必须设置\",{\"1\":{\"679\":1}}],[\"必须和构造方法的顺序一致\",{\"1\":{\"658\":1}}],[\"必须存在一个根节点\",{\"1\":{\"634\":1}}],[\"必须加\",{\"1\":{\"544\":1}}],[\"必须继承自父类\",{\"1\":{\"347\":1}}],[\"必须有子类继承\",{\"1\":{\"347\":1}}],[\"必须留一个抽象方法出来\",{\"1\":{\"257\":1,\"290\":1}}],[\"必须要进行异常的捕获\",{\"1\":{\"267\":1}}],[\"必须要考虑到出现异常的情况\",{\"1\":{\"264\":1}}],[\"必须要实现抽象类中所有抽象方法\",{\"1\":{\"218\":1}}],[\"必须要有\",{\"1\":{\"161\":1}}],[\"必须使用equals方法\",{\"1\":{\"216\":1}}],[\"必须注意是否安全\",{\"1\":{\"193\":1}}],[\"必须在开始之前\",{\"1\":{\"172\":2}}],[\"必须实现serializable接口才能被序列化\",{\"1\":{\"131\":1}}],[\"必须关闭这个流来完成对资源的释放\",{\"1\":{\"90\":1}}],[\"必须是static方法\",{\"1\":{\"802\":1}}],[\"必须是递增的\",{\"1\":{\"472\":1}}],[\"必须是在持有锁\",{\"1\":{\"161\":1}}],[\"必须是一个对象或是一个类\",{\"1\":{\"155\":1}}],[\"必须是实现\",{\"1\":{\"77\":1}}],[\"必须是number或是number的子类\",{\"1\":{\"15\":1}}],[\"必须调用我们自己定义的构造方法\",{\"1\":{\"9\":1}}],[\"返回结果为一个405页面\",{\"1\":{\"900\":1}}],[\"返回结点内部存放的元素\",{\"1\":{\"33\":1}}],[\"返回缓存对象的拷贝\",{\"1\":{\"701\":1}}],[\"返回多个\",{\"0\":{\"670\":1}}],[\"返回一个规范的响应文本\",{\"1\":{\"544\":1}}],[\"返回一个结果\",{\"1\":{\"362\":1}}],[\"返回一个string类型结果\",{\"1\":{\"290\":1}}],[\"返回它\",{\"1\":{\"355\":1}}],[\"返回对应的等级\",{\"1\":{\"338\":1}}],[\"返回void\",{\"1\":{\"297\":1}}],[\"返回负数\",{\"1\":{\"292\":1}}],[\"返回正数\",{\"1\":{\"292\":1}}],[\"返回泛型t\",{\"1\":{\"191\":1}}],[\"返回的是一个\",{\"1\":{\"331\":1}}],[\"返回的仍然是\",{\"1\":{\"186\":1}}],[\"返回的类型就是什么\",{\"1\":{\"14\":1}}],[\"返回备选方案\",{\"1\":{\"57\":1}}],[\"返回值为void\",{\"1\":{\"297\":1}}],[\"返回值为null\",{\"1\":{\"192\":1}}],[\"返回值一样\",{\"1\":{\"258\":1}}],[\"返回值就是方法的返回值\",{\"1\":{\"192\":1}}],[\"返回值是当前是否有中断标记\",{\"1\":{\"144\":1}}],[\"返回值是读取的字节数\",{\"1\":{\"91\":1}}],[\"返回值\",{\"1\":{\"60\":1,\"192\":1}}],[\"返回值我们会在后面讨论\",{\"1\":{\"57\":1}}],[\"返回值类型\",{\"1\":{\"5\":1}}],[\"返回当前键值对的哈希值\",{\"1\":{\"56\":1}}],[\"返回当前集合在指定范围内的子集\",{\"1\":{\"24\":1}}],[\"返回当前集合的迭代器\",{\"1\":{\"23\":1}}],[\"返回所有的键值对\",{\"1\":{\"56\":1}}],[\"返回map中存放的所有值\",{\"1\":{\"56\":1}}],[\"返回map中存放的所有键\",{\"1\":{\"56\":1}}],[\"返回其映射的值\",{\"1\":{\"56\":1}}],[\"返回上一个已遍历元素的下标\",{\"1\":{\"37\":1}}],[\"返回下一个待遍历元素的下标\",{\"1\":{\"37\":1}}],[\"瞬间变一行\",{\"1\":{\"14\":1}}],[\">更新数据<\",{\"1\":{\"893\":1}}],[\">点我下载高清资源<\",{\"1\":{\"891\":1}}],[\"><\",{\"1\":{\"635\":1,\"893\":1}}],[\"><img\",{\"1\":{\"333\":1}}],[\">=\",{\"1\":{\"59\":1,\"60\":2,\"71\":1,\"227\":1,\"564\":1,\"565\":1,\"580\":1}}],[\">>>\",{\"1\":{\"66\":1}}],[\">>\",{\"1\":{\"25\":1}}],[\">\",{\"1\":{\"14\":1,\"23\":3,\"25\":2,\"46\":1,\"47\":3,\"50\":1,\"59\":1,\"60\":2,\"64\":3,\"65\":2,\"71\":9,\"140\":2,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"156\":2,\"161\":3,\"162\":2,\"163\":2,\"165\":4,\"172\":3,\"173\":2,\"182\":3,\"183\":1,\"184\":1,\"186\":4,\"192\":4,\"199\":3,\"215\":1,\"227\":8,\"257\":7,\"258\":2,\"268\":1,\"281\":1,\"289\":3,\"290\":6,\"297\":1,\"319\":1,\"321\":3,\"322\":4,\"323\":4,\"330\":1,\"333\":1,\"339\":4,\"340\":5,\"352\":1,\"353\":1,\"354\":2,\"361\":1,\"364\":2,\"365\":2,\"580\":1,\"596\":1,\"606\":1,\"616\":2,\"634\":4,\"641\":11,\"643\":6,\"648\":4,\"649\":2,\"650\":1,\"651\":1,\"652\":5,\"653\":3,\"658\":4,\"659\":5,\"660\":1,\"666\":2,\"667\":9,\"668\":7,\"669\":1,\"670\":7,\"671\":7,\"672\":15,\"678\":1,\"679\":1,\"680\":1,\"681\":1,\"690\":4,\"691\":4,\"693\":2,\"694\":2,\"701\":2,\"703\":1,\"704\":1,\"711\":2,\"712\":1,\"714\":1,\"715\":3,\"717\":3,\"719\":9,\"768\":2,\"789\":6,\"790\":1,\"797\":1,\"812\":1,\"819\":2,\"834\":16,\"840\":2,\"843\":1,\"849\":2,\"864\":4,\"871\":2,\"886\":4,\"888\":11,\"889\":1,\"892\":2,\"910\":1}}],[\"这也是为什么我们启动tomcat服务器之后\",{\"1\":{\"871\":1}}],[\"这也证明了mybatis的缓存在生效\",{\"1\":{\"705\":1}}],[\"这需要使用三报文握手\",{\"1\":{\"859\":1}}],[\"这需求有点抽象\",{\"1\":{\"691\":1}}],[\"这将依次测试枚举类中的所有枚举\",{\"1\":{\"810\":1}}],[\"这将会导致无限循环\",{\"1\":{\"36\":1}}],[\"这会导致我们要花费大量时间来等待每次测试用例的初始化操作\",{\"1\":{\"803\":1}}],[\"这会导致mybatis自动处理出现问题\",{\"1\":{\"652\":1}}],[\"这在某些场景下可能会显得不太方便\",{\"1\":{\"803\":1}}],[\"这实际上是logger的父级提供的\",{\"1\":{\"735\":1}}],[\"这导致尽管会话2更新了数据\",{\"1\":{\"700\":1}}],[\"这非常适合处理我们前面说的批量执行sql的问题\",{\"1\":{\"692\":1}}],[\"这看似是一个很奇怪的查询条件\",{\"1\":{\"690\":1}}],[\"这与我们之前的xml配置完全一致\",{\"1\":{\"717\":1}}],[\"这与我们之前jdbc中是一样的\",{\"1\":{\"677\":1}}],[\"这与之前的一对一比较类似\",{\"1\":{\"672\":1}}],[\"这不仅使得我们类定义中充满了get和set方法\",{\"1\":{\"627\":1}}],[\"这并不是解决问题的最好办法\",{\"1\":{\"621\":1}}],[\"这包含资料的精确度\",{\"1\":{\"599\":1}}],[\"这表示写入的资料必须完全符合所有的预设规则\",{\"1\":{\"599\":1}}],[\"这另一个策略会更新到最优的策略\",{\"1\":{\"497\":1}}],[\"这类算法统称为\",{\"1\":{\"456\":1}}],[\"这一次请求直接返回了请求转发后的处理结果\",{\"1\":{\"900\":1}}],[\"这一次我们在resultmap中添加constructor标签\",{\"1\":{\"658\":1}}],[\"这一条\",{\"1\":{\"455\":1}}],[\"这一出场\",{\"1\":{\"344\":1}}],[\"这两个算法是一致的\",{\"1\":{\"444\":1}}],[\"这两种写法效果是完全一样的\",{\"1\":{\"714\":1}}],[\"这两种使用方法的弊端有\",{\"1\":{\"366\":1}}],[\"这两种分数类型都有可能出现\",{\"1\":{\"280\":1}}],[\"这步是更新策略π\",{\"1\":{\"437\":1}}],[\"这可以通过andthen方法来实现\",{\"1\":{\"354\":1}}],[\"这只是一种写法而已\",{\"1\":{\"289\":1}}],[\"这\",{\"1\":{\"245\":2}}],[\"这同样不是se中需要学习的内容\",{\"1\":{\"215\":1}}],[\"这玩意学来有啥用\",{\"1\":{\"208\":1}}],[\"这玩意居然能存字符串进去\",{\"1\":{\"80\":1}}],[\"这意味着\",{\"1\":{\"191\":1,\"701\":1}}],[\"这时在进行四次挥手\",{\"1\":{\"859\":1}}],[\"这时该咋写\",{\"1\":{\"346\":1}}],[\"这时\",{\"1\":{\"297\":1,\"899\":1}}],[\"这时为了方便\",{\"1\":{\"288\":1}}],[\"这时我们就可以使用三引号来囊括字符串\",{\"1\":{\"341\":1}}],[\"这时我们就可以手动抛出一个异常来终止程序继续运行下去\",{\"1\":{\"266\":1}}],[\"这时我们可以考虑使用optional进行包装\",{\"1\":{\"323\":1}}],[\"这时我们不希望用户将泛型指定为除数字类型外的其他类型\",{\"1\":{\"15\":1}}],[\"这时并没有立即释放锁\",{\"1\":{\"161\":1}}],[\"这时其他线程可以获取到此对象的锁\",{\"1\":{\"161\":1}}],[\"这就需要用到session了\",{\"1\":{\"910\":1}}],[\"这就导致我们还是会连带引入这些依赖\",{\"1\":{\"843\":1}}],[\"这就非常麻烦了\",{\"1\":{\"773\":1}}],[\"这就提供了可观的性能提升\",{\"1\":{\"701\":1}}],[\"这就是日志的配置文件\",{\"1\":{\"864\":1}}],[\"这就是maven本地仓库文件夹\",{\"1\":{\"826\":1}}],[\"这就是一种多对多的联系\",{\"1\":{\"550\":1}}],[\"这就是引入高速缓存引发的新问题\",{\"1\":{\"154\":1}}],[\"这就必然存在一个中间容器\",{\"1\":{\"174\":1}}],[\"这就产生了死锁\",{\"1\":{\"156\":1}}],[\"这样父项目就完全作为依赖统一管理\",{\"1\":{\"850\":1}}],[\"这样项目中就不会包含此依赖了\",{\"1\":{\"843\":1}}],[\"这样显然会降低我们的开发效率\",{\"1\":{\"773\":1}}],[\"这样显然是很冗余的\",{\"1\":{\"766\":1}}],[\"这样用mapper2时\",{\"1\":{\"701\":1}}],[\"这样sqlsession会开启批处理模式\",{\"1\":{\"688\":1}}],[\"这样下面在使用\",{\"1\":{\"678\":1}}],[\"这样mybatis运行时就会打印日志到控制台了\",{\"1\":{\"669\":1}}],[\"这样mybatis就可以通过association来自动处理了\",{\"1\":{\"672\":1}}],[\"这样mybatis就可以正确识别了\",{\"1\":{\"660\":1}}],[\"这样mybatis就可以按照我们的配置来正确找到对应的位置并赋值了\",{\"1\":{\"652\":1}}],[\"这样mybatis就知道该链接哪个数据库\",{\"1\":{\"641\":1}}],[\"这样编写实在是太复杂了\",{\"1\":{\"660\":1}}],[\"这样编写就不会报错了\",{\"1\":{\"330\":1}}],[\"这样会更加方便一些\",{\"1\":{\"647\":1}}],[\"这样会节省很多的时间\",{\"1\":{\"615\":1}}],[\"这样会先按照列名1进行排序\",{\"1\":{\"581\":1}}],[\"这样会把\",{\"1\":{\"84\":1}}],[\"这样才能去估计相应的qπ​\",{\"1\":{\"458\":1}}],[\"这样解决了缓冲区存在\",{\"1\":{\"374\":1}}],[\"这样有一个缺点\",{\"1\":{\"346\":1}}],[\"这样其他模块才能导入\",{\"1\":{\"308\":2}}],[\"这样进行比较也行\",{\"1\":{\"294\":1}}],[\"这样我们的控制台也可以看到对应的名称\",{\"1\":{\"778\":1}}],[\"这样我们就成功地添加了一个过滤器\",{\"1\":{\"919\":1}}],[\"这样我们就不用显式进行空值检测\",{\"1\":{\"355\":1}}],[\"这样我们就可以获取到自增后的值了\",{\"1\":{\"679\":1}}],[\"这样我们就可以成功实现多对一查询了\",{\"1\":{\"672\":1}}],[\"这样我们就可以正常使用了\",{\"1\":{\"311\":1}}],[\"这样我们就可以根据不同的类型进行选择了\",{\"1\":{\"281\":1}}],[\"这样我们之前写的java\",{\"1\":{\"306\":1}}],[\"这样我们在遍历\",{\"1\":{\"61\":1}}],[\"这样参数名称所表示的就是一个数组\",{\"1\":{\"241\":1}}],[\"这样是不能赋值的\",{\"1\":{\"238\":1}}],[\"这样就消除了传递依赖\",{\"1\":{\"555\":1}}],[\"这样就会给我们省去很多的时间\",{\"1\":{\"876\":1}}],[\"这样就会占用资源\",{\"1\":{\"538\":1}}],[\"这样就会导致我们可能只用到一部分内容\",{\"1\":{\"303\":1}}],[\"这样就可以追踪到底是哪一个浏览器在访问服务器\",{\"1\":{\"912\":1}}],[\"这样就可以直接访问到了\",{\"1\":{\"864\":1}}],[\"这样就可以通过配置文件的形式修改一些功能的默认属性了\",{\"1\":{\"756\":1}}],[\"这样就可以与\",{\"1\":{\"485\":1}}],[\"这样就可以正常继承了\",{\"1\":{\"347\":1}}],[\"这样就显得非常灵活了\",{\"1\":{\"347\":1}}],[\"这样就仿造了静态方法时的情况\",{\"1\":{\"295\":1}}],[\"这样就万事具备了\",{\"1\":{\"289\":1}}],[\"这样就是一个实现\",{\"1\":{\"255\":1}}],[\"这样就不用再去用那么多的转义字符了\",{\"1\":{\"341\":1}}],[\"这样就不会了\",{\"1\":{\"320\":1}}],[\"这样就不会得到同一个对象了\",{\"1\":{\"227\":1}}],[\"这样就不同\",{\"1\":{\"244\":1}}],[\"这样就无需再将代码写在本地\",{\"1\":{\"199\":1}}],[\"这样\",{\"1\":{\"206\":1,\"297\":1,\"455\":1,\"584\":1,\"649\":1,\"768\":1,\"793\":1,\"802\":2,\"827\":1,\"899\":1}}],[\"这样不断的循环\",{\"1\":{\"174\":1}}],[\"这样不仅代码量大幅度减少\",{\"1\":{\"71\":1}}],[\"这样的类加载机制\",{\"1\":{\"926\":1}}],[\"这样的话\",{\"1\":{\"878\":1,\"926\":1}}],[\"这样的话相当于直接从内存中获取而不是再去向数据库索要数据\",{\"1\":{\"699\":1}}],[\"这样的方式也能注册servlet\",{\"1\":{\"871\":1}}],[\"这样的任务称为episodic\",{\"1\":{\"393\":1}}],[\"这样的写法终于可以编译通过了\",{\"1\":{\"323\":1}}],[\"这样的写法称为装饰者模式\",{\"1\":{\"107\":1}}],[\"这样的数字分数\",{\"1\":{\"280\":1}}],[\"这样的异常称为运行时异常\",{\"1\":{\"264\":1}}],[\"这样的\",{\"1\":{\"238\":1}}],[\"这样的做法虽然简单粗暴\",{\"1\":{\"144\":1}}],[\"这样保存的元素数量就会存在限制\",{\"1\":{\"58\":1}}],[\"这样做是为了更加明确方法的具体功能\",{\"1\":{\"24\":1}}],[\"这些断言操作基本上都是用于判断某个测试结果是否符合我们的预期情况\",{\"1\":{\"785\":1}}],[\"这些都可以通过单元测试来完成\",{\"1\":{\"773\":1}}],[\"这些都是大佬写出来的\",{\"1\":{\"60\":1}}],[\"这些注解并不能像之前xml那样直接修改一些属性\",{\"1\":{\"714\":1}}],[\"这些操作相比查询操作来说非常简单就可以实现\",{\"1\":{\"681\":1}}],[\"这些方法默认情况下返回的结果都是int类型的\",{\"1\":{\"677\":1}}],[\"这些方法并没有被重写\",{\"1\":{\"236\":1}}],[\"这些数据库操作语句就可以构成一个事务\",{\"1\":{\"599\":1}}],[\"这些数据被存放在结构化的数据表里\",{\"1\":{\"549\":1}}],[\"这些特征也称为实体的一种属性\",{\"1\":{\"550\":1}}],[\"这些可以省\",{\"1\":{\"219\":1}}],[\"这些映射关系被存储为键值对\",{\"1\":{\"56\":1}}],[\"这些是新的容量和扩容阈值\",{\"1\":{\"60\":1}}],[\"这些是list的特殊转换\",{\"1\":{\"24\":1}}],[\"这些是list的专用迭代器\",{\"1\":{\"24\":1}}],[\"这些是list中独特的搜索操作\",{\"1\":{\"24\":1}}],[\"这些是list中独特的位置直接访问操作\",{\"1\":{\"24\":1}}],[\"这些是比较以及哈希计算相关的操作\",{\"1\":{\"23\":1}}],[\"这些是批量执行的操作\",{\"1\":{\"23\":1}}],[\"这些是修改相关的操作\",{\"1\":{\"23\":1}}],[\"这些是查询相关的操作\",{\"1\":{\"23\":1}}],[\"这种父子关系类似于继承\",{\"1\":{\"744\":1}}],[\"这种格式有助于程序的日志读取\",{\"1\":{\"737\":1}}],[\"这种迭代算法称为\",{\"1\":{\"436\":1}}],[\"这种迭代器因为能够双向遍历\",{\"1\":{\"37\":1}}],[\"这种方式创建的列表\",{\"1\":{\"371\":1}}],[\"这种全新的语法\",{\"1\":{\"340\":1}}],[\"这种全新的switch语法称为switch表达式\",{\"1\":{\"340\":1}}],[\"这种类型推断仅仅发生在编译期间\",{\"1\":{\"328\":1}}],[\"这种写法就有点像kotlin或是js中的语法\",{\"1\":{\"323\":1}}],[\"这种时候就需要做兼容了\",{\"1\":{\"306\":1}}],[\"这种形式也可以\",{\"1\":{\"281\":1}}],[\"这种局部内部类的形式\",{\"1\":{\"253\":1}}],[\"这种即可\",{\"1\":{\"219\":1}}],[\"这种动态获取信息及动态调用对象方法的功能叫java的反射机制\",{\"1\":{\"179\":1}}],[\"这种语法只支持实现了autocloseable接口的类\",{\"1\":{\"90\":2}}],[\"这种风格将要处理的元素集合看作一种流\",{\"1\":{\"71\":1}}],[\"这种情况我们将\",{\"1\":{\"526\":1}}],[\"这种情况是可以简化的\",{\"1\":{\"257\":1}}],[\"这种情况实际上会被优化为下面的写法\",{\"1\":{\"245\":1}}],[\"这种情况不用扩了\",{\"1\":{\"60\":1}}],[\"这种情况就是哈希冲突了\",{\"1\":{\"59\":1}}],[\"这种情况下的\",{\"1\":{\"526\":1}}],[\"这种情况下就很容易出问题\",{\"1\":{\"173\":1}}],[\"这种情况下\",{\"1\":{\"25\":1}}],[\"这种集合类型比较特殊\",{\"1\":{\"47\":1}}],[\"这是日志级别中倒数第二大的\",{\"1\":{\"727\":1}}],[\"这是在开始之前必须要掌握的内容\",{\"1\":{\"636\":1}}],[\"这是一种特殊的语言\",{\"1\":{\"561\":1}}],[\"这是一个无限制的流\",{\"1\":{\"71\":1}}],[\"这是我们所求的量\",{\"1\":{\"510\":1}}],[\"这是来求解\",{\"1\":{\"453\":1}}],[\"这是抽象方法\",{\"1\":{\"353\":1}}],[\"这是为了提升效率\",{\"1\":{\"227\":1}}],[\"这是浅拷贝\",{\"1\":{\"220\":1}}],[\"这是强制要求的\",{\"1\":{\"218\":1}}],[\"这是因为java代码编译后形参名称无法保留\",{\"1\":{\"660\":1}}],[\"这是因为数据库字段名称与类中字段名称不匹配导致的\",{\"1\":{\"652\":1}}],[\"这是因为此用户还没有权限\",{\"1\":{\"590\":1}}],[\"这是因为\",{\"1\":{\"227\":1,\"718\":1}}],[\"这是因为timer内存维护了一个任务队列和一个工作线程\",{\"1\":{\"167\":1}}],[\"这是因为集合类在删除元素时\",{\"1\":{\"25\":1}}],[\"这是arraylist的其中一个构造方法\",{\"1\":{\"25\":1}}],[\"这个类完善了配置文件读取和servlet信息相关的的操作\",{\"1\":{\"876\":1}}],[\"这个类在初始化时会对类中其他本地方法进行注册\",{\"1\":{\"215\":1}}],[\"这个时候就需要我们在网页展示时向后端发起请求\",{\"1\":{\"893\":1}}],[\"这个时候我们就可以通过排除依赖来防止添加不必要的依赖\",{\"1\":{\"843\":1}}],[\"这个时候如果阈值大于0\",{\"1\":{\"60\":1}}],[\"这个rootlogger对象为所有日志记录器的最顶层父级对象\",{\"1\":{\"744\":1}}],[\"这个实现类是由mybatis根据我们的配置自动生成的\",{\"1\":{\"659\":1}}],[\"这个数据库表中存在如下决定关系\",{\"1\":{\"556\":1}}],[\"这个仍然与之前一致\",{\"1\":{\"453\":1}}],[\"这个\",{\"1\":{\"452\":1}}],[\"这个便成为\",{\"1\":{\"397\":1}}],[\"这个是服务端的响应内容\",{\"1\":{\"875\":1}}],[\"这个是tomcat的一些文档\",{\"1\":{\"864\":1}}],[\"这个是源源不断的\",{\"1\":{\"321\":1}}],[\"这个是内部接口entry\",{\"1\":{\"56\":1}}],[\"这个参数就是异常的原因\",{\"1\":{\"265\":1}}],[\"这个抽象类直接就定义好了\",{\"1\":{\"255\":1}}],[\"这个长度是字符的数量\",{\"1\":{\"244\":1}}],[\"这个接口中什么都没定义\",{\"1\":{\"220\":1}}],[\"这个默认方法没有任何作用\",{\"1\":{\"219\":1}}],[\"这个注解默认情况下可以省略\",{\"1\":{\"216\":1}}],[\"这个我们会在最后一章的反射中进行讲解\",{\"1\":{\"215\":1}}],[\"这个工具类也经常被使用到\",{\"1\":{\"80\":1}}],[\"这个东西决定了hashmap的扩容效果\",{\"1\":{\"58\":1}}],[\"这个就是哈希表本体了\",{\"1\":{\"58\":1}}],[\"这个需要我们学习了map之后再来讨论\",{\"1\":{\"48\":1}}],[\"这个同样是删除指定元素\",{\"1\":{\"47\":1}}],[\"这个迭代器也是单向的\",{\"1\":{\"44\":1}}],[\"这个迭代器是针对于list的强化版本\",{\"1\":{\"37\":1}}],[\"这个效果跟上面的写法是完全一样的\",{\"1\":{\"35\":1}}],[\"这个方法是一个静态方法\",{\"1\":{\"292\":1}}],[\"这个方法是在\",{\"1\":{\"35\":1}}],[\"这个方法我们会在jvm篇视频教程中详细介绍\",{\"1\":{\"215\":1}}],[\"这个方法我们同样会放到多线程中进行介绍\",{\"1\":{\"47\":1}}],[\"这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量\",{\"1\":{\"91\":1}}],[\"这个方法会在多线程部分中进行介绍\",{\"1\":{\"36\":1}}],[\"这个方法会在执行排序时被调用\",{\"1\":{\"14\":1}}],[\"这个方法接受一个consumer\",{\"1\":{\"35\":1}}],[\"这个生成的list是只读的\",{\"1\":{\"25\":1}}],[\"这个套娃是可以一直套下去的\",{\"1\":{\"25\":1}}],[\"这个只做了解就行\",{\"1\":{\"25\":1}}],[\"这个操作并不是一定会添加成功\",{\"1\":{\"23\":1}}],[\"这里表示匹配所有请求\",{\"1\":{\"919\":1}}],[\"这里暂时不提及\",{\"1\":{\"864\":1}}],[\"这里只需要包括一个script标签我们就能像之前xml那样编写动态sql了\",{\"1\":{\"719\":1}}],[\"这里只是对两个对象进行equals判断\",{\"1\":{\"25\":1}}],[\"这里就暂时先介绍这么多\",{\"1\":{\"682\":1}}],[\"这里就不再演示了\",{\"1\":{\"835\":1}}],[\"这里就不再介绍了\",{\"1\":{\"586\":1}}],[\"这里就不做演示了\",{\"1\":{\"864\":1}}],[\"这里就不做详细介绍了\",{\"1\":{\"812\":1}}],[\"这里就不做介绍了\",{\"1\":{\"323\":1}}],[\"这里就不挨个介绍了\",{\"1\":{\"790\":1}}],[\"这里就不多做介绍了\",{\"1\":{\"681\":1}}],[\"这里就不多说了\",{\"1\":{\"323\":1}}],[\"这里就不提了\",{\"1\":{\"328\":1}}],[\"这里就不解释了\",{\"1\":{\"60\":1}}],[\"这里就不列出了\",{\"1\":{\"44\":1}}],[\"这里usegeneratedkeys设置为true表示我们希望获取数据库生成的键\",{\"1\":{\"679\":1}}],[\"这里id实际上就是param1\",{\"1\":{\"660\":1}}],[\"这里调用我们编写的接口方法\",{\"1\":{\"659\":1}}],[\"这里建议将对应的xml配置也放到放到同包中\",{\"1\":{\"659\":1}}],[\"这里截取部分mybatis源代码进行演示\",{\"1\":{\"658\":1}}],[\"这里有一个rowbounds参数\",{\"1\":{\"652\":1}}],[\"这里有多种mobility\",{\"1\":{\"388\":1}}],[\"这里也可以使用<id>标签\",{\"1\":{\"652\":1}}],[\"这里可以用不同的方法来近似\",{\"1\":{\"530\":1}}],[\"这里在视频没有详细介绍\",{\"1\":{\"529\":1}}],[\"这里包含了一个\",{\"1\":{\"510\":1}}],[\"这里\",{\"1\":{\"440\":1}}],[\"这里采用离散化空间坐标\",{\"1\":{\"387\":1}}],[\"这里和之前的switch语句是一样的\",{\"1\":{\"340\":1}}],[\"这里以输入流的方式获取\",{\"1\":{\"333\":1}}],[\"这里打印一下看看网页\",{\"1\":{\"333\":1}}],[\"这里虽然是有了var关键字进行自动类型推断\",{\"1\":{\"328\":1}}],[\"这里类型写为string\",{\"1\":{\"323\":1}}],[\"这里限制生成20个\",{\"1\":{\"321\":1}}],[\"这里新增的是允许结束迭代的\",{\"1\":{\"321\":1}}],[\"这里不进行介绍\",{\"1\":{\"652\":1}}],[\"这里不是指进行io操作的流\",{\"1\":{\"319\":1}}],[\"这里不讲解原理\",{\"1\":{\"173\":1}}],[\"这里添加一个模块的依赖\",{\"1\":{\"308\":1}}],[\"这里t可以是任何类型\",{\"1\":{\"281\":1}}],[\"这里发生的是数组越界异常\",{\"1\":{\"267\":1}}],[\"这里仅仅是对正则表达式的简单使用\",{\"1\":{\"246\":1}}],[\"这里字符串是oooo\",{\"1\":{\"246\":1}}],[\"这里进行4次加法运算\",{\"1\":{\"245\":1}}],[\"这里ceiling表示向上取整\",{\"1\":{\"229\":1}}],[\"这里会明确指出是哪一个变量调用出现了空指针\",{\"1\":{\"343\":1}}],[\"这里会有一个integercache\",{\"1\":{\"227\":1}}],[\"这里会判断容量是否充足\",{\"1\":{\"25\":1}}],[\"这里本质上就是被自动包装成了一个integer类型的对象\",{\"1\":{\"227\":1}}],[\"这里使用filehandler类型\",{\"1\":{\"737\":1}}],[\"这里使用gid作为分组id的逻辑外键\",{\"1\":{\"672\":1}}],[\"这里使用javap命令对class文件进行反编译得到\",{\"1\":{\"221\":1}}],[\"这里使用的是list的迭代器在进行遍历操作\",{\"1\":{\"30\":1}}],[\"这里向上抛出一下异常\",{\"1\":{\"220\":1}}],[\"这里要获取field类的modifiers字段进行修改\",{\"1\":{\"193\":1}}],[\"这里变成ioexception是因为调用close\",{\"1\":{\"90\":1}}],[\"这里因为本来就是integer\",{\"1\":{\"71\":1}}],[\"这里返回m\",{\"1\":{\"64\":1}}],[\"这里返回原来的value+m\",{\"1\":{\"64\":2}}],[\"这里多了一个指向前一个结点和后一个结点的引用\",{\"1\":{\"61\":1}}],[\"这里直接创建一个新的consolehandler对象\",{\"1\":{\"736\":1}}],[\"这里直接设定为控制台输出\",{\"1\":{\"606\":1}}],[\"这里直接将待插入结点等于原本冲突的结点\",{\"1\":{\"59\":1}}],[\"这里直接o2\",{\"1\":{\"14\":1}}],[\"这里计算完键的哈希值之后\",{\"1\":{\"59\":1}}],[\"这里用的是url\",{\"1\":{\"643\":1}}],[\"这里用的是内部类entry在表示\",{\"1\":{\"56\":1}}],[\"这里用到了迭代器\",{\"1\":{\"23\":1}}],[\"这里需要用到insert标签\",{\"1\":{\"678\":1}}],[\"这里需要通过迭代算法来精确求出\",{\"1\":{\"444\":1}}],[\"这里需要特别说一下\",{\"1\":{\"238\":1}}],[\"这里需要特别注意\",{\"1\":{\"9\":1}}],[\"这里需要填写两个泛型参数\",{\"1\":{\"56\":1}}],[\"这里需要介绍一下优先级队列\",{\"1\":{\"46\":1}}],[\"这里做了解就行了\",{\"1\":{\"45\":1}}],[\"这里随便写的\",{\"1\":{\"36\":1}}],[\"这里我们创建一个用于测试的简单项目\",{\"1\":{\"840\":1}}],[\"这里我们创建一个新的项目\",{\"1\":{\"304\":1}}],[\"这里我们来测试一下junit\",{\"1\":{\"834\":1}}],[\"这里我们使用\",{\"1\":{\"808\":1}}],[\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",{\"1\":{\"690\":1}}],[\"这里我们尝试新建一个类用于单元测试\",{\"1\":{\"776\":1}}],[\"这里我们打印一下系统名称和版本\",{\"1\":{\"755\":1}}],[\"这里我们会得到一个\",{\"1\":{\"744\":1}}],[\"这里我们先暂时不介绍继承关系\",{\"1\":{\"735\":1}}],[\"这里我们不如再做的更加极致一点\",{\"1\":{\"721\":1}}],[\"这里我们连续获取了两次id为1的用户\",{\"1\":{\"700\":1}}],[\"这里我们连续插入两个同样的字符串\",{\"1\":{\"48\":1}}],[\"这里我们将parametertype类型设置为我们的实体类型\",{\"1\":{\"678\":1}}],[\"这里我们将com\",{\"1\":{\"307\":2}}],[\"这里我们让user左连接到book表中\",{\"1\":{\"670\":1}}],[\"这里我们让age在赋值时增加一次\",{\"1\":{\"658\":1}}],[\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息\",{\"1\":{\"668\":1}}],[\"这里我们直接使用左连接\",{\"1\":{\"667\":1}}],[\"这里我们在resultmap标签中配置了一些result标签\",{\"1\":{\"652\":1}}],[\"这里我们填写刚刚的id\",{\"1\":{\"649\":1}}],[\"这里我们按照规律\",{\"1\":{\"333\":1}}],[\"这里我们选择ofstring直接响应实体转换为string字符串\",{\"1\":{\"333\":1}}],[\"这里我们选择使用父类的带参构造\",{\"1\":{\"265\":1}}],[\"这里我们写一个泛型类\",{\"1\":{\"323\":1}}],[\"这里我们可以直接尝试进行事务的提交\",{\"1\":{\"682\":1}}],[\"这里我们可以直接将一些元素封装到stream中\",{\"1\":{\"319\":1}}],[\"这里我们可以自由传入任意数量的字符串\",{\"1\":{\"241\":1}}],[\"这里我们就来创建两个项目\",{\"1\":{\"307\":1}}],[\"这里我们就简单将i转换为字符串形式\",{\"1\":{\"290\":1}}],[\"这里我们通过反射来获取string类中的value字段\",{\"1\":{\"305\":1}}],[\"这里我们导入java\",{\"1\":{\"304\":1}}],[\"这里我们需要修改一下user表来记录每一个用户所属的小组id\",{\"1\":{\"672\":1}}],[\"这里我们需要在mybatis配置文件中添加\",{\"1\":{\"669\":1}}],[\"这里我们需要使用selectlist方法来执行\",{\"1\":{\"653\":1}}],[\"这里我们需要根据用户id查询\",{\"1\":{\"648\":1}}],[\"这里我们需要特别注意一下\",{\"1\":{\"251\":1}}],[\"这里我们需进行模块导入\",{\"1\":{\"304\":1}}],[\"这里我们拋个异常看看\",{\"1\":{\"289\":1}}],[\"这里我们定义一个test注解\",{\"1\":{\"206\":1}}],[\"这里我们定义一个info静态变量\",{\"1\":{\"117\":1}}],[\"这里我们随便写一个类\",{\"1\":{\"36\":1}}],[\"这里我们接着介绍另一个列表实现类\",{\"1\":{\"25\":1}}],[\"这里同样是进行取余操作\",{\"1\":{\"59\":1}}],[\"这里同样只需要一个comparator就行了\",{\"1\":{\"24\":1}}],[\"这里同样用到了迭代器\",{\"1\":{\"24\":1}}],[\"这里传入的类型是什么\",{\"1\":{\"14\":1}}],[\"这里是每个无人机都有一张自己的q\",{\"1\":{\"387\":1}}],[\"这里是求和\",{\"1\":{\"71\":1}}],[\"这里是倒着往回遍历\",{\"1\":{\"37\":1}}],[\"这里是\",{\"1\":{\"9\":1}}],[\"这里没有使用this\",{\"1\":{\"7\":1}}],[\"这里实际上是将方法参数的局部变量name赋值为本身\",{\"1\":{\"7\":1}}],[\"这里编写代码跟我们之前在main中是一样的\",{\"1\":{\"5\":1}}],[\"这里的初始化参数仅仅是针对于此servlet\",{\"1\":{\"903\":1}}],[\"这里的snapshot代表快照\",{\"1\":{\"820\":1}}],[\"这里的查询操作实际上只进行了一次\",{\"1\":{\"700\":1}}],[\"这里的参数我们依然选择使用user\",{\"1\":{\"680\":1}}],[\"这里的column和javatype可以不填\",{\"1\":{\"667\":1}}],[\"这里的id与用户id一致\",{\"1\":{\"666\":1}}],[\"这里的i就是最终得到的下标位置了\",{\"1\":{\"59\":1}}],[\"这里的object就是刚刚构造好的实体类对象\",{\"1\":{\"658\":1}}],[\"这里的策略是随机性\",{\"1\":{\"529\":1}}],[\"这里的最优策略πk+1​是一个\",{\"1\":{\"437\":1}}],[\"这里的name是其所依附对象的\",{\"1\":{\"251\":1}}],[\"这里的话只能使用接口中的方法\",{\"1\":{\"219\":1}}],[\"这里的\",{\"1\":{\"80\":1,\"713\":1,\"808\":1}}],[\"这里的transient关键字我们会在后面i\",{\"1\":{\"25\":1}}],[\"这里的p1存放的是对象的引用\",{\"1\":{\"4\":1}}],[\"这里的a存放的是具体的某个值\",{\"1\":{\"4\":1}}],[\"这里定义的人类具有三个属性\",{\"1\":{\"4\":1}}],[\"ognl\",{\"1\":{\"690\":1}}],[\"our\",{\"1\":{\"606\":1}}],[\"outer>\",{\"1\":{\"634\":1}}],[\"outside\",{\"1\":{\"606\":1}}],[\"outofmemoryerror\",{\"1\":{\"264\":1}}],[\"out也是printstream\",{\"1\":{\"127\":1}}],[\"out就是一个printstream\",{\"1\":{\"127\":2}}],[\"output\",{\"1\":{\"92\":2,\"93\":1,\"94\":1,\"97\":1,\"113\":1,\"129\":1,\"131\":2,\"133\":2}}],[\"outputstreamwriter\",{\"1\":{\"126\":3,\"537\":4,\"544\":2}}],[\"outputstream\",{\"1\":{\"88\":1,\"92\":6,\"93\":3,\"94\":2,\"131\":3,\"133\":3,\"537\":2,\"543\":1,\"891\":5}}],[\"out\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"237\":2,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":2,\"275\":1,\"281\":1,\"288\":1,\"289\":1,\"292\":2,\"294\":2,\"295\":1,\"297\":6,\"304\":1,\"305\":1,\"307\":1,\"317\":3,\"318\":2,\"319\":1,\"320\":2,\"321\":2,\"322\":2,\"323\":6,\"328\":1,\"331\":6,\"333\":3,\"340\":1,\"343\":1,\"344\":1,\"347\":1,\"353\":1,\"354\":2,\"355\":3,\"358\":1,\"361\":1,\"362\":1,\"364\":4,\"365\":5,\"374\":1,\"536\":6,\"537\":9,\"538\":1,\"543\":1,\"544\":6,\"605\":1,\"606\":1,\"613\":1,\"616\":1,\"621\":1,\"622\":2,\"636\":1,\"643\":1,\"647\":1,\"649\":1,\"650\":1,\"651\":1,\"653\":3,\"658\":1,\"659\":2,\"660\":1,\"682\":2,\"700\":6,\"701\":2,\"705\":1,\"714\":1,\"735\":1,\"744\":2,\"747\":3,\"754\":1,\"755\":2,\"761\":3,\"767\":2,\"773\":4,\"790\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":2,\"797\":1,\"802\":3,\"803\":3,\"804\":3,\"805\":5,\"810\":2,\"811\":1,\"812\":2,\"825\":1,\"834\":2,\"840\":1,\"852\":1,\"874\":4,\"886\":1,\"889\":1,\"900\":1,\"901\":1,\"902\":1,\"903\":1,\"908\":1,\"919\":1,\"920\":5,\"922\":1}}],[\"owner或db\",{\"1\":{\"561\":1}}],[\"os\",{\"1\":{\"544\":1,\"755\":2,\"793\":3,\"796\":1}}],[\"o流进行网络数据传输\",{\"1\":{\"537\":1}}],[\"otherwise>\",{\"1\":{\"691\":1}}],[\"other\",{\"1\":{\"427\":1}}],[\"onclick=\",{\"1\":{\"893\":1}}],[\"onreadystatechange\",{\"1\":{\"893\":1}}],[\"only\",{\"1\":{\"864\":1}}],[\"onlyifabsent\",{\"1\":{\"59\":2}}],[\"onwards\",{\"1\":{\"864\":1}}],[\"one和\",{\"1\":{\"718\":1}}],[\"one\",{\"1\":{\"718\":2}}],[\"on进行左连接\",{\"1\":{\"586\":1}}],[\"on进行内连接\",{\"1\":{\"586\":1}}],[\"on\",{\"0\":{\"495\":1,\"496\":1,\"500\":1},\"1\":{\"352\":1,\"377\":1,\"497\":1,\"498\":1,\"514\":1,\"518\":1,\"586\":3,\"591\":2,\"597\":2,\"598\":1,\"667\":1,\"670\":1,\"672\":2},\"2\":{\"390\":1}}],[\"origin\",{\"1\":{\"908\":1,\"913\":1}}],[\"originalepisode\",{\"1\":{\"455\":1}}],[\"original\",{\"1\":{\"296\":4,\"606\":1}}],[\"ordinary\",{\"1\":{\"633\":1}}],[\"order注释指定的值对测试方法进行数值排序\",{\"1\":{\"804\":1}}],[\"orderannotation\",{\"1\":{\"804\":1}}],[\"order\",{\"1\":{\"581\":2,\"804\":1}}],[\"org\",{\"1\":{\"628\":1,\"641\":3,\"643\":2,\"658\":2,\"660\":2,\"690\":1,\"719\":1,\"812\":1,\"819\":4,\"834\":2,\"840\":4,\"849\":4,\"864\":1,\"888\":2}}],[\"oracle\",{\"1\":{\"549\":1}}],[\"or\",{\"1\":{\"323\":1,\"393\":1,\"414\":1,\"466\":1,\"486\":1,\"509\":1,\"580\":1,\"621\":2,\"622\":1,\"864\":2,\"876\":1,\"921\":1}}],[\"orelse表示如果为空就返回里面的内容\",{\"1\":{\"297\":1}}],[\"orelse\",{\"1\":{\"297\":1,\"355\":2,\"364\":2}}],[\"option来进行配置\",{\"1\":{\"720\":1}}],[\"options来控制单个操作的缓存启用\",{\"1\":{\"720\":1}}],[\"options\",{\"1\":{\"714\":1,\"720\":2,\"876\":1}}],[\"options注解\",{\"1\":{\"714\":1}}],[\"option是指当创建后\",{\"1\":{\"596\":1}}],[\"option\",{\"1\":{\"591\":2,\"596\":1}}],[\"optional>\",{\"1\":{\"842\":4}}],[\"optional1\",{\"1\":{\"364\":2}}],[\"optional<t>\",{\"1\":{\"364\":1}}],[\"optional<integer>\",{\"1\":{\"355\":4,\"364\":2}}],[\"optional提供很多有用的方法\",{\"1\":{\"355\":1}}],[\"optional\",{\"1\":{\"297\":4,\"323\":4,\"355\":11,\"364\":3,\"832\":1}}],[\"optional来了\",{\"1\":{\"297\":1}}],[\"optional类\",{\"0\":{\"297\":1}}],[\"optimization\",{\"0\":{\"510\":1},\"1\":{\"466\":1}}],[\"optimality\",{\"0\":{\"428\":1},\"1\":{\"426\":1,\"493\":1}}],[\"optimal\",{\"0\":{\"427\":1,\"493\":1},\"1\":{\"426\":2,\"427\":1,\"494\":1}}],[\"opinion\",{\"1\":{\"379\":1}}],[\"open和close用于控制起始和结束位置添加的符号\",{\"1\":{\"693\":1}}],[\"open=\",{\"1\":{\"693\":1}}],[\"opening\",{\"1\":{\"669\":1}}],[\"opensession\",{\"1\":{\"641\":1,\"643\":1,\"647\":1,\"659\":1,\"682\":2,\"688\":1,\"700\":2,\"834\":1,\"889\":1,\"910\":1}}],[\"opens\",{\"1\":{\"309\":2}}],[\"open\",{\"1\":{\"309\":1,\"310\":1,\"893\":1}}],[\"operation\",{\"1\":{\"71\":2,\"352\":11}}],[\"operator\",{\"1\":{\"24\":3}}],[\"o+\",{\"1\":{\"246\":2}}],[\"oooo\",{\"1\":{\"246\":1}}],[\"obtainvia来指定默认值的获取方式\",{\"1\":{\"629\":1}}],[\"obtained\",{\"1\":{\"415\":1}}],[\"obejctive\",{\"0\":{\"507\":1},\"1\":{\"510\":1}}],[\"obj\",{\"1\":{\"199\":5,\"215\":2,\"216\":4,\"235\":1,\"340\":2,\"342\":5}}],[\"objective\",{\"1\":{\"508\":2,\"509\":1,\"515\":1,\"516\":1,\"522\":1}}],[\"objectinputstream\",{\"1\":{\"131\":2,\"133\":2}}],[\"object类中的\",{\"0\":{\"220\":1}}],[\"objectoutputstream\",{\"1\":{\"131\":2,\"133\":2}}],[\"objectoutputstream不仅支持基本数据类型\",{\"1\":{\"130\":1}}],[\"object>\",{\"1\":{\"67\":1,\"650\":1,\"660\":1,\"754\":1}}],[\"objects\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1,\"84\":3,\"352\":1}}],[\"object\",{\"0\":{\"215\":1},\"1\":{\"15\":2,\"16\":2,\"23\":4,\"24\":4,\"25\":3,\"44\":2,\"47\":4,\"56\":5,\"67\":2,\"84\":4,\"139\":2,\"156\":4,\"161\":3,\"174\":1,\"183\":1,\"192\":3,\"199\":2,\"215\":4,\"216\":3,\"219\":2,\"220\":1,\"235\":1,\"236\":1,\"238\":5,\"264\":1,\"266\":2,\"267\":3,\"280\":4,\"281\":5,\"342\":2,\"616\":6,\"633\":1,\"658\":5,\"677\":3,\"876\":2}}],[\"obsolete\",{\"1\":{\"167\":2}}],[\"oftype=\",{\"1\":{\"670\":1,\"671\":1}}],[\"of是java9的特性\",{\"1\":{\"651\":1}}],[\"off\",{\"0\":{\"403\":1,\"405\":1,\"495\":1,\"497\":1,\"499\":1},\"1\":{\"497\":1,\"498\":1,\"729\":2}}],[\"offerlast\",{\"1\":{\"44\":1}}],[\"offerfirst\",{\"1\":{\"44\":1}}],[\"offer\",{\"1\":{\"43\":3,\"46\":6,\"174\":1}}],[\"ofinputstream\",{\"1\":{\"333\":1}}],[\"ofstring\",{\"1\":{\"333\":2}}],[\"of方法还被重载了很多次\",{\"1\":{\"318\":1}}],[\"ofnullable\",{\"1\":{\"297\":4,\"320\":1,\"323\":3,\"355\":2}}],[\"of\",{\"0\":{\"384\":1,\"417\":1,\"418\":1,\"485\":1,\"489\":1,\"493\":1,\"506\":1},\"1\":{\"139\":1,\"318\":3,\"319\":1,\"320\":1,\"323\":1,\"352\":1,\"355\":2,\"359\":3,\"371\":6,\"378\":3,\"384\":1,\"393\":4,\"394\":3,\"414\":1,\"415\":1,\"419\":2,\"432\":1,\"449\":1,\"455\":1,\"456\":1,\"466\":1,\"473\":1,\"493\":1,\"509\":1,\"516\":1,\"605\":1,\"606\":1,\"651\":1,\"660\":1,\"688\":1,\"693\":1,\"694\":1,\"811\":1,\"812\":2,\"864\":1}}],[\"o操作一般不能重复读取内容\",{\"1\":{\"108\":1}}],[\"o操作的并不是bufferedinputstream\",{\"1\":{\"107\":1}}],[\"o操作时\",{\"1\":{\"91\":1}}],[\"o设备的速度一般都达不到内存的读取速度\",{\"1\":{\"103\":1}}],[\"o设备去获取数据\",{\"1\":{\"103\":1}}],[\"oject类中的\",{\"1\":{\"84\":1}}],[\"oldthr\",{\"1\":{\"60\":4}}],[\"oldtab\",{\"1\":{\"60\":5}}],[\"oldcap\",{\"1\":{\"60\":5}}],[\"oldcapacity\",{\"1\":{\"25\":3}}],[\"oldvalue\",{\"1\":{\"59\":3}}],[\"o中介绍用途\",{\"1\":{\"25\":1}}],[\"o\",{\"1\":{\"15\":2,\"23\":3,\"24\":2,\"25\":3,\"44\":2,\"47\":3,\"56\":1,\"84\":10,\"246\":15,\"281\":1}}],[\"o2作为参数\",{\"1\":{\"294\":1}}],[\"o2\",{\"1\":{\"14\":5,\"156\":3,\"292\":2,\"294\":4}}],[\"o1作为目标对象\",{\"1\":{\"294\":1}}],[\"o1就行\",{\"1\":{\"14\":1}}],[\"o1\",{\"1\":{\"14\":5,\"156\":3,\"161\":5,\"292\":2,\"294\":4}}],[\"override表示重写父类方法\",{\"1\":{\"203\":1}}],[\"override\",{\"1\":{\"14\":2,\"23\":1,\"36\":3,\"47\":1,\"84\":3,\"166\":1,\"167\":1,\"204\":1,\"206\":1,\"216\":3,\"218\":1,\"219\":1,\"220\":2,\"255\":2,\"256\":1,\"266\":1,\"282\":2,\"288\":1,\"292\":1,\"294\":1,\"307\":1,\"323\":1,\"342\":2,\"344\":1,\"366\":1,\"761\":2,\"871\":5,\"874\":1,\"876\":1,\"881\":2,\"886\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":1,\"920\":3,\"921\":1,\"922\":1}}],[\"8<\",{\"1\":{\"819\":1}}],[\"8月\",{\"1\":{\"736\":1,\"746\":2}}],[\"854\",{\"1\":{\"563\":2}}],[\"81\",{\"1\":{\"544\":1}}],[\"8192\",{\"1\":{\"538\":1}}],[\"8到java\",{\"1\":{\"337\":1}}],[\"8及之前\",{\"1\":{\"323\":1}}],[\"8就有了\",{\"1\":{\"321\":1}}],[\"8新增的stream\",{\"1\":{\"319\":1}}],[\"8新增方法\",{\"1\":{\"24\":1}}],[\"8中的一个函数式接口\",{\"1\":{\"351\":1}}],[\"8中引入了optional类\",{\"1\":{\"323\":1}}],[\"8中\",{\"1\":{\"317\":1}}],[\"8中新引入了optional特性\",{\"1\":{\"297\":1}}],[\"8以下的编程模式\",{\"1\":{\"306\":1}}],[\"8代码才能正常地在java\",{\"1\":{\"306\":1}}],[\"8也为我们提供了一些内置的函数式接口供我们使用\",{\"1\":{\"296\":1}}],[\"8之后的又一个tls长期维护版本\",{\"1\":{\"329\":1}}],[\"8之后\",{\"1\":{\"289\":1}}],[\"8之前\",{\"1\":{\"288\":1}}],[\"8之前存放在永久代\",{\"1\":{\"180\":1}}],[\"8已经为集合框架中包含的所有数据结构提供了一个默认的spliterator实现\",{\"1\":{\"173\":1}}],[\"89\",{\"1\":{\"65\":1}}],[\"88\",{\"1\":{\"65\":1}}],[\"800\",{\"1\":{\"727\":1}}],[\"807\",{\"1\":{\"563\":1}}],[\"8081\",{\"1\":{\"908\":2,\"913\":2}}],[\"808\",{\"1\":{\"563\":1}}],[\"8080\",{\"1\":{\"536\":3,\"537\":2,\"538\":1,\"543\":2,\"544\":5,\"864\":5,\"910\":1}}],[\"80\",{\"1\":{\"65\":1,\"338\":1}}],[\"8\",{\"0\":{\"946\":1},\"1\":{\"14\":3,\"25\":2,\"71\":1,\"77\":2,\"88\":1,\"204\":1,\"205\":1,\"239\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"338\":1,\"339\":1,\"362\":1,\"371\":2,\"544\":2,\"634\":2,\"641\":1,\"643\":1,\"794\":2,\"795\":1,\"819\":1,\"820\":1,\"834\":2,\"840\":1,\"849\":1,\"850\":2,\"864\":1,\"875\":1,\"876\":1,\"881\":1,\"888\":1,\"889\":1,\"892\":1,\"893\":1,\"908\":3,\"913\":4}}],[\"999\",{\"1\":{\"788\":2}}],[\"99\",{\"1\":{\"544\":1}}],[\"94\",{\"1\":{\"544\":3}}],[\"9+\",{\"1\":{\"371\":1}}],[\"900\",{\"1\":{\"727\":1}}],[\"90\",{\"1\":{\"338\":1}}],[\"9隔了整整三年\",{\"1\":{\"337\":1}}],[\"9开始为半年更新一次\",{\"1\":{\"337\":1}}],[\"9带来的直观改变不是很多\",{\"1\":{\"327\":1}}],[\"9新增了一些更加方便的操作\",{\"1\":{\"323\":1}}],[\"9得到了进一步的增强\",{\"1\":{\"319\":1}}],[\"9之后\",{\"1\":{\"318\":1,\"323\":1}}],[\"9中\",{\"1\":{\"317\":1}}],[\"9为我们通过了一种交互式编程工具jshell\",{\"1\":{\"316\":1}}],[\"9的时候其实就已经引入了全新的http\",{\"1\":{\"332\":1}}],[\"9的多版本jar包支持\",{\"1\":{\"323\":1}}],[\"9的模块新特性\",{\"1\":{\"306\":1}}],[\"9的主要特性有\",{\"1\":{\"301\":1}}],[\"9以及之后的版本下运行\",{\"1\":{\"306\":1}}],[\"9以上的模块项目\",{\"1\":{\"306\":1}}],[\"9引入了模块机制来对这种情况进行优化\",{\"1\":{\"303\":1}}],[\"92\",{\"1\":{\"65\":1,\"280\":1}}],[\"95\",{\"1\":{\"65\":1}}],[\"98\",{\"1\":{\"65\":1}}],[\"9\",{\"0\":{\"933\":1},\"1\":{\"14\":3,\"77\":1,\"173\":2,\"246\":1,\"274\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"305\":1,\"338\":1,\"339\":1,\"371\":1,\"544\":3,\"563\":2,\"908\":2,\"913\":2}}],[\"7478463438252262094l\",{\"1\":{\"921\":1}}],[\"74f6c5d8\",{\"1\":{\"669\":1}}],[\"7<\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"775\",{\"1\":{\"563\":2}}],[\"700\",{\"1\":{\"727\":1}}],[\"70\",{\"1\":{\"338\":2}}],[\"7新增了try\",{\"1\":{\"90\":1}}],[\"72\",{\"1\":{\"65\":1}}],[\"75的hashmap\",{\"1\":{\"67\":1}}],[\"75\",{\"1\":{\"58\":1,\"60\":2,\"280\":1}}],[\"7\",{\"0\":{\"945\":1},\"1\":{\"14\":3,\"204\":1,\"239\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"338\":1,\"339\":1,\"544\":2,\"614\":1,\"682\":1,\"842\":2,\"864\":1,\"908\":2,\"913\":2}}],[\"39\",{\"1\":{\"746\":2}}],[\"37\",{\"1\":{\"725\":1,\"736\":1}}],[\"372\",{\"1\":{\"563\":2}}],[\"3306\",{\"1\":{\"605\":1,\"613\":1,\"721\":1,\"753\":1,\"834\":1}}],[\"32767\",{\"1\":{\"563\":1}}],[\"32768\",{\"1\":{\"563\":1}}],[\"3nf\",{\"0\":{\"555\":1}}],[\"3nf对依赖关系进一步加强\",{\"1\":{\"552\":1}}],[\"36<\",{\"1\":{\"825\":1}}],[\"36\",{\"1\":{\"544\":2,\"908\":2,\"913\":2}}],[\"3d部署和移动问题\",{\"1\":{\"379\":1}}],[\"3d位置进行优化处理\",{\"1\":{\"379\":1}}],[\"30秒内都不需要登陆\",{\"1\":{\"910\":1}}],[\"302\",{\"0\":{\"899\":1},\"1\":{\"899\":2,\"908\":1,\"913\":1}}],[\"304\",{\"1\":{\"876\":1}}],[\"30<\",{\"1\":{\"842\":2}}],[\"300\",{\"1\":{\"727\":1}}],[\"3000\",{\"1\":{\"144\":1,\"165\":2,\"174\":1,\"538\":1,\"705\":1}}],[\"30\",{\"1\":{\"274\":1,\"660\":1,\"910\":2}}],[\"3的结果\",{\"1\":{\"229\":1}}],[\"3\",{\"0\":{\"40\":1,\"41\":1,\"109\":1,\"402\":1,\"403\":1,\"404\":1,\"405\":1,\"406\":2,\"415\":1,\"419\":1,\"421\":1,\"442\":1,\"443\":1,\"444\":1,\"445\":1,\"453\":1,\"457\":1,\"459\":1,\"460\":1,\"461\":1,\"462\":2,\"463\":2,\"472\":1,\"474\":1,\"475\":1,\"476\":1,\"479\":2,\"480\":1,\"488\":1,\"489\":1,\"490\":1,\"491\":1,\"492\":2,\"498\":1,\"513\":1,\"529\":1,\"577\":1,\"941\":1},\"1\":{\"14\":4,\"50\":2,\"57\":2,\"71\":6,\"77\":1,\"78\":1,\"79\":1,\"80\":3,\"173\":2,\"229\":1,\"239\":1,\"240\":1,\"244\":1,\"246\":1,\"274\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"364\":1,\"371\":1,\"436\":2,\"444\":1,\"468\":1,\"471\":1,\"475\":1,\"605\":1,\"616\":1,\"641\":3,\"643\":2,\"690\":1,\"693\":2,\"719\":4,\"791\":1,\"808\":1,\"834\":4,\"888\":2}}],[\"6<\",{\"1\":{\"891\":1}}],[\"64\",{\"1\":{\"864\":1}}],[\"6746\",{\"1\":{\"384\":1}}],[\"666\",{\"1\":{\"228\":1,\"796\":2}}],[\"60000\",{\"1\":{\"701\":1}}],[\"60\",{\"1\":{\"15\":1,\"280\":1,\"338\":2}}],[\"6\",{\"0\":{\"272\":1,\"944\":1},\"1\":{\"14\":3,\"78\":1,\"173\":2,\"240\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"338\":1,\"339\":1,\"364\":2,\"605\":1,\"608\":1,\"908\":1,\"913\":1}}],[\"54\",{\"1\":{\"913\":1}}],[\"57\",{\"1\":{\"746\":2}}],[\"55\",{\"1\":{\"725\":1}}],[\"5555\",{\"1\":{\"228\":1}}],[\"512\",{\"1\":{\"701\":1,\"720\":1}}],[\"537\",{\"1\":{\"544\":2,\"908\":2,\"913\":2}}],[\"5新增了泛型\",{\"1\":{\"280\":1}}],[\"5个变量连续加\",{\"1\":{\"245\":1}}],[\"501\",{\"1\":{\"876\":1}}],[\"500\",{\"1\":{\"166\":1,\"727\":1}}],[\"50\",{\"1\":{\"65\":1,\"142\":1,\"147\":2,\"148\":2,\"161\":1,\"565\":2,\"908\":1}}],[\"5倍\",{\"1\":{\"25\":1}}],[\"5\",{\"0\":{\"423\":1,\"501\":1,\"515\":1,\"943\":1},\"1\":{\"14\":3,\"46\":5,\"78\":1,\"79\":1,\"80\":4,\"147\":1,\"172\":2,\"173\":2,\"240\":1,\"241\":1,\"274\":1,\"275\":1,\"280\":2,\"292\":2,\"294\":2,\"295\":1,\"384\":3,\"444\":1,\"544\":1,\"605\":1,\"688\":1,\"693\":3,\"786\":1,\"834\":1,\"841\":1,\"850\":1,\"888\":1,\"908\":1,\"913\":1}}],[\"4k高清无码\",{\"1\":{\"835\":1}}],[\"4kmeinv\",{\"1\":{\"333\":1}}],[\"4606\",{\"1\":{\"544\":1}}],[\"400\",{\"1\":{\"727\":1}}],[\"4000\",{\"1\":{\"174\":1}}],[\"404\",{\"1\":{\"367\":2,\"929\":1}}],[\"41\",{\"1\":{\"65\":1}}],[\"4\",{\"0\":{\"53\":1,\"54\":1,\"262\":1,\"407\":1,\"420\":1,\"422\":1,\"458\":1,\"473\":1,\"480\":1,\"493\":1,\"494\":1,\"495\":1,\"498\":1,\"514\":1,\"530\":1,\"595\":1,\"942\":1},\"1\":{\"14\":3,\"46\":5,\"71\":1,\"78\":1,\"79\":1,\"80\":4,\"173\":2,\"239\":3,\"240\":1,\"245\":1,\"274\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"384\":1,\"444\":1,\"605\":1,\"613\":2,\"693\":2,\"785\":1,\"819\":3,\"840\":3,\"849\":3,\"893\":1}}],[\"的类\",{\"1\":{\"926\":1}}],[\"的程序可以访问该cookie\",{\"1\":{\"909\":1}}],[\"的请求头\",{\"1\":{\"908\":1}}],[\"的位置即可\",{\"1\":{\"899\":1}}],[\"的垃圾回收器进行垃圾回收的\",{\"1\":{\"872\":1}}],[\"的生命周期\",{\"0\":{\"872\":1}}],[\"的默认的日志级别\",{\"1\":{\"756\":1,\"768\":1}}],[\"的默认处理器为\",{\"1\":{\"756\":1,\"768\":1}}],[\"的强大特性之一\",{\"1\":{\"689\":1}}],[\"的实例为核心的\",{\"1\":{\"642\":1}}],[\"的实现\",{\"1\":{\"46\":1}}],[\"的应用都是以一个\",{\"1\":{\"642\":1}}],[\"的东西\",{\"1\":{\"641\":1}}],[\"的操作\",{\"1\":{\"599\":1}}],[\"的操作是从对应的xxx流内获取一些东西\",{\"1\":{\"543\":1}}],[\"的操作是往对应的xxx流内写入一些东西\",{\"1\":{\"543\":1}}],[\"的用法\",{\"1\":{\"543\":1}}],[\"的算法\",{\"1\":{\"530\":1}}],[\"的选择\",{\"0\":{\"526\":1}}],[\"的权重或者分布\",{\"1\":{\"529\":1}}],[\"的权重\",{\"1\":{\"524\":1}}],[\"的加权平均\",{\"1\":{\"524\":1}}],[\"的加权均值\",{\"1\":{\"422\":1}}],[\"的基本步骤\",{\"1\":{\"522\":1}}],[\"的基础上来引入偏置量\",{\"1\":{\"399\":1}}],[\"的文章中\",{\"1\":{\"518\":1}}],[\"的输出是不一样的\",{\"1\":{\"518\":1}}],[\"的输出\",{\"1\":{\"516\":1}}],[\"的参数\",{\"1\":{\"516\":1}}],[\"的就不是有关\",{\"1\":{\"516\":1}}],[\"的梯度时\",{\"1\":{\"516\":1}}],[\"的分布\",{\"1\":{\"509\":1}}],[\"的新形式\",{\"1\":{\"487\":1}}],[\"的定义\",{\"1\":{\"487\":1}}],[\"的定义出发\",{\"1\":{\"451\":1}}],[\"的估计从\",{\"1\":{\"504\":1}}],[\"的估计\",{\"1\":{\"486\":1,\"490\":1}}],[\"的采样\",{\"1\":{\"484\":1}}],[\"的思想\",{\"1\":{\"475\":1}}],[\"的值\",{\"1\":{\"473\":1}}],[\"的值进行重新计算\",{\"1\":{\"64\":1}}],[\"的动作数量\",{\"1\":{\"461\":1}}],[\"的高效利用\",{\"0\":{\"455\":1}}],[\"的一些改进\",{\"1\":{\"454\":1}}],[\"的一些方法\",{\"0\":{\"63\":1}}],[\"的一个观测值\",{\"1\":{\"478\":1}}],[\"的一个\",{\"1\":{\"452\":1}}],[\"的原理\",{\"1\":{\"450\":1}}],[\"的策略来进行选择\",{\"1\":{\"440\":1}}],[\"的策略πk+1​\",{\"1\":{\"437\":1}}],[\"的策略所采集的数据来\",{\"1\":{\"403\":1}}],[\"的根据策略π加权平均\",{\"1\":{\"423\":1}}],[\"的转到下一个状态的\",{\"1\":{\"422\":1}}],[\"的过程\",{\"1\":{\"421\":1}}],[\"的计算即可\",{\"1\":{\"416\":1}}],[\"的期望\",{\"1\":{\"414\":1}}],[\"的概率\",{\"1\":{\"394\":2}}],[\"的概念\",{\"1\":{\"155\":1}}],[\"的s是有范围的\",{\"1\":{\"387\":1}}],[\"的函数\",{\"1\":{\"383\":1,\"516\":1}}],[\"的功率谱密度\",{\"1\":{\"383\":1}}],[\"的无人机3d动态运动设计算法\",{\"1\":{\"379\":1}}],[\"的部署方法\",{\"1\":{\"379\":1}}],[\"的问题\",{\"1\":{\"374\":1}}],[\"的行为\",{\"1\":{\"374\":1}}],[\"的流\",{\"1\":{\"362\":1}}],[\"的流转成一个\",{\"1\":{\"362\":1}}],[\"的情况下进行估计\",{\"1\":{\"449\":1}}],[\"的情况下使用\",{\"1\":{\"161\":1}}],[\"的情况\",{\"1\":{\"294\":1,\"450\":1,\"451\":2,\"478\":1}}],[\"的变量\",{\"1\":{\"256\":1}}],[\"的匿名类\",{\"1\":{\"255\":1}}],[\"的构造方法中我们可以写入原因\",{\"1\":{\"266\":1}}],[\"的构造方法\",{\"1\":{\"191\":1}}],[\"的区别\",{\"0\":{\"415\":1},\"1\":{\"84\":1}}],[\"的会保留\",{\"1\":{\"71\":1}}],[\"的处理\",{\"1\":{\"71\":1}}],[\"的源码发现\",{\"1\":{\"67\":1}}],[\"的全部性质\",{\"1\":{\"61\":1}}],[\"的容量\",{\"1\":{\"60\":1}}],[\"的关系存在\",{\"1\":{\"552\":1}}],[\"的关系\",{\"1\":{\"55\":1}}],[\"的性质\",{\"1\":{\"50\":1}}],[\"的底层实现是由\",{\"1\":{\"58\":1}}],[\"的底层实现\",{\"1\":{\"50\":1}}],[\"的方法进行解决\",{\"1\":{\"516\":1}}],[\"的方法支持添加default关键字来添加默认实现\",{\"1\":{\"317\":1}}],[\"的方法\",{\"1\":{\"35\":1,\"403\":1,\"442\":1,\"459\":1,\"521\":2}}],[\"的方式去创建一个抽象类或是接口对象\",{\"1\":{\"255\":1}}],[\"的方式使用静态内容\",{\"1\":{\"219\":1}}],[\"的方式\",{\"0\":{\"35\":1}}],[\"的形式来直接引用一个已有的方法作为实现\",{\"1\":{\"291\":1}}],[\"的形式进行替换即可\",{\"1\":{\"289\":1}}],[\"的形式\",{\"1\":{\"30\":1,\"258\":2,\"432\":1,\"473\":1}}],[\"的\",{\"1\":{\"30\":1,\"84\":1,\"186\":1,\"219\":1,\"236\":1,\"305\":1,\"374\":1,\"437\":1,\"440\":1,\"451\":1,\"452\":2,\"455\":1,\"458\":1,\"460\":1,\"461\":1,\"485\":1,\"487\":2,\"497\":2,\"498\":2,\"507\":1,\"529\":1,\"633\":1,\"701\":1}}],[\"的排序方法\",{\"1\":{\"14\":1}}],[\"的使用几乎相同\",{\"1\":{\"25\":1}}],[\"的使用和\",{\"1\":{\"25\":1}}],[\"的使用\",{\"0\":{\"7\":1}}],[\"因此无法使用这种方式来传递数据\",{\"1\":{\"900\":1}}],[\"因此无需多余配置\",{\"1\":{\"775\":1}}],[\"因此返回405状态码\",{\"1\":{\"900\":1}}],[\"因此返回值也是\",{\"1\":{\"14\":1}}],[\"因此此类仅仅是用于完善一个servlet的基本操作\",{\"1\":{\"876\":1}}],[\"因此此表中存在一个主键\",{\"1\":{\"554\":1}}],[\"因此之后我们一律使用注解进行开发\",{\"1\":{\"871\":1}}],[\"因此有时候可以省略\",{\"1\":{\"859\":1}}],[\"因此有对象锁和类锁区别\",{\"1\":{\"155\":1}}],[\"因此需要导入这些依赖来做兼容\",{\"1\":{\"842\":1}}],[\"因此需要用一个命名空间来区分\",{\"1\":{\"643\":1}}],[\"因此需要用近似算法来进行替代\",{\"1\":{\"510\":1}}],[\"因此只需在运行时包含即可\",{\"1\":{\"833\":1}}],[\"因此只能使用类来进行定义\",{\"1\":{\"243\":1}}],[\"因此lombok不需要在项目运行时也存在\",{\"1\":{\"833\":1}}],[\"因此maven第一次导入依赖是需要联网的\",{\"1\":{\"826\":1}}],[\"因此mos不仅与欧氏距离有关\",{\"1\":{\"387\":1}}],[\"因此moskn​​delay\",{\"1\":{\"384\":1}}],[\"因此默认值是\",{\"1\":{\"701\":1}}],[\"因此直接导入依赖后就可以使用了\",{\"1\":{\"628\":1}}],[\"因此要先起一个别名\",{\"1\":{\"585\":1}}],[\"因此不同的数据库都存在自己的\",{\"1\":{\"561\":1}}],[\"因此不需要进行\",{\"1\":{\"494\":1}}],[\"因此不需要data\",{\"1\":{\"366\":1}}],[\"因此存在传递依赖的情况\",{\"1\":{\"555\":1}}],[\"因此学号和学生之间也有一种联系\",{\"1\":{\"550\":1}}],[\"因此该指标可以描述为\",{\"1\":{\"524\":1}}],[\"因此左侧那个类似\",{\"1\":{\"516\":1}}],[\"因此对于常见的一些查询参数\",{\"1\":{\"648\":1}}],[\"因此对于用户kn​的在时刻t的传输速率rkn​​\",{\"1\":{\"383\":1}}],[\"因此对应的损失函数的梯度可以修改为\",{\"1\":{\"516\":1}}],[\"因此对应算法为\",{\"1\":{\"512\":1}}],[\"因此可以考虑\",{\"1\":{\"510\":1}}],[\"因此可以直接调用\",{\"1\":{\"274\":1,\"275\":1}}],[\"因此可以直接使用lambda表达式\",{\"1\":{\"139\":1}}],[\"因此可以直接放入\",{\"1\":{\"126\":1}}],[\"因此可以直接读取到中文字符\",{\"1\":{\"96\":1}}],[\"因此采用这种\",{\"1\":{\"508\":1}}],[\"因此这台主机也称为万维网服务器\",{\"1\":{\"859\":1}}],[\"因此这些日志框架仅mybatis内部做兼容需要导入使用\",{\"1\":{\"842\":1}}],[\"因此这种情况下的\",{\"1\":{\"508\":1}}],[\"因此这样就能够保证我们插入顺序和最后的迭代顺序一致了\",{\"1\":{\"49\":1}}],[\"因此是一个确定的贪心策略\",{\"1\":{\"462\":1}}],[\"因此是2n\",{\"1\":{\"388\":1}}],[\"因此随着用户位置的变化\",{\"1\":{\"388\":1}}],[\"因此gak\",{\"1\":{\"387\":1}}],[\"因此既可以存放integer也能存放string\",{\"1\":{\"280\":1}}],[\"因此会读取命令行中的指令参数进行存储到\",{\"1\":{\"242\":1}}],[\"因此它是在进行内部的转发\",{\"1\":{\"900\":1}}],[\"因此它能够有效地防止sql注入攻击\",{\"1\":{\"622\":1}}],[\"因此它可以被拆分为\",{\"1\":{\"553\":1}}],[\"因此它已经无法正常工作了\",{\"1\":{\"193\":1}}],[\"因此它只适合读纯文本的文件\",{\"1\":{\"96\":1}}],[\"因此守护线程不适合进行io操作\",{\"1\":{\"172\":1}}],[\"因此各个线程直接存放的内容互不干扰\",{\"1\":{\"162\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"156\":1}}],[\"因此并不能保证自增操作的原子性\",{\"1\":{\"155\":1}}],[\"因此为null\",{\"1\":{\"133\":1}}],[\"因此我们将第一个过滤器命名进行调整\",{\"1\":{\"920\":1}}],[\"因此我们将优化问题简化为区域分割问题\",{\"1\":{\"387\":1}}],[\"因此我们通过maven导入其他的依赖只需要填写这三个基本元素就可以了\",{\"1\":{\"820\":1}}],[\"因此我们不需要再去进行额外的环境安装\",{\"1\":{\"817\":1}}],[\"因此我们不需要手动指定\",{\"1\":{\"120\":1}}],[\"因此我们在默认情况下才能正常使用日志打印\",{\"1\":{\"744\":1}}],[\"因此我们打印日志就不会有任何效果\",{\"1\":{\"735\":1}}],[\"因此我们可能需要限制用户的输入来防止用户输入一些sql语句关键字\",{\"1\":{\"621\":1}}],[\"因此我们可以直接使用httpfilter来编写\",{\"1\":{\"921\":1}}],[\"因此我们可以直接使用数组的class对象表示\",{\"1\":{\"192\":1}}],[\"因此我们可以随时随地获取我们添加的属性\",{\"1\":{\"901\":1}}],[\"因此我们可以创建一个工具类来集中创建sqlsession\",{\"1\":{\"647\":1}}],[\"因此我们可以使用setkeepalive\",{\"1\":{\"538\":1}}],[\"因此我们可以通过\",{\"1\":{\"473\":1}}],[\"因此我们的服务端能够读取http请求\",{\"1\":{\"544\":1}}],[\"因此我们需要设置一下logging\",{\"1\":{\"768\":1}}],[\"因此我们需要保证对于所有的\",{\"1\":{\"529\":1}}],[\"因此我们需要一种方法来区分类的不同版本\",{\"1\":{\"132\":1}}],[\"因此我们用\",{\"1\":{\"511\":1}}],[\"因此我们编写一个自定义的来让它支持\",{\"1\":{\"199\":1}}],[\"因此我们自己编写的同名包同名类不会被加载\",{\"1\":{\"198\":1}}],[\"因此依然是装饰我们传入的输出流\",{\"1\":{\"127\":1}}],[\"因此性能还不够高\",{\"1\":{\"103\":1}}],[\"因此与read结合\",{\"1\":{\"91\":1}}],[\"因此所有的集合类都有这个方法\",{\"1\":{\"36\":1}}],[\"因此\",{\"1\":{\"14\":1,\"16\":1,\"47\":1,\"84\":1,\"156\":1,\"244\":1,\"255\":2,\"290\":1,\"383\":2,\"384\":1,\"400\":1,\"416\":1,\"422\":1,\"432\":1,\"445\":1,\"468\":1,\"475\":1,\"478\":2,\"484\":1,\"487\":1,\"498\":1,\"596\":1,\"642\":1,\"700\":1,\"705\":1,\"718\":1,\"729\":1,\"765\":1,\"773\":2,\"780\":1,\"826\":1,\"834\":1,\"842\":1,\"853\":1,\"859\":2,\"872\":1,\"912\":1}}],[\"因为配置文件位于内部\",{\"1\":{\"834\":1}}],[\"因为jdbc驱动由数据库厂商开发\",{\"1\":{\"833\":1}}],[\"因为中心仓库服务器位于国外\",{\"1\":{\"827\":1}}],[\"因为mybatis的日志级别都比较低\",{\"1\":{\"768\":1}}],[\"因为这这里off的值为int的最大值\",{\"1\":{\"729\":1}}],[\"因为这里需要多个参数\",{\"1\":{\"651\":1}}],[\"因为这里是void\",{\"1\":{\"192\":1}}],[\"因为并没有保存在缓存中\",{\"1\":{\"701\":1}}],[\"因为并没有使用到外部类的任何静态变量\",{\"1\":{\"254\":1}}],[\"因为id已经发生变化了\",{\"1\":{\"705\":1}}],[\"因为id为主键\",{\"1\":{\"652\":1}}],[\"因为integer类中默认提供了求两个int值之和的静态方法\",{\"1\":{\"258\":1}}],[\"因为只有这样mybatis才能正确识别我们配置的内容\",{\"1\":{\"641\":1}}],[\"因为equal方法可能不符合预期结果\",{\"1\":{\"629\":1}}],[\"因为浏览器不止发一个请求\",{\"1\":{\"544\":1}}],[\"因为浏览器访问时会不止发一个请求\",{\"1\":{\"544\":1}}],[\"因为我们使用了别人为我们提供的框架\",{\"1\":{\"854\":1}}],[\"因为我们是从外部进行修改\",{\"1\":{\"705\":1}}],[\"因为我们需要计算的是\",{\"1\":{\"529\":1}}],[\"因为我们前面学习了lambda表达式\",{\"1\":{\"14\":1}}],[\"因为最终策略更新的核心仍然是\",{\"1\":{\"453\":1}}],[\"因为无论在哪里\",{\"1\":{\"901\":1}}],[\"因为无论是\",{\"1\":{\"449\":1}}],[\"因为无论具体类型是什么\",{\"1\":{\"281\":1}}],[\"因为其满足该理论\",{\"1\":{\"432\":1}}],[\"因为其他类就算继承这个接口\",{\"1\":{\"219\":1}}],[\"因为q\",{\"1\":{\"387\":1}}],[\"因为目标函数对于无人机的3d坐标是非凸的\",{\"1\":{\"385\":1}}],[\"因为该方法已经添加到\",{\"1\":{\"359\":1}}],[\"因为b指定了non\",{\"1\":{\"347\":1}}],[\"因为继承的坑位已经默认被占了\",{\"1\":{\"344\":1}}],[\"因为完全可以从后面的值来判断是什么类型\",{\"1\":{\"328\":1}}],[\"因为不需要\",{\"1\":{\"499\":1}}],[\"因为不太常用\",{\"1\":{\"323\":1}}],[\"因为不这样就无法编译了\",{\"1\":{\"266\":1}}],[\"因为权限为私有的\",{\"1\":{\"317\":1}}],[\"因为没有模块只需要导包就行\",{\"1\":{\"306\":1}}],[\"因为数组本身是引用类型\",{\"1\":{\"281\":1}}],[\"因为此时并不明确具体是什么类型\",{\"1\":{\"281\":1}}],[\"因为现在父项目没有依赖\",{\"1\":{\"850\":1}}],[\"因为现在是以类为单位\",{\"1\":{\"803\":1}}],[\"因为现在有了类型变量\",{\"1\":{\"281\":1}}],[\"因为现在只需要使用接口来进行配置\",{\"1\":{\"711\":1}}],[\"因为现在只需要一个string类型的返回值\",{\"1\":{\"258\":1}}],[\"因为现在只可能出现number的子类\",{\"1\":{\"16\":1}}],[\"因为object是所有类型的父类\",{\"1\":{\"280\":1}}],[\"因为匿名内部类不支持自动类型推断\",{\"1\":{\"323\":1}}],[\"因为匿名内部类就是接口的实现类\",{\"1\":{\"14\":1}}],[\"因为匿名对象没有类名\",{\"1\":{\"255\":1}}],[\"因为在最后需要释放资源\",{\"1\":{\"605\":1}}],[\"因为在最后自动帮我们调用了close\",{\"1\":{\"90\":1}}],[\"因为在\",{\"1\":{\"466\":1}}],[\"因为在不考虑用户自由穿梭集群的情况\",{\"1\":{\"388\":1}}],[\"因为在编译的时候\",{\"1\":{\"254\":1}}],[\"因为成员内部类本身就是某个对象所有的\",{\"1\":{\"251\":1}}],[\"因为父类都是\",{\"1\":{\"238\":1}}],[\"因为同样是类\",{\"1\":{\"235\":1}}],[\"因为超出了缓存的范围\",{\"1\":{\"227\":1}}],[\"因为小的数使用频率非常高\",{\"1\":{\"227\":1}}],[\"因为包装类是一个类\",{\"1\":{\"227\":1}}],[\"因为底层是c++实现\",{\"1\":{\"220\":1}}],[\"因为底层实质上是借用的一个\",{\"1\":{\"48\":1}}],[\"因为抽象方法一定要由子类实现\",{\"1\":{\"218\":1}}],[\"因为普通的classloader无法加载二进制文件\",{\"1\":{\"199\":1}}],[\"因为是具体使用对象时才会明确具体类型\",{\"1\":{\"281\":1}}],[\"因为是属于类的\",{\"1\":{\"192\":1}}],[\"因为是在顶层接口中定义的\",{\"1\":{\"36\":1}}],[\"因为newinstance\",{\"1\":{\"191\":1}}],[\"因为都直接在一个缺省的包中\",{\"1\":{\"120\":1}}],[\"因为this关键字代表的是当前的对象本身\",{\"1\":{\"117\":1}}],[\"因为静态方法属于类的\",{\"1\":{\"117\":1}}],[\"因为关闭流是任何情况都必须要执行的\",{\"1\":{\"90\":1}}],[\"因为它们都被认为是一个文本节点\",{\"1\":{\"636\":1}}],[\"因为它们直接操作字符\",{\"1\":{\"88\":1}}],[\"因为它本质上就相当于是对应类型的子类\",{\"1\":{\"255\":1}}],[\"因为它作用范围就只是方法内\",{\"1\":{\"253\":1}}],[\"因为它是我们直接加载的\",{\"1\":{\"199\":1}}],[\"因为它会将我们插入的结点按照规则进行排序\",{\"1\":{\"62\":1}}],[\"因为重写了\",{\"1\":{\"84\":1}}],[\"因为传入的哈希值可能会很大\",{\"1\":{\"59\":1}}],[\"因为操作特殊\",{\"1\":{\"55\":1,\"56\":1}}],[\"因为list是有序集合\",{\"1\":{\"37\":1}}],[\"因为\",{\"1\":{\"35\":1,\"57\":1,\"67\":2,\"84\":1,\"451\":1,\"478\":1,\"498\":1}}],[\"因为所有的对象都是属于一个普通的类型\",{\"1\":{\"16\":1}}],[\"因为还是有可能是\",{\"1\":{\"15\":1}}],[\"因而也被称为实例\",{\"1\":{\"4\":1}}],[\"title\",{\"1\":{\"670\":3}}],[\"timeservlet\",{\"1\":{\"893\":1}}],[\"time存储时间\",{\"1\":{\"563\":1}}],[\"timed\",{\"1\":{\"538\":1}}],[\"timeout>\",{\"1\":{\"914\":1}}],[\"timeout>1<\",{\"1\":{\"914\":1}}],[\"timeout=20\",{\"1\":{\"908\":1,\"913\":1}}],[\"timeout\",{\"1\":{\"215\":2}}],[\"timerthread继承自thread\",{\"1\":{\"167\":1}}],[\"timerthread\",{\"1\":{\"167\":2}}],[\"timertask\",{\"1\":{\"165\":3,\"166\":1,\"167\":2}}],[\"timer\",{\"1\":{\"166\":4,\"167\":15}}],[\"timerlooptask\",{\"1\":{\"165\":3}}],[\"time\",{\"1\":{\"165\":5,\"384\":1,\"455\":1,\"893\":4,\"899\":1,\"900\":2,\"901\":2,\"908\":3,\"910\":1,\"913\":3}}],[\"tcp是传输层协议\",{\"1\":{\"859\":1}}],[\"tcp协议实际上是经历了三次握手再进行通信\",{\"1\":{\"859\":1}}],[\"tcp发送缓冲区\",{\"1\":{\"538\":1}}],[\"tcp接收缓冲区\",{\"1\":{\"538\":1}}],[\"tcp在传输过程中\",{\"1\":{\"538\":1}}],[\"t=0∑∞​γtrt+1​\",{\"1\":{\"525\":1}}],[\"t=0\",{\"1\":{\"486\":1,\"490\":1}}],[\"td\",{\"0\":{\"485\":1,\"488\":1,\"489\":1,\"493\":1,\"501\":1,\"512\":1},\"1\":{\"487\":1,\"512\":1,\"516\":1,\"530\":1}}],[\"t∈rn\",{\"1\":{\"420\":2}}],[\"t∈r2×1\",{\"1\":{\"382\":2}}],[\"tupian\",{\"1\":{\"333\":2}}],[\"t会根据使用时提供的类型自动变成对应类型\",{\"1\":{\"281\":1}}],[\"tmp\",{\"1\":{\"91\":3,\"94\":3}}],[\"txt\",{\"1\":{\"91\":6,\"92\":2,\"93\":1,\"94\":2,\"96\":2,\"97\":1,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"128\":1,\"129\":2,\"131\":2,\"133\":2,\"543\":2}}],[\"t2\",{\"1\":{\"84\":4,\"147\":2,\"148\":2,\"154\":2,\"155\":4,\"156\":2,\"161\":2,\"162\":2}}],[\"t1\",{\"1\":{\"84\":5,\"147\":2,\"148\":3,\"154\":2,\"155\":4,\"156\":2,\"161\":2,\"162\":2}}],[\"temp目录\",{\"1\":{\"864\":1}}],[\"temporal\",{\"0\":{\"483\":1}}],[\"teach\",{\"1\":{\"586\":4}}],[\"teacher\",{\"1\":{\"219\":7}}],[\"terminate\",{\"1\":{\"864\":1}}],[\"terminal\",{\"1\":{\"71\":1,\"393\":1}}],[\"terms\",{\"1\":{\"493\":1}}],[\"technology\",{\"1\":{\"377\":1},\"2\":{\"390\":1}}],[\"ten\",{\"1\":{\"229\":1}}],[\"text+\",{\"1\":{\"199\":1,\"537\":2}}],[\"text\",{\"1\":{\"199\":3,\"289\":1,\"303\":2,\"304\":1,\"305\":1,\"308\":2,\"316\":6,\"318\":1,\"328\":3,\"337\":1,\"341\":2,\"343\":2,\"344\":2,\"347\":2,\"358\":1,\"537\":1,\"544\":1,\"658\":1,\"659\":1,\"666\":1,\"667\":2,\"670\":1,\"672\":1,\"688\":2,\"693\":1,\"694\":1,\"699\":1,\"700\":2,\"701\":1,\"705\":1,\"714\":1,\"737\":1,\"747\":1,\"765\":1,\"773\":1,\"775\":1,\"776\":2,\"777\":1,\"778\":1,\"780\":1,\"786\":1,\"790\":1,\"791\":1,\"793\":1,\"803\":2,\"805\":1,\"818\":1,\"826\":1,\"853\":1,\"864\":3,\"875\":1,\"876\":1,\"881\":1,\"886\":1,\"889\":1,\"892\":1,\"893\":1,\"908\":3,\"912\":1,\"913\":2,\"918\":1,\"920\":2,\"922\":1,\"926\":1}}],[\"testlistener\",{\"1\":{\"922\":1}}],[\"testfilter2\",{\"1\":{\"920\":1}}],[\"testfilter\",{\"1\":{\"919\":1}}],[\"testutils\",{\"1\":{\"840\":2}}],[\"testservlet<\",{\"1\":{\"871\":1}}],[\"testservlet\",{\"1\":{\"871\":1,\"876\":1,\"881\":1}}],[\"tests\",{\"1\":{\"812\":2}}],[\"testsqlbuilder\",{\"1\":{\"719\":2}}],[\"testclassorder来控制嵌套类的执行顺序\",{\"1\":{\"805\":1}}],[\"testcondition\",{\"1\":{\"797\":2}}],[\"testing\",{\"1\":{\"864\":1}}],[\"testinstance\",{\"1\":{\"803\":2}}],[\"testimpl\",{\"1\":{\"310\":2}}],[\"testmain\",{\"1\":{\"803\":2}}],[\"testmapper明明是一个我们自己定义接口啊\",{\"1\":{\"659\":1}}],[\"testmapper\",{\"1\":{\"643\":2,\"658\":1,\"659\":9,\"660\":2,\"678\":1,\"682\":6,\"688\":2,\"694\":2,\"700\":6,\"701\":4,\"705\":2,\"711\":1,\"712\":1,\"713\":1,\"720\":1,\"834\":5}}],[\"testtemplate方法时\",{\"1\":{\"797\":1}}],[\"test3\",{\"1\":{\"776\":1,\"804\":1}}],[\"test注解或是其他标记junit测试案例的注解\",{\"1\":{\"852\":1}}],[\"test注解\",{\"1\":{\"776\":1}}],[\"test注解即可快速创建新的测试用例\",{\"1\":{\"776\":1}}],[\"test1\",{\"1\":{\"776\":2,\"778\":1,\"780\":1,\"786\":1,\"791\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":2,\"797\":1,\"802\":1,\"803\":2,\"804\":1,\"805\":3,\"807\":1,\"808\":1,\"809\":2,\"810\":2,\"811\":1,\"812\":2,\"880\":1}}],[\"test=123\",{\"1\":{\"908\":2,\"913\":1}}],[\"test=\",{\"1\":{\"690\":1,\"691\":2,\"719\":2}}],[\"test2\",{\"1\":{\"672\":2,\"776\":1,\"777\":1,\"793\":1,\"794\":1,\"803\":1,\"804\":1,\"805\":3,\"880\":1}}],[\"test>\",{\"1\":{\"635\":1}}],[\"test是一个接口\",{\"1\":{\"310\":1}}],[\"test包\",{\"1\":{\"310\":1}}],[\"test包下所有内容暴露出去\",{\"1\":{\"308\":2}}],[\"test包下所有内容都暴露出去\",{\"1\":{\"307\":1}}],[\"test包暴露给指定的模块module\",{\"1\":{\"307\":1}}],[\"test<t>\",{\"1\":{\"323\":1}}],[\"test<>\",{\"1\":{\"281\":1,\"323\":1}}],[\"test<string\",{\"1\":{\"281\":1}}],[\"test<string>\",{\"1\":{\"186\":1,\"191\":1,\"192\":1,\"281\":1,\"323\":1}}],[\"test<a\",{\"1\":{\"281\":1}}],[\"test<integer>\",{\"1\":{\"281\":1}}],[\"test<\",{\"1\":{\"281\":1,\"819\":1,\"840\":2,\"843\":1,\"871\":1}}],[\"testexception\",{\"1\":{\"265\":4}}],[\"test这个包中\",{\"1\":{\"120\":1}}],[\"test\",{\"1\":{\"14\":2,\"16\":7,\"23\":1,\"36\":1,\"84\":21,\"91\":6,\"94\":1,\"96\":2,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"112\":3,\"117\":1,\"120\":7,\"121\":4,\"126\":2,\"127\":1,\"129\":1,\"186\":2,\"191\":5,\"192\":10,\"199\":10,\"206\":3,\"207\":9,\"208\":13,\"219\":2,\"221\":7,\"238\":1,\"241\":3,\"242\":1,\"251\":25,\"252\":6,\"253\":4,\"254\":11,\"255\":7,\"256\":1,\"257\":2,\"266\":3,\"267\":4,\"281\":7,\"282\":5,\"290\":10,\"291\":3,\"296\":4,\"307\":4,\"308\":2,\"309\":4,\"310\":10,\"311\":3,\"317\":4,\"323\":8,\"343\":1,\"621\":3,\"622\":1,\"636\":2,\"643\":1,\"648\":1,\"649\":2,\"652\":1,\"653\":3,\"658\":4,\"659\":2,\"660\":1,\"666\":3,\"667\":1,\"668\":5,\"670\":3,\"671\":4,\"672\":5,\"678\":1,\"679\":1,\"703\":1,\"704\":1,\"711\":2,\"712\":1,\"714\":1,\"715\":1,\"716\":1,\"721\":3,\"725\":2,\"736\":1,\"737\":1,\"738\":1,\"744\":1,\"745\":1,\"746\":2,\"747\":3,\"753\":1,\"754\":1,\"756\":2,\"763\":1,\"764\":1,\"776\":3,\"777\":1,\"778\":1,\"780\":1,\"786\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":4,\"797\":1,\"802\":1,\"803\":3,\"804\":4,\"805\":6,\"833\":1,\"834\":6,\"835\":1,\"840\":2,\"852\":2,\"853\":1,\"854\":1,\"864\":1,\"871\":1,\"876\":1,\"878\":2,\"881\":1,\"892\":2,\"900\":2,\"901\":2,\"902\":2,\"908\":1}}],[\"typealiases>\",{\"1\":{\"649\":2,\"834\":1}}],[\"type=\",{\"1\":{\"634\":1,\"641\":2,\"649\":1,\"652\":1,\"658\":1,\"666\":1,\"667\":1,\"668\":1,\"670\":1,\"671\":1,\"672\":2,\"715\":1,\"834\":2,\"886\":2,\"888\":2,\"892\":1,\"910\":1}}],[\"type1\",{\"1\":{\"186\":9}}],[\"types\",{\"1\":{\"186\":6}}],[\"typevariableimpl\",{\"1\":{\"186\":3}}],[\"type\",{\"1\":{\"65\":5,\"183\":4,\"186\":20,\"207\":4,\"208\":1,\"719\":1,\"810\":8,\"832\":1,\"875\":1,\"908\":1,\"913\":1}}],[\"taking\",{\"1\":{\"422\":1}}],[\"takewhile\",{\"1\":{\"322\":1}}],[\"take\",{\"1\":{\"139\":1,\"174\":4,\"460\":1}}],[\"taobao\",{\"1\":{\"246\":2}}],[\"taohai\",{\"1\":{\"65\":3}}],[\"taskfired\",{\"1\":{\"167\":1}}],[\"taskqueue\",{\"1\":{\"167\":2}}],[\"tasks转换成continuing\",{\"1\":{\"393\":1}}],[\"tasks\",{\"1\":{\"167\":2,\"393\":3}}],[\"task\",{\"1\":{\"165\":6,\"167\":2}}],[\"target>\",{\"1\":{\"819\":1,\"849\":1}}],[\"target>17<\",{\"1\":{\"819\":1,\"849\":1}}],[\"target限定为只能作用于方法上\",{\"1\":{\"206\":1}}],[\"target\",{\"1\":{\"139\":2,\"205\":1,\"206\":3,\"207\":4,\"208\":2,\"495\":1,\"496\":1,\"497\":1,\"498\":1,\"499\":2,\"516\":4}}],[\"tabular\",{\"1\":{\"504\":1}}],[\"tab\",{\"1\":{\"59\":8}}],[\"table来删除一个表\",{\"1\":{\"569\":1}}],[\"table来进行修改\",{\"1\":{\"568\":1}}],[\"table来找出对应q\",{\"1\":{\"387\":1}}],[\"table语句来创建一张表\",{\"1\":{\"567\":1}}],[\"table过大\",{\"1\":{\"388\":1}}],[\"table管理\",{\"1\":{\"387\":1}}],[\"table\",{\"1\":{\"58\":1,\"59\":1,\"60\":2,\"387\":2,\"565\":1,\"567\":1,\"568\":1,\"569\":1}}],[\"t>\",{\"1\":{\"35\":1,\"36\":1,\"352\":1}}],[\"thu\",{\"1\":{\"908\":1,\"913\":1}}],[\"these\",{\"1\":{\"864\":1}}],[\"then\",{\"1\":{\"432\":2,\"606\":1,\"864\":1}}],[\"theorem来求解贝尔曼最优公式\",{\"1\":{\"432\":1}}],[\"theorem\",{\"1\":{\"427\":2,\"432\":1,\"436\":1,\"472\":1}}],[\"they\",{\"1\":{\"167\":1}}],[\"them\",{\"1\":{\"167\":1}}],[\"the\",{\"0\":{\"398\":1,\"417\":1,\"418\":1},\"1\":{\"139\":5,\"167\":7,\"183\":4,\"352\":8,\"378\":1,\"383\":1,\"384\":1,\"393\":6,\"394\":4,\"411\":1,\"414\":1,\"415\":2,\"421\":1,\"422\":4,\"423\":2,\"426\":1,\"427\":2,\"432\":2,\"455\":1,\"456\":2,\"460\":1,\"472\":2,\"509\":1,\"516\":2,\"605\":4,\"606\":10,\"658\":1,\"864\":27,\"871\":4}}],[\"that\",{\"1\":{\"139\":3,\"352\":2,\"415\":1,\"432\":1,\"455\":1,\"606\":2,\"864\":2}}],[\"through\",{\"1\":{\"606\":1,\"864\":1}}],[\"throughput\",{\"1\":{\"378\":1}}],[\"throwable\",{\"1\":{\"215\":1,\"658\":2}}],[\"throws\",{\"1\":{\"107\":1,\"128\":1,\"142\":1,\"143\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"172\":2,\"182\":1,\"191\":2,\"192\":3,\"193\":3,\"199\":1,\"208\":1,\"215\":5,\"220\":2,\"264\":1,\"266\":3,\"267\":4,\"305\":1,\"323\":3,\"333\":4,\"352\":3,\"606\":3,\"607\":2,\"615\":1,\"622\":1,\"623\":4,\"641\":1,\"643\":1,\"871\":2,\"874\":1,\"876\":4,\"881\":2,\"886\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":1,\"920\":3,\"921\":3}}],[\"throw\",{\"1\":{\"25\":1,\"32\":1,\"110\":1,\"174\":1,\"266\":6,\"267\":3,\"289\":1,\"537\":1,\"543\":1,\"606\":4,\"613\":1,\"616\":1,\"658\":1,\"807\":1,\"808\":1,\"876\":1,\"889\":1,\"921\":1}}],[\"threadlocal<>\",{\"1\":{\"162\":1}}],[\"threadlocal<string>\",{\"1\":{\"162\":1,\"163\":1}}],[\"threadlocal定义在主线程中\",{\"1\":{\"162\":1}}],[\"thread\",{\"1\":{\"139\":7,\"140\":6,\"142\":5,\"144\":5,\"145\":3,\"147\":5,\"148\":4,\"154\":5,\"155\":18,\"156\":6,\"161\":5,\"162\":6,\"163\":3,\"165\":4,\"166\":1,\"167\":8,\"172\":10,\"173\":1,\"174\":9,\"288\":4,\"289\":8,\"606\":1,\"658\":1,\"705\":1,\"765\":1}}],[\"thread构造方法中需要传入一个runnable接口的实现\",{\"1\":{\"139\":1}}],[\"threadinfo\",{\"1\":{\"138\":2}}],[\"threadmxbean\",{\"1\":{\"138\":1}}],[\"threshold\",{\"1\":{\"59\":2,\"60\":3}}],[\"this\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"9\":12,\"15\":3,\"23\":1,\"24\":3,\"25\":5,\"35\":1,\"36\":1,\"47\":1,\"58\":1,\"59\":1,\"65\":3,\"84\":4,\"107\":1,\"131\":1,\"132\":1,\"133\":1,\"139\":1,\"165\":4,\"167\":2,\"191\":2,\"192\":2,\"214\":1,\"215\":1,\"216\":3,\"218\":4,\"221\":2,\"251\":6,\"252\":1,\"253\":1,\"280\":3,\"281\":3,\"294\":1,\"296\":3,\"307\":2,\"317\":1,\"323\":1,\"342\":4,\"352\":5,\"366\":6,\"367\":4,\"368\":10,\"528\":1,\"605\":1,\"606\":2,\"616\":3,\"627\":6,\"658\":8,\"717\":3,\"864\":2,\"876\":16,\"900\":1,\"921\":1}}],[\"truncated\",{\"0\":{\"443\":1,\"445\":1,\"446\":1},\"1\":{\"445\":1}}],[\"true表示开启追加模式\",{\"1\":{\"93\":1}}],[\"true\",{\"1\":{\"23\":2,\"24\":1,\"25\":2,\"36\":1,\"59\":1,\"71\":1,\"84\":2,\"93\":1,\"144\":1,\"165\":1,\"172\":5,\"173\":1,\"174\":2,\"191\":1,\"192\":1,\"193\":4,\"305\":1,\"363\":3,\"536\":1,\"538\":2,\"544\":3,\"623\":1,\"641\":1,\"643\":1,\"647\":1,\"659\":1,\"679\":1,\"682\":1,\"700\":2,\"701\":4,\"704\":1,\"705\":1,\"714\":2,\"715\":1,\"717\":1,\"718\":1,\"720\":1,\"737\":1,\"789\":1,\"797\":1,\"834\":3,\"889\":1,\"893\":1,\"910\":1}}],[\"triggers\",{\"1\":{\"598\":1}}],[\"trigger\",{\"1\":{\"598\":2}}],[\"trial\",{\"1\":{\"393\":2}}],[\"trip\",{\"1\":{\"384\":1}}],[\"trace\",{\"1\":{\"876\":1}}],[\"trajectory以及对应的\",{\"1\":{\"528\":1}}],[\"trajectory是在策略给定下\",{\"1\":{\"393\":1}}],[\"trajectory\",{\"1\":{\"393\":4,\"415\":1,\"416\":1,\"528\":1}}],[\"transaction\",{\"1\":{\"599\":1}}],[\"transactions\",{\"1\":{\"377\":1},\"2\":{\"390\":1}}],[\"transmission\",{\"1\":{\"382\":1}}],[\"transition\",{\"1\":{\"393\":2,\"394\":1}}],[\"transitive\",{\"1\":{\"308\":1}}],[\"transient\",{\"1\":{\"25\":4,\"58\":1,\"67\":1,\"133\":1}}],[\"trying\",{\"1\":{\"606\":1}}],[\"try\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"167\":2,\"172\":2,\"174\":2,\"199\":2,\"267\":9,\"323\":2,\"333\":1,\"374\":2,\"536\":3,\"537\":2,\"538\":1,\"543\":2,\"544\":2,\"605\":2,\"606\":1,\"613\":1,\"615\":1,\"616\":1,\"621\":1,\"622\":1,\"623\":4,\"636\":1,\"641\":1,\"643\":1,\"647\":2,\"658\":2,\"659\":1,\"682\":2,\"700\":1,\"701\":1,\"834\":1,\"889\":2,\"892\":1,\"910\":1}}],[\"treemap\",{\"0\":{\"62\":1},\"1\":{\"67\":1}}],[\"treeifybin\",{\"1\":{\"59\":1}}],[\"treeify\",{\"1\":{\"59\":1}}],[\"treenode<k\",{\"1\":{\"59\":1}}],[\"treenode\",{\"1\":{\"59\":1}}],[\"treeset<>\",{\"1\":{\"50\":2}}],[\"treeset<integer>\",{\"1\":{\"50\":2}}],[\"treeset\",{\"0\":{\"50\":1},\"1\":{\"62\":1,\"67\":1}}],[\"tomcat容器私有的类加载器\",{\"1\":{\"926\":1}}],[\"tomcat最基本的类加载器\",{\"1\":{\"926\":1}}],[\"tomcat本身也是一个java程序\",{\"1\":{\"926\":1}}],[\"tomcat需要分别去加载不同应用程序的类以及依赖\",{\"1\":{\"926\":1}}],[\"tomcat到底是如何加载和运行我们的web应用程序的\",{\"1\":{\"926\":1}}],[\"tomcat类加载机制\",{\"0\":{\"926\":1}}],[\"tomcat也自带了几个默认的servlet\",{\"1\":{\"871\":1}}],[\"tomcat还自带管理页面\",{\"1\":{\"864\":1}}],[\"tomcat会将jsp文件转换为java文件\",{\"1\":{\"864\":1}}],[\"tomcat服务器编写了一套自己的类加载机制\",{\"1\":{\"926\":1}}],[\"tomcat服务器既然要同时运行多个web应用程序\",{\"1\":{\"926\":1}}],[\"tomcat服务器会为我们提供一些默认的servlet\",{\"1\":{\"871\":1}}],[\"tomcat服务器默认是使用8080端口\",{\"1\":{\"864\":1}}],[\"tomcat服务端运行的一些依赖\",{\"1\":{\"864\":1}}],[\"tomcat\",{\"1\":{\"864\":6,\"875\":1}}],[\"tomact类加载机制\",{\"0\":{\"925\":1}}],[\"tomact\",{\"0\":{\"862\":1,\"864\":1}}],[\"topic\",{\"1\":{\"767\":1}}],[\"total\",{\"1\":{\"669\":2}}],[\"tools\",{\"1\":{\"864\":1}}],[\"tool\",{\"1\":{\"426\":1}}],[\"tocollection\",{\"1\":{\"365\":2}}],[\"tochararray\",{\"1\":{\"244\":1}}],[\"touppercase\",{\"1\":{\"354\":1}}],[\"tolowercase\",{\"1\":{\"297\":2,\"323\":2,\"354\":1}}],[\"tolist\",{\"1\":{\"71\":3,\"365\":3,\"371\":2}}],[\"tohexstring\",{\"1\":{\"215\":1,\"228\":1}}],[\"to\",{\"0\":{\"421\":1},\"1\":{\"139\":2,\"167\":1,\"307\":1,\"308\":2,\"309\":3,\"310\":1,\"341\":3,\"352\":2,\"378\":1,\"393\":1,\"394\":1,\"456\":1,\"460\":1,\"466\":1,\"472\":1,\"591\":1,\"599\":1,\"606\":3,\"669\":1,\"864\":16}}],[\"toindex\",{\"1\":{\"24\":1}}],[\"toarray\",{\"1\":{\"23\":2,\"24\":1,\"47\":2,\"365\":5}}],[\"tostring来为当前类生成预设的tostring方法\",{\"1\":{\"629\":1}}],[\"tostring\",{\"1\":{\"14\":4,\"98\":1,\"173\":1,\"215\":2,\"245\":2,\"251\":4,\"267\":1,\"275\":3,\"292\":2,\"294\":2,\"295\":1,\"307\":1,\"344\":2,\"365\":3,\"366\":1,\"368\":1,\"629\":1,\"658\":1,\"719\":1,\"735\":1,\"744\":1,\"765\":1,\"886\":1,\"889\":1,\"921\":1}}],[\"t\",{\"1\":{\"14\":10,\"15\":3,\"16\":8,\"23\":2,\"35\":3,\"36\":3,\"47\":2,\"140\":3,\"142\":2,\"144\":3,\"145\":3,\"163\":2,\"172\":7,\"281\":2,\"282\":2,\"323\":8,\"352\":7,\"359\":1,\"362\":1,\"364\":2,\"366\":4,\"367\":2,\"382\":11,\"383\":20,\"384\":12,\"385\":8,\"387\":6,\"616\":1,\"658\":3}}],[\"当dofilter方法调用时\",{\"1\":{\"920\":1}}],[\"当没有下一个过滤器时\",{\"1\":{\"920\":1}}],[\"当没有客户端连接时\",{\"1\":{\"536\":1,\"537\":1}}],[\"当满足条件时\",{\"1\":{\"908\":1}}],[\"当浏览器收到一个重定向的响应时\",{\"1\":{\"899\":1}}],[\"当建立tcp连接的三报文握手的前两部分完成后\",{\"1\":{\"859\":1}}],[\"当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时\",{\"1\":{\"842\":1}}],[\"当测试出现问题时\",{\"1\":{\"853\":1}}],[\"当测试开始前\",{\"1\":{\"802\":1}}],[\"当测试案例失败时\",{\"1\":{\"780\":1}}],[\"当条件方法位于外部类中时\",{\"1\":{\"797\":1}}],[\"当断言操作发现实际结果与预期不符时\",{\"1\":{\"786\":1}}],[\"当父级和子级都配置时\",{\"1\":{\"746\":1}}],[\"当多个cpu在操作自己的缓存时\",{\"1\":{\"705\":1}}],[\"当一级缓存中都还没有数据时\",{\"1\":{\"702\":1}}],[\"当一个线程进入到同步代码块时\",{\"1\":{\"155\":1}}],[\"当二级缓存中没有时\",{\"1\":{\"702\":1}}],[\"当到达指定时间时会自动清理所有缓存\",{\"1\":{\"701\":1}}],[\"当缓存达到上限时\",{\"1\":{\"701\":1}}],[\"当主键列不是表中的第一列的时候\",{\"1\":{\"679\":1}}],[\"当触发器表上发生select\",{\"1\":{\"598\":1}}],[\"当数据库和表为\",{\"1\":{\"591\":1}}],[\"当对方没有发送任何数据过来\",{\"1\":{\"538\":1}}],[\"当对象被判定为已经不再使用的\",{\"1\":{\"215\":1}}],[\"当对象不同时\",{\"1\":{\"155\":1}}],[\"当客户端连接后\",{\"1\":{\"538\":1}}],[\"当超过设定时间都依然没有收到客户端或是服务端的数据时\",{\"1\":{\"538\":1}}],[\"当策略是以函数的形式存在时\",{\"1\":{\"522\":1}}],[\"当策略是以表格的形式保存时\",{\"1\":{\"522\":1}}],[\"当a为静止时\",{\"1\":{\"387\":1}}],[\"当执行动作at​时\",{\"1\":{\"387\":1}}],[\"当只需要部分参数的时候需要再定义个构造函数\",{\"1\":{\"366\":1}}],[\"当i小于10时正常通过\",{\"1\":{\"322\":1}}],[\"当integer不是number的子类时\",{\"1\":{\"186\":1}}],[\"当子类实现此接口时\",{\"1\":{\"282\":1}}],[\"当代码可能出现多种类型的异常时\",{\"1\":{\"267\":1}}],[\"当程序没有按照我们理想的样子运行而出现异常时\",{\"1\":{\"267\":1}}],[\"当程序在运行时\",{\"1\":{\"16\":1}}],[\"当别人调用我们的方法时\",{\"1\":{\"266\":1}}],[\"当你使用内部类静态方法\",{\"1\":{\"254\":1}}],[\"当前数组长度为\",{\"1\":{\"236\":1}}],[\"当前类\",{\"1\":{\"121\":1}}],[\"当属性为数组\",{\"1\":{\"207\":1}}],[\"当属性为数组时呢\",{\"1\":{\"207\":1}}],[\"当属性存在默认值时\",{\"1\":{\"207\":1}}],[\"当访问private字段时\",{\"1\":{\"193\":1}}],[\"当访问权限不是public的时候\",{\"1\":{\"191\":1}}],[\"当方法是静态方法时\",{\"1\":{\"192\":1}}],[\"当方法的参数为可变参数时\",{\"1\":{\"192\":1}}],[\"当出现非public方法时\",{\"1\":{\"192\":1}}],[\"当出现多个进程需要同时运行时\",{\"1\":{\"138\":1}}],[\"当默认无参构造的权限不是public时\",{\"1\":{\"191\":1}}],[\"当类默认的构造方法被带参构造覆盖时\",{\"1\":{\"191\":1}}],[\"当货架空的时候\",{\"1\":{\"174\":1}}],[\"当其他所有的非守护线程结束之后\",{\"1\":{\"172\":1}}],[\"当其他线程调用对象的notify\",{\"1\":{\"161\":1}}],[\"当被唤醒后都没有任务时\",{\"1\":{\"167\":1}}],[\"当有新的任务时\",{\"1\":{\"167\":1}}],[\"当队列为空同时没有被关闭时\",{\"1\":{\"167\":1}}],[\"当两个线程同时读取value的时候\",{\"1\":{\"154\":1}}],[\"当线程出现异常或错误\",{\"1\":{\"143\":1}}],[\"当线程进入休眠\",{\"1\":{\"143\":1}}],[\"当等待状态结束后会回到就绪状态\",{\"1\":{\"143\":1}}],[\"当cpu给予的运行时间结束时\",{\"1\":{\"143\":1}}],[\"当需要等待外部io操作\",{\"1\":{\"142\":1}}],[\"当读取的内容数量超过\",{\"1\":{\"108\":1}}],[\"当调用\",{\"1\":{\"108\":2}}],[\"当向外部设备写入数据时\",{\"1\":{\"103\":1}}],[\"当整个链式调用完成后\",{\"1\":{\"71\":1}}],[\"当遇到大量的复杂操作时\",{\"1\":{\"71\":1}}],[\"当key存在时存在则计算并赋予新的值\",{\"1\":{\"64\":1}}],[\"当链表长度到达一定限制时\",{\"1\":{\"58\":1}}],[\"当我们希望用户登录完成之后\",{\"1\":{\"899\":1}}],[\"当我们希望一个线程等待另一个线程执行完成后再继续进行\",{\"1\":{\"148\":1}}],[\"当我们的项目依赖于其他内容时\",{\"1\":{\"841\":1}}],[\"当我们在嵌套测试中使用诸如\",{\"1\":{\"805\":1}}],[\"当我们在指定操作系统下执行时\",{\"1\":{\"793\":1}}],[\"当我们在使用变量时\",{\"1\":{\"15\":1}}],[\"当我们开启二级缓存后\",{\"1\":{\"703\":1}}],[\"当我们查询条件不同时\",{\"1\":{\"690\":1}}],[\"当我们要执行很多条语句时\",{\"1\":{\"615\":1,\"688\":1}}],[\"当我们要进行的操作非常多时\",{\"1\":{\"599\":1}}],[\"当我们需要把一个集合按照某种规则转成另外一个集合的时候\",{\"1\":{\"365\":1}}],[\"当我们需要使用复杂字符串时\",{\"1\":{\"341\":1}}],[\"当我们不想使用jshell时\",{\"1\":{\"316\":1}}],[\"当我们按下tab键还可以进行自动补全\",{\"1\":{\"316\":1}}],[\"当我们导入一个jar包作为依赖时\",{\"1\":{\"303\":1}}],[\"当我们使用非静态方法时\",{\"1\":{\"294\":1}}],[\"当我们使用同一个包中的类时\",{\"1\":{\"120\":1}}],[\"当我们字符串编辑完成之后\",{\"1\":{\"245\":1}}],[\"当我们同时去操作一个共享变量时\",{\"1\":{\"154\":1}}],[\"当我们创建对象时\",{\"1\":{\"58\":1}}],[\"当不存在对应的键值对时\",{\"1\":{\"57\":1}}],[\"当\",{\"1\":{\"57\":1,\"64\":1,\"701\":1,\"797\":2}}],[\"当做流水线处理\",{\"1\":{\"71\":1}}],[\"当做队列使用\",{\"1\":{\"43\":1}}],[\"当做一个队列来使用\",{\"1\":{\"43\":1}}],[\"当某个方法\",{\"1\":{\"14\":1}}],[\"当然如果仍然需要提交的话也可以使用commit\",{\"1\":{\"682\":1}}],[\"当然如果要导入javase的所有依赖\",{\"1\":{\"304\":1}}],[\"当然我们也可以打印到一个日志文件中\",{\"1\":{\"735\":1}}],[\"当然我们也可以将此方法设计为两个参数的形式\",{\"1\":{\"680\":1}}],[\"当然我们也可以通过反射来获取类是否为密封类型\",{\"1\":{\"347\":1}}],[\"当然这个关系哪怕只写一个mybatis也可以自动推断其他的\",{\"1\":{\"670\":1}}],[\"当然也可以直接不填这个属性\",{\"1\":{\"648\":1}}],[\"当然还支持直接转换为stream\",{\"1\":{\"323\":1}}],[\"当然除了以上的特性之外还有java\",{\"1\":{\"323\":1}}],[\"当然除了普通的exports进行包的暴露之外\",{\"1\":{\"307\":1}}],[\"当然除了上面提到的这些情况可以使用方法引用之外\",{\"1\":{\"296\":1}}],[\"当然前提是方法定义\",{\"1\":{\"258\":1}}],[\"当然不加效果也是一样的\",{\"1\":{\"203\":1}}],[\"当然在磁盘io下\",{\"1\":{\"91\":1}}],[\"当然计算哈希还是使用键\",{\"1\":{\"58\":1}}],[\"当然\",{\"1\":{\"7\":1,\"9\":3,\"14\":1,\"16\":1,\"25\":1,\"45\":1,\"50\":1,\"61\":1,\"112\":1,\"120\":2,\"218\":1,\"246\":1,\"255\":1,\"267\":1,\"281\":1,\"296\":1,\"297\":1,\"318\":1,\"340\":1,\"536\":1,\"634\":1,\"636\":1,\"649\":1,\"650\":1,\"660\":1,\"672\":1,\"716\":1,\"719\":1,\"728\":1,\"735\":1,\"746\":1,\"753\":1,\"755\":1,\"780\":1,\"796\":1,\"803\":1,\"812\":1,\"850\":1,\"854\":1,\"870\":1,\"874\":1}}],[\"24\",{\"1\":{\"908\":1,\"913\":1}}],[\"24d46ca6\",{\"1\":{\"744\":1}}],[\"28\",{\"1\":{\"736\":1,\"746\":2}}],[\"255\",{\"1\":{\"564\":1}}],[\"25565\",{\"1\":{\"538\":2}}],[\"2nf\",{\"0\":{\"554\":1}}],[\"2nf对主属性和其他属性的依赖关系产生约束\",{\"1\":{\"552\":1}}],[\"2种方法\",{\"1\":{\"423\":1}}],[\"2l−1\",{\"1\":{\"384\":1}}],[\"2mssfs​+1\",{\"1\":{\"384\":1}}],[\"2mss\",{\"1\":{\"384\":1}}],[\"2~3\",{\"1\":{\"384\":1}}],[\"2​\",{\"1\":{\"382\":1}}],[\"2+\",{\"1\":{\"382\":1}}],[\"22<\",{\"1\":{\"850\":1}}],[\"223\",{\"1\":{\"563\":2}}],[\"22\",{\"1\":{\"371\":1}}],[\"2109规范\",{\"1\":{\"909\":1}}],[\"2147483647\",{\"1\":{\"563\":1}}],[\"2147483648\",{\"1\":{\"563\":1}}],[\"21\",{\"1\":{\"371\":1}}],[\"29327\",{\"1\":{\"333\":1}}],[\"23\",{\"1\":{\"318\":1}}],[\"27<\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"27\",{\"1\":{\"219\":1}}],[\"2打印\",{\"1\":{\"147\":1,\"148\":1}}],[\"20秒内访问都会携带此cookie\",{\"1\":{\"909\":1}}],[\"2019\",{\"1\":{\"377\":1}}],[\"2001\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"200\",{\"1\":{\"366\":2,\"544\":2,\"893\":1}}],[\"2000\",{\"1\":{\"162\":1}}],[\"20\",{\"1\":{\"142\":1,\"193\":1,\"256\":1,\"258\":2,\"274\":1,\"318\":1,\"321\":3,\"322\":2,\"371\":1,\"658\":1,\"717\":1,\"789\":2,\"909\":1}}],[\"2025\",{\"1\":{\"908\":1,\"913\":1}}],[\"20250319235934\",{\"1\":{\"536\":1}}],[\"20250312005934\",{\"1\":{\"198\":1}}],[\"20250312002044\",{\"1\":{\"192\":1}}],[\"20250310170551\",{\"1\":{\"186\":1}}],[\"20250310170039\",{\"1\":{\"186\":1}}],[\"20250310165216\",{\"1\":{\"186\":1}}],[\"20250310160214\",{\"1\":{\"180\":1}}],[\"20250309155822\",{\"1\":{\"162\":1}}],[\"20250226231025\",{\"1\":{\"156\":1}}],[\"20250226223324\",{\"1\":{\"154\":1}}],[\"20250226175843\",{\"1\":{\"140\":1,\"143\":1}}],[\"20250226173747\",{\"1\":{\"138\":1}}],[\"20250225192918\",{\"1\":{\"127\":1}}],[\"20250225181159\",{\"1\":{\"103\":1}}],[\"20230306164008613\",{\"1\":{\"859\":1}}],[\"20230306163528771\",{\"1\":{\"633\":1,\"635\":1}}],[\"2021\",{\"1\":{\"725\":1}}],[\"2024\",{\"1\":{\"669\":2,\"736\":1,\"746\":2}}],[\"20240826181712\",{\"1\":{\"531\":1}}],[\"20240826181638\",{\"1\":{\"530\":1}}],[\"20240826181538\",{\"1\":{\"530\":1}}],[\"20240826181340\",{\"1\":{\"530\":1}}],[\"20240826180244\",{\"1\":{\"529\":1}}],[\"20240826173749\",{\"1\":{\"525\":1}}],[\"20240820231205\",{\"1\":{\"518\":1}}],[\"20240820231024\",{\"1\":{\"518\":1}}],[\"20240820230944\",{\"1\":{\"517\":1}}],[\"20240820230920\",{\"1\":{\"517\":1}}],[\"20240820230827\",{\"1\":{\"517\":1}}],[\"20240820184405\",{\"1\":{\"514\":1}}],[\"20240820184127\",{\"1\":{\"513\":1}}],[\"20240820181718\",{\"1\":{\"509\":1}}],[\"20240820181406\",{\"1\":{\"509\":1}}],[\"20240818182231\",{\"1\":{\"501\":1}}],[\"20240818182301\",{\"1\":{\"501\":1}}],[\"20240818182057\",{\"1\":{\"499\":1}}],[\"20240818181917\",{\"1\":{\"500\":1}}],[\"20240817000409\",{\"1\":{\"492\":1}}],[\"20240817000331\",{\"1\":{\"492\":1}}],[\"20240817000642\",{\"1\":{\"491\":1}}],[\"20240817000601\",{\"1\":{\"491\":1}}],[\"20240817000500\",{\"1\":{\"491\":1}}],[\"20240817000230\",{\"1\":{\"490\":1}}],[\"20240817000134\",{\"1\":{\"490\":1}}],[\"20240817000114\",{\"1\":{\"490\":1}}],[\"20240814230747\",{\"1\":{\"480\":1}}],[\"20240814014058\",{\"1\":{\"477\":1}}],[\"20240812010538\",{\"1\":{\"463\":1}}],[\"20240812011140\",{\"1\":{\"462\":1}}],[\"20240812004534\",{\"1\":{\"457\":1}}],[\"20240811233346\",{\"1\":{\"453\":1}}],[\"20240811011334\",{\"1\":{\"446\":1}}],[\"20240811010933\",{\"1\":{\"445\":1}}],[\"20240811002219\",{\"1\":{\"441\":1}}],[\"20240810190018\",{\"1\":{\"438\":1}}],[\"20240815234719\",{\"1\":{\"120\":1}}],[\"20240830200624\",{\"1\":{\"407\":1}}],[\"20240830200608\",{\"1\":{\"407\":1}}],[\"20240830200406\",{\"1\":{\"406\":1}}],[\"20240830200343\",{\"1\":{\"405\":1}}],[\"20240830200320\",{\"1\":{\"405\":1}}],[\"20240830200305\",{\"1\":{\"405\":1}}],[\"20240830200248\",{\"1\":{\"405\":1}}],[\"20240830200138\",{\"1\":{\"404\":1}}],[\"20240830200118\",{\"1\":{\"404\":1}}],[\"20240830200056\",{\"1\":{\"404\":1}}],[\"20240830185629\",{\"1\":{\"402\":1}}],[\"20240830185556\",{\"1\":{\"402\":1}}],[\"20240830185537\",{\"1\":{\"402\":1}}],[\"20240830185324\",{\"1\":{\"401\":1}}],[\"20240830185127\",{\"1\":{\"400\":1}}],[\"20240830184424\",{\"1\":{\"398\":1}}],[\"20240830184330\",{\"1\":{\"398\":1}}],[\"20240830184312\",{\"1\":{\"397\":1}}],[\"20240830184236\",{\"1\":{\"397\":1}}],[\"20241029001425\",{\"1\":{\"264\":1}}],[\"20241027015718\",{\"1\":{\"254\":1}}],[\"20241027015244\",{\"1\":{\"254\":1}}],[\"20241027012950\",{\"1\":{\"251\":1}}],[\"20241017002218\",{\"1\":{\"227\":1}}],[\"20241130012855\",{\"1\":{\"84\":1}}],[\"20241130005736\",{\"1\":{\"80\":1}}],[\"20241130004116\",{\"1\":{\"71\":1}}],[\"20241130001811\",{\"1\":{\"60\":1}}],[\"20241130000528\",{\"1\":{\"58\":1}}],[\"20241127001435\",{\"1\":{\"43\":1}}],[\"20241126232128\",{\"1\":{\"31\":1}}],[\"20241126232114\",{\"1\":{\"31\":1}}],[\"20241120130452\",{\"1\":{\"23\":1,\"36\":1}}],[\"20241106133211\",{\"1\":{\"15\":1}}],[\"20241106133159\",{\"1\":{\"15\":1}}],[\"20241106133117\",{\"1\":{\"15\":1}}],[\"2\",{\"0\":{\"12\":1,\"13\":1,\"28\":1,\"29\":1,\"108\":1,\"233\":1,\"314\":1,\"394\":1,\"399\":1,\"400\":1,\"401\":2,\"402\":1,\"405\":1,\"414\":1,\"416\":1,\"417\":1,\"418\":2,\"419\":1,\"420\":1,\"428\":1,\"429\":1,\"430\":2,\"431\":2,\"432\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":2,\"442\":1,\"445\":1,\"452\":1,\"454\":1,\"455\":1,\"456\":2,\"457\":1,\"458\":1,\"461\":1,\"469\":1,\"470\":1,\"471\":2,\"472\":1,\"473\":1,\"476\":1,\"485\":1,\"486\":1,\"487\":2,\"488\":1,\"491\":1,\"495\":1,\"506\":1,\"507\":1,\"510\":2,\"523\":1,\"524\":1,\"527\":2,\"560\":1,\"940\":1},\"1\":{\"14\":3,\"50\":2,\"57\":2,\"64\":2,\"71\":4,\"77\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":1,\"91\":1,\"112\":1,\"173\":2,\"239\":2,\"240\":2,\"245\":1,\"246\":2,\"274\":1,\"275\":1,\"292\":2,\"294\":2,\"295\":1,\"331\":1,\"364\":1,\"371\":1,\"382\":1,\"383\":1,\"387\":1,\"388\":1,\"436\":1,\"437\":1,\"440\":1,\"442\":1,\"444\":1,\"453\":2,\"468\":1,\"471\":1,\"475\":1,\"486\":1,\"490\":1,\"507\":1,\"508\":2,\"509\":2,\"510\":2,\"515\":1,\"516\":2,\"565\":1,\"605\":1,\"616\":1,\"622\":1,\"691\":1,\"693\":2,\"780\":1,\"805\":4,\"834\":2,\"842\":1}}],[\"泛型和多态\",{\"0\":{\"282\":1}}],[\"泛型只能确定为一个引用类型\",{\"1\":{\"281\":1}}],[\"泛型变量不止可以只有一个\",{\"1\":{\"281\":1}}],[\"泛型将数据类型的确定控制在了编译阶段\",{\"1\":{\"281\":1}}],[\"泛型在定义时并不明确是什么类型\",{\"1\":{\"281\":1}}],[\"泛型其实就一个待定类型\",{\"1\":{\"281\":1}}],[\"泛型其实仅仅是在编译阶段进行类型检查\",{\"1\":{\"16\":1}}],[\"泛型类需要使用<>\",{\"1\":{\"281\":1}}],[\"泛型类\",{\"0\":{\"281\":1}}],[\"泛型的参数获取\",{\"1\":{\"186\":1}}],[\"泛型的类型检查只存在于编译阶段\",{\"1\":{\"80\":1}}],[\"泛型通配符也支持泛型的界限\",{\"1\":{\"15\":1}}],[\"泛型界限\",{\"0\":{\"15\":1}}],[\"泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计\",{\"1\":{\"14\":1}}],[\"泛型方法会在使用时自动确定泛型类型\",{\"1\":{\"14\":1}}],[\"泛型方法\",{\"0\":{\"14\":1}}],[\"泛型\",{\"0\":{\"12\":1,\"13\":1,\"278\":1,\"279\":1}}],[\"css\",{\"1\":{\"864\":1,\"921\":1}}],[\"csrf\",{\"1\":{\"864\":2}}],[\"cst\",{\"1\":{\"669\":1}}],[\"cgi\",{\"1\":{\"864\":1}}],[\"customcondition\",{\"1\":{\"797\":2}}],[\"current\",{\"1\":{\"812\":1}}],[\"currentthread\",{\"1\":{\"140\":2,\"142\":1,\"144\":1,\"166\":1,\"167\":1,\"173\":1,\"174\":2,\"606\":1,\"765\":1}}],[\"cursor<user>\",{\"1\":{\"653\":1}}],[\"cursor<t>\",{\"1\":{\"653\":1}}],[\"cursor\",{\"1\":{\"33\":1,\"653\":2}}],[\"cdata\",{\"1\":{\"635\":2}}],[\"cj\",{\"1\":{\"605\":1,\"622\":1,\"641\":1,\"669\":1,\"721\":1,\"753\":1,\"834\":1}}],[\"ci\",{\"1\":{\"566\":1}}],[\"city\",{\"1\":{\"368\":1}}],[\"ck\",{\"1\":{\"565\":1}}],[\"cname\",{\"1\":{\"756\":5}}],[\"cno\",{\"1\":{\"596\":1}}],[\"cn\",{\"1\":{\"544\":1,\"641\":1,\"719\":1,\"908\":1,\"913\":1}}],[\"central\",{\"1\":{\"825\":1}}],[\"certain\",{\"1\":{\"522\":1}}],[\"ceiling\",{\"1\":{\"229\":1}}],[\"credentials\",{\"1\":{\"864\":1}}],[\"created\",{\"1\":{\"669\":1}}],[\"create\",{\"1\":{\"139\":1,\"561\":1,\"565\":1,\"566\":2,\"567\":1,\"589\":2,\"596\":2,\"597\":1,\"598\":1}}],[\"createstatement\",{\"1\":{\"605\":1,\"607\":1,\"613\":1,\"615\":1,\"621\":1,\"623\":4}}],[\"creates\",{\"1\":{\"139\":1}}],[\"critic\",{\"0\":{\"397\":1,\"398\":1,\"399\":1,\"403\":1,\"407\":1},\"1\":{\"397\":2}}],[\"cmax​\",{\"1\":{\"388\":1}}],[\"cycles\",{\"1\":{\"384\":1}}],[\"c1​和c2​是通过分析web浏览应用程序的实验结果确定的常数\",{\"1\":{\"384\":1}}],[\"c是光速\",{\"1\":{\"383\":1}}],[\"c4πfc​​\",{\"1\":{\"383\":1}}],[\"c>\",{\"1\":{\"281\":1}}],[\"c++实现\",{\"1\":{\"183\":1}}],[\"cpdd\",{\"1\":{\"182\":1}}],[\"cpu一般通过时间片轮转调度算法\",{\"1\":{\"138\":1}}],[\"cpu一个核心同时只能处理一件事情\",{\"1\":{\"138\":1}}],[\"catalina\",{\"1\":{\"926\":1}}],[\"catch代码块\",{\"1\":{\"629\":1}}],[\"catch\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"172\":2,\"174\":2,\"199\":2,\"267\":10,\"374\":1,\"536\":3,\"537\":2,\"543\":2,\"544\":2,\"605\":1,\"606\":1,\"613\":1,\"615\":1,\"616\":1,\"621\":1,\"622\":1,\"623\":4,\"636\":1,\"647\":1,\"658\":2,\"889\":1}}],[\"cause\",{\"1\":{\"658\":1,\"660\":1}}],[\"causes\",{\"1\":{\"139\":1}}],[\"carlo\",{\"0\":{\"449\":1,\"511\":1},\"1\":{\"449\":1,\"530\":1}}],[\"cacheenabled\",{\"1\":{\"834\":1}}],[\"cachenamespace\",{\"1\":{\"720\":1}}],[\"cachenamespace注解直接定义在接口上即可\",{\"1\":{\"720\":1}}],[\"cache\",{\"1\":{\"227\":1,\"544\":1,\"908\":1,\"913\":1}}],[\"callersensitive\",{\"1\":{\"606\":1}}],[\"callercl\",{\"1\":{\"606\":5}}],[\"caller\",{\"1\":{\"352\":1,\"606\":4}}],[\"called\",{\"1\":{\"139\":1,\"393\":1,\"455\":1,\"460\":1}}],[\"calls\",{\"1\":{\"167\":1}}],[\"cast\",{\"1\":{\"184\":1}}],[\"case后直接添加匹配值\",{\"1\":{\"340\":1}}],[\"cased\",{\"1\":{\"107\":1}}],[\"case\",{\"1\":{\"107\":1,\"338\":5,\"339\":3,\"340\":4}}],[\"cas无锁算法\",{\"1\":{\"107\":1}}],[\"cannot\",{\"1\":{\"606\":1}}],[\"can\",{\"1\":{\"415\":1,\"422\":2,\"606\":2}}],[\"cancel\",{\"1\":{\"167\":1}}],[\"cancelled\",{\"1\":{\"167\":1}}],[\"canexecute\",{\"1\":{\"98\":1}}],[\"canwrite\",{\"1\":{\"98\":1}}],[\"canread\",{\"1\":{\"98\":1}}],[\"capacity\",{\"1\":{\"25\":2,\"60\":5}}],[\"child\",{\"1\":{\"636\":3}}],[\"childnodes\",{\"1\":{\"636\":3}}],[\"chiness\",{\"1\":{\"65\":3}}],[\"checkbox\",{\"1\":{\"910\":1}}],[\"check\",{\"1\":{\"564\":2,\"565\":1,\"596\":2,\"606\":1}}],[\"checkedxxx可以将给定集合类进行包装\",{\"1\":{\"80\":1}}],[\"checkedlist\",{\"1\":{\"80\":1}}],[\"chrome\",{\"1\":{\"544\":2,\"908\":1,\"913\":1}}],[\"chromium\",{\"1\":{\"544\":1,\"913\":1}}],[\"ch\",{\"1\":{\"544\":3,\"913\":1}}],[\"choose>\",{\"1\":{\"691\":1}}],[\"choose\",{\"1\":{\"394\":1}}],[\"changed\",{\"1\":{\"864\":2}}],[\"channel\",{\"1\":{\"383\":1}}],[\"chapter\",{\"1\":{\"436\":1,\"442\":1}}],[\"chain\",{\"1\":{\"393\":1,\"921\":6}}],[\"charlie\",{\"1\":{\"371\":1}}],[\"charset=utf\",{\"1\":{\"875\":1,\"876\":1,\"881\":1,\"889\":1,\"892\":1,\"893\":1,\"908\":1,\"913\":1}}],[\"charset\",{\"1\":{\"566\":1}}],[\"charsequence\",{\"1\":{\"305\":1}}],[\"chars\",{\"1\":{\"244\":2}}],[\"character>\",{\"1\":{\"281\":1}}],[\"character\",{\"1\":{\"227\":1}}],[\"charat\",{\"1\":{\"71\":2}}],[\"char\",{\"1\":{\"91\":2,\"96\":3,\"105\":1,\"108\":8,\"112\":1,\"126\":1,\"227\":1,\"243\":1,\"244\":1,\"323\":1,\"544\":1,\"563\":1,\"808\":1}}],[\"clean命令\",{\"1\":{\"851\":1}}],[\"cleanup作用与局部变量\",{\"1\":{\"629\":1}}],[\"clear\",{\"1\":{\"23\":1,\"47\":1,\"56\":1,\"167\":1}}],[\"clientpreparedstatement\",{\"1\":{\"622\":1}}],[\"client\",{\"1\":{\"332\":1,\"333\":7,\"537\":2,\"543\":2}}],[\"clazz3\",{\"1\":{\"182\":1}}],[\"clazz2\",{\"1\":{\"182\":1}}],[\"clazz\",{\"1\":{\"182\":1,\"184\":6,\"191\":6,\"192\":10,\"199\":7,\"208\":4,\"616\":3}}],[\"class>\",{\"1\":{\"871\":1}}],[\"class>com\",{\"1\":{\"871\":1}}],[\"class模式后\",{\"1\":{\"803\":1}}],[\"class=\",{\"1\":{\"711\":1,\"834\":1,\"888\":1}}],[\"classloader\",{\"1\":{\"199\":3,\"606\":3,\"926\":5}}],[\"class<t>\",{\"1\":{\"616\":1}}],[\"class<a>\",{\"1\":{\"347\":1}}],[\"class<student>\",{\"1\":{\"191\":3,\"208\":2}}],[\"class<string\",{\"1\":{\"184\":1}}],[\"class<string>\",{\"1\":{\"182\":1,\"305\":1}}],[\"class<integer>\",{\"1\":{\"183\":2}}],[\"class<\",{\"1\":{\"182\":2,\"183\":1,\"186\":1,\"192\":3,\"199\":2,\"215\":1,\"606\":1,\"616\":1}}],[\"class对象中包含我们类的一些信息\",{\"1\":{\"180\":1}}],[\"class文件\",{\"1\":{\"180\":1,\"199\":1,\"851\":1}}],[\"classnotfoundexception\",{\"1\":{\"131\":1,\"133\":1,\"182\":1,\"192\":1,\"193\":1,\"266\":2,\"615\":1,\"622\":1,\"623\":4}}],[\"class关键字我们会在后面反射中介绍\",{\"1\":{\"80\":1}}],[\"class\",{\"0\":{\"181\":1,\"183\":1,\"184\":1,\"185\":1},\"1\":{\"4\":1,\"5\":1,\"9\":4,\"14\":1,\"15\":1,\"16\":4,\"23\":1,\"25\":3,\"36\":1,\"42\":1,\"58\":2,\"61\":1,\"65\":1,\"67\":1,\"80\":1,\"84\":4,\"117\":1,\"118\":2,\"120\":3,\"121\":2,\"131\":1,\"132\":1,\"133\":1,\"155\":6,\"165\":2,\"167\":2,\"174\":1,\"182\":4,\"183\":4,\"184\":1,\"186\":13,\"191\":7,\"192\":11,\"193\":4,\"198\":6,\"199\":5,\"206\":1,\"207\":2,\"208\":2,\"215\":1,\"216\":1,\"218\":2,\"219\":2,\"220\":1,\"221\":2,\"241\":1,\"251\":7,\"252\":2,\"253\":3,\"254\":7,\"255\":4,\"265\":2,\"280\":1,\"281\":2,\"282\":6,\"304\":1,\"305\":2,\"307\":2,\"310\":1,\"311\":1,\"323\":1,\"342\":2,\"344\":1,\"346\":2,\"347\":6,\"355\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":2,\"367\":1,\"368\":3,\"466\":1,\"537\":2,\"543\":2,\"544\":1,\"605\":4,\"606\":3,\"613\":1,\"616\":2,\"627\":2,\"643\":1,\"647\":1,\"652\":1,\"658\":1,\"659\":2,\"660\":1,\"666\":2,\"670\":2,\"672\":2,\"682\":3,\"688\":1,\"694\":1,\"700\":3,\"701\":2,\"705\":1,\"715\":1,\"717\":4,\"719\":2,\"721\":1,\"725\":1,\"727\":2,\"728\":1,\"735\":1,\"744\":1,\"754\":1,\"761\":1,\"767\":2,\"773\":1,\"776\":2,\"790\":1,\"797\":1,\"803\":3,\"805\":3,\"808\":1,\"810\":1,\"825\":2,\"834\":3,\"840\":1,\"849\":1,\"852\":1,\"871\":1,\"876\":1,\"881\":1,\"886\":1,\"888\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"910\":1,\"919\":1,\"920\":1,\"921\":2,\"922\":1}}],[\"closing\",{\"1\":{\"669\":1}}],[\"close=\",{\"1\":{\"693\":1}}],[\"closeable\",{\"1\":{\"653\":1}}],[\"closed\",{\"1\":{\"421\":1,\"864\":1}}],[\"close\",{\"1\":{\"90\":1,\"107\":2,\"536\":1,\"537\":2,\"543\":1,\"544\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"215\":1,\"220\":2,\"264\":1}}],[\"clone\",{\"1\":{\"215\":2,\"220\":6,\"264\":1,\"266\":1}}],[\"cloneable\",{\"1\":{\"25\":2,\"42\":1,\"58\":1,\"67\":1,\"220\":2}}],[\"c\",{\"1\":{\"23\":4,\"24\":3,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"47\":4,\"71\":1,\"92\":1,\"281\":3,\"319\":1,\"331\":1,\"371\":1,\"385\":1,\"387\":1,\"623\":3,\"786\":3,\"787\":1,\"789\":6,\"817\":1,\"864\":1}}],[\"ccc\",{\"1\":{\"14\":1,\"318\":2,\"371\":1,\"808\":1}}],[\"cookies\",{\"1\":{\"910\":3}}],[\"cookie消失\",{\"1\":{\"909\":1}}],[\"cookie使用的版本号\",{\"1\":{\"909\":1}}],[\"cookie失效的时间\",{\"1\":{\"909\":1}}],[\"cookie的使用路径\",{\"1\":{\"909\":1}}],[\"cookie的值\",{\"1\":{\"909\":1}}],[\"cookie的名称\",{\"1\":{\"909\":1}}],[\"cookie一旦创建\",{\"1\":{\"909\":1}}],[\"cookie\",{\"0\":{\"906\":1,\"907\":1},\"1\":{\"907\":1,\"908\":15,\"909\":1,\"910\":17,\"911\":1,\"913\":3}}],[\"copy\",{\"1\":{\"891\":1,\"892\":1}}],[\"copyofarrays\",{\"1\":{\"275\":1}}],[\"copyof\",{\"1\":{\"14\":1,\"25\":1}}],[\"could\",{\"1\":{\"606\":1}}],[\"count\",{\"1\":{\"358\":4,\"582\":3}}],[\"correct\",{\"1\":{\"606\":1}}],[\"core\",{\"1\":{\"426\":1,\"628\":1}}],[\"columns\",{\"1\":{\"669\":2}}],[\"column=\",{\"1\":{\"652\":2,\"658\":2,\"667\":8,\"668\":4,\"670\":5,\"671\":4,\"672\":9,\"715\":2,\"717\":3}}],[\"column\",{\"1\":{\"568\":2,\"652\":1,\"715\":2,\"717\":3,\"718\":2}}],[\"collate\",{\"1\":{\"566\":1}}],[\"collocations\",{\"1\":{\"75\":1}}],[\"collectstreamdemo\",{\"1\":{\"365\":1}}],[\"collectors\",{\"1\":{\"71\":3,\"365\":5,\"371\":2}}],[\"collect\",{\"1\":{\"71\":3,\"365\":6,\"371\":2}}],[\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",{\"1\":{\"693\":1}}],[\"collection=\",{\"1\":{\"693\":1,\"694\":1}}],[\"collection>\",{\"1\":{\"670\":1}}],[\"collections\",{\"0\":{\"74\":1,\"75\":1},\"1\":{\"76\":2,\"77\":1,\"78\":1,\"79\":3,\"80\":2}}],[\"collection\",{\"1\":{\"24\":2,\"47\":3,\"55\":1,\"359\":1,\"670\":1}}],[\"collection<v>\",{\"1\":{\"56\":1}}],[\"collection<\",{\"1\":{\"23\":4,\"24\":1,\"47\":4}}],[\"collection<e>\",{\"1\":{\"23\":1,\"24\":1,\"43\":1,\"47\":1}}],[\"coefficient\",{\"1\":{\"471\":1}}],[\"common\",{\"1\":{\"926\":1}}],[\"commons\",{\"1\":{\"690\":2,\"768\":1,\"891\":1}}],[\"commonpool\",{\"1\":{\"359\":1}}],[\"commit\",{\"1\":{\"599\":1,\"623\":5,\"682\":1,\"701\":1}}],[\"committed\",{\"1\":{\"599\":1}}],[\"comments\",{\"1\":{\"444\":1}}],[\"comment\",{\"1\":{\"167\":1,\"909\":1}}],[\"combinedprinter\",{\"1\":{\"354\":2}}],[\"com\",{\"1\":{\"120\":8,\"121\":1,\"192\":4,\"199\":3,\"221\":6,\"242\":1,\"246\":1,\"254\":4,\"255\":2,\"304\":1,\"307\":4,\"308\":2,\"309\":4,\"310\":7,\"311\":3,\"333\":5,\"605\":1,\"622\":1,\"641\":1,\"643\":1,\"648\":1,\"649\":2,\"652\":1,\"653\":2,\"658\":2,\"659\":2,\"660\":1,\"666\":1,\"668\":3,\"669\":3,\"670\":2,\"671\":2,\"672\":3,\"678\":1,\"679\":1,\"703\":1,\"704\":1,\"711\":2,\"712\":1,\"714\":1,\"721\":3,\"725\":1,\"736\":1,\"746\":2,\"747\":4,\"763\":1,\"825\":1,\"827\":1,\"834\":3,\"888\":2,\"909\":2}}],[\"compile命令可以将项目编译为\",{\"1\":{\"851\":1}}],[\"compile\",{\"1\":{\"833\":1,\"851\":1}}],[\"compiler\",{\"1\":{\"819\":4,\"849\":4}}],[\"compiled\",{\"1\":{\"221\":1}}],[\"compatibility\",{\"1\":{\"606\":1}}],[\"comparable<string>\",{\"1\":{\"305\":1}}],[\"comparable\",{\"1\":{\"77\":1}}],[\"comparator\",{\"1\":{\"24\":1,\"46\":1}}],[\"comparator<\",{\"1\":{\"24\":1}}],[\"comparator<integer>\",{\"1\":{\"14\":2,\"292\":1,\"294\":1}}],[\"compareto\",{\"1\":{\"294\":3,\"295\":1}}],[\"compareandset\",{\"1\":{\"107\":1}}],[\"compare方法要求返回一个int来表示两个数的大小关系\",{\"1\":{\"14\":1}}],[\"compare\",{\"1\":{\"14\":2,\"292\":3,\"294\":3}}],[\"composed\",{\"1\":{\"352\":3}}],[\"completablefuture\",{\"1\":{\"323\":1}}],[\"computeifabsent\",{\"1\":{\"64\":2}}],[\"computeifpresent\",{\"1\":{\"64\":2}}],[\"compute\",{\"1\":{\"64\":3}}],[\"conf\",{\"1\":{\"864\":1}}],[\"conf文件夹\",{\"1\":{\"827\":1}}],[\"config>\",{\"1\":{\"914\":2}}],[\"config\",{\"1\":{\"641\":4,\"643\":1,\"647\":1,\"727\":4,\"728\":1,\"756\":1,\"834\":2,\"864\":1,\"888\":4,\"889\":1}}],[\"configuration>\",{\"1\":{\"641\":1,\"834\":1,\"854\":1,\"888\":1}}],[\"configuration\",{\"1\":{\"641\":2,\"721\":9,\"834\":1,\"864\":1,\"888\":1}}],[\"condition\",{\"1\":{\"787\":1}}],[\"con\",{\"1\":{\"606\":3,\"623\":3}}],[\"connector\",{\"1\":{\"834\":1,\"850\":1,\"888\":1}}],[\"connectivity\",{\"1\":{\"604\":1}}],[\"connectionimpl\",{\"1\":{\"669\":1}}],[\"connection是数据库的连接对象\",{\"1\":{\"607\":1}}],[\"connection\",{\"1\":{\"544\":1,\"605\":3,\"606\":5,\"613\":3,\"615\":3,\"621\":3,\"622\":3,\"623\":23,\"669\":4,\"908\":2,\"913\":2}}],[\"connect\",{\"1\":{\"538\":2,\"606\":2}}],[\"convert\",{\"1\":{\"616\":2}}],[\"converges\",{\"1\":{\"472\":1}}],[\"convergence\",{\"1\":{\"432\":1}}],[\"convex问题\",{\"1\":{\"385\":1}}],[\"concepts\",{\"1\":{\"426\":1}}],[\"contain\",{\"1\":{\"864\":1}}],[\"containsvalue\",{\"1\":{\"56\":1}}],[\"containskey\",{\"1\":{\"56\":1,\"889\":2,\"910\":1}}],[\"containsall\",{\"1\":{\"23\":1,\"47\":1}}],[\"contains\",{\"1\":{\"23\":1,\"47\":1,\"361\":1}}],[\"contest\",{\"1\":{\"901\":1}}],[\"content\",{\"0\":{\"858\":1,\"862\":1,\"868\":1,\"884\":1,\"896\":1,\"906\":1,\"917\":1,\"925\":1},\"1\":{\"875\":1,\"908\":2,\"913\":2}}],[\"context\",{\"1\":{\"653\":2,\"901\":3,\"903\":3}}],[\"control\",{\"1\":{\"544\":1,\"561\":1,\"908\":1,\"913\":1}}],[\"contractive\",{\"1\":{\"432\":1}}],[\"contraction\",{\"1\":{\"427\":2,\"432\":2,\"436\":1}}],[\"contract\",{\"1\":{\"139\":1}}],[\"continuing\",{\"1\":{\"393\":1}}],[\"consolehandler会配置一个simpleformatter对象\",{\"1\":{\"738\":1}}],[\"consolehandler\",{\"1\":{\"735\":2,\"736\":2,\"746\":1,\"756\":2,\"764\":1,\"768\":2,\"864\":1}}],[\"consider\",{\"1\":{\"432\":1}}],[\"considered\",{\"1\":{\"378\":1}}],[\"constraint\",{\"1\":{\"565\":6}}],[\"constructorargs\",{\"1\":{\"717\":1}}],[\"constructorargs注解\",{\"1\":{\"717\":1}}],[\"constructor>\",{\"1\":{\"658\":2,\"717\":1}}],[\"constructor<t>\",{\"1\":{\"616\":1}}],[\"constructor<\",{\"1\":{\"192\":1}}],[\"constructor<student>\",{\"1\":{\"191\":2}}],[\"constructor\",{\"1\":{\"139\":1,\"191\":5,\"192\":2,\"616\":3,\"658\":1}}],[\"constantdesc\",{\"1\":{\"305\":1}}],[\"constable\",{\"1\":{\"305\":1}}],[\"consume\",{\"1\":{\"374\":1}}],[\"consumer接口还支持链式操作\",{\"1\":{\"354\":1}}],[\"consumer接口表示一个消费者\",{\"1\":{\"351\":1}}],[\"consumer是java\",{\"1\":{\"351\":1}}],[\"consumer\",{\"1\":{\"296\":1,\"330\":1,\"352\":2,\"354\":2}}],[\"consumer<t>\",{\"1\":{\"352\":2}}],[\"consumer<string>\",{\"1\":{\"330\":1,\"353\":1,\"354\":3}}],[\"consumer<\",{\"1\":{\"32\":1,\"35\":1,\"36\":1,\"352\":1}}],[\"consumes\",{\"1\":{\"167\":1}}],[\"code=\",{\"1\":{\"366\":1}}],[\"coder\",{\"1\":{\"296\":2}}],[\"code>\",{\"1\":{\"139\":3}}],[\"code\",{\"0\":{\"932\":1},\"1\":{\"183\":2,\"352\":6,\"366\":9,\"367\":5},\"2\":{\"10\":1,\"17\":1,\"26\":1,\"38\":1,\"51\":1,\"68\":1,\"72\":1,\"81\":1,\"85\":1,\"99\":1,\"114\":1,\"122\":1,\"134\":1,\"149\":1,\"157\":1,\"168\":1,\"175\":1,\"187\":1,\"194\":1,\"200\":1,\"209\":1,\"222\":1,\"230\":1,\"247\":1,\"259\":1,\"269\":1,\"276\":1,\"283\":1,\"298\":1,\"312\":1,\"324\":1,\"334\":1,\"348\":1,\"369\":1,\"372\":1,\"375\":1,\"539\":1,\"545\":1,\"557\":1,\"574\":1,\"592\":1,\"600\":1,\"609\":1,\"617\":1,\"624\":1,\"630\":1,\"637\":1,\"644\":1,\"654\":1,\"661\":1,\"673\":1,\"683\":1,\"695\":1,\"706\":1,\"722\":1,\"730\":1,\"739\":1,\"748\":1,\"757\":1,\"769\":1,\"781\":1,\"798\":1,\"813\":1,\"821\":1,\"828\":1,\"836\":1,\"844\":1,\"856\":1,\"860\":1,\"866\":1,\"882\":1,\"894\":1,\"904\":1,\"915\":1,\"923\":1,\"927\":1}}],[\"0表示遵循netscape的cookie规范\",{\"1\":{\"909\":1}}],[\"09\",{\"1\":{\"908\":1,\"913\":1}}],[\"07\",{\"1\":{\"908\":1,\"913\":1}}],[\"0协议\",{\"1\":{\"859\":1}}],[\"0<\",{\"1\":{\"819\":1,\"835\":1,\"840\":1,\"849\":1,\"854\":1}}],[\"0<c1​≤▽w​g\",{\"1\":{\"472\":1}}],[\"08\",{\"1\":{\"669\":1}}],[\"08001\",{\"1\":{\"606\":2}}],[\"0版本以上\",{\"1\":{\"605\":1}}],[\"03\",{\"1\":{\"580\":1,\"669\":2}}],[\"036\",{\"1\":{\"563\":2}}],[\"0≤t≤ts​\",{\"1\":{\"382\":2,\"385\":2}}],[\"0xa6\",{\"1\":{\"228\":1}}],[\"0\",{\"1\":{\"9\":1,\"14\":5,\"23\":1,\"25\":7,\"36\":1,\"48\":1,\"49\":1,\"59\":2,\"60\":4,\"64\":1,\"66\":6,\"71\":4,\"92\":1,\"94\":1,\"139\":1,\"142\":1,\"147\":3,\"148\":2,\"154\":3,\"155\":14,\"161\":2,\"172\":2,\"173\":2,\"199\":1,\"237\":1,\"239\":1,\"241\":1,\"244\":1,\"246\":5,\"266\":1,\"274\":1,\"275\":1,\"280\":1,\"292\":3,\"294\":2,\"295\":1,\"321\":3,\"322\":2,\"323\":1,\"333\":6,\"338\":2,\"355\":1,\"364\":3,\"387\":17,\"388\":1,\"393\":1,\"421\":1,\"461\":1,\"478\":1,\"543\":1,\"544\":7,\"565\":1,\"616\":2,\"634\":2,\"636\":2,\"641\":2,\"643\":2,\"745\":1,\"763\":1,\"790\":1,\"797\":1,\"807\":1,\"819\":11,\"834\":3,\"840\":10,\"849\":9,\"850\":1,\"876\":1,\"888\":3,\"908\":9,\"913\":9}}],[\"但允许执行delete操作\",{\"1\":{\"596\":1}}],[\"但允许空值\",{\"1\":{\"564\":1}}],[\"但在发表\",{\"1\":{\"518\":1}}],[\"但对于\",{\"1\":{\"516\":1}}],[\"但对象中的属性都是同一个地址\",{\"1\":{\"220\":1}}],[\"但这里还有一个难点\",{\"1\":{\"510\":1}}],[\"但实际情况可能并不是所有状态的概率都是一致的\",{\"1\":{\"508\":1}}],[\"但实际上我们往往是选择一个非常小的常数\",{\"1\":{\"472\":1}}],[\"但实际上还是遍历了20个\",{\"1\":{\"322\":1}}],[\"但实际上还是在调用本身的方法\",{\"1\":{\"216\":1}}],[\"但能否保证其精确度\",{\"1\":{\"475\":1}}],[\"但能匹配\",{\"1\":{\"246\":1}}],[\"但需要大量的\",{\"1\":{\"475\":1}}],[\"但由于\",{\"1\":{\"475\":1}}],[\"但目前无法保证\",{\"1\":{\"458\":1}}],[\"但存在一定的浪费\",{\"1\":{\"455\":1}}],[\"但现实场景中不太经常使用\",{\"1\":{\"450\":1}}],[\"但若考虑集群情况\",{\"1\":{\"388\":1}}],[\"但每个无人机所管理的用户不同\",{\"1\":{\"387\":1}}],[\"但即使仅考虑用户聚类\",{\"1\":{\"387\":1}}],[\"但功能灵活\",{\"1\":{\"371\":1}}],[\"但如果是\",{\"1\":{\"371\":1}}],[\"但\",{\"1\":{\"368\":1}}],[\"但有的时候\",{\"1\":{\"346\":1}}],[\"但并不是最好的方案\",{\"1\":{\"280\":1}}],[\"但并不是这个文件本身\",{\"1\":{\"98\":1}}],[\"但它必须是静态的\",{\"1\":{\"812\":1}}],[\"但它继承自一个现有的类或实现了一个接口\",{\"1\":{\"255\":1}}],[\"但它是为了并行执行而设计的\",{\"1\":{\"173\":1}}],[\"但类名必须与接口一致\",{\"1\":{\"255\":1}}],[\"但我们可以在方法中使用匿名内部类\",{\"1\":{\"255\":1}}],[\"但还存在\",{\"1\":{\"530\":1}}],[\"但还是先初始化内部类\",{\"1\":{\"254\":1}}],[\"但还未复制\",{\"1\":{\"9\":1}}],[\"但不能超过n\",{\"1\":{\"563\":1}}],[\"但不能匹配\",{\"1\":{\"246\":1}}],[\"但不产生任何结果\",{\"1\":{\"351\":1}}],[\"但不一定会导致致命的问题\",{\"1\":{\"264\":1}}],[\"但不推荐\",{\"1\":{\"235\":1}}],[\"但不支持\",{\"1\":{\"229\":1}}],[\"但包装类的class和基本类的class显然是不同的\",{\"1\":{\"183\":1}}],[\"但效果是一致的\",{\"1\":{\"97\":1}}],[\"但集合可以有不同种类的元素\",{\"1\":{\"22\":1}}],[\"但集合只能存放对象\",{\"1\":{\"22\":1}}],[\"但是对于tomcat容器不可见\",{\"1\":{\"926\":1}}],[\"但是对于我们人来说\",{\"1\":{\"737\":1}}],[\"但是仍然有一个问题\",{\"1\":{\"910\":1}}],[\"但是init和构造方法只会执行一次\",{\"1\":{\"872\":1}}],[\"但是idea已经自带了maven环境\",{\"1\":{\"817\":1}}],[\"但是显然直接使用注解更加方便\",{\"1\":{\"871\":1}}],[\"但是通信的双方在交换http报文之前不需要先建立http连接\",{\"1\":{\"859\":1}}],[\"但是http协议本身是无连接的\",{\"1\":{\"859\":1}}],[\"但是http协议并不会保持长连接\",{\"1\":{\"544\":1}}],[\"但是请注意默认的test命令有以下要求\",{\"1\":{\"852\":1}}],[\"但是请一定谨慎使用\",{\"1\":{\"192\":1}}],[\"但是在编译代码时无效\",{\"1\":{\"833\":1}}],[\"但是在运行时无效\",{\"1\":{\"833\":1}}],[\"但是在使用之前\",{\"1\":{\"191\":1}}],[\"但是参数可以由我们自己决定\",{\"1\":{\"808\":1}}],[\"但是会用空格替换方法名称中的下划线\",{\"1\":{\"779\":1}}],[\"但是会删除无参数方法的尾随括号\",{\"1\":{\"779\":1}}],[\"但是会话1中的数据是从缓存得到的\",{\"1\":{\"700\":1}}],[\"但是还是会有人警告你最好别这样做\",{\"1\":{\"727\":1}}],[\"但是还不够方便\",{\"1\":{\"633\":1}}],[\"但是结果却是依然能够读取\",{\"1\":{\"705\":1}}],[\"但是缓存存在一个问题\",{\"1\":{\"705\":1}}],[\"但是更安全\",{\"1\":{\"701\":1}}],[\"但是依然没有去实现service方法\",{\"1\":{\"876\":1}}],[\"但是依然没有影响会话1之中的缓存\",{\"1\":{\"700\":1}}],[\"但是依然能够正常读取\",{\"1\":{\"108\":1}}],[\"但是实际上这种情况完全可以简写为一个sql语句\",{\"1\":{\"693\":1}}],[\"但是实际上这里是完全可以进行类型推断的\",{\"1\":{\"330\":1}}],[\"但是实际上我们每次执行sql语句\",{\"1\":{\"688\":1}}],[\"但是并没有提交\",{\"1\":{\"682\":1}}],[\"但是并不会生成setter并且成员属性都是final的\",{\"1\":{\"629\":1}}],[\"但是并不能查看完整的数据库列表\",{\"1\":{\"590\":1}}],[\"但是并不是同一个对象\",{\"1\":{\"227\":1}}],[\"但是并不是所推荐的做法\",{\"1\":{\"142\":1}}],[\"但是并不是很常用\",{\"1\":{\"45\":1}}],[\"但是某些数据库\",{\"1\":{\"679\":1}}],[\"但是一般都是用于\",{\"1\":{\"870\":1}}],[\"但是一般情况下不需要手动设置\",{\"1\":{\"679\":1}}],[\"但是一定注意\",{\"1\":{\"700\":1}}],[\"但是一旦确定\",{\"1\":{\"281\":1}}],[\"但是其分页功能是对查询到的数据进行划分\",{\"1\":{\"652\":1}}],[\"但是转换的实体类数据并没有被添加上去\",{\"1\":{\"652\":1}}],[\"但是哪怕只是完成一个sql语句的执行\",{\"1\":{\"633\":1}}],[\"但是关键字非常多\",{\"1\":{\"621\":1}}],[\"但是他们目前都是在同一个小组中\",{\"1\":{\"672\":1}}],[\"但是他们之间会存在一些细微的差异\",{\"1\":{\"561\":1}}],[\"但是他们的相同和不同之处在于\",{\"1\":{\"22\":1}}],[\"但是提供技术支持\",{\"1\":{\"549\":1}}],[\"但是不会出现错误\",{\"1\":{\"641\":1}}],[\"但是不能和final\",{\"1\":{\"347\":1}}],[\"但是不允许别人写的类继承a\",{\"1\":{\"346\":1}}],[\"但是不支持继承\",{\"1\":{\"344\":1}}],[\"但是不再是object类型\",{\"1\":{\"15\":1}}],[\"但是当我们在java\",{\"1\":{\"343\":1}}],[\"但是当前作用域下只有对象属性的name变量\",{\"1\":{\"7\":1}}],[\"但是到底是a为null还是b为null呢\",{\"1\":{\"343\":1}}],[\"但是这实在是太过复杂了\",{\"1\":{\"719\":1}}],[\"但是这是一种极其不推荐的做法\",{\"1\":{\"694\":1}}],[\"但是这并不代表它们就不重要\",{\"1\":{\"599\":1}}],[\"但是这个版本instanceof加强之后\",{\"1\":{\"342\":1}}],[\"但是这样很明显是不正确的\",{\"1\":{\"705\":1}}],[\"但是这样可能还是不够方便\",{\"1\":{\"659\":1}}],[\"但是这样并不是使用return\",{\"1\":{\"340\":1}}],[\"但是这样写着就不能一气呵成了\",{\"1\":{\"297\":1}}],[\"但是这样实现的话\",{\"1\":{\"297\":1}}],[\"但是这样的写法实在是太过臃肿了\",{\"1\":{\"288\":1}}],[\"但是这样始终治标不治本\",{\"1\":{\"60\":1}}],[\"但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串\",{\"1\":{\"341\":1}}],[\"但是最终还是会变成string类型\",{\"1\":{\"328\":1}}],[\"但是java终究不像js那样进行动态推断\",{\"1\":{\"328\":1}}],[\"但是java中的基本数据类型却不是面向对象的\",{\"1\":{\"226\":1}}],[\"但是很明显我们这里给的参数是string类型的\",{\"1\":{\"323\":1}}],[\"但是很有可能导致资源不能完全释放\",{\"1\":{\"144\":1}}],[\"但是去单独进行一次null判断写起来又不太简洁\",{\"1\":{\"323\":1}}],[\"但是需要知道mybatis就是通过这种方式来读取配置文件的\",{\"1\":{\"636\":1}}],[\"但是需要引用一个完整的类库\",{\"1\":{\"303\":1}}],[\"但是需要的形式参数不一样\",{\"1\":{\"8\":1}}],[\"但是由于表名相同\",{\"1\":{\"585\":1}}],[\"但是由于我们这里a和b都调用了length\",{\"1\":{\"343\":1}}],[\"但是由于我们不清楚给进来的str到底是不是null\",{\"1\":{\"323\":1}}],[\"但是由于它们是属于同一个依赖捆绑在一起\",{\"1\":{\"303\":1}}],[\"但是由于仅仅是语法糖\",{\"1\":{\"30\":1}}],[\"但是mainobject对象并未参与进来\",{\"1\":{\"295\":1}}],[\"但是lambda却不会\",{\"1\":{\"289\":1}}],[\"但是注意这样的switch是有返回值的\",{\"1\":{\"340\":1}}],[\"但是注意语法还是和java是一样的\",{\"1\":{\"316\":1}}],[\"但是注意必须是唯一的\",{\"1\":{\"304\":1}}],[\"但是注意\",{\"1\":{\"281\":1,\"289\":1,\"318\":1,\"328\":1,\"658\":1}}],[\"但是注意两个线程必须使用同一把锁\",{\"1\":{\"155\":1}}],[\"但是编译不会报错\",{\"1\":{\"280\":1}}],[\"但是编程不可见\",{\"1\":{\"235\":1}}],[\"但是object类型在编译阶段并不具有良好的类型判断能力\",{\"1\":{\"280\":1}}],[\"但是outputstream又只支持byte类型\",{\"1\":{\"126\":1}}],[\"但是成绩分为两种\",{\"1\":{\"280\":1}}],[\"但是成绩依然可能是整数\",{\"1\":{\"15\":1}}],[\"但是要注意一下顺序\",{\"1\":{\"267\":1}}],[\"但是必须保证其他方法有默认实现\",{\"1\":{\"257\":1,\"290\":1}}],[\"但是可以直接new了\",{\"1\":{\"252\":1}}],[\"但是可以存在静态变量和静态方法\",{\"1\":{\"219\":1}}],[\"但是能匹配\",{\"1\":{\"246\":1}}],[\"但是拼接字符串实际上底层需要进行很多操作\",{\"1\":{\"245\":1}}],[\"但是只能在定义时赋值\",{\"1\":{\"235\":1}}],[\"但是biginteger没有这些限制\",{\"1\":{\"229\":1}}],[\"但是各位小伙伴只需要知道\",{\"1\":{\"227\":1}}],[\"但是它不是从远程仓库获取\",{\"1\":{\"835\":1}}],[\"但是它是第三个\",{\"1\":{\"804\":1}}],[\"但是它的作用范围实在是有限\",{\"1\":{\"700\":1}}],[\"但是它却和comparator需要实现的方法返回值和参数定义一模一样\",{\"1\":{\"292\":1}}],[\"但是它继承自enum类\",{\"1\":{\"221\":1}}],[\"但是它存在自动刷新机制\",{\"1\":{\"127\":1}}],[\"但是推荐打上\",{\"1\":{\"221\":1}}],[\"但是像这样的拷贝操作其实也分为浅拷贝和深拷贝\",{\"1\":{\"220\":1}}],[\"但是类加载器并不是只有一个\",{\"1\":{\"198\":1}}],[\"但是获取到的type的实现并不一定是class\",{\"1\":{\"186\":1}}],[\"但是前者是唤醒所有调用wait\",{\"1\":{\"161\":1}}],[\"但是又被对方牢牢把握\",{\"1\":{\"156\":1}}],[\"但是又迟迟不释放\",{\"1\":{\"156\":1}}],[\"但是class类实例同样的类无论怎么获取都是同一个\",{\"1\":{\"155\":1}}],[\"但是如果别人的项目中没有将我们不希望的依赖作为可选依赖\",{\"1\":{\"843\":1}}],[\"但是如果我把这些任务合在一起告诉数据库\",{\"1\":{\"688\":1}}],[\"但是如果我们每次上菜推一个小推车装满n个菜一起上\",{\"1\":{\"688\":1}}],[\"但是如果我们使用构造方法主动创建两个新的对象\",{\"1\":{\"244\":1}}],[\"但是如果我们在运行时\",{\"1\":{\"242\":1}}],[\"但是如果存在多个构造方法\",{\"1\":{\"658\":1}}],[\"但是如果使用$\",{\"1\":{\"648\":1}}],[\"但是如果希望向指定列上插入数据\",{\"1\":{\"571\":1}}],[\"但是如果此时我们主动将b设定为non\",{\"1\":{\"347\":1}}],[\"但是如果是null\",{\"1\":{\"323\":1}}],[\"但是如果是引用类型的话\",{\"1\":{\"238\":1}}],[\"但是如果超出这个缓存范围的话\",{\"1\":{\"227\":1}}],[\"但是如果同时写入内容\",{\"1\":{\"154\":1}}],[\"但是如果多个处理器的运算任务都涉及同一块内存区域\",{\"1\":{\"154\":1}}],[\"但是如果队列为空\",{\"1\":{\"43\":2}}],[\"但是如果队列已经为空\",{\"1\":{\"43\":2}}],[\"但是run是直接在当前线程执行\",{\"1\":{\"141\":1}}],[\"但是\",{\"1\":{\"138\":1,\"156\":1,\"236\":1,\"556\":1,\"903\":1}}],[\"但是name属性并没有保存\",{\"1\":{\"133\":1}}],[\"但是我个人认为这种说法是错的\",{\"1\":{\"219\":1}}],[\"但是我只能往一个outputstream里输出\",{\"1\":{\"126\":1}}],[\"但是我们需要一个一个去进行配置\",{\"1\":{\"918\":1}}],[\"但是我们项目中并不一定会使用这些日志框架作为mybatis的日志打印器\",{\"1\":{\"842\":1}}],[\"但是我们希望缓存能够扩展到所有会话都能使用\",{\"1\":{\"700\":1}}],[\"但是我们希望能够按字符的方式读取\",{\"1\":{\"126\":1}}],[\"但是我们不能过度使用索引\",{\"1\":{\"597\":1}}],[\"但是我们不能滥用\",{\"1\":{\"193\":1}}],[\"但是我们服务端却收到了不少的信息\",{\"1\":{\"544\":1}}],[\"但是我们的main类中压根没有这个方法\",{\"1\":{\"289\":1}}],[\"但是我们的程序并没有停止\",{\"1\":{\"167\":1}}],[\"但是我们也可以将接口实现类的对象以接口的形式去使用\",{\"1\":{\"219\":1}}],[\"但是我们明明在自己写的string类中定义了main方法\",{\"1\":{\"198\":1}}],[\"但是我们限定下界的话\",{\"1\":{\"15\":1}}],[\"但是我们发现xml配置文件读取实在是太麻烦\",{\"1\":{\"753\":1}}],[\"但是我们发现\",{\"1\":{\"9\":1,\"292\":1,\"305\":1,\"714\":1,\"900\":1,\"926\":1}}],[\"但是我们前面说了\",{\"1\":{\"4\":1}}],[\"但是同样需要有访问权限的情况下才可以\",{\"1\":{\"121\":1}}],[\"但是现在我们可以使用密封类型sealed\",{\"1\":{\"346\":1}}],[\"但是现在我们可以使用新的特性了\",{\"1\":{\"339\":1}}],[\"但是现在我们有一个需求\",{\"1\":{\"346\":1}}],[\"但是现在我们想要一个abcdabcd这样的基于原本字符串的重复字符串\",{\"1\":{\"331\":1}}],[\"但是现在我们希望依赖可以传递\",{\"1\":{\"308\":1}}],[\"但是现在支持以reader的方式进行读取\",{\"1\":{\"126\":1}}],[\"但是现在支持以writer的方式进行写入\",{\"1\":{\"126\":1}}],[\"但是现在\",{\"1\":{\"120\":1}}],[\"但是静态方法是可以访问到静态变量的\",{\"1\":{\"117\":1}}],[\"但是进行了一些额外的处理然后再调用fileinputstream的同名方法\",{\"1\":{\"107\":1}}],[\"但是每次都需要从外部i\",{\"1\":{\"103\":1}}],[\"但是学习\",{\"1\":{\"50\":1}}],[\"但是出队顺序是按照优先级来的\",{\"1\":{\"46\":1}}],[\"但是是可以正常运行的\",{\"1\":{\"719\":1}}],[\"但是是固定长度为n\",{\"1\":{\"563\":1}}],[\"但是是next方法是从后往前进行遍历的\",{\"1\":{\"44\":1}}],[\"但是是并行执行的\",{\"1\":{\"23\":1}}],[\"但是插入失败不会抛出异常\",{\"1\":{\"43\":1}}],[\"但是都是按照迭代器的标准进行了实现\",{\"1\":{\"33\":1}}],[\"但是之后的版本可以\",{\"1\":{\"25\":1}}],[\"但是仅返回类型不同\",{\"1\":{\"8\":1}}],[\"但是规则跟变量的命名差不多\",{\"1\":{\"5\":1}}],[\"而要解决以上提到的一些问题\",{\"1\":{\"926\":1}}],[\"而要修改日志的默认打印级别\",{\"1\":{\"729\":1}}],[\"而传统的类加载机制无法做到这一点\",{\"1\":{\"926\":1}}],[\"而传输到客户端时\",{\"1\":{\"859\":1}}],[\"而过滤器不允许的通过的请求\",{\"1\":{\"918\":1}}],[\"而此cookie就对应了你属于哪一个对话\",{\"1\":{\"912\":1}}],[\"而超过20秒\",{\"1\":{\"909\":1}}],[\"而请求转发则是服务器内部进行跳转\",{\"1\":{\"900\":1}}],[\"而使用我们的\",{\"1\":{\"879\":1}}],[\"而使用lombok之后\",{\"1\":{\"627\":1}}],[\"而urlpatterns和value实际上是同样功能\",{\"1\":{\"878\":1}}],[\"而每次访问都会执行的是service方法\",{\"1\":{\"872\":1}}],[\"而每一个\",{\"1\":{\"118\":1}}],[\"而具体实现由我们来编写\",{\"1\":{\"870\":1}}],[\"而具体的实现\",{\"1\":{\"218\":1}}],[\"而服务端返回给客户端的称为响应报文\",{\"1\":{\"859\":1}}],[\"而http是应用层协议\",{\"1\":{\"859\":1}}],[\"而http和tcp并不是一个层次的通信协议\",{\"1\":{\"859\":1}}],[\"而hashmap也是这样的\",{\"1\":{\"58\":1}}],[\"而版本全由父项目管理\",{\"1\":{\"850\":1}}],[\"而modelversion定义了当前模型的版本\",{\"1\":{\"819\":1}}],[\"而mybatis也会这样\",{\"1\":{\"705\":1}}],[\"而mybatis不知道该如何选择\",{\"1\":{\"658\":1}}],[\"而下面的pom\",{\"1\":{\"819\":1}}],[\"而下面这样的就存在可分割的情况\",{\"1\":{\"553\":1}}],[\"而test和main目录下又具有java\",{\"1\":{\"818\":1}}],[\"而管理相关的测试全部归为一个组\",{\"1\":{\"805\":1}}],[\"而单元测试则可以针对某一个方法直接进行测试执行\",{\"1\":{\"773\":1}}],[\"而默认情况下是未配置\",{\"1\":{\"768\":1}}],[\"而日志在打印时\",{\"1\":{\"744\":1}}],[\"而all则相反\",{\"1\":{\"729\":1}}],[\"而info级别以下的日志则会直接省略\",{\"1\":{\"728\":1}}],[\"而返回类型mybatis会自动根据方法的返回值进行判断\",{\"1\":{\"713\":1}}],[\"而可读写的缓存会\",{\"1\":{\"701\":1}}],[\"而数据库也是这样\",{\"1\":{\"688\":1}}],[\"而构造方法中没有传入的字段\",{\"1\":{\"658\":1}}],[\"而字段的赋值无论是什么构造方法\",{\"1\":{\"658\":1}}],[\"而字符串则是一系列字符的序列\",{\"1\":{\"243\":1}}],[\"而通过sqlsession就可以完成几乎所有的数据库操作\",{\"1\":{\"642\":1}}],[\"而xml主要是存放数据\",{\"1\":{\"634\":1}}],[\"而最外层有一个真正的\",{\"1\":{\"622\":1}}],[\"而最小值问题\",{\"1\":{\"478\":1}}],[\"而它就是自动生成的logger\",{\"1\":{\"767\":1}}],[\"而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换\",{\"1\":{\"616\":1}}],[\"而它的run方法会循环地读取队列中是否还有任务\",{\"1\":{\"167\":1}}],[\"而cascade会强制连带引用此列的约束\",{\"1\":{\"568\":1}}],[\"而书籍名称和书籍作者依赖于书籍编号\",{\"1\":{\"555\":1}}],[\"而学号唯一对应\",{\"1\":{\"550\":1}}],[\"而学生相对于老师就是被教授的关系\",{\"1\":{\"550\":1}}],[\"而像一个老师教多个学生的联系就是一种一对多的联系\",{\"1\":{\"550\":1}}],[\"而java就对socket底层支持进行了一套完整的封装\",{\"1\":{\"535\":1}}],[\"而对应的真实梯度可以用一个估计的梯度来替代\",{\"1\":{\"530\":1}}],[\"而对应的策略梯度上升算法就是对应\",{\"1\":{\"397\":1}}],[\"而\",{\"1\":{\"415\":1,\"444\":1,\"445\":1,\"564\":1,\"911\":1}}],[\"而密封类的作用就是限制类的继承\",{\"1\":{\"346\":1}}],[\"而记录类型本质上也是一个普通的类\",{\"1\":{\"344\":1}}],[\"而在这个过程中\",{\"1\":{\"705\":1}}],[\"而在右表中缺失的数据会使用null来代替\",{\"1\":{\"586\":1}}],[\"而在java\",{\"1\":{\"317\":1,\"318\":1}}],[\"而在引入模块机制之后\",{\"1\":{\"303\":1}}],[\"而之后创建实现类就只需要交给jvm去处理就好了\",{\"1\":{\"289\":1}}],[\"而计算机网络实验这门课是以等级进行结算\",{\"1\":{\"280\":1}}],[\"而错误是致命问题\",{\"1\":{\"264\":1}}],[\"而bigdecimal可以实现小数的精确计算\",{\"1\":{\"229\":1}}],[\"而bufferedinputstream虽然有着同样的方法\",{\"1\":{\"107\":1}}],[\"而实际项目运行时\",{\"1\":{\"833\":1}}],[\"而实际上指向的还是原来的那个对象\",{\"1\":{\"220\":1}}],[\"而实际要去启动的是真正的string类\",{\"1\":{\"198\":1}}],[\"而方法的重写是覆盖原有的方法实现\",{\"1\":{\"216\":1}}],[\"而与注释不同的是\",{\"1\":{\"203\":1}}],[\"而我们可以选择不使用这些框架或是选择其中一个即可\",{\"1\":{\"842\":1}}],[\"而我们可以通过连地址法解决这种问题\",{\"1\":{\"58\":1}}],[\"而我们又不一定能立即察觉到\",{\"1\":{\"773\":1}}],[\"而我们自己编写的类实际上是appclassloader加载的\",{\"1\":{\"198\":1}}],[\"而反射机制其实就是利用这些存放的类信息\",{\"1\":{\"181\":1}}],[\"而当货架有货物的时候\",{\"1\":{\"174\":1}}],[\"而当我们需要使用其他包中的类时\",{\"1\":{\"120\":1}}],[\"而守护线程就不一样了\",{\"1\":{\"172\":1}}],[\"而后者是看运气随机选择一个\",{\"1\":{\"161\":1}}],[\"而如果是自己定义\",{\"1\":{\"926\":1}}],[\"而如果是普通成员方法\",{\"1\":{\"155\":1}}],[\"而如果抽象类定义的是\",{\"1\":{\"218\":1}}],[\"而如果我们希望同时执行多个任务\",{\"1\":{\"138\":1}}],[\"而其他的部分实际上在任何地方编写都是一模一样的\",{\"1\":{\"289\":1}}],[\"而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容\",{\"1\":{\"155\":1}}],[\"而其他则是无序的\",{\"1\":{\"21\":1}}],[\"而这种问题\",{\"1\":{\"622\":1}}],[\"而这个变量就是类型转换之后的\",{\"1\":{\"342\":1}}],[\"而这里面就定义了大量的接口\",{\"1\":{\"604\":1}}],[\"而这里我们就通过lambda的形式给了它一个方法体\",{\"1\":{\"289\":1}}],[\"而这里定义为只在代码中\",{\"1\":{\"206\":1}}],[\"而这里的结点既存放键也存放值\",{\"1\":{\"58\":1}}],[\"而这时如果其他使用同样的锁的同步代码块也想执行内容\",{\"1\":{\"155\":1}}],[\"而进行自增操作之后\",{\"1\":{\"154\":1}}],[\"而类似这样的发送通知来告知线程需要中断\",{\"1\":{\"144\":1}}],[\"而原来保存的数据只适用于之前版本的这个类\",{\"1\":{\"132\":1}}],[\"而并非完全由readlimit确定\",{\"1\":{\"108\":1}}],[\"而缓冲流提供了缓冲机制\",{\"1\":{\"108\":1}}],[\"而缓冲流正如其名称一样\",{\"1\":{\"103\":1}}],[\"而filenotfoundexception是继承自ioexception的\",{\"1\":{\"90\":1}}],[\"而言\",{\"1\":{\"84\":1,\"444\":1}}],[\"而且也传送任何可从互联网上得到的信息\",{\"1\":{\"859\":1}}],[\"而且也不需要我们自己考虑break或是return来结束switch了\",{\"1\":{\"339\":1}}],[\"而且没有执行\",{\"1\":{\"701\":1}}],[\"而且还要知道对应的返回类型\",{\"1\":{\"659\":1}}],[\"而且语义明确\",{\"1\":{\"340\":1}}],[\"而且是\",{\"1\":{\"236\":1}}],[\"而且如果是子类\",{\"1\":{\"218\":1}}],[\"而且在更多情况下\",{\"1\":{\"199\":1}}],[\"而且我们不仅可以通过class关键字获取\",{\"1\":{\"183\":1}}],[\"而且执行不同进程会产生上下文切换\",{\"1\":{\"138\":1}}],[\"而且通过对对象的序列化操作\",{\"1\":{\"130\":1}}],[\"而且逻辑也更加清晰明了\",{\"1\":{\"71\":1}}],[\"而且接口中本身就已经定义了主要的方法\",{\"1\":{\"25\":1}}],[\"而内部维护的\",{\"1\":{\"67\":1}}],[\"而冲突时会得到一个被覆盖的值\",{\"1\":{\"60\":1}}],[\"而值就是学生信息\",{\"1\":{\"56\":1}}],[\"而双端队列允许在队列的两端进行入队和出队操作\",{\"1\":{\"44\":1}}],[\"而不需要我们再使用代码进行配置\",{\"1\":{\"756\":1}}],[\"而不需要关心集合类是如何实现\",{\"1\":{\"33\":1}}],[\"而不同的数据库厂商实现的这套标准\",{\"1\":{\"604\":1}}],[\"而不会直接存放到主内存中\",{\"1\":{\"162\":1}}],[\"而不太重要的任务\",{\"1\":{\"145\":1}}],[\"而不是包含外部类中和其他内部类中的全部测试用例\",{\"1\":{\"805\":1}}],[\"而不是失败\",{\"1\":{\"791\":1}}],[\"而不是让整个项目完全跑起来\",{\"1\":{\"773\":1}}],[\"而不是启动整个项目\",{\"1\":{\"773\":1}}],[\"而不是传统的直接打印\",{\"1\":{\"766\":1}}],[\"而不是再去向数据库进行请求\",{\"1\":{\"699\":1}}],[\"而不是预先定义好的\",{\"1\":{\"659\":1}}],[\"而不是仅考虑吞吐量\",{\"1\":{\"378\":1}}],[\"而不是char\",{\"1\":{\"305\":1}}],[\"而不是类所有的\",{\"1\":{\"251\":1}}],[\"而不是创建一个数组\",{\"1\":{\"207\":1}}],[\"而不是在对象创建的时候分配\",{\"1\":{\"118\":1}}],[\"而不是具体的某个对象\",{\"1\":{\"117\":1}}],[\"而不是字节\",{\"1\":{\"96\":1}}],[\"而不是直接执行\",{\"1\":{\"803\":1}}],[\"而不是直接向外部设备写入\",{\"1\":{\"103\":1}}],[\"而不是直接替换原文件内容\",{\"1\":{\"93\":1}}],[\"而不是直接开始执行内容\",{\"1\":{\"71\":1}}],[\"而不是进行等号判断\",{\"1\":{\"25\":1}}],[\"而不是对象本身的复制\",{\"1\":{\"4\":1}}],[\"而不是本体\",{\"1\":{\"4\":1}}],[\"而迭代器则可以将多种多样不同的集合类遍历方式进行统一\",{\"1\":{\"31\":1}}],[\"而另一些则不允许\",{\"1\":{\"21\":1}}],[\"而是再次回到webappclassloader进行加载\",{\"1\":{\"926\":1}}],[\"而是由我们通过java\",{\"1\":{\"870\":1}}],[\"而是将所有的依赖进行集中管理\",{\"1\":{\"850\":1}}],[\"而是只有一个jar怎么办呢\",{\"1\":{\"835\":1}}],[\"而是maven自动帮助我们下载依赖并导入\",{\"1\":{\"820\":1}}],[\"而是使用list内部所包含的类型\",{\"1\":{\"653\":1}}],[\"而是使用内部检查机制checkerror\",{\"1\":{\"127\":1}}],[\"而是直接导入本地jar包\",{\"1\":{\"835\":1}}],[\"而是直接使用注解在接口上进行配置呢\",{\"1\":{\"710\":1}}],[\"而是直接使用类似于\",{\"1\":{\"289\":1}}],[\"而是直接获取之前创建好的\",{\"1\":{\"700\":1}}],[\"而是直接传值\",{\"1\":{\"648\":1}}],[\"而是它们能够使得我们在不同的开发场景下\",{\"1\":{\"633\":1}}],[\"而是一口气全部交给数据库处理\",{\"1\":{\"615\":1}}],[\"而是一个参数化类型\",{\"1\":{\"186\":1}}],[\"而是等\",{\"1\":{\"516\":1}}],[\"而是yield关键字\",{\"1\":{\"340\":1}}],[\"而是需要做点什么其他的工作才能返回结果呢\",{\"1\":{\"340\":1}}],[\"而是需要到使用时才会确定对应的泛型类型\",{\"1\":{\"281\":1}}],[\"而是jdk1\",{\"1\":{\"319\":1}}],[\"而是类似\",{\"1\":{\"295\":1}}],[\"而是对应的样本\",{\"1\":{\"473\":1}}],[\"而是对应的上界\",{\"1\":{\"15\":1}}],[\"而是对象所有\",{\"1\":{\"294\":1}}],[\"而是动态进行传递\",{\"1\":{\"199\":1}}],[\"而是通过invokedynamic指令实现的\",{\"1\":{\"289\":1}}],[\"而是通过获取构造器\",{\"1\":{\"191\":1}}],[\"而是通过这个类去使用\",{\"1\":{\"117\":1}}],[\"而是通知程序做其他事情\",{\"1\":{\"144\":1}}],[\"而是在需要时才会去加载\",{\"1\":{\"118\":1}}],[\"而是在这之前就已经完成了\",{\"1\":{\"9\":1}}],[\"而是我们传入的fileinputstream\",{\"1\":{\"107\":1}}],[\"而是单独的一个体系\",{\"1\":{\"55\":1,\"56\":1}}],[\"而是按照数字的大小进行排列\",{\"1\":{\"50\":1}}],[\"而是\",{\"1\":{\"49\":1}}],[\"而非\",{\"1\":{\"9\":1}}],[\"要实现此功能\",{\"1\":{\"893\":1}}],[\"要开启日志系统\",{\"1\":{\"768\":1}}],[\"要开启二级缓存\",{\"1\":{\"701\":1}}],[\"要解决这种问题也很简单\",{\"1\":{\"658\":1}}],[\"要解决这种问题很简单\",{\"1\":{\"80\":1}}],[\"要去设计存放一个实体的表\",{\"1\":{\"552\":1}}],[\"要保持服务器一直在线\",{\"1\":{\"544\":1}}],[\"要证明加入baseline成立\",{\"1\":{\"400\":1}}],[\"要求g\",{\"1\":{\"472\":1}}],[\"要求\",{\"0\":{\"347\":1}}],[\"要求设计一个score对象\",{\"1\":{\"280\":1}}],[\"要快速使用map\",{\"1\":{\"318\":1}}],[\"要么全部不完成\",{\"1\":{\"599\":1}}],[\"要么全部完成\",{\"1\":{\"599\":1}}],[\"要么在当前函数通过\",{\"1\":{\"267\":1}}],[\"要么一直\",{\"1\":{\"267\":1}}],[\"要么就往上一级函数上\",{\"1\":{\"266\":1}}],[\"要么自己处理好\",{\"1\":{\"266\":1}}],[\"要创建一个子项目非常简单\",{\"1\":{\"849\":1}}],[\"要创建一个抽象类的实例对象\",{\"1\":{\"255\":1}}],[\"要创建一个缓冲字节流\",{\"1\":{\"105\":1}}],[\"要使用抽象类\",{\"1\":{\"218\":1}}],[\"要是由一种更简单的方式就好了\",{\"1\":{\"660\":1}}],[\"要是都不是这个类型还比什么\",{\"1\":{\"216\":1}}],[\"要是扩容之后比最大的大小还大\",{\"1\":{\"25\":1}}],[\"要是扩容之后的大小还没最小的大小大\",{\"1\":{\"25\":1}}],[\"要生成正常使用的\",{\"1\":{\"25\":1}}],[\"要注意传参问题\",{\"1\":{\"25\":1}}],[\"要给成员变量设定初始值\",{\"1\":{\"9\":1}}],[\"要在对象创建时进行处理\",{\"1\":{\"9\":1}}],[\"会继续前往第二个过滤器\",{\"1\":{\"920\":1}}],[\"会按照重定向响应给出的地址\",{\"1\":{\"899\":1}}],[\"会依次进行解包\",{\"1\":{\"859\":1}}],[\"会根据子模块的相互依赖关系整理一个build顺序\",{\"1\":{\"855\":1}}],[\"会根据eviction配置的策略进行清理\",{\"1\":{\"701\":1}}],[\"会暂时存储在本地仓库\",{\"1\":{\"826\":1}}],[\"会优先进行指定的准备工作\",{\"1\":{\"802\":1}}],[\"会话1在重复查询数据时\",{\"1\":{\"700\":1}}],[\"会话之间相互隔离\",{\"1\":{\"642\":1}}],[\"会发现得到的两个对象实际上就是同一个\",{\"1\":{\"700\":1}}],[\"会执行\",{\"1\":{\"628\":1}}],[\"会存在严重的sql注入攻击漏洞\",{\"1\":{\"622\":1}}],[\"会产生庞大的数据\",{\"1\":{\"584\":1}}],[\"会产生异常\",{\"1\":{\"186\":1}}],[\"会以别名显示此列\",{\"1\":{\"579\":1}}],[\"会抛出异常\",{\"1\":{\"538\":1}}],[\"会一直进行更新\",{\"1\":{\"516\":1}}],[\"会与环境一直交互下去\",{\"1\":{\"393\":1}}],[\"会创建一个builder\",{\"1\":{\"368\":1}}],[\"会创建很多线程\",{\"1\":{\"138\":1}}],[\"会自动向后台发送一个post请求\",{\"1\":{\"886\":1}}],[\"会自动将查询的结果转换为我们所需要的实体类\",{\"1\":{\"658\":1}}],[\"会自动生成两个临时的表\",{\"1\":{\"598\":1}}],[\"会自动执行我们预先设定的内容\",{\"1\":{\"598\":1}}],[\"会自动编译出\",{\"1\":{\"344\":1}}],[\"会自动强制转换类型为指定类型\",{\"1\":{\"342\":1}}],[\"会自动转换为红黑树\",{\"1\":{\"60\":1}}],[\"会提示\",{\"1\":{\"864\":1}}],[\"会提示找不到\",{\"1\":{\"304\":1}}],[\"会提取一个类的信息生成class对象存放在内存中\",{\"1\":{\"181\":1}}],[\"会识别\",{\"1\":{\"294\":1}}],[\"会隐式修改为\",{\"1\":{\"256\":1}}],[\"会限制其子类不允许其重写所对应的成员变量\",{\"1\":{\"217\":1}}],[\"会由jvm来调用一次此方法进行资源释放之类的操作\",{\"1\":{\"215\":1}}],[\"会报编译警告\",{\"1\":{\"204\":1}}],[\"会报编译错误\",{\"1\":{\"204\":1}}],[\"会报错\",{\"1\":{\"184\":1,\"238\":1}}],[\"会极大地降低后期维护性\",{\"1\":{\"192\":1}}],[\"会无法找到此构造方法\",{\"1\":{\"191\":1}}],[\"会更加合理\",{\"1\":{\"191\":1}}],[\"会更加合理一些\",{\"1\":{\"144\":1}}],[\"会出现问题\",{\"1\":{\"826\":1}}],[\"会出现以下报错\",{\"1\":{\"198\":1}}],[\"会出现illegalaccessexception异常\",{\"1\":{\"191\":1}}],[\"会出现instantiationexception异常\",{\"1\":{\"191\":1}}],[\"会出现异常\",{\"1\":{\"4\":1}}],[\"会将我们当前的实体类对象的id修改为得到的id\",{\"1\":{\"714\":1}}],[\"会将其划分为n个簇\",{\"1\":{\"382\":1}}],[\"会将子类的也捕获\",{\"1\":{\"267\":1}}],[\"会将类的信息提取出来\",{\"1\":{\"180\":1}}],[\"会将指定key的值进行重新计算\",{\"1\":{\"64\":1}}],[\"会将指定\",{\"1\":{\"64\":1}}],[\"会调用wait\",{\"1\":{\"167\":1}}],[\"会唤醒刚才变成等待状态的线程\",{\"1\":{\"161\":1}}],[\"会获取到当前的锁\",{\"1\":{\"155\":1}}],[\"会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作\",{\"1\":{\"144\":1}}],[\"会从运行状态回到就绪\",{\"1\":{\"143\":1}}],[\"会被变为转义形式\",{\"1\":{\"622\":1}}],[\"会被回滚\",{\"1\":{\"599\":1}}],[\"会被唤醒\",{\"1\":{\"167\":1}}],[\"会被自动添加这个属性\",{\"1\":{\"132\":1}}],[\"会被排到最后一位\",{\"1\":{\"61\":1}}],[\"会在类刚加载的时候就分配\",{\"1\":{\"118\":1}}],[\"会使用抽象方参数列表的第一个作为目标对象\",{\"1\":{\"294\":1}}],[\"会使用默认的负载因子\",{\"1\":{\"58\":1}}],[\"会使得线程的运行终止\",{\"1\":{\"143\":1}}],[\"会使得线程处于等待状态\",{\"1\":{\"143\":1}}],[\"会使得当前的读取位置回到\",{\"1\":{\"108\":1}}],[\"会直接跳转到time页面\",{\"1\":{\"910\":1}}],[\"会直接替换掉默认的\",{\"1\":{\"879\":1}}],[\"会直接复制值给拷贝对象\",{\"1\":{\"220\":1}}],[\"会直接创建这个文件\",{\"1\":{\"92\":1}}],[\"会直接抛出异常告诉我们这个测试案例没有通过\",{\"1\":{\"786\":1}}],[\"会直接抛出异常\",{\"1\":{\"43\":1,\"79\":2}}],[\"会生成一个只有一个元素的list\",{\"1\":{\"79\":1}}],[\"会先记录每一步操作\",{\"1\":{\"71\":1}}],[\"会得到\",{\"1\":{\"60\":1}}],[\"会对底层哈希表数组进行扩容\",{\"1\":{\"59\":1}}],[\"会返回\",{\"1\":{\"64\":1}}],[\"会返回原本的被覆盖值\",{\"1\":{\"59\":1}}],[\"会返回null\",{\"1\":{\"43\":2}}],[\"会转变为效率更高的红黑树结构\",{\"1\":{\"58\":1}}],[\"会变成什么类型呢\",{\"1\":{\"15\":1}}],[\"会覆盖掉默认的那一个无参构造方法\",{\"1\":{\"9\":1}}],[\"在父类加载器没有找到所请求的类的情况下\",{\"1\":{\"926\":1}}],[\"在应用程序加载的时候\",{\"1\":{\"922\":1}}],[\"在经过第一个过滤器之后\",{\"1\":{\"920\":1}}],[\"在主页界面\",{\"1\":{\"913\":1}}],[\"在主键列中\",{\"1\":{\"564\":1}}],[\"在登录界面\",{\"1\":{\"913\":1}}],[\"在登陆成功的时候\",{\"1\":{\"900\":1}}],[\"在网络上传输数据之前先将数据加密\",{\"1\":{\"909\":1}}],[\"在本地\",{\"1\":{\"908\":1}}],[\"在本文中\",{\"1\":{\"388\":1}}],[\"在本文中不考虑用户移动到其他集群的情况\",{\"1\":{\"388\":1}}],[\"在服务器端发送\",{\"1\":{\"908\":1}}],[\"在请求转发后\",{\"1\":{\"900\":1}}],[\"在点击按钮后\",{\"1\":{\"886\":1}}],[\"在阅读了httpservlet源码之后\",{\"1\":{\"876\":1}}],[\"在浏览器中访问\",{\"1\":{\"864\":1}}],[\"在build父级项目时\",{\"1\":{\"855\":1}}],[\"在之后编写springboot项目时可以解决一些缓存没更新的问题\",{\"1\":{\"851\":1}}],[\"在之前的学习中\",{\"1\":{\"710\":1}}],[\"在之前的我们的项目是这样的\",{\"1\":{\"303\":1}}],[\"在之前jdbc讲解的时候\",{\"1\":{\"688\":1}}],[\"在之前关于使用\",{\"1\":{\"479\":1}}],[\"在之前我们一直都是采用这种先判断类型\",{\"1\":{\"342\":1}}],[\"在之前\",{\"1\":{\"318\":1}}],[\"在某些情况下\",{\"1\":{\"842\":1}}],[\"在某种条件下会自动触发\",{\"1\":{\"598\":1}}],[\"在运行\",{\"1\":{\"833\":1}}],[\"在运行时动态创建\",{\"1\":{\"235\":1}}],[\"在运行时同样会进行类型检查\",{\"1\":{\"80\":1}}],[\"在下次导入依赖时\",{\"1\":{\"826\":1}}],[\"在下次读取时\",{\"1\":{\"103\":1}}],[\"在每个测试用例执行之前\",{\"1\":{\"802\":1}}],[\"在每一次迭代时\",{\"1\":{\"516\":1}}],[\"在几种情况下\",{\"1\":{\"797\":1}}],[\"在很多情况下\",{\"1\":{\"773\":1}}],[\"在默认情况下如果我们需要修改日志打印等级\",{\"1\":{\"745\":1}}],[\"在默认状态下\",{\"1\":{\"561\":1}}],[\"在后续的学习中\",{\"1\":{\"725\":1}}],[\"在后面\",{\"1\":{\"705\":1}}],[\"在后面我们会学习mybatis框架\",{\"1\":{\"616\":1}}],[\"在后面我们会详细介绍preparedstatement的使用\",{\"1\":{\"607\":1}}],[\"在多次处理相同sql时会尽可能转换为一次执行\",{\"1\":{\"688\":1}}],[\"在关闭自动提交后\",{\"1\":{\"682\":1}}],[\"在此标签内部填写需要进行一对一映射的对象属性\",{\"1\":{\"667\":1}}],[\"在此情况下\",{\"1\":{\"388\":1}}],[\"在根目录下重新创建一个mapper文件夹\",{\"1\":{\"643\":1}}],[\"在查询语句返回结果后\",{\"1\":{\"643\":1}}],[\"在最上方还引入了一个叫做dtd\",{\"1\":{\"641\":1}}],[\"在最后自动调用其close\",{\"1\":{\"629\":1}}],[\"在项目根目录下新建名为mybatis\",{\"1\":{\"641\":1}}],[\"在开始介绍mybatis之前\",{\"1\":{\"634\":1}}],[\"在前面jdbc的学习中\",{\"1\":{\"633\":1}}],[\"在以往编写项目时\",{\"1\":{\"627\":1}}],[\"在刚启动时\",{\"1\":{\"606\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"599\":1}}],[\"在update操作时\",{\"1\":{\"598\":1}}],[\"在delete操作时\",{\"1\":{\"598\":1}}],[\"在servlet处理完成之后\",{\"1\":{\"920\":1}}],[\"在select\",{\"1\":{\"598\":1}}],[\"在sleep代码中可以发现\",{\"1\":{\"143\":1}}],[\"在数据量变得非常庞大时\",{\"1\":{\"597\":1}}],[\"在数组的对象头中有一个\",{\"1\":{\"25\":1}}],[\"在满足第二范式的情况下\",{\"1\":{\"555\":1}}],[\"在得到我们响应的数据后会立即关闭tcp连接\",{\"1\":{\"544\":1}}],[\"在得到field之后\",{\"1\":{\"193\":1}}],[\"在收到响应的数据后会立即关闭tcp连接\",{\"1\":{\"544\":1}}],[\"在收集到了足够多的\",{\"1\":{\"456\":1}}],[\"在状态s采用动作a\",{\"1\":{\"527\":1}}],[\"在该策略下的所有\",{\"1\":{\"522\":1}}],[\"在该文中考虑的是网页浏览应用传输情况\",{\"1\":{\"384\":1}}],[\"在该文中\",{\"1\":{\"384\":1}}],[\"在原文是\",{\"1\":{\"518\":1}}],[\"在训练求解梯度时\",{\"1\":{\"516\":1}}],[\"在将\",{\"1\":{\"516\":1}}],[\"在计算机网络\",{\"1\":{\"859\":1}}],[\"在计算\",{\"1\":{\"516\":1}}],[\"在通过经验来更新这个策略\",{\"1\":{\"496\":1}}],[\"在这里\",{\"1\":{\"461\":1}}],[\"在这种情况下\",{\"1\":{\"186\":1,\"797\":1}}],[\"在求解\",{\"1\":{\"445\":1}}],[\"在策略更新上\",{\"1\":{\"444\":1}}],[\"在策略梯度算法中引入一个\",{\"1\":{\"400\":1}}],[\"在当前状态s下\",{\"1\":{\"422\":1}}],[\"在当前状态s下采取动作\",{\"1\":{\"422\":1}}],[\"在当前包以外的其他包中无法访问\",{\"1\":{\"121\":1}}],[\"在policy是确定的情况下\",{\"1\":{\"394\":1}}],[\"在执行一个动作后获得的一个常数\",{\"1\":{\"393\":1}}],[\"在执行完毕后会自动释放这把锁\",{\"1\":{\"155\":1}}],[\"在设计无人机的移动之前\",{\"1\":{\"388\":1}}],[\"在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为\",{\"1\":{\"383\":1}}],[\"在时间t\",{\"1\":{\"383\":1}}],[\"在任意时刻t\",{\"1\":{\"382\":1}}],[\"在初始化的时候是设为相同的\",{\"1\":{\"516\":1}}],[\"在初始化时会调用一次\",{\"1\":{\"60\":1}}],[\"在初始时间假设用户处于静止下不断调整\",{\"1\":{\"379\":1}}],[\"在构建器中\",{\"1\":{\"368\":5}}],[\"在构造时自动启动\",{\"1\":{\"167\":1}}],[\"在子类final\",{\"1\":{\"347\":1}}],[\"在比较完成的屁股后面\",{\"1\":{\"342\":1}}],[\"在低版本这样写是会直接报错的\",{\"1\":{\"323\":1}}],[\"在模块module\",{\"1\":{\"308\":1}}],[\"在程序运行之后\",{\"1\":{\"305\":1}}],[\"在调用tolowercase方法时岂不是直接空指针异常了\",{\"1\":{\"297\":1}}],[\"在创建sqlsession的时候不填写参数默认使用的就是事务模式\",{\"1\":{\"682\":1}}],[\"在创建表之前\",{\"1\":{\"567\":1}}],[\"在创建thread时\",{\"1\":{\"288\":1}}],[\"在创建了对象之后\",{\"1\":{\"4\":1}}],[\"在编写sql时\",{\"1\":{\"690\":1}}],[\"在编写代码的时候就能明确泛型的类型\",{\"1\":{\"281\":1}}],[\"在编译阶段就需要进行处理\",{\"1\":{\"264\":1}}],[\"在编译阶段无法感知代码是否会出现问题\",{\"1\":{\"264\":1}}],[\"在new的时候\",{\"1\":{\"255\":1}}],[\"在内部类中使用this关键字\",{\"1\":{\"251\":1}}],[\"在成员内部类中\",{\"1\":{\"251\":1}}],[\"在成员变量初始化之后执行\",{\"1\":{\"9\":1}}],[\"在class关键字前添加sealed关键字\",{\"1\":{\"346\":1}}],[\"在c中就是一个字符数组\",{\"1\":{\"243\":1}}],[\"在collection接口中重复定义了一次\",{\"1\":{\"36\":1}}],[\"在修改后\",{\"1\":{\"216\":1}}],[\"在修改访问权限之后\",{\"1\":{\"191\":1}}],[\"在回收之前\",{\"1\":{\"215\":1}}],[\"在接触到spring和springboot等大型框架后\",{\"1\":{\"208\":1}}],[\"在上述中有写到\",{\"1\":{\"206\":1}}],[\"在类加载时就进行创建\",{\"1\":{\"647\":1}}],[\"在类加载过程的同时\",{\"1\":{\"181\":1}}],[\"在类\",{\"1\":{\"198\":1}}],[\"在进行反射操作时\",{\"1\":{\"193\":1}}],[\"在没有了解别人代码的整个过程就强行越权访问\",{\"1\":{\"192\":1}}],[\"在一个客户程序主窗口上显示出的万维网文档称为页面\",{\"1\":{\"859\":1}}],[\"在一个项目内部在创建一个项目就行\",{\"1\":{\"849\":1}}],[\"在一个对象从构造到方法调用\",{\"1\":{\"192\":1}}],[\"在一些jdk内部的源码中\",{\"1\":{\"133\":1}}],[\"在加载过程中\",{\"1\":{\"180\":1}}],[\"在arrays数组工具类中\",{\"1\":{\"173\":1}}],[\"在集合跟接口collection中提供了一个spliterator\",{\"1\":{\"173\":1}}],[\"在守护线程中产生的新线程也是守护的\",{\"1\":{\"172\":1}}],[\"在指定时间内\",{\"1\":{\"161\":1}}],[\"在指定位置上插入元素\",{\"1\":{\"24\":1}}],[\"在使用package命令打包之前也会自动执行一次test命令\",{\"1\":{\"853\":1}}],[\"在使用opensession时直接配置executortype为batch即可\",{\"1\":{\"688\":1}}],[\"在使用之前\",{\"1\":{\"621\":1}}],[\"在使用instanceof判断类型成立后\",{\"1\":{\"342\":1}}],[\"在使用时同样需要跟上<>并在其中填写明确要使用的类型\",{\"1\":{\"281\":1}}],[\"在使用完成一个流之后\",{\"1\":{\"90\":1}}],[\"在使线程暂停的同时\",{\"1\":{\"156\":1}}],[\"在写回主内存时就会发生冲突\",{\"1\":{\"154\":1}}],[\"在继续当前内容\",{\"1\":{\"148\":1}}],[\"在i==10时\",{\"1\":{\"148\":1}}],[\"在让位之后\",{\"1\":{\"147\":1}}],[\"在junit5中\",{\"1\":{\"834\":1}}],[\"在jdk9之后\",{\"1\":{\"191\":1}}],[\"在jdk1\",{\"1\":{\"90\":1}}],[\"在javase中我们就给大家介绍过\",{\"1\":{\"853\":1}}],[\"在java\",{\"1\":{\"288\":1,\"289\":1,\"317\":1,\"319\":1,\"323\":4,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"338\":1,\"342\":1,\"344\":1,\"346\":1}}],[\"在java程序启动时\",{\"1\":{\"180\":1}}],[\"在java中\",{\"1\":{\"138\":1,\"328\":1,\"346\":1}}],[\"在早期的计算机中\",{\"1\":{\"138\":1}}],[\"在序列化时\",{\"1\":{\"132\":1}}],[\"在我们学习到springboot或是springcloud开发时\",{\"1\":{\"849\":1}}],[\"在我们项目的维护过程中\",{\"1\":{\"773\":1}}],[\"在我们后续的操作中\",{\"1\":{\"132\":1}}],[\"在我们自己定义一个构造方法之后\",{\"1\":{\"9\":1}}],[\"在不同包下的类\",{\"1\":{\"120\":1}}],[\"在放入包中\",{\"1\":{\"120\":1}}],[\"在静态方法中\",{\"1\":{\"117\":1}}],[\"在重写\",{\"1\":{\"84\":1}}],[\"在实体类中\",{\"1\":{\"368\":1}}],[\"在实际情况中\",{\"1\":{\"401\":1}}],[\"在实际应用中\",{\"1\":{\"383\":1}}],[\"在实际开发中\",{\"1\":{\"344\":1}}],[\"在实际运行时\",{\"1\":{\"80\":1}}],[\"在实现接口或是继承父类时\",{\"1\":{\"282\":1}}],[\"在实现\",{\"1\":{\"48\":1}}],[\"在外面花钱请别人帮你写公司的业务\",{\"1\":{\"67\":1}}],[\"在插入键值对时\",{\"1\":{\"61\":1}}],[\"在红黑树中插入新的结点\",{\"1\":{\"59\":1}}],[\"在队尾进行移除操作\",{\"1\":{\"44\":1}}],[\"在队尾进行插入操作\",{\"1\":{\"44\":1}}],[\"在队首进行移除操作\",{\"1\":{\"44\":1}}],[\"在队首进行插入操作\",{\"1\":{\"44\":1}}],[\"在双端队列中\",{\"1\":{\"44\":1}}],[\"在遍历过程中\",{\"1\":{\"37\":1}}],[\"在什么使用使用arraylist和linkedlist\",{\"1\":{\"25\":1}}],[\"在\",{\"1\":{\"25\":2,\"35\":1,\"48\":1,\"56\":1,\"217\":1,\"255\":1,\"266\":1,\"399\":1,\"442\":2,\"460\":1,\"512\":1,\"516\":1,\"873\":1,\"876\":2,\"888\":2,\"889\":1,\"920\":1}}],[\"在list接口中\",{\"1\":{\"24\":1}}],[\"在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法\",{\"1\":{\"14\":1}}],[\"在赋值之前看看是否有初始值\",{\"1\":{\"9\":1}}],[\"男\",{\"1\":{\"9\":2,\"216\":4,\"219\":1,\"220\":1,\"221\":1,\"613\":1}}],[\"只允许静态资源和登陆页面请求通过\",{\"1\":{\"921\":1}}],[\"只允许我们自己写的类继承a\",{\"1\":{\"346\":1}}],[\"只用作开发阶段测试使用\",{\"1\":{\"834\":1}}],[\"只在测试时有效\",{\"1\":{\"833\":1}}],[\"只仅用于测试\",{\"1\":{\"818\":1}}],[\"只启用了本地的会话缓存\",{\"1\":{\"700\":1}}],[\"只取前n个结果\",{\"1\":{\"583\":1}}],[\"只查询不重复的值\",{\"1\":{\"579\":1}}],[\"只删除指定的数据\",{\"1\":{\"573\":1}}],[\"只给出了梯度的公式\",{\"1\":{\"529\":1}}],[\"只读的缓存会给所有调用者返回相同的缓存对象\",{\"1\":{\"701\":1}}],[\"只读\",{\"1\":{\"701\":1}}],[\"只读整数\",{\"1\":{\"374\":1}}],[\"只读集合\",{\"1\":{\"79\":1}}],[\"只需添加exclusion标签即可\",{\"1\":{\"843\":1}}],[\"只需添加一个\",{\"1\":{\"776\":1}}],[\"只需添加一个无参构造或是全参构造即可\",{\"1\":{\"658\":1}}],[\"只需留下我们需要具体实现的方法体\",{\"1\":{\"289\":1}}],[\"只需要实现filter接口\",{\"1\":{\"919\":1}}],[\"只需要实现comparator方法即可\",{\"1\":{\"292\":1}}],[\"只需要调用一个方法即可\",{\"1\":{\"899\":1}}],[\"只需要组名和项目名称\",{\"1\":{\"843\":1}}],[\"只需要填写和这边一样的坐标\",{\"1\":{\"840\":1}}],[\"只需要添加\",{\"1\":{\"811\":1}}],[\"只需要添加一个\",{\"1\":{\"767\":1}}],[\"只需要添加几个注解\",{\"1\":{\"627\":1}}],[\"只需要将one或是many参数进行填写即可\",{\"1\":{\"718\":1}}],[\"只需要将原本的流作为构造参数传入bufferedinputstream即可\",{\"1\":{\"105\":1}}],[\"只需要修改usecache属性即可\",{\"1\":{\"703\":1}}],[\"只需要保证\",{\"1\":{\"400\":1}}],[\"只需要用\",{\"1\":{\"219\":1}}],[\"只需要把类文件传递即可\",{\"1\":{\"199\":1}}],[\"只需要在web\",{\"1\":{\"903\":1}}],[\"只需要在后面填写路径即可\",{\"1\":{\"864\":1}}],[\"只需要在比较后面加个变量名\",{\"1\":{\"342\":1}}],[\"只需要在stream中一气呵成\",{\"1\":{\"319\":1}}],[\"只需要在类名前面添加包名就行了\",{\"1\":{\"120\":1}}],[\"只需要在泛型变量的后面添加extends关键字即可指定上界\",{\"1\":{\"15\":1}}],[\"只需要存储\",{\"1\":{\"67\":2}}],[\"只需要各个集合类根据自己的情况进行对应实现就行了\",{\"1\":{\"31\":1}}],[\"只需要\",{\"1\":{\"5\":1}}],[\"只添加一个元素\",{\"1\":{\"193\":1}}],[\"只适用于默认无参构造\",{\"1\":{\"191\":1}}],[\"只适合打打杂\",{\"1\":{\"172\":1}}],[\"只能做调整\",{\"1\":{\"700\":1}}],[\"只能由触发器使用\",{\"1\":{\"598\":1}}],[\"只能选择其一\",{\"1\":{\"347\":1}}],[\"只能调试\",{\"1\":{\"343\":1}}],[\"只能对其进行继承\",{\"1\":{\"255\":1}}],[\"只能表示内部类对象\",{\"1\":{\"251\":1}}],[\"只能重新创建\",{\"1\":{\"236\":1,\"243\":1}}],[\"只能\",{\"1\":{\"229\":1}}],[\"只能内部使用\",{\"1\":{\"221\":1}}],[\"只能作为一个附属功能加在主体上\",{\"1\":{\"219\":1}}],[\"只能在构造函数进行赋值\",{\"1\":{\"217\":1}}],[\"只能得到\",{\"1\":{\"216\":1,\"218\":1}}],[\"只能使用这种嵌套查询来完成复杂查询操作\",{\"1\":{\"718\":1}}],[\"只能使用\",{\"1\":{\"256\":1}}],[\"只能使用匿名内部类\",{\"1\":{\"166\":1}}],[\"只能使用获取内容相关的方法\",{\"1\":{\"25\":1}}],[\"只能被类本身和同包中的其他类访问\",{\"1\":{\"121\":1}}],[\"只保留mapper相关的接口\",{\"1\":{\"710\":1}}],[\"只保留方法的定义\",{\"1\":{\"218\":1}}],[\"只保留之后的1个字符\",{\"1\":{\"108\":2}}],[\"只保留小于0的数字\",{\"1\":{\"71\":1}}],[\"只保留当前集合中在给定集合中出现的元素\",{\"1\":{\"23\":1}}],[\"只获取前10个数字\",{\"1\":{\"71\":1}}],[\"只放行前两个元素\",{\"1\":{\"71\":1}}],[\"只是反过来而已\",{\"1\":{\"586\":1}}],[\"只是反向操作\",{\"1\":{\"110\":1}}],[\"只是连接对象变成自己和自己了\",{\"1\":{\"585\":1}}],[\"只是进行了一步求解\",{\"1\":{\"445\":1}}],[\"只是求解各状态的\",{\"1\":{\"430\":1}}],[\"只是对操作进行了记录\",{\"1\":{\"357\":1}}],[\"只是借用了一下刚好匹配的方法\",{\"1\":{\"295\":1}}],[\"只是初始化了内部类的\",{\"1\":{\"254\":1}}],[\"只是数组的地址不准修改\",{\"1\":{\"239\":1}}],[\"只是语法上为了简单\",{\"1\":{\"227\":1}}],[\"只是一定程度上\",{\"1\":{\"199\":1}}],[\"只是一个表壳\",{\"1\":{\"67\":1}}],[\"只是利用反射机制实现了方法的调用\",{\"1\":{\"192\":1}}],[\"只是编程不可见\",{\"1\":{\"184\":1}}],[\"只是可以使用包装类来表示\",{\"1\":{\"183\":1}}],[\"只是不用我们去写\",{\"1\":{\"9\":1}}],[\"只有两个过滤器全部经过之后\",{\"1\":{\"920\":1}}],[\"只有过滤器允许通过的请求\",{\"1\":{\"918\":1}}],[\"只有授权的用户\",{\"1\":{\"918\":1}}],[\"只有完成登陆的用户才有资格访问首页\",{\"1\":{\"914\":1}}],[\"只有比较新的版本才支持此注解\",{\"1\":{\"871\":1}}],[\"只有commit了\",{\"1\":{\"701\":1}}],[\"只有提交之后\",{\"1\":{\"623\":1}}],[\"只有innodb引擎支持事务\",{\"1\":{\"599\":1}}],[\"只有sysadmin\",{\"1\":{\"561\":1}}],[\"只有一个参数\",{\"1\":{\"364\":1}}],[\"只有有一个元素不匹配传入的条件\",{\"1\":{\"363\":1}}],[\"只有等到终端操作的时候\",{\"1\":{\"358\":1}}],[\"只有当样本全部收集完才能估计\",{\"1\":{\"468\":1}}],[\"只有当所有\",{\"1\":{\"456\":1}}],[\"只有当所有东西都是确定性的\",{\"1\":{\"415\":1}}],[\"只有当满足条件时再开始通过\",{\"1\":{\"322\":1}}],[\"只有当对象作为锁时\",{\"1\":{\"161\":1}}],[\"只有我们明确需要的模块才会导入依赖库\",{\"1\":{\"304\":1}}],[\"只有这一个抽象方法\",{\"1\":{\"290\":1}}],[\"只有抽象类中的抽象方法\",{\"1\":{\"219\":1}}],[\"只有是当前类型的对象\",{\"1\":{\"216\":1}}],[\"只有bootstarpclassloader都没有加载的类\",{\"1\":{\"198\":1}}],[\"只有在运行的时候才知道会不会出错\",{\"1\":{\"264\":1}}],[\"只有在你使用到外部类的静态变量或方法后\",{\"1\":{\"254\":1}}],[\"只有在类不在同一个包下时才需要进行导入\",{\"1\":{\"120\":1}}],[\"只有在不存在相同键的键值对时才会存放\",{\"1\":{\"57\":1}}],[\"只有同时匹配时才移除\",{\"1\":{\"66\":1}}],[\"只有键和值都匹配时\",{\"1\":{\"66\":1}}],[\"只有可能是前面出现了相同键的情况\",{\"1\":{\"59\":1}}],[\"只会返回两个表满足条件的交集部分\",{\"1\":{\"586\":1}}],[\"只会从笛卡尔积的结果中得到满足条件的数据\",{\"1\":{\"584\":1}}],[\"只会复制对象的地址\",{\"1\":{\"220\":1}}],[\"只会存放在线程自己的工作空间中\",{\"1\":{\"162\":1}}],[\"只会删除排在前面的第一个元素\",{\"1\":{\"25\":1}}],[\"只会调用equals方法进行判断是否为指定元素\",{\"1\":{\"25\":1}}],[\"只要我们的浏览器携带此cookie访问服务器\",{\"1\":{\"912\":1}}],[\"只要我们绕过这个阶段\",{\"1\":{\"80\":1}}],[\"只要是此用户发起的请求\",{\"1\":{\"913\":1}}],[\"只要是使用这个mapper的会话\",{\"1\":{\"701\":1}}],[\"只要是实现这个接口的类\",{\"1\":{\"219\":1}}],[\"只要有一个元素匹配传入的条件\",{\"1\":{\"363\":2}}],[\"只要重写的内容中不会抛出对应的异常我们可以直接省去\",{\"1\":{\"266\":1}}],[\"只要一个类的父类或者自身有对应方法\",{\"1\":{\"219\":1}}],[\"只要判断成功\",{\"1\":{\"25\":1}}],[\"只要\",{\"1\":{\"24\":1}}],[\"只不过并没有写具体操作\",{\"1\":{\"876\":1}}],[\"只不过格式稍微有点炸裂\",{\"1\":{\"768\":1}}],[\"只不过由于idea不支持这种语法的识别\",{\"1\":{\"719\":1}}],[\"只不过使用起来和我们之前jdbc中的resultset比较类似\",{\"1\":{\"653\":1}}],[\"只不过这种操作实际上是治标不治本的\",{\"1\":{\"705\":1}}],[\"只不过这种方式查询的话\",{\"1\":{\"660\":1}}],[\"只不过这种方式在大部分请情况下还是用的比较少\",{\"1\":{\"653\":1}}],[\"只不过这和我们之前说的map不太一样\",{\"1\":{\"653\":1}}],[\"只不过这个方法并不是静态的\",{\"1\":{\"294\":1}}],[\"只不过这个锁不用你去给\",{\"1\":{\"155\":1}}],[\"只不过我们此时需要遍历所有的\",{\"1\":{\"453\":1}}],[\"只不过根据区域划分\",{\"1\":{\"387\":1}}],[\"只不过会删除其他不符合条件的\",{\"1\":{\"322\":1}}],[\"只不过默认情况下没有开启断言\",{\"1\":{\"268\":1}}],[\"只不过还能更简单\",{\"1\":{\"258\":1}}],[\"只不过意义不大\",{\"1\":{\"255\":1}}],[\"只不过它比较特殊\",{\"1\":{\"244\":1}}],[\"只不过它的用法比较特殊\",{\"1\":{\"203\":1}}],[\"只不过它只是代表这个文件\",{\"1\":{\"98\":1}}],[\"只不过它是一个双向链表\",{\"1\":{\"25\":1}}],[\"只不过它是采用的链式实现\",{\"1\":{\"25\":1}}],[\"只不过现在的方向变为我们向文件里写入内容\",{\"1\":{\"92\":1}}],[\"只不过多了一些特殊的东西\",{\"1\":{\"58\":1}}],[\"只不过hashmap中没有设计头结点\",{\"1\":{\"58\":1}}],[\"只不过对这些方法有更加特殊的定义\",{\"1\":{\"47\":1}}],[\"只不过\",{\"1\":{\"47\":1,\"660\":1}}],[\"只不过需要注意的是\",{\"1\":{\"46\":1}}],[\"只不过list也是一样的\",{\"1\":{\"43\":1}}],[\"只不过linkedlist不仅可以当做list来使用\",{\"1\":{\"25\":1}}],[\"只不过此时编译器会给出警告\",{\"1\":{\"16\":1}}],[\"只不过下界仅适用于通配符\",{\"1\":{\"15\":1}}],[\"默认时间为30分钟\",{\"1\":{\"914\":1}}],[\"默认为我们提供了很多类型的监听器\",{\"1\":{\"922\":1}}],[\"默认为false\",{\"1\":{\"909\":1}}],[\"默认为升序\",{\"1\":{\"581\":1}}],[\"默认在导入依赖时\",{\"1\":{\"842\":1}}],[\"默认建立在c盘\",{\"1\":{\"826\":1}}],[\"默认日志级别\",{\"1\":{\"727\":1}}],[\"默认获取第一个构造方法\",{\"1\":{\"616\":1}}],[\"默认并不是你创建的数据库\",{\"1\":{\"567\":1}}],[\"默认值仅在插入数据时使用\",{\"1\":{\"564\":1}}],[\"默认值为false\",{\"1\":{\"4\":1}}],[\"默认是以xml格式进行写入的\",{\"1\":{\"737\":1}}],[\"默认是restrict\",{\"1\":{\"568\":1}}],[\"默认是不传递的\",{\"1\":{\"308\":1}}],[\"默认是接收控制台输入\",{\"1\":{\"128\":1}}],[\"默认使用的就是任意ip地址\",{\"1\":{\"589\":1}}],[\"默认使用的是\",{\"1\":{\"359\":1}}],[\"默认使用\",{\"0\":{\"294\":1}}],[\"默认会让整个程序终止并打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"默认会交给\",{\"1\":{\"267\":1}}],[\"默认会返回\",{\"1\":{\"57\":1}}],[\"默认继承自\",{\"1\":{\"264\":1}}],[\"默认private\",{\"1\":{\"221\":1}}],[\"默认实现是直接用等号判断\",{\"1\":{\"215\":1}}],[\"默认只有一个属性时\",{\"1\":{\"207\":1}}],[\"默认\",{\"1\":{\"121\":2,\"205\":1,\"564\":1}}],[\"默认从小到大排序\",{\"1\":{\"71\":1}}],[\"默认情况\",{\"1\":{\"340\":1}}],[\"默认情况按照自然顺序\",{\"1\":{\"46\":1}}],[\"默认情况下会一并引入所有此项目包含的依赖项\",{\"1\":{\"841\":1}}],[\"默认情况下会认为传入的是int类型值\",{\"1\":{\"25\":1}}],[\"默认情况下为per\",{\"1\":{\"803\":1}}],[\"默认情况下一个mapper中所有的操作都会使用二级缓存\",{\"1\":{\"703\":1}}],[\"默认情况下如果不配置此项则不会进行定时清理\",{\"1\":{\"701\":1}}],[\"默认情况下别名就是类的名称\",{\"1\":{\"649\":1}}],[\"默认情况下所有的包都是私有的\",{\"1\":{\"307\":1}}],[\"默认情况下是直接导出所有的包\",{\"1\":{\"306\":1}}],[\"默认情况下直接运行什么都没有\",{\"1\":{\"242\":1}}],[\"默认情况下格式为\",{\"1\":{\"215\":1}}],[\"默认情况下\",{\"1\":{\"121\":1,\"180\":1,\"700\":1,\"738\":1,\"803\":1,\"804\":1,\"881\":1}}],[\"默认情况下包名是可以省略的\",{\"1\":{\"120\":1}}],[\"默认情况下阈值也是0\",{\"1\":{\"60\":1}}],[\"默认情况下每个类都会自带一个没有任何参数的无参构造方法\",{\"1\":{\"9\":1}}],[\"默认都是尾插\",{\"1\":{\"43\":1}}],[\"默认有一个指向集合中第一个元素的指针\",{\"1\":{\"31\":1}}],[\"默认的servlet实际上可以帮助我们去访问一些静态资源\",{\"1\":{\"871\":1}}],[\"默认的依赖有效范围\",{\"1\":{\"833\":1}}],[\"默认的情况下\",{\"1\":{\"121\":1}}],[\"默认的列表最大长度为integer\",{\"1\":{\"25\":1}}],[\"默认的数组容量\",{\"1\":{\"25\":1}}],[\"默认就是原始类型\",{\"1\":{\"16\":1}}],[\"默认就是object\",{\"1\":{\"16\":1}}],[\"并添加\",{\"1\":{\"919\":1}}],[\"并添加注解\",{\"1\":{\"871\":1}}],[\"并由其他servlet来返回结果\",{\"1\":{\"900\":1}}],[\"并放入桌面\",{\"1\":{\"864\":1}}],[\"并交由tomcat进行管理\",{\"1\":{\"864\":1}}],[\"并继续向下一层进行传递\",{\"1\":{\"859\":1}}],[\"并支持自定义种子的配置\",{\"1\":{\"804\":1}}],[\"并通过实例化对象来调用其中的测试方法\",{\"1\":{\"803\":1}}],[\"并最终以失败状态结束\",{\"1\":{\"786\":1}}],[\"并使用association标签的select属性来指定关联查询操作\",{\"1\":{\"668\":1}}],[\"并填写以下内容\",{\"1\":{\"641\":1,\"643\":1}}],[\"并得到结果集\",{\"1\":{\"605\":1}}],[\"并获得奖励rt​的这一过程可以用条件转移概率p\",{\"1\":{\"387\":1}}],[\"并与传统的基于遗传的学习算法进行对比\",{\"1\":{\"379\":1}}],[\"并具有和实体类一致的属性\",{\"1\":{\"368\":1}}],[\"并根据后端响应的结果\",{\"1\":{\"893\":1}}],[\"并根据反馈进行调整\",{\"1\":{\"337\":1}}],[\"并根据实际需求扩展出新的行为\",{\"1\":{\"212\":1}}],[\"并转换为stream进行操作\",{\"1\":{\"331\":2}}],[\"并在请求中完成动态更新\",{\"1\":{\"893\":1}}],[\"并在当前位置打开cmd窗口\",{\"1\":{\"864\":1}}],[\"并在方法内编写我们的需要进行测试的代码\",{\"1\":{\"776\":1}}],[\"并在方法体内定义具体的操作\",{\"1\":{\"353\":1}}],[\"并在数据库中添加用于存放数据的表\",{\"1\":{\"551\":1}}],[\"并在src目录下\",{\"1\":{\"304\":1}}],[\"并在控制台打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"并直接创建实例对象\",{\"1\":{\"255\":1}}],[\"并没有再次请求新的url\",{\"1\":{\"900\":1}}],[\"并没有进行依赖传递\",{\"1\":{\"308\":1}}],[\"并没有初始化内部类\",{\"1\":{\"254\":1}}],[\"并没有考虑到多线程运行的情况\",{\"1\":{\"173\":1}}],[\"并返回一个新的子串对象\",{\"1\":{\"244\":1}}],[\"并提供对外访问的接口\",{\"1\":{\"212\":1}}],[\"并非是某种特殊的计算机网络\",{\"1\":{\"859\":1}}],[\"并非是所对应的对象本身\",{\"1\":{\"4\":1}}],[\"并非只是一个单一的轨迹\",{\"1\":{\"393\":1}}],[\"并非java定义\",{\"1\":{\"183\":1}}],[\"并行流\",{\"1\":{\"173\":2}}],[\"并打印出了相关线程的栈追踪信息\",{\"1\":{\"156\":1}}],[\"并发会用到\",{\"1\":{\"107\":1}}],[\"并且所有的请求都没有任何的响应内容\",{\"1\":{\"919\":1}}],[\"并且过滤器可以添加很多个\",{\"1\":{\"918\":1}}],[\"并且请求的信息全部被转交给另一个servlet\",{\"1\":{\"900\":1}}],[\"并且请求转发只能转发到此应用程序内部的servlet\",{\"1\":{\"900\":1}}],[\"并且响应头中添加了一个location属性\",{\"1\":{\"899\":1}}],[\"并且携带了表单中文本框的数据\",{\"1\":{\"886\":1}}],[\"并且数字的大小决定了此servlet的启动优先级\",{\"1\":{\"881\":1}}],[\"并且它已经帮助我们提前实现了一些操作\",{\"1\":{\"876\":1}}],[\"并且在下次请求时\",{\"1\":{\"907\":1}}],[\"并且在连接已经建立的过程中\",{\"1\":{\"859\":1}}],[\"并且在mybatis每个操作都配置flushcache为true来保证刷新\",{\"1\":{\"705\":1}}],[\"并且每个参数都会进行一次测试\",{\"1\":{\"808\":1}}],[\"并且每个学生的所有属性都依赖于学号\",{\"1\":{\"554\":1}}],[\"并且当每一次执行都没有出现问题时\",{\"1\":{\"807\":1}}],[\"并且\",{\"1\":{\"803\":1}}],[\"并且都开启了缓存\",{\"1\":{\"705\":1}}],[\"并且sid并没有发生改变\",{\"1\":{\"705\":1}}],[\"并且使用\",{\"1\":{\"622\":1}}],[\"并且可以反复使用\",{\"1\":{\"599\":1}}],[\"并且可以在管道的节点上进行处理\",{\"1\":{\"71\":1}}],[\"并且内层查询的from子句中涉及的表也是导出该视图的基本表\",{\"1\":{\"596\":1}}],[\"并且不能为空\",{\"1\":{\"564\":1}}],[\"并且需要使用\",{\"1\":{\"561\":1}}],[\"并且如果按照这样一个策略\",{\"1\":{\"460\":1}}],[\"并且与状态\",{\"1\":{\"422\":1}}],[\"并且返回值是构建器本身\",{\"1\":{\"368\":1}}],[\"并且tostring也是被重写了的\",{\"1\":{\"344\":1}}],[\"并且var关键字仅适用于局部变量\",{\"1\":{\"328\":1}}],[\"并且此方法只能被接口中的其他私有方法或是默认实现调用\",{\"1\":{\"317\":1}}],[\"并且无需花括号\",{\"1\":{\"290\":1}}],[\"并且接口没有继承数量限制\",{\"1\":{\"219\":1}}],[\"并且默认在类中实现的权限是\",{\"1\":{\"219\":1}}],[\"并且也导入了我们自己定义的string类\",{\"1\":{\"120\":1}}],[\"并且同样支持try\",{\"1\":{\"92\":1}}],[\"并且方法名称与类名相同\",{\"1\":{\"9\":2}}],[\"并将我们刚才下载的文件又上传给服务端\",{\"1\":{\"892\":1}}],[\"并将结果响应给用户\",{\"1\":{\"872\":1}}],[\"并将其绑定到一个接口上\",{\"1\":{\"710\":1}}],[\"并将其保留到运行时\",{\"1\":{\"206\":1}}],[\"并将字符串转换为字符\",{\"1\":{\"127\":1}}],[\"并将下一个元素作为待遍历元素\",{\"1\":{\"32\":1}}],[\"并将元素替换为处理之后的结果\",{\"1\":{\"24\":1}}],[\"并不编写方法的主体\",{\"1\":{\"218\":1}}],[\"并不一定真实的数据量就是这么多\",{\"1\":{\"91\":1}}],[\"并不会立即执行\",{\"1\":{\"357\":1}}],[\"并不会去释放任何锁资源\",{\"1\":{\"156\":1}}],[\"并不会在一开始就去加载它\",{\"1\":{\"118\":1}}],[\"并不会真的进行类型检查\",{\"1\":{\"80\":1}}],[\"并不会真的去检查对应类型\",{\"1\":{\"16\":1}}],[\"并不会维持插入的顺序\",{\"1\":{\"61\":1}}],[\"并不是为了一定要去使用它\",{\"1\":{\"633\":1}}],[\"并不是真实存在的\",{\"1\":{\"596\":1}}],[\"并不是一直进行更新\",{\"1\":{\"516\":1}}],[\"并不是说只有抽象类和接口才可以像这样创建匿名内部类\",{\"1\":{\"255\":1}}],[\"并不是说一定优先级越高的线程越先执行\",{\"1\":{\"145\":1}}],[\"并不是基本数据类型\",{\"1\":{\"235\":1}}],[\"并不是包装类型\",{\"1\":{\"183\":1}}],[\"并不是所有的类都会在一开始加载\",{\"1\":{\"180\":1}}],[\"并不是我们实际list中的顺序\",{\"1\":{\"173\":1}}],[\"并不是将另一个线程和当前线程合并\",{\"1\":{\"148\":1}}],[\"并不是创建一个线程执行\",{\"1\":{\"141\":1}}],[\"并不是写入的字符串\",{\"1\":{\"129\":1}}],[\"并不是\",{\"1\":{\"55\":1}}],[\"并不是在构造方法之后\",{\"1\":{\"9\":1}}],[\"来加载类\",{\"1\":{\"926\":1}}],[\"来加载驱动类\",{\"1\":{\"605\":1}}],[\"来判断是否登录\",{\"1\":{\"913\":1}}],[\"来开启启动时加载\",{\"1\":{\"881\":1}}],[\"来让我们处理用户的请求\",{\"1\":{\"872\":1}}],[\"来让我们更优雅的处理空指针异常\",{\"1\":{\"297\":1}}],[\"来测试一下是否能直接访问\",{\"1\":{\"871\":1}}],[\"来运行我们编写的\",{\"1\":{\"870\":1}}],[\"来更加合理地对项目中代码进行职责划分\",{\"1\":{\"849\":1}}],[\"来更新参数值\",{\"1\":{\"516\":1}}],[\"来做到全方面的问题排查\",{\"1\":{\"808\":1}}],[\"来做事\",{\"1\":{\"67\":1}}],[\"来确保之前的功能没有因为后续的修改而出现问题\",{\"1\":{\"773\":1}}],[\"来继承formatter\",{\"1\":{\"761\":1}}],[\"来一次性提交之前是所有批处理操作\",{\"1\":{\"688\":1}}],[\"来强制提交\",{\"1\":{\"682\":1}}],[\"来有效地防止sql注入问题\",{\"1\":{\"648\":1}}],[\"来填入我们给定的属性\",{\"1\":{\"648\":1}}],[\"来手动回滚之前的全部操作\",{\"1\":{\"623\":1}}],[\"来提交事务的话\",{\"1\":{\"623\":1}}],[\"来提升当前策略\",{\"1\":{\"440\":1}}],[\"来将我们输入的内容进行包裹\",{\"1\":{\"622\":1}}],[\"来获取到此对象\",{\"1\":{\"901\":1}}],[\"来获取所有的系统属性\",{\"1\":{\"795\":1}}],[\"来获取每一列的数据\",{\"1\":{\"614\":1}}],[\"来获取\",{\"1\":{\"608\":1}}],[\"来获取类的信息和操作类\",{\"1\":{\"181\":1}}],[\"来执行任意的sql语句\",{\"1\":{\"608\":1}}],[\"来分析我们设定的驱动是否可以连接\",{\"1\":{\"606\":1}}],[\"来限制用户登录的登录ip地址\",{\"1\":{\"589\":1}}],[\"来编写注释内容\",{\"1\":{\"561\":1}}],[\"来连接我们本地端口的服务器\",{\"1\":{\"544\":1}}],[\"来定义最优的策略\",{\"1\":{\"522\":1}}],[\"来近似\",{\"1\":{\"511\":1,\"512\":1}}],[\"来进行重定向操作外\",{\"1\":{\"899\":1}}],[\"来进行提交\",{\"1\":{\"886\":1}}],[\"来进行动态网页响应\",{\"1\":{\"870\":1}}],[\"来进行访问\",{\"1\":{\"864\":1}}],[\"来进行转义\",{\"1\":{\"653\":1}}],[\"来进行操作保证安全性\",{\"1\":{\"648\":1}}],[\"来进行数据库的链接\",{\"1\":{\"606\":1}}],[\"来进行多行注释\",{\"1\":{\"561\":1}}],[\"来进行求解\",{\"1\":{\"451\":1}}],[\"来进行迭代\",{\"1\":{\"387\":1}}],[\"来保证项目能够正常运行\",{\"1\":{\"853\":1}}],[\"来保证这个梯度的方差最小即可\",{\"1\":{\"400\":1}}],[\"来保证数据正确写入到硬盘文件中\",{\"1\":{\"92\":1}}],[\"来表示此表单用于文件传输\",{\"1\":{\"892\":1}}],[\"来表示\",{\"1\":{\"387\":1}}],[\"来最大化mos总和\",{\"1\":{\"387\":1}}],[\"来考虑无人机的机动性\",{\"1\":{\"378\":1}}],[\"来初始化你的实例对象\",{\"1\":{\"368\":1}}],[\"来辅助设计\",{\"1\":{\"368\":1}}],[\"来看一下\",{\"1\":{\"365\":1}}],[\"来并行执行操作\",{\"1\":{\"356\":1}}],[\"来返回如果匹配此case语句的结果\",{\"1\":{\"340\":1}}],[\"来迭代生成数据\",{\"0\":{\"321\":1}}],[\"来自浏览器的所有访问请求都会首先经过过滤器\",{\"1\":{\"918\":1}}],[\"来自同一个浏览器的所有请求\",{\"1\":{\"911\":1}}],[\"来自jdk和jre的模块\",{\"1\":{\"306\":1}}],[\"来自定义排序规则\",{\"1\":{\"14\":1}}],[\"来个数组\",{\"1\":{\"292\":1}}],[\"来指定具体的在新的线程中要执行的任务\",{\"1\":{\"288\":1}}],[\"来作为结果\",{\"1\":{\"280\":1}}],[\"来处理\",{\"1\":{\"267\":1}}],[\"来快速创建不解析区域\",{\"1\":{\"635\":1}}],[\"来快速添加注释文本\",{\"1\":{\"634\":1}}],[\"来快速获取我们标记的注解\",{\"1\":{\"208\":1}}],[\"来快速编写代码\",{\"1\":{\"71\":1}}],[\"来调用已经获取到的方法\",{\"1\":{\"192\":1}}],[\"来创建一个子项目\",{\"1\":{\"849\":1}}],[\"来创建对象实例\",{\"1\":{\"191\":1}}],[\"来创建工作内存中的变量\",{\"1\":{\"162\":1}}],[\"来实例化对象\",{\"1\":{\"191\":1}}],[\"来实现具体对应方法的请求\",{\"1\":{\"876\":1}}],[\"来实现这个功能\",{\"1\":{\"346\":1}}],[\"来实现类的能力复用\",{\"1\":{\"346\":1}}],[\"来实现\",{\"1\":{\"218\":1}}],[\"来实现多个进程的同时运行\",{\"1\":{\"138\":1}}],[\"来实现更加方便的操作\",{\"1\":{\"126\":1}}],[\"来模拟一个餐厅的2个厨师和3个顾客\",{\"1\":{\"174\":1}}],[\"来支持对象类型的io\",{\"1\":{\"130\":1}}],[\"来完成\",{\"1\":{\"9\":1}}],[\"来明确表示当前类的示例对象本身\",{\"1\":{\"7\":1}}],[\"bb\",{\"1\":{\"808\":1}}],[\"bbb\",{\"1\":{\"14\":1,\"43\":1,\"44\":1,\"245\":1,\"318\":4,\"340\":1,\"371\":1,\"812\":2}}],[\"btree\",{\"1\":{\"597\":1}}],[\"bcnf作为第三范式的补充\",{\"1\":{\"556\":1}}],[\"bcnf\",{\"0\":{\"556\":1}}],[\"bcnf则是对主键的选取进行唯一确定\",{\"1\":{\"552\":1}}],[\"bgd\",{\"0\":{\"480\":1},\"1\":{\"475\":1}}],[\"browser\",{\"1\":{\"864\":2}}],[\"broad\",{\"1\":{\"466\":1}}],[\"br\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"brand\",{\"1\":{\"544\":1,\"913\":1}}],[\"break\",{\"1\":{\"59\":2,\"144\":1,\"167\":1,\"338\":4,\"544\":1}}],[\"banana\",{\"1\":{\"811\":1}}],[\"batch\",{\"1\":{\"475\":1,\"516\":2,\"688\":1}}],[\"base\",{\"1\":{\"604\":1}}],[\"based\",{\"0\":{\"462\":1},\"1\":{\"451\":1,\"456\":1,\"521\":2,\"530\":1}}],[\"baseline\",{\"0\":{\"400\":1,\"401\":1},\"1\":{\"399\":1,\"400\":2,\"401\":1}}],[\"basic\",{\"0\":{\"450\":1},\"1\":{\"454\":1,\"455\":1,\"462\":1}}],[\"baidu\",{\"1\":{\"120\":3,\"333\":1,\"669\":2}}],[\"bkn​​=bn​\",{\"1\":{\"383\":1}}],[\"b2​\",{\"1\":{\"383\":1}}],[\"b2​pnlos​=1−plos​\",{\"1\":{\"383\":1}}],[\"b1​\",{\"1\":{\"383\":2}}],[\"by子句\",{\"1\":{\"596\":1}}],[\"by来对查询结果进行分组\",{\"1\":{\"583\":1}}],[\"by来将查询结果进行排序\",{\"1\":{\"581\":1}}],[\"by\",{\"1\":{\"352\":2,\"581\":2,\"583\":2,\"589\":1}}],[\"byte类型的包装类也有类似的机制\",{\"1\":{\"227\":1}}],[\"bytes\",{\"1\":{\"91\":4,\"94\":3,\"199\":3,\"543\":6}}],[\"byte\",{\"1\":{\"91\":3,\"94\":2,\"107\":1,\"199\":3,\"227\":2,\"305\":1,\"333\":2,\"543\":4,\"808\":1}}],[\"b中\",{\"1\":{\"308\":1}}],[\"boe\",{\"0\":{\"428\":1},\"1\":{\"426\":1,\"432\":1}}],[\"body>\",{\"1\":{\"886\":1}}],[\"body\",{\"1\":{\"333\":4}}],[\"bodyhandlers\",{\"1\":{\"333\":3}}],[\"bob\",{\"1\":{\"246\":2,\"371\":1}}],[\"books\",{\"1\":{\"670\":2,\"671\":1}}],[\"book\",{\"1\":{\"670\":4,\"671\":3}}],[\"bootstrapping\",{\"1\":{\"419\":1}}],[\"bootstarpclassloader用于加载jdk提供的类\",{\"1\":{\"198\":1}}],[\"boolean\",{\"1\":{\"23\":11,\"24\":1,\"25\":2,\"32\":1,\"36\":1,\"37\":2,\"43\":2,\"44\":4,\"47\":9,\"56\":4,\"59\":2,\"67\":1,\"84\":2,\"167\":1,\"215\":1,\"216\":1,\"227\":2,\"342\":2,\"647\":1,\"797\":2,\"808\":1}}],[\"button>\",{\"1\":{\"886\":1,\"892\":1,\"893\":1}}],[\"but\",{\"1\":{\"864\":1}}],[\"budgetpositive\",{\"1\":{\"565\":1}}],[\"budget\",{\"1\":{\"565\":2}}],[\"build>\",{\"1\":{\"854\":1}}],[\"buildgetuserbyid\",{\"1\":{\"719\":2}}],[\"build\",{\"1\":{\"333\":3,\"367\":4,\"368\":2,\"641\":1,\"643\":1,\"647\":1,\"721\":1,\"819\":2,\"834\":1,\"889\":1}}],[\"builders\",{\"1\":{\"719\":1}}],[\"builder来快速生成建造者模式\",{\"1\":{\"629\":1}}],[\"builder注释的方法具体实现了\",{\"1\":{\"368\":1}}],[\"builder最容易用放在方法的用例来解释\",{\"1\":{\"368\":1}}],[\"builder可以放在类\",{\"1\":{\"368\":1}}],[\"builder可以让你以下面显示的那样调用你的代码\",{\"1\":{\"368\":1}}],[\"builder<>\",{\"1\":{\"367\":1}}],[\"builder<t>\",{\"1\":{\"367\":1}}],[\"builder\",{\"1\":{\"245\":8,\"367\":7,\"368\":4,\"629\":2,\"636\":2,\"765\":8}}],[\"bufupdater\",{\"1\":{\"107\":1}}],[\"buf\",{\"1\":{\"107\":2}}],[\"bufferedwriter\",{\"1\":{\"111\":1,\"113\":2}}],[\"bufferedreader\",{\"1\":{\"111\":1,\"112\":6,\"126\":1,\"537\":4}}],[\"bufferedoutputstream\",{\"1\":{\"110\":2}}],[\"bufferedinputstream\",{\"1\":{\"105\":4,\"108\":18,\"109\":3}}],[\"buffer\",{\"0\":{\"517\":1},\"1\":{\"107\":3,\"516\":1}}],[\"bid\",{\"1\":{\"670\":3}}],[\"bit\",{\"1\":{\"384\":2,\"864\":1}}],[\"bigint用于存储大型整数\",{\"1\":{\"563\":1}}],[\"biginteger\",{\"1\":{\"229\":10}}],[\"bigdecimal\",{\"1\":{\"229\":6}}],[\"bindingexception\",{\"1\":{\"660\":1}}],[\"binding\",{\"1\":{\"660\":1}}],[\"binaryoperator<t>\",{\"1\":{\"364\":2}}],[\"binarysearch\",{\"1\":{\"77\":1}}],[\"bincount\",{\"1\":{\"59\":2}}],[\"been\",{\"1\":{\"606\":1}}],[\"begin\",{\"1\":{\"599\":1}}],[\"behavior\",{\"1\":{\"495\":1,\"496\":1,\"497\":1,\"498\":1,\"509\":1}}],[\"behave\",{\"1\":{\"167\":1}}],[\"bellman\",{\"0\":{\"416\":1,\"419\":1,\"420\":1,\"428\":1},\"1\":{\"411\":1,\"420\":2,\"421\":1,\"423\":2,\"426\":1,\"440\":1,\"442\":2,\"444\":1,\"445\":1,\"451\":1,\"487\":3,\"489\":1,\"493\":1}}],[\"become\",{\"1\":{\"167\":1}}],[\"be\",{\"1\":{\"139\":1,\"352\":1,\"378\":1,\"415\":1,\"606\":2,\"864\":2}}],[\"bean\",{\"1\":{\"138\":3}}],[\"before被废弃\",{\"1\":{\"834\":1}}],[\"beforeeach和\",{\"1\":{\"803\":1}}],[\"beforeeach\",{\"1\":{\"802\":2,\"805\":1,\"834\":1}}],[\"beforeall这种注解时\",{\"1\":{\"805\":1}}],[\"beforeall表示此准备工作在所有测试用例执行之前执行\",{\"1\":{\"802\":1}}],[\"beforeall\",{\"1\":{\"802\":3,\"834\":1}}],[\"before|after\",{\"1\":{\"598\":1}}],[\"before\",{\"1\":{\"61\":1,\"834\":1}}],[\"b是当前要计算的参数\",{\"1\":{\"71\":1}}],[\"b\",{\"1\":{\"8\":4,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"46\":2,\"50\":2,\"64\":2,\"71\":5,\"199\":3,\"227\":6,\"241\":1,\"251\":2,\"258\":5,\"266\":3,\"281\":4,\"282\":1,\"295\":2,\"307\":3,\"308\":2,\"309\":3,\"310\":2,\"319\":3,\"331\":1,\"343\":2,\"346\":1,\"347\":3,\"355\":5,\"364\":4,\"371\":1,\"400\":1,\"623\":3,\"786\":2}}],[\"也有可能存储在一些其他的远程仓库\",{\"1\":{\"826\":1}}],[\"也有可能是给当前线程发送一个其他的信号\",{\"1\":{\"144\":1}}],[\"也有可能是数组存储\",{\"1\":{\"31\":1}}],[\"也符合逻辑\",{\"1\":{\"688\":1}}],[\"也放到后面来详细进行讲解\",{\"1\":{\"607\":1}}],[\"也称为\",{\"1\":{\"414\":1}}],[\"也支持向下转型\",{\"1\":{\"238\":1}}],[\"也支持键值同时匹配\",{\"1\":{\"66\":1}}],[\"也只有这里能进行方法的具体实现了\",{\"1\":{\"317\":1}}],[\"也只有这一个静态的变量或方法\",{\"1\":{\"117\":1}}],[\"也只能表示64bit的数据\",{\"1\":{\"229\":1}}],[\"也会在数据更新时产生额外建立索引的开销\",{\"1\":{\"597\":1}}],[\"也会返回左边表中的全部数据\",{\"1\":{\"586\":1}}],[\"也会执行\",{\"1\":{\"374\":1}}],[\"也会进行拷贝\",{\"1\":{\"220\":1}}],[\"也会等待获取cpu资源\",{\"1\":{\"142\":1}}],[\"也就自然找不到main方法了\",{\"1\":{\"198\":1}}],[\"也就是需要进行测试的参数列表\",{\"1\":{\"808\":1}}],[\"也就是让所有的mybatis都使用同一个缓存进行数据存取\",{\"1\":{\"705\":1}}],[\"也就是每一个sqlsession都有有一个对应的缓存\",{\"1\":{\"700\":1}}],[\"也就是每一项数据和另一张表的每一项数据都结合一次\",{\"1\":{\"584\":1}}],[\"也就是一级缓存\",{\"1\":{\"700\":1}}],[\"也就是删除\",{\"1\":{\"682\":1}}],[\"也就是标签名称\",{\"1\":{\"636\":1}}],[\"也就是相当于返回了一个指定长度的字符串数组\",{\"1\":{\"365\":1}}],[\"也就是把\",{\"1\":{\"362\":1}}],[\"也就是将多个consumer组合在一起\",{\"1\":{\"354\":1}}],[\"也就是只包含方法的定义\",{\"1\":{\"219\":1}}],[\"也就是直接判断是否为同一个对象\",{\"1\":{\"215\":1}}],[\"也就是构造方法需要的类型\",{\"1\":{\"191\":1}}],[\"也就是结束工作线程\",{\"1\":{\"167\":1}}],[\"也就是异步的\",{\"1\":{\"138\":1}}],[\"也就是同步的\",{\"1\":{\"138\":1}}],[\"也就是同时保存两个方向\",{\"1\":{\"25\":1}}],[\"也就是所在进程的内存空间\",{\"1\":{\"138\":1}}],[\"也就是我们上面编写的servlet路径\",{\"1\":{\"886\":1}}],[\"也就是我们默认打开的网站\",{\"1\":{\"864\":1}}],[\"也就是我们刚刚无参\",{\"1\":{\"60\":1}}],[\"也就是我们之前讲解的链表\",{\"1\":{\"25\":1}}],[\"也就是移除对应的键值对\",{\"1\":{\"56\":1}}],[\"也就是新的键值对\",{\"1\":{\"56\":1}}],[\"也就是说怎么让这个请求顺利通过呢\",{\"1\":{\"920\":1}}],[\"也就是说在服务器启动后\",{\"1\":{\"871\":1}}],[\"也就是说在组中用于区分于其他项目的标记\",{\"1\":{\"820\":1}}],[\"也就是说保证整个通信是稳定的\",{\"1\":{\"859\":1}}],[\"也就是说我们导入mybatis之后想用什么日志框架再自己加就可以了\",{\"1\":{\"842\":1}}],[\"也就是说我们第二次查询不仅压根就没执行sql语句\",{\"1\":{\"700\":1}}],[\"也就是说不打印\",{\"1\":{\"768\":1}}],[\"也就是说没有任何日志级别的值大于它\",{\"1\":{\"729\":1}}],[\"也就是说mybatis知道我们对数据库里面的数据进行了修改\",{\"1\":{\"700\":1}}],[\"也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了\",{\"1\":{\"658\":1}}],[\"也就是说依然是采用的object中的默认实现\",{\"1\":{\"236\":1}}],[\"也就是说数组的长度一旦确定\",{\"1\":{\"236\":1}}],[\"也就是说这个方法只有定义\",{\"1\":{\"218\":1}}],[\"也就是说只能同时执行一个任务\",{\"1\":{\"138\":1}}],[\"也就是说只要整个哈希表用了75\",{\"1\":{\"60\":1}}],[\"也就是说需要的时候\",{\"1\":{\"71\":1}}],[\"也就是说对于刚访问过的元素\",{\"1\":{\"61\":1}}],[\"也就是说\",{\"1\":{\"55\":1,\"67\":1,\"117\":1,\"172\":1,\"294\":1,\"365\":1,\"833\":1,\"841\":1,\"859\":1,\"900\":1,\"926\":3}}],[\"也就是对遍历的每一个元素进行的操作\",{\"1\":{\"35\":1}}],[\"也包含大量的并行方法\",{\"1\":{\"173\":1}}],[\"也能执行线程里面定义的内容\",{\"1\":{\"141\":1}}],[\"也存在大量的transient关键字\",{\"1\":{\"133\":1}}],[\"也需要使用到\",{\"1\":{\"311\":1}}],[\"也需要考虑重写\",{\"1\":{\"84\":1}}],[\"也需要相同\",{\"1\":{\"84\":1}}],[\"也可被用于构建和管理各种项目\",{\"1\":{\"817\":1}}],[\"也可能是integer类型\",{\"1\":{\"280\":1}}],[\"也可能是小数\",{\"1\":{\"15\":1}}],[\"也可以进行某个扩展名称的匹配\",{\"1\":{\"878\":1}}],[\"也可以用于其他的通信\",{\"1\":{\"870\":1}}],[\"也可以用来将我们的类进行分类\",{\"1\":{\"120\":1}}],[\"也可以根本版本号进行选择\",{\"1\":{\"820\":1}}],[\"也可以作为参数来源\",{\"1\":{\"812\":1}}],[\"也可以嵌套select\",{\"1\":{\"672\":1}}],[\"也可以为它起个别名\",{\"1\":{\"649\":1}}],[\"也可以通过excute\",{\"1\":{\"608\":1}}],[\"也可以不使用配置文件\",{\"1\":{\"641\":1}}],[\"也可以不带密码\",{\"1\":{\"589\":1}}],[\"也可以不同\",{\"1\":{\"8\":1}}],[\"也可以存储任意数量字符串\",{\"1\":{\"563\":1}}],[\"也可以采用基于\",{\"1\":{\"530\":1}}],[\"也可以使用初始化参数来实现\",{\"1\":{\"902\":1}}],[\"也可以使用之前的\",{\"1\":{\"803\":1}}],[\"也可以使用其他类型\",{\"1\":{\"643\":1}}],[\"也可以使用cdata\",{\"1\":{\"635\":1}}],[\"也可以使用rollback\",{\"1\":{\"623\":1}}],[\"也可以使用\",{\"1\":{\"356\":1,\"561\":1,\"794\":1}}],[\"也可以使用访问顺序\",{\"1\":{\"61\":1}}],[\"也可以是一个ip地址\",{\"1\":{\"859\":1}}],[\"也可以是一段文本内容\",{\"1\":{\"636\":1}}],[\"也可以是向量\",{\"1\":{\"475\":1}}],[\"也可以是无限长的trajectory\",{\"1\":{\"393\":1}}],[\"也可以是继承自其他抽象类的子类或是实现其他接口的类等\",{\"1\":{\"347\":1}}],[\"也可以是绝对路径\",{\"1\":{\"98\":1}}],[\"也可以像这样\",{\"1\":{\"340\":1}}],[\"也可以指定目标开放反射\",{\"1\":{\"309\":1}}],[\"也可以象征性\",{\"1\":{\"244\":1}}],[\"也可以被子类访问\",{\"1\":{\"121\":1}}],[\"也可以理解为是所有对象共享的内容\",{\"1\":{\"117\":1}}],[\"也可以直接扫描整个包下的所有实体类\",{\"1\":{\"649\":1}}],[\"也可以直接写入byte\",{\"1\":{\"92\":1}}],[\"也可以直接在定义时赋值\",{\"1\":{\"9\":1}}],[\"也可以控制读取的数量\",{\"1\":{\"91\":1}}],[\"也可以精准匹配\",{\"1\":{\"66\":1}}],[\"也可以当做栈来使用\",{\"1\":{\"44\":1}}],[\"也可以当做双端队列使用\",{\"1\":{\"25\":1}}],[\"也可以从后向前\",{\"1\":{\"37\":1}}],[\"也可以利用静态代码块\",{\"1\":{\"25\":1}}],[\"也是整个项目的所有依赖\",{\"1\":{\"819\":1}}],[\"也是可用的日志级别中最大的\",{\"1\":{\"727\":1}}],[\"也是通过迭代器的形式去进行数据的读取\",{\"1\":{\"653\":1}}],[\"也是我们需要给的\",{\"1\":{\"353\":1}}],[\"也是帮助我们实现好了的\",{\"1\":{\"344\":1}}],[\"也是无法进行修改的\",{\"1\":{\"318\":1}}],[\"也是一样的\",{\"1\":{\"251\":1}}],[\"也是以对象的形式存在的\",{\"1\":{\"235\":1}}],[\"也是支持拆箱的\",{\"1\":{\"227\":1}}],[\"也是用于唤醒\",{\"1\":{\"161\":1}}],[\"也是用到了泛型\",{\"1\":{\"14\":1}}],[\"也是同样的值\",{\"1\":{\"154\":1}}],[\"也是更加推荐的做法\",{\"1\":{\"144\":1}}],[\"也是程序执行的最小单位\",{\"1\":{\"138\":1}}],[\"也是不同的两个类\",{\"1\":{\"120\":1}}],[\"也是由缓冲区处理\",{\"1\":{\"103\":1}}],[\"也是根据\",{\"1\":{\"84\":1}}],[\"也是头结点数组\",{\"1\":{\"58\":1}}],[\"也是1\",{\"1\":{\"25\":1}}],[\"也是尽量使用小写字母开头的单词\",{\"1\":{\"5\":1}}],[\"一律需要经过此过滤器\",{\"1\":{\"919\":1}}],[\"一键测试所有位于test目录下的测试案例\",{\"1\":{\"852\":1}}],[\"一只企鹅\",{\"1\":{\"778\":1}}],[\"一级缓存给我们提供了很高速的访问效率\",{\"1\":{\"700\":1}}],[\"一级缓存只针对于单个会话\",{\"1\":{\"700\":1}}],[\"一级缓存强制启用\",{\"1\":{\"700\":1}}],[\"一级缓存\",{\"0\":{\"700\":1}}],[\"一次性开启所有测试案例每个案例开始之前都会执行一次\",{\"1\":{\"834\":1}}],[\"一次性开启所有测试案例只会执行一次\",{\"1\":{\"834\":1}}],[\"一次性提交一个批量操作给数据库\",{\"1\":{\"688\":1}}],[\"一次性读取全部内容\",{\"1\":{\"91\":1}}],[\"一对多查询\",{\"0\":{\"670\":1}}],[\"一对一查询我们可以使用association标签来进行指定\",{\"1\":{\"667\":1}}],[\"一对一查询\",{\"0\":{\"666\":1}}],[\"一起执行\",{\"1\":{\"615\":1}}],[\"一开始是在第一行上面\",{\"1\":{\"614\":1}}],[\"一开始创建时\",{\"1\":{\"245\":1}}],[\"一套完整的\",{\"1\":{\"604\":1}}],[\"一条记录\",{\"1\":{\"571\":1}}],[\"一样\",{\"1\":{\"456\":1}}],[\"一样才行\",{\"1\":{\"258\":1}}],[\"一种最简单的方式就是和之前一样\",{\"1\":{\"660\":1}}],[\"一种则是有所偏向\",{\"1\":{\"526\":1}}],[\"一种是将所有状态视为同等重要\",{\"1\":{\"526\":1}}],[\"一种是通过迭代算法来求解\",{\"1\":{\"442\":1}}],[\"一种是可以直接通过矩阵求逆进行求解\",{\"1\":{\"442\":1}}],[\"一种是以优秀\",{\"1\":{\"280\":1}}],[\"一种迭代策略\",{\"1\":{\"421\":1}}],[\"一会要保存的格式\",{\"1\":{\"333\":1}}],[\"一会直接覆盖\",{\"1\":{\"59\":1}}],[\"一直都是此版本作为广泛使用的版本\",{\"1\":{\"329\":1}}],[\"一直以来编写的都是单线程应用程序\",{\"1\":{\"138\":1}}],[\"一些特性\",{\"1\":{\"529\":1}}],[\"一些细节\",{\"1\":{\"516\":1,\"530\":1}}],[\"一些状态可能很少被访问\",{\"1\":{\"508\":1}}],[\"一些问题\",{\"0\":{\"442\":1}}],[\"一些方法\",{\"1\":{\"275\":1}}],[\"一些集合是有序的\",{\"1\":{\"21\":1}}],[\"一定可以遍历所给定的\",{\"1\":{\"458\":1}}],[\"一定知道三引号\",{\"1\":{\"341\":1}}],[\"一定是\",{\"1\":{\"281\":1}}],[\"一定要先切换到我们要创建表的数据库内\",{\"1\":{\"567\":1}}],[\"一定要用equals\",{\"1\":{\"244\":1}}],[\"一定要注意\",{\"1\":{\"156\":1}}],[\"一定比线程t先醒来\",{\"1\":{\"144\":1}}],[\"一旦使用\",{\"1\":{\"629\":1}}],[\"一旦关闭自动提交\",{\"1\":{\"623\":1}}],[\"一旦提交\",{\"1\":{\"599\":1}}],[\"一旦tcp连接建立\",{\"1\":{\"536\":1}}],[\"一旦大于等于10直接截断\",{\"1\":{\"322\":1}}],[\"一旦类型明确\",{\"1\":{\"281\":1}}],[\"一旦获取到\",{\"1\":{\"142\":1}}],[\"一旦被声明为静态\",{\"1\":{\"117\":1}}],[\"一部分内容可以被暂时保存bufferedinputstream\",{\"1\":{\"108\":1}}],[\"一致性\",{\"1\":{\"599\":1}}],[\"一致也是可以的\",{\"1\":{\"498\":1}}],[\"一致\",{\"1\":{\"84\":1}}],[\"一般通过\",{\"1\":{\"886\":1}}],[\"一般是此接口实现\",{\"1\":{\"874\":1}}],[\"一般是4\",{\"1\":{\"819\":1}}],[\"一般仅用作测试的依赖如junit只保留在测试中即可\",{\"1\":{\"834\":1}}],[\"一般表示这是一个处于开发中的项目\",{\"1\":{\"820\":1}}],[\"一般用于指定项目在当前组中的唯一名称\",{\"1\":{\"820\":1}}],[\"一般用于指定组名称\",{\"1\":{\"820\":1}}],[\"一般不咋用\",{\"1\":{\"658\":1}}],[\"一般都是将其转换为对应的实体类对象\",{\"1\":{\"648\":1}}],[\"一般聚集函数是这样使用的\",{\"1\":{\"582\":1}}],[\"一般\",{\"1\":{\"543\":1}}],[\"一般化的推广\",{\"1\":{\"443\":1}}],[\"一般构建对象时会有两种方法\",{\"1\":{\"366\":1}}],[\"一般出现错误可能jvm就无法继续正常运行了\",{\"1\":{\"264\":1}}],[\"一般他们是配合一起使用的\",{\"1\":{\"129\":1}}],[\"一般遇到以下情况时才会会加载类\",{\"1\":{\"118\":1}}],[\"一般情况\",{\"1\":{\"229\":1}}],[\"一般情况下使用不到\",{\"1\":{\"864\":1}}],[\"一般情况下只是为了进行一些额外的初始化工作而已\",{\"1\":{\"255\":1}}],[\"一般情况下\",{\"1\":{\"117\":1,\"206\":1}}],[\"一般情况都是真实的数据量\",{\"1\":{\"91\":1}}],[\"一般在java\",{\"1\":{\"88\":1}}],[\"一般的比较运算符\",{\"1\":{\"580\":1}}],[\"一般的方法是\",{\"1\":{\"366\":1}}],[\"一般的\",{\"1\":{\"25\":1}}],[\"一般使用驼峰命名法最规范\",{\"1\":{\"5\":1}}],[\"一个cookie包含信息\",{\"1\":{\"909\":1}}],[\"一个servlet的生命周期为\",{\"1\":{\"872\":1}}],[\"一个jar包实际上就是对我们生成的字节码文件进行的压缩打包\",{\"1\":{\"853\":1}}],[\"一个maven项目可以继承自另一个maven项目\",{\"1\":{\"849\":1}}],[\"一个maven项目和我们普通的项目有什么区别\",{\"1\":{\"818\":1}}],[\"一个项目有可能依赖于其他项目\",{\"1\":{\"832\":1}}],[\"一个项目依赖一般是存储在中央仓库中\",{\"1\":{\"826\":1}}],[\"一个组下面可以有很多个项目\",{\"1\":{\"820\":1}}],[\"一个标准的pom配置长这样\",{\"1\":{\"819\":1}}],[\"一个测试类中可以同时有多个测试案例\",{\"1\":{\"776\":1}}],[\"一个logger中可以包含多个handler用于同时向不同的地方打印日志\",{\"1\":{\"735\":1}}],[\"一个会话dml操作只会重置当前会话的缓存\",{\"1\":{\"700\":1}}],[\"一个比较特殊的选择方法selectmap\",{\"1\":{\"653\":1}}],[\"一个节点下可能会有很多个节点\",{\"1\":{\"636\":1}}],[\"一个xml文件存在以下的格式规范\",{\"1\":{\"634\":1}}],[\"一个事务\",{\"1\":{\"599\":1}}],[\"一个不允许更新的视图上定义的视图也不允许更新\",{\"1\":{\"596\":1}}],[\"一个表可以有多个唯一约束\",{\"1\":{\"564\":1}}],[\"一个表只能有一个主键\",{\"1\":{\"564\":1,\"565\":1}}],[\"一个仓库可以存储多种物品\",{\"1\":{\"556\":1}}],[\"一个实体的属性可以有很多个\",{\"1\":{\"550\":1}}],[\"一个\",{\"1\":{\"477\":1}}],[\"一个build\",{\"1\":{\"368\":1}}],[\"一个名为foobuilder的内部静态类\",{\"1\":{\"368\":1}}],[\"一个默认的构造函数\",{\"1\":{\"366\":1}}],[\"一个可以产生所需的新数组的函数\",{\"1\":{\"365\":1}}],[\"一个注解就搞定了\",{\"1\":{\"344\":1}}],[\"一个注解可以有很多个作用域\",{\"1\":{\"206\":1}}],[\"一个repeat就搞定了\",{\"1\":{\"331\":1}}],[\"一个是运行时异常\",{\"1\":{\"265\":1}}],[\"一个是编译时异常\",{\"1\":{\"265\":1}}],[\"一个成员内部类\",{\"1\":{\"251\":1}}],[\"一个三行两列的数组\",{\"1\":{\"240\":1}}],[\"一个类可以附加很多个功能\",{\"1\":{\"219\":1}}],[\"一个类中可以包含多个同名的方法\",{\"1\":{\"8\":1}}],[\"一个最简单的注解就被我们创建了\",{\"1\":{\"206\":1}}],[\"一个线程处于运行状态下\",{\"1\":{\"143\":1}}],[\"一个进程可以有多个线程\",{\"1\":{\"138\":1}}],[\"一个对象改变了静态变量的值\",{\"1\":{\"117\":1}}],[\"一个新的迭代器就像上面这样\",{\"1\":{\"31\":1}}],[\"一个集合中可以存放多个集合\",{\"1\":{\"25\":1}}],[\"一个泛型类型编译之后\",{\"1\":{\"16\":1}}],[\"有一个session被创建了\",{\"1\":{\"922\":1}}],[\"有两种方式配置\",{\"1\":{\"827\":1}}],[\"有两种不同的方式加载关联\",{\"1\":{\"666\":1}}],[\"有些操作可能比较特殊\",{\"1\":{\"704\":1}}],[\"有些时候我们可能需要对测试用例进行进一步的分层\",{\"1\":{\"805\":1}}],[\"有些时候我们可能需要控制某些测试案例的顺序\",{\"1\":{\"804\":1}}],[\"有些时候我们可能需要配置各种条件来执行某些测试案例\",{\"1\":{\"792\":1}}],[\"有些时候我们可能需要生成一个空的集合类返回\",{\"1\":{\"79\":1}}],[\"有些时候我们可以会打印一些比较重要的日志信息\",{\"1\":{\"726\":1}}],[\"有些时候并不需要创建那么多对象\",{\"1\":{\"227\":1}}],[\"有些时候\",{\"1\":{\"8\":1,\"660\":1,\"679\":1,\"777\":1}}],[\"有助于优化性能\",{\"1\":{\"658\":1}}],[\"有助于提高性能\",{\"1\":{\"652\":1}}],[\"有表示\",{\"1\":{\"529\":1}}],[\"有\",{\"1\":{\"453\":1}}],[\"有运算规则\",{\"1\":{\"364\":1}}],[\"有起始值\",{\"1\":{\"364\":1}}],[\"有且仅有一个抽象方法\",{\"1\":{\"290\":1}}],[\"有关servletcontext其他的内容\",{\"1\":{\"903\":1}}],[\"有关mybatis的基本使用\",{\"1\":{\"721\":1}}],[\"有关mybatis这一部分的原理\",{\"1\":{\"659\":1}}],[\"有关\",{\"1\":{\"422\":1,\"526\":1}}],[\"有关java\",{\"1\":{\"328\":1}}],[\"有关注解我们会在最后一章进行介绍\",{\"1\":{\"216\":1}}],[\"有关锁的内容\",{\"1\":{\"215\":1}}],[\"有关线程中断相关问题\",{\"1\":{\"142\":1}}],[\"有了session之后\",{\"1\":{\"918\":1}}],[\"有了\",{\"1\":{\"186\":1}}],[\"有哪些方法\",{\"1\":{\"179\":1}}],[\"有可能会使得这个类的一些结构发生变化\",{\"1\":{\"132\":1}}],[\"有时我们可能也需要对多个输入参数进行测试\",{\"1\":{\"808\":1}}],[\"有时候为了方便\",{\"1\":{\"796\":1}}],[\"有时候我们的方法中可能会出现一些与成员变量重名的变量\",{\"1\":{\"7\":1}}],[\"有时会遇到这样一个很麻烦的问题\",{\"1\":{\"126\":1}}],[\"有着不同程度的访问限制\",{\"1\":{\"121\":1}}],[\"有点混乱\",{\"1\":{\"120\":1}}],[\"1表示遵循w3c的rfc\",{\"1\":{\"909\":1}}],[\"1l\",{\"1\":{\"876\":1}}],[\"1协议了\",{\"1\":{\"859\":1}}],[\"1<\",{\"1\":{\"834\":1,\"850\":2}}],[\"1=1一定是true\",{\"1\":{\"621\":1}}],[\"1=1\",{\"1\":{\"621\":2,\"622\":1}}],[\"1nf\",{\"0\":{\"553\":1}}],[\"1nf对表中每一列进行约束\",{\"1\":{\"552\":1}}],[\"1−∣a\",{\"1\":{\"461\":1}}],[\"1~2\",{\"1\":{\"384\":1}}],[\"1+σ2pkn​​gkn​​\",{\"1\":{\"383\":1}}],[\"1+ns​\",{\"1\":{\"383\":1}}],[\"15s\",{\"1\":{\"765\":1}}],[\"15\",{\"1\":{\"544\":1,\"669\":4,\"725\":1,\"786\":1,\"789\":1}}],[\"15首次提出并测试了两个版本\",{\"1\":{\"346\":1}}],[\"15才正式开放使用\",{\"1\":{\"341\":1}}],[\"17<\",{\"1\":{\"842\":1}}],[\"17下执行的测试案例\",{\"1\":{\"795\":1}}],[\"1724143033753\",{\"1\":{\"713\":1}}],[\"17之前想要实现就很麻烦\",{\"1\":{\"346\":1}}],[\"17正式推出的又一重磅类型\",{\"1\":{\"346\":1}}],[\"17作为新的lts长期维护版本\",{\"1\":{\"345\":1}}],[\"17\",{\"0\":{\"345\":1,\"933\":1},\"1\":{\"694\":2,\"794\":1,\"795\":1}}],[\"17出现之前\",{\"1\":{\"329\":1}}],[\"14中首次出场\",{\"1\":{\"344\":1}}],[\"14或更高版本运行时\",{\"1\":{\"343\":1}}],[\"14\",{\"1\":{\"342\":1,\"786\":1,\"787\":1,\"789\":1}}],[\"14才正式开放使用\",{\"1\":{\"340\":1}}],[\"1111\",{\"1\":{\"621\":2}}],[\"11为string新增一些更加方便的操作\",{\"1\":{\"331\":1}}],[\"11\",{\"0\":{\"326\":1},\"1\":{\"329\":1,\"330\":1}}],[\"1997年以前使用的是http\",{\"1\":{\"859\":1}}],[\"1962329560\",{\"1\":{\"669\":2}}],[\"19\",{\"1\":{\"274\":1,\"318\":1,\"694\":2,\"700\":2}}],[\"127\",{\"1\":{\"544\":2}}],[\"120和4\",{\"1\":{\"384\":1}}],[\"12引入全新的switch语法\",{\"1\":{\"338\":1}}],[\"12\",{\"0\":{\"336\":1,\"337\":1},\"1\":{\"337\":1,\"725\":1,\"736\":2,\"746\":2}}],[\"128~127之间的值自动装箱为integer类型的对象\",{\"1\":{\"227\":1}}],[\"128~127之间的所有值\",{\"1\":{\"227\":1}}],[\"128\",{\"1\":{\"227\":4,\"374\":1}}],[\"1234\",{\"1\":{\"407\":1,\"615\":2,\"623\":11}}],[\"1234567\",{\"1\":{\"133\":1}}],[\"123456\",{\"1\":{\"132\":1,\"344\":2,\"605\":1,\"613\":1,\"622\":1,\"721\":1,\"834\":1}}],[\"123\",{\"1\":{\"192\":1}}],[\"1打印\",{\"1\":{\"147\":1,\"148\":1}}],[\"1static\",{\"1\":{\"219\":1}}],[\"1s\",{\"1\":{\"142\":1}}],[\"16<\",{\"1\":{\"841\":1}}],[\"16才正式开放使用\",{\"1\":{\"342\":1,\"344\":1}}],[\"16这五个版本并非长期支持版本\",{\"1\":{\"337\":1}}],[\"166\",{\"1\":{\"228\":1}}],[\"16\",{\"0\":{\"336\":1,\"337\":1},\"1\":{\"88\":1,\"669\":2}}],[\"138\",{\"1\":{\"908\":2,\"913\":4}}],[\"13版本引入了一些实验性功能\",{\"1\":{\"337\":1}}],[\"13\",{\"1\":{\"77\":1}}],[\"1\",{\"0\":{\"19\":1,\"20\":1,\"107\":1,\"278\":1,\"279\":1,\"326\":1,\"336\":1,\"393\":1,\"398\":1,\"400\":1,\"404\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":1,\"417\":1,\"427\":1,\"429\":1,\"431\":1,\"436\":1,\"437\":2,\"438\":1,\"440\":1,\"444\":1,\"450\":1,\"451\":2,\"452\":1,\"453\":1,\"455\":1,\"460\":1,\"467\":1,\"468\":2,\"470\":1,\"475\":1,\"484\":1,\"486\":1,\"490\":1,\"494\":1,\"505\":1,\"507\":1,\"522\":1,\"524\":1,\"548\":1,\"938\":1},\"1\":{\"14\":4,\"25\":2,\"33\":1,\"50\":2,\"57\":6,\"59\":3,\"60\":2,\"64\":4,\"71\":4,\"78\":1,\"79\":1,\"80\":3,\"91\":3,\"92\":1,\"94\":1,\"96\":1,\"108\":3,\"110\":1,\"173\":2,\"183\":1,\"239\":1,\"240\":2,\"241\":1,\"246\":5,\"266\":1,\"267\":2,\"274\":1,\"275\":1,\"292\":4,\"294\":2,\"295\":1,\"321\":2,\"322\":2,\"364\":1,\"371\":1,\"384\":1,\"387\":7,\"388\":1,\"393\":1,\"440\":1,\"444\":1,\"453\":2,\"461\":1,\"472\":2,\"475\":1,\"486\":1,\"490\":1,\"543\":3,\"544\":11,\"550\":4,\"605\":2,\"616\":1,\"621\":1,\"622\":2,\"634\":4,\"641\":1,\"643\":1,\"649\":1,\"650\":1,\"651\":1,\"653\":1,\"660\":1,\"669\":6,\"682\":4,\"688\":1,\"691\":1,\"693\":3,\"700\":8,\"701\":2,\"705\":1,\"780\":1,\"790\":1,\"791\":1,\"797\":1,\"804\":1,\"805\":4,\"819\":1,\"834\":4,\"840\":1,\"843\":1,\"849\":1,\"854\":1,\"859\":2,\"876\":1,\"881\":2,\"888\":1,\"889\":1,\"908\":6,\"913\":6}}],[\"180π​\",{\"1\":{\"383\":1}}],[\"18\",{\"1\":{\"5\":1,\"9\":1,\"216\":4,\"219\":1,\"220\":1,\"221\":1,\"307\":1,\"318\":1,\"564\":2,\"651\":1,\"653\":1,\"660\":1,\"669\":1,\"688\":1,\"690\":1,\"691\":3,\"694\":2,\"719\":3,\"825\":2,\"850\":1}}],[\"10​a=ak∗​\",{\"1\":{\"437\":1,\"440\":1}}],[\"10​a=a∗a=a∗​\",{\"1\":{\"431\":1}}],[\"1024\",{\"1\":{\"333\":1,\"543\":2}}],[\"10我们认识了var关键字\",{\"1\":{\"330\":1}}],[\"10新增的一些其他改进\",{\"1\":{\"328\":1}}],[\"10主要带来的是一些内部更新\",{\"1\":{\"327\":1}}],[\"100000\",{\"1\":{\"155\":6}}],[\"10000\",{\"1\":{\"154\":2,\"155\":4}}],[\"1000ms\",{\"1\":{\"142\":1}}],[\"1000\",{\"1\":{\"142\":1,\"154\":1,\"155\":4,\"156\":2,\"161\":1,\"162\":1,\"166\":1,\"167\":1,\"172\":4,\"538\":1,\"727\":1}}],[\"100~100之间的\",{\"1\":{\"71\":1}}],[\"100\",{\"1\":{\"71\":4,\"193\":1,\"229\":2,\"267\":1,\"274\":1,\"323\":1,\"338\":2,\"564\":1}}],[\"10\",{\"1\":{\"4\":1,\"9\":1,\"15\":2,\"25\":5,\"46\":4,\"71\":1,\"77\":1,\"79\":2,\"94\":1,\"96\":1,\"148\":1,\"184\":1,\"186\":4,\"193\":4,\"227\":5,\"229\":1,\"235\":1,\"236\":1,\"237\":1,\"238\":4,\"256\":1,\"257\":2,\"258\":2,\"267\":2,\"268\":2,\"281\":1,\"322\":2,\"333\":3,\"338\":2,\"339\":2,\"355\":1,\"544\":1,\"564\":1,\"565\":1,\"786\":1,\"789\":2,\"807\":2,\"864\":1,\"908\":1,\"913\":1}}],[\"小刘\",{\"1\":{\"694\":2}}],[\"小张\",{\"1\":{\"694\":2}}],[\"小黑子\",{\"1\":{\"688\":1}}],[\"小美\",{\"1\":{\"688\":1,\"694\":2}}],[\"小强\",{\"1\":{\"688\":1}}],[\"小刚\",{\"1\":{\"688\":1}}],[\"小辣椒\",{\"1\":{\"627\":1}}],[\"小王\",{\"1\":{\"219\":1,\"688\":1}}],[\"小于0表示小于\",{\"1\":{\"14\":1}}],[\"小明\",{\"1\":{\"5\":1,\"9\":1,\"57\":4,\"216\":4,\"220\":1,\"221\":1,\"251\":1,\"669\":1,\"825\":1}}],[\"小红\",{\"1\":{\"4\":1,\"57\":2,\"251\":1}}],[\"+log\",{\"1\":{\"767\":2}}],[\"+child\",{\"1\":{\"636\":1}}],[\"+c2​\",{\"1\":{\"384\":1}}],[\"+param\",{\"1\":{\"616\":1}}],[\"+object\",{\"1\":{\"616\":1}}],[\"+reader\",{\"1\":{\"537\":1}}],[\"+rtt−rkn​​\",{\"1\":{\"384\":1}}],[\"+η▽w​f\",{\"1\":{\"478\":1}}],[\"+η​\",{\"1\":{\"473\":1,\"484\":1}}],[\"+ηk​\",{\"1\":{\"471\":1}}],[\"+γs\",{\"1\":{\"420\":1,\"451\":1}}],[\"+γe\",{\"1\":{\"416\":1,\"419\":1}}],[\"+ζ2​moskn​​rate\",{\"1\":{\"384\":1}}],[\"+127\",{\"1\":{\"374\":1}}],[\"+html\",{\"1\":{\"333\":1}}],[\"+scanner\",{\"1\":{\"621\":2}}],[\"+sex\",{\"1\":{\"616\":1}}],[\"+sid+\",{\"1\":{\"616\":1}}],[\"+socket\",{\"1\":{\"536\":2,\"537\":1,\"544\":2}}],[\"+s\",{\"1\":{\"323\":1}}],[\"+str\",{\"1\":{\"192\":1,\"199\":1}}],[\"+e\",{\"1\":{\"267\":1}}],[\"+text\",{\"1\":{\"537\":1}}],[\"+test\",{\"1\":{\"251\":1}}],[\"+this\",{\"1\":{\"251\":1}}],[\"+name\",{\"1\":{\"251\":2}}],[\"+name+\",{\"1\":{\"5\":1,\"616\":1}}],[\"+表示对前面这个字符匹配一次或多次\",{\"1\":{\"246\":1}}],[\"+=\",{\"1\":{\"245\":1}}],[\"+a\",{\"1\":{\"257\":5}}],[\"+array\",{\"1\":{\"236\":1}}],[\"+age+\",{\"1\":{\"5\":1,\"307\":1}}],[\"+i+\",{\"1\":{\"333\":1,\"613\":1}}],[\"+i\",{\"1\":{\"142\":1,\"147\":2,\"148\":2,\"173\":1,\"291\":1}}],[\"++size\",{\"1\":{\"59\":1}}],[\"++modcount\",{\"1\":{\"59\":1}}],[\"++bincount\",{\"1\":{\"59\":1}}],[\"+\",{\"0\":{\"310\":1,\"322\":1,\"346\":1,\"808\":1,\"846\":1,\"847\":1,\"906\":1,\"917\":1},\"1\":{\"8\":2,\"25\":3,\"33\":1,\"48\":1,\"49\":1,\"65\":4,\"71\":1,\"139\":1,\"173\":1,\"174\":6,\"192\":1,\"215\":2,\"227\":1,\"237\":1,\"245\":5,\"246\":2,\"254\":1,\"258\":1,\"274\":1,\"321\":2,\"322\":2,\"333\":4,\"343\":1,\"355\":3,\"364\":2,\"366\":8,\"368\":4,\"382\":1,\"473\":1,\"484\":1,\"606\":9,\"616\":1,\"621\":2,\"636\":1,\"658\":2,\"688\":2,\"717\":1,\"756\":4,\"761\":3,\"786\":1,\"874\":2,\"886\":2,\"899\":1,\"908\":2}}],[\"果直接创建对象\",{\"1\":{\"4\":1}}],[\"就出现了几个新的类加载器\",{\"1\":{\"926\":1}}],[\"就相当于添加了很多堵墙\",{\"1\":{\"918\":1}}],[\"就属于同一个会话\",{\"1\":{\"911\":1}}],[\"就获取不了共享参数了\",{\"1\":{\"900\":1}}],[\"就行\",{\"1\":{\"893\":1}}],[\"就行了\",{\"1\":{\"67\":2,\"265\":2}}],[\"就被tomcat服务器封装为了一个servletrequest对象\",{\"1\":{\"873\":1}}],[\"就把所请求的文档作为响应报文返回给客户\",{\"1\":{\"859\":1}}],[\"就存在大量的可选依赖\",{\"1\":{\"842\":1}}],[\"就存放在resultset中\",{\"1\":{\"608\":1}}],[\"就算像这样进行了修改\",{\"1\":{\"658\":1}}],[\"就算其他项目将此项目作为依赖也无法使用\",{\"1\":{\"307\":1}}],[\"就能够收到服务器发来的响应内容了\",{\"1\":{\"875\":1}}],[\"就能够很好地解决缓存一致性问题\",{\"1\":{\"705\":1}}],[\"就能够直接将查询结果转化为一个实体类\",{\"1\":{\"643\":1}}],[\"就能够解决掉我们之前长长的一串代码\",{\"1\":{\"627\":1}}],[\"就无法再进行回滚了\",{\"1\":{\"599\":1}}],[\"就直接去更新策略\",{\"1\":{\"456\":1}}],[\"就好了\",{\"1\":{\"437\":1}}],[\"就好像默认其是\",{\"1\":{\"281\":1}}],[\"就没有这个\",{\"1\":{\"371\":1}}],[\"就没办法了\",{\"1\":{\"229\":1}}],[\"就返回\",{\"1\":{\"363\":3}}],[\"就类似于使用\",{\"1\":{\"356\":1}}],[\"就很好地解决了我们上面所提到的问题\",{\"1\":{\"926\":1}}],[\"就很头疼\",{\"1\":{\"343\":1}}],[\"就很蠢\",{\"1\":{\"323\":1}}],[\"就明确指出了在运行的时候会出现的异常\",{\"1\":{\"264\":1}}],[\"就近原则\",{\"1\":{\"251\":1}}],[\"就表示这个是一个数组类型\",{\"1\":{\"235\":1}}],[\"就支持像这样编写\",{\"1\":{\"227\":1}}],[\"就不会被加载\",{\"1\":{\"926\":1}}],[\"就不会执行接口的默认方法\",{\"1\":{\"219\":1}}],[\"就不再是通过预编译\",{\"1\":{\"648\":1}}],[\"就不太可行\",{\"1\":{\"508\":1}}],[\"就不需要是\",{\"1\":{\"499\":1}}],[\"就不能确保所选择的\",{\"1\":{\"458\":1}}],[\"就不一定需要实现\",{\"1\":{\"218\":1}}],[\"就不是正常的\",{\"1\":{\"186\":1}}],[\"就连被定义为final字段的值都能强行修改\",{\"1\":{\"193\":1}}],[\"就保证三个线程的锁是一致的\",{\"1\":{\"155\":1}}],[\"就必须确保这样做是安全的\",{\"1\":{\"192\":1}}],[\"就必须等待当前同步代码块的内容执行完毕\",{\"1\":{\"155\":1}}],[\"就必须运行两个进程\",{\"1\":{\"138\":1}}],[\"就会一直向下直到servlet\",{\"1\":{\"920\":1}}],[\"就会重新读取\",{\"1\":{\"701\":1}}],[\"就会向下移动一行\",{\"1\":{\"614\":1}}],[\"就会根据设置的值进行创建实体对象\",{\"1\":{\"368\":1}}],[\"就会直接\",{\"1\":{\"343\":1}}],[\"就会直接交给jvm进行处理\",{\"1\":{\"267\":1}}],[\"就会报错\",{\"1\":{\"256\":1}}],[\"就会得到不同的对象了\",{\"1\":{\"227\":1}}],[\"就会结束循环\",{\"1\":{\"167\":1}}],[\"就会出现问题\",{\"1\":{\"154\":1}}],[\"就会暂时处于休眠状态\",{\"1\":{\"142\":1}}],[\"就可能导致各自的高速缓存数据不一致\",{\"1\":{\"154\":1}}],[\"就可以通过初始化参数来给予servlet\",{\"1\":{\"902\":1}}],[\"就可以通过set中提供的方法\",{\"1\":{\"614\":1}}],[\"就可以快速完成servlet的编写\",{\"1\":{\"876\":1}}],[\"就可以正常显示中文了\",{\"1\":{\"864\":1}}],[\"就可以正常使用logger了\",{\"1\":{\"304\":1}}],[\"就可以创建一个自定义的日志格式处理逻辑了\",{\"1\":{\"761\":1}}],[\"就可以创造出不同的对象\",{\"1\":{\"367\":1}}],[\"就可以编写为这种形式\",{\"1\":{\"753\":1}}],[\"就可以直接帮助用户跳转到用户首页了\",{\"1\":{\"899\":1}}],[\"就可以直接执行当前类中所有的测试案例\",{\"1\":{\"776\":1}}],[\"就可以直接执行我们的测试方法了\",{\"1\":{\"776\":1}}],[\"就可以直接在二级缓存中命中了\",{\"1\":{\"701\":1}}],[\"就可以直接从缓存中读取\",{\"1\":{\"699\":1}}],[\"就可以直接就创出对象\",{\"1\":{\"255\":1}}],[\"就可以解决这样的问题\",{\"1\":{\"627\":1}}],[\"就可以配套使用\",{\"1\":{\"365\":1}}],[\"就可以让客户端帮助我们发送出去了\",{\"1\":{\"333\":1}}],[\"就可以简写为\",{\"1\":{\"290\":1}}],[\"就可以使用多重异常捕获\",{\"1\":{\"267\":1}}],[\"就可以使用tostring转换为字符串了\",{\"1\":{\"245\":1}}],[\"就可以使用非public方法了\",{\"1\":{\"191\":1}}],[\"就可以表示这个是哪一个包里的类了\",{\"1\":{\"120\":1}}],[\"就可以轻松地通过键找到对应的映射值\",{\"1\":{\"55\":1}}],[\"就可以执行定义好的方法了\",{\"1\":{\"5\":1}}],[\"就可以进行一定操作\",{\"1\":{\"4\":1}}],[\"就开始按顺序执行我们给定的程序\",{\"1\":{\"142\":1}}],[\"就需要用到javascript来帮助我们\",{\"1\":{\"893\":1}}],[\"就需要用到java多线程框架\",{\"1\":{\"138\":1}}],[\"就需要给出列名\",{\"1\":{\"571\":1}}],[\"就需要新的算法进行解决\",{\"1\":{\"470\":1}}],[\"就需要将这三种类型都进行明确指定\",{\"1\":{\"281\":1}}],[\"就需要对异常进行捕获\",{\"1\":{\"267\":1}}],[\"就需要注意了\",{\"1\":{\"120\":1}}],[\"就像之前的jdbc一样\",{\"1\":{\"870\":1}}],[\"就像lol一样\",{\"1\":{\"820\":1}}],[\"就像下面这个图一样\",{\"1\":{\"747\":1}}],[\"就像下面这样\",{\"1\":{\"117\":1}}],[\"就像包名一样\",{\"1\":{\"747\":1}}],[\"就像是我们之前使用association和collection那样\",{\"1\":{\"718\":1}}],[\"就像我们的项目\",{\"1\":{\"832\":1}}],[\"就像我们之前在使用constrator标签一样\",{\"1\":{\"717\":1}}],[\"就像我们遍历数组那样\",{\"1\":{\"31\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"599\":1}}],[\"就像hash表一样\",{\"1\":{\"597\":1}}],[\"就像使用普通类型那样\",{\"1\":{\"221\":1}}],[\"就像注释一样\",{\"1\":{\"203\":1}}],[\"就像在这个类定义的方法一样\",{\"1\":{\"121\":1}}],[\"就像你进了公司\",{\"1\":{\"67\":1}}],[\"就跟我们之前的顺序表插入是一样的\",{\"1\":{\"24\":1}}],[\"就是用来处理这种问题的\",{\"1\":{\"911\":1}}],[\"就是用于分割的\",{\"1\":{\"120\":1}}],[\"就是我们的首页\",{\"1\":{\"910\":1}}],[\"就是代表当前servlet的访问路径\",{\"1\":{\"878\":1}}],[\"就是写到里面\",{\"1\":{\"805\":1}}],[\"就是inner标签的一个属性\",{\"1\":{\"634\":1}}],[\"就是\",{\"1\":{\"461\":1}}],[\"就是前面\",{\"1\":{\"452\":1}}],[\"就是进行迭代\",{\"1\":{\"445\":1}}],[\"就是运算规则\",{\"1\":{\"364\":1}}],[\"就是一个典型的web应用服务器软件\",{\"1\":{\"864\":1}}],[\"就是一个已经实现了抽象方法的对象\",{\"1\":{\"255\":1}}],[\"就是一种一对一的联系\",{\"1\":{\"550\":1}}],[\"就是一次遍历执行多个操作\",{\"1\":{\"358\":1}}],[\"就是后面的unaryoperator的参数i一开始的值\",{\"1\":{\"321\":1}}],[\"就是哪个模块用了什么依赖\",{\"1\":{\"308\":1}}],[\"就是说如果这个函数结束时有异常\",{\"1\":{\"266\":1}}],[\"就是内存溢出错误\",{\"1\":{\"264\":1}}],[\"就是将表本身和表进行笛卡尔积计算\",{\"1\":{\"585\":1}}],[\"就是将一个已实现的方法\",{\"1\":{\"258\":1}}],[\"就是将当前集合变成当前集合与给定集合的并集\",{\"1\":{\"23\":1}}],[\"就是创建在内部的类\",{\"1\":{\"250\":1}}],[\"就是专门用于构造字符串的\",{\"1\":{\"245\":1}}],[\"就是0\",{\"1\":{\"235\":1}}],[\"就是null\",{\"1\":{\"235\":1}}],[\"就是精确到最后一位时\",{\"1\":{\"229\":1}}],[\"就是生产者在不断的生产\",{\"1\":{\"174\":1}}],[\"就是使用的对象锁\",{\"1\":{\"155\":1}}],[\"就是使用的类锁\",{\"1\":{\"155\":1}}],[\"就是类锁\",{\"1\":{\"155\":1}}],[\"就是对象锁\",{\"1\":{\"155\":1}}],[\"就是域名\",{\"1\":{\"120\":1}}],[\"就是在运行时进行类型检查\",{\"1\":{\"80\":1}}],[\"就是为了实现这种数据结构而存在的\",{\"1\":{\"55\":1}}],[\"就是不断向后寻找结点\",{\"1\":{\"33\":1}}],[\"就是直接按下标访问\",{\"1\":{\"33\":1}}],[\"就是重复\",{\"1\":{\"24\":1}}],[\"就是求当前集合与给定集合的交集\",{\"1\":{\"23\":1}}],[\"就是求当前集合与给定集合的差集\",{\"1\":{\"23\":1}}],[\"就是看给定集合是不是当前集合的子集\",{\"1\":{\"23\":1}}],[\"就是要操作\",{\"1\":{\"4\":1}}],[\"我被初始化了\",{\"1\":{\"881\":1}}],[\"我被构造了\",{\"1\":{\"9\":1}}],[\"我看你<><><>是一点都不懂哦>>>\",{\"1\":{\"635\":1}}],[\"我的性别是\",{\"1\":{\"616\":1}}],[\"我希望将这两张表结合到一起来查看完整的数据\",{\"1\":{\"586\":1}}],[\"我就想一行解决\",{\"1\":{\"297\":1}}],[\"我现在又有强迫症\",{\"1\":{\"297\":1}}],[\"我会学习\",{\"1\":{\"219\":1,\"220\":1}}],[\"我姓🐴\",{\"1\":{\"198\":1}}],[\"我这里读取的是一个字符串或是一个个字符\",{\"1\":{\"126\":1}}],[\"我是1号过滤器\",{\"1\":{\"920\":2}}],[\"我是2号过滤器\",{\"1\":{\"920\":3}}],[\"我是一个默认的初始化参数\",{\"1\":{\"902\":1}}],[\"我是一个阳光开朗大男孩\",{\"1\":{\"669\":1}}],[\"我是重定向之前的数据\",{\"1\":{\"901\":1}}],[\"我是请求转发前的数据\",{\"1\":{\"900\":1}}],[\"我是响应内容\",{\"1\":{\"875\":1}}],[\"我是内部测试类型2\",{\"1\":{\"805\":2}}],[\"我是内部测试类型1\",{\"1\":{\"805\":2}}],[\"我是外部测试类型\",{\"1\":{\"805\":1}}],[\"我是测试\",{\"1\":{\"852\":1}}],[\"我是测试用例2\",{\"1\":{\"804\":1}}],[\"我是测试用例1\",{\"1\":{\"804\":1}}],[\"我是测试用例3\",{\"1\":{\"804\":1}}],[\"我是测试前必须要执行的准备工作\",{\"1\":{\"802\":2}}],[\"我是测试方法1\",{\"1\":{\"802\":1}}],[\"我是测试方法\",{\"1\":{\"199\":1}}],[\"我是自定义的测试条件\",{\"1\":{\"797\":1}}],[\"我是自定义日志格式\",{\"1\":{\"761\":2}}],[\"我是只在环境变量\",{\"1\":{\"796\":1}}],[\"我是只在arm64架构下做的测试\",{\"1\":{\"796\":1}}],[\"我是只在java8\",{\"1\":{\"795\":1}}],[\"我是只在java8下执行的测试案例\",{\"1\":{\"794\":1}}],[\"我是只在java17下执行的测试案例\",{\"1\":{\"794\":1}}],[\"我是只在windows下执行的测试案例\",{\"1\":{\"793\":1}}],[\"我是只在mac下执行的测试案例\",{\"1\":{\"793\":1}}],[\"我是第三个功能\",{\"1\":{\"773\":1}}],[\"我是第二个功能\",{\"1\":{\"773\":1}}],[\"我是第一个功能\",{\"1\":{\"773\":1}}],[\"我是日志信息\",{\"1\":{\"767\":2,\"849\":1}}],[\"我是普通的日志\",{\"1\":{\"725\":2}}],[\"我是其他要做的事情\",{\"1\":{\"340\":1}}],[\"我是接口中的私有方法\",{\"1\":{\"317\":1}}],[\"我是test方法默认实现\",{\"1\":{\"317\":2}}],[\"我是已经存在的实现\",{\"1\":{\"291\":1}}],[\"我是编译时异常\",{\"1\":{\"266\":1}}],[\"我是学习方法\",{\"1\":{\"257\":2}}],[\"我是匿名内部类的实现\",{\"1\":{\"255\":1}}],[\"我是局部内部类\",{\"1\":{\"253\":1}}],[\"我是静态内部类\",{\"1\":{\"252\":1}}],[\"我是静态方法\",{\"1\":{\"117\":1,\"121\":1}}],[\"我是成员内部类\",{\"1\":{\"251\":2}}],[\"我是默认实现\",{\"1\":{\"219\":1}}],[\"我是工人\",{\"1\":{\"216\":1,\"218\":1}}],[\"我是定时任务\",{\"1\":{\"165\":2}}],[\"我是另一个线程\",{\"1\":{\"140\":2}}],[\"我是代码块\",{\"1\":{\"9\":1}}],[\"我叫🐴nb\",{\"1\":{\"198\":1}}],[\"我叫\",{\"1\":{\"5\":1,\"616\":1}}],[\"我任性\",{\"1\":{\"4\":1}}],[\"我们添加几个输出语句来判断一下\",{\"1\":{\"920\":1}}],[\"我们都可以从httpsession中读取到存储在会话中的数据\",{\"1\":{\"913\":1}}],[\"我们都需要flushstatements\",{\"1\":{\"688\":1}}],[\"我们修改一下默认的请求地址\",{\"1\":{\"910\":1}}],[\"我们修改一下服务器的配置文件\",{\"1\":{\"864\":1}}],[\"我们进行一个真正的用户登录操作\",{\"1\":{\"887\":1}}],[\"我们进入tomcat文件夹bin目录下\",{\"1\":{\"864\":1}}],[\"我们得到是其实是tomcat服务器帮助我们创建的一个实现类\",{\"1\":{\"873\":1}}],[\"我们得到的观测值是\",{\"1\":{\"473\":1}}],[\"我们后面会讲到\",{\"1\":{\"864\":1}}],[\"我们打开\",{\"1\":{\"864\":1}}],[\"我们打开浏览器\",{\"1\":{\"864\":1}}],[\"我们打开idea的安装目录\",{\"1\":{\"827\":1}}],[\"我们所有的测试用例全部编写到maven项目给我们划分的test目录下\",{\"1\":{\"834\":1}}],[\"我们着重来讲解一下scope属性\",{\"1\":{\"833\":1}}],[\"我们尝试使用maven来帮助我们快速导入依赖\",{\"1\":{\"825\":1}}],[\"我们称为一个项目的基本坐标\",{\"1\":{\"820\":1}}],[\"我们称为数据库驱动\",{\"1\":{\"604\":1}}],[\"我们可能需要多次执行才能确定其是否存在某些问题\",{\"1\":{\"806\":1}}],[\"我们可以随意创建和jdk同包同名的类\",{\"1\":{\"926\":1}}],[\"我们可以随意在里面使用特殊字符\",{\"1\":{\"341\":1}}],[\"我们可以再来创建一个过滤器看看效果\",{\"1\":{\"920\":1}}],[\"我们可以自由地进行控制是否进行重定向或是请求转发\",{\"1\":{\"918\":1}}],[\"我们可以自由设定某些操作在测试开始之前或之后执行\",{\"1\":{\"802\":1}}],[\"我们可以给一个servlet添加一些初始化参数\",{\"1\":{\"902\":1}}],[\"我们可以给依赖添加optional标签表示此依赖是可选的\",{\"1\":{\"842\":1}}],[\"我们可以引入一个工具库\",{\"1\":{\"891\":1}}],[\"我们可以获取请求的一些信息\",{\"1\":{\"874\":1}}],[\"我们可以获取到类中所有声明为public的方法\",{\"1\":{\"192\":1}}],[\"我们可以从\",{\"1\":{\"873\":1}}],[\"我们可以多次尝试去访问此页面\",{\"1\":{\"872\":1}}],[\"我们可以重新进行一次打包任务\",{\"1\":{\"854\":1}}],[\"我们可以创建一个dependencies节点\",{\"1\":{\"825\":1}}],[\"我们可以看到在idea右上角maven板块中\",{\"1\":{\"851\":1}}],[\"我们可以看到\",{\"1\":{\"819\":1,\"849\":1}}],[\"我们可以看到其他的类无论是继承a还是继承b都无法通过编译\",{\"1\":{\"347\":1}}],[\"我们可以先来看一下\",{\"1\":{\"818\":1}}],[\"我们可以得到这样的输出结果\",{\"1\":{\"803\":1}}],[\"我们可以来尝试自己配置一个用于控制台打印的handler处理器\",{\"1\":{\"736\":1}}],[\"我们可以来试验一下\",{\"1\":{\"700\":1}}],[\"我们可以来测试一下\",{\"1\":{\"44\":1}}],[\"我们可以提前保存一些测试用例\",{\"1\":{\"773\":1}}],[\"我们可以提前将一部分内容放入缓存\",{\"1\":{\"699\":1}}],[\"我们可以提前准备好合适容量的byte数组来存放\",{\"1\":{\"91\":1}}],[\"我们可以像这样进行编写\",{\"1\":{\"691\":1}}],[\"我们可以开启mybatis的日志来观察具体执行的操作\",{\"1\":{\"669\":1}}],[\"我们可以尝试接着来写一个同时查询id和年龄的查询操作\",{\"1\":{\"651\":1}}],[\"我们可以尝试让服务端一直运行来不断接受客户端的连接\",{\"1\":{\"536\":1}}],[\"我们可以添加一些用于条件判断的标签到xml的sql语句中\",{\"1\":{\"690\":1}}],[\"我们可以添加\",{\"1\":{\"629\":1}}],[\"我们可以添加transient关键字\",{\"1\":{\"133\":1}}],[\"我们可以断点调试一下\",{\"1\":{\"606\":1}}],[\"我们可以打开idea的数据库连接配置\",{\"1\":{\"605\":1}}],[\"我们可以这样来查看支持的引擎\",{\"1\":{\"599\":1}}],[\"我们可以手动指定当前项目的版本号\",{\"1\":{\"820\":1}}],[\"我们可以手动编写一个带调试信息的无参构造\",{\"1\":{\"658\":1}}],[\"我们可以手动配一个resultmap来解决这种问题\",{\"1\":{\"652\":1}}],[\"我们可以手动为驱动管理器添加一个日志打印\",{\"1\":{\"606\":1}}],[\"我们可以手动调整其大小来优化传输效率\",{\"1\":{\"538\":1}}],[\"我们可以手动关闭单向的流\",{\"1\":{\"538\":1}}],[\"我们可以认为\",{\"1\":{\"524\":1}}],[\"我们可以写出\",{\"1\":{\"487\":1}}],[\"我们可以修改为噪音\",{\"1\":{\"473\":1}}],[\"我们可以设计如下方程\",{\"1\":{\"473\":1}}],[\"我们可以确保其可以遍历所有的\",{\"1\":{\"460\":1}}],[\"我们可以生成一个\",{\"1\":{\"452\":1}}],[\"我们可以生成一个统计实例来帮助我们快速进行统计\",{\"1\":{\"71\":1}}],[\"我们可以很轻松的求出各个情况下的q\",{\"1\":{\"451\":1}}],[\"我们可以分析出在该状态下采取哪个\",{\"1\":{\"422\":1}}],[\"我们可以在配置文件\",{\"1\":{\"914\":1}}],[\"我们可以在浏览器中尝试一下\",{\"1\":{\"878\":1}}],[\"我们可以在这里填写我们想要发送给浏览器显示的内容\",{\"1\":{\"875\":1}}],[\"我们可以在网站上搜索junit的依赖\",{\"1\":{\"834\":1}}],[\"我们可以在\",{\"1\":{\"825\":1}}],[\"我们可以在主类中使用日志打印\",{\"1\":{\"725\":1}}],[\"我们可以在获取sqlsession关闭自动提交来开启事务模式\",{\"1\":{\"682\":1}}],[\"我们可以在模块b中去实现一下\",{\"1\":{\"310\":1}}],[\"我们可以在收到中断信号后\",{\"1\":{\"144\":1}}],[\"我们可以为其他模块开放某些运行使用反射的类\",{\"1\":{\"309\":1}}],[\"我们可以为成员变量\",{\"1\":{\"121\":1}}],[\"我们可以对cache标签进行一些配置\",{\"1\":{\"701\":1}}],[\"我们可以对类似于这种匿名内部类的写法\",{\"1\":{\"289\":1}}],[\"我们可以对一个集合进行二分搜索\",{\"1\":{\"77\":1}}],[\"我们可以选择在实现类明确泛型类型\",{\"1\":{\"282\":1}}],[\"我们可以下面的方式实现多种字符匹配\",{\"1\":{\"246\":1}}],[\"我们可以让他等于一个非常大的数字\",{\"1\":{\"229\":1}}],[\"我们可以快速预览当前服务器的一些信息\",{\"1\":{\"864\":1}}],[\"我们可以快速获取到我们标记的注解\",{\"1\":{\"208\":1}}],[\"我们可以快速生成一个只读的list\",{\"1\":{\"25\":1}}],[\"我们可以发现\",{\"1\":{\"193\":1,\"604\":1}}],[\"我们可以把这个容器想象成是一个货架\",{\"1\":{\"174\":1}}],[\"我们可以利用jstack命令来检测死锁\",{\"1\":{\"156\":1}}],[\"我们可以理解为是属于这个类的\",{\"1\":{\"117\":1}}],[\"我们可以通过实现\",{\"1\":{\"870\":1}}],[\"我们可以通过断言工具类assertions来对结果进行判定\",{\"1\":{\"780\":1}}],[\"我们可以通过logger的getparent方法来获取其父logger对象\",{\"1\":{\"744\":1}}],[\"我们可以通过limit来限制查询的数量\",{\"1\":{\"583\":1}}],[\"我们可以通过gethandlers方法来获取logger对象中已经配置的handler对象\",{\"1\":{\"735\":1}}],[\"我们可以通过配置来进行调整\",{\"1\":{\"728\":1}}],[\"我们可以通过二级缓存来实现\",{\"1\":{\"701\":1}}],[\"我们可以通过sqlsessionfactory来创建多个新的会话\",{\"1\":{\"642\":1}}],[\"我们可以通过添加\",{\"1\":{\"629\":2}}],[\"我们可以通过下面的命令创建索引\",{\"1\":{\"597\":1}}],[\"我们可以通过使用getresultset\",{\"1\":{\"608\":1}}],[\"我们可以通过使用grant来为一个数据库用户进行授权\",{\"1\":{\"591\":1}}],[\"我们可以通过使用delete来删除表中的数据\",{\"1\":{\"573\":1}}],[\"我们可以通过\",{\"1\":{\"589\":1}}],[\"我们可以通过order\",{\"1\":{\"581\":1}}],[\"我们可以通过update语句来更新表中的数据\",{\"1\":{\"572\":1}}],[\"我们可以通过drop\",{\"1\":{\"569\":1}}],[\"我们可以通过add来添加一个新的列\",{\"1\":{\"568\":1}}],[\"我们可以通过alter\",{\"1\":{\"568\":1}}],[\"我们可以通过create\",{\"1\":{\"566\":1,\"589\":1,\"596\":1}}],[\"我们可以通过java来实现socket通信\",{\"1\":{\"535\":1}}],[\"我们可以通过一个注解快速生成构造方法\",{\"1\":{\"766\":1}}],[\"我们可以通过一个关键字解决\",{\"1\":{\"308\":1}}],[\"我们可以通过一些特定的算法进行求解\",{\"1\":{\"470\":1}}],[\"我们可以通过前面所引入的\",{\"1\":{\"451\":1}}],[\"我们可以通过对应的迭代算法来求解贝尔曼最优公式\",{\"1\":{\"436\":1}}],[\"我们可以通过对象的引用来间接操作对象\",{\"1\":{\"4\":1}}],[\"我们可以通过继承\",{\"1\":{\"346\":1}}],[\"我们可以通过迭代快速生成一组数据\",{\"1\":{\"321\":1}}],[\"我们可以通过类名直接使用\",{\"1\":{\"272\":1}}],[\"我们可以通过method对象的invoke\",{\"1\":{\"192\":1}}],[\"我们可以通过反射来无视权限修饰符\",{\"1\":{\"192\":1}}],[\"我们可以通过反射来调用类的方法\",{\"1\":{\"192\":1}}],[\"我们可以通过反射机制\",{\"1\":{\"179\":1}}],[\"我们可以通过调用getclass\",{\"1\":{\"659\":1}}],[\"我们可以通过调用getconnection\",{\"1\":{\"606\":1}}],[\"我们可以通过调用setsotimeout\",{\"1\":{\"538\":1}}],[\"我们可以通过调用foreachordered\",{\"1\":{\"173\":1}}],[\"我们可以通过调用cancel\",{\"1\":{\"167\":1}}],[\"我们可以通过此对象来创建任意类型的定时任务\",{\"1\":{\"166\":1}}],[\"我们可以通过创建一个timer类来让它进行定时任务调度\",{\"1\":{\"166\":1}}],[\"我们可以通过包的形式将这些类进行分类存放\",{\"1\":{\"120\":1}}],[\"我们可以通过它来获取文件的输入流\",{\"1\":{\"90\":1}}],[\"我们可以非常高效的从\",{\"1\":{\"48\":1}}],[\"我们可以直接看到\",{\"1\":{\"909\":1}}],[\"我们可以直接获取到该数据\",{\"1\":{\"900\":1}}],[\"我们可以直接发送\",{\"1\":{\"899\":1}}],[\"我们可以直接点击package来进行打包操作\",{\"1\":{\"853\":1}}],[\"我们可以直接设置一系列值\",{\"1\":{\"808\":1}}],[\"我们可以直接使用一个静态变量log\",{\"1\":{\"767\":1}}],[\"我们可以直接使用foreach语法来快速遍历集合类\",{\"1\":{\"34\":1}}],[\"我们可以直接删除掉所有的mapper\",{\"1\":{\"710\":1}}],[\"我们可以直接让一个user对象作为参数传入\",{\"1\":{\"678\":1}}],[\"我们可以直接将其遍历查看\",{\"1\":{\"886\":1}}],[\"我们可以直接将其设置回去\",{\"1\":{\"623\":1}}],[\"我们可以直接将student替换为模式变量\",{\"1\":{\"342\":1}}],[\"我们可以直接将现有的变量丢进去\",{\"1\":{\"323\":1}}],[\"我们可以直接将此方法\",{\"1\":{\"291\":1}}],[\"我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值\",{\"1\":{\"227\":1}}],[\"我们可以直接将一个\",{\"1\":{\"43\":1}}],[\"我们可以直接创建静态内部类的对象\",{\"1\":{\"252\":1}}],[\"我们可以直接在类的内部定义成员内部类\",{\"1\":{\"251\":1}}],[\"我们可以直接通过servlet的getinitparameter方法获取\",{\"1\":{\"902\":1}}],[\"我们可以直接通过\",{\"1\":{\"864\":1}}],[\"我们可以直接通过of方法来快速创建了\",{\"1\":{\"318\":1}}],[\"我们可以直接通过接口名\",{\"1\":{\"219\":1}}],[\"我们可以直接通过method对象来获取这些信息\",{\"1\":{\"192\":1}}],[\"我们可以直接传入一个值\",{\"1\":{\"207\":1}}],[\"我们可以将用户名和密码全部保存在cookie中\",{\"1\":{\"910\":1}}],[\"我们可以将其修改为大于等于0的数\",{\"1\":{\"881\":1}}],[\"我们可以将其名字设定为value\",{\"1\":{\"207\":1}}],[\"我们可以将之前编写的页面放入到webapp目录下\",{\"1\":{\"871\":1}}],[\"我们可以将我们自己的项目也放到webapp文件夹中\",{\"1\":{\"864\":1}}],[\"我们可以将dependencies全部放入dependencymanagement节点\",{\"1\":{\"850\":1}}],[\"我们可以将一些静态资源\",{\"1\":{\"834\":1}}],[\"我们可以将一个类定义为一个泛型类\",{\"1\":{\"281\":1}}],[\"我们可以将查询的结果作为另一个查询的条件\",{\"1\":{\"587\":1}}],[\"我们可以将此数据库删除\",{\"1\":{\"566\":1}}],[\"我们可以将书籍信息进行单独拆分为另一张表\",{\"1\":{\"555\":1}}],[\"我们可以将该问题定义为一个\",{\"1\":{\"484\":1}}],[\"我们可以将这个问题可以转化为一个随机变量的方法\",{\"1\":{\"479\":1}}],[\"我们可以将这个只读的列表作为参数传入\",{\"1\":{\"25\":1}}],[\"我们可以将\",{\"1\":{\"475\":1,\"477\":1,\"478\":1}}],[\"我们可以将任何的变量包装进optional类中使用\",{\"1\":{\"297\":1}}],[\"我们可以将方法标记为静态\",{\"1\":{\"117\":1}}],[\"我们可以将各种需要初始化的操作都在这里进行处理\",{\"1\":{\"9\":1}}],[\"我们可以使用即将要介绍的servletcontext对象\",{\"1\":{\"900\":1}}],[\"我们可以使用第四种作用域\",{\"1\":{\"835\":1}}],[\"我们可以使用此框架来实现日志的规范化打印\",{\"1\":{\"725\":1}}],[\"我们可以使用动态sql来一次性生成一个批量操作的sql语句\",{\"1\":{\"689\":1}}],[\"我们可以使用一个map\",{\"1\":{\"651\":1}}],[\"我们可以使用一个特殊的名字表示泛型\",{\"1\":{\"281\":1}}],[\"我们可以使用preparedstatement来解决\",{\"1\":{\"622\":1}}],[\"我们可以使用pow方法直接计算a的b次方\",{\"1\":{\"274\":1}}],[\"我们可以使用revoke来收回一个权限\",{\"1\":{\"591\":1}}],[\"我们可以使用花括号来将整套逻辑括起来\",{\"1\":{\"340\":1}}],[\"我们可以使用自动类型推断\",{\"1\":{\"328\":1}}],[\"我们可以使用断言表达式来对某些东西进行判断\",{\"1\":{\"268\":1}}],[\"我们可以使用append方法来讲字符串拼接到后面\",{\"1\":{\"245\":1}}],[\"我们可以使用它来对字符串进行拼接\",{\"1\":{\"245\":1}}],[\"我们可以使用getconstructor\",{\"1\":{\"191\":1}}],[\"我们可以使用threadlocal类\",{\"1\":{\"162\":1}}],[\"我们可以使用join\",{\"1\":{\"148\":1}}],[\"我们可以使用\",{\"1\":{\"9\":1,\"49\":1,\"57\":1,\"120\":1,\"714\":1,\"715\":1,\"791\":1}}],[\"我们可以进行一次重载\",{\"1\":{\"8\":1}}],[\"我们肯定希望测试的结果是我们所期望的一个值\",{\"1\":{\"780\":1}}],[\"我们刚刚在filehandler中见到的是默认生成的xmlformatter\",{\"1\":{\"738\":1}}],[\"我们创建的logger默认是不带任何handler对象的\",{\"1\":{\"735\":1}}],[\"我们已经认识了bin目录\",{\"1\":{\"864\":1}}],[\"我们已经体验到mybatis为我们带来的便捷了\",{\"1\":{\"710\":1}}],[\"我们已经知道如何使用mybatis进行各种查询操作\",{\"1\":{\"658\":1}}],[\"我们去掉类上的\",{\"1\":{\"700\":1}}],[\"我们首先来回顾一下tcp的通信原理\",{\"1\":{\"859\":1}}],[\"我们首先来看看一对一查询\",{\"1\":{\"718\":1}}],[\"我们首先来看一下一级缓存\",{\"1\":{\"700\":1}}],[\"我们首先需要创建对象\",{\"1\":{\"251\":1}}],[\"我们基本上可以解决大部分的sql查询和批量处理场景了\",{\"1\":{\"694\":1}}],[\"我们每一次执行sql语句\",{\"1\":{\"688\":1}}],[\"我们每次上菜的时候只从厨房端一个菜\",{\"1\":{\"688\":1}}],[\"我们每次都需要去找映射器对应操作的名称\",{\"1\":{\"659\":1}}],[\"我们接着来了解一下测试类的生命周期\",{\"1\":{\"803\":1}}],[\"我们接着来尝试将日志记录到我们本地的文件中\",{\"1\":{\"737\":1}}],[\"我们接着来测试一下回滚操作\",{\"1\":{\"682\":1}}],[\"我们接着来看loadonstartup属性\",{\"1\":{\"881\":1}}],[\"我们接着来看webservlet注解\",{\"1\":{\"877\":1}}],[\"我们接着来看package命令\",{\"1\":{\"853\":1}}],[\"我们接着来看mybatis\",{\"1\":{\"768\":1}}],[\"我们接着来看修改操作\",{\"1\":{\"680\":1}}],[\"我们接着来看修改相关操作\",{\"1\":{\"677\":1}}],[\"我们接着来看一对多查询\",{\"1\":{\"670\":1}}],[\"我们接着来看更方便的用法\",{\"1\":{\"660\":1}}],[\"我们现在循环地每三秒读取一次\",{\"1\":{\"705\":1}}],[\"我们现在同样需要使用resultmap来自定义映射规则\",{\"1\":{\"666\":1}}],[\"我们现在只拿到了一个inputstream\",{\"1\":{\"126\":1}}],[\"我们使用的始终是jdk中提供的接口\",{\"1\":{\"833\":1}}],[\"我们使用setuseparenthandlers方法来屏蔽所有父级提供的日志处理器\",{\"1\":{\"735\":1}}],[\"我们使用其他软件手动修改数据库中的数据\",{\"1\":{\"705\":1}}],[\"我们使用一个map作为参数\",{\"1\":{\"660\":1}}],[\"我们使用instanceof进行类型比较\",{\"1\":{\"186\":1}}],[\"我们放在最后一节进行讲解\",{\"1\":{\"659\":1}}],[\"我们主要还是以selectone和selectlist为主\",{\"1\":{\"653\":1}}],[\"我们再来了解一下http的报文结构\",{\"1\":{\"859\":1}}],[\"我们再来看看之前在resultmap中配置的关联查询该如何编写\",{\"1\":{\"718\":1}}],[\"我们再来看一个例子\",{\"1\":{\"694\":1}}],[\"我们再来尝试编写一下查询一个列表\",{\"1\":{\"653\":1}}],[\"我们再来使用这个对象的泛型成员\",{\"1\":{\"15\":1}}],[\"我们输入的参数一旦出现\",{\"1\":{\"622\":1}}],[\"我们输入以下命令来看看能否访问所有数据库\",{\"1\":{\"590\":1}}],[\"我们该怎么去写\",{\"1\":{\"621\":1}}],[\"我们仍可在old表中拿到被删除的数据\",{\"1\":{\"598\":1}}],[\"我们仍需要估计\",{\"1\":{\"453\":1}}],[\"我们平时所说的crud其实就是增删改查\",{\"1\":{\"561\":1}}],[\"我们平时使用的println方法就是printstream中的方法\",{\"1\":{\"127\":1}}],[\"我们要限制某个测试案例只在指定操作系统下进行\",{\"1\":{\"793\":1}}],[\"我们要学习的就是以下四种类型的sql语言\",{\"1\":{\"561\":1}}],[\"我们要学习一下每一个表该如何去设计\",{\"1\":{\"552\":1}}],[\"我们要创建一个数组\",{\"1\":{\"235\":1}}],[\"我们便称为\",{\"1\":{\"530\":1}}],[\"我们定义\",{\"1\":{\"522\":1}}],[\"我们定义最优的策略为\",{\"1\":{\"522\":1}}],[\"我们定义的每一个状态其实就是一个public\",{\"1\":{\"221\":1}}],[\"我们先在前端页面的表单中添加一个勾选框\",{\"1\":{\"910\":1}}],[\"我们先点击取消\",{\"1\":{\"864\":1}}],[\"我们先直接求解\",{\"1\":{\"516\":1}}],[\"我们先来看第一种方式\",{\"1\":{\"667\":1}}],[\"我们先来看看如果我们想模拟登陆一个用户\",{\"1\":{\"621\":1}}],[\"我们先来看看下面这个例子\",{\"1\":{\"297\":1}}],[\"我们先来看看队列接口\",{\"1\":{\"43\":1}}],[\"我们先来测试一下它的特性\",{\"1\":{\"48\":1}}],[\"我们是无法估计的\",{\"1\":{\"510\":1}}],[\"我们是引入了\",{\"1\":{\"479\":1}}],[\"我们是没办法直接得到的\",{\"1\":{\"343\":1}}],[\"我们是没办法在其他地方使用的\",{\"1\":{\"328\":1}}],[\"我们很难直接获得\",{\"1\":{\"475\":1}}],[\"我们有以下几种方法\",{\"1\":{\"475\":1}}],[\"我们采用的是\",{\"1\":{\"461\":1}}],[\"我们选取其\",{\"1\":{\"453\":1}}],[\"我们不用去修改\",{\"1\":{\"819\":1}}],[\"我们不需要删除这些多余的构造方法\",{\"1\":{\"658\":1}}],[\"我们不断地与环境进行交互\",{\"1\":{\"509\":1}}],[\"我们不能直接得到随机变量的值\",{\"1\":{\"473\":1}}],[\"我们不能通过之前的方法来求出q\",{\"1\":{\"451\":1}}],[\"我们不仅可以用来估计q\",{\"1\":{\"455\":1}}],[\"我们不仅可以通过构造方法\",{\"1\":{\"9\":1}}],[\"我们这里就演示一下监听session的创建即可\",{\"1\":{\"922\":1}}],[\"我们这里导入最新的junit5作为依赖\",{\"1\":{\"834\":1}}],[\"我们这里指定了jdk的源代码和编译版本为17\",{\"1\":{\"820\":1}}],[\"我们这里强行初始化为vπ0​​\",{\"1\":{\"444\":1}}],[\"我们这里要删除的是刚刚传入的值为10的integer对象\",{\"1\":{\"25\":1}}],[\"我们通常将\",{\"1\":{\"401\":1}}],[\"我们通过添加\",{\"1\":{\"629\":2}}],[\"我们通过实战来演示一下lombok的实用注解\",{\"1\":{\"629\":1}}],[\"我们通过以下例子来探究以下事务\",{\"1\":{\"599\":1}}],[\"我们通过\",{\"1\":{\"191\":1}}],[\"我们通过使用\",{\"1\":{\"117\":1}}],[\"我们通过保存键值对的形式来存储映射关系\",{\"1\":{\"55\":1}}],[\"我们对无人机的发射功率有一个约束\",{\"1\":{\"383\":1}}],[\"我们对于集合的一些操作就大大地简化了\",{\"1\":{\"319\":1}}],[\"我们甚至可以轻松地做一个爬虫\",{\"1\":{\"333\":1}}],[\"我们同时处理两种情况\",{\"1\":{\"323\":1}}],[\"我们同样需要使用\",{\"1\":{\"719\":1}}],[\"我们同样需要使用对象来进行方法引用\",{\"1\":{\"258\":1}}],[\"我们同样可以进行简单的条件查询\",{\"1\":{\"653\":1}}],[\"我们同样可以使用\",{\"1\":{\"57\":1}}],[\"我们一次输入一行\",{\"1\":{\"316\":1}}],[\"我们一般使用http协议\",{\"1\":{\"859\":1}}],[\"我们一般只会在测试阶段使用junit\",{\"1\":{\"833\":1}}],[\"我们一般只会在类的内部自己使用\",{\"1\":{\"251\":1}}],[\"我们一般都使用\",{\"1\":{\"648\":1}}],[\"我们一般通过create\",{\"1\":{\"567\":1}}],[\"我们一般称为限定符\",{\"1\":{\"246\":1}}],[\"我们少考虑了一个问题\",{\"1\":{\"297\":1}}],[\"我们注意到comparator要求我们实现的方法为\",{\"1\":{\"294\":1}}],[\"我们为所需要的接口提供了一个方法作为它的实现\",{\"1\":{\"291\":1}}],[\"我们希望这个案例抛出指定的异常\",{\"1\":{\"790\":1}}],[\"我们希望能够分不同情况处理不同类型的异常\",{\"1\":{\"267\":1}}],[\"我们希望cpu花费更多的时间去处理更重要的任务\",{\"1\":{\"145\":1}}],[\"我们抛出异常实际上就是将这个异常对象抛出\",{\"1\":{\"266\":1}}],[\"我们自己创建的一个java项目\",{\"1\":{\"306\":1}}],[\"我们自己写的java模块项目\",{\"1\":{\"306\":1}}],[\"我们自己写的都行\",{\"1\":{\"36\":1}}],[\"我们自定义异常也是从这两类中进行选择\",{\"1\":{\"265\":1}}],[\"我们知道日志的默认打印级别为info\",{\"1\":{\"729\":1}}],[\"我们知道\",{\"1\":{\"243\":1,\"658\":1,\"768\":1,\"900\":1}}],[\"我们如果需要控制单个方法的缓存\",{\"1\":{\"720\":1}}],[\"我们如果直接让\",{\"1\":{\"227\":1}}],[\"我们如果想一次性全部读取的话\",{\"1\":{\"91\":1}}],[\"我们如果想要在方法中访问到当前对象的属性\",{\"1\":{\"7\":1}}],[\"我们直接将其添加到dependencies节点中即可\",{\"1\":{\"825\":1}}],[\"我们直接使用即可\",{\"1\":{\"605\":1}}],[\"我们直接使用成员变量即可\",{\"1\":{\"5\":1}}],[\"我们直接调用父类的实现就可以了\",{\"1\":{\"220\":1}}],[\"我们无法完全通过注解来实现之前的联合查询解析\",{\"1\":{\"718\":1}}],[\"我们无法在代码中直接使用此类型\",{\"1\":{\"199\":1}}],[\"我们无论通过什么方式访问\",{\"1\":{\"180\":1}}],[\"我们把它放到根目录下\",{\"1\":{\"199\":1}}],[\"我们来看一下http的传输过程\",{\"1\":{\"859\":1}}],[\"我们来看看各个加载器的不同之处\",{\"1\":{\"926\":1}}],[\"我们来看看maven项目的依赖管理流程\",{\"1\":{\"826\":1}}],[\"我们来看看这个例子\",{\"1\":{\"705\":1}}],[\"我们来看看这里面是怎么定义的\",{\"1\":{\"58\":1}}],[\"我们来看看下面这段代码\",{\"1\":{\"700\":1}}],[\"我们来看看实际执行的sql语句是什么\",{\"1\":{\"622\":1}}],[\"我们来看看如何从resultset中去获取数据\",{\"1\":{\"614\":1}}],[\"我们来看看它的详细规则\",{\"1\":{\"340\":1}}],[\"我们来看看是不是类型也能正常获取\",{\"1\":{\"328\":1}}],[\"我们来看看以下这段代码会得到什么结果\",{\"1\":{\"156\":1}}],[\"我们来看看resize\",{\"1\":{\"60\":1}}],[\"我们来编写一个测试用例尝试一下\",{\"1\":{\"849\":1}}],[\"我们来尝试编写一下\",{\"1\":{\"765\":1}}],[\"我们来尝试编写一个插入操作\",{\"1\":{\"678\":1}}],[\"我们来尝试以全注解的形式重现编写咱们的sql语句映射\",{\"1\":{\"710\":1}}],[\"我们来尝试一下直接读取实体类\",{\"1\":{\"643\":1}}],[\"我们来接着尝试一下使用回滚操作\",{\"1\":{\"623\":1}}],[\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的sql语句\",{\"1\":{\"587\":1}}],[\"我们来试试看向我们刚刚创建的表中添加三条数据\",{\"1\":{\"571\":1}}],[\"我们来试试看修改成员字段之后\",{\"1\":{\"199\":1}}],[\"我们来试试看修改一些其他的类型\",{\"1\":{\"193\":1}}],[\"我们来试试看创建一个此类的对象并调用其方法\",{\"1\":{\"199\":1}}],[\"我们也体会到lombok给我们带来的便捷\",{\"1\":{\"766\":1}}],[\"我们也没有导入student类\",{\"1\":{\"192\":1}}],[\"我们也可以在代码中使用invalidate方法来使session立即失效\",{\"1\":{\"914\":1}}],[\"我们也可以在web\",{\"1\":{\"871\":1}}],[\"我们也可以在类中添加代码块\",{\"1\":{\"9\":1}}],[\"我们也可以访问example项目\",{\"1\":{\"864\":1}}],[\"我们也可以传入空值或是一些为空的字符串\",{\"1\":{\"809\":1}}],[\"我们也可以利用这些属性来编写一个类似于的simpleformatter的日志格式\",{\"1\":{\"765\":1}}],[\"我们也可以利用反射机制来将查询结果映射为对象\",{\"1\":{\"616\":1}}],[\"我们也可以通过这种方式来获取我们的一些系统属性\",{\"1\":{\"755\":1}}],[\"我们也可以通过log方法来主动设定该条日志的输出级别\",{\"1\":{\"728\":1}}],[\"我们也可以通过下面的命令删除一个索引\",{\"1\":{\"597\":1}}],[\"我们也可以单独配置其不使用二级缓存\",{\"1\":{\"703\":1}}],[\"我们也可以去创建一个回滚点来实现定点回滚\",{\"1\":{\"623\":1}}],[\"我们也可以去修改为其他的引擎\",{\"1\":{\"599\":1}}],[\"我们也可以进行关联查询来让mybatis自动解析结果并封装为对象\",{\"1\":{\"670\":1}}],[\"我们也可以进行分页\",{\"1\":{\"583\":1}}],[\"我们也可以进行近似\",{\"1\":{\"530\":1}}],[\"我们也可以可以同时添加多个排序\",{\"1\":{\"581\":1}}],[\"我们也可以添加where字句来限定查询目标\",{\"1\":{\"579\":1}}],[\"我们也可以一次性向数据库中插入多条数据\",{\"1\":{\"571\":1}}],[\"我们也可以快速创建一个方法供后续的调用\",{\"1\":{\"316\":1}}],[\"我们也可以直接读取环境变量\",{\"1\":{\"796\":1}}],[\"我们也可以直接对某个boolean类型的结果快速进行判断\",{\"1\":{\"787\":1}}],[\"我们也可以直接将其绑定到一个接口上\",{\"1\":{\"678\":1}}],[\"我们也可以直接将这两个参数定义到形参列表中\",{\"1\":{\"660\":1}}],[\"我们也可以直接指定将包暴露给指定的模块\",{\"1\":{\"307\":1}}],[\"我们也可以直接使用java\",{\"1\":{\"306\":1}}],[\"我们也可以写一个\",{\"1\":{\"290\":1}}],[\"我们也可以定义全局初始化参数\",{\"1\":{\"903\":1}}],[\"我们也可以定义多个\",{\"1\":{\"281\":1}}],[\"我们也可以定义泛型方法\",{\"1\":{\"14\":1}}],[\"我们也可以手动跳过\",{\"1\":{\"853\":1}}],[\"我们也可以手动修改测试类的初始化行为\",{\"1\":{\"803\":1}}],[\"我们也可以手动指定名称\",{\"1\":{\"767\":1}}],[\"我们也可以手动指定版本\",{\"1\":{\"132\":1}}],[\"我们也可以手动添加一个\",{\"1\":{\"660\":1}}],[\"我们也可以手动声明\",{\"1\":{\"9\":1}}],[\"我们也可以使用常见的压缩工具打开jar包查看其内部文件\",{\"1\":{\"853\":1}}],[\"我们也可以使用特定的方法来生成我们需要的测试参数\",{\"1\":{\"811\":1}}],[\"我们也可以使用枚举值来进行测试\",{\"1\":{\"810\":1}}],[\"我们也可以使用java8的lambda来编写结果判断逻辑\",{\"1\":{\"789\":1}}],[\"我们也可以使用\",{\"1\":{\"777\":1}}],[\"我们也可以使用where来添加条件\",{\"1\":{\"573\":1}}],[\"我们也可以使用or\",{\"1\":{\"323\":1}}],[\"我们也可以使用default关键字来为这些属性指定默认值\",{\"1\":{\"207\":1}}],[\"我们也可以使用stop\",{\"1\":{\"142\":1}}],[\"我们也可以使用scanner来扫描其他的输入流\",{\"1\":{\"128\":1}}],[\"我们也可以使用泛型来表示\",{\"1\":{\"14\":1}}],[\"我们也可以让它向文件中打印\",{\"1\":{\"127\":1}}],[\"我们也可以寻找子集合的位置\",{\"1\":{\"80\":1}}],[\"我们也可以将一个可修改的集合变成只读的集合\",{\"1\":{\"79\":1}}],[\"我们也可以对集合的元素进行快速填充\",{\"1\":{\"78\":1}}],[\"我们也可以只通过stream来完成所有数字的和\",{\"1\":{\"71\":1}}],[\"我们也可以为所有的方法单个插入准备工作\",{\"1\":{\"802\":1}}],[\"我们也可以为本次断言添加一个message来助于我们快速了解是什么类型的测试结果出现问题\",{\"1\":{\"786\":1}}],[\"我们也可以为这种情况添加一个预备方案\",{\"1\":{\"57\":1}}],[\"我们也可以为构造方法设定参数\",{\"1\":{\"9\":1}}],[\"我们也可以自定义我们想要的日志打印格式\",{\"1\":{\"761\":1}}],[\"我们也可以自定义排序规则\",{\"1\":{\"50\":1}}],[\"我们也可以自定义比较规则\",{\"1\":{\"46\":1}}],[\"我们也可以不对任何对象进行引用\",{\"1\":{\"4\":1}}],[\"我们从\",{\"1\":{\"186\":1}}],[\"我们从开始\",{\"1\":{\"138\":1}}],[\"我们前面已经得知\",{\"1\":{\"877\":1}}],[\"我们前面学习tcp通信的时候已经介绍过了\",{\"1\":{\"859\":1}}],[\"我们前面提到的stop\",{\"1\":{\"144\":1}}],[\"我们前面创建对象\",{\"1\":{\"9\":1}}],[\"我们需要完成后面内容的学习\",{\"1\":{\"903\":1}}],[\"我们需要填写servlet上指明的路径\",{\"1\":{\"900\":1}}],[\"我们需要修改一下我们的servlet\",{\"1\":{\"886\":1}}],[\"我们需要修改一下配置文件中的mapper文件目录\",{\"1\":{\"659\":1}}],[\"我们需要导入之前的jdbc驱动依赖\",{\"1\":{\"825\":1}}],[\"我们需要导入mybatis的依赖\",{\"1\":{\"641\":1}}],[\"我们需要使用servletcontext来读取全局初始化参数\",{\"1\":{\"903\":1}}],[\"我们需要使用另一个插件来实现一起打包\",{\"1\":{\"854\":1}}],[\"我们需要使用resources类的getresourceasstream来获取内部的资源文件\",{\"1\":{\"834\":1}}],[\"我们需要使用国内的镜像仓库服务器来加速访问\",{\"1\":{\"827\":1}}],[\"我们需要使用\",{\"1\":{\"778\":1}}],[\"我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试\",{\"1\":{\"773\":1}}],[\"我们需要进行一个简单的环境搭建\",{\"1\":{\"864\":1}}],[\"我们需要进行配置\",{\"1\":{\"768\":1}}],[\"我们需要进行导入\",{\"1\":{\"307\":1}}],[\"我们需要同时调整handler和logger的level属性\",{\"1\":{\"729\":1}}],[\"我们需要先创建一个类编写我们的动态sql操作\",{\"1\":{\"719\":1}}],[\"我们需要先修改访问权限\",{\"1\":{\"191\":1}}],[\"我们需要手动为其起个别名\",{\"1\":{\"672\":1}}],[\"我们需要配置一个collection标签来让其可以正确处理关联的集合结果\",{\"1\":{\"670\":1}}],[\"我们需要一种更加简洁高效的方式来和数据库进行交互\",{\"1\":{\"633\":1}}],[\"我们需要一种更加安全的机制来维持秩序\",{\"1\":{\"154\":1}}],[\"我们需要提前给到preparedstatement一个sql语句\",{\"1\":{\"622\":1}}],[\"我们需要更多的用户来一起管理整个数据库\",{\"1\":{\"588\":1}}],[\"我们需要创建什么样子的表\",{\"1\":{\"551\":1}}],[\"我们需要从经验池\",{\"1\":{\"516\":1}}],[\"我们需要思考使用\",{\"1\":{\"478\":1}}],[\"我们需要保证策略是不断提升\",{\"1\":{\"442\":1}}],[\"我们需要找到一个\",{\"1\":{\"400\":1}}],[\"我们需要对继承关系有一些限制的控制手段\",{\"1\":{\"346\":1}}],[\"我们需要传入一个runnable接口的实现类\",{\"1\":{\"288\":1}}],[\"我们需要在tomcat官网下载最新的tomcat服务端程序\",{\"1\":{\"864\":1}}],[\"我们需要在映射器xml文件中添加\",{\"1\":{\"701\":1}}],[\"我们需要在resultmap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系\",{\"1\":{\"670\":1}}],[\"我们需要在java程序启动时\",{\"1\":{\"641\":1}}],[\"我们需要在里面添加1\",{\"1\":{\"281\":1}}],[\"我们需要在虚拟机参数中手动开启一下\",{\"1\":{\"268\":1}}],[\"我们需要在使用时手动指定注解的属性名称\",{\"1\":{\"207\":1}}],[\"我们需要用到反射机制\",{\"1\":{\"208\":1}}],[\"我们需要明确指定一下\",{\"1\":{\"120\":1}}],[\"我们需要结合具体的场景来决定\",{\"1\":{\"25\":1}}],[\"我们将请求转发给处理时间的servlet\",{\"1\":{\"900\":1}}],[\"我们将\",{\"1\":{\"512\":1}}],[\"我们将类放到包中\",{\"1\":{\"120\":1}}],[\"我们将变量p2赋值为p1的值\",{\"1\":{\"4\":1}}],[\"我们之前在学习mybatis的时候学习了xml\",{\"1\":{\"753\":1}}],[\"我们之前在计算机组成原理中可能学习过缓存一致性问题\",{\"1\":{\"705\":1}}],[\"我们之前的例子就失效了\",{\"1\":{\"622\":1}}],[\"我们之前使用了executequery\",{\"1\":{\"608\":1}}],[\"我们之前使用的都是通过构造方法直接连接服务端\",{\"1\":{\"538\":1}}],[\"我们之前学习的类就是对现实世界数据的一种抽象\",{\"1\":{\"550\":1}}],[\"我们之前都是直接创建的类\",{\"1\":{\"120\":1}}],[\"我们之前一个结点只有键\",{\"1\":{\"58\":1}}],[\"我们实际上是将\",{\"1\":{\"118\":1}}],[\"我们并不会通过一个具体的对象去修改和使用静态属性\",{\"1\":{\"117\":1}}],[\"我们发现这个接口中定义了大量数据库操作的方法\",{\"1\":{\"642\":1}}],[\"我们发现除了普通的statement\",{\"1\":{\"607\":1}}],[\"我们发现浏览器是无法打开这个链接的\",{\"1\":{\"544\":1}}],[\"我们发现如果我们依赖了一个模块\",{\"1\":{\"309\":1}}],[\"我们发现现在不见了\",{\"1\":{\"304\":1}}],[\"我们发现integer类中有一个compareto方法\",{\"1\":{\"294\":1}}],[\"我们发现type实际上是class类的父接口\",{\"1\":{\"186\":1}}],[\"我们发现实际上效果是相同的\",{\"1\":{\"155\":1}}],[\"我们发现\",{\"1\":{\"147\":1,\"148\":1,\"156\":1,\"173\":1,\"192\":1,\"227\":1,\"296\":1,\"590\":1,\"608\":1,\"621\":1,\"622\":3,\"627\":2,\"641\":1,\"659\":1,\"682\":1,\"725\":1,\"766\":1,\"834\":1,\"850\":1,\"864\":1,\"871\":1,\"874\":1,\"876\":1,\"900\":1,\"909\":1,\"919\":1,\"920\":1}}],[\"我们发现虽然后面的部分没有保存\",{\"1\":{\"108\":1}}],[\"我们发现得到的是一个optional类实例\",{\"1\":{\"71\":1}}],[\"我们惊奇地发现\",{\"1\":{\"80\":1}}],[\"我们想快速求得list中的最大值和最小值\",{\"1\":{\"76\":1}}],[\"我们想让每一个元素通过\",{\"1\":{\"71\":1}}],[\"我们想要遍历一个集合中所有的元素\",{\"1\":{\"33\":1}}],[\"我们用一堆随机数来进行更多流操作的演示\",{\"1\":{\"71\":1}}],[\"我们用就完事\",{\"1\":{\"60\":1}}],[\"我们还需要单独编写一个类来做这种事情\",{\"1\":{\"719\":1}}],[\"我们还需要理解其所描述的最优策略π∗\",{\"1\":{\"430\":1}}],[\"我们还需要去依赖对应的模块\",{\"1\":{\"311\":1}}],[\"我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题\",{\"1\":{\"60\":1}}],[\"我们还可以为一个servlet配置多个访问路径\",{\"1\":{\"880\":1}}],[\"我们还可以为测试案例添加一个自定义的名称\",{\"1\":{\"778\":1}}],[\"我们还可以通过使用test命令\",{\"1\":{\"852\":1}}],[\"我们还可以通过flat来对整个流进行进一步细分\",{\"1\":{\"71\":1}}],[\"我们还可以让父maven项目统一管理所有的依赖\",{\"1\":{\"850\":1}}],[\"我们还可以直接从系统属性中获取我们需要的参数来进行判断\",{\"1\":{\"795\":1}}],[\"我们还可以利用单元测试来评估某个模块或是功能的耗时和性能\",{\"1\":{\"773\":1}}],[\"我们还可以使用它来完成更多操作\",{\"1\":{\"874\":1}}],[\"我们还可以使用assertall来包含多个判断操作\",{\"1\":{\"789\":1}}],[\"我们还可以使用注解进行动态sql的配置\",{\"1\":{\"719\":1}}],[\"我们还可以使用\",{\"1\":{\"629\":1}}],[\"我们还可以使用executeupdate\",{\"1\":{\"608\":1}}],[\"我们还可以使用方法引用\",{\"1\":{\"257\":1}}],[\"我们还可以添加having来限制分组条件\",{\"1\":{\"583\":1}}],[\"我们还可以指定模块需要使用的抽象类或是接口实现\",{\"1\":{\"310\":1}}],[\"我们还可以指定如果get的对象为null的替代方案\",{\"1\":{\"297\":1}}],[\"我们还可以在注解中定义一些属性\",{\"1\":{\"207\":1}}],[\"我们还可以在当前线程的工作不重要时\",{\"1\":{\"147\":1}}],[\"我们还可以对byte\",{\"1\":{\"199\":1}}],[\"我们还会回来看我们\",{\"1\":{\"50\":1}}],[\"我们只需右键左侧栏\",{\"1\":{\"849\":1}}],[\"我们只需要重写这些具体方法就行\",{\"1\":{\"876\":1}}],[\"我们只需要实现servlet类即可\",{\"1\":{\"871\":1}}],[\"我们只需要执行java\",{\"1\":{\"854\":1}}],[\"我们只需要点击类旁边的运行按钮\",{\"1\":{\"776\":1}}],[\"我们只需要继承formatter类\",{\"1\":{\"761\":1}}],[\"我们只需要直接通过浏览器访问我们的项目即可\",{\"1\":{\"864\":1}}],[\"我们只需要直接在其中编写sql语句即可\",{\"1\":{\"713\":1}}],[\"我们只需要直接拿来用就行了\",{\"1\":{\"23\":1}}],[\"我们只需要编写对应的映射器\",{\"1\":{\"710\":1}}],[\"我们只需要让查询出来的每一个用户都左连接分组信息即可\",{\"1\":{\"672\":1}}],[\"我们只需要告诉一个映射关系\",{\"1\":{\"643\":1}}],[\"我们只需要挑选在当前迭代下最大的\",{\"1\":{\"437\":1}}],[\"我们只需要在最后添加一句\",{\"1\":{\"920\":1}}],[\"我们只需要在对应的\",{\"1\":{\"876\":1}}],[\"我们只需要在编译阶段使用它\",{\"1\":{\"833\":1}}],[\"我们只需要在创建sqlsession时进行一些配置即可\",{\"1\":{\"688\":1}}],[\"我们只需要在mybatis的配置文件中进行编写即可\",{\"1\":{\"649\":1}}],[\"我们只需要在一张表中去查找数据即可\",{\"1\":{\"579\":1}}],[\"我们只需要在当前状态下\",{\"1\":{\"431\":1}}],[\"我们只需要在类名前面把完整的包名也给写上\",{\"1\":{\"120\":1}}],[\"我们只需要输入jshell命令即可开启交互式编程了\",{\"1\":{\"316\":1}}],[\"我们只需要使用\",{\"1\":{\"5\":1}}],[\"我们只能关闭所有二级缓存\",{\"1\":{\"705\":1}}],[\"我们只能通过\",{\"1\":{\"471\":1}}],[\"我们只能使用对应的包装类\",{\"1\":{\"281\":1}}],[\"我们只能去创建它的子类对象\",{\"1\":{\"218\":1}}],[\"我们只能把它当做一个不得已才去使用的工具\",{\"1\":{\"193\":1}}],[\"我们只能简单的删除\",{\"1\":{\"48\":1}}],[\"我们在用户登录成功之后\",{\"1\":{\"913\":1}}],[\"我们在登陆成功时进行判断\",{\"1\":{\"910\":1}}],[\"我们在登陆成功之后\",{\"1\":{\"899\":1}}],[\"我们在webapp目录下新建test文件夹\",{\"1\":{\"864\":1}}],[\"我们在前面已经给大家讲解过了\",{\"1\":{\"864\":1}}],[\"我们在前面介绍了arrays\",{\"1\":{\"75\":1}}],[\"我们在配置\",{\"1\":{\"718\":1}}],[\"我们在配置文件中添加这个mapper映射器\",{\"1\":{\"643\":1}}],[\"我们在查询时\",{\"1\":{\"699\":1}}],[\"我们在查询时mybatis就可以自动把额外信息也封装好了\",{\"1\":{\"667\":1}}],[\"我们在里面写入了一个select标签\",{\"1\":{\"643\":1}}],[\"我们在移动行数后\",{\"1\":{\"614\":1}}],[\"我们在某些情况下可能需要用到匿名内部类\",{\"1\":{\"288\":1}}],[\"我们在方法中使用待确定类型的变量时\",{\"1\":{\"281\":1}}],[\"我们在重写方法时\",{\"1\":{\"266\":1}}],[\"我们在重写父类方法时\",{\"1\":{\"216\":1}}],[\"我们在之前其实已经接触过一些异常了\",{\"1\":{\"264\":1}}],[\"我们在编写程序时\",{\"1\":{\"156\":1}}],[\"我们在自己的包中也建一个名为string的类\",{\"1\":{\"120\":1}}],[\"我们在\",{\"1\":{\"118\":1}}],[\"我们在创建时可以设定编码格式\",{\"1\":{\"566\":1}}],[\"我们在创建时\",{\"1\":{\"62\":1}}],[\"我们在正常插入一个键值对时\",{\"1\":{\"60\":1}}],[\"我们在获取所有键和所有值时\",{\"1\":{\"57\":1}}],[\"我们在获取一个不存在的映射时\",{\"1\":{\"57\":1}}],[\"我们在这里先不去探讨实现原理\",{\"1\":{\"48\":1}}],[\"我们在使用注解传参时\",{\"1\":{\"207\":1}}],[\"我们在使用\",{\"1\":{\"25\":1}}],[\"我们的页面已经基本完善为我们想要的样子了\",{\"1\":{\"921\":1}}],[\"我们的请求只有穿过层层阻碍\",{\"1\":{\"918\":1}}],[\"我们的请求现在是被另一个servlet进行处理\",{\"1\":{\"900\":1}}],[\"我们的浏览器会去重新请求另一个网址\",{\"1\":{\"899\":1}}],[\"我们的浏览器请求一个页面\",{\"1\":{\"859\":1}}],[\"我们的maven项目也是这样\",{\"1\":{\"820\":1}}],[\"我们的项目可能会很庞大\",{\"1\":{\"773\":1}}],[\"我们的内容是没有进入到数据库的\",{\"1\":{\"682\":1}}],[\"我们的数据插入后使用的是一个自增主键id\",{\"1\":{\"679\":1}}],[\"我们的数据可以交给数据库来帮助我们进行管理\",{\"1\":{\"549\":1}}],[\"我们的查询操作可能需要不止一个参数\",{\"1\":{\"660\":1}}],[\"我们的每一个异常也是一个类\",{\"1\":{\"264\":1}}],[\"我们的包就可以命名为com\",{\"1\":{\"120\":1}}],[\"我们的元素之间是两两对应的\",{\"1\":{\"55\":1}}],[\"我们的插入顺序虽然是10\",{\"1\":{\"46\":1}}],[\"我们的方法需要能够同时应对多种情况\",{\"1\":{\"8\":1}}],[\"我们会继续学习redis\",{\"1\":{\"705\":1}}],[\"我们会发现我们本地存在一个\",{\"1\":{\"826\":1}}],[\"我们会发现\",{\"1\":{\"643\":1,\"658\":1}}],[\"我们会使用接口的引用\",{\"1\":{\"25\":1}}],[\"我们会在日志中惊奇地发现\",{\"1\":{\"700\":1}}],[\"我们会在第六章多线程部分中讲解\",{\"1\":{\"215\":1}}],[\"我们会在第五章集合类中使用到\",{\"1\":{\"215\":1}}],[\"我们会在jvm篇视频教程中进行介绍\",{\"1\":{\"215\":1}}],[\"我们会在下一章多线程部分中进行介绍\",{\"1\":{\"23\":2}}],[\"我们会在后面讲解\",{\"1\":{\"643\":1}}],[\"我们会在后面继续了解\",{\"1\":{\"142\":1}}],[\"我们会在后面进行详细介绍\",{\"1\":{\"25\":1}}],[\"我们会在后面进行讲解\",{\"1\":{\"23\":1}}],[\"我们会在后面进行介绍\",{\"1\":{\"23\":1}}],[\"我们会在后面介绍\",{\"1\":{\"23\":1}}],[\"我们就用不到测试了\",{\"1\":{\"833\":1}}],[\"我们就将默认的远程仓库地址\",{\"1\":{\"827\":1}}],[\"我们就将此class文件读取并解析为class了\",{\"1\":{\"199\":1}}],[\"我们就暂时介绍到这里\",{\"1\":{\"721\":1}}],[\"我们就提到过批量执行语句的问题\",{\"1\":{\"688\":1}}],[\"我们就告诉了mybatis我们链接数据库的一些信息\",{\"1\":{\"641\":1}}],[\"我们就需要使用mybatis提前帮助我们规定好的标签来进行配置\",{\"1\":{\"641\":1}}],[\"我们就需要使用到泛型的上界定义\",{\"1\":{\"15\":1}}],[\"我们就需要执行大量的sql语句来完成\",{\"1\":{\"599\":1}}],[\"我们就需要了解数据库的关系规范化\",{\"1\":{\"552\":1}}],[\"我们就能很好地理清不同数据模型之间的关系和特点\",{\"1\":{\"550\":1}}],[\"我们就能快速得到文件的所有信息\",{\"1\":{\"98\":1}}],[\"我们就不需要了\",{\"1\":{\"342\":1}}],[\"我们就又可以一气呵成了\",{\"1\":{\"297\":1}}],[\"我们就直接使用匿名内部类的方式传入一个实现\",{\"1\":{\"288\":1}}],[\"我们就来尝试定义一个自己的注解\",{\"1\":{\"206\":1}}],[\"我们就可以给我们的应用程序添加一个过滤器\",{\"1\":{\"921\":1}}],[\"我们就可以很好地控制用户的登陆验证了\",{\"1\":{\"918\":1}}],[\"我们就可以很好地存储这样带有一定联系的数据\",{\"1\":{\"550\":1}}],[\"我们就可以更好地控制用户对于资源的访问\",{\"1\":{\"914\":1}}],[\"我们就可以更加谨慎地进行一些操作了\",{\"1\":{\"623\":1}}],[\"我们就可以更加灵活地控制泛型的具体类型范围\",{\"1\":{\"15\":1}}],[\"我们就可以快速部署我们的web项目\",{\"1\":{\"864\":1}}],[\"我们就可以直接上手使用了\",{\"1\":{\"775\":1}}],[\"我们就可以直接通过set\",{\"1\":{\"193\":1}}],[\"我们就可以删除此触发器\",{\"1\":{\"598\":1}}],[\"我们就可以获取到对应的i\",{\"1\":{\"537\":1}}],[\"我们就可以通过使用外连接来进行查询\",{\"1\":{\"586\":1}}],[\"我们就可以通过\",{\"1\":{\"478\":1}}],[\"我们就可以得到\",{\"1\":{\"473\":1}}],[\"我们就可以简单地进行模块的使用了\",{\"1\":{\"311\":1}}],[\"我们就可以按照模块的方式进行管理了\",{\"1\":{\"303\":1}}],[\"我们就可以实现两台计算机之间的通信\",{\"1\":{\"535\":1}}],[\"我们就可以实现外部加载甚至是网络加载一个类\",{\"1\":{\"199\":1}}],[\"我们就可以实现对集合中的元素的进行遍历\",{\"1\":{\"31\":1}}],[\"我们就可以使用监听器来实现\",{\"1\":{\"922\":1}}],[\"我们就可以使用重定向来完成\",{\"1\":{\"899\":1}}],[\"我们就可以使用继承关系来快速配置\",{\"1\":{\"849\":1}}],[\"我们就可以使用select语句来直接查询视图上的数据了\",{\"1\":{\"596\":1}}],[\"我们就可以使用biginteger来完成\",{\"1\":{\"229\":1}}],[\"我们就可以使用inputstreamreader来帮助我们实现\",{\"1\":{\"126\":1}}],[\"我们就可以使用\",{\"1\":{\"71\":1}}],[\"我们就可以把一个\",{\"1\":{\"71\":1}}],[\"我们就可以自定义\",{\"1\":{\"14\":1}}],[\"修改国内镜像源\",{\"0\":{\"827\":1}}],[\"修改默认情况下的打印等级\",{\"0\":{\"745\":1}}],[\"修改输出格式\",{\"0\":{\"738\":1}}],[\"修改日志的默认打印级别\",{\"0\":{\"729\":1}}],[\"修改对应\",{\"0\":{\"762\":1}}],[\"修改对应接口+注解\",{\"0\":{\"712\":1}}],[\"修改对象的属性\",{\"1\":{\"4\":1}}],[\"修改\",{\"0\":{\"680\":1}}],[\"修改语法树\",{\"1\":{\"628\":1}}],[\"修改数据\",{\"0\":{\"572\":1}}],[\"修改表\",{\"0\":{\"568\":1}}],[\"修改为\",{\"1\":{\"516\":1}}],[\"修改操作被阻止了\",{\"1\":{\"305\":1}}],[\"修改类的属性\",{\"0\":{\"193\":1}}],[\"修改访问权限\",{\"1\":{\"191\":1}}],[\"修改变量\",{\"1\":{\"191\":1}}],[\"修改键值对的值\",{\"1\":{\"56\":1}}],[\"修改相关操作\",{\"1\":{\"56\":1}}],[\"修改一个对象的属性并不会影响到其他对象\",{\"1\":{\"4\":1}}],[\"访问登陆页面后\",{\"1\":{\"910\":1}}],[\"访问后默认使用的项目为root项目\",{\"1\":{\"864\":1}}],[\"访问成功说明我们的tomcat环境已经部署成功了\",{\"1\":{\"864\":1}}],[\"访问速度更快\",{\"1\":{\"827\":1}}],[\"访问第三行第二列的元素\",{\"1\":{\"240\":1}}],[\"访问元素\",{\"0\":{\"237\":1}}],[\"访问权限控制\",{\"0\":{\"121\":1}}],[\"访问类的静态变量\",{\"1\":{\"118\":1}}],[\"访问\",{\"1\":{\"4\":1}}],[\"如tomcat\",{\"1\":{\"870\":1}}],[\"如文本\",{\"1\":{\"859\":1}}],[\"如lombok\",{\"1\":{\"832\":1}}],[\"如配置文件\",{\"1\":{\"818\":1}}],[\"如supplier这种懒加载的数据\",{\"1\":{\"812\":1}}],[\"如数组\",{\"1\":{\"811\":1}}],[\"如空字符串\",{\"1\":{\"809\":1}}],[\"如梯度上升算法\",{\"1\":{\"522\":1}}],[\"如可以在target\",{\"1\":{\"393\":1}}],[\"如p\",{\"1\":{\"393\":1}}],[\"如a\",{\"1\":{\"388\":1}}],[\"如此方便的框架\",{\"1\":{\"319\":1}}],[\"如何才可以实现只有登陆之后才能访问呢\",{\"1\":{\"910\":1}}],[\"如何才能很好的去存可能出现的两种类型呢\",{\"1\":{\"280\":1}}],[\"如何在重定向之间传递数据呢\",{\"1\":{\"900\":1}}],[\"如何在其他项目中引入我们自己编写的maven项目作为依赖使用\",{\"1\":{\"840\":1}}],[\"如何在没有模型\",{\"1\":{\"449\":1}}],[\"如何设计一个优良的关系模型是最关键的内容\",{\"1\":{\"552\":1}}],[\"如何估计\",{\"0\":{\"452\":1}}],[\"如何将定义好的xml文件读取到java程序中\",{\"1\":{\"636\":1}}],[\"如何将\",{\"1\":{\"450\":1}}],[\"如何确保策略\",{\"1\":{\"442\":1}}],[\"如何通过\",{\"1\":{\"442\":1}}],[\"如何处理等式右边的\",{\"0\":{\"431\":1}}],[\"如何求解\",{\"0\":{\"430\":1}}],[\"如何得到最优策略\",{\"1\":{\"427\":1}}],[\"如何获取我们编写的注解\",{\"1\":{\"208\":1}}],[\"如cas算法\",{\"1\":{\"155\":1}}],[\"如等待io请求\",{\"1\":{\"143\":1}}],[\"如读取和写入文本文件\",{\"1\":{\"88\":1}}],[\"如下\",{\"1\":{\"84\":1}}],[\"如果还失败\",{\"1\":{\"926\":1}}],[\"如果定义了同包同名的类\",{\"1\":{\"926\":1}}],[\"如果用户没有登录就去访问首页\",{\"1\":{\"913\":1}}],[\"如果用户勾选了记住我\",{\"1\":{\"910\":1}}],[\"如果登陆失败\",{\"1\":{\"910\":1}}],[\"如果登陆成功则直接跳转到首页\",{\"1\":{\"910\":1}}],[\"如果访问我们的首页时携带了这些cookie\",{\"1\":{\"910\":1}}],[\"如果设置为\",{\"1\":{\"909\":3}}],[\"如果设置了keeplive为\",{\"1\":{\"538\":1}}],[\"如果为0\",{\"1\":{\"909\":1}}],[\"如果为负数\",{\"1\":{\"909\":1}}],[\"如果为正数\",{\"1\":{\"909\":1}}],[\"如果为二进制数据\",{\"1\":{\"909\":1}}],[\"如果直接调用是默认提示没有支持该方法的\",{\"1\":{\"876\":1}}],[\"如果直接使用加的话\",{\"1\":{\"245\":1}}],[\"如果出现乱码\",{\"1\":{\"864\":1}}],[\"如果出现键相同的情况\",{\"1\":{\"57\":1}}],[\"如果环境变量配置有误\",{\"1\":{\"864\":1}}],[\"如果scope为system\",{\"1\":{\"835\":1}}],[\"如果别人要用我们的项目作为依赖\",{\"1\":{\"832\":1}}],[\"如果maven发现本地仓库中就已经存在某个依赖\",{\"1\":{\"826\":1}}],[\"如果mybatis缓存中存在数据\",{\"1\":{\"699\":1}}],[\"如果依然对测试用例执行前后有其他准备工作需求\",{\"1\":{\"803\":1}}],[\"如果判断流程比较复杂\",{\"1\":{\"789\":1}}],[\"如果判断失败会抛出错误\",{\"1\":{\"268\":1}}],[\"如果测试的结果并不是我们所期望的结果\",{\"1\":{\"780\":1}}],[\"如果现在我们想单独测试某一个功能的对应方法\",{\"1\":{\"773\":1}}],[\"如果发现有默认配置优先使用配置里面的\",{\"1\":{\"756\":1}}],[\"如果发现其父类\",{\"1\":{\"204\":1}}],[\"如果将打印等级配置为off\",{\"1\":{\"729\":1}}],[\"如果遇到了多个参数的情况\",{\"1\":{\"719\":1}}],[\"如果对这种复杂查询有着一定需求的话\",{\"1\":{\"718\":1}}],[\"如果对于\",{\"1\":{\"470\":1}}],[\"如果查询的id大于3\",{\"1\":{\"690\":1}}],[\"如果你c盘空间不足\",{\"1\":{\"826\":1}}],[\"如果你认为这还不够灵活\",{\"1\":{\"797\":1}}],[\"如果你还是觉得这种方式配置起来不如之前方便\",{\"1\":{\"716\":1}}],[\"如果你使用过\",{\"1\":{\"689\":1}}],[\"如果你实在需要使用对应的属性名称\",{\"1\":{\"660\":1}}],[\"如果你不需要转换为实体类\",{\"1\":{\"650\":1}}],[\"如果你觉得像这样每次都要写一个完整的类名太累了\",{\"1\":{\"649\":1}}],[\"如果你学习过python\",{\"1\":{\"341\":1}}],[\"如果你学习过sql的话\",{\"1\":{\"71\":1}}],[\"如果之前的配置文件编写错误\",{\"1\":{\"641\":1}}],[\"如果嫌一个一个改太麻烦\",{\"1\":{\"635\":1}}],[\"如果注解处理器产生了新的源文件\",{\"1\":{\"628\":1}}],[\"如果前面任何操作出现异常\",{\"1\":{\"623\":1}}],[\"如果单纯地使用statement来执行sql命令\",{\"1\":{\"622\":1}}],[\"如果允许这样的数据插入\",{\"1\":{\"621\":1}}],[\"如果成功就返回对应的\",{\"1\":{\"606\":1}}],[\"如果加载会提示\",{\"1\":{\"605\":1}}],[\"如果更新视图中的数据\",{\"1\":{\"596\":1}}],[\"如果忘记添加where字句来限定条件\",{\"1\":{\"572\":1}}],[\"如果修改管理员id\",{\"1\":{\"556\":1}}],[\"如果修改了a\",{\"1\":{\"256\":1}}],[\"如果连接的双方发生意外而通知不到对方\",{\"1\":{\"538\":1}}],[\"如果接收端读取的是\",{\"1\":{\"537\":1}}],[\"如果服务端是\",{\"1\":{\"537\":1}}],[\"如果ϵ=1\",{\"1\":{\"461\":1}}],[\"如果经过了\",{\"1\":{\"458\":1}}],[\"如果从其他状态出发\",{\"1\":{\"458\":1}}],[\"如果该容器找到了对应的需要的实例就会采用该服务然后返回\",{\"1\":{\"875\":1}}],[\"如果该\",{\"1\":{\"455\":1}}],[\"如果γ接近0\",{\"1\":{\"393\":1}}],[\"如果agent在当前时刻t所执行的动作能够提高总mos\",{\"1\":{\"387\":1}}],[\"如果全部不匹配\",{\"1\":{\"363\":1}}],[\"如果全部匹配\",{\"1\":{\"363\":1}}],[\"如果传递的参数是\",{\"1\":{\"355\":1}}],[\"如果传入null会报错\",{\"1\":{\"320\":1}}],[\"如果传入了错误的参数导致程序无法正常运行\",{\"1\":{\"266\":1}}],[\"如果传入的对象为null\",{\"1\":{\"216\":1}}],[\"如果值为unicode字符\",{\"1\":{\"909\":1}}],[\"如果值存在\",{\"1\":{\"355\":1}}],[\"如果值存在则ispresent\",{\"1\":{\"355\":1}}],[\"如果值相同\",{\"1\":{\"227\":1}}],[\"如果添加了final关键字\",{\"1\":{\"346\":1}}],[\"如果当前被包装的类不是null\",{\"1\":{\"323\":1}}],[\"如果当前链表的长度已经很长了\",{\"1\":{\"59\":1}}],[\"如果模块module\",{\"1\":{\"307\":1,\"308\":1}}],[\"如果模块没有明确授权给其他模块使用反射的权限\",{\"1\":{\"305\":1}}],[\"如果未在\",{\"1\":{\"304\":1}}],[\"如果已经有实现好的方法\",{\"1\":{\"291\":1}}],[\"如果已经是主方法了\",{\"1\":{\"267\":1}}],[\"如果各位不好理解\",{\"1\":{\"289\":1}}],[\"如果使用之前的selectone会导致异常\",{\"1\":{\"653\":1}}],[\"如果使用非静态方法\",{\"1\":{\"294\":1}}],[\"如果使用通配符\",{\"1\":{\"281\":1}}],[\"如果使用该方法\",{\"1\":{\"204\":1}}],[\"如果要使用它\",{\"1\":{\"366\":1}}],[\"如果要存放基本数据类型的值\",{\"1\":{\"281\":1}}],[\"如果要让某个变量支持引用确定了任意类型的泛型\",{\"1\":{\"281\":1}}],[\"如果要往里面写入内容\",{\"1\":{\"126\":1}}],[\"如果类型不符合\",{\"1\":{\"281\":1}}],[\"如果大于10就抛出错误\",{\"1\":{\"268\":1}}],[\"如果\",{\"1\":{\"268\":1,\"470\":1}}],[\"如果父类中的方法表明了会抛出某个异常\",{\"1\":{\"266\":1}}],[\"如果父类的方法是\",{\"1\":{\"216\":1}}],[\"如果参数只有一个\",{\"1\":{\"257\":1}}],[\"如果不作配置\",{\"1\":{\"855\":1}}],[\"如果不开启会直接覆盖重写\",{\"1\":{\"737\":1}}],[\"如果不满足\",{\"1\":{\"690\":1}}],[\"如果不自动提交\",{\"1\":{\"647\":1}}],[\"如果不需要\",{\"1\":{\"598\":1}}],[\"如果不加limit\",{\"1\":{\"321\":1}}],[\"如果不加以限制\",{\"1\":{\"71\":1}}],[\"如果不经比较就很容易出现类型转换异常\",{\"1\":{\"280\":1}}],[\"如果不同的分支条件会出现不同的异常\",{\"1\":{\"266\":1}}],[\"如果不进行处理\",{\"1\":{\"264\":1}}],[\"如果不是则匹配失败\",{\"1\":{\"780\":1}}],[\"如果不是\",{\"1\":{\"256\":1}}],[\"如果想用外部变量\",{\"1\":{\"256\":1}}],[\"如果想通过对象的形式去使用他们\",{\"1\":{\"226\":1}}],[\"如果程序中大量进行字符串的拼接似乎不太好\",{\"1\":{\"245\":1}}],[\"如果内容相同\",{\"1\":{\"244\":1}}],[\"如果同时存在其他参数\",{\"1\":{\"241\":1}}],[\"如果在定义依赖关系的时候\",{\"1\":{\"833\":1}}],[\"如果在最后添加了with\",{\"1\":{\"591\":1}}],[\"如果在插入数据时没有为该列提供值\",{\"1\":{\"564\":1}}],[\"如果在范围内\",{\"1\":{\"227\":1}}],[\"如果在向下找的过程中发现已经存在相同键的键值对了\",{\"1\":{\"59\":1}}],[\"如果方法体中只有一个返回语句\",{\"1\":{\"257\":1}}],[\"如果方法在接口中存在默认实现\",{\"1\":{\"219\":1}}],[\"如果方法内没有变量出现重名的情况\",{\"1\":{\"7\":1}}],[\"如果抽象方法在抽象类定义的是\",{\"1\":{\"218\":1}}],[\"如果子类是一个普通类\",{\"1\":{\"282\":1}}],[\"如果子类都访问不了\",{\"1\":{\"218\":1}}],[\"如果子线程修改了也是可以\",{\"1\":{\"163\":1}}],[\"如果希望调用父类原本的方法实现\",{\"1\":{\"216\":1}}],[\"如果数组里面只有一个内容\",{\"1\":{\"207\":1}}],[\"如果实在是需要使用别人定义为private的方法\",{\"1\":{\"192\":1}}],[\"如果这种情况\",{\"1\":{\"186\":1}}],[\"如果这个位置上什么都没有\",{\"1\":{\"59\":1}}],[\"如果一个会话结束\",{\"1\":{\"700\":1}}],[\"如果一个方法的参数需要的是一个接口的实现\",{\"1\":{\"257\":1}}],[\"如果一个接口中有且只有一个待实现的抽象方法\",{\"1\":{\"257\":1}}],[\"如果一个类的父类是泛型\",{\"1\":{\"186\":1}}],[\"如果一个包中有多个类\",{\"1\":{\"120\":1}}],[\"如果两个应用程序使用了同一个版本的同一个依赖\",{\"1\":{\"926\":1}}],[\"如果两个表中都带有此属性\",{\"1\":{\"584\":1}}],[\"如果两个线程同时执行\",{\"1\":{\"173\":1}}],[\"如果两个对象通过\",{\"1\":{\"84\":1}}],[\"如果两个对象使用equals方法相等\",{\"1\":{\"25\":1}}],[\"如果有一个参数和返回值的话\",{\"1\":{\"257\":1}}],[\"如果有初始值\",{\"1\":{\"217\":1}}],[\"如果有任务依次执行\",{\"1\":{\"167\":1}}],[\"如果有就可以继续获取到下一个元素\",{\"1\":{\"34\":1}}],[\"如果没有找到匹配当前访问路径的servlet\",{\"1\":{\"879\":1}}],[\"如果没有commit\",{\"1\":{\"701\":1}}],[\"如果没有创建module\",{\"1\":{\"306\":1}}],[\"如果没有其他线程唤醒自己\",{\"1\":{\"161\":1}}],[\"如果没有出现歧义\",{\"1\":{\"120\":1}}],[\"如果resume\",{\"1\":{\"156\":1}}],[\"如果仅仅是读取还好\",{\"1\":{\"154\":1}}],[\"如果存在多台服务器或者是多个程序都在使用mybatis操作同一个数据库\",{\"1\":{\"705\":1}}],[\"如果存在一个\",{\"1\":{\"458\":1}}],[\"如果存在\",{\"1\":{\"144\":1}}],[\"如果我需要的依赖没有上传的远程仓库\",{\"1\":{\"835\":1}}],[\"如果我和我的朋友同时在银行取我账户里面的钱\",{\"1\":{\"154\":1}}],[\"如果我希望两个任务同时进行\",{\"1\":{\"138\":1}}],[\"如果我们希望\",{\"1\":{\"922\":1}}],[\"如果我们希望读取某个文件的内容\",{\"1\":{\"98\":1}}],[\"如果我们成功登陆\",{\"1\":{\"899\":1}}],[\"如果我们需要打包一个可执行文件\",{\"1\":{\"854\":1}}],[\"如果我们现在需要全面使用日志系统\",{\"1\":{\"766\":1}}],[\"如果我们在不屏蔽父级handler的情况下为子级配置一个handler\",{\"1\":{\"746\":1}}],[\"如果我们在提交事务之前\",{\"1\":{\"682\":1}}],[\"如果我们在方法中抛出了一个非运行时异常\",{\"1\":{\"266\":1}}],[\"如果我们的旧项目中引入了一些其他的依赖\",{\"1\":{\"841\":1}}],[\"如果我们的类中存在其他的构造方法覆盖掉默认的无参构造\",{\"1\":{\"658\":1}}],[\"如果我们的服务器要支持响应http请求\",{\"1\":{\"544\":1}}],[\"如果我们创建错误了\",{\"1\":{\"566\":1}}],[\"如果我们强制让\",{\"1\":{\"498\":1}}],[\"如果我们不希望服务端等待太长的时间\",{\"1\":{\"538\":1}}],[\"如果我们不希望某些属性参与到序列化中进行保存\",{\"1\":{\"133\":1}}],[\"如果我们不创建module\",{\"1\":{\"311\":1}}],[\"如果我们要指定在某个jdk版本执行测试案例\",{\"1\":{\"794\":1}}],[\"如果我们要捕获的异常\",{\"1\":{\"267\":1}}],[\"如果我们要使用成员内部类\",{\"1\":{\"251\":1}}],[\"如果我们要使用一个集合类\",{\"1\":{\"25\":1}}],[\"如果我们确实不想在当前这个方法中进行处理\",{\"1\":{\"267\":1}}],[\"如果我们想从事务模式切换为原有的自动提交模式\",{\"1\":{\"623\":1}}],[\"如果我们想修改表结构\",{\"1\":{\"568\":1}}],[\"如果我们想要快速创建一个map只能\",{\"1\":{\"318\":1}}],[\"如果我们想要表示一个范围内的字符\",{\"1\":{\"246\":1}}],[\"如果我们想直接作为接口抽象方法的实现\",{\"1\":{\"257\":1}}],[\"如果我们我们将其权限改为private\",{\"1\":{\"251\":1}}],[\"如果我们仅仅是想要判断两个字符串的内容是否相同\",{\"1\":{\"244\":1}}],[\"如果我们已经明确了继承的泛型的类型\",{\"1\":{\"186\":1}}],[\"如果我们并不是希望收到中断信号就是结束程序\",{\"1\":{\"144\":1}}],[\"如果我们给类型变量设定了上界\",{\"1\":{\"16\":1}}],[\"如果某个方法明确指出会抛出哪些异常\",{\"1\":{\"267\":1}}],[\"如果某个类中存在静态方法或是静态变量\",{\"1\":{\"121\":1}}],[\"如果某个元素在当前集合中不存在\",{\"1\":{\"23\":1}}],[\"如果缓冲区中存在此数据\",{\"1\":{\"103\":1}}],[\"如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型\",{\"1\":{\"80\":1}}],[\"如果集合中本身没有元素\",{\"1\":{\"78\":1}}],[\"如果旧的数组不为空\",{\"1\":{\"60\":1}}],[\"如果旧的容量已经大于最大限制了\",{\"1\":{\"60\":1}}],[\"如果旧容量大于0\",{\"1\":{\"60\":1}}],[\"如果超过阈值\",{\"1\":{\"59\":1}}],[\"如果e不为空\",{\"1\":{\"59\":1}}],[\"如果第一个结点是treenode类型的\",{\"1\":{\"59\":1}}],[\"如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同\",{\"1\":{\"59\":1}}],[\"如果底层哈希表没初始化\",{\"1\":{\"59\":1}}],[\"如果需要更加灵活地控制日志级别\",{\"1\":{\"728\":1}}],[\"如果需要让mybatis完全使用构造方法进行对象构建与赋值工作\",{\"1\":{\"658\":1}}],[\"如果需要使用多个的话\",{\"1\":{\"281\":1}}],[\"如果需要使用更大的数组\",{\"1\":{\"236\":1}}],[\"如果需要指定为外部的对象\",{\"1\":{\"251\":2}}],[\"如果需要完整学习正则表达式\",{\"1\":{\"246\":1}}],[\"如果需要维护顺序\",{\"1\":{\"57\":1}}],[\"如果需要再次进行遍历操作\",{\"1\":{\"34\":1}}],[\"如果插入的数据与列一一对应\",{\"1\":{\"571\":1}}],[\"如果插入的长度小于定义长度时\",{\"1\":{\"563\":1}}],[\"如果插入时该列有明确值\",{\"1\":{\"564\":1}}],[\"如果插入重复元素\",{\"1\":{\"47\":1}}],[\"如果插入失败\",{\"1\":{\"43\":1}}],[\"如果o2比o1大\",{\"1\":{\"14\":1}}],[\"如果是单数则匹配成功\",{\"1\":{\"780\":1}}],[\"如果是自己编写的类型\",{\"1\":{\"648\":1}}],[\"如果是jdk内置的包装类型或是其他类型\",{\"1\":{\"648\":1}}],[\"如果是集合的话\",{\"1\":{\"359\":1}}],[\"如果是数组的话\",{\"1\":{\"359\":1}}],[\"如果是null的话会引起空指针异常\",{\"1\":{\"323\":1}}],[\"如果是null的话\",{\"1\":{\"297\":1}}],[\"如果是普通成员方法\",{\"1\":{\"258\":1}}],[\"如果是直接使用双引号创建的字符串\",{\"1\":{\"244\":1}}],[\"如果是基本数据类型\",{\"1\":{\"235\":1}}],[\"如果是基本类型的数组\",{\"1\":{\"281\":1}}],[\"如果是基本类型\",{\"1\":{\"4\":1,\"648\":1}}],[\"如果是\",{\"1\":{\"161\":1,\"342\":1,\"371\":1}}],[\"如果是静态方法\",{\"1\":{\"155\":1}}],[\"如果是类\",{\"1\":{\"155\":1}}],[\"如果是文件夹\",{\"1\":{\"98\":1}}],[\"如果是其他类型的文件不适用\",{\"1\":{\"96\":1}}],[\"如果是多个单词\",{\"1\":{\"5\":1}}],[\"如果是引用类型\",{\"1\":{\"4\":1,\"235\":1}}],[\"如果是boolean的话\",{\"1\":{\"4\":1}}],[\"如\",{\"1\":{\"4\":1,\"88\":2,\"453\":1,\"456\":1}}],[\"即每当一个类加载器接收到加载请求时\",{\"1\":{\"926\":1}}],[\"即经过了一个rtt时间后\",{\"1\":{\"859\":1}}],[\"即继承的子logger不能直接修改父logger的handler\",{\"1\":{\"745\":1}}],[\"即我们在java中所传给他的值\",{\"1\":{\"693\":1}}],[\"即我通过一个策略与环境进行交互生成一系列经验\",{\"1\":{\"497\":1}}],[\"即我通过这个策略与环境进行交互生成一系列经验\",{\"1\":{\"496\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"599\":1}}],[\"即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值\",{\"1\":{\"564\":1}}],[\"即存在关键字段决定关键字段的情况\",{\"1\":{\"556\":1}}],[\"即此时策略\",{\"1\":{\"522\":1}}],[\"即此时的discounted\",{\"1\":{\"393\":1}}],[\"即基于一个策略\",{\"1\":{\"509\":1}}],[\"即各个状态的可能性为∣s∣1​\",{\"1\":{\"508\":1}}],[\"即函数\",{\"1\":{\"471\":1}}],[\"即不需要使用\",{\"1\":{\"605\":1}}],[\"即不需要完全精确地求出\",{\"1\":{\"456\":1}}],[\"即不具备terminal\",{\"1\":{\"393\":1}}],[\"即p\",{\"1\":{\"449\":1}}],[\"即j→∞\",{\"1\":{\"440\":1}}],[\"即求解右边的式子\",{\"1\":{\"437\":1}}],[\"即f\",{\"1\":{\"432\":1}}],[\"即a∗=argmaxa​q\",{\"1\":{\"431\":1}}],[\"即vπ​\",{\"1\":{\"423\":1}}],[\"即一个trajectory下的discounted\",{\"1\":{\"413\":1}}],[\"即无记忆的特性\",{\"1\":{\"394\":1}}],[\"即无人机作为空中基站\",{\"1\":{\"382\":1}}],[\"即表示具有终止状态terminal\",{\"1\":{\"393\":1}}],[\"即在策略\",{\"1\":{\"526\":1}}],[\"即在状态s1​下采用动作a1​获得的奖励r=1的概率\",{\"1\":{\"393\":1}}],[\"即在运行状态中\",{\"1\":{\"179\":1}}],[\"即状态s1​采用动作a1​转到状态s2​的概率\",{\"1\":{\"393\":1}}],[\"即ξ=\",{\"1\":{\"388\":1}}],[\"即xuav​\",{\"1\":{\"387\":1}}],[\"即γ≥γkn​​\",{\"1\":{\"383\":1}}],[\"即需要考虑地面不同用户的具体需求\",{\"1\":{\"378\":1}}],[\"即用参数1调用方法\",{\"1\":{\"295\":1}}],[\"即之后不能修改\",{\"1\":{\"256\":1}}],[\"即使我们什么都不编写\",{\"1\":{\"871\":1}}],[\"即使用指定的枚举常量进行测试\",{\"1\":{\"810\":1}}],[\"即使用初始化块\",{\"1\":{\"255\":1}}],[\"即使会话2已经修改了数据\",{\"1\":{\"700\":1}}],[\"即使这里不指定具体类型\",{\"1\":{\"678\":1}}],[\"即使这样\",{\"1\":{\"374\":1}}],[\"即使先估计了\",{\"1\":{\"453\":1}}],[\"即使模块不同\",{\"1\":{\"304\":1}}],[\"即使是基本类型的数组\",{\"1\":{\"235\":1}}],[\"即使是最大的long类型\",{\"1\":{\"229\":1}}],[\"即使是两个不同的对象\",{\"1\":{\"216\":1}}],[\"即使强制类型转换\",{\"1\":{\"216\":1}}],[\"即使类名相同\",{\"1\":{\"120\":1}}],[\"即使值不同\",{\"1\":{\"57\":1}}],[\"即通过\",{\"1\":{\"108\":1,\"192\":1}}],[\"即对于损失函数中的\",{\"1\":{\"507\":1}}],[\"即对于数据\",{\"1\":{\"454\":1}}],[\"即对于每个状态\",{\"1\":{\"453\":1}}],[\"即对于给定策略\",{\"1\":{\"421\":1}}],[\"即对于\",{\"1\":{\"35\":1}}],[\"即可直接通过该接口执行我们的sql语句\",{\"1\":{\"710\":1}}],[\"即可在配置中直接解析其属性到insert语句中\",{\"1\":{\"678\":1}}],[\"即可以通过梯度下降\",{\"1\":{\"516\":1}}],[\"即可以进行套娃\",{\"1\":{\"109\":1}}],[\"即可创建对应的对象实例\",{\"1\":{\"191\":1}}],[\"即可\",{\"1\":{\"5\":1,\"156\":1,\"304\":1,\"431\":1,\"451\":1}}],[\"即空指针异常\",{\"1\":{\"4\":1}}],[\"即\",{\"1\":{\"4\":1,\"218\":1,\"219\":1,\"238\":1,\"289\":1,\"295\":1,\"304\":1,\"400\":1,\"437\":2,\"440\":2,\"442\":1,\"451\":1,\"452\":2,\"468\":1,\"473\":1,\"511\":1,\"701\":1,\"920\":1}}],[\"对父项目执行的任何操作除了作用于本身\",{\"1\":{\"855\":1}}],[\"对数据的修改就是永久的\",{\"1\":{\"599\":1}}],[\"对视图的修改就是对基本表的修改\",{\"1\":{\"596\":1}}],[\"对流的操作分为两种\",{\"1\":{\"358\":1}}],[\"对集合数据进行操作\",{\"1\":{\"356\":1}}],[\"对集合中元素的批量处理\",{\"1\":{\"319\":1}}],[\"对反射进行了限制\",{\"1\":{\"193\":1}}],[\"对\",{\"1\":{\"67\":1}}],[\"对应用户会收到相应请求\",{\"1\":{\"913\":1}}],[\"对应用户发起的请求信息\",{\"1\":{\"874\":1}}],[\"对应实体类如下\",{\"1\":{\"670\":1}}],[\"对应实体类属性名\",{\"1\":{\"652\":1}}],[\"对应数据库字段名\",{\"1\":{\"652\":1}}],[\"对应java进行调用\",{\"1\":{\"648\":1}}],[\"对应哪个数据库的jdbc驱动\",{\"1\":{\"641\":1}}],[\"对应支持http协议的响应内容\",{\"1\":{\"544\":1}}],[\"对应目标函数的真实梯度是\",{\"1\":{\"510\":1}}],[\"对应收敛性证明\",{\"1\":{\"478\":1}}],[\"对应一个向量\",{\"1\":{\"432\":1}}],[\"对应策略表示为\",{\"1\":{\"431\":1}}],[\"对应算法\",{\"0\":{\"402\":1}}],[\"对应状态中所有可选择的动作集合\",{\"1\":{\"393\":1}}],[\"对应s就是uav的部署位置\",{\"1\":{\"387\":1}}],[\"对应关系如下表\",{\"1\":{\"227\":1}}],[\"对应的用户请求头就会包含\",{\"1\":{\"908\":1}}],[\"对应的服务器响应头就会包含\",{\"1\":{\"908\":1}}],[\"对应的前端用\",{\"1\":{\"886\":1}}],[\"对应的实体类为\",{\"1\":{\"666\":1}}],[\"对应的vk+1​\",{\"1\":{\"437\":1}}],[\"对应的动作\",{\"1\":{\"431\":1}}],[\"对应的discounted\",{\"1\":{\"413\":1}}],[\"对应的class\",{\"1\":{\"186\":1}}],[\"对应的\",{\"1\":{\"186\":1,\"416\":2,\"420\":1,\"440\":1,\"468\":1,\"490\":1,\"876\":1}}],[\"对应地\",{\"1\":{\"186\":1}}],[\"对应多个文件夹\",{\"1\":{\"120\":1}}],[\"对应缓冲流的close源码\",{\"1\":{\"107\":1}}],[\"对应\",{\"1\":{\"55\":1,\"397\":2,\"528\":1,\"913\":1}}],[\"对出队顺序进行调整\",{\"1\":{\"46\":1}}],[\"对剩下的元素进行自定义遍历操作\",{\"1\":{\"32\":1}}],[\"对当前集合按照给定的规则进行排序操作\",{\"1\":{\"24\":1}}],[\"对于项目坐标定义的packaging\",{\"1\":{\"832\":1}}],[\"对于其他类中的方法\",{\"1\":{\"811\":1}}],[\"对于某些存在随机性的测试案例\",{\"1\":{\"806\":1}}],[\"对于更加复杂的组合结果判断\",{\"1\":{\"789\":1}}],[\"对于一些不影响结果的测试\",{\"1\":{\"791\":1}}],[\"对于一对多查询\",{\"1\":{\"670\":1}}],[\"对于一个测试案例来说\",{\"1\":{\"780\":1}}],[\"对于一个\",{\"1\":{\"455\":1}}],[\"对于策略\",{\"1\":{\"487\":1}}],[\"对于观测值g​\",{\"1\":{\"478\":1}}],[\"对于这个问题\",{\"1\":{\"475\":1}}],[\"对于这种成员内部类\",{\"1\":{\"251\":1}}],[\"对于函数\",{\"1\":{\"475\":1}}],[\"对于贝尔曼最优公式而言\",{\"1\":{\"429\":1,\"430\":1}}],[\"对于所有状态s\",{\"1\":{\"420\":1}}],[\"对于不同的策略\",{\"1\":{\"414\":1}}],[\"对于每个\",{\"1\":{\"455\":1}}],[\"对于每个智能体\",{\"1\":{\"387\":1}}],[\"对于每一个状态\",{\"1\":{\"393\":1}}],[\"对于动作空间而言\",{\"1\":{\"388\":1}}],[\"对于用户kn​存在特定的信噪比目标γkn​​\",{\"1\":{\"383\":1}}],[\"对于用户kn​∈kn​\",{\"1\":{\"382\":1}}],[\"对于无人机的总发射功率也均匀地分配给每个用户\",{\"1\":{\"383\":1}}],[\"对于无人机n\",{\"1\":{\"382\":1,\"383\":1}}],[\"对于指定区域\",{\"1\":{\"382\":1}}],[\"对于实体类中的每个参数\",{\"1\":{\"368\":1}}],[\"对于目标类中的所有的属性和未初始化的final字段\",{\"1\":{\"368\":1}}],[\"对于使用者来说\",{\"1\":{\"280\":1}}],[\"对于已经实现的方法\",{\"1\":{\"257\":1}}],[\"对于普通字符来说\",{\"1\":{\"246\":1}}],[\"对于变量来说\",{\"1\":{\"245\":1}}],[\"对于基本类型的数组来说\",{\"1\":{\"238\":1}}],[\"对于需要精确计算的场景\",{\"1\":{\"229\":1}}],[\"对于非常大的整数计算\",{\"1\":{\"229\":1}}],[\"对于引用类型\",{\"1\":{\"220\":1}}],[\"对于类中基本数据类型\",{\"1\":{\"220\":1}}],[\"对于类型变量来说是不支持的\",{\"1\":{\"15\":2}}],[\"对于人类的不同子类\",{\"1\":{\"219\":1}}],[\"对于成员方法\",{\"1\":{\"217\":1}}],[\"对于成员变量\",{\"1\":{\"217\":1}}],[\"对于任意一个对象\",{\"1\":{\"179\":1}}],[\"对于任意一个类\",{\"1\":{\"179\":1}}],[\"对于\",{\"1\":{\"84\":3,\"256\":1,\"422\":1,\"444\":3,\"451\":2,\"453\":1,\"455\":1,\"462\":1,\"504\":1,\"516\":1}}],[\"对于泛型类test\",{\"1\":{\"16\":1}}],[\"对于对象而言\",{\"1\":{\"4\":1}}],[\"对其进行修改\",{\"1\":{\"9\":1}}],[\"对象里\",{\"1\":{\"912\":1}}],[\"对象判断\",{\"0\":{\"788\":1}}],[\"对象与多态\",{\"0\":{\"185\":1}}],[\"对象始终是相同的\",{\"1\":{\"182\":1}}],[\"对象序列化\",{\"0\":{\"131\":1}}],[\"对象流\",{\"0\":{\"130\":1}}],[\"对象再多\",{\"1\":{\"117\":1}}],[\"对象在创建之后\",{\"1\":{\"9\":1}}],[\"对象创建成功之后\",{\"1\":{\"4\":1}}],[\"对象实例的创建\",{\"1\":{\"4\":1}}],[\"对象\",{\"0\":{\"183\":1,\"184\":1,\"251\":1},\"1\":{\"4\":1,\"155\":1,\"182\":1,\"249\":1,\"258\":2,\"295\":1}}],[\"=等\",{\"1\":{\"580\":1}}],[\"=θt​+αe\",{\"1\":{\"530\":1}}],[\"=dtvπ​\",{\"1\":{\"524\":1}}],[\"=i=1∑n​yt​−q^​\",{\"1\":{\"516\":1}}],[\"=−2e\",{\"1\":{\"510\":1}}],[\"=−c1​ln\",{\"1\":{\"384\":1}}],[\"=∣s∣1​s∈s∑​\",{\"1\":{\"508\":1}}],[\"=qt​\",{\"1\":{\"490\":1,\"494\":1}}],[\"=vt​\",{\"1\":{\"486\":1}}],[\"=vπ0​​\",{\"1\":{\"444\":1}}],[\"=w−\",{\"1\":{\"484\":1}}],[\"=wk​−αk​▽w​f\",{\"1\":{\"478\":1}}],[\"=wk​−αk​e\",{\"1\":{\"475\":1}}],[\"=wk​−αk​\",{\"1\":{\"473\":1,\"484\":1}}],[\"=▽w​j\",{\"1\":{\"478\":1}}],[\"=g\",{\"1\":{\"471\":1,\"478\":1}}],[\"=k1​\",{\"1\":{\"468\":1}}],[\"=k0​−1dkn​​−α\",{\"1\":{\"383\":1}}],[\"=n1​∑i=1n​xi​\",{\"1\":{\"468\":1}}],[\"=1\",{\"1\":{\"453\":1,\"509\":1,\"524\":1}}],[\"=argmaxπ​∑a​π\",{\"1\":{\"453\":1}}],[\"=argmaxa​qπk​​\",{\"1\":{\"440\":1}}],[\"=argmaxa​qk​\",{\"1\":{\"437\":1}}],[\"=a∑​πk​\",{\"1\":{\"440\":1}}],[\"=a∑​π\",{\"1\":{\"417\":1,\"418\":3,\"419\":1,\"422\":1,\"487\":1}}],[\"=πargmax​a∑​πk​\",{\"1\":{\"440\":1}}],[\"=πargmax​a∑​π\",{\"1\":{\"437\":1}}],[\"=πmax​\",{\"1\":{\"435\":1,\"436\":1}}],[\"=x∗\",{\"1\":{\"432\":1}}],[\"=x\",{\"1\":{\"432\":1}}],[\"=maxa​qk​\",{\"1\":{\"437\":1}}],[\"=maxπ​\",{\"1\":{\"432\":1}}],[\"=maxπ​∑a​π\",{\"1\":{\"431\":1}}],[\"=mean\",{\"1\":{\"419\":1}}],[\"=∑a​π\",{\"1\":{\"423\":1}}],[\"=∑a​qπ​\",{\"1\":{\"422\":1}}],[\"=∑r​p\",{\"1\":{\"422\":1}}],[\"=r∑​rp\",{\"1\":{\"527\":1}}],[\"=r∑​p\",{\"1\":{\"451\":1}}],[\"=rπ​\",{\"1\":{\"420\":1}}],[\"=rt+1​+γgt+1​​\",{\"1\":{\"416\":1}}],[\"=rt+1​+γ\",{\"1\":{\"416\":1}}],[\"=s∈s∑​d\",{\"1\":{\"529\":1}}],[\"=s∈s∑​dπ​\",{\"1\":{\"509\":1}}],[\"=s\",{\"1\":{\"418\":3}}],[\"=sin−1\",{\"1\":{\"383\":1}}],[\"=es∼d\",{\"1\":{\"529\":1}}],[\"=es∼d​\",{\"1\":{\"527\":1,\"529\":1}}],[\"=es∼η\",{\"1\":{\"400\":1}}],[\"=e\",{\"1\":{\"414\":1,\"416\":2,\"422\":1,\"423\":2,\"449\":2,\"451\":1,\"452\":1,\"475\":1,\"478\":4,\"487\":3,\"489\":1,\"493\":1,\"507\":1,\"508\":1,\"509\":1,\"510\":1,\"515\":1,\"516\":3,\"525\":1,\"527\":1,\"529\":1}}],[\"=0\",{\"1\":{\"400\":1,\"470\":1,\"472\":2,\"473\":1,\"478\":2,\"484\":1}}],[\"=p\",{\"1\":{\"394\":2}}],[\"=3rtt+rkn​​\",{\"1\":{\"384\":1}}],[\"=ζ1​moskn​​delay\",{\"1\":{\"384\":1}}],[\"=γk0​σ2dkn​​α\",{\"1\":{\"383\":1}}],[\"=b2​ln\",{\"1\":{\"383\":1}}],[\"=bkn​​log2​\",{\"1\":{\"383\":1}}],[\"=b1​\",{\"1\":{\"383\":1}}],[\"=σ2pkn​​gkn​​\",{\"1\":{\"383\":1}}],[\"===\",{\"1\":{\"893\":2}}],[\"====>\",{\"1\":{\"669\":2}}],[\"====​n→∞lim​n1​e\",{\"1\":{\"528\":1}}],[\"=========================\",{\"1\":{\"258\":1}}],[\"====================================\",{\"1\":{\"257\":2}}],[\"=================\",{\"1\":{\"258\":1}}],[\"==>向右的箭头就是发送给mysql服务器的sql语句以及其参数列表\",{\"1\":{\"669\":1}}],[\"==>\",{\"1\":{\"669\":2}}],[\"==\",{\"1\":{\"25\":2,\"59\":9,\"60\":1,\"84\":6,\"142\":1,\"147\":1,\"148\":1,\"183\":1,\"186\":1,\"215\":1,\"216\":2,\"220\":1,\"227\":3,\"244\":3,\"266\":2,\"292\":1,\"544\":1,\"606\":3,\"636\":1,\"691\":2,\"747\":3,\"756\":1,\"787\":1,\"789\":2,\"791\":1,\"807\":1,\"808\":1,\"876\":1,\"913\":1,\"921\":1}}],[\"=\",{\"1\":{\"4\":6,\"5\":3,\"7\":2,\"9\":16,\"14\":9,\"15\":8,\"16\":1,\"23\":4,\"24\":3,\"25\":26,\"30\":4,\"33\":3,\"34\":3,\"35\":1,\"43\":1,\"44\":1,\"45\":2,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"58\":1,\"59\":20,\"60\":14,\"64\":1,\"65\":5,\"66\":3,\"67\":2,\"71\":12,\"76\":1,\"77\":1,\"78\":1,\"79\":3,\"80\":4,\"84\":12,\"90\":4,\"91\":6,\"92\":2,\"93\":1,\"94\":5,\"96\":3,\"97\":1,\"98\":4,\"105\":1,\"107\":5,\"108\":2,\"109\":1,\"110\":1,\"112\":3,\"113\":1,\"117\":1,\"120\":1,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":5,\"132\":2,\"133\":6,\"138\":3,\"140\":2,\"142\":4,\"144\":1,\"145\":1,\"147\":4,\"148\":4,\"154\":5,\"155\":19,\"156\":4,\"161\":4,\"162\":3,\"163\":2,\"165\":4,\"166\":1,\"167\":4,\"172\":5,\"173\":2,\"174\":3,\"182\":3,\"183\":1,\"184\":1,\"186\":14,\"191\":9,\"192\":12,\"193\":7,\"199\":9,\"207\":1,\"208\":4,\"216\":5,\"218\":4,\"219\":4,\"220\":2,\"221\":3,\"227\":10,\"228\":3,\"229\":6,\"235\":6,\"236\":1,\"237\":2,\"238\":8,\"239\":3,\"240\":1,\"241\":1,\"244\":10,\"245\":13,\"246\":2,\"251\":11,\"252\":2,\"253\":2,\"254\":1,\"255\":4,\"256\":3,\"257\":5,\"258\":6,\"267\":3,\"268\":1,\"274\":2,\"275\":1,\"280\":5,\"281\":13,\"282\":4,\"288\":1,\"289\":2,\"290\":5,\"291\":1,\"292\":2,\"294\":2,\"295\":2,\"296\":4,\"297\":1,\"305\":2,\"307\":3,\"318\":4,\"321\":1,\"323\":6,\"328\":3,\"330\":1,\"331\":3,\"333\":22,\"338\":6,\"339\":1,\"340\":3,\"341\":1,\"342\":3,\"343\":1,\"344\":2,\"347\":1,\"353\":1,\"354\":3,\"355\":7,\"358\":2,\"361\":2,\"362\":2,\"364\":6,\"365\":7,\"366\":8,\"367\":5,\"368\":4,\"371\":3,\"374\":1,\"382\":1,\"393\":1,\"431\":1,\"437\":1,\"440\":1,\"461\":1,\"473\":1,\"484\":1,\"529\":1,\"536\":5,\"537\":11,\"538\":2,\"543\":13,\"544\":7,\"586\":2,\"587\":1,\"598\":1,\"605\":3,\"606\":12,\"613\":6,\"615\":2,\"616\":12,\"621\":5,\"622\":5,\"623\":9,\"627\":6,\"636\":8,\"641\":4,\"643\":3,\"647\":3,\"648\":2,\"649\":1,\"650\":2,\"651\":3,\"652\":2,\"653\":4,\"658\":11,\"659\":5,\"660\":5,\"667\":2,\"668\":2,\"669\":2,\"670\":2,\"671\":2,\"672\":3,\"680\":2,\"681\":1,\"682\":5,\"688\":3,\"690\":1,\"691\":3,\"693\":1,\"694\":2,\"700\":5,\"701\":4,\"703\":1,\"704\":1,\"705\":1,\"714\":4,\"715\":5,\"717\":10,\"718\":9,\"719\":5,\"720\":5,\"721\":4,\"725\":1,\"727\":8,\"728\":1,\"729\":2,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"744\":3,\"747\":4,\"754\":1,\"755\":2,\"756\":8,\"763\":1,\"765\":3,\"767\":1,\"780\":2,\"786\":3,\"795\":2,\"796\":5,\"807\":1,\"808\":1,\"810\":2,\"812\":2,\"825\":1,\"834\":3,\"864\":1,\"874\":3,\"875\":1,\"876\":12,\"881\":2,\"888\":2,\"889\":10,\"891\":4,\"892\":2,\"893\":5,\"901\":1,\"902\":4,\"903\":1,\"908\":1,\"910\":14,\"913\":3,\"919\":1,\"921\":4}}],[\"nt\",{\"1\":{\"908\":1,\"913\":1}}],[\"n→∞lim​n1​e\",{\"1\":{\"528\":2}}],[\"n=0∑∞​βnrt+n​\",{\"1\":{\"387\":1}}],[\"n∈n=\",{\"1\":{\"387\":1}}],[\"n∈1\",{\"1\":{\"382\":1}}],[\"n0​为用户所在位置的加性高斯白噪声\",{\"1\":{\"383\":1}}],[\"nice\",{\"1\":{\"341\":3}}],[\"nd\",{\"1\":{\"331\":1}}],[\"nc\",{\"1\":{\"331\":1}}],[\"n换行符进行切割\",{\"1\":{\"331\":2}}],[\"n个类型变量\",{\"1\":{\"281\":1}}],[\"n个\",{\"1\":{\"206\":1}}],[\"navigate\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"nanos\",{\"1\":{\"215\":1}}],[\"native\",{\"1\":{\"143\":1,\"183\":1,\"215\":7,\"264\":1}}],[\"names\",{\"1\":{\"810\":1}}],[\"namespace=\",{\"1\":{\"643\":1,\"659\":1}}],[\"name=test\",{\"1\":{\"753\":1}}],[\"name=小明\",{\"1\":{\"669\":1}}],[\"name=\",{\"1\":{\"641\":4,\"649\":1,\"669\":1,\"711\":1,\"768\":2,\"834\":8,\"886\":2,\"888\":4,\"892\":1,\"910\":1}}],[\"name>lbwnb<\",{\"1\":{\"903\":1}}],[\"name>jsp<\",{\"1\":{\"871\":1}}],[\"name>default<\",{\"1\":{\"871\":1}}],[\"name>test<\",{\"1\":{\"871\":2}}],[\"name>\",{\"1\":{\"634\":1,\"635\":1,\"827\":1,\"871\":4,\"903\":1}}],[\"name+\",{\"1\":{\"307\":1}}],[\"named\",{\"1\":{\"183\":1,\"796\":2,\"864\":1}}],[\"name\",{\"1\":{\"4\":3,\"5\":2,\"7\":7,\"9\":14,\"15\":4,\"65\":5,\"84\":15,\"117\":1,\"121\":1,\"131\":5,\"132\":4,\"133\":5,\"140\":1,\"167\":2,\"174\":4,\"183\":1,\"186\":1,\"191\":5,\"192\":5,\"199\":2,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"221\":5,\"241\":1,\"251\":14,\"252\":4,\"253\":4,\"254\":2,\"280\":4,\"281\":4,\"307\":4,\"342\":12,\"368\":1,\"564\":2,\"613\":1,\"616\":4,\"627\":9,\"643\":1,\"652\":1,\"658\":10,\"666\":1,\"667\":2,\"668\":2,\"669\":1,\"670\":3,\"671\":2,\"672\":9,\"678\":3,\"679\":2,\"688\":1,\"694\":3,\"713\":2,\"714\":4,\"715\":2,\"717\":6,\"755\":1,\"825\":1,\"874\":3,\"902\":1,\"909\":1}}],[\"noargsconstructor来快速生成全参构造和无参构造\",{\"1\":{\"629\":1}}],[\"no\",{\"1\":{\"606\":2,\"658\":1,\"768\":1}}],[\"nobody\",{\"1\":{\"606\":1}}],[\"normal\",{\"1\":{\"597\":1}}],[\"novel\",{\"1\":{\"378\":1}}],[\"nosuchfieldexception\",{\"1\":{\"193\":1,\"305\":1}}],[\"nosuchmethodexception\",{\"1\":{\"191\":1,\"192\":1,\"193\":1,\"208\":1}}],[\"nonnull的成员字段\",{\"1\":{\"629\":1}}],[\"none\",{\"1\":{\"544\":1}}],[\"nonematch\",{\"1\":{\"363\":1}}],[\"non\",{\"1\":{\"167\":1,\"347\":4,\"876\":1,\"921\":1}}],[\"nom\",{\"1\":{\"145\":1}}],[\"note\",{\"1\":{\"864\":1}}],[\"notifyall\",{\"1\":{\"174\":1,\"215\":1}}],[\"notifyall其实和notify一样\",{\"1\":{\"161\":1}}],[\"notify\",{\"1\":{\"161\":4,\"215\":1}}],[\"not\",{\"1\":{\"139\":1,\"352\":1,\"544\":1,\"564\":3,\"565\":1,\"566\":1,\"580\":3,\"606\":2,\"660\":1,\"864\":5,\"876\":2,\"913\":1,\"929\":1}}],[\"nodelist\",{\"1\":{\"636\":4}}],[\"node<k\",{\"1\":{\"58\":3,\"59\":3,\"60\":4,\"61\":2}}],[\"node<e>\",{\"1\":{\"25\":7}}],[\"node\",{\"1\":{\"25\":1,\"60\":1,\"636\":4}}],[\"n\",{\"0\":{\"491\":1},\"1\":{\"59\":6,\"241\":1,\"246\":12,\"374\":2,\"382\":2,\"385\":1,\"387\":2,\"444\":1,\"445\":1,\"516\":1,\"537\":4,\"544\":2,\"550\":2,\"563\":2}}],[\"need\",{\"1\":{\"864\":1}}],[\"nested\",{\"1\":{\"805\":2}}],[\"net\",{\"1\":{\"538\":1,\"543\":1}}],[\"network\",{\"1\":{\"516\":5,\"518\":1}}],[\"networks\",{\"0\":{\"377\":1},\"1\":{\"378\":1,\"516\":1}}],[\"netbian\",{\"1\":{\"333\":4}}],[\"nextelement\",{\"1\":{\"874\":1}}],[\"nextline\",{\"1\":{\"374\":1,\"537\":1,\"621\":2,\"622\":2}}],[\"nextintscanner\",{\"1\":{\"374\":1}}],[\"nextint方法可以指定创建0\",{\"1\":{\"274\":1}}],[\"nextint\",{\"1\":{\"274\":1,\"374\":2,\"780\":1,\"807\":1}}],[\"nextindex\",{\"1\":{\"37\":1}}],[\"nextindex++\",{\"1\":{\"33\":1}}],[\"nextthreadnum\",{\"1\":{\"139\":1}}],[\"next\",{\"1\":{\"23\":1,\"24\":2,\"25\":4,\"30\":1,\"32\":3,\"33\":5,\"34\":1,\"36\":1,\"37\":1,\"58\":1,\"59\":2,\"61\":2,\"605\":1,\"614\":1,\"616\":2,\"621\":1,\"622\":1}}],[\"newdocumentbuilder\",{\"1\":{\"636\":1}}],[\"new表和old表\",{\"1\":{\"598\":1}}],[\"newestimatevt+1​\",{\"1\":{\"486\":1}}],[\"newbuilder\",{\"1\":{\"333\":3,\"367\":1}}],[\"newhttpclient\",{\"1\":{\"333\":4}}],[\"newhelloworld\",{\"1\":{\"304\":2}}],[\"newinputstream\",{\"1\":{\"323\":1}}],[\"newinstance\",{\"1\":{\"191\":4,\"192\":3,\"199\":2,\"616\":1,\"636\":1}}],[\"newline\",{\"1\":{\"113\":1}}],[\"newlist\",{\"1\":{\"79\":2}}],[\"newoutputstream\",{\"1\":{\"110\":1}}],[\"newtasksmaybescheduled\",{\"1\":{\"167\":2}}],[\"newtab\",{\"1\":{\"60\":2}}],[\"newthr\",{\"1\":{\"60\":4}}],[\"newcap\",{\"1\":{\"60\":5}}],[\"newcapacity\",{\"1\":{\"25\":6}}],[\"newnode\",{\"1\":{\"59\":2}}],[\"newarr\",{\"1\":{\"14\":2}}],[\"new\",{\"1\":{\"4\":3,\"5\":1,\"14\":4,\"15\":3,\"16\":1,\"23\":1,\"25\":13,\"32\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":2,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"60\":2,\"64\":1,\"65\":10,\"66\":3,\"67\":2,\"71\":7,\"76\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":6,\"90\":2,\"91\":5,\"92\":2,\"93\":1,\"94\":3,\"96\":3,\"97\":1,\"98\":4,\"105\":2,\"107\":1,\"108\":4,\"109\":3,\"110\":2,\"112\":6,\"113\":2,\"118\":1,\"120\":1,\"126\":4,\"127\":2,\"128\":3,\"129\":4,\"131\":5,\"133\":5,\"139\":1,\"140\":2,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":11,\"156\":4,\"161\":3,\"162\":3,\"163\":3,\"165\":4,\"166\":2,\"167\":4,\"172\":3,\"173\":2,\"174\":10,\"182\":1,\"184\":1,\"186\":1,\"193\":1,\"199\":3,\"216\":4,\"219\":2,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":1,\"235\":5,\"236\":1,\"237\":1,\"238\":4,\"241\":1,\"244\":4,\"245\":2,\"251\":7,\"252\":1,\"253\":1,\"255\":4,\"256\":1,\"258\":2,\"266\":6,\"267\":3,\"274\":1,\"275\":1,\"280\":1,\"281\":5,\"282\":2,\"288\":2,\"289\":3,\"292\":3,\"294\":3,\"295\":2,\"296\":2,\"307\":1,\"318\":1,\"323\":1,\"333\":5,\"344\":2,\"355\":3,\"358\":1,\"361\":1,\"362\":1,\"365\":5,\"366\":2,\"367\":2,\"368\":2,\"371\":6,\"374\":1,\"536\":3,\"537\":10,\"538\":3,\"543\":7,\"544\":3,\"598\":1,\"605\":1,\"606\":6,\"613\":1,\"616\":3,\"621\":1,\"622\":1,\"641\":1,\"643\":2,\"647\":2,\"694\":3,\"714\":1,\"719\":1,\"721\":5,\"727\":7,\"728\":1,\"729\":2,\"736\":1,\"737\":1,\"738\":2,\"746\":1,\"754\":2,\"755\":1,\"756\":1,\"763\":1,\"765\":3,\"780\":1,\"807\":2,\"808\":1,\"825\":1,\"834\":3,\"876\":2,\"889\":2,\"892\":1,\"893\":3,\"908\":1,\"910\":2,\"921\":1}}],[\"numbers\",{\"1\":{\"449\":1}}],[\"number\",{\"1\":{\"15\":1,\"16\":2,\"186\":1,\"280\":1,\"384\":1}}],[\"number>\",{\"1\":{\"15\":3,\"16\":1}}],[\"nullandemptysource\",{\"1\":{\"809\":1}}],[\"nullsource和\",{\"1\":{\"809\":1}}],[\"nullsource\",{\"1\":{\"809\":1}}],[\"nullvalues\",{\"1\":{\"804\":1}}],[\"nullpointerexception\",{\"1\":{\"267\":3,\"352\":1,\"355\":1,\"371\":1,\"606\":1,\"728\":1}}],[\"null\",{\"1\":{\"4\":1,\"25\":1,\"57\":1,\"59\":10,\"60\":3,\"64\":1,\"84\":2,\"90\":2,\"107\":4,\"127\":1,\"139\":1,\"216\":1,\"229\":1,\"267\":1,\"282\":2,\"297\":1,\"320\":2,\"323\":4,\"338\":1,\"352\":1,\"355\":3,\"371\":2,\"564\":6,\"565\":1,\"606\":13,\"616\":2,\"756\":3,\"804\":1,\"871\":1,\"889\":1,\"910\":6,\"913\":1,\"921\":1}}],[\"s3cret\",{\"1\":{\"864\":2}}],[\"small\",{\"1\":{\"810\":2}}],[\"smallint用于存储小的整数\",{\"1\":{\"563\":1}}],[\"s2\",{\"1\":{\"700\":2}}],[\"s2​\",{\"1\":{\"455\":4}}],[\"s2​a3​​s5​a1​​\",{\"1\":{\"455\":1}}],[\"s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"455\":1}}],[\"s2​∣s1​\",{\"1\":{\"393\":1}}],[\"s1\",{\"1\":{\"700\":2}}],[\"s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"455\":1}}],[\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"455\":2}}],[\"s1​\",{\"1\":{\"420\":2,\"455\":4,\"486\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​\",{\"1\":{\"393\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​\",{\"1\":{\"393\":1}}],[\"s1​→a1​s2​\",{\"1\":{\"393\":1}}],[\"sneakythrows\",{\"1\":{\"834\":1}}],[\"sneakythrows来自动生成try\",{\"1\":{\"629\":1}}],[\"snapshot<\",{\"1\":{\"819\":1,\"840\":2,\"843\":1,\"849\":1}}],[\"sno\",{\"1\":{\"596\":1,\"598\":2}}],[\"sn​\",{\"1\":{\"420\":2}}],[\"s∣s\",{\"1\":{\"529\":1}}],[\"s∣a\",{\"1\":{\"431\":1,\"432\":1}}],[\"s∑​dπ​\",{\"1\":{\"528\":1}}],[\"sgdw\",{\"0\":{\"480\":1}}],[\"sgd的目标是\",{\"1\":{\"478\":1}}],[\"sgd\",{\"0\":{\"476\":1,\"478\":1,\"479\":1},\"1\":{\"475\":1,\"478\":3,\"479\":2,\"510\":1,\"529\":1}}],[\"s5​\",{\"1\":{\"455\":1}}],[\"s5​a1​​\",{\"1\":{\"455\":1}}],[\"s​=maxπ​∑a​π\",{\"1\":{\"432\":1}}],[\"sj​∣si​\",{\"1\":{\"420\":1}}],[\"s0​\",{\"1\":{\"394\":2,\"486\":1}}],[\"s∈s​\",{\"1\":{\"509\":1}}],[\"s∈s\",{\"1\":{\"394\":1,\"437\":1,\"440\":2,\"487\":2}}],[\"s=\",{\"1\":{\"393\":1}}],[\"specifiedformatter\",{\"1\":{\"756\":3}}],[\"spi\",{\"1\":{\"605\":1}}],[\"spatial\",{\"1\":{\"597\":1}}],[\"space\",{\"1\":{\"387\":2,\"393\":3}}],[\"splitable\",{\"1\":{\"173\":1}}],[\"split\",{\"1\":{\"71\":1,\"244\":2}}],[\"spliterator也用于遍历数据源中的元素\",{\"1\":{\"173\":1}}],[\"spliteratorunknownsize\",{\"1\":{\"36\":1}}],[\"spliterator<t>\",{\"1\":{\"36\":1}}],[\"spliterator<e>\",{\"1\":{\"23\":1,\"47\":1}}],[\"spliterators\",{\"1\":{\"23\":1,\"36\":1,\"47\":1}}],[\"spliterator\",{\"1\":{\"23\":4,\"36\":1,\"47\":3,\"173\":1}}],[\"slf4j<\",{\"1\":{\"842\":2}}],[\"slf4j\",{\"1\":{\"768\":1}}],[\"slove\",{\"0\":{\"421\":1}}],[\"slow\",{\"1\":{\"384\":1}}],[\"sleep\",{\"1\":{\"142\":1,\"143\":1,\"144\":1,\"154\":1,\"155\":4,\"156\":2,\"161\":1,\"162\":2,\"165\":2,\"172\":4,\"174\":2,\"221\":4,\"705\":1}}],[\"switch表达式在java\",{\"1\":{\"340\":1}}],[\"switch\",{\"1\":{\"338\":1,\"339\":1,\"340\":3}}],[\"sqrt\",{\"1\":{\"274\":1}}],[\"sql类中提供了常见的select\",{\"1\":{\"719\":1}}],[\"sqlsession接口中为我们提供了事务操作相关的方法\",{\"1\":{\"682\":1}}],[\"sqlsession对象\",{\"1\":{\"642\":1,\"647\":1}}],[\"sqlsession\",{\"1\":{\"641\":1,\"643\":3,\"647\":4,\"659\":4,\"682\":2,\"700\":2,\"701\":3,\"834\":3,\"889\":3,\"910\":3}}],[\"sqlsessionfactory对象是什么东西\",{\"1\":{\"642\":1}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"641\":1,\"643\":1,\"647\":1,\"721\":1,\"834\":1,\"889\":1}}],[\"sqlsessionfactory\",{\"1\":{\"641\":3,\"642\":1,\"643\":3,\"647\":4,\"682\":1,\"721\":1,\"834\":1,\"889\":1}}],[\"sqlexception\",{\"1\":{\"605\":1,\"606\":7,\"607\":2,\"613\":1,\"615\":1,\"616\":2,\"621\":1,\"622\":1,\"623\":4}}],[\"sql包\",{\"1\":{\"604\":1}}],[\"sql语句映射配置我们就编写好了\",{\"1\":{\"649\":1}}],[\"sql语句\",{\"1\":{\"623\":3}}],[\"sql语句中的等于判断是=\",{\"1\":{\"572\":1}}],[\"sql语句不区分大小写\",{\"1\":{\"561\":1}}],[\"sql数据类型\",{\"0\":{\"563\":1}}],[\"sql也支持注释\",{\"1\":{\"561\":1}}],[\"sql\",{\"0\":{\"561\":1},\"1\":{\"71\":1,\"356\":1,\"549\":1,\"606\":1,\"607\":1,\"613\":1,\"633\":1,\"666\":1,\"689\":3,\"719\":1}}],[\"ssl等\",{\"1\":{\"909\":1}}],[\"sss\",{\"1\":{\"765\":1}}],[\"ss\",{\"1\":{\"255\":2,\"765\":1,\"893\":1}}],[\"sh拖入窗口按回车运行\",{\"1\":{\"864\":1}}],[\"should\",{\"1\":{\"606\":1,\"864\":1}}],[\"show\",{\"1\":{\"590\":1,\"597\":1,\"598\":1,\"599\":1}}],[\"short\",{\"1\":{\"227\":3,\"808\":1}}],[\"shutdowninput\",{\"1\":{\"538\":1}}],[\"shutdownoutput\",{\"1\":{\"538\":1}}],[\"shared\",{\"1\":{\"167\":1,\"926\":1}}],[\"same\",{\"1\":{\"908\":1,\"913\":1}}],[\"samples\",{\"1\":{\"475\":1,\"516\":1}}],[\"sample\",{\"1\":{\"452\":1,\"473\":1,\"475\":1}}],[\"sampling\",{\"0\":{\"404\":1}}],[\"say\",{\"1\":{\"616\":3}}],[\"savepoint\",{\"1\":{\"599\":1,\"623\":3}}],[\"savage\",{\"1\":{\"368\":1}}],[\"safari\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"safevarargs\",{\"1\":{\"204\":1}}],[\"sa​\",{\"1\":{\"490\":2}}],[\"sarsa\",{\"0\":{\"490\":1,\"491\":1,\"492\":1,\"513\":1},\"1\":{\"489\":3,\"490\":1,\"497\":1}}],[\"sa\",{\"1\":{\"466\":2}}],[\"satisfying\",{\"1\":{\"472\":1}}],[\"satisfaction\",{\"1\":{\"378\":1}}],[\"satic\",{\"1\":{\"216\":1}}],[\"san\",{\"1\":{\"368\":1}}],[\"sonatype\",{\"1\":{\"825\":1}}],[\"so\",{\"1\":{\"606\":2}}],[\"sockethandler\",{\"1\":{\"735\":2}}],[\"socket2\",{\"0\":{\"541\":1,\"542\":1}}],[\"sockettimeoutexception\",{\"1\":{\"538\":1}}],[\"socket也被翻译为套接字\",{\"1\":{\"535\":1}}],[\"socket\",{\"0\":{\"535\":1,\"536\":1,\"543\":1,\"938\":1},\"1\":{\"536\":8,\"537\":13,\"538\":10,\"543\":9,\"544\":7}}],[\"socket1\",{\"0\":{\"534\":1}}],[\"soloving\",{\"1\":{\"466\":1}}],[\"solution\",{\"1\":{\"421\":2}}],[\"soft\",{\"0\":{\"460\":1},\"1\":{\"459\":1,\"460\":2,\"461\":1,\"701\":1}}],[\"some\",{\"1\":{\"393\":1,\"490\":1}}],[\"someone\",{\"1\":{\"167\":1}}],[\"sourceencoding>\",{\"1\":{\"819\":1}}],[\"sourceencoding>utf\",{\"1\":{\"819\":1}}],[\"source>\",{\"1\":{\"819\":1,\"849\":1}}],[\"source>17<\",{\"1\":{\"819\":1,\"849\":1}}],[\"sources\",{\"1\":{\"812\":1}}],[\"source\",{\"1\":{\"206\":1}}],[\"sorted\",{\"1\":{\"71\":2,\"112\":1}}],[\"sort\",{\"1\":{\"14\":3,\"24\":2,\"275\":1,\"292\":3,\"294\":2,\"295\":1}}],[\"synchronize\",{\"1\":{\"606\":1}}],[\"synchronized关键字也可以作用于方法上\",{\"1\":{\"155\":1}}],[\"synchronized需要在括号中填入一个内容\",{\"1\":{\"155\":1}}],[\"synchronized\",{\"1\":{\"155\":8,\"156\":4,\"161\":2,\"167\":2,\"174\":2,\"606\":2}}],[\"syntax\",{\"1\":{\"246\":1}}],[\"systempath>\",{\"1\":{\"835\":1}}],[\"system类中有一个getproperties方法用于存储所有系统相关的属性值\",{\"1\":{\"755\":1}}],[\"system\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"128\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"237\":2,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":2,\"275\":1,\"281\":1,\"288\":1,\"289\":1,\"292\":2,\"294\":2,\"295\":1,\"297\":6,\"304\":1,\"305\":1,\"307\":1,\"317\":3,\"318\":2,\"319\":1,\"320\":2,\"321\":2,\"322\":2,\"323\":6,\"328\":1,\"331\":6,\"333\":3,\"340\":1,\"343\":1,\"344\":1,\"347\":1,\"353\":1,\"354\":2,\"355\":3,\"358\":1,\"361\":1,\"362\":1,\"364\":4,\"365\":5,\"374\":3,\"536\":6,\"537\":10,\"538\":1,\"543\":1,\"544\":6,\"605\":1,\"606\":1,\"613\":1,\"616\":1,\"621\":2,\"622\":3,\"636\":1,\"643\":1,\"647\":1,\"649\":1,\"650\":1,\"651\":1,\"653\":3,\"658\":1,\"659\":2,\"660\":1,\"682\":2,\"700\":6,\"701\":2,\"705\":1,\"714\":1,\"735\":1,\"744\":2,\"747\":3,\"754\":1,\"755\":5,\"761\":3,\"767\":2,\"773\":4,\"790\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":2,\"797\":1,\"802\":3,\"803\":3,\"804\":3,\"805\":5,\"810\":2,\"811\":1,\"812\":2,\"825\":1,\"834\":2,\"835\":1,\"840\":1,\"852\":1,\"874\":4,\"886\":1,\"889\":1,\"900\":1,\"901\":1,\"902\":1,\"903\":1,\"908\":1,\"919\":1,\"920\":5,\"922\":1}}],[\"script\",{\"1\":{\"864\":2}}],[\"script>\",{\"1\":{\"719\":1,\"893\":1}}],[\"scope>\",{\"1\":{\"834\":1,\"835\":1,\"850\":4}}],[\"scope\",{\"1\":{\"832\":1}}],[\"scoremap\",{\"1\":{\"65\":3}}],[\"score<string>\",{\"1\":{\"281\":3}}],[\"score<>\",{\"1\":{\"15\":3,\"281\":1}}],[\"score<\",{\"1\":{\"15\":3}}],[\"score<t>\",{\"1\":{\"281\":1}}],[\"score<t\",{\"1\":{\"15\":1}}],[\"score\",{\"1\":{\"15\":6,\"65\":5,\"280\":9,\"281\":4,\"338\":5,\"339\":3,\"379\":1}}],[\"schemalocation=\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"schedule\",{\"1\":{\"166\":1,\"167\":2}}],[\"sc是不允许更新的\",{\"1\":{\"596\":1}}],[\"sc的基本表是sc\",{\"1\":{\"596\":1}}],[\"sc\",{\"1\":{\"596\":4}}],[\"scala\",{\"1\":{\"817\":1}}],[\"scalar\",{\"1\":{\"522\":1}}],[\"scanner\",{\"1\":{\"128\":6,\"374\":6,\"537\":4,\"538\":3,\"621\":3,\"622\":5}}],[\"src=\",{\"1\":{\"333\":1}}],[\"src\",{\"1\":{\"110\":1,\"199\":1}}],[\"skip=true来以跳过测试的方式进行打包\",{\"1\":{\"853\":1}}],[\"skipping\",{\"1\":{\"606\":1}}],[\"skip\",{\"1\":{\"91\":2,\"96\":1,\"606\":1}}],[\"simple\",{\"1\":{\"779\":1}}],[\"simpledateformat\",{\"1\":{\"765\":2,\"893\":2}}],[\"simpleformatter\",{\"1\":{\"738\":1}}],[\"simplest\",{\"0\":{\"398\":1}}],[\"sid=3\",{\"1\":{\"613\":1}}],[\"sid\",{\"1\":{\"586\":4,\"613\":1,\"616\":4,\"627\":9,\"643\":1,\"659\":2,\"671\":6,\"672\":2}}],[\"site\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"signed\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"si​\",{\"1\":{\"393\":2,\"516\":2}}],[\"single\",{\"1\":{\"456\":1,\"528\":1,\"864\":1}}],[\"singletonlist\",{\"1\":{\"79\":1}}],[\"sin\",{\"1\":{\"383\":1}}],[\"since\",{\"1\":{\"183\":1,\"864\":1,\"876\":1}}],[\"size表示最大的缓存对象数量\",{\"1\":{\"701\":1}}],[\"size=\",{\"1\":{\"701\":1}}],[\"size++\",{\"1\":{\"25\":1}}],[\"size\",{\"1\":{\"23\":1,\"25\":6,\"47\":1,\"56\":1,\"67\":2,\"193\":2,\"333\":3,\"720\":1}}],[\"sdawers\",{\"1\":{\"71\":1}}],[\"s\",{\"0\":{\"526\":1},\"1\":{\"30\":4,\"34\":2,\"139\":1,\"183\":1,\"191\":1,\"192\":2,\"246\":4,\"297\":2,\"319\":2,\"323\":3,\"353\":2,\"354\":4,\"383\":1,\"384\":1,\"385\":1,\"387\":5,\"394\":5,\"400\":4,\"401\":1,\"414\":2,\"415\":1,\"416\":1,\"418\":10,\"419\":7,\"420\":4,\"422\":13,\"423\":4,\"427\":3,\"429\":4,\"431\":2,\"437\":11,\"440\":13,\"449\":3,\"451\":9,\"452\":8,\"453\":4,\"456\":1,\"458\":6,\"461\":6,\"486\":2,\"487\":7,\"489\":2,\"490\":3,\"493\":1,\"494\":3,\"505\":2,\"506\":2,\"507\":3,\"508\":4,\"509\":8,\"510\":7,\"515\":5,\"516\":28,\"524\":6,\"526\":1,\"527\":8,\"528\":2,\"529\":12,\"530\":4,\"606\":1,\"641\":1,\"864\":1}}],[\"suitable\",{\"1\":{\"606\":2}}],[\"success\",{\"1\":{\"366\":2,\"606\":1,\"851\":1}}],[\"suffix\",{\"1\":{\"333\":2}}],[\"sub\",{\"1\":{\"244\":2}}],[\"substring\",{\"1\":{\"244\":2,\"333\":2}}],[\"sublist\",{\"1\":{\"24\":1}}],[\"sun\",{\"1\":{\"186\":1}}],[\"suspend\",{\"1\":{\"156\":1}}],[\"supported\",{\"1\":{\"876\":1}}],[\"supposed\",{\"1\":{\"378\":1}}],[\"supplier<list<string>>\",{\"1\":{\"812\":1}}],[\"supplier等\",{\"1\":{\"296\":1}}],[\"suppresswarnings\",{\"1\":{\"24\":1,\"60\":1,\"183\":1,\"204\":1}}],[\"super\",{\"1\":{\"15\":2,\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1,\"61\":1,\"214\":1,\"216\":3,\"218\":1,\"219\":1,\"220\":2,\"251\":2,\"265\":2,\"352\":1,\"881\":1}}],[\"summarystatistics\",{\"1\":{\"71\":2}}],[\"sum\",{\"1\":{\"8\":2,\"65\":1,\"71\":2,\"258\":5,\"355\":2,\"364\":2,\"582\":1,\"583\":2}}],[\"sevice\",{\"1\":{\"873\":1}}],[\"severe\",{\"1\":{\"727\":4,\"728\":1}}],[\"separator用于控制分隔符\",{\"1\":{\"693\":1}}],[\"separator=\",{\"1\":{\"693\":1,\"694\":1}}],[\"separately\",{\"1\":{\"139\":1}}],[\"sessioncreated\",{\"1\":{\"922\":1}}],[\"session将丢失\",{\"1\":{\"914\":1}}],[\"session并不是永远都存在的\",{\"1\":{\"914\":1}}],[\"session实际上是基于cookie实现的\",{\"1\":{\"912\":1}}],[\"sessionweb\",{\"1\":{\"909\":2}}],[\"session2\",{\"1\":{\"701\":3}}],[\"session\",{\"0\":{\"906\":1,\"911\":1},\"1\":{\"649\":1,\"650\":1,\"651\":1,\"653\":5,\"660\":1,\"682\":7,\"688\":2,\"693\":1,\"694\":1,\"700\":1,\"701\":2,\"705\":1,\"864\":1,\"911\":2,\"912\":1,\"913\":6,\"914\":3,\"921\":2}}],[\"select中编写一个xml配置动态sql\",{\"1\":{\"719\":1}}],[\"selectprovider\",{\"1\":{\"719\":1}}],[\"selectprovider来引用这边编写好的动态sql操作\",{\"1\":{\"719\":1}}],[\"selectdetailbyid\",{\"1\":{\"718\":2}}],[\"select代表的就是select标签\",{\"1\":{\"713\":1}}],[\"selectgroup\",{\"1\":{\"672\":2}}],[\"selectalluser\",{\"1\":{\"672\":1,\"712\":2,\"713\":1,\"715\":1,\"716\":1,\"717\":1}}],[\"selectbookbysid\",{\"1\":{\"671\":2}}],[\"select=\",{\"1\":{\"668\":1,\"671\":1,\"672\":1}}],[\"selectstusbysex\",{\"1\":{\"659\":2}}],[\"selectstubyid\",{\"1\":{\"659\":2,\"671\":1,\"701\":2}}],[\"selectstudent\",{\"1\":{\"643\":2,\"647\":1,\"659\":3,\"672\":1}}],[\"selectcursor\",{\"1\":{\"653\":1}}],[\"selectmap\",{\"1\":{\"653\":1}}],[\"selectuserdetailbyid\",{\"1\":{\"668\":2}}],[\"selectusersbyage\",{\"1\":{\"653\":2}}],[\"selectusers\",{\"1\":{\"653\":4}}],[\"selectuserbyidandage\",{\"1\":{\"650\":1,\"651\":2,\"652\":1,\"660\":5}}],[\"selectuserbyid\",{\"1\":{\"648\":4,\"649\":1,\"650\":1,\"653\":1,\"658\":1,\"666\":1,\"668\":1,\"682\":2,\"690\":1,\"691\":1,\"700\":6,\"703\":1,\"704\":1,\"705\":1,\"718\":1,\"719\":3,\"720\":1}}],[\"selectone\",{\"1\":{\"649\":1,\"650\":1,\"651\":1}}],[\"selectlist\",{\"1\":{\"643\":1,\"647\":1,\"653\":2}}],[\"select>\",{\"1\":{\"643\":1,\"648\":4,\"650\":1,\"651\":1,\"652\":1,\"653\":2,\"658\":1,\"659\":3,\"660\":1,\"666\":1,\"668\":2,\"671\":2,\"672\":3,\"690\":1,\"691\":1,\"703\":1,\"704\":1,\"712\":1,\"719\":1}}],[\"select返回的数据类似于一个excel表格\",{\"1\":{\"614\":1}}],[\"select\",{\"0\":{\"668\":1},\"1\":{\"579\":5,\"581\":2,\"582\":1,\"583\":4,\"584\":3,\"585\":1,\"586\":2,\"587\":2,\"596\":2,\"605\":1,\"621\":2,\"622\":2,\"643\":1,\"648\":2,\"650\":1,\"651\":1,\"652\":1,\"653\":3,\"658\":1,\"659\":3,\"660\":2,\"666\":1,\"667\":1,\"668\":2,\"669\":2,\"670\":1,\"671\":3,\"672\":4,\"690\":1,\"691\":1,\"703\":1,\"704\":1,\"712\":1,\"713\":2,\"715\":2,\"716\":2,\"717\":2,\"718\":5,\"719\":4,\"720\":2,\"888\":2}}],[\"secure\",{\"1\":{\"909\":1}}],[\"securityadmin等人员才有权力执行dcl\",{\"1\":{\"561\":1}}],[\"sec\",{\"1\":{\"544\":7,\"908\":4,\"913\":5}}],[\"service\",{\"1\":{\"871\":1,\"872\":1,\"873\":1,\"874\":1,\"876\":5}}],[\"servletcontext\",{\"1\":{\"901\":1,\"903\":1}}],[\"servletcontext全局唯一\",{\"1\":{\"901\":1}}],[\"servletcontext对象\",{\"0\":{\"901\":1}}],[\"servletconfig\",{\"1\":{\"871\":3}}],[\"servlet3\",{\"0\":{\"896\":1,\"897\":1}}],[\"servlet2\",{\"0\":{\"884\":1,\"885\":1}}],[\"servlet只有在被访问时才会加载\",{\"1\":{\"881\":1}}],[\"servlet>\",{\"1\":{\"871\":1}}],[\"servletresponse就是我们需要返回给浏览器的http响应报文实体类封装\",{\"1\":{\"873\":1}}],[\"servletresponse\",{\"1\":{\"871\":2,\"874\":2,\"875\":1,\"876\":1,\"919\":2,\"920\":10,\"921\":1}}],[\"servletrequest和servletresponse\",{\"1\":{\"873\":1}}],[\"servletrequest\",{\"1\":{\"871\":2,\"873\":1,\"874\":3,\"876\":1,\"919\":3,\"920\":10,\"921\":1}}],[\"servletexception\",{\"1\":{\"871\":2,\"874\":1,\"876\":5,\"881\":2,\"886\":1,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"919\":1,\"920\":3,\"921\":4}}],[\"servlet并不是专用于http协议通信\",{\"1\":{\"870\":1}}],[\"servlet1\",{\"0\":{\"868\":1}}],[\"servlet\",{\"0\":{\"870\":1,\"872\":1},\"1\":{\"604\":1,\"870\":3,\"871\":11,\"872\":5,\"875\":1,\"876\":1}}],[\"server\",{\"1\":{\"536\":4,\"537\":5,\"543\":4,\"544\":5,\"549\":2}}],[\"serversocket\",{\"1\":{\"536\":4,\"537\":2,\"543\":2,\"544\":4}}],[\"serialversionuid\",{\"1\":{\"132\":1,\"133\":1,\"921\":1}}],[\"serializable\",{\"1\":{\"25\":2,\"42\":1,\"58\":1,\"67\":1,\"131\":1,\"132\":1,\"133\":1,\"305\":1,\"599\":1,\"727\":1}}],[\"sequence\",{\"1\":{\"352\":2,\"432\":1}}],[\"sealed主动放弃了密封特性\",{\"1\":{\"347\":1}}],[\"sealed类型\",{\"1\":{\"347\":4}}],[\"sealed或是non\",{\"1\":{\"347\":1}}],[\"sealed关键字同时出现\",{\"1\":{\"347\":1}}],[\"sealed写在原来final的位置\",{\"1\":{\"347\":1}}],[\"sealed\",{\"1\":{\"346\":1,\"347\":5}}],[\"sendredircet\",{\"1\":{\"899\":1}}],[\"sendredirect\",{\"1\":{\"899\":1,\"901\":1,\"908\":1,\"910\":1,\"913\":1,\"921\":1}}],[\"senderror\",{\"1\":{\"876\":2}}],[\"send\",{\"1\":{\"333\":3,\"893\":1}}],[\"se\",{\"1\":{\"304\":1,\"922\":1}}],[\"see\",{\"1\":{\"139\":1,\"167\":1,\"864\":1}}],[\"seely\",{\"1\":{\"65\":3}}],[\"setmaxage\",{\"1\":{\"909\":1,\"910\":2}}],[\"setmessage\",{\"1\":{\"366\":2}}],[\"setcontenttype\",{\"1\":{\"876\":1,\"881\":1,\"889\":1,\"891\":2,\"892\":1,\"893\":1}}],[\"setcode\",{\"1\":{\"366\":2}}],[\"setheader\",{\"1\":{\"875\":1,\"899\":1}}],[\"setformatter\",{\"1\":{\"738\":1,\"763\":1}}],[\"setuseparenthandlers\",{\"1\":{\"735\":1}}],[\"setuseragebyid\",{\"1\":{\"680\":3}}],[\"setlevel\",{\"1\":{\"729\":2,\"745\":2}}],[\"setlogimpl\",{\"1\":{\"721\":1}}],[\"setlogwriter\",{\"1\":{\"606\":1}}],[\"setenvironment\",{\"1\":{\"721\":1}}],[\"settings>\",{\"1\":{\"669\":1,\"834\":1}}],[\"setter来为当前类的所有字段生成get\",{\"1\":{\"629\":1}}],[\"setter冗长\",{\"1\":{\"366\":1}}],[\"setter\",{\"1\":{\"366\":1,\"627\":1,\"629\":1}}],[\"setbeanproperty\",{\"1\":{\"658\":1}}],[\"set方法\",{\"1\":{\"627\":1,\"629\":1}}],[\"setattribute\",{\"1\":{\"900\":1,\"901\":1,\"913\":1}}],[\"setautocommit\",{\"1\":{\"623\":6}}],[\"setaccessible\",{\"1\":{\"191\":1,\"192\":2,\"193\":4,\"305\":1}}],[\"setreceivebuffersize\",{\"1\":{\"538\":1}}],[\"setkeepalive\",{\"1\":{\"538\":1}}],[\"setsex\",{\"1\":{\"627\":1,\"714\":1}}],[\"setsendbuffersize\",{\"1\":{\"538\":1}}],[\"setsid\",{\"1\":{\"627\":1}}],[\"setsavepoint\",{\"1\":{\"623\":1}}],[\"setstring\",{\"1\":{\"622\":2}}],[\"setstatus\",{\"1\":{\"221\":2,\"876\":1,\"899\":1}}],[\"setsotimeout\",{\"1\":{\"538\":1}}],[\"sets\",{\"1\":{\"394\":1}}],[\"setdata\",{\"1\":{\"366\":2}}],[\"setdaemon\",{\"1\":{\"172\":3}}],[\"setint\",{\"1\":{\"193\":1}}],[\"setpriority\",{\"1\":{\"145\":1}}],[\"setvalue\",{\"1\":{\"56\":1}}],[\"set<map\",{\"1\":{\"56\":1}}],[\"set<k>\",{\"1\":{\"56\":1}}],[\"set<string>\",{\"1\":{\"48\":3,\"49\":1,\"318\":1}}],[\"set<e>\",{\"1\":{\"47\":1,\"67\":1}}],[\"set支持的功能其实也就和\",{\"1\":{\"47\":1}}],[\"set集合\",{\"1\":{\"47\":1}}],[\"set\",{\"0\":{\"47\":1},\"1\":{\"24\":3,\"37\":1,\"47\":2,\"48\":13,\"49\":3,\"50\":13,\"67\":3,\"84\":1,\"162\":2,\"163\":1,\"193\":3,\"199\":1,\"318\":2,\"394\":3,\"572\":1,\"605\":3,\"613\":1,\"614\":1,\"616\":8,\"680\":1,\"908\":2,\"913\":2}}],[\"setname\",{\"1\":{\"7\":2,\"167\":1,\"627\":1,\"714\":1}}],[\"sex>\",{\"1\":{\"634\":1}}],[\"sex\",{\"1\":{\"4\":1,\"5\":1,\"9\":14,\"117\":1,\"121\":1,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"241\":1,\"616\":4,\"627\":9,\"643\":1,\"659\":3,\"671\":2,\"672\":2}}],[\"stdoutimpl\",{\"1\":{\"721\":1}}],[\"stdout\",{\"1\":{\"669\":1,\"768\":2}}],[\"steady\",{\"1\":{\"509\":1}}],[\"step\",{\"0\":{\"491\":1},\"1\":{\"440\":2,\"453\":2,\"528\":1}}],[\"st+2​→at+3​\",{\"1\":{\"413\":1,\"416\":1}}],[\"st+2​→at+2​rt+3​\",{\"1\":{\"413\":1,\"416\":1}}],[\"st+1​=s\",{\"1\":{\"418\":2}}],[\"st+1​→at+1​rt+2​\",{\"1\":{\"413\":1,\"416\":1}}],[\"st+1​∣at+1​\",{\"1\":{\"394\":3}}],[\"st+1​\",{\"1\":{\"387\":1,\"486\":4,\"490\":2,\"493\":1,\"494\":1,\"512\":2,\"513\":1,\"514\":2}}],[\"st​→at​rt+1​\",{\"1\":{\"413\":1,\"416\":1}}],[\"st​\",{\"1\":{\"394\":4,\"486\":12,\"490\":6,\"494\":5,\"510\":4,\"511\":4,\"512\":3,\"513\":2,\"514\":2,\"530\":1}}],[\"store\",{\"1\":{\"755\":1}}],[\"stochastic\",{\"0\":{\"474\":1},\"1\":{\"393\":1,\"427\":1,\"460\":1,\"466\":2}}],[\"stop\",{\"1\":{\"142\":1,\"143\":1,\"393\":1}}],[\"study<integer>\",{\"1\":{\"282\":1}}],[\"study<t>\",{\"1\":{\"282\":2}}],[\"study\",{\"1\":{\"219\":15,\"220\":2,\"221\":4,\"255\":6,\"256\":3,\"257\":18,\"258\":15,\"605\":1,\"613\":1,\"721\":1,\"834\":1}}],[\"student\",{\"1\":{\"65\":14,\"186\":3,\"191\":15,\"192\":8,\"208\":2,\"216\":4,\"219\":2,\"220\":10,\"221\":6,\"255\":5,\"342\":12,\"371\":6,\"586\":4,\"597\":1,\"598\":2,\"605\":1,\"613\":3,\"616\":11,\"627\":3,\"643\":5,\"647\":2,\"659\":7,\"671\":2,\"672\":2,\"714\":5,\"825\":5}}],[\"students\",{\"1\":{\"65\":2}}],[\"standard\",{\"1\":{\"779\":1}}],[\"stable\",{\"1\":{\"305\":1}}],[\"statrts的解释\",{\"0\":{\"458\":1}}],[\"statement除了执行这样的dql语句外\",{\"1\":{\"608\":1}}],[\"statement\",{\"1\":{\"605\":3,\"607\":1,\"613\":5,\"615\":5,\"621\":3,\"622\":5,\"623\":19,\"677\":6,\"688\":1,\"719\":1}}],[\"statevalue\",{\"1\":{\"510\":1}}],[\"states中\",{\"1\":{\"393\":1}}],[\"states中限制action\",{\"1\":{\"393\":1}}],[\"states的任务\",{\"1\":{\"393\":1}}],[\"states的trajectory\",{\"1\":{\"393\":1}}],[\"states\",{\"1\":{\"393\":1,\"394\":1}}],[\"state\",{\"0\":{\"412\":1,\"414\":1,\"415\":1,\"421\":1,\"432\":1,\"485\":1,\"506\":1,\"524\":1},\"1\":{\"387\":2,\"393\":6,\"394\":4,\"411\":1,\"414\":4,\"415\":4,\"416\":1,\"419\":1,\"421\":1,\"422\":6,\"423\":2,\"426\":1,\"429\":1,\"430\":1,\"437\":1,\"440\":2,\"442\":1,\"444\":2,\"445\":1,\"449\":1,\"451\":3,\"453\":3,\"455\":6,\"456\":1,\"458\":2,\"460\":1,\"466\":1,\"485\":1,\"487\":2,\"489\":2,\"505\":1,\"509\":1,\"522\":1,\"524\":2,\"529\":1}}],[\"status>\",{\"1\":{\"221\":1}}],[\"status\",{\"1\":{\"221\":22,\"393\":1,\"564\":2,\"864\":5,\"893\":1}}],[\"stationary\",{\"0\":{\"509\":1},\"1\":{\"509\":2,\"526\":1}}],[\"statistics\",{\"1\":{\"71\":4}}],[\"static<t>\",{\"1\":{\"359\":1}}],[\"static\",{\"1\":{\"4\":3,\"5\":1,\"14\":6,\"15\":3,\"16\":1,\"23\":1,\"25\":12,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"58\":1,\"61\":1,\"64\":1,\"65\":2,\"66\":3,\"67\":1,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":4,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":5,\"120\":2,\"121\":3,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":2,\"132\":2,\"133\":3,\"138\":1,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":2,\"155\":10,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":4,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":4,\"182\":1,\"183\":3,\"184\":1,\"186\":9,\"191\":3,\"192\":3,\"193\":3,\"198\":3,\"199\":2,\"206\":1,\"207\":3,\"208\":2,\"215\":2,\"219\":3,\"220\":1,\"221\":8,\"227\":5,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":2,\"254\":10,\"255\":3,\"256\":1,\"257\":4,\"258\":5,\"266\":3,\"267\":6,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":6,\"288\":1,\"289\":1,\"290\":1,\"291\":2,\"292\":3,\"294\":1,\"295\":1,\"296\":1,\"297\":4,\"304\":1,\"305\":1,\"307\":1,\"311\":1,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":6,\"328\":2,\"330\":1,\"331\":3,\"333\":4,\"338\":2,\"339\":1,\"343\":1,\"347\":1,\"355\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":2,\"536\":3,\"537\":2,\"543\":2,\"544\":2,\"606\":4,\"613\":1,\"615\":1,\"616\":1,\"622\":1,\"623\":4,\"641\":1,\"643\":1,\"647\":4,\"719\":1,\"721\":1,\"725\":1,\"727\":8,\"729\":2,\"767\":2,\"773\":4,\"797\":1,\"802\":1,\"811\":1,\"812\":2,\"825\":1,\"834\":2,\"840\":2,\"849\":1,\"921\":1}}],[\"starts\",{\"0\":{\"454\":1,\"457\":1},\"1\":{\"454\":1,\"458\":2,\"459\":1}}],[\"start\",{\"1\":{\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"156\":2,\"161\":2,\"162\":2,\"163\":2,\"165\":6,\"167\":1,\"172\":3,\"174\":5,\"288\":1,\"289\":2,\"384\":1,\"802\":2}}],[\"starting\",{\"1\":{\"139\":1,\"415\":1,\"422\":2}}],[\"strarray\",{\"1\":{\"365\":4}}],[\"striptrailing\",{\"1\":{\"331\":1}}],[\"stripleading\",{\"1\":{\"331\":1}}],[\"strip\",{\"1\":{\"331\":1}}],[\"stringprovider\",{\"1\":{\"811\":2}}],[\"stringclass\",{\"1\":{\"305\":2}}],[\"string底层数据存放的是byte\",{\"1\":{\"305\":1}}],[\"string的拼接会在编译时进行各种优化\",{\"1\":{\"245\":1}}],[\"stringbuilder\",{\"0\":{\"245\":1},\"1\":{\"245\":5,\"765\":2}}],[\"string类中刚好有一个\",{\"1\":{\"296\":1}}],[\"string类重载了equals方法用于判断和比较内容是否相同\",{\"1\":{\"244\":1}}],[\"string类的加载器\",{\"1\":{\"198\":1}}],[\"string本身也是一个类\",{\"1\":{\"244\":1}}],[\"string>\",{\"1\":{\"57\":4,\"64\":1,\"66\":3}}],[\"strings这个变量就是一个string\",{\"1\":{\"241\":1}}],[\"strings\",{\"1\":{\"14\":3,\"241\":3,\"244\":2,\"808\":1}}],[\"string\",{\"0\":{\"244\":1},\"1\":{\"4\":5,\"5\":3,\"7\":3,\"9\":14,\"14\":12,\"15\":8,\"16\":1,\"23\":1,\"25\":11,\"30\":5,\"34\":3,\"35\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":7,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":6,\"90\":2,\"91\":4,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":4,\"120\":6,\"121\":3,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":3,\"132\":2,\"133\":3,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":2,\"172\":2,\"173\":2,\"174\":3,\"182\":4,\"183\":2,\"184\":2,\"186\":14,\"191\":6,\"192\":12,\"193\":3,\"198\":6,\"199\":9,\"206\":1,\"207\":7,\"208\":3,\"215\":1,\"218\":8,\"219\":4,\"220\":3,\"221\":5,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":6,\"239\":1,\"240\":1,\"241\":8,\"242\":2,\"244\":18,\"245\":14,\"246\":4,\"251\":10,\"252\":3,\"253\":2,\"254\":2,\"255\":4,\"256\":1,\"257\":3,\"258\":8,\"265\":2,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":6,\"281\":8,\"282\":3,\"288\":1,\"289\":1,\"290\":1,\"291\":3,\"292\":2,\"294\":1,\"295\":1,\"296\":6,\"297\":4,\"304\":1,\"305\":3,\"307\":4,\"311\":1,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":10,\"328\":3,\"330\":1,\"331\":5,\"333\":7,\"338\":3,\"339\":1,\"342\":4,\"343\":2,\"344\":6,\"347\":1,\"355\":1,\"361\":1,\"362\":3,\"364\":1,\"365\":11,\"366\":6,\"367\":2,\"368\":11,\"536\":3,\"537\":3,\"543\":2,\"544\":2,\"606\":4,\"607\":1,\"613\":1,\"615\":1,\"616\":4,\"621\":1,\"622\":2,\"623\":4,\"627\":10,\"641\":2,\"643\":3,\"647\":1,\"652\":1,\"658\":5,\"659\":1,\"666\":3,\"670\":2,\"672\":2,\"677\":6,\"688\":1,\"715\":1,\"717\":4,\"719\":1,\"725\":1,\"727\":1,\"756\":2,\"761\":2,\"765\":2,\"767\":2,\"773\":1,\"808\":2,\"809\":1,\"811\":1,\"812\":2,\"825\":2,\"840\":1,\"849\":1,\"871\":1,\"874\":1,\"876\":4,\"888\":4,\"889\":3,\"893\":1,\"910\":2,\"921\":1}}],[\"str5\",{\"1\":{\"245\":4}}],[\"str4\",{\"1\":{\"244\":2,\"245\":4}}],[\"str3\",{\"1\":{\"244\":2,\"245\":4}}],[\"str2\",{\"1\":{\"244\":3,\"245\":4}}],[\"str1\",{\"1\":{\"244\":3,\"245\":4}}],[\"structured\",{\"1\":{\"561\":1}}],[\"structure\",{\"1\":{\"167\":1}}],[\"stream等\",{\"1\":{\"811\":1}}],[\"stream可以由数组或集合创建\",{\"1\":{\"358\":1}}],[\"stream<integer>\",{\"1\":{\"362\":2}}],[\"stream<t>\",{\"1\":{\"359\":1}}],[\"stream<string>\",{\"1\":{\"331\":1,\"361\":1,\"362\":1}}],[\"stream<e>\",{\"1\":{\"23\":2,\"173\":1}}],[\"stream还新增了对数据的截断操作\",{\"1\":{\"322\":1}}],[\"stream流\",{\"0\":{\"70\":1,\"71\":1}}],[\"streamsupport\",{\"1\":{\"23\":2,\"173\":1}}],[\"stream\",{\"0\":{\"319\":1},\"1\":{\"23\":3,\"71\":11,\"109\":1,\"110\":2,\"127\":2,\"173\":1,\"199\":3,\"319\":1,\"320\":2,\"321\":2,\"322\":2,\"333\":3,\"356\":2,\"358\":1,\"359\":6,\"361\":3,\"362\":3,\"363\":1,\"364\":5,\"365\":7,\"371\":3,\"537\":2,\"543\":3,\"892\":2}}],[\"str\",{\"1\":{\"14\":1,\"25\":7,\"71\":5,\"96\":3,\"186\":4,\"192\":1,\"199\":3,\"244\":8,\"246\":5,\"296\":1,\"297\":11,\"323\":9,\"330\":1,\"331\":12,\"365\":2,\"796\":2,\"808\":2,\"809\":1,\"811\":2,\"812\":4}}],[\"a>\",{\"1\":{\"891\":1}}],[\"against\",{\"1\":{\"804\":1,\"864\":1}}],[\"age=18\",{\"1\":{\"669\":1}}],[\"age=0\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"age>\",{\"1\":{\"634\":1}}],[\"agent从一个状态出发\",{\"1\":{\"422\":1}}],[\"agent从一个状态出发可以得到的平均return\",{\"1\":{\"422\":1}}],[\"agent可能走出的全部轨迹\",{\"1\":{\"393\":1}}],[\"agent将获得负奖励\",{\"1\":{\"387\":1}}],[\"agent\",{\"1\":{\"387\":1,\"393\":2,\"422\":2,\"528\":1,\"544\":1,\"908\":1,\"913\":1}}],[\"age已经初始化完\",{\"1\":{\"9\":1}}],[\"age\",{\"1\":{\"4\":1,\"5\":2,\"9\":18,\"117\":1,\"121\":1,\"186\":1,\"191\":1,\"192\":1,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"241\":1,\"307\":4,\"564\":3,\"651\":3,\"652\":3,\"653\":2,\"658\":6,\"660\":7,\"666\":1,\"667\":2,\"668\":2,\"669\":1,\"670\":3,\"672\":3,\"678\":2,\"679\":2,\"680\":4,\"688\":1,\"690\":1,\"691\":3,\"694\":3,\"713\":2,\"714\":4,\"715\":1,\"717\":6,\"719\":3,\"825\":1}}],[\"aferall\",{\"1\":{\"802\":1}}],[\"afterwards\",{\"1\":{\"864\":1}}],[\"afterall则会在所有测试用例完成之后执行\",{\"1\":{\"802\":1}}],[\"aftereach来实现灵活控制\",{\"1\":{\"803\":1}}],[\"aftereach\",{\"1\":{\"802\":1}}],[\"after\",{\"1\":{\"61\":1,\"352\":9}}],[\"afternodeinsertion\",{\"1\":{\"59\":1}}],[\"afternodeaccess\",{\"1\":{\"59\":1}}],[\"authorized\",{\"1\":{\"864\":1}}],[\"autocommit\",{\"1\":{\"647\":3,\"688\":1}}],[\"automatically\",{\"1\":{\"605\":1}}],[\"aug\",{\"1\":{\"669\":1}}],[\"a1\",{\"1\":{\"584\":2}}],[\"a1​\",{\"1\":{\"393\":2,\"394\":2,\"455\":1}}],[\"a∈a∑​π\",{\"1\":{\"529\":1}}],[\"a∈a∑​▽θ​π\",{\"1\":{\"529\":2}}],[\"ak​=k1​是满足上面三个条件的\",{\"1\":{\"472\":1}}],[\"ak​→0不要过快\",{\"1\":{\"472\":1}}],[\"ak​→0\",{\"1\":{\"472\":1}}],[\"ak​\",{\"1\":{\"471\":1}}],[\"ak∗​∣s\",{\"1\":{\"453\":1}}],[\"ak∗​\",{\"1\":{\"440\":1}}],[\"a3​\",{\"1\":{\"455\":2}}],[\"a4​\",{\"1\":{\"455\":2}}],[\"a2\",{\"1\":{\"584\":1}}],[\"a2​\",{\"1\":{\"455\":4}}],[\"a2c\",{\"0\":{\"399\":1}}],[\"a=ak∗​\",{\"1\":{\"437\":1,\"440\":1}}],[\"avatar=https\",{\"1\":{\"669\":1}}],[\"avatar\",{\"1\":{\"666\":1,\"667\":2,\"669\":1}}],[\"available\",{\"1\":{\"91\":2,\"98\":1,\"199\":1,\"660\":1}}],[\"avg\",{\"1\":{\"582\":1,\"596\":1}}],[\"avif\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"average\",{\"0\":{\"524\":1,\"527\":1},\"1\":{\"422\":2,\"528\":1}}],[\"a∑​π\",{\"1\":{\"419\":1,\"529\":1}}],[\"a∑​p\",{\"1\":{\"418\":1}}],[\"a∼π​\",{\"1\":{\"400\":3,\"529\":1}}],[\"a∣s\",{\"1\":{\"394\":1,\"400\":3,\"415\":1,\"417\":2,\"418\":5,\"419\":4,\"422\":3,\"423\":1,\"429\":2,\"431\":2,\"432\":1,\"437\":2,\"440\":3,\"453\":1,\"461\":1,\"487\":1,\"522\":1,\"527\":1,\"529\":14,\"530\":2}}],[\"attempting\",{\"1\":{\"606\":1}}],[\"at+1​\",{\"1\":{\"490\":2,\"513\":1,\"514\":1}}],[\"at\",{\"1\":{\"393\":1,\"394\":1,\"660\":1}}],[\"at​∣st​\",{\"1\":{\"530\":1}}],[\"at​=a\",{\"1\":{\"417\":1,\"418\":2,\"422\":2,\"423\":1,\"449\":1,\"451\":1,\"452\":1,\"493\":1}}],[\"at​\",{\"1\":{\"387\":1,\"490\":8,\"494\":5,\"513\":2,\"514\":2,\"530\":1}}],[\"ai​\",{\"1\":{\"393\":1,\"516\":2}}],[\"awgn\",{\"1\":{\"383\":1}}],[\"aerial\",{\"1\":{\"378\":1}}],[\"aeiou\",{\"1\":{\"246\":1}}],[\"already\",{\"1\":{\"606\":1}}],[\"aliyun\",{\"1\":{\"827\":1}}],[\"alias=\",{\"1\":{\"649\":1}}],[\"alive\",{\"1\":{\"544\":1,\"908\":3,\"913\":3}}],[\"alice\",{\"1\":{\"371\":1}}],[\"along\",{\"1\":{\"528\":1}}],[\"alogorithm\",{\"0\":{\"506\":1}}],[\"algorithms\",{\"0\":{\"510\":1},\"1\":{\"466\":1}}],[\"algorithm\",{\"0\":{\"436\":1,\"439\":1,\"443\":1,\"445\":1,\"446\":1,\"469\":1},\"1\":{\"432\":1,\"442\":2,\"444\":2,\"445\":1,\"450\":1,\"453\":1,\"472\":1}}],[\"allows\",{\"1\":{\"864\":4}}],[\"allargsconstructor和\",{\"1\":{\"629\":1}}],[\"allargsconstructor\",{\"1\":{\"627\":1,\"825\":1}}],[\"all|权限1\",{\"1\":{\"591\":2}}],[\"all\",{\"1\":{\"415\":1,\"427\":1,\"729\":2,\"745\":2}}],[\"allmatch\",{\"1\":{\"363\":1}}],[\"alter\",{\"1\":{\"568\":2}}],[\"alt\",{\"1\":{\"289\":1,\"303\":2,\"304\":1,\"305\":1,\"308\":2,\"316\":6,\"318\":1,\"328\":3,\"337\":1,\"341\":2,\"343\":2,\"344\":2,\"347\":2,\"358\":1,\"658\":1,\"659\":1,\"666\":1,\"667\":2,\"670\":1,\"672\":1,\"688\":2,\"693\":1,\"694\":1,\"699\":1,\"700\":2,\"701\":1,\"705\":1,\"714\":1,\"737\":1,\"747\":1,\"765\":1,\"773\":1,\"775\":1,\"776\":2,\"777\":1,\"778\":1,\"780\":1,\"786\":1,\"790\":1,\"791\":1,\"793\":1,\"803\":2,\"805\":1,\"818\":1,\"826\":1,\"853\":1,\"908\":1,\"912\":1,\"918\":1,\"920\":2,\"922\":1,\"926\":1}}],[\"adriver\",{\"1\":{\"606\":6}}],[\"advantage\",{\"0\":{\"399\":1}}],[\"adam\",{\"1\":{\"368\":1}}],[\"admin\",{\"1\":{\"344\":2,\"864\":2}}],[\"addcookie\",{\"1\":{\"908\":1,\"910\":2}}],[\"addclasspath>\",{\"1\":{\"854\":1}}],[\"addhandler\",{\"1\":{\"736\":1,\"737\":1,\"746\":1}}],[\"addmappers\",{\"1\":{\"721\":1}}],[\"adduser\",{\"1\":{\"678\":2,\"679\":1}}],[\"addbatch\",{\"1\":{\"615\":2}}],[\"addifabsent\",{\"1\":{\"606\":1}}],[\"added\",{\"1\":{\"606\":1}}],[\"addthen\",{\"1\":{\"354\":1}}],[\"addlast\",{\"1\":{\"44\":1}}],[\"addfirst\",{\"1\":{\"44\":1}}],[\"addall\",{\"1\":{\"23\":1,\"24\":1,\"47\":1,\"48\":1,\"49\":1}}],[\"add\",{\"1\":{\"14\":2,\"23\":2,\"24\":1,\"25\":13,\"37\":1,\"43\":1,\"47\":1,\"48\":3,\"50\":6,\"71\":16,\"79\":2,\"80\":2,\"84\":1,\"155\":9,\"174\":3,\"193\":1,\"358\":4,\"361\":4,\"362\":4,\"365\":4,\"371\":2,\"568\":1,\"864\":2}}],[\"a的模块呢\",{\"1\":{\"308\":1}}],[\"a依赖于其他模块\",{\"1\":{\"308\":1}}],[\"a不暴露\",{\"1\":{\"307\":1}}],[\"a中暴露出来的包内容了\",{\"1\":{\"307\":1}}],[\"a<t>\",{\"1\":{\"282\":2}}],[\"a<>\",{\"1\":{\"282\":1}}],[\"a<string>\",{\"1\":{\"282\":2}}],[\"aa\",{\"1\":{\"808\":1}}],[\"aarch64\",{\"1\":{\"796\":1}}],[\"aasd\",{\"1\":{\"207\":1}}],[\"aaaa\",{\"1\":{\"71\":1,\"242\":1}}],[\"aaa\",{\"1\":{\"14\":1,\"43\":1,\"44\":1,\"48\":4,\"80\":2,\"245\":1,\"318\":4,\"323\":2,\"340\":1,\"371\":1,\"812\":2}}],[\"anotherinteger\",{\"1\":{\"294\":2}}],[\"annotationprocessor\",{\"1\":{\"628\":1}}],[\"annotationtype\",{\"1\":{\"208\":2}}],[\"annotation\",{\"1\":{\"208\":14}}],[\"aninterface\",{\"1\":{\"186\":2}}],[\"andthen\",{\"1\":{\"352\":1,\"354\":2}}],[\"and\",{\"0\":{\"377\":1},\"1\":{\"167\":2,\"378\":2,\"388\":1,\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"449\":1,\"516\":1,\"580\":1,\"605\":1,\"621\":2,\"622\":2,\"651\":1,\"652\":1,\"660\":2,\"690\":1,\"691\":3,\"719\":2,\"864\":4,\"888\":1}}],[\"anymatch\",{\"1\":{\"363\":1}}],[\"any\",{\"1\":{\"139\":1,\"427\":1,\"432\":1,\"460\":1,\"864\":1}}],[\"an\",{\"1\":{\"139\":1,\"352\":2,\"393\":1,\"421\":1,\"422\":1}}],[\"above\",{\"1\":{\"864\":1}}],[\"ab\",{\"1\":{\"331\":1}}],[\"abs方法可以求绝对值\",{\"1\":{\"274\":1}}],[\"abs\",{\"1\":{\"274\":1}}],[\"abstractset<e>\",{\"1\":{\"67\":1}}],[\"abstractsequentiallist<e>\",{\"1\":{\"25\":1,\"42\":1}}],[\"abstractmap<k\",{\"1\":{\"58\":1}}],[\"abstractlist<e>\",{\"1\":{\"25\":1}}],[\"abstract\",{\"1\":{\"16\":8,\"139\":1,\"218\":2,\"219\":1,\"255\":2,\"290\":2,\"317\":1,\"323\":2,\"347\":1,\"921\":1}}],[\"abc\",{\"1\":{\"246\":2,\"714\":1}}],[\"abcabccaa\",{\"1\":{\"246\":1}}],[\"abcd\",{\"1\":{\"91\":3,\"305\":1,\"331\":1}}],[\"a是上一次计算的值\",{\"1\":{\"71\":1}}],[\"asc|desc\",{\"1\":{\"581\":3}}],[\"asdf\",{\"1\":{\"186\":1}}],[\"asdasda\",{\"1\":{\"71\":1}}],[\"assign\",{\"1\":{\"864\":1}}],[\"assisted\",{\"1\":{\"378\":1}}],[\"assembly<\",{\"1\":{\"854\":1}}],[\"assembly\",{\"1\":{\"854\":1}}],[\"assertarrayequals\",{\"1\":{\"834\":1}}],[\"assertall\",{\"1\":{\"789\":1}}],[\"assert在junit5时名称发生了变化assertions\",{\"1\":{\"834\":1}}],[\"assertsame\",{\"1\":{\"788\":1}}],[\"assertthrows\",{\"1\":{\"790\":1}}],[\"asserttrue\",{\"1\":{\"787\":1,\"789\":4}}],[\"assertture\",{\"1\":{\"787\":1}}],[\"assertequals\",{\"1\":{\"780\":1,\"786\":3}}],[\"assertions\",{\"1\":{\"780\":1,\"786\":3,\"787\":2,\"788\":1,\"789\":5,\"790\":1,\"804\":1,\"834\":1}}],[\"assertionerror\",{\"1\":{\"268\":1}}],[\"assert\",{\"1\":{\"268\":2}}],[\"assert断言表达式\",{\"1\":{\"268\":1}}],[\"assumetrue\",{\"1\":{\"791\":1}}],[\"assumptions\",{\"1\":{\"791\":1}}],[\"assubclass\",{\"1\":{\"186\":2}}],[\"association\",{\"1\":{\"670\":1}}],[\"association>\",{\"1\":{\"667\":1,\"672\":1}}],[\"associate\",{\"1\":{\"394\":1}}],[\"assdw\",{\"1\":{\"71\":1}}],[\"as\",{\"1\":{\"167\":2,\"432\":1,\"478\":1,\"596\":2,\"672\":2}}],[\"aslist\",{\"1\":{\"25\":2,\"30\":2,\"34\":2,\"35\":1,\"48\":1,\"49\":1,\"65\":1,\"71\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":4,\"173\":1,\"186\":1,\"364\":1}}],[\"apache\",{\"1\":{\"658\":2,\"660\":2,\"690\":1,\"817\":3,\"819\":3,\"840\":3,\"849\":3,\"864\":1}}],[\"apng\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"appclassloader\",{\"1\":{\"926\":1}}],[\"app\",{\"1\":{\"864\":1}}],[\"apptest\",{\"1\":{\"596\":1}}],[\"appears\",{\"1\":{\"455\":1}}],[\"append\",{\"1\":{\"97\":1,\"245\":7,\"765\":11}}],[\"approximation\",{\"0\":{\"504\":1,\"511\":1,\"512\":1,\"513\":1,\"514\":1},\"1\":{\"466\":1,\"521\":1}}],[\"approximate\",{\"1\":{\"456\":1}}],[\"approach\",{\"1\":{\"388\":2}}],[\"appropriate\",{\"1\":{\"167\":1}}],[\"application\",{\"1\":{\"544\":3,\"606\":1,\"864\":1,\"908\":3,\"913\":3}}],[\"applets\",{\"1\":{\"604\":1}}],[\"applewebkit\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"apple\",{\"1\":{\"255\":3,\"811\":1}}],[\"apply\",{\"1\":{\"24\":1}}],[\"api<\",{\"1\":{\"842\":1}}],[\"api的改进等\",{\"1\":{\"323\":1}}],[\"api\",{\"0\":{\"319\":1},\"1\":{\"71\":1,\"305\":1,\"319\":1,\"332\":1,\"356\":2,\"604\":1}}],[\"api添加了一个新的抽象称为\",{\"1\":{\"71\":1}}],[\"actual\",{\"1\":{\"786\":1}}],[\"active\",{\"1\":{\"564\":2}}],[\"action=\",{\"1\":{\"886\":1,\"892\":1}}],[\"actions\",{\"1\":{\"394\":1}}],[\"action\",{\"0\":{\"422\":1,\"489\":1,\"493\":1},\"1\":{\"32\":3,\"35\":3,\"36\":3,\"139\":1,\"387\":1,\"393\":3,\"394\":2,\"422\":8,\"423\":2,\"427\":2,\"431\":2,\"437\":1,\"440\":1,\"444\":2,\"449\":1,\"451\":5,\"453\":6,\"455\":9,\"456\":3,\"458\":4,\"460\":2,\"466\":1,\"489\":4,\"490\":1,\"493\":2,\"494\":1,\"505\":1}}],[\"actor\",{\"0\":{\"397\":1,\"398\":1,\"399\":1,\"403\":1,\"407\":1},\"1\":{\"397\":2}}],[\"academic\",{\"0\":{\"936\":1},\"2\":{\"389\":1,\"395\":1,\"408\":1,\"424\":1,\"433\":1,\"447\":1,\"464\":1,\"481\":1,\"502\":1,\"519\":1,\"532\":1}}],[\"accpeted\",{\"1\":{\"544\":1}}],[\"accumulator\",{\"1\":{\"364\":2}}],[\"account1\",{\"1\":{\"344\":2}}],[\"account0\",{\"1\":{\"344\":2}}],[\"account\",{\"1\":{\"344\":7}}],[\"acc\",{\"1\":{\"139\":2}}],[\"accessed\",{\"1\":{\"864\":1}}],[\"access\",{\"1\":{\"864\":5}}],[\"accessors来控制生成getter和setter的样式\",{\"1\":{\"629\":1}}],[\"accesscontrolcontext\",{\"1\":{\"139\":2}}],[\"accepted\",{\"1\":{\"544\":1}}],[\"accept\",{\"1\":{\"32\":1,\"35\":1,\"36\":1,\"352\":3,\"353\":2,\"354\":1,\"536\":2,\"537\":2,\"543\":1,\"544\":5,\"908\":3,\"913\":3}}],[\"artifactid\",{\"1\":{\"820\":2}}],[\"artifactid>\",{\"1\":{\"819\":1,\"825\":1,\"834\":3,\"835\":1,\"840\":2,\"841\":1,\"842\":3,\"843\":2,\"849\":2,\"850\":6,\"854\":1,\"888\":2,\"891\":1}}],[\"archive>\",{\"1\":{\"854\":1}}],[\"arch\",{\"1\":{\"796\":1}}],[\"are\",{\"1\":{\"660\":1,\"864\":4}}],[\"arithmeticexception\",{\"1\":{\"266\":1}}],[\"arg0\",{\"1\":{\"660\":1}}],[\"arg1\",{\"1\":{\"660\":1}}],[\"argumentssource\",{\"1\":{\"812\":1}}],[\"argument\",{\"1\":{\"352\":2}}],[\"arg\",{\"1\":{\"242\":2,\"717\":3}}],[\"args\",{\"1\":{\"4\":3,\"5\":1,\"14\":5,\"15\":3,\"16\":1,\"23\":1,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":2,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":1,\"120\":2,\"121\":1,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":1,\"182\":1,\"183\":1,\"184\":1,\"186\":9,\"191\":2,\"192\":3,\"193\":3,\"198\":3,\"199\":1,\"206\":1,\"207\":3,\"208\":2,\"219\":2,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":3,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":1,\"254\":1,\"255\":3,\"256\":1,\"257\":3,\"258\":5,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":2,\"288\":1,\"289\":1,\"291\":1,\"292\":2,\"294\":1,\"295\":1,\"296\":1,\"304\":1,\"305\":1,\"307\":1,\"311\":1,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":5,\"328\":2,\"330\":1,\"331\":3,\"333\":4,\"340\":1,\"347\":1,\"355\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":1,\"536\":3,\"537\":2,\"543\":2,\"544\":2,\"613\":1,\"615\":1,\"622\":1,\"623\":4,\"641\":1,\"643\":1,\"647\":1,\"725\":1,\"727\":1,\"767\":2,\"773\":1,\"825\":1,\"840\":1,\"849\":1}}],[\"arrav\",{\"1\":{\"238\":1}}],[\"array就是我们要遍历的数组\",{\"1\":{\"237\":1}}],[\"arraydeque<>\",{\"1\":{\"45\":1}}],[\"array\",{\"1\":{\"25\":2,\"235\":2,\"236\":2,\"237\":4,\"238\":2,\"292\":6,\"294\":6,\"295\":3}}],[\"arraylist源码部分\",{\"1\":{\"25\":1}}],[\"arraylist<e>\",{\"1\":{\"25\":1}}],[\"arraylist<>\",{\"1\":{\"23\":1,\"25\":6,\"71\":5,\"76\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":1,\"173\":1,\"186\":1,\"193\":1,\"358\":1,\"361\":1,\"362\":1,\"365\":1}}],[\"arraylist<string>\",{\"1\":{\"23\":1,\"25\":1}}],[\"arraylist\",{\"0\":{\"25\":1},\"1\":{\"23\":2,\"25\":3,\"33\":1,\"186\":1,\"193\":1,\"365\":2,\"371\":1}}],[\"arrays类\",{\"1\":{\"275\":2}}],[\"arrays\",{\"1\":{\"14\":9,\"24\":1,\"25\":4,\"30\":2,\"34\":2,\"35\":1,\"48\":1,\"49\":1,\"65\":1,\"71\":2,\"77\":1,\"78\":1,\"79\":1,\"80\":4,\"98\":1,\"173\":3,\"186\":1,\"275\":5,\"292\":5,\"294\":4,\"295\":2,\"359\":2,\"364\":1,\"365\":2,\"735\":1,\"744\":1,\"886\":1}}],[\"arr\",{\"1\":{\"14\":12,\"173\":3,\"238\":8,\"240\":2,\"267\":2,\"275\":2,\"809\":1}}],[\"a\",{\"1\":{\"4\":1,\"8\":4,\"16\":4,\"23\":1,\"24\":3,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"46\":2,\"47\":1,\"48\":1,\"49\":1,\"50\":2,\"64\":2,\"71\":6,\"84\":4,\"107\":1,\"139\":3,\"219\":1,\"227\":7,\"229\":1,\"239\":3,\"241\":1,\"246\":6,\"251\":2,\"256\":3,\"257\":5,\"258\":5,\"266\":4,\"267\":2,\"268\":2,\"281\":3,\"282\":7,\"295\":2,\"307\":3,\"308\":2,\"309\":2,\"310\":2,\"319\":1,\"328\":4,\"331\":1,\"343\":2,\"346\":2,\"347\":6,\"352\":2,\"355\":5,\"364\":4,\"365\":1,\"371\":1,\"378\":1,\"387\":3,\"388\":2,\"393\":7,\"394\":5,\"400\":2,\"415\":3,\"417\":1,\"418\":3,\"419\":6,\"422\":13,\"423\":2,\"426\":1,\"427\":1,\"429\":3,\"431\":1,\"432\":2,\"437\":6,\"440\":6,\"444\":1,\"449\":3,\"451\":11,\"452\":8,\"453\":3,\"455\":2,\"456\":2,\"458\":6,\"460\":1,\"466\":1,\"487\":1,\"489\":4,\"490\":3,\"493\":3,\"494\":4,\"509\":1,\"515\":3,\"516\":22,\"527\":5,\"529\":9,\"530\":4,\"544\":1,\"606\":1,\"623\":4,\"786\":2,\"864\":3,\"913\":1}}],[\"a+b=c\",{\"1\":{\"0\":1}}],[\"png\",{\"1\":{\"891\":5,\"921\":1}}],[\"png放入到resource文件夹中\",{\"1\":{\"891\":1}}],[\"phase>\",{\"1\":{\"854\":1}}],[\"pwd=\",{\"1\":{\"621\":2,\"622\":2}}],[\"pk\",{\"1\":{\"565\":2}}],[\"pkn​\",{\"1\":{\"385\":1,\"387\":1}}],[\"pkn​​=pmax​\",{\"1\":{\"383\":1}}],[\"please\",{\"1\":{\"864\":2}}],[\"plugin>\",{\"1\":{\"854\":1}}],[\"plugin<\",{\"1\":{\"854\":1}}],[\"plugins>\",{\"1\":{\"854\":1}}],[\"plugins\",{\"1\":{\"827\":1}}],[\"placeholder=\",{\"1\":{\"886\":2,\"910\":1}}],[\"plain\",{\"1\":{\"633\":1}}],[\"platform\",{\"1\":{\"544\":1}}],[\"plos​μlos​+pnlos​μnlos​\",{\"1\":{\"383\":1}}],[\"plos​\",{\"1\":{\"383\":1}}],[\"pπ​\",{\"1\":{\"420\":1}}],[\"pπ​∈rn×n\",{\"1\":{\"420\":1}}],[\"pm​ax​\",{\"1\":{\"383\":1}}],[\"pmax​≥γσ2k0​dkn​​α\",{\"1\":{\"383\":1}}],[\"ppolicy\",{\"1\":{\"498\":1}}],[\"ppp\",{\"1\":{\"255\":1}}],[\"pp\",{\"1\":{\"255\":2,\"256\":2}}],[\"ppenguin\",{\"1\":{\"207\":1}}],[\"python等等都是支持正则表达式的\",{\"1\":{\"246\":1}}],[\"pi\",{\"1\":{\"440\":1,\"442\":1,\"444\":1}}],[\"pic=\",{\"1\":{\"333\":1}}],[\"pic\",{\"1\":{\"333\":4}}],[\"pig\",{\"1\":{\"162\":1}}],[\"pid\",{\"1\":{\"156\":1}}],[\"pages\",{\"1\":{\"864\":4}}],[\"page\",{\"1\":{\"864\":1}}],[\"packing默认是jar类型\",{\"1\":{\"855\":1}}],[\"packaging>\",{\"1\":{\"855\":1}}],[\"package等\",{\"1\":{\"851\":1}}],[\"package\",{\"1\":{\"120\":3,\"192\":1,\"198\":1,\"199\":1,\"220\":1,\"254\":3,\"255\":2,\"304\":1,\"307\":1,\"310\":2,\"311\":1,\"853\":1}}],[\"part\",{\"1\":{\"892\":4}}],[\"parent>\",{\"1\":{\"849\":1}}],[\"parent\",{\"1\":{\"744\":2,\"745\":1}}],[\"parse\",{\"1\":{\"636\":1}}],[\"param>\",{\"1\":{\"903\":2}}],[\"param来指定参数名称\",{\"1\":{\"719\":1}}],[\"param注解来指定某个参数的名称\",{\"1\":{\"660\":1}}],[\"param2\",{\"1\":{\"660\":4}}],[\"param1\",{\"1\":{\"660\":4}}],[\"params\",{\"1\":{\"658\":2}}],[\"param\",{\"1\":{\"338\":1,\"352\":2,\"616\":4,\"647\":1,\"660\":4,\"680\":2,\"888\":2,\"903\":2}}],[\"parametermap存储了我们发送的post请求所携带的表单数据\",{\"1\":{\"886\":1}}],[\"parameterized\",{\"1\":{\"812\":1}}],[\"parameterizedtest\",{\"1\":{\"808\":1,\"809\":2,\"810\":2,\"811\":1,\"812\":2}}],[\"parameterizedtest或\",{\"1\":{\"797\":1}}],[\"parameterizedtype\",{\"1\":{\"186\":7}}],[\"parameters\",{\"1\":{\"660\":1,\"669\":2}}],[\"parametertype=\",{\"1\":{\"648\":3,\"659\":1,\"671\":1,\"678\":1,\"679\":1,\"714\":1}}],[\"parameter\",{\"1\":{\"192\":3,\"660\":1,\"677\":3}}],[\"parallelsort\",{\"1\":{\"173\":1}}],[\"parallelstream就是利用了可拆分迭代器进行多线程操作\",{\"1\":{\"173\":1}}],[\"parallelstream\",{\"1\":{\"23\":1,\"173\":3,\"359\":1}}],[\"pair\",{\"1\":{\"453\":1,\"455\":6,\"456\":1,\"458\":2,\"460\":1}}],[\"password=123456\",{\"1\":{\"753\":1}}],[\"password=\",{\"1\":{\"368\":1,\"864\":2}}],[\"password\",{\"1\":{\"344\":3,\"368\":12,\"606\":4,\"641\":1,\"834\":1,\"864\":1,\"886\":2,\"888\":6,\"889\":4,\"910\":10}}],[\"path=\",{\"1\":{\"913\":1}}],[\"path\",{\"1\":{\"909\":1}}],[\"paths\",{\"1\":{\"110\":1,\"323\":1}}],[\"patch\",{\"1\":{\"876\":1}}],[\"pattern>\",{\"1\":{\"871\":8}}],[\"pattern\",{\"1\":{\"246\":1}}],[\"pool\",{\"1\":{\"669\":1}}],[\"pooleddatasource\",{\"1\":{\"721\":2}}],[\"pooled\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"poor\",{\"1\":{\"384\":1}}],[\"pojos\",{\"1\":{\"633\":1}}],[\"poicy\",{\"0\":{\"499\":1}}],[\"point\",{\"1\":{\"432\":1}}],[\"post\",{\"1\":{\"876\":2,\"886\":2,\"892\":1}}],[\"postgresql\",{\"1\":{\"679\":1}}],[\"positive\",{\"1\":{\"460\":1,\"471\":1}}],[\"possible\",{\"1\":{\"415\":1}}],[\"policies\",{\"1\":{\"459\":1,\"461\":2}}],[\"policy版本\",{\"1\":{\"514\":1}}],[\"policyevaluation\",{\"1\":{\"451\":1}}],[\"policy\",{\"0\":{\"403\":1,\"405\":1,\"427\":1,\"439\":1,\"443\":1,\"444\":1,\"445\":1,\"446\":1,\"456\":1,\"460\":1,\"461\":1,\"462\":1,\"495\":2,\"496\":1,\"497\":1,\"500\":1,\"521\":1},\"1\":{\"393\":2,\"394\":1,\"397\":2,\"419\":1,\"421\":1,\"426\":1,\"427\":2,\"437\":3,\"440\":2,\"442\":1,\"443\":1,\"444\":11,\"445\":2,\"450\":1,\"451\":1,\"453\":4,\"456\":3,\"460\":2,\"461\":2,\"462\":1,\"485\":1,\"489\":1,\"494\":1,\"495\":2,\"496\":2,\"497\":4,\"498\":3,\"499\":2,\"518\":1,\"521\":2,\"522\":1}}],[\"polllast\",{\"1\":{\"44\":1}}],[\"pollfirst\",{\"1\":{\"44\":1}}],[\"poll\",{\"1\":{\"43\":3,\"46\":6,\"174\":1}}],[\"pom\",{\"1\":{\"323\":1,\"817\":1,\"819\":2,\"840\":2,\"849\":2,\"888\":1}}],[\"power\",{\"1\":{\"383\":1}}],[\"pow\",{\"1\":{\"274\":1}}],[\"pop\",{\"1\":{\"44\":3}}],[\"pu\",{\"1\":{\"444\":1}}],[\"puttreeval\",{\"1\":{\"59\":1}}],[\"putval\",{\"1\":{\"59\":2}}],[\"putifabsent\",{\"1\":{\"57\":2}}],[\"putall\",{\"1\":{\"56\":1}}],[\"put\",{\"0\":{\"59\":1},\"1\":{\"56\":1,\"57\":5,\"59\":1,\"64\":4,\"66\":3,\"84\":1,\"174\":1,\"318\":2,\"606\":2,\"876\":2}}],[\"push\",{\"1\":{\"44\":3}}],[\"public<\",{\"1\":{\"827\":1}}],[\"public\",{\"1\":{\"4\":4,\"5\":2,\"9\":4,\"14\":8,\"15\":6,\"16\":5,\"23\":3,\"24\":1,\"25\":15,\"30\":2,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"36\":5,\"37\":1,\"42\":1,\"43\":2,\"44\":2,\"45\":1,\"46\":2,\"47\":1,\"48\":3,\"49\":1,\"50\":2,\"56\":1,\"57\":4,\"58\":2,\"59\":1,\"64\":1,\"65\":5,\"66\":3,\"67\":5,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":9,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":2,\"120\":5,\"121\":6,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":2,\"132\":1,\"133\":2,\"138\":1,\"139\":3,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":6,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":6,\"166\":2,\"167\":5,\"172\":2,\"173\":2,\"174\":2,\"182\":1,\"183\":2,\"184\":1,\"186\":11,\"191\":7,\"192\":8,\"193\":3,\"198\":5,\"199\":5,\"206\":4,\"207\":9,\"208\":3,\"215\":10,\"216\":3,\"218\":8,\"219\":9,\"220\":6,\"221\":13,\"227\":5,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":5,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":15,\"252\":5,\"253\":5,\"254\":9,\"255\":12,\"256\":2,\"257\":3,\"258\":8,\"265\":4,\"266\":1,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":3,\"281\":9,\"282\":7,\"288\":2,\"289\":1,\"290\":5,\"291\":2,\"292\":4,\"294\":4,\"295\":2,\"296\":3,\"297\":4,\"304\":2,\"305\":2,\"307\":5,\"310\":2,\"311\":2,\"317\":3,\"318\":3,\"319\":1,\"320\":1,\"321\":2,\"322\":2,\"323\":11,\"328\":2,\"330\":1,\"331\":3,\"333\":4,\"338\":2,\"339\":1,\"342\":6,\"343\":1,\"344\":5,\"346\":2,\"347\":6,\"352\":1,\"355\":3,\"359\":1,\"361\":2,\"362\":2,\"364\":2,\"365\":2,\"366\":12,\"367\":5,\"368\":8,\"536\":3,\"537\":4,\"543\":4,\"544\":3,\"606\":2,\"613\":2,\"615\":1,\"616\":3,\"622\":1,\"623\":4,\"627\":9,\"641\":2,\"643\":3,\"647\":3,\"652\":1,\"653\":1,\"658\":6,\"659\":1,\"666\":2,\"670\":2,\"672\":2,\"678\":1,\"712\":1,\"713\":1,\"715\":1,\"717\":2,\"719\":2,\"720\":1,\"725\":2,\"727\":9,\"729\":2,\"754\":1,\"761\":3,\"765\":1,\"767\":4,\"773\":2,\"776\":6,\"777\":1,\"778\":1,\"780\":1,\"786\":1,\"791\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":2,\"797\":2,\"802\":3,\"803\":5,\"804\":3,\"805\":6,\"807\":1,\"808\":1,\"809\":2,\"810\":2,\"811\":1,\"812\":2,\"825\":3,\"834\":6,\"840\":3,\"849\":2,\"852\":2,\"871\":6,\"874\":1,\"876\":2,\"881\":2,\"886\":1,\"888\":3,\"889\":2,\"891\":1,\"892\":1,\"893\":1,\"919\":2,\"920\":4,\"921\":4,\"922\":2}}],[\"pe\",{\"1\":{\"440\":2,\"442\":1,\"444\":1,\"451\":1}}],[\"per\",{\"1\":{\"803\":1}}],[\"persistenceexception\",{\"1\":{\"658\":1}}],[\"person\",{\"1\":{\"4\":8,\"5\":3,\"9\":8,\"117\":3,\"120\":1,\"121\":2,\"216\":10,\"218\":3,\"219\":1,\"220\":1,\"241\":5,\"368\":1}}],[\"permission\",{\"1\":{\"606\":1}}],[\"permits后面跟上允许继承的类型\",{\"1\":{\"346\":1}}],[\"permits\",{\"1\":{\"346\":1,\"347\":2}}],[\"periods\",{\"1\":{\"384\":1}}],[\"perform\",{\"1\":{\"352\":1,\"804\":1}}],[\"performed\",{\"1\":{\"352\":1}}],[\"performing\",{\"1\":{\"352\":2}}],[\"performs\",{\"1\":{\"352\":3}}],[\"people\",{\"1\":{\"131\":9,\"132\":2,\"133\":9}}],[\"penguin\",{\"1\":{\"110\":1,\"127\":1,\"131\":1,\"162\":1,\"191\":1,\"192\":4,\"219\":1,\"254\":1,\"255\":4,\"307\":1,\"544\":1}}],[\"peeklast\",{\"1\":{\"44\":1}}],[\"peekfirst\",{\"1\":{\"44\":1}}],[\"peek\",{\"1\":{\"43\":1}}],[\"protocol\",{\"1\":{\"876\":2}}],[\"protection\",{\"1\":{\"864\":1}}],[\"protected\",{\"1\":{\"121\":2,\"215\":2,\"218\":7,\"255\":1,\"264\":1,\"266\":1,\"864\":1,\"876\":3,\"881\":1,\"886\":1,\"889\":1,\"891\":1,\"892\":1,\"893\":1,\"900\":1,\"910\":1,\"921\":2}}],[\"proxy\",{\"1\":{\"864\":1}}],[\"proxy2\",{\"1\":{\"659\":1}}],[\"program\",{\"1\":{\"864\":1}}],[\"provided\",{\"1\":{\"833\":1}}],[\"provides\",{\"1\":{\"310\":1}}],[\"project>\",{\"1\":{\"819\":1,\"840\":1,\"849\":1}}],[\"project\",{\"1\":{\"819\":1}}],[\"projectlombok<\",{\"1\":{\"825\":1,\"850\":2}}],[\"projectlombok\",{\"1\":{\"628\":1}}],[\"problems\",{\"1\":{\"466\":1}}],[\"probability\",{\"1\":{\"393\":1,\"394\":4,\"460\":1,\"472\":1,\"507\":1}}],[\"prop\",{\"1\":{\"658\":2}}],[\"prop是要设置的值的字段信息\",{\"1\":{\"658\":1}}],[\"properties中一般都是一些变量和选项的配置\",{\"1\":{\"820\":1}}],[\"properties>\",{\"1\":{\"819\":1,\"849\":1}}],[\"properties默认的日志级别\",{\"1\":{\"768\":1}}],[\"properties文件\",{\"1\":{\"755\":1,\"864\":1}}],[\"properties格式的文件是java的一种配置文件\",{\"1\":{\"753\":1}}],[\"properties\",{\"1\":{\"606\":3,\"754\":8,\"755\":8,\"756\":1}}],[\"propertytokenizer\",{\"1\":{\"658\":1}}],[\"property=\",{\"1\":{\"652\":2,\"667\":8,\"668\":4,\"670\":6,\"671\":4,\"672\":10,\"715\":2}}],[\"property\",{\"1\":{\"394\":1,\"652\":1,\"715\":2,\"718\":2}}],[\"proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件\",{\"1\":{\"383\":1}}],[\"proposition1\",{\"1\":{\"383\":1}}],[\"proposed\",{\"1\":{\"378\":1}}],[\"process\",{\"0\":{\"394\":1},\"1\":{\"394\":1,\"509\":1}}],[\"prompt\",{\"1\":{\"374\":1}}],[\"profession\",{\"1\":{\"218\":4}}],[\"produces\",{\"1\":{\"167\":1}}],[\"preparing\",{\"1\":{\"669\":2}}],[\"preparestatement\",{\"1\":{\"607\":1,\"622\":1}}],[\"preparedstatement\",{\"1\":{\"607\":1,\"622\":1}}],[\"prefix\",{\"1\":{\"333\":3}}],[\"present\",{\"1\":{\"67\":1}}],[\"previousindex\",{\"1\":{\"37\":1}}],[\"previous\",{\"1\":{\"37\":1}}],[\"prev\",{\"1\":{\"25\":4}}],[\"predicate<\",{\"1\":{\"23\":1}}],[\"primary\",{\"1\":{\"564\":2,\"565\":3}}],[\"primitive\",{\"1\":{\"183\":2}}],[\"priority\",{\"1\":{\"145\":4}}],[\"priorityqueue<>\",{\"1\":{\"45\":1,\"46\":2}}],[\"printwriter\",{\"1\":{\"606\":1,\"613\":1}}],[\"printer\",{\"1\":{\"353\":2}}],[\"print\",{\"1\":{\"237\":2,\"274\":1,\"323\":1,\"341\":1,\"537\":1,\"544\":1}}],[\"printstream也永远不会抛出异常\",{\"1\":{\"127\":1}}],[\"printstream也继承自filteroutputstream类\",{\"1\":{\"127\":1}}],[\"printstream\",{\"1\":{\"127\":3}}],[\"printstacktrace\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"172\":2,\"174\":1,\"199\":2,\"267\":1,\"536\":3,\"537\":1,\"543\":1,\"544\":2,\"605\":1,\"615\":1,\"616\":1,\"621\":1,\"622\":1,\"623\":4,\"636\":1,\"647\":1}}],[\"println也是接受一个string参数\",{\"1\":{\"297\":1}}],[\"println\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":1,\"275\":1,\"281\":1,\"288\":1,\"289\":1,\"292\":2,\"294\":2,\"295\":1,\"297\":6,\"304\":1,\"305\":1,\"307\":1,\"317\":3,\"318\":2,\"319\":1,\"320\":2,\"321\":2,\"322\":2,\"323\":6,\"328\":1,\"331\":6,\"333\":3,\"340\":1,\"343\":1,\"344\":1,\"347\":1,\"353\":1,\"354\":2,\"355\":3,\"358\":1,\"361\":1,\"362\":1,\"364\":4,\"365\":5,\"374\":2,\"536\":6,\"537\":8,\"543\":1,\"544\":5,\"605\":1,\"606\":7,\"613\":1,\"616\":1,\"621\":1,\"622\":2,\"636\":1,\"643\":1,\"647\":1,\"649\":1,\"650\":1,\"651\":1,\"653\":3,\"658\":1,\"659\":2,\"660\":1,\"682\":2,\"700\":6,\"701\":2,\"705\":1,\"714\":1,\"735\":1,\"744\":2,\"747\":3,\"754\":1,\"755\":2,\"761\":3,\"767\":2,\"773\":4,\"790\":1,\"793\":2,\"794\":2,\"795\":1,\"796\":2,\"797\":1,\"802\":3,\"803\":3,\"804\":3,\"805\":5,\"810\":2,\"811\":1,\"812\":2,\"825\":1,\"834\":2,\"840\":1,\"852\":1,\"874\":4,\"886\":1,\"889\":1,\"900\":1,\"901\":1,\"902\":1,\"903\":1,\"908\":1,\"919\":1,\"920\":5,\"922\":1}}],[\"private\",{\"1\":{\"14\":2,\"15\":3,\"25\":5,\"65\":3,\"67\":2,\"121\":2,\"132\":1,\"133\":1,\"154\":1,\"155\":7,\"167\":3,\"174\":3,\"215\":1,\"216\":1,\"218\":2,\"221\":2,\"251\":2,\"252\":1,\"253\":1,\"257\":1,\"266\":2,\"267\":2,\"305\":1,\"317\":1,\"342\":2,\"366\":3,\"367\":4,\"368\":6,\"606\":1,\"616\":1,\"627\":6,\"647\":1,\"658\":1,\"721\":1,\"773\":3,\"834\":1,\"921\":1}}],[\"p2\",{\"1\":{\"4\":1,\"216\":3}}],[\"p1\",{\"1\":{\"4\":2,\"216\":3}}],[\"p\",{\"1\":{\"4\":4,\"5\":4,\"59\":10,\"393\":1,\"394\":3,\"415\":2,\"418\":1,\"419\":2,\"437\":2,\"449\":1,\"451\":4,\"472\":1,\"590\":1}}],[\"是基于\",{\"1\":{\"911\":1}}],[\"是基于一个给定策略\",{\"1\":{\"414\":1}}],[\"是的话进行转化\",{\"1\":{\"876\":1}}],[\"是这样描述万维网的\",{\"1\":{\"859\":1}}],[\"是hashmap的同步加锁版\",{\"1\":{\"754\":1}}],[\"是通过添加注解来实现的\",{\"1\":{\"628\":1}}],[\"是通过一个容器来解决生产者和消费者的强耦合问题\",{\"1\":{\"174\":1}}],[\"是从1开始的\",{\"1\":{\"616\":1}}],[\"是数据库控制语言\",{\"1\":{\"561\":1}}],[\"是用来设置或更改数据库用户或角色权限的语句\",{\"1\":{\"561\":1}}],[\"是用来与环境进行交互\",{\"1\":{\"495\":1}}],[\"是用于描述数据库中要存储的现实世界实体的语言\",{\"1\":{\"561\":1}}],[\"是开发以数据为中心的应用程序必定会使用到的指令\",{\"1\":{\"561\":1}}],[\"是sql语言中\",{\"1\":{\"561\":1}}],[\"是string类型的\",{\"1\":{\"280\":1}}],[\"是由tomcat帮助我们生成的一个默认响应头\",{\"1\":{\"875\":1}}],[\"是由\",{\"1\":{\"872\":1}}],[\"是由一批数据构成的有序集合\",{\"1\":{\"549\":1}}],[\"是由环境决定的\",{\"1\":{\"419\":1}}],[\"是获取对应流的内容\",{\"1\":{\"537\":1}}],[\"是把东西先到对应的流里\",{\"1\":{\"537\":1}}],[\"是操作系统底层提供的一项通信技术\",{\"1\":{\"535\":1}}],[\"是未知的\",{\"1\":{\"530\":1}}],[\"是各个\",{\"1\":{\"524\":1}}],[\"是我们需要进行优化的\",{\"1\":{\"522\":1}}],[\"是我们不断进行更新的策略\",{\"1\":{\"495\":1}}],[\"是直接建立一个基于策略的目标函数来进行梯度上升的优化\",{\"1\":{\"521\":1}}],[\"是直接继承自hashmap\",{\"1\":{\"61\":1}}],[\"是qπ​\",{\"1\":{\"490\":1}}],[\"是关于\",{\"1\":{\"486\":1}}],[\"是常数\",{\"1\":{\"484\":1}}],[\"是需要被优化的参数\",{\"1\":{\"475\":1}}],[\"是第\",{\"1\":{\"471\":2}}],[\"是针对\",{\"1\":{\"454\":1}}],[\"是针对一条trajectory所求的\",{\"1\":{\"415\":1}}],[\"是优于\",{\"1\":{\"442\":1}}],[\"是已知的\",{\"1\":{\"437\":1}}],[\"是依赖于策略π的\",{\"1\":{\"422\":1}}],[\"是最优的\",{\"1\":{\"458\":1}}],[\"是最大报文长度\",{\"1\":{\"384\":1}}],[\"是最顶层的类\",{\"1\":{\"215\":1}}],[\"是网页大小\",{\"1\":{\"384\":1}}],[\"是与传输速率有关的延迟时间\",{\"1\":{\"384\":1}}],[\"是\",{\"1\":{\"356\":1,\"414\":1,\"423\":1,\"460\":1,\"487\":1,\"497\":2,\"498\":1,\"524\":1,\"689\":1,\"817\":1,\"870\":1}}],[\"是个容器\",{\"1\":{\"355\":1}}],[\"是final类型且继承自java\",{\"1\":{\"344\":1}}],[\"是继java\",{\"1\":{\"329\":1}}],[\"是继承\",{\"1\":{\"264\":1}}],[\"是没办法直接进行反射操作的\",{\"1\":{\"309\":1}}],[\"是某个异常的父类\",{\"1\":{\"267\":1}}],[\"是某一类事物实际存在的每个个体\",{\"1\":{\"4\":1}}],[\"是无法访问到外部类的非静态内容的\",{\"1\":{\"252\":1}}],[\"是属于类的\",{\"1\":{\"252\":1}}],[\"是可以直接拿过来用的\",{\"1\":{\"291\":1}}],[\"是可以访问到外层的变量的\",{\"1\":{\"251\":1}}],[\"是可以的\",{\"1\":{\"238\":1}}],[\"是对现实世界数据特征的一种抽象\",{\"1\":{\"550\":1}}],[\"是对象所有的\",{\"1\":{\"251\":1}}],[\"是对一类事物的描述\",{\"1\":{\"4\":1}}],[\"是匹配所有空白符\",{\"1\":{\"246\":1}}],[\"是在基于\",{\"1\":{\"397\":1}}],[\"是在\",{\"1\":{\"274\":1,\"275\":1}}],[\"是在一开始就确定的\",{\"1\":{\"236\":1}}],[\"是在队尾进行插入\",{\"1\":{\"43\":1}}],[\"是只在代码中\",{\"1\":{\"205\":1}}],[\"是因为suspend\",{\"1\":{\"156\":1}}],[\"是因为集合类的实现方案有很多\",{\"1\":{\"31\":1}}],[\"是class类实例\",{\"1\":{\"155\":1}}],[\"是否所有的请求都会经过此过滤器\",{\"1\":{\"919\":1}}],[\"是否开启自动提交\",{\"1\":{\"647\":1}}],[\"是否要满足子查询中的条件表达式\",{\"1\":{\"596\":1}}],[\"是否在集合中\",{\"1\":{\"580\":1}}],[\"是否成立\",{\"1\":{\"478\":1}}],[\"是否是收敛的\",{\"0\":{\"446\":1}}],[\"是否简洁\",{\"1\":{\"371\":1}}],[\"是否允许包含\",{\"1\":{\"371\":1}}],[\"是否支持增删元素\",{\"1\":{\"371\":1}}],[\"是否可变\",{\"1\":{\"371\":1}}],[\"是否可执行\",{\"1\":{\"98\":1}}],[\"是否可写\",{\"1\":{\"98\":1}}],[\"是否可读\",{\"1\":{\"98\":1}}],[\"是否为密封\",{\"1\":{\"347\":1}}],[\"是否为一个文件夹\",{\"1\":{\"98\":1}}],[\"是否为空\",{\"1\":{\"56\":1}}],[\"是根据q\",{\"1\":{\"387\":1}}],[\"是根据\",{\"1\":{\"84\":1}}],[\"是不同的\",{\"1\":{\"414\":1,\"497\":1}}],[\"是不是感觉这种类型就是专门为这种实体类而生的\",{\"1\":{\"344\":1}}],[\"是不是感觉这个工具类好像还挺好用的\",{\"1\":{\"80\":1}}],[\"是不是感觉非常方便\",{\"1\":{\"318\":1}}],[\"是不是感觉非常简洁\",{\"1\":{\"257\":1}}],[\"是不是感觉比之前的写法更优雅\",{\"1\":{\"297\":1}}],[\"是不是有点太浪费了\",{\"1\":{\"245\":1}}],[\"是不能\",{\"1\":{\"238\":1}}],[\"是不支持自动装箱和拆箱的\",{\"1\":{\"238\":1}}],[\"是不允许的\",{\"1\":{\"8\":1}}],[\"是以键值对的形式存在\",{\"1\":{\"55\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"633\":1}}],[\"是一种插件化注解api\",{\"1\":{\"628\":1}}],[\"是一种自动唤醒机制\",{\"1\":{\"161\":1}}],[\"是一致的\",{\"1\":{\"415\":1,\"496\":1}}],[\"是一个项目管理工具\",{\"1\":{\"817\":1}}],[\"是一个期望值\",{\"1\":{\"475\":1}}],[\"是一个随机变量\",{\"1\":{\"475\":1}}],[\"是一个黑盒\",{\"1\":{\"471\":1}}],[\"是一个必要条件\",{\"1\":{\"458\":1}}],[\"是一个contraction\",{\"1\":{\"432\":1}}],[\"是一个有关状态s的函数\",{\"1\":{\"414\":1}}],[\"是一个有序的集合\",{\"1\":{\"24\":1}}],[\"是一个收集器的工具类\",{\"1\":{\"365\":1}}],[\"是一个\",{\"1\":{\"365\":1,\"471\":1}}],[\"是一个非负整数\",{\"1\":{\"246\":2}}],[\"是一个新创建的线程\",{\"1\":{\"167\":1}}],[\"是一样的\",{\"1\":{\"62\":1}}],[\"是一起删除还是只删除一个呢\",{\"1\":{\"25\":1}}],[\"是为了方便日后如果我们想要更换不同的集合类实现\",{\"1\":{\"25\":1}}],[\"是为了完成某件事情而存在的\",{\"1\":{\"5\":1}}],[\"是集合类型的一个分支\",{\"1\":{\"24\":1}}],[\"是类的一个具体化个体\",{\"1\":{\"4\":1}}],[\"是抽象的\",{\"1\":{\"4\":1}}],[\"类提供了三个方法可供进行元素匹配\",{\"1\":{\"363\":1}}],[\"类是一个可以为null的容器对象\",{\"1\":{\"355\":1}}],[\"类使用\",{\"0\":{\"333\":1}}],[\"类进行存储成绩\",{\"1\":{\"280\":1}}],[\"类呢\",{\"1\":{\"280\":1}}],[\"类的\",{\"1\":{\"362\":1}}],[\"类的引入很好的解决空指针异常\",{\"1\":{\"355\":1}}],[\"类的构造方法默认返回自身对象\",{\"1\":{\"296\":1}}],[\"类的构造方法\",{\"1\":{\"296\":1}}],[\"类的子类\",{\"1\":{\"281\":1}}],[\"类的异常都是编译时异常\",{\"1\":{\"264\":1}}],[\"类的内部类它会单独生成一个\",{\"1\":{\"254\":1}}],[\"类的创建\",{\"1\":{\"4\":1}}],[\"类只能继承一个\",{\"1\":{\"219\":1}}],[\"类可以实现这个接口\",{\"1\":{\"219\":1}}],[\"类加载器就是用于加载一个类的\",{\"1\":{\"198\":1}}],[\"类加载器\",{\"0\":{\"198\":1}}],[\"类加载机制\",{\"0\":{\"180\":1}}],[\"类名称\",{\"1\":{\"765\":1}}],[\"类名\",{\"1\":{\"258\":3,\"291\":1,\"347\":1,\"738\":1}}],[\"类名上\",{\"1\":{\"203\":1}}],[\"类名必须和我们定义的保持一致\",{\"1\":{\"199\":1}}],[\"类名获取\",{\"1\":{\"182\":1}}],[\"类名的首字母通常是大写的\",{\"1\":{\"4\":1}}],[\"类还有三个方法我们从来没有使用过\",{\"1\":{\"161\":1}}],[\"类锁\",{\"1\":{\"155\":1}}],[\"类锁只有一个\",{\"1\":{\"155\":1}}],[\"类就是专用于集合的工具类\",{\"1\":{\"75\":1}}],[\"类似\",{\"1\":{\"71\":1,\"255\":1,\"599\":1}}],[\"类似于递归的结构\",{\"1\":{\"920\":1}}],[\"类似于下面图中的日志格式\",{\"1\":{\"765\":1}}],[\"类似于一个插件\",{\"1\":{\"219\":1}}],[\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制\",{\"1\":{\"154\":1}}],[\"类似于c++中的namespace\",{\"1\":{\"120\":1}}],[\"类似于c++指针的情况\",{\"1\":{\"4\":1}}],[\"类似于vip用户可以优先结束排队\",{\"1\":{\"46\":1}}],[\"类型名称\",{\"1\":{\"648\":1}}],[\"类型的参数\",{\"1\":{\"362\":1}}],[\"类型的变量\",{\"1\":{\"281\":1}}],[\"类型的\",{\"1\":{\"241\":1}}],[\"类型的成绩了\",{\"1\":{\"15\":1}}],[\"类型为\",{\"1\":{\"186\":1}}],[\"类型比较\",{\"0\":{\"186\":1}}],[\"类型作为存储\",{\"1\":{\"96\":1}}],[\"类型擦除\",{\"0\":{\"16\":1}}],[\"类型\",{\"1\":{\"14\":2,\"235\":8,\"280\":1,\"281\":1,\"331\":1,\"371\":1}}],[\"类型变量并不是只能在泛型类中才可以使用\",{\"1\":{\"14\":1}}],[\"类除了具有属性外\",{\"1\":{\"5\":1}}],[\"类\",{\"0\":{\"98\":1,\"181\":1,\"215\":1,\"244\":1,\"245\":1,\"252\":1},\"1\":{\"4\":1,\"23\":1,\"84\":1,\"155\":1,\"208\":1,\"217\":1,\"249\":1,\"264\":1,\"274\":1,\"294\":1,\"296\":1,\"367\":1}}],[\"类与对象4\",{\"0\":{\"224\":1}}],[\"类与对象3\",{\"0\":{\"211\":1}}],[\"类与对象2\",{\"0\":{\"116\":1}}],[\"类与对象\",{\"0\":{\"4\":1}}],[\"类与对象1\",{\"0\":{\"3\":1}}],[\"dmaven\",{\"1\":{\"853\":1}}],[\"dml\",{\"0\":{\"570\":1,\"677\":1},\"1\":{\"561\":1}}],[\"dd\",{\"1\":{\"765\":1}}],[\"ddl\",{\"0\":{\"562\":1}}],[\"dtd\",{\"1\":{\"641\":3,\"643\":3,\"834\":3,\"888\":3}}],[\"df\",{\"1\":{\"565\":1}}],[\"db\",{\"1\":{\"561\":1}}],[\"dbcreator\",{\"1\":{\"561\":1}}],[\"dcl\",{\"0\":{\"588\":1},\"1\":{\"561\":1}}],[\"dql\",{\"0\":{\"578\":1},\"1\":{\"561\":1}}],[\"dqn\",{\"0\":{\"515\":1},\"1\":{\"516\":1,\"518\":1}}],[\"d0​\",{\"1\":{\"526\":1}}],[\"dπ​\",{\"1\":{\"509\":2,\"526\":1}}],[\"dpg\",{\"0\":{\"407\":1}}],[\"dkn​​\",{\"1\":{\"383\":1}}],[\"dkn​​=hn2​\",{\"1\":{\"382\":1}}],[\"dkn​\",{\"1\":{\"383\":1}}],[\"dynamic\",{\"1\":{\"378\":1,\"419\":1}}],[\"driver=com\",{\"1\":{\"753\":1}}],[\"driverinfo\",{\"1\":{\"606\":2}}],[\"driveraction\",{\"1\":{\"606\":1}}],[\"driver\",{\"1\":{\"605\":6,\"606\":14,\"641\":2,\"721\":1,\"753\":1,\"834\":2,\"888\":2}}],[\"drivermanager是管理我们的数据库驱动的\",{\"1\":{\"606\":1}}],[\"drivermanager\",{\"0\":{\"606\":1},\"1\":{\"605\":1,\"606\":4,\"613\":1,\"615\":1,\"621\":1,\"622\":1,\"623\":4}}],[\"driven\",{\"1\":{\"378\":1}}],[\"drop\",{\"1\":{\"566\":1,\"568\":1,\"569\":1,\"596\":1,\"597\":1,\"598\":1}}],[\"dropwhile\",{\"1\":{\"322\":1}}],[\"div>\",{\"1\":{\"886\":3,\"892\":2,\"893\":1,\"910\":1}}],[\"divide\",{\"1\":{\"229\":1}}],[\"difference\",{\"0\":{\"483\":1}}],[\"displaynamegeneration注解来配置使用\",{\"1\":{\"779\":1}}],[\"displayname\",{\"1\":{\"778\":1,\"804\":1,\"834\":1}}],[\"displayname注解来为其命名\",{\"1\":{\"778\":1}}],[\"disabledif用于\",{\"1\":{\"797\":1}}],[\"disabledif在类上使用时\",{\"1\":{\"797\":1}}],[\"disabledonjre\",{\"1\":{\"794\":1}}],[\"disabledonos\",{\"1\":{\"793\":1}}],[\"disabled\",{\"1\":{\"777\":1}}],[\"disable来关闭某一个测试用例\",{\"1\":{\"777\":1}}],[\"distributon\",{\"0\":{\"508\":1},\"1\":{\"509\":3}}],[\"distributed\",{\"1\":{\"449\":1}}],[\"distribution\",{\"0\":{\"509\":1},\"1\":{\"394\":1,\"507\":1,\"509\":1,\"526\":1}}],[\"distinct表示去重再统计\",{\"1\":{\"582\":1}}],[\"distinct\",{\"1\":{\"47\":1,\"71\":3,\"112\":1,\"319\":1,\"358\":1,\"579\":1,\"582\":7}}],[\"discounted\",{\"1\":{\"393\":1,\"416\":1,\"487\":1,\"511\":1}}],[\"dofilter\",{\"1\":{\"919\":1,\"920\":8,\"921\":6}}],[\"domain属性\",{\"1\":{\"909\":1}}],[\"domain\",{\"1\":{\"909\":1}}],[\"dotrace\",{\"1\":{\"876\":1}}],[\"dooptions\",{\"1\":{\"876\":1}}],[\"dodelete\",{\"1\":{\"876\":1}}],[\"dopatch\",{\"1\":{\"876\":1}}],[\"doput\",{\"1\":{\"876\":1}}],[\"dopost\",{\"1\":{\"876\":1,\"886\":1,\"889\":2,\"892\":1,\"900\":1}}],[\"dohead\",{\"1\":{\"876\":1}}],[\"dormant\",{\"1\":{\"690\":1}}],[\"docs\",{\"1\":{\"812\":1,\"864\":1}}],[\"doctype\",{\"1\":{\"641\":1,\"643\":1,\"834\":1,\"888\":1}}],[\"documentbuilder\",{\"1\":{\"636\":1}}],[\"documentbuilderfactory\",{\"1\":{\"636\":2}}],[\"document\",{\"1\":{\"544\":1,\"636\":1,\"893\":1,\"908\":1,\"913\":1}}],[\"documented\",{\"1\":{\"205\":1}}],[\"doget\",{\"1\":{\"876\":5,\"881\":1,\"891\":1,\"893\":1,\"900\":1,\"910\":1}}],[\"dog\",{\"1\":{\"613\":1}}],[\"download=\",{\"1\":{\"891\":1}}],[\"download\",{\"1\":{\"628\":1,\"864\":1}}],[\"down\",{\"1\":{\"382\":1}}],[\"doxy\",{\"1\":{\"246\":1}}],[\"does\",{\"1\":{\"246\":1,\"606\":1}}],[\"do\",{\"1\":{\"246\":3}}],[\"double用于存储双精度的小数\",{\"1\":{\"563\":1}}],[\"double\",{\"1\":{\"8\":3,\"227\":2,\"808\":1}}],[\"dao\",{\"1\":{\"888\":1}}],[\"da\",{\"1\":{\"606\":2}}],[\"dateformat\",{\"1\":{\"765\":2,\"893\":2}}],[\"datetime用于混合存储日期+时间\",{\"1\":{\"563\":1}}],[\"date存储日期\",{\"1\":{\"563\":1}}],[\"date\",{\"1\":{\"174\":2,\"666\":1,\"765\":4,\"893\":3,\"908\":1,\"913\":1}}],[\"datasource\",{\"1\":{\"721\":2,\"753\":4}}],[\"datasource>\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"data注解\",{\"1\":{\"700\":1}}],[\"data类似\",{\"1\":{\"629\":1}}],[\"data就不建议此类有继承关系\",{\"1\":{\"629\":1}}],[\"data能代表\",{\"1\":{\"629\":1}}],[\"databases\",{\"1\":{\"590\":1}}],[\"database来删除一个数据库\",{\"1\":{\"566\":1}}],[\"database来创建一个数据库\",{\"1\":{\"566\":1}}],[\"database\",{\"1\":{\"566\":3,\"658\":1}}],[\"data=\",{\"1\":{\"366\":1}}],[\"data\",{\"1\":{\"167\":1,\"333\":4,\"344\":1,\"366\":9,\"367\":3,\"455\":1,\"543\":1,\"561\":4,\"604\":1,\"643\":2,\"652\":1,\"666\":2,\"670\":2,\"672\":2,\"825\":1,\"888\":1,\"892\":2}}],[\"dataoutputstream\",{\"1\":{\"129\":4}}],[\"datainputstream\",{\"1\":{\"129\":4}}],[\"daily\",{\"0\":{\"930\":1},\"2\":{\"1\":1}}],[\"daily1\",{\"0\":{\"0\":1}}],[\"d\",{\"0\":{\"526\":1},\"1\":{\"71\":1,\"216\":1,\"218\":1,\"331\":1,\"384\":3,\"449\":1,\"524\":2,\"526\":5,\"623\":1,\"636\":2}}],[\"detail表的查询操作\",{\"1\":{\"669\":1}}],[\"detail表的对应信息\",{\"1\":{\"668\":1}}],[\"detail=userdetail\",{\"1\":{\"669\":1}}],[\"detail\",{\"1\":{\"666\":1,\"667\":3,\"668\":2,\"669\":1,\"718\":2}}],[\"deterministic\",{\"0\":{\"407\":1,\"479\":1},\"1\":{\"388\":1,\"393\":1,\"427\":2}}],[\"development\",{\"1\":{\"641\":2,\"721\":1,\"834\":2,\"888\":2}}],[\"deny\",{\"1\":{\"561\":1}}],[\"deep\",{\"0\":{\"515\":1},\"1\":{\"515\":1}}],[\"deeptostring\",{\"1\":{\"275\":1}}],[\"decimal\",{\"1\":{\"565\":1}}],[\"decision\",{\"0\":{\"394\":1}}],[\"decode\",{\"1\":{\"228\":1}}],[\"demonstrating\",{\"1\":{\"378\":1}}],[\"destroy\",{\"1\":{\"871\":1,\"872\":1}}],[\"dest\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"desc=description\",{\"1\":{\"753\":1}}],[\"descriptorrefs>\",{\"1\":{\"854\":1}}],[\"descriptorref>\",{\"1\":{\"854\":1}}],[\"description=我是一个阳光开朗大男孩\",{\"1\":{\"669\":1}}],[\"description\",{\"1\":{\"666\":1,\"667\":2,\"669\":1}}],[\"describes\",{\"1\":{\"509\":1}}],[\"desc>\",{\"1\":{\"634\":1}}],[\"descent\",{\"0\":{\"474\":1},\"1\":{\"475\":2}}],[\"descendingiterator\",{\"1\":{\"44\":1}}],[\"design\",{\"0\":{\"377\":1}}],[\"dependencies<\",{\"1\":{\"854\":1}}],[\"dependencies>\",{\"1\":{\"825\":1,\"841\":1,\"850\":3}}],[\"dependencymanagement>\",{\"1\":{\"850\":1}}],[\"dependency>\",{\"1\":{\"825\":1,\"834\":3,\"835\":1,\"840\":1,\"841\":1,\"842\":3,\"843\":1,\"850\":6,\"888\":2,\"891\":1}}],[\"departmentname\",{\"1\":{\"565\":3}}],[\"departmentid\",{\"1\":{\"565\":2}}],[\"departments\",{\"1\":{\"564\":2,\"565\":2}}],[\"department\",{\"1\":{\"564\":2}}],[\"deployment\",{\"0\":{\"377\":1},\"1\":{\"378\":1}}],[\"deprecated\",{\"1\":{\"204\":1,\"605\":1}}],[\"deleteusers\",{\"1\":{\"693\":2}}],[\"deleteuserbyid\",{\"1\":{\"681\":1,\"682\":3,\"688\":1,\"693\":1}}],[\"delete>\",{\"1\":{\"681\":1,\"693\":1}}],[\"delete等操作时\",{\"1\":{\"598\":1}}],[\"delete时\",{\"1\":{\"598\":1}}],[\"delete三种指令为核心\",{\"1\":{\"561\":1}}],[\"delete\",{\"1\":{\"245\":1,\"561\":1,\"573\":2,\"598\":1,\"613\":1,\"677\":2,\"681\":1,\"693\":3,\"701\":1,\"876\":1}}],[\"definition\",{\"1\":{\"561\":1}}],[\"defineclass\",{\"1\":{\"199\":3}}],[\"deflate\",{\"1\":{\"544\":1,\"908\":1,\"913\":1}}],[\"defaultformatter\",{\"1\":{\"756\":2}}],[\"defaultlevel\",{\"1\":{\"756\":2}}],[\"defaultbundle\",{\"1\":{\"727\":7,\"729\":2}}],[\"default=\",{\"1\":{\"641\":1,\"834\":1,\"888\":1}}],[\"default来指定默认值\",{\"1\":{\"629\":1}}],[\"default\",{\"1\":{\"23\":4,\"24\":2,\"25\":1,\"32\":2,\"35\":1,\"36\":2,\"47\":1,\"58\":1,\"60\":4,\"173\":1,\"207\":1,\"219\":2,\"317\":2,\"338\":1,\"339\":1,\"340\":3,\"352\":1,\"564\":2,\"565\":1,\"566\":1,\"871\":1}}],[\"deque<string>\",{\"1\":{\"44\":1,\"45\":1}}],[\"deque<e>\",{\"1\":{\"25\":1,\"42\":1,\"44\":1}}],[\"deque\",{\"0\":{\"42\":1,\"44\":1},\"1\":{\"44\":5,\"45\":1}}],[\"d1\",{\"2\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
