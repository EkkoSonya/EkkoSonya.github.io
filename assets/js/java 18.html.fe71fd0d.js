"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[1847],{3671:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,n]of i)t[e]=n;return t}},3455:(e,i,t)=>{t.r(i),t.d(i,{comp:()=>d,data:()=>r});var n=t(7847);const a=[(0,n.Fv)('<h2 id="io流1" tabindex="-1"><a class="header-anchor" href="#io流1"><span>IO流1</span></a></h2><p>一般在<code>java.io</code>中</p><h3 id="文件字节流" tabindex="-1"><a class="header-anchor" href="#文件字节流"><span>文件字节流</span></a></h3><h4 id="输入流-java-io-fileinputstream" tabindex="-1"><a class="header-anchor" href="#输入流-java-io-fileinputstream"><span>输入流 <code>java.io.FileInputStream</code></span></a></h4><p>我们可以通过它来获取文件的输入流：<br> 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    FileInputStream inputStream = null;    //定义可以先放在try外部\n    try {\n        inputStream = new FileInputStream(&quot;路径&quot;);\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } finally {\n        try {    //建议在finally中进行，因为关闭流是任何情况都必须要执行的！\n            if(inputStream != null) inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n\n    //注意，这种语法只支持实现了AutoCloseable接口的类！\n    try(FileInputStream inputStream = new FileInputStream(&quot;路径&quot;)) {   //直接在try()中定义要在完成之后释放的资源\n\n    } catch (IOException e) {   //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的\n        e.printStackTrace();\n    }\n    //无需再编写finally语句块，因为在最后自动帮我们调用了close()\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种语法<strong>只支持实现了AutoCloseable接口的类</strong></p><h5 id="文件读取" tabindex="-1"><a class="header-anchor" href="#文件读取"><span>文件读取</span></a></h5><ul><li><p><code>read</code> 方法<br> 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    //test.txt：abcd\n    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) {\n        int tmp;\n        while ((tmp = inputStream.read()) != -1){   //通过while循环来一次性读完内容\n            System.out.println((char)tmp);\n        }\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>available</code> 方法<br> 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）<br> 因此与<code>read</code>结合，可以一次直接读取全部数据：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    //test.txt：abcd\n    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) {\n        byte[] bytes = new byte[inputStream.available()];   //我们可以提前准备好合适容量的byte数组来存放\n        System.out.println(inputStream.read(bytes));   //一次性读取全部内容（返回值是读取的字节数）\n        System.out.println(new String(bytes));   //通过String(byte[])构造方法得到字符串\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以控制读取的数量：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>System.out.println(inputStream.read(bytes, 1, 2));   //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>skip</code> 方法 可以跳过指定数量的字节</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    //test.txt：abcd\n    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) {\n        System.out.println(inputStream.skip(1));\n        System.out.println((char) inputStream.read());   //跳过了一个字节\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="输出流-java-io-fileoutputstream" tabindex="-1"><a class="header-anchor" href="#输出流-java-io-fileoutputstream"><span>输出流 <code>java.io.FileOutputStream</code></span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    //输出流也需要在最后调用close()方法，并且同样支持try-with-resource\n    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) {\n        //注意：若此文件不存在，会直接创建这个文件！\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) {\n        outputStream.write(&#39;c&#39;);   //同read一样，可以直接写入内容\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes());   //也可以直接写入byte[]\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes(), 0, 1);  //同上输入流\n      \toutputStream.flush();  //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="追加操作" tabindex="-1"><a class="header-anchor" href="#追加操作"><span>追加操作</span></a></h5><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;, true)) {  //true表示开启追加模式\n        outputStream.write(&quot;lb&quot;.getBytes());   //现在只会进行追加写入，而不是直接替换原文件内容\n        outputStream.flush();\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="文件拷贝操作实现" tabindex="-1"><a class="header-anchor" href="#文件拷贝操作实现"><span>文件拷贝操作实现</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;);\n        FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) {   //可以写入多个\n        byte[] bytes = new byte[10];    //使用长度为10的byte[]做传输媒介\n        int tmp;   //存储本地读取字节数\n        while ((tmp = inputStream.read(bytes)) != -1){   //直到读取完成为止\n            outputStream.write(bytes, 0, tmp);    //写入对应长度的数据到输出流\n        }\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="文件字符流" tabindex="-1"><a class="header-anchor" href="#文件字符流"><span>文件字符流</span></a></h3><p><code>java.io.FileReader</code> &amp; <code>java.io.FileWriter</code></p><h4 id="filereader" tabindex="-1"><a class="header-anchor" href="#filereader"><span><code>FileReader</code></span></a></h4><p>字符流不同于字节，字符流是以<strong>一个具体的字符</strong>进行读取，因此它只适合读<strong>纯文本</strong>的文件，如果是其他类型的文件不适用.</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileReader reader = new FileReader(&quot;test.txt&quot;)){\n      \treader.skip(1);   //现在跳过的是一个字符\n        System.out.println((char) reader.read());   //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同理，字符流只支持<code>char[]</code>类型作为存储：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileReader reader = new FileReader(&quot;test.txt&quot;)){\n        char[] str = new char[10];\n        reader.read(str);\n        System.out.println(str);   //直接读取到char[]中\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="filewriter" tabindex="-1"><a class="header-anchor" href="#filewriter"><span><code>FileWriter</code></span></a></h4><p><code>writer</code>除了<code>write</code>方法外，还有一个<code>append</code>方法，但效果是一致的</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    try(FileWriter writer = new FileWriter(&quot;output.txt&quot;)){\n      \twriter.getEncoding();   //支持获取编码（不同的文本文件可能会有不同的编码类型）\n       writer.write(&#39;牛&#39;);\n       writer.append(&#39;牛&#39;);   //其实功能和write一样\n      \twriter.flush();   //刷新\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="file类" tabindex="-1"><a class="header-anchor" href="#file类"><span><code>File</code>类</span></a></h4><p>专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过<code>File</code>对象，可以更好地管理和操作硬盘上的文件。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(String[] args) {\n    File file = new File(&quot;test.txt&quot;);   //直接创建文件对象，可以是相对路径，也可以是绝对路径\n    System.out.println(file.exists());   //此文件是否存在\n    System.out.println(file.length());   //获取文件的大小\n    System.out.println(file.isDirectory());   //是否为一个文件夹\n    System.out.println(file.canRead());   //是否可读\n    System.out.println(file.canWrite());   //是否可写\n    System.out.println(file.canExecute());   //是否可执行\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>File</code>对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>File file = new File(&quot;/&quot;);\nSystem.out.println(Arrays.toString(file.list()));   //快速获取文件夹下的文件名称列表\nfor (File f : file.listFiles()){   //所有子文件的File对象\n    System.out.println(f.getAbsolutePath());   //获取文件的绝对路径\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>File file = new File(&quot;test.txt&quot;);\ntry (FileInputStream inputStream = new FileInputStream(file)){   //直接做参数\n    System.out.println(inputStream.available());\n}catch (IOException e){\n    e.printStackTrace();\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',36)],l={},d=(0,t(3671).A)(l,[["render",function(e,i){return(0,n.uX)(),(0,n.CE)("div",null,a)}]]),r=JSON.parse('{"path":"/code/java/java%2018.html","title":"Java - IO","lang":"zh-CN","frontmatter":{"title":"Java - IO","date":"2025-01-27T00:00:00.000Z","category":["code"],"tag":["java"],"order":-0.84,"description":"IO流1 一般在java.io中 文件字节流 输入流 java.io.FileInputStream 我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用 不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法： 这种语法只支持实现了AutoClo...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java/java%2018.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Java - IO"}],["meta",{"property":"og:description","content":"IO流1 一般在java.io中 文件字节流 输入流 java.io.FileInputStream 我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用 不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法： 这种语法只支持实现了AutoClo..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-19T15:08:48.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2025-01-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-19T15:08:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java - IO\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-19T15:08:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"IO流1","slug":"io流1","link":"#io流1","children":[{"level":3,"title":"文件字节流","slug":"文件字节流","link":"#文件字节流","children":[]},{"level":3,"title":"文件拷贝操作实现","slug":"文件拷贝操作实现","link":"#文件拷贝操作实现","children":[]},{"level":3,"title":"文件字符流","slug":"文件字符流","link":"#文件字符流","children":[]}]}],"git":{"createdTime":1739977728000,"updatedTime":1739977728000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":5.35,"words":1604},"filePathRelative":"code/java/java 18.md","localizedDate":"2025年1月27日","excerpt":"<h2>IO流1</h2>\\n<p>一般在<code>java.io</code>中</p>\\n<h3>文件字节流</h3>\\n<h4>输入流 <code>java.io.FileInputStream</code></h4>\\n<p>我们可以通过它来获取文件的输入流：<br>\\n在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>public static void main(String[] args) {\\n    FileInputStream inputStream = null;    //定义可以先放在try外部\\n    try {\\n        inputStream = new FileInputStream(\\"路径\\");\\n    } catch (FileNotFoundException e) {\\n        e.printStackTrace();\\n    } finally {\\n        try {    //建议在finally中进行，因为关闭流是任何情况都必须要执行的！\\n            if(inputStream != null) inputStream.close();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n</code></pre></div>","autoDesc":true}')}}]);