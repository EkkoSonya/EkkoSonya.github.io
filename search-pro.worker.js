const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":427,\"nextId\":427,\"documentIds\":{\"0\":\"2\",\"1\":\"2@0\",\"2\":\"2@1\",\"3\":\"3\",\"4\":\"3#主要动机\",\"5\":\"3#主要贡献\",\"6\":\"3#主要内容\",\"7\":\"3#系统结构\",\"8\":\"3#基本设置\",\"9\":\"3#信号模型\",\"10\":\"3#quality-of-experience-model\",\"11\":\"3#优化问题建立\",\"12\":\"3#解决方案\",\"13\":\"3#无人机的3d部署\",\"14\":\"3#无人机的动态移动设计\",\"15\":\"3@0\",\"16\":\"3@1\",\"17\":\"4\",\"18\":\"4#强化学习框架图\",\"19\":\"4#_1-基本概念\",\"20\":\"4#_2-markov-decision-process-mdp\",\"21\":\"4@0\",\"22\":\"4@1\",\"23\":\"5\",\"24\":\"5#_1-the-simplest-actor-critic-qac\",\"25\":\"5#_2-advantage-actor-critic-a2c\",\"26\":\"5#_2-1-baseline\",\"27\":\"5#_2-2-最好的-baseline\",\"28\":\"5#_2-3-对应算法\",\"29\":\"5#_3-off-policy-actor-critic\",\"30\":\"5#_3-1-重要性采样-importance-sampling\",\"31\":\"5#_3-2-off-policy\",\"32\":\"5#_3-3-伪代码\",\"33\":\"5#_4-deterministic-actor-critic-dpg\",\"34\":\"5@0\",\"35\":\"5@1\",\"36\":\"6\",\"37\":\"6#核心内容\",\"38\":\"6#_1-state-value\",\"39\":\"6#_1-1\",\"40\":\"6#_1-2-state-value\",\"41\":\"6#_1-3-state-value-与-return-的区别\",\"42\":\"6#_2-bellman-equation\",\"43\":\"6#_2-1-the-mean-of-immediate-rewards\",\"44\":\"6#_2-2-the-mean-of-future-rewards\",\"45\":\"6#_2-3-bellman-equation\",\"46\":\"6#_2-4-bellman-equation-matrix-vector-form\",\"47\":\"6#_3-why-to-slove-state-value\",\"48\":\"6#_4-action-value\",\"49\":\"6#_5-总结\",\"50\":\"6@0\",\"51\":\"6@1\",\"52\":\"7\",\"53\":\"7#_1-optimal-policy\",\"54\":\"7#_2-bellman-optimality-equation-boe\",\"55\":\"7#_2-1-基本形式\",\"56\":\"7#_2-2-如何求解\",\"57\":\"7#_2-2-1-如何处理等式右边的-最优策略\",\"58\":\"7#_2-求解-state-value\",\"59\":\"7@0\",\"60\":\"7@1\",\"61\":\"8\",\"62\":\"8#_1-value-iteration-algorithm\",\"63\":\"8#_1-1-具体步骤\",\"64\":\"8#_1-2-伪代码\",\"65\":\"8#_2-policy-iteration-algorithm\",\"66\":\"8#_2-1-算法描述\",\"67\":\"8#_2-2-伪代码\",\"68\":\"8#_2-3-一些问题\",\"69\":\"8#_3-truncated-policy-iteration-algorithm\",\"70\":\"8#_3-1-value-iteration-与-policy-iteration-算法比较\",\"71\":\"8#_3-2-truncated-policy-iteration-algorithm\",\"72\":\"8#truncated-policy-iteration-algorithm-是否是收敛的\",\"73\":\"8@0\",\"74\":\"8@1\",\"75\":\"9\",\"76\":\"9#_1-mc-basic\",\"77\":\"9#_1-1-算法思路\",\"78\":\"9#_1-2-如何估计\",\"79\":\"9#_1-3-具体算法\",\"80\":\"9#_2-mc-exploring-starts\",\"81\":\"9#_2-1-episode-的高效利用\",\"82\":\"9#_2-2-高效地更新-policy\",\"83\":\"9#_2-3-mc-exploring-starts\",\"84\":\"9#_2-4-exploring-statrts的解释\",\"85\":\"9#_3-mc-eplison-greedy\",\"86\":\"9#_3-1-soft-policy\",\"87\":\"9#_3-2-greedy-policy\",\"88\":\"9#_3-3-greedy-policy-引入-mc-based-算法中\",\"89\":\"9#_3-3-算法流程\",\"90\":\"9@0\",\"91\":\"9@1\",\"92\":\"10\",\"93\":\"10#_1-引言\",\"94\":\"10#_1-1-求均值的方法\",\"95\":\"10#_2-robbins-monto-rm-algorithm\",\"96\":\"10#_2-1-问题引入\",\"97\":\"10#_2-2-算法介绍\",\"98\":\"10#_2-3-收敛性分析\",\"99\":\"10#_2-4-应用于-mean-estimation-中\",\"100\":\"10#_3-stochastic-gradient-descent\",\"101\":\"10#_3-1-问题引入\",\"102\":\"10#_3-2-sgd-分析\",\"103\":\"10#mean-estimation-问题转化\",\"104\":\"10#sgd-正确性和收敛性分析\",\"105\":\"10#_3-3-sgd-另一种问题描述方法-deterministic-formulation\",\"106\":\"10#_3-4-bgd-mbgd-sgdw\",\"107\":\"10@0\",\"108\":\"10@1\",\"109\":\"11\",\"110\":\"11#_1-引入\",\"111\":\"11#_2-td-learning-of-state-value\",\"112\":\"11#_2-1-算法描述\",\"113\":\"11#_2-2-算法分析\",\"114\":\"11#_2-3-td-算法-与-mc-算法的比较\",\"115\":\"11#_3-td-learning-of-action-value\",\"116\":\"11#_3-1-sarsa\",\"117\":\"11#_3-2-n-step-sarsa\",\"118\":\"11#_3-3-expected-sarsa\",\"119\":\"11#_4-td-learning-of-optimal-action-value\",\"120\":\"11#_4-1-q-learning\",\"121\":\"11#_4-2-off-policy-on-policy\",\"122\":\"11#on-policy\",\"123\":\"11#off-policy\",\"124\":\"11#_4-3-q-learning-伪代码\",\"125\":\"11#off-poicy-版本\",\"126\":\"11#on-policy-版本\",\"127\":\"11#_5-td-算法的统一形式和总结\",\"128\":\"11@0\",\"129\":\"11@1\",\"130\":\"12\",\"131\":\"12#_1-引入\",\"132\":\"12#_2-alogorithm-of-state-value-estimation\",\"133\":\"12#_2-1-obejctive-function\",\"134\":\"12#uniform-distributon\",\"135\":\"12#stationary-distribution\",\"136\":\"12#_2-2-optimization-algorithms-优化算法\",\"137\":\"12#monte-carlo-learning-with-function-approximation\",\"138\":\"12#td-learning-with-function-approximation\",\"139\":\"12#_3-sarsa-with-function-approximation\",\"140\":\"12#_4-q-learning-with-function-approximation\",\"141\":\"12#_5-deep-q-learning-dqn\",\"142\":\"12#优化方法\",\"143\":\"12#经验回放-replay-buffer\",\"144\":\"12#伪代码\",\"145\":\"12@0\",\"146\":\"12@1\",\"147\":\"13\",\"148\":\"13#_1-基本思路\",\"149\":\"13#_2-目标函数定义\",\"150\":\"13#_2-1-average-state-value\",\"151\":\"13#另一种表达\",\"152\":\"13#d-s-的选择\",\"153\":\"13#_2-2-average-return-value\",\"154\":\"13#另一种表达-1\",\"155\":\"13#_3-目标函数梯度求解\",\"156\":\"13#_4-reinforce-梯度上升算法\",\"157\":\"13#reinforce-算法\",\"158\":\"13@0\",\"159\":\"13@1\",\"160\":\"14\",\"161\":\"14#类与对象\",\"162\":\"14#方法的创建与使用\",\"163\":\"14#方法的进阶使用\",\"164\":\"14#this-的使用\",\"165\":\"14#方法的重载\",\"166\":\"14#构造方法\",\"167\":\"14@0\",\"168\":\"14@1\",\"169\":\"15\",\"170\":\"15#泛型-2\",\"171\":\"15#泛型方法\",\"172\":\"15#泛型界限\",\"173\":\"15#类型擦除\",\"174\":\"15@0\",\"175\":\"15@1\",\"176\":\"16\",\"177\":\"16#集合类-1\",\"178\":\"16#集合类\",\"179\":\"16#集合类与数组区别\",\"180\":\"16#集合根接口\",\"181\":\"16#list-列表\",\"182\":\"16#arraylist\",\"183\":\"16@0\",\"184\":\"16@1\",\"185\":\"17\",\"186\":\"17#集合类-2\",\"187\":\"17#迭代器\",\"188\":\"17#iterator-简介\",\"189\":\"17#源码定义\",\"190\":\"17#不同集合类-迭代器-实现用例\",\"191\":\"17#使用示例\",\"192\":\"17#其他遍历-集合类-的方式\",\"193\":\"17#iterable-介绍\",\"194\":\"17#listiterator-介绍\",\"195\":\"17@0\",\"196\":\"17@1\",\"197\":\"18\",\"198\":\"18#集合类-3\",\"199\":\"18#quene-和-deque\",\"200\":\"18#quene-队列\",\"201\":\"18#deque-双端队列\",\"202\":\"18#其他集合类实现-队列\",\"203\":\"18#优先级队列\",\"204\":\"18#set-集合\",\"205\":\"18#hashset\",\"206\":\"18#linkedhashset\",\"207\":\"18#treeset\",\"208\":\"18@0\",\"209\":\"18@1\",\"210\":\"19\",\"211\":\"19#集合类-4\",\"212\":\"19#map\",\"213\":\"19#map-基本定义\",\"214\":\"19#hashmap\",\"215\":\"19#hashmap-底层实现\",\"216\":\"19#put-方法\",\"217\":\"19#resize-方法\",\"218\":\"19#linkedhashmap\",\"219\":\"19#treemap\",\"220\":\"19#map-的一些方法\",\"221\":\"19#compute\",\"222\":\"19#merge\",\"223\":\"19#replace\",\"224\":\"19#hashset-底层实现\",\"225\":\"19@0\",\"226\":\"19@1\",\"227\":\"20\",\"228\":\"20#stream流\",\"229\":\"20@0\",\"230\":\"20@1\",\"231\":\"21\",\"232\":\"21#collections-工具类\",\"233\":\"21#最大-最小\",\"234\":\"21#二分搜索\",\"235\":\"21#快速填充\",\"236\":\"21#空集合\",\"237\":\"21#查找位置\",\"238\":\"21@0\",\"239\":\"21@1\",\"240\":\"22\",\"241\":\"22#集合类对象相等判定\",\"242\":\"22@0\",\"243\":\"22@1\",\"244\":\"23\",\"245\":\"23#io流1\",\"246\":\"23#文件字节流\",\"247\":\"23#输入流-java-io-fileinputstream\",\"248\":\"23#文件读取\",\"249\":\"23#输出流-java-io-fileoutputstream\",\"250\":\"23#追加操作\",\"251\":\"23#文件拷贝操作实现\",\"252\":\"23#文件字符流\",\"253\":\"23#filereader\",\"254\":\"23#filewriter\",\"255\":\"23#file类\",\"256\":\"23@0\",\"257\":\"23@1\",\"258\":\"24\",\"259\":\"24#io流2\",\"260\":\"24#缓冲流\",\"261\":\"24#缓冲字节流\",\"262\":\"24#缓冲字节读取流-bufferedinputstream\",\"263\":\"24#缓冲流特性\",\"264\":\"24#_1-装饰着模式\",\"265\":\"24#_2-缓冲机制\",\"266\":\"24#_3-缓冲流可以叠加\",\"267\":\"24#缓冲字节输出流-bufferedoutputstream\",\"268\":\"24#缓冲字符流\",\"269\":\"24#缓冲字符读取流-bufferedreader\",\"270\":\"24#缓冲字符输出流-bufferedwriter\",\"271\":\"24@0\",\"272\":\"24@1\",\"273\":\"25\",\"274\":\"25#静态变量和静态方法\",\"275\":\"25#静态变量初始化\",\"276\":\"25#包的访问与控制\",\"277\":\"25#包的声明和导入\",\"278\":\"25#访问权限控制\",\"279\":\"25@0\",\"280\":\"25@1\",\"281\":\"26\",\"282\":\"26#io流3\",\"283\":\"26#转换流\",\"284\":\"26#打印流-printstream\",\"285\":\"26#输入流\",\"286\":\"26#数据流-datainputstream\",\"287\":\"26#对象流\",\"288\":\"26#对象序列化\",\"289\":\"26#serialversionuid\",\"290\":\"26#transient关键字\",\"291\":\"26@0\",\"292\":\"26@1\",\"293\":\"27\",\"294\":\"27#多线程\",\"295\":\"27#进程与线程概念\",\"296\":\"27#线程的创建和启动\",\"297\":\"27#start方法\",\"298\":\"27#run方法\",\"299\":\"27#sleep方法\",\"300\":\"27#线程的休眠和中断\",\"301\":\"27#中断\",\"302\":\"27#线程优先级\",\"303\":\"27#线程的礼让和加入\",\"304\":\"27#yield-主动让出cpu资源\",\"305\":\"27#join\",\"306\":\"27@0\",\"307\":\"27@1\",\"308\":\"28\",\"309\":\"28#多线程2\",\"310\":\"28#线程锁和线程同步\",\"311\":\"28#多线程下java内存管理\",\"312\":\"28#线程锁-synchronized\",\"313\":\"28#死锁\",\"314\":\"28@0\",\"315\":\"28@1\",\"316\":\"29\",\"317\":\"29#多线程3\",\"318\":\"29#wait-和-notify-方法\",\"319\":\"29#threadlocal\",\"320\":\"29#inheritablethreadlocal\",\"321\":\"29#定时器-timer\",\"322\":\"29#自己定义的定时器\",\"323\":\"29#timer\",\"324\":\"29#timer-不会终止\",\"325\":\"29@0\",\"326\":\"29@1\",\"327\":\"30\",\"328\":\"30#多线程4\",\"329\":\"30#守护线程\",\"330\":\"30#集合类\",\"331\":\"30#生产者与消费者\",\"332\":\"30@0\",\"333\":\"30@1\",\"334\":\"31\",\"335\":\"31#反射1\",\"336\":\"31#反射\",\"337\":\"31#java-类加载机制\",\"338\":\"31#class-类\",\"339\":\"31#获取相应类的class对象\",\"340\":\"31#基本数据类型的-class-对象\",\"341\":\"31#数组的-class-对象\",\"342\":\"31#class-对象与多态\",\"343\":\"31#类型比较\",\"344\":\"31@0\",\"345\":\"31@1\",\"346\":\"32\",\"347\":\"32#封装-继承和多态\",\"348\":\"32#封装\",\"349\":\"32#继承\",\"350\":\"32#object-类\",\"351\":\"32#方法重写-override\",\"352\":\"32#控制符-final\",\"353\":\"32#抽象类-abstract\",\"354\":\"32#接口-interface\",\"355\":\"32#object类中的-克隆方法\",\"356\":\"32#枚举类-enum\",\"357\":\"32@0\",\"358\":\"32@1\",\"359\":\"33\",\"360\":\"33#面向对象高级篇1\",\"361\":\"33#基本类型包装类\",\"362\":\"33#所有包装类如下\",\"363\":\"33#包装类的方法\",\"364\":\"33#特殊包装类\",\"365\":\"33@0\",\"366\":\"33@1\",\"367\":\"34\",\"368\":\"34#面向对象高级篇-2\",\"369\":\"34#数组\",\"370\":\"34#定义\",\"371\":\"34#方法\",\"372\":\"34#访问元素\",\"373\":\"34#特性\",\"374\":\"34#final性质\",\"375\":\"34#多维数组\",\"376\":\"34#可变长参数\",\"377\":\"34#main函数的-string-args\",\"378\":\"34#字符串\",\"379\":\"34#string-类\",\"380\":\"34#stringbuilder-类\",\"381\":\"34#正则表达式\",\"382\":\"34@0\",\"383\":\"34@1\",\"384\":\"35\",\"385\":\"35#内部类\",\"386\":\"35#成员内部类-属于-对象\",\"387\":\"35#静态内部类-属于-类\",\"388\":\"35#局部内部类\",\"389\":\"35#静态内部类编译特性\",\"390\":\"35#匿名内部类\",\"391\":\"35#匿名内部类特性\",\"392\":\"35#lambda表达式\",\"393\":\"35#方法引用\",\"394\":\"35@0\",\"395\":\"35@1\",\"396\":\"36\",\"397\":\"36#面向对象高级篇-4\",\"398\":\"36#异常机制\",\"399\":\"36#异常类型\",\"400\":\"36#自定义异常\",\"401\":\"36#抛出异常-throw\",\"402\":\"36#异常的处理-try-catch-finally\",\"403\":\"36#断言表达式-assert\",\"404\":\"36@0\",\"405\":\"36@1\",\"406\":\"37\",\"407\":\"37#面向对象高级篇-6\",\"408\":\"37#常用工具类\",\"409\":\"37#数学工具类-math\",\"410\":\"37#数组工具类-arrays\",\"411\":\"37@0\",\"412\":\"37@1\",\"413\":\"38\",\"414\":\"38#泛型-1\",\"415\":\"38#使用泛型的原因\",\"416\":\"38#泛型类-classname-t\",\"417\":\"38#泛型和多态\",\"418\":\"38@0\",\"419\":\"38@1\",\"420\":\"39\",\"421\":\"40\",\"422\":\"41\",\"423\":\"42\",\"424\":\"43\",\"425\":\"44\",\"426\":\"45\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[10,6],\"4\":[1,45],\"5\":[1,29],\"6\":[1],\"7\":[1],\"8\":[1,44],\"9\":[1,105],\"10\":[4,82],\"11\":[1,34],\"12\":[1],\"13\":[1,157],\"14\":[1,67],\"15\":[null,null,1],\"16\":[null,null,6],\"17\":[2],\"18\":[1,1],\"19\":[2,118],\"20\":[6,54],\"21\":[null,null,1],\"22\":[null,null,1],\"23\":[4,19],\"24\":[7,2],\"25\":[6,8],\"26\":[3,28],\"27\":[3,8],\"28\":[3,3],\"29\":[5,10],\"30\":[6,3],\"31\":[4,4],\"32\":[2,1],\"33\":[6,3],\"34\":[null,null,1],\"35\":[null,null,1],\"36\":[2],\"37\":[1,5],\"38\":[3],\"39\":[1,16],\"40\":[4,27],\"41\":[7,36],\"42\":[3,35],\"43\":[8,10],\"44\":[7,23],\"45\":[4,47],\"46\":[8,34],\"47\":[6,34],\"48\":[3,72],\"49\":[2,29],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[2,16],\"53\":[3,36],\"54\":[6],\"55\":[3,28],\"56\":[2,8],\"57\":[5,21],\"58\":[4,75],\"59\":[null,null,1],\"60\":[null,null,1],\"61\":[4,6],\"62\":[4,18],\"63\":[2,53],\"64\":[3,1],\"65\":[4,3],\"66\":[3,70],\"67\":[2,1],\"68\":[3,44],\"69\":[5,6],\"70\":[7,71],\"71\":[6,23],\"72\":[5,1],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[6,51],\"76\":[3,16],\"77\":[2,61],\"78\":[3,33],\"79\":[3,49],\"80\":[4,10],\"81\":[4,63],\"82\":[3,52],\"83\":[5,1],\"84\":[4,33],\"85\":[4,9],\"86\":[4,25],\"87\":[4,39],\"88\":[7,12],\"89\":[2,1],\"90\":[null,null,1],\"91\":[null,null,1],\"92\":[2,33],\"93\":[2],\"94\":[2,32],\"95\":[5],\"96\":[3,17],\"97\":[2,31],\"98\":[3,44],\"99\":[6,41],\"100\":[4],\"101\":[3,57],\"102\":[4],\"103\":[3,8],\"104\":[2,67],\"105\":[6,11],\"106\":[5,1],\"107\":[null,null,1],\"108\":[null,null,1],\"109\":[4],\"110\":[2,50],\"111\":[6,10],\"112\":[3,36],\"113\":[2,37],\"114\":[7],\"115\":[6,23],\"116\":[3,37],\"117\":[5,3],\"118\":[3,2],\"119\":[7,21],\"120\":[4,24],\"121\":[6,7],\"122\":[2,9],\"123\":[2,17],\"124\":[5,17],\"125\":[3,10],\"126\":[3,1],\"127\":[3,2],\"128\":[null,null,1],\"129\":[null,null,1],\"130\":[6,11],\"131\":[2,12],\"132\":[6,9],\"133\":[4,15],\"134\":[2,22],\"135\":[2,52],\"136\":[4,40],\"137\":[6,19],\"138\":[5,15],\"139\":[5,10],\"140\":[6,13],\"141\":[6,21],\"142\":[1,110],\"143\":[4,3],\"144\":[1,13],\"145\":[null,null,1],\"146\":[null,null,1],\"147\":[5,10],\"148\":[2,38],\"149\":[2],\"150\":[5,22],\"151\":[1,5],\"152\":[3,21],\"153\":[4,20],\"154\":[1,27],\"155\":[2,60],\"156\":[3,40],\"157\":[2,1],\"158\":[null,null,1],\"159\":[null,null,1],\"160\":[2],\"161\":[1,85],\"162\":[1,56],\"163\":[1],\"164\":[2,23],\"165\":[1,20],\"166\":[1,75],\"167\":[null,null,1],\"168\":[null,null,1],\"169\":[3],\"170\":[2],\"171\":[1,100],\"172\":[1,79],\"173\":[1,46],\"174\":[null,null,1],\"175\":[null,null,1],\"176\":[3],\"177\":[2],\"178\":[1,17],\"179\":[1,14],\"180\":[1,138],\"181\":[2,112],\"182\":[1,229],\"183\":[null,null,1],\"184\":[null,null,1],\"185\":[3],\"186\":[2],\"187\":[1,36],\"188\":[1,20],\"189\":[1,31],\"190\":[3,30],\"191\":[1,35],\"192\":[3,51],\"193\":[1,64],\"194\":[1,37],\"195\":[null,null,1],\"196\":[null,null,1],\"197\":[3],\"198\":[2],\"199\":[3,18],\"200\":[2,55],\"201\":[2,72],\"202\":[2,22],\"203\":[1,43],\"204\":[2,67],\"205\":[1,44],\"206\":[1,30],\"207\":[1,41],\"208\":[null,null,1],\"209\":[null,null,1],\"210\":[3],\"211\":[2],\"212\":[1,15],\"213\":[2,84],\"214\":[1,65],\"215\":[2,69],\"216\":[2,104],\"217\":[2,89],\"218\":[1,36],\"219\":[1,9],\"220\":[2],\"221\":[1,49],\"222\":[1,65],\"223\":[1,33],\"224\":[2,72],\"225\":[null,null,1],\"226\":[null,null,1],\"227\":[2],\"228\":[1,181],\"229\":[null,null,1],\"230\":[null,null,1],\"231\":[3],\"232\":[2,9],\"233\":[3,16],\"234\":[1,30],\"235\":[1,29],\"236\":[1,33],\"237\":[1,57],\"238\":[null,null,1],\"239\":[null,null,1],\"240\":[2],\"241\":[1,108],\"242\":[null,null,1],\"243\":[null,null,1],\"244\":[2],\"245\":[1,49],\"246\":[1],\"247\":[1,43],\"248\":[1,60],\"249\":[1,45],\"250\":[1,26],\"251\":[1,37],\"252\":[1,4],\"253\":[1,40],\"254\":[1,30],\"255\":[1,60],\"256\":[null,null,1],\"257\":[null,null,1],\"258\":[2],\"259\":[1],\"260\":[1,19],\"261\":[1],\"262\":[1,28],\"263\":[1],\"264\":[2,38],\"265\":[2,60],\"266\":[2,9],\"267\":[1,24],\"268\":[1,3],\"269\":[1,39],\"270\":[1,26],\"271\":[null,null,1],\"272\":[null,null,1],\"273\":[2],\"274\":[1,52],\"275\":[1,27],\"276\":[1],\"277\":[1,90],\"278\":[1,60],\"279\":[null,null,1],\"280\":[null,null,1],\"281\":[2],\"282\":[1],\"283\":[1,49],\"284\":[1,48],\"285\":[1,24],\"286\":[1,39],\"287\":[1,7],\"288\":[1,41],\"289\":[1,24],\"290\":[1,55],\"291\":[null,null,1],\"292\":[null,null,1],\"293\":[2],\"294\":[1],\"295\":[1,71],\"296\":[1,69],\"297\":[1,29],\"298\":[1,5],\"299\":[1,59],\"300\":[1,36],\"301\":[1,65],\"302\":[1,37],\"303\":[1],\"304\":[1,43],\"305\":[1,54],\"306\":[null,null,1],\"307\":[null,null,1],\"308\":[2],\"309\":[1],\"310\":[1],\"311\":[1,72],\"312\":[1,91],\"313\":[1,75],\"314\":[null,null,1],\"315\":[null,null,1],\"316\":[2],\"317\":[1],\"318\":[2,92],\"319\":[1,54],\"320\":[1,25],\"321\":[1],\"322\":[1,39],\"323\":[1,37],\"324\":[1,110],\"325\":[null,null,1],\"326\":[null,null,1],\"327\":[2],\"328\":[1],\"329\":[1,50],\"330\":[1,79],\"331\":[1,75],\"332\":[null,null,1],\"333\":[null,null,1],\"334\":[2],\"335\":[1],\"336\":[1,17],\"337\":[2,26],\"338\":[2,5],\"339\":[1,36],\"340\":[3,59],\"341\":[3,30],\"342\":[2],\"343\":[1,104],\"344\":[null,null,1],\"345\":[null,null,1],\"346\":[2],\"347\":[2,16],\"348\":[1],\"349\":[1,4],\"350\":[2,79],\"351\":[1,74],\"352\":[1,14],\"353\":[1,73],\"354\":[1,141],\"355\":[2,73],\"356\":[1,72],\"357\":[null,null,1],\"358\":[null,null,1],\"359\":[2],\"360\":[1],\"361\":[1,9],\"362\":[1,97],\"363\":[1,25],\"364\":[1,69],\"365\":[null,null,1],\"366\":[null,null,1],\"367\":[5],\"368\":[2],\"369\":[1,5],\"370\":[1,47],\"371\":[1,40],\"372\":[1,29],\"373\":[1,32],\"374\":[1,22],\"375\":[1,24],\"376\":[1,43],\"377\":[1,25],\"378\":[1,15],\"379\":[2,65],\"380\":[2,60],\"381\":[1,148],\"382\":[null,null,1],\"383\":[null,null,1],\"384\":[2,6],\"385\":[1,3],\"386\":[4,93],\"387\":[4,34],\"388\":[1,35],\"389\":[1,42],\"390\":[1,84],\"391\":[1,35],\"392\":[1,53],\"393\":[1,67],\"394\":[null,null,1],\"395\":[null,null,1],\"396\":[2],\"397\":[2],\"398\":[1],\"399\":[1,50],\"400\":[1,23],\"401\":[1,57],\"402\":[1,104],\"403\":[1,26],\"404\":[null,null,1],\"405\":[null,null,1],\"406\":[2],\"407\":[2,5],\"408\":[1],\"409\":[1,59],\"410\":[1,45],\"411\":[null,null,1],\"412\":[null,null,1],\"413\":[3],\"414\":[2],\"415\":[1,79],\"416\":[1,106],\"417\":[1,44],\"418\":[null,null,1],\"419\":[null,null,1],\"420\":[1,3],\"421\":[1],\"422\":[1],\"423\":[1],\"424\":[1],\"425\":[1],\"426\":[1]},\"averageFieldLength\":[2.3560375458588716,38.03968727352362,1],\"storedFields\":{\"0\":{\"h\":\"daily1\",\"t\":[\"a+b=c\"]},\"1\":{\"c\":[\"daily\"]},\"2\":{\"c\":[\"d1\"]},\"3\":{\"h\":\"Reinforcement Learning in Multiple-UAV Networks:Deployment and Movement Design\",\"t\":[\"2019 IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"4\":{\"h\":\"主要动机\",\"t\":[\"A novel framework is proposed for quality of experience driven deployment and dynamic movement of multiple unmanned aerial vehicles (UAVs).\",\"过去研究大多没有基于用户的移动(movement of users)来考虑无人机的机动性，更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署。\",\"考虑QoE, 而不是仅考虑吞吐量(throughput)，即需要考虑地面不同用户的具体需求。(QoE is invoked for demonstrating the users’ satisfaction, and it is supposed to be considered in UAV-assisted wireless networks)\",\"该文设计的是3D部署，过去研究主要考虑的是2D部署。\"]},\"5\":{\"h\":\"主要贡献\",\"t\":[\"提出了一个理想的由QoE驱动的多无人机协助通信框架。该框架将无人机部署在三维空间内，以 mean opinion score(MOS) 为指标。通过优化无人机的部署和动态移动来解决总用户MOS最大化问题。\",\"提出解决总用户MOS最大化问题的三步骤: \",\"通过GAK-mean算法获得初始单元划分。\",\"设计一种基于 q-learning 的部署方法，在初始时间假设用户处于静止下不断调整 UAVs 3D位置进行优化处理。\",\"设计一种基于 q-learning 的无人机3D动态运动设计算法。\",\"该文基于q-learning的方案来解决无人机的NP-hard 3D部署和移动问题，并与传统的基于遗传的学习算法进行对比。\",\"该文提出的算法具较快的收敛性，与K-means和IGK算法比具有较低的复杂度。\"]},\"6\":{\"h\":\"主要内容\"},\"7\":{\"h\":\"系统结构\"},\"8\":{\"h\":\"基本设置\",\"t\":[\"考虑无人机辅助无线网络的下行链路传输(down-link transmission)，即无人机作为空中基站。\",\"对于指定区域，会将其划分为N个簇，其中用户表示为K=K1​,…,KN​，其中KN​表示划分到集群N的用户，N∈1,2,…,N。\",\"每个用户只能属于一个集群，Kn​∩Kn′​=ϕ,n′=n,\",\"在任意时刻t，同一无人机通过FDMA同时为同一集群中的多个用户提供服务\",\"对于用户kn​∈Kn​，其坐标表示为wkn​​=[xkn​​(t),ykn​​(t)]T∈R2×1\",\"对于无人机n(飞行速度恒定)，其垂直高度表示为hn​(t)∈[hmin​,hmax​],0≤t≤Ts​，其水平坐标表示为qn​(t)=[xn​(t),yn​(t)]T∈R2×1,0≤t≤Ts​\",\"无人机n与用户kn​在时间t的距离表示为:\",\"dkn​​=hn2​(t)+[xn​(t)−xkn​​(t)]2+[yn​(t)−ykn​​(t)]2​\"]},\"9\":{\"h\":\"信号模型\",\"t\":[\"无人机往往有更高的LoS链接概率，该文中表示为:\",\"PLoS​(θkn​​)=b1​(π180​θkn​​−ζ)b2​PNLoS​=1−PLoS​\",\"其中θkn​​(t)=sin−1[dkn​(t)​hn​(t)​]，表示无人机与用户之间的仰角。b1​,b2​,ζ是由环境决定的常数。在实际应用中，为了在LoS信道概率和路径损耗之间取得平衡，需要合理选择无人机n的垂直高度hn​(t)。\",\"在时间t，从无人机n到用户kn​的信道功率增益(the channel power gain)为:\",\"gkn​​(t)=K0​−1dkn​​−α[t](PLos​μLoS​+PNLos​μNLoS​)−1\",\"其中K0​=(c4πfc​​)2，α是表示路径损耗指数(常数)，μLoS​,μNLoS​是表示LoS和NLoS链路的衰减因子，fc​是载波频率，c是光速。\",\"对于无人机n，其可用带宽为Bn​，将其平均分配给其∣Kn​∣个关联用户，其每个用户带宽表示为: Bkn​​=Bn​/Kn​. 该文中不同集群所利用的频谱是不同的，且无人机向关联用户的发射功率是恒定的。 同样，对于无人机的总发射功率也均匀地分配给每个用户，pkn​​=Pmax​/Kn​\",\"由于不同集群的频谱不同，可以减轻无人机对用户接收到的干扰。因此，在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为:\",\"Γkn​​(t)=σ2pkn​​gkn​​(t)​\",\"其中σ2=Bkn​​N0​, N0​为用户所在位置的加性高斯白噪声(AWGN)的功率谱密度。\",\"为了满足不同用户传输速率要求，对于用户kn​存在特定的信噪比目标γkn​​, 即Γ≥γkn​​.\",\"由此，存在Lemma1： 为了保证所有用户都能连接到网络，我们对无人机的发射功率有一个约束，可以表示为\",\"Pmax​≥γσ2K0​dkn​​α(t)μNLoS​\",\"根据香农定理: 信道容量C=B∗log(1+NS​)，且传输率永远都不可能超过信道容量C。 因此对于用户kn​的在时刻t的传输速率rkn​​(t)，表示为rkn​​(t)=Bkn​​log2​[1+σ2pkn​​gkn​​(t)​].\",\"Proposition1: 无人机n的高度需满足:\",\"dkn​​(t)sin[180π​(ζ+eM(t))]≤hn​(t)≤(γK0​σ2μLoS​Pmax​​)\",\"其中\",\"M(t)=b2​ln(b1​(μLoS​−μNLoS​)S(t)​−μLoS​−μNLoS​μNLoS​​​S(t)=γK0​σ2dkn​​α(t)Pm​ax​\",\"Proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件。 可知，其高度的下界是距离dkn​​(t)的函数；高度的上界是最大发射功率Pmax​的函数。 因此，随着无人机与用户之间距离和发射功率的变化，需要调整相应无人机的高度，以向用户提供可靠的服务。\"]},\"10\":{\"h\":\"Quality-of-Experience Model\",\"t\":[\"由于不同用户对于传输速率的需求是不同的，所以在无人机辅助通信网络中我们需要考虑QoE模型。\",\"在该文中，采用MOS作为用户QoS衡量的标准，具体如下:\",\"MOSkn​​(t)=ζ1​MOSkn​​delay(t)+ζ2​MOSkn​​rate(t)\",\"其中，ζ1​,ζ2​是系数，且ζ1​+ζ2​=1。\",\"根据MOS数值，共划分5个等级: excellent(4.5) very good(2~3.5) fair(1~2) poor(1)。\",\"在该文中考虑的是网页浏览应用传输情况，因此MOSkn​​delay(t)可以忽略，因此，此时的MOS模型定义如下:\",\"MOSkn​​(t)=−C1​ln[d(rkn​​(t))]+C2​\",\"d(rkn​​(t))是与传输速率有关的延迟时间，MOSkn​​(t)为t时刻的MOS评分，取值范围从1−4.5。C1​和C2​是通过分析web浏览应用程序的实验结果确定的常数，分别设为1.120和4.6746。\",\"d(rkn​​(t))=3RTT+rkn​​(t)FS​+L(rkn​​MSS​)+RTT−rkn​​(t)2MSS(2L−1)​\",\"其中，RTT[s]表示round trip time(数据包从发送端-接收端-发送端的时间)，FS[bit]是网页大小，MSS[bit]是最大报文长度，L=min[L1​,L2​]表示 the number of slow start cycles with idle periods。\",\"L1​=log2​(MSSrkn​​RTT​+1)−1,L2​=log2​(2MSSFS​+1)−1.\",\"用户rkn​​在一段时间Ts​内的MOS总和为:\",\"MOSrkn​​​=t=0∑Ts​​MOSkn​​(t)\"]},\"11\":{\"h\":\"优化问题建立\",\"t\":[\"假设功率Q=qn​(t),0≤t≤Ts​, 高度H=hn​(t),0≤t≤Ts​\",\"本文目的是优化无人机在每个时隙的位置，从而最大化所有用户的总MOS值。具体表述如下:\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​∑t=0Ts​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"该优化问题是一个non-convex问题，因为目标函数对于无人机的3D坐标是非凸的。\",\"总用户的MOS取决于无人机的发射功率、数量和位置(水平位置和高度)。\"]},\"12\":{\"h\":\"解决方案\"},\"13\":{\"h\":\"无人机的3D部署\",\"t\":[\"考虑以下场景，将上述优化问题简化:\",\"无人机n以可变高度悬停在用户上方，用户是保持静态的。 每架无人机的带宽和发射功率都均匀分配给每个用户。 因此我们将优化问题简化为区域分割问题。\",\"描述如下: 但即使仅考虑用户聚类，该问题依然是NP-hard问题\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"无人机-用户关联策略(用户区域划分算法)\",\"采用基于遗传算法的GAK-means算法 由于特定用户的MOS与该用户与无人机之间的距离有关，因此GAK-means可以视为获得无人机部署的低复杂度方案。\",\"根据N个用户，根据遗传算法找到CN​个最优个体作为簇的中心。\",\"将无人机部署在每个中心内，再将用户划分给距离最近的无人机\",\"重复步骤，再找到新的簇的各中心，再根据欧几里得距离重新划分，直到各个簇的成员没有太大变化，划分完毕。\",\"无人机3D部署算法\",\"根据所给定的用户划分情况，目标是获得无人机的最佳3D位置，来最大化MOS总和。 由于GAK-means的优化目标是最小化无人机与对应集群用户的欧氏距离，MOS主要是有关传输速率rkn​​的函数，因此MOS不仅与欧氏距离有关，还与LoS的概率有关。\",\"采用Q-learning算法\",\"智能体(agent): UAVn,n∈N={1,2,…,N}\",\"状态(state): 对于每个智能体，其状态为其3D坐标，定义为ξ=(xUAV​,yUAV​,hUAV​)\",\"状态空间(state space S): 这里采用离散化空间坐标，即xUAV​:{0,1,…,Xd​},yUAV​:0,1,…,Yd​,hUAV​:{hmin​,…,hmax​}，所以状态其实共有(XD​+1)×(Yd​+1)×(hmax​−hmin​+1)个\",\"动作空间(action space): 每次无人机会根据当前状态st​∈S，按照所给定策略J来执行一个动作at​∈A从而获得奖励rt​以及下一个状态st+1​ 该论文中在精度和模型复杂型上作出平衡，共考虑7个方向。 (1,0,0)：右转 (−1,0,0)：左转 (0,1,0)：前进 (0,−1,0)：后退 (0,0,1)：上行 (0,0,−1)：下行 (0,0,0)：静止\",\"状态转换模型: 当执行动作at​时，从状态st​到st+1​，并获得奖励rt​的这一过程可以用条件转移概率p(st+1​,rt​∣st​,at​)来表示。 Q-learning的优化目标是最大化长期收益\",\"Gt​=E[n=0∑∞​βnrt+n​]\",\"奖励(reward): 如果agent在当前时刻t所执行的动作能够提高总MOS，则无人机将获得正奖励。否则，agent将获得负奖励。\",\"xt​=⎩⎨⎧​1,−0.1,−1,​ifMOSnew​>MOSold​ifMOSnew​=MOSold​ifMOSnew​<MOSold​​\",\"具体代码：（策略为贪心策略）\",\"算法1\",\"个人理解：\",\"通过K-means来划分各个无人机所管理的用户簇。无人机的位置初始化也是随机部署的\",\"但每个无人机所管理的用户不同，其目标也应该不一样，不能用同一个Q-table管理，这里是每个无人机都有一张自己的Q-table，来进行迭代？ 还是同一张Q-table，只不过根据区域划分，不同的无人机agent的Q(s,a)的s是有范围的？(个人感觉是这个)\",\"最终输出的结果，应该是无人机最终停的位置即是部署的最佳位置(因为q-learning是优化长期目标)，发现在该位置静止是最优的，表示是最佳部署位置。\",\"最终输出结果，是根据Q-table来找出对应q(s,a)当a为静止时，最大的q(s,a)值，对应s就是UAV的部署位置\"]},\"14\":{\"h\":\"无人机的动态移动设计\",\"t\":[\"考虑用户在每个时隙移动的情况，由于用户在每个时隙都处于漫游状态，因此随着用户位置的变化，每个集群中无人机的最优位置也会发生变化，无人机需要进行移动。\",\"在本文中不考虑用户移动到其他集群的情况 因为在不考虑用户自由穿梭集群的情况，对于动作空间而言，仅需要考虑无人机的7个移动方向即可；但若考虑集群情况，动作空间包含两个部分：选择移动方向和选择关联用户。设无人机总数为N，∣Kn​∣为第n个簇的用户总数，则用户的关联动作数为2N∑n=1N​∣Kn​∣，∑n=1N​∣Kn​∣是总用户数，每个用户都需要判断是否与每个无人机关联，因此是2N 则总动作空间的大小为7+2N∑n=1N​∣Kn​∣会导致动作空间过大，Q-table过大。\",\"1.用户漫游模型 在设计无人机的移动之前，需考虑用户的移动性，这里有多种mobility modles可选择，如a deterministic approach, a hybrid approach, and a random walk model. 在本文中，采用的是the random walk model(Markovian mobility model) 每个用户的移动方向均匀分布在左、右、前、后四个方向。 用户的速度设为[0,cmax​]，其中cmax​表示用户的最大速度。\",\"2.基于q-learning的移动算法 与基于q-learning的部署算法不同的是，在此情况下，状态除了要考虑无人机的3D位置外，还需要考虑所有用户的2D位置。即ξ={xUAV​,yUAV​,hUAV​,xuser​,yuser​}(xuser​,yuser​)由用户的初始位置和运动模型决定，(xUAV​,yUAV​,hUAV​)由无人机的位置和它们在最后时隙采取的动作决定.\",\"训练阶段: \",\"测试阶段:\\n\"]},\"15\":{\"c\":[\"academic\"]},\"16\":{\"c\":[\"UAV\",\"IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"17\":{\"h\":\"RL1 - 基本概念\"},\"18\":{\"h\":\"强化学习框架图\",\"t\":[\"主要框架\"]},\"19\":{\"h\":\"1. 基本概念\",\"t\":[\"State(状态)：The status of the agent with respect to the environment.\",\"State Space(状态空间): 所有状态的集合。S={si​}i=1n​。\",\"Action(动作): 对于每一个状态，都有可选择的动作。\",\"Action space of a state: 对应状态中所有可选择的动作集合。A(si​)={ai​}i=1n​\",\"State transition(状态转换): s1​→a1​s2​。定义了agent与环境的交互行为。\",\"State transition probability: p(s2​∣s1​,a1​)，即状态s1​采用动作a1​转到状态s2​的概率。\",\"Policy π: 指导agent在当前状态下选择哪个动作。\",\"Reward(奖励): 在执行一个动作后获得的一个常数(依赖于当前状态和所采取的动作)。同样可以用条件概率的形式进行描述，如p(r=1∣s1​,a1​)，即在状态s1​下采用动作a1​获得的奖励r=1的概率。\",\"Trajectory：a state-action-reward chain.(可以有限，也可以是无限长的trajectory) s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​. 个人理解，trajectory是在策略给定下，agent可能走出的全部轨迹，并非只是一个单一的轨迹。\",\"Return of a trajectory：将对应的轨迹所获得的所有reward的总和，可以粗步衡量一个策略的好坏。\",\"Discounted return(of a trajectory)：为了应对具有无限步的trajectory的return=∞的情况。 s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​…. 此时该trajectory的return=0+0+0+1+1+⋯=∞。 引入discount rate, γ∈[0,1). 此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​ 显然，如果γ接近0，即此时的discounted return越短视，注重近期的reward；γ接近1，更远视，更注重长远的reward。\",\"Episode(trial)：When interacting with the environment following a policy, the agent may stop at some terminal states. The resulting trajectory is called an episode(or a trial)/ 即表示具有终止状态terminal states的trajectory，通常是具有有限步长的trajectory. 同理，这样的任务称为episodic tasks。\",\"continuing tasks：即不具备terminal states的任务，会与环境一直交互下去。 可以通过设置将episodic tasks转换成continuing tasks，如可以在target states中限制action space，控制其一直待在target states中。 Deterministic — Stochastic\"]},\"20\":{\"h\":\"2.Markov decision process(MDP)\",\"t\":[\"关键元素：\",\"Sets： \",\"State：the set of states S\",\"Action：the set of actions A(s) is associate for state s∈S\",\"Reward：the set of rewards R(s,a).\",\"Probability distribution： \",\"State transition probability p(s′∣s,a): 表示在状态s下采取动作a，转换到状态s′的概率。\",\"Reward probability p(r∣s,a): 表示在状态s下采取动作a，获得reward r 的概率。\",\"Policy：at state s, the probability to choose action a is π(a∣s). 表示在各状态执行各动作的概率。\",\"Markov property：即无记忆的特性。 p(st+1​∣at+1​,st​,…,a1​,s0​)=p(st+1​∣at+1​,st​)r(st+1​∣at+1​,st​,…,a1​,s0​)=p(rt+1​∣at+1​,st​)\",\"Markov process：在policy是确定的情况下，MDP就变为MP。\"]},\"21\":{\"c\":[\"academic\"]},\"22\":{\"c\":[\"强化学习\"]},\"23\":{\"h\":\"RL10 - Actor-Critic 方法\",\"t\":[\"actor: 对应 policy update\",\"critic: 对应 policy evaluation 或者 value evaluation\",\"20240830184236\",\"显然，是在基于 策略梯度上升 算法的基础上，将对于 Q 值的估计通过一个网络来进行描述，这个便成为 critic, 而对应的策略梯度上升算法就是对应 actor。\",\"20240830184312\"]},\"24\":{\"h\":\"1. The simplest actor-critic (QAC)\",\"t\":[\"20240830184330\",\"20240830184424\"]},\"25\":{\"h\":\"2. Advantage actor-critic (A2C)\",\"t\":[\"核心思想：在 QAC 的基础上来引入偏置量(baseline)，从而减小方差，提升采样的效率。\"]},\"26\":{\"h\":\"2.1 baseline\",\"t\":[\"在策略梯度算法中引入一个 baseline, 不会影响所求的梯度。 即:\",\"▽θ​J(θ)​=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)]=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)−b(S)]​\",\"证明: 要证明加入baseline成立，只需要保证:\",\"ES∼η,A∼π​[▽θ​ln(A∣S,θ)b(S)]=0\",\"20240830185127\",\"作用:\",\"因此，我们需要找到一个 baseline 来保证这个梯度的方差最小即可。\"]},\"27\":{\"h\":\"2.2 最好的 baseline\",\"t\":[\"20240830185324\",\"在实际情况中，我们通常将 baseline 设置为 vπ​(s)\"]},\"28\":{\"h\":\"2.3 对应算法\",\"t\":[\"20240830185537\",\"20240830185556\",\"20240830185629\"]},\"29\":{\"h\":\"3. off-policy actor-critic\",\"t\":[\"通过 重要性采样 的方法，将处于 另一分布下 的策略所采集的数据来 运用到 策略更新 中。\"]},\"30\":{\"h\":\"3.1 重要性采样 (Importance sampling)\",\"t\":[\"20240830200056\",\"20240830200118\",\"20240830200138\"]},\"31\":{\"h\":\"3.2 off-policy\",\"t\":[\"20240830200248\",\"20240830200305\",\"20240830200320\",\"20240830200343\"]},\"32\":{\"h\":\"3.3 伪代码\",\"t\":[\"20240830200406\"]},\"33\":{\"h\":\"4. Deterministic actor-critic (DPG)\",\"t\":[\"1234\",\"20240830200608\",\"20240830200624\"]},\"34\":{\"c\":[\"academic\"]},\"35\":{\"c\":[\"强化学习\"]},\"36\":{\"h\":\"RL2 - 贝尔曼公式\"},\"37\":{\"h\":\"核心内容\",\"t\":[\"state value\",\"the Bellman equation\"]},\"38\":{\"h\":\"1.State value\"},\"39\":{\"h\":\"1.1\",\"t\":[\"引入随机变量后对应的discounted return的描述。 即一个trajectory下的discounted return。 由此可以推导出一个多步的trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的discounted return为：Gt​=Rt+1​+γRt+2​+γ2Rt+3​+…\",\"γ 为discounted rate\",\"Gt​也是一个随机变量\"]},\"40\":{\"h\":\"1.2 State value\",\"t\":[\"State value 是 Gt​ 的期望, 也称为 state value function 表示为 The expection(expected value or mean) of Gt​:\",\"vπ​(s)=E[Gt​∣St​=s]\",\"是一个有关状态s的函数.\",\"vπ​(s) 是基于一个给定策略 π , 对于不同的策略，所得到的 state value 是不同的.\",\"state value 可以用来衡量一个状态的价值.\"]},\"41\":{\"h\":\"1.3 State value 与 return 的区别\",\"t\":[\"Return 是针对一条trajectory所求的，而 State value 则是对多个 trajectory 求 return 再求平均值。 The state value is the mean of all possible returns that can be obtained starting from a state. 只有当所有东西都是确定性的(π(a∣s),p(r∣s,a),p(s′∣s,a))，state value 与 return 是一致的.\"]},\"42\":{\"h\":\"2. Bellman equation\",\"t\":[\"用来描述所有状态的state value的关系. 根据一个 random trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的 discounted return Gt​ 为:\",\"Gt​​=Rt+1​+γRt+2​+γ2Rt+3​+…=Rt+1​+γ(Rt+2​+γRt+3​+…)=Rt+1​+γGt+1​​\",\"因此，对应的 state value 为:\",\"vπ​(s)​=E[Gt​∣St​=s]=E[Rt+1​+γGt+1​∣St​=s]=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s]​\",\"需要推导E[Rt+1​∣St​=s]和E[Gt+1​∣St​=s]的计算即可。\"]},\"43\":{\"h\":\"2.1 The mean of immediate rewards:\",\"t\":[\"E[Rt+1​∣St​=s]​=a∑​π(a∣s)E[Rt+1​∣St​=s,At​=a]=a∑​π(a∣s)r∑​p(r∣s,a)r​\"]},\"44\":{\"h\":\"2.2 The mean of future rewards:\",\"t\":[\"E[Gt+1​∣St​=s]​=s′∑​E[Gt+1​∣St​=s,St+1​=s′]=s′∑​E[Gt+1​∣St+1​=s′](无记忆性)=s′∑​vπ​(s′)p(s′∣s)=s′∑​vπ​(s′)a∑​p(s′∣s,a)π(a∣s)​\",\"个人推导：\",\"E[Gt+1​∣St​=s]​=a∑​π(a∣s)E[Gt+1​∣St​=s,At​=a]=a∑​π(a∣s)s′∑​E[Gt+1​∣St​=s,At​=a,St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)E[Gt+1​∣St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​\"]},\"45\":{\"h\":\"2.3 Bellman equation\",\"t\":[\"vπ​(s)​=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s],=mean of immediate rewards a∑​π(a∣s)r∑​p(r∣s,a)r​​+mean of future rewards γa∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​​,=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)],∀s∈S.​\",\"该式子针对状态空间中的所有状态均成立.\",\"通过 Bootstrapping , 可以求解 state value.\",\"π(a∣s) 表示一个给定的策略. 求解Bellman equation 称为策略评估(Policy evaluation).\",\"p(r∣s,a),p(s′∣s,a) 是由环境决定的(dynamic model|environment model). 后续可能是未知的(model-free)，需要通过采样解决.\"]},\"46\":{\"h\":\"2.4 Bellman equation (Matrix-vector form)\",\"t\":[\" 此时,对于所有状态s，对应的 Bellman equation 为\",\"vπ​(s)=rπ​(s)+γs′∑​pπ​(s′∣s)vπ​(s′)​\",\"将所有状态的 Bellman equation 整合，重新修改为 matrix-vector form.\",\"vπ​=rπ​+γPπ​vπ​​\",\"其中,\",\"vπ​=[vπ​(s1​),…,vπ​(sn​)]T∈Rn\",\"rπ​=[rπ​(s1​),…,rπ​(sn​)]T∈Rn\",\"Pπ​∈Rn×n, where [Pπ​]ij​=pπ​(sj​∣si​), 表示状态转移矩阵.\"]},\"47\":{\"h\":\"3. Why to slove state value\",\"t\":[\"为了进行 Policy evaluation, 即对于给定策略，求出其对应状态的 state value 的过程。\",\"通过 Bellman euqation 进行求解。\",\"The closed-form solution(不常用):\",\"vπ​=(I−γpπ​)−1rπ​​\",\"An iterative solution(一种迭代策略):\",\"vk+1​=rπ​+γPπ​vk​​\",\"可以最开始均初始化为 0 , 然后进行不断迭代，可以得到一个序列v0​,v1​,v2​,…. 最终可以证明：vk​→vπ​=(I−γpπ​)−1rπ​,k→∞\"]},\"48\":{\"h\":\"4. Action value\",\"t\":[\"State value: agent从一个状态出发可以得到的平均return. the average return the agent can get starting from a state\",\"Action value: agent从一个状态出发，采取一个指定的action可以得到的平均return。 the average return the agent can get starting from a state and taking an action.\",\"通过求解 action value 我们可以分析出在该状态下采取哪个 action 收益最大. Action value 定义:\",\"qπ​(s,a)=E[Gt​∣St​=s,At​=a]​\",\"同样地，qπ​(s,a)是依赖于策略π的，并且与状态 s 和动作 a 有关.\",\"vπ​(s)E[Gt​∣St​=s]​​=a∑​qπ​(s,a)E[Gt​∣St​=s,At​=a]​​π(a∣s)\",\"因此，vπ​(s)=∑a​qπ​(s,a)π(a∣s) 由于,\",\"vπ​(s)=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)]​\",\"所以，qπ​(s,a)=∑r​p(r∣s,a)r+γ∑s′​p(s′∣s,a)vπ​(s′)\",\"实际意义是：在当前状态s下采取动作 a 所获得的均值，加上 γ 的转到下一个状态的 state value 加权均值。\",\"引入 action value 后，对于 state value 实际意义的解释：在当前状态s下，根据策略π, 所有可能动作的 action value 的加权均值。\",\"state value 和 action value 可以互相转化。\"]},\"49\":{\"h\":\"5. 总结\",\"t\":[\"State value: vπ​(s)=E[Gt​∣St​=s]\",\"Action value: qπ​(s,a)=E[Gt​∣St​=s,At​=a]\",\"State value 是 action value 的根据策略π加权平均，即vπ​(s)=∑a​π(a∣s)q(s,a)\",\"The Bellman equation (elementwise form and matrix-vector form)\",\"求解 the Bellman equation (2种方法)\"]},\"50\":{\"c\":[\"academic\"]},\"51\":{\"c\":[\"强化学习\"]},\"52\":{\"h\":\"RL3 - 贝尔曼最优公式\",\"t\":[\"Core concepts: optimal state value and optimal policy\",\"A fundamental tool: the Bellman optimality equation (BOE)\"]},\"53\":{\"h\":\"1. Optimal policy\",\"t\":[\"最优策略的定义: A policy π∗ is optimal if π∗(s)≥vπ​(s) for all s and for any other policy π. 需要确定几件事:\",\"最优策略是否存在 存在，根据 the contraction mapping Theorem.\",\"最优策略是否唯一 唯一，根据 the contraction mapping Theorem.\",\"最优策略是 stochastic 还是 deterministic deterministic 且 greedy\",\"如何得到最优策略 选取状态中最大的 action value 作为下一步的 action\"]},\"54\":{\"h\":\"2. Bellman optimality equation (BOE)\"},\"55\":{\"h\":\"2.1 基本形式\",\"t\":[\"对于贝尔曼最优公式而言，其策略π表示的是最优策略，除了需要求解 state value 外，还需要求解最优策略π.elementwise form:\",\"vπ​(s)​=πmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)),∀s∈S=πmax​a∑​π(a∣s)q(a,s),∀s∈S​\",\"matrix-vector foem:\",\"v=πmax​(rπ​+γPπ​v)​\"]},\"56\":{\"h\":\"2.2 如何求解\",\"t\":[\"对于贝尔曼最优公式而言，区别于贝尔曼公式，只是求解各状态的 state value, 我们还需要理解其所描述的最优策略π∗ 具体分两步:\"]},\"57\":{\"h\":\"2.2.1 如何处理等式右边的 (最优策略)\",\"t\":[\"vπ​(s)=maxπ​∑a​π(a∣s)q(s,a), 为了让右边取到最大值的情况，我们只需要在当前状态下，保证选取最大的 action value 即可，对应策略表示为:\",\"π(a∣s)={10​a=a∗a=a∗​\",\"其中a∗表示在该状态下计算出来的最大 action value 对应的动作，即a∗=argmaxa​q(s∣a)\"]},\"58\":{\"h\":\"2. 求解 state value\",\"t\":[\"将 BOE 转换为 v=f(v) 的形式，其中f(v):=maxπ​(rπ​+γPπ​v)f(v)对应一个向量, [f(v)]s​=maxπ​∑a​π(a∣s)q(s∣a),∀s∈S\",\"求解方法：\",\"Fix point: f(x)=x\",\"Contraction mapping(contractive function): ∣∣f(x1​)−f(x2​)∣∣≤γ∣∣x1​−x2​∣∣\",\"由此可以根据Contraction Mapping Theorem: For any equation that has the form of x=f(x), if f is a contraction mapping, then\",\"Existence: 存在不动点x∗，满足f(x∗)=x∗\",\"Uniqueness: 不动点x∗是唯一的\",\"Algorithm: Consider a sequence xk​ where xk+1​=f(xk​), then xk​→x∗ as k→∞. Moreover, the convergence rate is exponentially fast.\",\"因此，可以通过Contraction Mapping Theorem来求解贝尔曼最优公式，因为其满足该理论，即f(v)是一个contraction mapping。\"]},\"59\":{\"c\":[\"academic\"]},\"60\":{\"c\":[\"强化学习\"]},\"61\":{\"h\":\"RL4 - 值迭代和策略迭代(动态规划)\",\"t\":[\"贝尔曼最优公式:\",\"v=f(v)=πmax​(rπ​+γPπ​v)\"]},\"62\":{\"h\":\"1. Value iteration algorithm\",\"t\":[\"根据 chapter 3 中涉及的 contraction mapping theorem, 我们可以通过对应的迭代算法来求解贝尔曼最优公式\",\"vk+1​=f(vk​)=πmax​(rπ​+γPπ​vk​),k=1,2,3…\",\"这种迭代算法称为 value iteration.\"]},\"63\":{\"h\":\"1.1 具体步骤\",\"t\":[\"共分为 2 步：\",\"Policy update 这步是更新策略π，即求解右边的式子，πk+1​=argmaxπ​(rπ​+γPπ​vk​), 其中vk​是给定的。 其对应的 elementwise form:\",\"πk+1​(s)=πargmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)v(s′)),s∈S 由于 p(s′∣s,a),p(r∣s,a),v(s′) 是已知的，显然，这里的最优策略πk+1​是一个 greedy policy，我们只需要挑选在当前迭代下最大的 action value 就好了, 即:\",\"πk+1​(a∣s)={10​a=ak∗​(s)a=ak∗​(s)​ 其中ak∗​(s)=argmaxa​qk​(a,s).\",\"value update 根据 Policy update 的策略πk+1​, 求解下一步的vk+1​, 即\",\"vk+1​=rπk+1​​+γPπk+1​​vk​这里的vk​并不是 state value 由于πk+1​是 greedy 的，对应的vk+1​(s)=maxa​qk​(a,s)\"]},\"64\":{\"h\":\"1.2 伪代码\",\"t\":[\"20240810190018\"]},\"65\":{\"h\":\"2. Policy iteration algorithm\",\"t\":[\"算法迭代示意图:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\"]},\"66\":{\"h\":\"2.1 算法描述\",\"t\":[\"首先随机设计一个初始的策略π0​\",\"Step 1: policy evaluation (PE) 策略评估 该步骤是用来计算当前策略 πk​ 的 state value. 可以通过 Bellman equation 进行求解，即:\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"根据对应的 Elementwise form:\",\"vπk​(j+1)​(s)=a∑​πk​(a∣s)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​(j)​(s′)),s∈S\",\"由此进行迭代，直到设置的收敛条件为止，即j→∞ 或者 ∣∣vπk+1​(j+1)​(s)−vπk​(j)​(s)∣∣≤δ.\",\"Step 2: policy improvement (PI) 策略提升 该步骤是根据 PE 所求出的 state value, 根据 action value，来提升当前策略 πk​\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"对应的 Elementwise form:\",\"πk+1​(s)=πargmax​a∑​πk​(a∣s)qπk​​(s,a)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​​(s′))​​,s∈S\",\"这里，显然是可以通过一个 greedy 的策略来进行选择，即:\",\"πk+1​(a∣s)={10​a=ak∗​(s),a=ak∗​(s).​\",\"其中 aK∗​(s)=argmaxa​qπk​​(s,a).\"]},\"67\":{\"h\":\"2.2 伪代码\",\"t\":[\"20240811002219\"]},\"68\":{\"h\":\"2.3 一些问题\",\"t\":[\"在 PE 步骤中，如何通过 Bellman equation 得到 state value vπk​​. 根据 chapter 2 中求解 Bellman equation 的方法 一种是可以直接通过矩阵求逆进行求解，即 vπk​​=(I−γPπk​​)−1rπk​​，实际不常用. 一种是通过迭代算法来求解\",\"vπk​(j+1)​=rπk​​+γPπk​​vπk​(j)​\",\"在 PI 步骤中，如何确保策略 πk+1​ 是优于 πk​的.\",\"为什么这个迭代算法最终可以找到最优策略 每次迭代都会使得策略进行提升，那么\",\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",\"我们需要保证策略是不断提升，且最终会收敛到最优策略v∗\",\"policy iteration algorithm 与 value iteration algorithm 之间存在什么关系.\"]},\"69\":{\"h\":\"3. Truncated policy iteration algorithm\",\"t\":[\"该算法是 value iteration 以及 policy iteration 一般化的推广\"]},\"70\":{\"h\":\"3.1 value iteration 与 policy iteration 算法比较\",\"t\":[\"Policy iteration: 需要初始化策略π0​, 之后进行迭代\",\"Policy evaluation (PE): 通过 Bellman equation 求解当前策略的 state value.\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"内嵌迭代算法求解.\",\"Policy improvement (PI): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"Value iteration: 需要初始化猜测的 state value v0​\",\"Policy update (PU): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vk​)\",\"Value update (VU): 进行迭代\",\"vk+1​=rπk+1​​+γPπk+1​​vk​\",\"两个算法迭代过程十分类似: Policy iteration:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\",\"Value iteration:\",\"u0​PU​π1′​VU​u1​PU​π2′​VU​u2​PU​…\",\"Policy iteration algorithm\",\"Value iteration algorithm\",\"Comments\",\"1) Policy:\",\"π0​\",\"N/A\",\"2) Value:\",\"vπ0​​=rπ0​​+γPπ0​​vπ0​​\",\"v0​:=vπ0​​\",\"对于 policy iteration，vπ0​​是通过迭代算法来求的; 而 value iteration 我们这里强行初始化为vπ0​​，方便后续比较\",\"3) Policy:\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"在策略更新上，这两个算法是一致的。\",\"4) Value:\",\"vπ1​​=rπ1​​+γPπ1​​vπ1​​\",\"v1​=rπ1​​+γPπ1​​v0​\",\"对于 Policy iteration 而言, 这里需要通过迭代算法来精确求出 vπ1​​; 对于 Value iteration，则只是进行一次带入求解。\",\"5) Policy:\",\"π2​=argmaxπ​(rπ​+γPπ​vπ1​​)\",\"π2′​=argmaxπ​(rπ​+γPπ​v1​)\",\"⋮\",\"⋮\",\"⋮\",\"⋮\"]},\"71\":{\"h\":\"3.2 Truncated policy iteration algorithm\",\"t\":[\"20240811010933\",\"显然，在求解 Bellman equation 中，Value iteration 只是进行了一步求解，而 Policy iteration 进行了无穷多步来进行了真实的求解 state value，显然在现实运行算法中是无法做到的。 因此 Truncated policy iteration algorithm 就是进行迭代 n 步来求解。\"]},\"72\":{\"h\":\"truncated policy iteration algorithm 是否是收敛的\",\"t\":[\"20240811011334\"]},\"73\":{\"c\":[\"academic\"]},\"74\":{\"c\":[\"强化学习\"]},\"75\":{\"h\":\"RL5 - 蒙特卡洛方法 (Monte Carlo) model-free\",\"t\":[\"如何在没有模型 (即p(r∣s,a),p(s′∣s,a)等均未知) 的情况下进行估计 通过 Monte Carlo estimation. 其核心思想是： 若有一系列(i.i.d)样本采样，得到一个样本序列x1​,x2​,…,xN​ 那么对于随机变量X的估计可以为：\",\"E[x]≈xˉ=N1​j=1∑N​xj​\",\"该方法成立的数学依据是 大数定理 (Law of Large Numbers)样本必须是独立同分布(iid, independent and identically distributed)\",\"为什么考虑 mean estimation. 因为无论是 state value 还是 action value 其原始定义都是从期望出发的。\",\"vπ​(s)=E[Gt​∣St​=s];qπ​(s,a)=E[Gt​∣St​=s,At​=a]\"]},\"76\":{\"h\":\"1. MC Basic\",\"t\":[\"最简单的示例算法，用于解释 MC 的原理，但现实场景中不太经常使用，效率过低。\",\"核心思想：如何将 Policy iteration algorithm 转换为 model-free 的情况。\"]},\"77\":{\"h\":\"1.1 算法思路\",\"t\":[\"Policy iteration 算法的核心是 先根据当前策略计算出各个状态的 state value， 再将 state value 转换为 action value，更新策略的步骤就是选择此时 action value 最大的 action.\",\"{Policyevaluation:vπk​​=rπk​​+γPπk​​vπk​​Policyimprovement:πk+1​=argmaxπ​(rπ​+γPπ​vπk​​)​\",\"显然其核心关键就是在 PE 中 通过迭代算法求解 Bellman equation 的 state value后：\",\"对于 model-based 的情况, 因为 p(r∣s,a),p(s′∣s,a) 已知，我们可以很轻松的求出各个情况下的q(s,a)，从而选择每个状态下最大的 action value 即可。\",\"qπk​​(s,a)=r∑​p(r∣s,a)+γs′∑​p(s′∣s,a)vπk​​(s)\",\"对于 model-free 的情况，此时 p(r∣s,a),p(s′∣s,a) 未知，我们不能通过之前的方法来求出q(s,a)，需要从 action value 的定义出发，即：\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]\",\"从此可以发现，我们可以通过前面所引入的 mean estimation 方法，来进行求解 q(s,a).\"]},\"78\":{\"h\":\"1.2 如何估计\",\"t\":[\"从指定的 (s,a) 出发，根据策略 πk​, 我们可以生成一个 episode.\",\"这个 episode 的 return 为 g(s,a).\",\"显然，g(s,a) 就是前面 Gt​ 的一个 sample.\",\"假设我们有了一系列 从状态 s 出发, 采取动作 a 的 episodes, 即 g(j)(s,a). 那么我们可以对 qπk​​(s,a) 进行估计，即\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]≈N1​i=1∑N​g(i)(s,a).\"]},\"79\":{\"h\":\"1.3 具体算法\",\"t\":[\"与 Policy iteration algorithm 步骤类似 首先初始化一个随机的策略π0​，然后进行迭代，对于 kth 迭代，有：\",\"Step 1: Policy evaluation. 求在策略πk​下所有的 action value, q(s,a). 具体求解方法，如 1.2 节所述，只不过我们此时需要遍历所有的 action-state pair. 为什么不去求 state value，因为最终策略更新的核心仍然是 action value, 即使先估计了 state value, 我们仍需要估计 action value.\",\"Step 2: Policy improvement. 这是来求解 πk+1​(s)=argmaxπ​∑a​π(a∣s)qπk​​(s,a),foralls∈S 这个仍然与之前一致，采用 greedy policy，即对于每个状态，我们选取其 action value 最大的 action.πk+1​(ak∗​∣s)=1，其中ak∗​=argmaxa​qπk​​(s,a)\",\"20240811233346\"]},\"80\":{\"h\":\"2. MC Exploring Starts\",\"t\":[\"MC Exploring Starts 是针对 MC Basic 的一些改进，即对于数据(experience)更加高效利用。\"]},\"81\":{\"h\":\"2.1 Episode 的高效利用\",\"t\":[\"Visit: every time a state-action pair appears in the episode, it is called a visit of that state-action pair.\",\"考虑一个 episode, 跟随策略π,\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…\",\"对于 MC-Basic, 这一条 episode 仅用作估计 state-action pair (s1​,a2​) 的 action value q(s1​,a2​)，但存在一定的浪费, 对于一个 episode, 可以拆分为多个 episode, 从而进行多次利用.\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s1​a2​​s2​a3​​s5​a1​​…s2​a3​​s5​a1​​…s5​a1​​…​[originalepisode][episodestartingfrom(s2​,a4​)][episodestartingfrom(s1​,a2​)][episodestartingfrom(s2​,a3​)][episodestartingfrom(s5​,a1​)]​\",\"这样，我们不仅可以用来估计q(s1​,a2​), 还可以估计q(s2​,a4​),q(s2​,a3​)…\",\"Data-efficient methods:\",\"first-visit method 记录在 episode 中第一次出现的 state-action pair, 如果该 state-action pair 再次出现, 不记录 action value 估计中.\",\"every-visit method 对于每个 state-action pair, 都记录 action value 估计中.\"]},\"82\":{\"h\":\"2.2 高效地更新 Policy\",\"t\":[\"什么时候更新策略也是一个影响效率的因素。\",\"方法1：如 MC Based 一样，在收集到了足够多的 从给定的 state-action pair 出发的 episodes 后, 通过 mean estimation 估计了q(s,a)后, 才进行更新。 缺点，等候时间过长，只有当所有 episodes 均收集完，才能进行 策略更新。\",\"方法2：直接 uses the return of a single episode to approximate the action value. 这类算法统称为：Generalized policy iteration (GPI). 它会在 Policy-evaluation 和 policy-improvement 中不断切换，即不需要完全精确地求出 action value，就直接去更新策略。\"]},\"83\":{\"h\":\"2.3 MC Exploring Starts\",\"t\":[\"20240812004534\"]},\"84\":{\"h\":\"2.4 Exploring Statrts的解释\",\"t\":[\"Exploring 表示对于每一个 action-state pair (s,a), 都需要有多个 episodes, 这样才能去估计相应的qπ​(s,a). 如果存在一个 action value 未能访问，就不能确保所选择的 action 是最优的。\",\"Starts 表示对于对应 action-state pair (s,a) 的 episodes，每次都是从对应的状态 s 出发，选择对应的动作 a 进行的采样。 如果从其他状态出发，得到的 episode，如果经过了 (s,a)，那么这称为 visit , 但目前无法保证 visit 一定可以遍历所给定的 (s,a).\",\"据目前而言，Exploring Starts 是一个必要条件.\"]},\"85\":{\"h\":\"3. MC Eplison-Greedy\",\"t\":[\"将 Exploring Starts 条件转换掉，通过采取 Soft Policies 的方法。\"]},\"86\":{\"h\":\"3.1 Soft Policy\",\"t\":[\"A policy is called soft if the probability to take any action is positive. 显然 soft policy 是 stochastic 的，并且如果按照这样一个策略，在 episode 足够长的情况下，我们可以确保其可以遍历所有的 state-action pair.\"]},\"87\":{\"h\":\"3.2 -greedy policy\",\"t\":[\"在这里，我们采用的是 ϵ-greedy policies, 其属于 soft policies.\",\"π(a∣s)={1−∣A(s)∣ϵ​(∣A(s)∣−1),∣A(s)∣ϵ​,​forthegreedyaction,fortheother∣A(s)∣−1action,​\",\"其中 ϵ∈[0,1] 且 ∣A(s)∣ 为状态 s 的动作数量.ϵ-greedy policy 可以平衡 exploitation 和 exploration. 显然ϵ=0, policy 就是 greedy 的; 如果ϵ=1, 此时就是随机策略，其探索性就很强.\"]},\"88\":{\"h\":\"3.3 -greedy policy 引入 MC-based 算法中\",\"t\":[\"对于 MC Basic 以及 MC Exploring 中的 policy improvement 中，找的是在所有可能策略中的最优策略，因此是一个确定的贪心策略。\",\"20240812011140\"]},\"89\":{\"h\":\"3.3 算法流程\",\"t\":[\"20240812010538\"]},\"90\":{\"c\":[\"academic\"]},\"91\":{\"c\":[\"强化学习\"]},\"92\":{\"h\":\"RL6 - 随机近似理论与随机梯度下降算法\",\"t\":[\"针对 mean estimation 问题进行研究，因为在 RL 中 无论是 state value 还是 action value 其定义都是一个均值 (means)\",\"Stochastic approximation(SA): SA refers to a broad class of stochastic iterative algorithms soloving root finding or optimization problems.\"]},\"93\":{\"h\":\"1. 引言\"},\"94\":{\"h\":\"1.1 求均值的方法\",\"t\":[\"第一种：直接通过 E[x]≈xˉ:=N1​∑i=1N​xi​，进行估计，只有当样本全部收集完才能估计.\",\"第二种: 增量式的迭代算法. 假设:\",\"wk+1​=k1​i=1∑k​xi​,k=1,2,…\",\"对应的\",\"wk​=k−11​i=1∑k−1​xi​,k=2,3,…\",\"那么，wk+1​可以由wk​推导出来，即\",\"wk+1​​=k1​∑i=1k​xi​​=k1​(∑i=1k−1​xi​+xk​)=k1​((k−1)wk​+xk​)​=wk​−k1​(wk​−xk​)​\",\"因此，wk+1​=wk​−k1​(wk​−xk​)\"]},\"95\":{\"h\":\"2. Robbins-Monto(RM) algorithm\"},\"96\":{\"h\":\"2.1 问题引入\",\"t\":[\"假设我们需要求解如下方程:\",\"g(w)=0\",\"其中, w∈R 且需要被求解出来，g:R→R 为一个函数方程. 显然，如果对于 g(w) 已知的情况，我们可以通过一些特定的算法进行求解。 如果 g(w) 未知，就需要新的算法进行解决。\"]},\"97\":{\"h\":\"2.2 算法介绍\",\"t\":[\"RM 算法就可以用来求解当 g(w) 未知时的情况，即函数 g(w) 是一个黑盒，我们只能通过 输入序列: wk​, 得到含有噪音的观测值序列: g​(wk​,ηk​) 具体解决如下:\",\"wk+1​=wk​−ak​g​(wk​,ηk​),k=1,2,3,…\",\"其中:\",\"wk​ 是第 k 次方程根的估计.\",\"g​(wk​,ηk​)=g(wk​)+ηk​ 是第 k 次的观测值(含噪音).\",\"ak​ 是一个 positive coefficient.\"]},\"98\":{\"h\":\"2.3 收敛性分析\",\"t\":[\"Robbins-Monro Theorem In the Robbins-Monro algorithm, if\",\"0<c1​≤▽w​g(w)≤c2​,forallw; 要求g(w)必须是递增的，确保根是存在且唯一的。\",\"∑k=1∞​ak​=∞ 且 ∑k=1∞​ak2​<∞;∑k=1∞​ak2​=∞ 保证 ak​→0,k→0∑k=1∞​ak​=∞ 保证 ak​→0不要过快.\",\"E[ηk​∣Hk​]=0 且 E[ηk2​∣Hk​]<∞; 其中Hk​=wk​,wk−1​,…, 那么 wk​ converges with probability 1 (w.p.1) to the root w∗ satisfying g(w∗)=0.\",\"ak​=k1​是满足上面三个条件的. 但实际上我们往往是选择一个非常小的常数。\"]},\"99\":{\"h\":\"2.4 应用于 mean estimation 中\",\"t\":[\"比如我们要估计某个随机变量X的 E[X] 我们可以设计如下方程:\",\"g(w)≐w−E[X].\",\"那么只要求解 g(w)=0, 我们就可以得到 E[X] 的值。 同样，我们不能直接得到随机变量的值，而是对应的样本 x，sample of X. 即，我们得到的观测值是:\",\"g​(w,x)≐w−x\",\"我们可以修改为噪音 η 的形式，\",\"g​(w,η)​=w−x​=w−x+E[X]−E[X]=(w−E[X])+(E[X]−x)​≐g(w)+η​\",\"因此我们可以通过 RM 算法来进行求解\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​(wk​−xk​)\"]},\"100\":{\"h\":\"3. Stochastic gradient descent\"},\"101\":{\"h\":\"3.1 问题引入\",\"t\":[\"需要求解一个优化问题:\",\"wargmin​J(w)=E[f(w,X)]\",\"其中，\",\"w 是需要被优化的参数\",\"X 是一个随机变量\",\"w 和 X 可以是标量，也可以是向量. 对于函数 f(⋅) 输出为标量.\",\"对于这个问题，我们有以下几种方法:\",\"Method 1: 梯度下降法 (gradient descent, GD)\",\"wk+1​=wk​−αk​▽w​E[f(wk​,X)]=wk​−αk​E[▽w​f(wk​,X)]\",\"但由于 j(w) 是一个期望值，我们很难直接获得.\",\"Method 2: batch gradient descent (BGD) 借用 MC 的思想，我们可以将:\",\"E[▽w​f(wk​,X)]≈n1​i=1∑n​▽w​f(wk​,xi​).\",\"因此\",\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f(wk​,xi​)\",\"但需要大量的 samples 收集完毕才能进行一次迭代.\",\"Method 3: 随机梯度下降(SGD) 考虑能否仅用一次 sample 进行迭代.\",\"wk+1​=wk​−αk​▽w​f(wk​,xk​)\",\"但能否保证其精确度，以及是否可以到最后优化的成果。\"]},\"102\":{\"h\":\"3.2 SGD 分析\"},\"103\":{\"h\":\"mean estimation 问题转化\",\"t\":[\"我们可以将 均值估计 问题 转化为 一个 优化问题 进行求解：\",\"20240814014058\"]},\"104\":{\"h\":\"SGD 正确性和收敛性分析\",\"t\":[\"从 GD 到 SGD:\",\"wk+1​=wk​−αk​E[▽w​f(wk​,X)]⇓wk+1​=wk​−αk​▽w​f(wk​,x)​\",\"显然我们可以将 ▽w​f(wk​,x) 视为 E[▽w​f(wk​,x)] 的一个观测值(含噪声):\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]+η▽w​f(wk​,x)−E[▽w​f(wk​,x)]​​\",\"因为\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]\",\"因此，我们需要思考使用 SGD 时wk​→w∗ as k→∞ 是否成立。\",\"我们可以将 SGD 视为一个特殊情况下的 RM 算法 SGD的目标是 minimize\",\"J(w)=E[f(w,X)]\",\"而最小值问题，往往可以转化为导数为 0 的情况,\",\"▽w​J(w)=E[▽w​f(w,X)]=0\",\"显然，可以参考 RM 算法, 让\",\"g(w)=▽w​J(w)=E[▽w​f(w,X)]\",\"从而转换为一个 root-finding 问题. 相应的，对于观测值g​(w,η),\",\"g~​(w,η)​=∇w​f(w,x)=g(w)E[∇w​f(w,X)]​​+η∇w​f(w,x)−E[∇w​f(w,X)]​​.​\",\"因此，我们就可以通过 RM 算法进行求解g(w)=0,\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​▽w​f(wk​,xk​)\",\"对应收敛性证明\"]},\"105\":{\"h\":\"3.3 SGD 另一种问题描述方法 (deterministic formulation)\",\"t\":[\"在之前关于使用 SGD 算法的问题描述中，我们是引入了 随机变量 和 期望的情况. 我们可以将这个问题可以转化为一个随机变量的方法，从而引入 SGD 算法.\"]},\"106\":{\"h\":\"3.4 BGD MBGD SGDw\",\"t\":[\"20240814230747\"]},\"107\":{\"c\":[\"academic\"]},\"108\":{\"c\":[\"强化学习\"]},\"109\":{\"h\":\"RL7 - Temporal-Difference Learning\"},\"110\":{\"h\":\"1. 引入\",\"t\":[\"考虑一个复杂的均值估计问题: 计算\",\"ω=E[R+γv(X)],\",\"其中, R, X 均是随机变量，γ 是常数，v(⋅) 表示一个函数。 显然我们仍然可以通过 RM 算法进行求解，假设我们可以得到有关随机变量 R, X 的采样 {x},{r}\",\"g(w)g~​(w,η)​=w−E[R+γv(X)]=w−[r+γv(x)]=(w−E[R+γv(X)])+(E[R+γv(X)]−[r+γv(x)])≐g(w)+η​\",\"因此，我们可以将该问题定义为一个 root-finding 问题: g(w)=0. 相应的 RM 算法为:\",\"wk+1​=wk​−αk​g~​(wk​,ηk​)=wk​−αk​[wk​−[rk​+γv(xk​)]]\"]},\"111\":{\"h\":\"2. TD Learning of state value\",\"t\":[\"求解给定策略 π 的 state value，这样就可以与 policy improvement 结合去寻找最优策略。\"]},\"112\":{\"h\":\"2.1 算法描述\",\"t\":[\"算法所需的数据(experience): 根据给定的策略 π 所生成的数据 (s0​,r1​,s1​,…,st​,rt+1​,st+1​,…) or {(st​,rt+1​,st+1​)}\",\"相应的算法是:\",\"vt+1​(st​)vt+1​(s)​=vt​(st​)−αt​(st​)[vt​(st​)−[rt+1​+γvt​(st+1​)]]=vt​(s),∀s=st​,​\",\"其中 t=0,1,2,…, vt​(st​)是关于 vπ​(st​) 的估计。\",\"newestimatevt+1​(st​)​​=currentestimatevt​(st​)​​−αt​(st​)[vt​(st​)−TDtargetvt​ˉ​[rt+1​+γvt​(st+1​)]​​]​TDerrorδt​​\"]},\"113\":{\"h\":\"2.2 算法分析\",\"t\":[\"TD 算法是用来求解一个 给定策略 π 的 Bellman equation.\",\"根据 state value 的定义，对于策略 π 的 state value\",\"vπ​(s)=E[R+γG∣S=s],s∈S\",\"其中 G 是 discounted return。\",\"E[G∣S=s]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s)=E[vπ​(S′)∣S=s]\",\"因此，我们可以写出 Bellman equation 的新形式，称为 Bellman expection equation\",\"vπ​(s)=E[E+γvπ​(S′)∣S=s],s∈S\"]},\"114\":{\"h\":\"2.3 TD 算法 与 MC 算法的比较\"},\"115\":{\"h\":\"3. TD Learning of action value\",\"t\":[\"Sarsa (state-action-reward-state-action) Sarsa 算法其目的是用于直接估计 action value, 从而可以在 policy improvement 中直接根据 action value 进行更新即可。\",\"Sarsa 算法同样是来求解 Bellman equation:\",\"qπ​(s,a)=E[R+γqπ​(S′,A′)∣s,a],∀s,a\"]},\"116\":{\"h\":\"3.1 Sarsa\",\"t\":[\"假设我们具有 some experience {(st​,at​,rt+1​,st+1​,at+1​)} 对应的 Sarsa 算法如下来进行估计 action value:\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(sa​,at​)−αt​(st​,at​)[qt​(sa​,at​)−[rt+1​+γqt​(st+1​,at+1​)]]=qt​(s,a),∀(s,a)=(st​,at​)​\",\"其中 t=0,1,2,…, qt​(st​,at​) 是qπ​(st​,at​)的估计。\",\"收敛性情况\",\"20240817000114\",\"伪代码\",\"20240817000134\",\"20240817000230\"]},\"117\":{\"h\":\"3.2 n-step Sarsa\",\"t\":[\"20240817000500\",\"20240817000601\",\"20240817000642\"]},\"118\":{\"h\":\"3.3 Expected Sarsa\",\"t\":[\"20240817000331\",\"20240817000409\"]},\"119\":{\"h\":\"4. TD Learning of optimal action value\",\"t\":[\"Q-learning 算法是用来解决 action value 形式下的贝尔曼最优公式 (Bellman optimality equation in terms of action value)\",\"q(s,a)=E[Rt+1​+γamax​q(St+1​,a)∣St​=s,At​=a],∀s,a\"]},\"120\":{\"h\":\"4.1 Q-learning\",\"t\":[\"Q-learning 直接估计的是 optimal action value，因此不需要进行 policy improvement。\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(st​,at​)−αt​(st​,at​)[qt​(st​,at​)−[rt+1​+γa∈Amax​qt​(st+1​,a)]]=qt​(s,a),∀(s,a)=(st​,at​)​\"]},\"121\":{\"h\":\"4.2. off-policy | on-policy\",\"t\":[\"behavior policy: 是用来与环境进行交互，从而生成经验数据的策略\",\"target policy: 是我们不断进行更新的策略，最终优化的策略\"]},\"122\":{\"h\":\"on - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是一致的，即我通过这个策略与环境进行交互生成一系列经验，在通过经验来更新这个策略。\"]},\"123\":{\"h\":\"off - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是不同的，即我通过一个策略与环境进行交互生成一系列经验。再通过这些经验来不断改进更新另一个策略，这另一个策略会更新到最优的策略。\",\"Sarsa，MC 是 on-policy 的 Q-learning 是 off-policy 的\"]},\"124\":{\"h\":\"4.3 Q-learning 伪代码\",\"t\":[\"因为 Q-learning 是 off-policy 的，因此，如果我们强制让 target policy 与 behavior ppolicy 一致也是可以的，此时也可以是 on-policy 的。\"]},\"125\":{\"h\":\"off-poicy 版本\",\"t\":[\"20240818182057\",\"此时 target policy 就不需要是 ϵ−greedy 策略了，因为不需要 target policy 进行生成数据。\"]},\"126\":{\"h\":\"on-policy 版本\",\"t\":[\"20240818181917\"]},\"127\":{\"h\":\"5. TD 算法的统一形式和总结\",\"t\":[\"20240818182301\",\"20240818182231\"]},\"128\":{\"c\":[\"academic\"]},\"129\":{\"c\":[\"强化学习\"]},\"130\":{\"h\":\"RL8 - 值函数近似(Value Function Approximation)\",\"t\":[\"对于 q-value 的估计从 基于表格的 (tabular representation) 转换到 基于函数的 (function representation)\"]},\"131\":{\"h\":\"1. 引入\",\"t\":[\"通过使用一个函数来进行拟合 state values 或者 action values: v^(s,w)≈vπ​(s)， 其中w∈Rm是参数向量。\",\"可以提高存储效率\",\"提高泛化能力\"]},\"132\":{\"h\":\"2. Alogorithm of state value estimation\",\"t\":[\"目标: 寻找一个最优的参数w，使得v^(s,w)最接近真实的vπ​(s).\",\"共两步:\",\"定义目标函数\",\"优化目标函数的算法\"]},\"133\":{\"h\":\"2.1 Obejctive function\",\"t\":[\"J(w)=E[(vπ​(S)−v^(S,w))2]\",\"分析随机变量 S 的 probability distribution (即对于损失函数中的 expection 需要考虑怎样对状态进行平均):\"]},\"134\":{\"h\":\"uniform distributon\",\"t\":[\"认为所有状态都是同等重要的，即各个状态的可能性为∣S∣1​ 因此这种情况下的 objective function 可以写成:\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=∣S∣1​s∈S∑​(vπ​(s)−v^(s,w))2\",\"但实际情况可能并不是所有状态的概率都是一致的，基于给定策略下，一些状态可能很少被访问，另一些则频繁被访问，因此采用这种 objective function 就不太可行。\"]},\"135\":{\"h\":\"stationary distribution\",\"t\":[\"stationary: 表示是一种长时间的交互行为\",\"distributon: 表示是 状态 的分布\",\"通常也称为 steady-state distributon or limiting distributon.\",\"describes the long-run behavior of a Markov process. 即基于一个策略，我们不断地与环境进行交互，最终会达到一个平稳的状态，此时可以分析每一个状态在这个策略下的概率。\",\"设 {dπ​(s)}s∈S​ 表示 基于策略 π 下的 stationary distribution。其中 dπ​(s)≥0 且 ∑s∈S​dπ​(s)=1\",\"那么此时的 objective function 可以表示为：\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=s∈S∑​dπ​(s)(vπ​(s)−v^(s,w))2\",\"20240820181406\",\"20240820181718\"]},\"136\":{\"h\":\"2.2 Optimization algorithms 优化算法\",\"t\":[\"目前的优化算法只是在估计给定策略的 statevalue\",\"minisize obejctive function J(w), 采用 梯度下降 算法:\",\"wk+1​=wk​−αk​▽w​J(wk​)\",\"对应目标函数的真实梯度是：\",\"▽w​j(w)​=▽w​E[(vπ​(S)−v^(S,w))2]=E[▽w​(vπ​(S)−v^(S,w))2]=−2E[(vπ​(S)−v^(S,w))▽w​v^(S,w)]​\",\"这里包含了一个 Expection，因此可以考虑 SGD 方法进行求解：\",\"wk+1​=wk​+αk​(vπ​(st​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\",\"其中st​是随机变量S的一个样本。 但这里还有一个难点，vπ​(st​) 我们是无法估计的，这是我们所求的量，因此需要用近似算法来进行替代，从而使得算法可行。\"]},\"137\":{\"h\":\"Monte Carlo learning with function approximation\",\"t\":[\"设 gt​ 表示在一个 episode 中，从状态 st​ 出发的 discounted return。因此我们用 gt​ 来近似 vπ​(st​), 即：\",\"wk+1​=wk​+αk​(gt​−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"138\":{\"h\":\"TD Learning with function approximation\",\"t\":[\"在 TD 算法中，我们将 rt+1​+γv^(st+1​,wt​) 来近似 vπ​(st​), 因此对应算法为：\",\"wk+1​=wk​+αk​(rt+1​+γv^(st+1​,wt​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"139\":{\"h\":\"3. Sarsa with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γq^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"20240820184127\"]},\"140\":{\"h\":\"4. Q-learning with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γa∈A(st+1​)max​q^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"on-policy版本：\",\"20240820184405\"]},\"141\":{\"h\":\"5. Deep Q-learning (DQN)\",\"t\":[\"Deep Q-learning 目的是最小化目标函数(objective/loss function):\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"其中 (S,A,R,S′) 均是随机变量。\"]},\"142\":{\"h\":\"优化方法\",\"t\":[\"采用梯度下降。\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"对于 q^​(S,A,w) 求解梯度还是很好求的。 但对于 maxa∈A(S′)​q^​(S′,a,w) 其求解梯度比较难求，在 DQN 中采用一个 固定 的方法进行解决。 尝试将 y≐R+γmaxa∈A(S′)​q^​(S′,a,w) 中的 w 进行固定求解，具体如下：\",\"引入两个网络：\",\"main network q^​(s,a,w)w 会一直进行更新，根据梯度下降的公式。\",\"target network q^​(s′,a,wT​) 并不是一直进行更新，而是等 main network 更新一定次数后，将该网络的 w 复制到 wT​ 中\",\"将 objective function 修改为：\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))2]\",\"在计算 main network q^​(s,a,w) 的梯度时，将 q^​(S′,a,wT​) 中的 wT​ 固定不动，因此左侧那个类似 TD target 的就不是有关 w 的函数，不用进行求导，从而方便计算。 然后在更新了一定次数之后，在将 wT​=w 进行赋值。\",\"因此对应的损失函数的梯度可以修改为：\",\"▽w​J​=E[−2(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))▽w​q^​(S,A,w)]=E[−2(YT​−q^​(S,A,w))▽w​q^​(S,A,w)]​\",\"一些细节:\",\"w 和 wT​ 表示 the main and target networks 的参数，在初始化的时候是设为相同的。\",\"在每一次迭代时，我们需要从经验池 (the replay buffer) 中取出一定数量的样本 (a mini-batch of samples {(s,a,r,s')}) 进行训练。\",\"网络的输入包括 状态 s 和 动作 a. 在训练求解梯度时，我们先直接求解 target network 的输出，视为 yT​≐r+γmaxa∈A(s′)​q^​(s′,a,wT​)。 然后我们通过 mini-batch 样本 {(s,a,yT​)}, 通过梯度的算法来最小化对应的损失函数, 假设有 N 个样本，那么对应的损失函数求解为：\",\"J(w)=i=1∑N​yT​−q^​(s,a,w) 即可以通过梯度下降，来更新参数值\",\"wt+1​=wt​+αt​N1​i=1∑N​(yT​−q^​(si​,ai​,wt​))⋅▽w​q^​(si​,ai​,wt​)\"]},\"143\":{\"h\":\"经验回放 (replay buffer)\",\"t\":[\"20240820230827\",\"20240820230920\",\"20240820230944\"]},\"144\":{\"h\":\"伪代码\",\"t\":[\"20240820231024\",\"但在发表 DQN 的文章中，不太一样，在原文是 on-policy 且 main network 的输出是不一样的。\",\"20240820231205\"]},\"145\":{\"c\":[\"academic\"]},\"146\":{\"c\":[\"强化学习\"]},\"147\":{\"h\":\"RL9 - 策略梯度法(Policy gradient)\",\"t\":[\"之前介绍的方法都是 value-based 的方法，从这章开始时基于 policy-based 的方法。\",\"policy function approximation 是直接建立一个基于策略的目标函数来进行梯度上升的优化。\"]},\"148\":{\"h\":\"1. 基本思路\",\"t\":[\"将基于表格表示的策略 转换为 基于函数表示的策略。 即此时策略 π 可以描述为：\",\"π(a∣s,θ)\",\"其中，θ∈Rm表示参数向量，是我们需要进行优化的。\",\"当策略是以表格的形式保存时，我们定义最优的策略为 在该策略下的所有 state value 都是最大的。\",\"当策略是以函数的形式存在时，我们定义 最优的策略 为 可以最大化一个确定的常数指标(certain scalar metrics).\",\"Policy gradient 的基本步骤：\",\"确定 metrics/objective function，来定义最优的策略：J(θ)\",\"进行优化，如梯度上升算法\",\"θt+1​=θt​+α▽θ​J(θt​)\"]},\"149\":{\"h\":\"2. 目标函数定义\"},\"150\":{\"h\":\"2.1 average state value\",\"t\":[\"vˉπ​=s∈S∑​d(s)vπ​(s)=dTvπ​\",\"vˉπ​ 显然是 state value 的加权平均。\",\"d(s)≥0 是各个 state 的权重\",\"∑s∈S​d(s)=1, 我们可以认为 d(s) 是 概率分布，因此该指标可以描述为:\",\"vˉπ​=ES∼d​[vπ​(S)]\"]},\"151\":{\"h\":\"另一种表达\",\"t\":[\"J(θ)=E[t=0∑∞​γtRt+1​]\",\"20240826173749\"]},\"152\":{\"h\":\"d(s)的选择\",\"t\":[\"d 与策略 π 无关 这种情况我们将 d 表示为 d0​, vˉπ​ 表示为 vˉπ0​. 这种情况下的 d 可以根据对各个状态的重要程度进行选择： 一种是将所有状态视为同等重要，一种则是有所偏向。\",\"d 与策略 π 有关 d 表示为 dπ​(s), 即在策略 π 下的 stationary distribution。\"]},\"153\":{\"h\":\"2.2 average return value\",\"t\":[\"rˉπ​=s∈S∑​dπ​(s)rπ​(s)=ES∼d​[rπ​(s)]\",\"其中:\",\"rπ​(s)r(s,a)​≐a∈A∑​π(a∣s)r(s,a)=E[R∣s,a]=r∑​rp(r∣s,a)​\",\"rπ​(s)表示在策略π下 状态s时可以得到的平均reward。r(s,a)表示在单步情况下(在状态s采用动作a)时的平均reward。\"]},\"154\":{\"h\":\"另一种表达\",\"t\":[\"假设 agent 跟随一个 给定的策略 然后生成了一个 trajectory以及对应的 rewards (Rt+1​,Rt+2​,…)\",\"对应 average single-step reward along this trajectory is\",\"====​n→∞lim​n1​E[Rt+1​+Rt+2​+⋯+Rt+n​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​]s∑​dπ​(s)rπ​(s)rˉπ​​\"]},\"155\":{\"h\":\"3. 目标函数梯度求解\",\"t\":[\"这里在视频没有详细介绍，只给出了梯度的公式：\",\"▽θ​J(θ)​=s∈S∑​η(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"其中\",\"J(θ) 可以是 vˉπ​,rˉπ​,vˉπ0​ 任何一种。\",\"\\\"=\\\" 有表示 严格等于 近似 以及 成比例等于\",\"η 表示 state 的权重或者分布\",\"具体推导过程:\",\"▽θ​lnπ(a∣s,θ)▽θ​J(θ)​=π(a∣s,θ)▽θ​π(a∣s,θ)​=s∈S∑​d(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=s∈S∑​d(s)a∈A∑​π(a∣s,θ)▽θ​lnπ(a∣s,θ)qπ​(s,a)=ES∼d​[a∑​π(s∣S,θ)▽θ​lnπ(a∣S,θ)qπ​(S,a)]=ES∼d,A∼π​[▽θ​lnπ(A∣S,θ)qπ​(S,A)]≐E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"根据这个式子我们就可以通过 SGD 方法，从而可以进行近似求解：\",\"▽θ​J(θ)≈▽θ​lnπ(a∣s,θ)qπ​(s,a)\",\"一些特性 这里的策略是随机性 的，因为我们需要计算的是 lnπ(a∣s,θ), 因此我们需要保证对于所有的 s,a,θ\",\"π(a∣s,θ)≥0\",\"20240826180244\"]},\"156\":{\"h\":\"4. REINFORCE 梯度上升算法\",\"t\":[\"梯度上升算法的本质就是最大化目标函数 J(θ)\",\"θt+1​​=θt​+α▽θ​J(θ)=θt​+αE[▽θ​lnπ(A∣S,θt​)qπ​(S,A)]​\",\"而对应的真实梯度可以用一个估计的梯度来替代:\",\"θt+1​=θt​+α▽θ​lnπ(at​∣st​,θt​)qπ​(s,a)\",\"但还存在 qπ​(s,a) 是未知的，我们也可以进行近似：\",\"θt+1​=θt​+α▽θ​lnπ(a∣s,θt​)qt​(st​,at​)\",\"这里可以用不同的方法来近似 qπ​(s,a).\",\"Monte-Carlo based method， 我们便称为 REINFORCE\",\"也可以采用基于 TD 的算法 或者 其他的算法。\",\"一些细节\",\"20240826181340\",\"20240826181538\",\"20240826181638\"]},\"157\":{\"h\":\"REINFORCE 算法\",\"t\":[\"20240826181712\"]},\"158\":{\"c\":[\"academic\"]},\"159\":{\"c\":[\"强化学习\"]},\"160\":{\"h\":\"Java - 类与对象1\"},\"161\":{\"h\":\"类与对象\",\"t\":[\"类: 是对一类事物的描述，是抽象的、概念上的定义.对象: 是某一类事物实际存在的每个个体，因而也被称为实例（instance）， 是类的一个具体化个体.\",\"类的创建: 类名的首字母通常是大写的.\",\"public class Person {//这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } \",\"对象实例的创建 new Person() :\",\"public static void main(String[] args) { Person p = new Person(); } \",\"对于对象而言，其变量名存储的是对象的引用（类似于c++指针的情况），并非是所对应的对象本身，即\",\"public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p1存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p1 = new Person(); Person p2 = p1; // 我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制 } \",\"在创建了对象之后，就可以进行一定操作，如: 访问、修改对象的属性. 不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象. 关于对象类型的变量，我们也可以不对任何对象进行引用：\",\"public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \\\"小红\\\"; //我任性，就是要操作 System.out.println(p.name); } \",\"会出现异常，即空指针异常. 对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\"]},\"162\":{\"h\":\"方法的创建与使用\",\"t\":[\"类除了具有属性外，还可以定义一些方法来描述同一类的行为。 方法是语句的集合，是为了完成某件事情而存在的。 方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\",\"方法的定义如下:\",\"返回值类型 方法名称() { 方法体... } \",\"具体而言:\",\"public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\\\"我叫 \\\"+name+\\\" 今年 \\\"+age+\\\" 岁了！\\\"); } } \",\"方法的调用:\",\"public static void main(String[] args) { Person p = new Person(); p.name = \\\"小明\\\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } \"]},\"163\":{\"h\":\"方法的进阶使用\"},\"164\":{\"h\":\"this 的使用\",\"t\":[\"有时候我们的方法中可能会出现一些与成员变量重名的变量：\",\"void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的 //这里实际上是将方法参数的局部变量name赋值为本身 } \",\"我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\",\"void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } \",\"当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\",\"String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } \"]},\"165\":{\"h\":\"方法的重载\",\"t\":[\"有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况。\",\"一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\",\"int sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } \"]},\"166\":{\"h\":\"构造方法\",\"t\":[\"我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？ 要在对象创建时进行处理，我们可以使用**构造方法（构造器）**来完成。\",\"构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\",\"public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \\\"小明\\\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \\\"男\\\"; } } \",\"构造方法会在new的时候自动执行, 当然，我们也可以为构造方法设定参数：\",\"public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } \",\"注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法.\",\"当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\",\"public class Person { String name = \\\"未知\\\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \\\"男\\\"; } \",\"这里需要特别注意，成员变量的初始化，并不是在构造方法之后，而是在这之前就已经完成了.\",\"Person(String name, int age, String sex){ System.out.println(this.age); // 在赋值之前看看是否有初始值 // 这里是 this.age 而非 age // 此时this.age已经初始化完，但还未复制，this.age = 0 this.name = name; this.age = age; this.sex = sex; } \",\"我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\",\"public class Person { String name; int age; String sex; { System.out.println(\\\"我是代码块\\\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\\\"我被构造了\\\"); this.name = name; this.age = age; this.sex = sex; } } \"]},\"167\":{\"c\":[\"code\"]},\"168\":{\"c\":[\"java\"]},\"169\":{\"h\":\"Java - 泛型 2\"},\"170\":{\"h\":\"泛型 2\"},\"171\":{\"h\":\"泛型方法\",\"t\":[\"当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。\",\"当某个方法（无论是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：\",\"public class Main { public static void main(String[] args) { String str = test(\\\"Hello World!\\\"); } private static <T> T test(T t){ //在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法 return t; } } \",\"泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型 T 作为参数，同样的类型 T 作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成 String 类型，因此返回值也是 String 类型。\",\"public static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \\\"Hello\\\"); System.out.println(Arrays.toString(strings)); } private <T> void add(T[] arr, T t){ arr[0] = t; } \",\"实际上泛型方法在很多工具类中也有，比如说 Arrays 的排序方法：\",\"Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; } }); \",\"比如现在我们想要让数据从大到小排列，我们就可以自定义：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr)); } \",\"因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -> o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr)); } \",\"包括数组复制方法：\",\"public static void main(String[] args) { String[] arr = {\\\"AAA\\\", \\\"BBB\\\", \\\"CCC\\\"}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr)); } \",\"因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。\"]},\"172\":{\"h\":\"泛型界限\",\"t\":[\"上界 extend\",\"下界 super 仅适用于通配符，对于类型变量来说是不支持的\",\"现在有一个新的需求，现在没有 String 类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\",\"public class Score<T extends Number> { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; } } \",\"只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：\",\"实际上就像这样：\",\"20241106133117\",\"同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：\",\"public static void main(String[] args) { Score<? extends Integer> score = new Score<>(\\\"数据结构与算法\\\", \\\"EP074512\\\", 60); } \",\"那么既然泛型有上界，那么有没有下界呢？肯定的啊：\",\"20241106133159\",\"只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：\",\"20241106133211\",\"那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\",\"public static void main(String[] args) { Score<? extends Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 } \",\"但是我们限定下界的话，因为还是有可能是 Object，所以说依然是跟之前一样：\",\"public static void main(String[] args) { Score<? super Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Object o = score.getValue(); } \",\"通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。\"]},\"173\":{\"h\":\"类型擦除\",\"t\":[\"前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？\",\"public abstract class A <T>{ abstract T test(T t); } \",\"实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：\",\"public abstract class A { abstract Object test(Object t); //默认就是Object } \",\"当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：\",\"public abstract class A <T extends Number>{ //设定上界为Number abstract T test(T t); } \",\"那么编译之后：\",\"public abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类 } \",\"因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：\",\"public static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型 } \",\"只不过此时编译器会给出警告\"]},\"174\":{\"c\":[\"code\"]},\"175\":{\"c\":[\"java\"]},\"176\":{\"h\":\"Java - 集合类 1\"},\"177\":{\"h\":\"集合类 1\"},\"178\":{\"h\":\"集合类\",\"t\":[\"集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\",\"集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。\"]},\"179\":{\"h\":\"集合类与数组区别\",\"t\":[\"集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\",\"相同之处：\",\"它们都是容器，都能够容纳一组元素。\",\"不同之处：\",\"数组的大小是固定的，集合的大小是可变的。\",\"数组可以存放基本数据类型，但集合只能存放对象。\",\"数组存放的类型只能是一种，但集合可以有不同种类的元素。\"]},\"180\":{\"h\":\"集合根接口\",\"t\":[\"所有的集合类最终都是实现自集合根接口的\",\"Java 中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\",\"import java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"树脂666\\\"); } } \",\"比如 ArrayList 类，它的祖先就是Collection接口：\",\"20241120130452\",\"public interface Collection<E> extends Iterable<E> { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator<E> iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 <T> T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection<?> c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection<? extends E> c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection<?> c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate<? super E> filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator<E> each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection<?> c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); } } \"]},\"181\":{\"h\":\"List 列表\",\"t\":[\"List 列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。\",\"List 是集合类型的一个分支，它的主要特性有：\",\"是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置\",\"列表中允许存在重复元素 (只要 集合的 equal 方法判定为 True 就是重复)\",\"List 直接继承自前面介绍的 Collection 接口，其中很多地方重新定义了一次 Collection 接口中定义的方法，这样做是为了更加明确方法的具体功能\",\"可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作\",\"//List是一个有序的集合类，每个元素都有一个自己的下标位置 //List中可插入重复元素 //针对于这些特性，扩展了Collection接口中一些额外的操作 public interface List<E> extends Collection<E> { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection<? extends E> c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator<E> operator) { Objects.requireNonNull(operator); final ListIterator<E> li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\\\"unchecked\\\", \\\"rawtypes\\\"}) default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(); //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List<E> subList(int fromIndex, int toIndex); ... } \"]},\"182\":{\"h\":\"ArrayList\",\"t\":[\"在 ArrayList 中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity < 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 } } \",\"一般的，如果我们要使用一个集合类，我们会使用接口的引用：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\\\"科技与狠活\\\"); //使用add添加元素 list.add(\\\"上头啊\\\"); System.out.println(list); //打印集合类，可以得到一个非常规范的结果 } \",\"集合的各种功能我们都可以来测试一下\",\"特别注意一下，我们在使用 Integer 时，要注意传参问题：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除 } \",\"那要是这样写呢？\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list); } \",\"可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象：\",\"//ArrayList源码部分 public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false; } \",\"列表中允许存在相同元素，所以说我们可以添加两个一模一样的：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); System.out.println(list); } \",\"那要是此时我们删除对象呢，是一起删除还是只删除一个呢？\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); list.remove(str); System.out.println(list); } \",\"这种情况下，只会删除排在前面的第一个元素。\",\"集合类是支持嵌套使用的，一个集合中可以存放多个集合\",\"public static void main(String[] args) { List<List<String>> list = new LinkedList<>(); list.add(new LinkedList<>()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty()); } \",\"在 Arrays 工具类中，我们可以快速生成一个只读的List：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); //非常方便 System.out.println(list); } \",\"注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\")); System.out.println(list); } \",\"当然，也可以利用静态代码块：\",\"public static void main(String[] args) { List<String> list = new ArrayList<String>() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\\\"A\\\"); add(\\\"B\\\"); add(\\\"C\\\"); }}; System.out.println(list); } \",\"这里我们接着介绍另一个列表实现类，LinkedList 同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { transient int size = 0; //引用首结点 transient Node<E> first; //引用尾结点 transient Node<E> last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node<E> { //内部使用的结点类 E item; Node<E> next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node<E> prev; Node(Node<E> prev, E element, Node<E> next) { this.item = element; this.next = next; this.prev = prev; } } ... } \",\"LinkedList 的使用和 ArrayList 的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。\",\"只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。\"]},\"183\":{\"c\":[\"code\"]},\"184\":{\"c\":[\"java\"]},\"185\":{\"h\":\"Java - 集合类 2\"},\"186\":{\"h\":\"集合类 2\"},\"187\":{\"h\":\"迭代器\",\"t\":[\"实际上我们的集合类都是支持使用foreach语法 (增强 for 语法) 的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); } } \",\"但是由于仅仅是语法糖，实际上编译之后会修改为 迭代器 iterator 的形式：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } \"]},\"188\":{\"h\":\"简介\",\"t\":[\"通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：\",\"20241126232114\",\"一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：\",\"20241126232128\",\"每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。\",\"至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。\"]},\"189\":{\"h\":\"源码定义\",\"t\":[\"主要方法： next() | hasNext() | remove()\",\"public interface Iterator<E> { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\\\"remove\\\"); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } } \"]},\"190\":{\"h\":\"不同集合类 迭代器 实现用例\",\"t\":[\"ArrayList 就是直接按下标访问：\",\"public E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素 } \",\"LinkedList 就是不断向后寻找结点：\",\"public E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素 } \",\"虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现.\"]},\"191\":{\"h\":\"使用示例\",\"t\":[\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 } } \",\"注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。\",\"为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { System.out.println(s); } } \"]},\"192\":{\"h\":\"其他遍历 集合类 的方式\",\"t\":[\"在 Java8 提供了一个支持 Lambda 表达式的 forEach 方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作\",\"即对于 集合类 自身存在一个 forEach 的方法：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); list.forEach(System.out::println); } \",\"这个效果跟上面的写法是完全一样的，因为 forEach 方法内部本质上也是迭代器在处理，这个方法是在 Iterable 接口中定义的：\",\"default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 } } \"]},\"193\":{\"h\":\"介绍\",\"t\":[\"20241120130452\",\"//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了 public interface Iterable<T> { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator<T> iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator<T> spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } \",\"得益于 Iterable 提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用 foreach 语法：\",\"public class Test implements Iterable<String>{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator<String> iterator() { return new Iterator<String>() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \\\"测试\\\"; } }; } } \"]},\"194\":{\"h\":\"介绍\",\"t\":[\"这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：\",\"这种迭代器因为能够双向遍历，所以说可以反复使用。\",\"public interface ListIterator<E> extends Iterator<E> { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e); } \"]},\"195\":{\"c\":[\"code\"]},\"196\":{\"c\":[\"java\"]},\"197\":{\"h\":\"Java - 集合类 3\"},\"198\":{\"h\":\"集合类 3\"},\"199\":{\"h\":\"Quene 和 Deque\",\"t\":[\"其中 LinkedList 除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable \"]},\"200\":{\"h\":\"Quene 队列\",\"t\":[\"20241127001435\",\"我们先来看看队列接口，它扩展了大量队列相关操作：\",\"public interface Queue<E> extends Collection<E> { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek(); } \",\"我们可以直接将一个 LinkedList 当做一个队列来使用：\",\"public static void main(String[] args) { Queue<String> queue = new LinkedList<>(); //当做队列使用，还是很方便的 queue.offer(\\\"AAA\\\"); queue.offer(\\\"BBB\\\"); System.out.println(queue.poll()); System.out.println(queue.poll()); } \"]},\"201\":{\"h\":\"Deque 双端队列\",\"t\":[\"普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作\",\"利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用\",\"//在双端队列中，所有的操作都有分别对应队首和队尾的 public interface Deque<E> extends Queue<E> { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator<E> descendingIterator(); } \",\"我们可以来测试一下，比如我们可以直接当做栈来进行使用：\",\"public static void main(String[] args) { Deque<String> deque = new LinkedList<>(); deque.push(\\\"AAA\\\"); deque.push(\\\"BBB\\\"); System.out.println(deque.pop()); System.out.println(deque.pop()); } \"]},\"202\":{\"h\":\"其他集合类实现 队列\",\"t\":[\"当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：\",\"public static void main(String[] args) { Deque<String> deque = new ArrayDeque<>(); //数组实现的栈和队列 Queue<String> queue = new PriorityQueue<>(); //优先级队列 } \"]},\"203\":{\"h\":\"优先级队列\",\"t\":[\"这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的(4/5/10)，类似于VIP用户可以优先结束排队。\",\"我们也可以自定义比较规则，同样需要给一个 Comparator 的实现(10/5/4)：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的\",\"想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。\"]},\"204\":{\"h\":\"Set 集合\",\"t\":[\"Set集合，这种集合类型比较特殊\",\"set 接口中定义的方法都是 Collection 中直接继承的，因此，Set支持的功能其实也就和 Collection 中定义的差不多，只不过：\",\"不允许出现重复元素\",\"不支持随机访问（不允许通过下标访问）\",\"public interface Set<E> extends Collection<E> { // Set 集合中基本都是从 Collection 直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator<E> iterator(); Object[] toArray(); <T> T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection<?> c); //同样是只能插入那些不重复的元素 boolean addAll(Collection<? extends E> c); boolean retainAll(Collection<?> c); boolean removeAll(Collection<?> c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); } } \"]},\"205\":{\"h\":\"HashSet\",\"t\":[\"它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个 HashMap 在实现，这个需要我们学习了Map之后再来讨论）\",\"我们可以非常高效的从 HashSet 中存取元素，我们先来测试一下它的特性：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\\\"AAA\\\")); System.out.println(set); //可以看到，最后实际上只有一个成功插入了 } \",\"在 Set 接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除 Set 中的某个对象：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); System.out.println(set.remove(\\\"AAA\\\")); System.out.println(set); } \",\"由于底层采用哈希表实现，所以说无法维持插入元素的顺序：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"206\":{\"h\":\"LinkedHashSet\",\"t\":[\"那要是我们就是想要使用维持顺序的Set集合呢？\",\"我们可以使用 LinkedHashSet，LinkedHashSet 底层维护的不再是一个 HashMap，而是 LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\",\"public static void main(String[] args) { Set<String> set = new LinkedHashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"207\":{\"h\":\"TreeSet\",\"t\":[\"还有一种Set叫做TreeSet，它会在元素插入时进行排序：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>(); set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>((a, b) -> b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"目前，Set 集合只是粗略的进行了讲解，但是学习 Map 之后，我们还会回来看我们 Set 的底层实现，所以说最重要的还是 Map目前只需要记住 Set 的性质、使用即可。\"]},\"208\":{\"c\":[\"code\"]},\"209\":{\"c\":[\"java\"]},\"210\":{\"h\":\"Java - 集合类 4\"},\"211\":{\"h\":\"集合类 4\"},\"212\":{\"h\":\"Map\",\"t\":[\"映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\",\"Map 就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值\",\"Map 并不是 Collection 体系下的接口，而是单独的一个体系，因为操作特殊\"]},\"213\":{\"h\":\"Map 基本定义\",\"t\":[\"在 Map 中，这些映射关系被存储为键值对，Map 接口中定义的操作：\",\"// Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊 // 这里需要填写两个泛型参数， // 其中K就是键的类型，V就是值的类型， // 比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的 public interface Map<K,V> { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map<? extends K, ? extends V> m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set<K> keySet(); //返回Map中存放的所有值 Collection<V> values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set<Map.Entry<K, V>> entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry<K,V> { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ... } \"]},\"214\":{\"h\":\"HashMap\",\"t\":[\"底层采用哈希表实现\",\"基本示例\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \\\"小红\\\"); System.out.println(map.get(2)); //使用get方法根据键获取对应的值 } \",\"Map 中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的\",\"为了防止意外将之前的键值对覆盖掉，我们可以使用 putIfAbsent：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); map.putIfAbsent(1, \\\"小红\\\"); //Java8 新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); } \",\"我们在获取一个不存在的映射时，默认会返回 null 作为结果：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null } \",\"我们也可以为这种情况添加一个预备方案 getOrDefault，当 Map 中不存在时，可以返回一个备选的返回值：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); System.out.println(map.getOrDefault(3, \\\"备胎\\\")); //Java8新增操作，当不存在对应的键值对时，返回备选方案 } \",\"因为 HashMap 底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的\",\"如果需要维护顺序，我们同样可以使用 LinkedHashMap，它的内部对插入顺序进行了维护\"]},\"215\":{\"h\":\"HashMap 底层实现\",\"t\":[\"HashMap 的底层实现是由 哈希表 实现的。\",\"哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：\",\"20241130000528\",\"实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... static class Node<K,V> implements Map.Entry<K,V> { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node<K,V> next; ... } ... transient Node<K,V>[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } \",\"可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：\",\"HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板\",\"HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构\"]},\"216\":{\"h\":\"put 方法\",\"t\":[\"public V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; // 通过resize方法初始化底层哈希表，初始容量为16， // 后续会根据情况扩容，底层哈希表的长度永远是2的n次方 // 因为传入的哈希值可能会很大，这里同样是进行取余操作 // (n - 1) & hash 等价于 hash % n // 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果这个位置上什么都没有，那就直接放一个新的结点 else { // 这种情况就是哈希冲突了 Node<K,V> e; K k; // 如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount >= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash); //那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size > threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null } \"]},\"217\":{\"h\":\"resize 方法\",\"t\":[\"resize 在初始化时会调用一次，此外在每次扩容时会调用。\",\"根据上面的推导，我们在正常插入一个键值对时，会得到 null 返回值，而冲突时会得到一个被覆盖的值.\",\"HashMap的一个链表长度过大时，会自动转换为红黑树：\",\"20241130001811\",\"但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap > 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap >= MAXIMUM_CAPACITY) { // 如果旧的容量已经大于最大限制了， // 那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr << 1; //新的阈值也提升到原来的两倍 } else if (oldThr > 0) // 旧容量不大于0只可能是还没初始化 // 这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参 new 出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; // 新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值为负载因子乘以默认容量，负载因子默认为0.75 // 也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了， // 反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 } } \"]},\"218\":{\"h\":\"LinkedHashMap\",\"t\":[\"HashMap 并不会维持插入的顺序，LinkedHashMap 是直接继承自HashMap，具有 HashMap 的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序\",\"static class Entry<K,V> extends HashMap.Node<K,V> { // LinkedHashMap中的结点实现 Entry<K,V> before, after; // 这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); } } \",\"这样我们在遍历 LinkedHashMap 时，顺序就同我们的插入顺序一致。\",\"当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\"]},\"219\":{\"h\":\"TreeMap\",\"t\":[\"它的内部直接维护了一个红黑树（没有使用哈希表）\",\"因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的 TreeSet 是一样的\"]},\"220\":{\"h\":\"Map 的一些方法\"},\"221\":{\"h\":\"\",\"t\":[\"compute 会将指定 Key 的值进行重新计算，若 Key 不存在，v 会返回 null\",\"computeIfPresent 当 Key 存在时存在则计算并赋予新的值\",\"computeIfAbsent 不存在Key时，计算并将键值对放入Map中：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.compute(1, (k, v) -> { //compute 会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\\\"M\\\"; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -> { // 当Key存在时存在则计算并赋予新的值 return v+\\\"M\\\"; //这里返回原来的value+M }); System.out.println(map); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.computeIfAbsent(0, (k) -> { //若不存在则计算并插入新的值 return \\\"M\\\"; //这里返回M }); System.out.println(map); } \"]},\"222\":{\"h\":\"\",\"t\":[\"merge方法用于处理数据：\",\"public static void main(String[] args) { List<Student> students = Arrays.asList( new Student(\\\"yoni\\\", \\\"English\\\", 80), new Student(\\\"yoni\\\", \\\"Chiness\\\", 98), new Student(\\\"yoni\\\", \\\"Math\\\", 95), new Student(\\\"taohai.wang\\\", \\\"English\\\", 50), new Student(\\\"taohai.wang\\\", \\\"Chiness\\\", 72), new Student(\\\"taohai.wang\\\", \\\"Math\\\", 41), new Student(\\\"Seely\\\", \\\"English\\\", 88), new Student(\\\"Seely\\\", \\\"Chiness\\\", 89), new Student(\\\"Seely\\\", \\\"Math\\\", 92) ); Map<String, Integer> scoreMap = new HashMap<>(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -> scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -> System.out.println(\\\"key:\\\" + k + \\\"总分\\\" + \\\"value:\\\" + v)); } static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; } } \"]},\"223\":{\"h\":\"\",\"t\":[\"replace方法可以快速替换某个映射的值\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\">>>\\\"); //直接替换为新的 System.out.println(map); } \",\"也可以精准匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\"巴卡\\\", \\\"玛卡\\\"); //只有键和值都匹配时，才进行替换 System.out.println(map); } \",\"包括 remove 方法，也支持键值同时匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.remove(0, \\\"单走\\\"); //只有同时匹配时才移除 System.out.println(map); } \"]},\"224\":{\"h\":\"HashSet 底层实现\",\"t\":[\"它的底层很简单，底层是直接用 HashMap 套壳实现的。\",\"因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value\",\"public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable { private transient HashMap<E,Object> map; //对，你没看错，底层直接用 map 来做事 // 因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value private static final Object PRESENT = new Object(); // 直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap<>(); } ... // 你会发现所有的方法全是替身攻击 public Iterator<E> iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } } \",\"通过观察 HashSet 的源码发现，HashSet 几乎都在操作内部维护的一个HashMap ，也就是说，HashSet 只是一个表壳，而内部维护的 HashMap 才是灵魂！\",\"就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。\",\"所以说，HashSet 利用了 HashMap 内部的数据结构，轻松地就实现了 Set 定义的全部功能！\",\"再来看 TreeSet，实际上用的就是我们的 TreeMap\",\"LinkedSet 用的就是 LinkedMap\"]},\"225\":{\"c\":[\"code\"]},\"226\":{\"c\":[\"java\"]},\"227\":{\"h\":\"Java - Stream流\"},\"228\":{\"h\":\"Stream流\",\"t\":[\"Java 8 API添加了一个新的抽象称为 流Stream，可以让你以一种声明的方式处理数据。\",\"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\",\"Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\",\"这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\",\"元素流在管道中经过 中间操作（intermediate operation）的处理，最后由 最终操作(terminal operation)得到前面处理的结果。\",\"20241130004116\",\"我们就可以把一个 Stream 当做流水线处理：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"aaaa\\\", \\\"asdasda\\\", \\\"AssdW\\\", \\\"xx\\\", \\\"add\\\", \\\"Xss\\\", \\\"sdawErs\\\")); // 过滤 长度不超过 3 // 过滤 首字母不是大写字母 // 去除 重复字符串 // filter(...) 里面条件为 true 的会保留 // distinct 去重 list = list.stream() .filter(str -> str.length() > 3) .filter(str -> str.charAt(0) >= 'A' && str.charAt(0) <= 'Z') .distinct() .collect(Collectors.toList()); System.out.println(list); } \",\"类似\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); list.add(3); list = list.stream() .distinct() //去重（使用equals判断） .sorted((a, b) -> b - a) //进行倒序排列 .map(e -> e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } \",\"当遇到大量的复杂操作时，我们就可以使用 Stream 来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\",\"注意：不能认为每一步是直接依次执行的！\",\"实际上，stream 会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。\",\"接下来，我们用一堆随机数来进行更多流操作的演示：\",\"public static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random.ints(-100, 100) // 生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -> i < 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } \",\"我们可以生成一个统计实例来帮助我们快速进行统计：\",\"public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } \",\"普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -> i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } \",\"我们还可以通过flat来对整个流进行进一步细分：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"A,B\\\"); list.add(\\\"C,D\\\"); list.add(\\\"E,F\\\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -> Arrays.stream(e.split(\\\",\\\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } \",\"我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -> a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum); } \"]},\"229\":{\"c\":[\"code\"]},\"230\":{\"c\":[\"java\"]},\"231\":{\"h\":\"Java - Collections 工具类\"},\"232\":{\"h\":\"Collections 工具类\",\"t\":[\"我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。\",\"既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的 Collocations 类就是专用于集合的工具类\"]},\"233\":{\"h\":\"最大 | 最小\",\"t\":[\"我们想快速求得List中的最大值和最小值：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); Collections.max(list); Collections.min(list); } \"]},\"234\":{\"h\":\"二分搜索\",\"t\":[\"同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现 Comparable 接口的类）：\",\"public static void main(String[] args) { List<Integer> list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8)); } \"]},\"235\":{\"h\":\"快速填充\",\"t\":[\"我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list); } \",\"如果集合中本身没有元素，那么fill操作不会生效。\"]},\"236\":{\"h\":\"空集合\",\"t\":[\"有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：\",\"public static void main(String[] args) { List<Integer> list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常 } \",\"### 只读集合\",\"我们也可以将一个可修改的集合变成只读的集合：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); List<Integer> newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常 } \"]},\"237\":{\"h\":\"查找位置\",\"t\":[\"我们也可以寻找子集合的位置：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5))); } \",\"得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：\",\"public static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list.add(\\\"aaa\\\"); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list); } \",\"没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：\",\"public static void main(String[] args) { List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\\\"aaa\\\"); System.out.println(list); } \",\"checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：\",\"20241130005736\",\"是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。\"]},\"238\":{\"c\":[\"code\"]},\"239\":{\"c\":[\"java\"]},\"240\":{\"h\":\"Java - 集合类对象相等判定\"},\"241\":{\"h\":\"集合类对象相等判定\",\"t\":[\"Oject类中的 equals 方法比较的是地址，所以自己定义的类要自己重写 equals 等方法，否则给你当成 Object 类\",\"equals 方法 和 == 的区别\",\"集合类中并不是通过 == 进行判断的，都是根据 equals 方法进行判断的\",\"remove 也是根据 equals 进行判断来删除元素\",\"20241130012855\",\"对于 List 列表 判断两个元素是否相同，是根据 元素中的 equals 方法判断的\",\"public class Main { public static void main(String[] args) { List<Test> list = new ArrayList<>(); Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); list.add(t1); System.out.println(list.remove(t2)); // 这样会把 t1 移除，因为 Test 的 equals 判断修改成根据 name 进行判断 } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } } } \",\"对于 Map 以及 Set 而言 两个对象只有 equals 方法判断相同后，还需要判断 hashCode 方法也相同，才认为这两个元素是相同的\",\"对于 Object 定义中提到，如果两个对象通过 equals 判断相同，那么它们的 hashCode 也需要相同。\",\"因此，在重写 equals 方法时，也需要考虑重写 hashCode 方法，保证当两个对象通过 equals 方法判断相同时，它们通过 hashCode 得到的 hash 值也相同\",\"如下，因为重写了 equals 和 hashCode 所以只要 name 一致，通过 map 操作就是相同的\",\"public class Main { public static void main(String[] args) { Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); Map<Test, Integer> map = new HashMap<>(); map.put(t1, 2); System.out.println(map.get(t2)); } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } @Override public int hashCode() { return Objects.hashCode(name); } } } \"]},\"242\":{\"c\":[\"code\"]},\"243\":{\"c\":[\"java\"]},\"244\":{\"h\":\"Java - IO\"},\"245\":{\"h\":\"IO流1\",\"t\":[\"一般在java.io中\",\"字节流：\",\"处理单位：以字节（8 位）为单位进行读写操作。\",\"适用场景：适用于处理所有类型的数据，包括文本、图片、音频、视频等二进制数据。\",\"主要类：InputStream 和 OutputStream 及其子类，如 FileInputStream 和 FileOutputStream。\",\"编码处理：不涉及字符编码转换，直接处理原始字节数据。\",\"字符流：\",\"处理单位：以字符（16 位）为单位进行读写操作。\",\"适用场景：专门用于处理文本数据，如读取和写入文本文件。\",\"主要类：Reader 和 Writer 及其子类，如 FileReader 和 FileWriter。\",\"编码处理：自动处理字符编码转换，适用于处理文本文件。\",\"主要区别：处理单位：字节流以字节为单位，字符流以字符为单位。 适用范围：字节流适用于所有类型的数据，字符流仅适用于文本数据。 编码处理：字节流不处理字符编码，字符流自动处理字符编码转换。 性能：字符流在处理文本数据时通常更高效，因为它们直接操作字符，减少了字节到字符的转换时间。\"]},\"246\":{\"h\":\"文件字节流\"},\"247\":{\"h\":\"输入流\",\"t\":[\"我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用\",\"public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\\\"路径\\\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } \",\"不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法：\",\"public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\\\"路径\\\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } \",\"这种语法只支持实现了AutoCloseable接口的类\"]},\"248\":{\"h\":\"文件读取\",\"t\":[\"read 方法 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } \",\"available 方法 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量） 因此与read结合，可以一次直接读取全部数据：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } \",\"也可以控制读取的数量：\",\"System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 \",\"skip 方法 可以跳过指定数量的字节\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } \"]},\"249\":{\"h\":\"输出流\",\"t\":[\"public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } \",\"输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容:\",\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\\\"lbwnb\\\".getBytes()); //也可以直接写入byte[] outputStream.write(\\\"lbwnb\\\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"250\":{\"h\":\"追加操作\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\", true)) { //true表示开启追加模式 outputStream.write(\\\"lb\\\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } \"]},\"251\":{\"h\":\"文件拷贝操作实现\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\"); FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); } } \"]},\"252\":{\"h\":\"文件字符流\",\"t\":[\"java.io.FileReader & java.io.FileWriter\"]},\"253\":{\"h\":\"\",\"t\":[\"字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用.\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } \",\"同理，字符流只支持char[]类型作为存储：\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"254\":{\"h\":\"\",\"t\":[\"writer除了write方法外，还有一个append方法，但效果是一致的\",\"public static void main(String[] args) { try(FileWriter writer = new FileWriter(\\\"output.txt\\\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } \"]},\"255\":{\"h\":\"类\",\"t\":[\"专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\",\"public static void main(String[] args) { File file = new File(\\\"test.txt\\\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } \",\"通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容:\",\"File file = new File(\\\"/\\\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } \",\"如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\",\"File file = new File(\\\"test.txt\\\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } \"]},\"256\":{\"c\":[\"code\"]},\"257\":{\"c\":[\"java\"]},\"258\":{\"h\":\"Java - IO\"},\"259\":{\"h\":\"IO流2\"},\"260\":{\"h\":\"缓冲流\",\"t\":[\"虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，**提前将部分内容存入内存（缓冲区）**在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\",\"20250225181159\"]},\"261\":{\"h\":\"缓冲字节流\"},\"262\":{\"h\":\"缓冲字节读取流\",\"t\":[\"要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可:\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } \"]},\"263\":{\"h\":\"缓冲流特性\"},\"264\":{\"h\":\"1. 装饰着模式\",\"t\":[\"实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式\",\"对应缓冲流的close源码：\",\"public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } \",\"实际上这种模式是父类FilterInputStream提供的规范\"]},\"265\":{\"h\":\"2. 缓冲机制\",\"t\":[\"I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存BufferedInputStream 支持 reset() 和 mark() 操作 即通过 mark 标记位置, reset 可以返回之前标记过的位置。\",\"当调用 mark(readlimit) 之后，输入流会以某种方式保留之后读取的readlimit 数量的内容，当读取的内容数量超过 readlimit 则之后的内容不会被保留，当调用 reset() 之后，会使得当前的读取位置回到 mark() 调用时的位置。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \"]},\"266\":{\"h\":\"3. 缓冲流可以叠加\",\"t\":[\"即可以进行套娃：BufferedInputStream stream = new BufferedInputStream(new BufferedInputStream(new FileInputStream(\\\"test.txt\\\")))\"]},\"267\":{\"h\":\"缓冲字节输出流\",\"t\":[\"其实和BufferedInputStream原理差不多，只是反向操作\",\"try (BufferedOutputStream stream = new BufferedOutputStream(Files.newOutputStream(Paths.get(\\\"src/1.txt\\\")))){ stream.write(\\\"Hello Penguin!\\\".getBytes()); } catch (IOException e) { throw new RuntimeException(e); } \"]},\"268\":{\"h\":\"缓冲字符流\",\"t\":[\"BufferedReader | BufferedWriter\"]},\"269\":{\"h\":\"缓冲字符读取流\",\"t\":[\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"相比Reader更方便的是，它支持按行读取\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } \",\"读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } \",\"它同样也支持mark()和reset()操作\"]},\"270\":{\"h\":\"缓冲字符输出流\",\"t\":[\"public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\\\"output.txt\\\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\\\"汉堡做滴彳亍不彳亍\\\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } \"]},\"271\":{\"c\":[\"code\"]},\"272\":{\"c\":[\"java\"]},\"273\":{\"h\":\"Java - 类与对象2\"},\"274\":{\"h\":\"静态变量和静态方法\",\"t\":[\"Static 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。 我们通过使用 static 关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\",\"一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\",\"public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } \",\"public static void main(String[] args) { Person.info = \\\"让我看看\\\"; System.out.println(Person.info); } \",\"同样的，我们可以将方法标记为静态：\",\"static void test(){ System.out.println(\\\"我是静态方法\\\"); } \",\"静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样:\",\"因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值, 同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的.\"]},\"275\":{\"h\":\"静态变量初始化\",\"t\":[\"我们实际上是将 .class 文件丢给 JVM 去执行的，而每一个 .class 文件其实就是我们编写的一个类，我们在 Java 中使用一个类之前， JVM 并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\",\"访问类的静态变量，或者为静态变量赋值\",\"new 创建类的实例（隐式加载）\",\"调用类的静态方法\",\"子类初始化时\",\"其他的情况会在讲到反射时介绍\",\"所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\"]},\"276\":{\"h\":\"包的访问与控制\"},\"277\":{\"h\":\"包的声明和导入\",\"t\":[\"包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\",\"包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的 www.baidu.com ，后面的 baidu.com 就是域名，我们的包就可以命名为com.baidu，其中的.就是用于分割的，对应多个文件夹，比如com.test\",\"20240815234719\",\"我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 需要通过关键字 package，用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\",\"package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } \",\"当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中） 而当我们需要使用其他包中的类时，需要先进行导入才可以： 需要通过关键字 import 导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类:\",\"import com.test.entity.Person; //使用import关键字导入其他包中的类 import com.test.entity.*; \",\"Java会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\",\"不同类的重名问题 在不同包下的类，即使类名相同，也是不同的两个类：\",\"package com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } \",\"由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\",\"public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } \",\"我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\"]},\"278\":{\"h\":\"访问权限控制\",\"t\":[\"Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\",\"private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。\",\"什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。\",\"protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）\",\"public - 公共，标记为公共的内容，允许在任何地方被访问。\",\"当前类\",\"同一个包下的类\",\"不同包下的子类\",\"不同包下的类\",\"public\",\"✅\",\"✅\",\"✅\",\"✅\",\"protected\",\"✅\",\"✅\",\"✅\",\"❌\",\"默认\",\"✅\",\"✅\",\"❌\",\"❌\",\"private\",\"✅\",\"❌\",\"❌\",\"❌\",\"默认的情况下，在当前包以外的其他包中无法访问。\",\"如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\",\"public class Person { String name; int age; String sex; public static void test(){ System.out.println(\\\"我是静态方法！\\\"); } } \",\"静态导入：\",\"import static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } \"]},\"279\":{\"c\":[\"code\"]},\"280\":{\"c\":[\"java\"]},\"281\":{\"h\":\"Java - IO\"},\"282\":{\"h\":\"IO流3\"},\"283\":{\"h\":\"转换流\",\"t\":[\"有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦\",\"public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\\\"test.txt\\\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\\\"lbwnb\\\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } \",\"同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现\",\"public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\\\"test.txt\\\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } \",\"InputStreamReader 和 OutputStreamWriter 本质也是Reader和Writer，因此可以直接放入 BufferedReader 来实现更加方便的操作。\"]},\"284\":{\"h\":\"打印流\",\"t\":[\"打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类\",\"public final static PrintStream out = null; \",\"因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。\",\"PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\",\"可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\",\"public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\\\"test.txt\\\"))){ stream.println(\\\"penguin\\\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } \",\"我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\",\"20250225192918\"]},\"285\":{\"h\":\"输入流\",\"t\":[\"之前使用的Scanner，使用的是系统提供的输入流\",\"public static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入 } \",\"我们也可以使用Scanner来扫描其他的输入流：\",\"public static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\\\"秘制小汉堡.txt\\\")); //将文件内容作为输入流进行扫描 } \"]},\"286\":{\"h\":\"数据流\",\"t\":[\"数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\",\"public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\\\"test.txt\\\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } \",\"用于写入基本数据类型:\",\"public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\\\"output.txt\\\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } \",\"注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\"]},\"287\":{\"h\":\"对象流\",\"t\":[\"ObjectOutputStream不仅支持基本数据类型，而且通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\"]},\"288\":{\"h\":\"对象序列化\",\"t\":[\"自己定义的类要序列化保存，则必须实现Serializable接口才能被序列化\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"penguin\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } \"]},\"289\":{\"h\":\"\",\"t\":[\"在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\",\"static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } \"]},\"290\":{\"h\":\"关键字\",\"t\":[\"如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"lbw\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } \",\"其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\"]},\"291\":{\"c\":[\"code\"]},\"292\":{\"c\":[\"java\"]},\"293\":{\"h\":\"Java - 多线程与反射\"},\"294\":{\"h\":\"多线程\"},\"295\":{\"h\":\"进程与线程概念\",\"t\":[\"进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\",\"20250226173747\",\"在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时。\",\"线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\",\"在Java中，我们从开始，一直以来编写的都是单线程应用程序(运行main()方法的内容), 也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程:\",\"public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } \"]},\"296\":{\"h\":\"线程的创建和启动\",\"t\":[\"线程之间是同时运行的 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式\",\" /** * Creates a new Thread that inherits the given AccessControlContext. * This is not a public constructor. */ Thread(Runnable target, AccessControlContext acc) { init(null, target, \\\"Thread-\\\" + nextThreadNum(), 0, acc, false); } //Runnable @FunctionalInterface public interface Runnable { /** * When an object implementing interface <code>Runnable</code> is used * to create a thread, starting the thread causes the object's * <code>run</code> method to be called in that separately executing * thread. * <p> * The general contract of the method <code>run</code> is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } \"]},\"297\":{\"h\":\"方法\",\"t\":[\"20250226175843\",\"创建好后，通过调用start()方法来运行此线程:\",\"public static void main(String[] args) { Thread t = new Thread(() -> { //直接编写逻辑 System.out.println(\\\"我是另一个线程！\\\"); }); t.start(); //调用此方法来开始执行此线程 } \",\"Thread.currentThread() // 获取当前线程对象 Thread t = new Thread(() -> { //自定义线程名称 System.out.println(\\\"我是另一个线程！\\\"); }, \\\"name\\\"); Thread.currentThread().getName() // 获取线程名称 \"]},\"298\":{\"h\":\"方法\",\"t\":[\"run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\"]},\"299\":{\"h\":\"方法\",\"t\":[\"实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间\",\"Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s \",\"我们也可以使用stop()方法来强行终止此线程\",\"public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i < 50; i++) { System.out.println(\\\"打印:\\\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } \",\"虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\"]},\"300\":{\"h\":\"线程的休眠和中断\",\"t\":[\"20250226175843\",\"一个线程处于运行状态下，线程的下一个状态会出现以下情况：\",\"当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。\",\"当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。\",\"当线程出现异常或错误 / 被 stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。\",\"通过调用sleep()方法可以将当前线程进入休眠，使得线程处于等待状态一段时间。\",\"在sleep代码中可以发现，显示声明了会抛出一个InterruptedException异常\",\"public static native void sleep(long millis) throws InterruptedException; \"]},\"301\":{\"h\":\"中断\",\"t\":[\"每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。\",\"interrupt用法：\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\\\"线程被中断了！\\\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } \",\"通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\",\"Thread.interrupted(); /复位中断标记（返回值是当前是否有中断标记） \"]},\"302\":{\"h\":\"线程优先级\",\"t\":[\"Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！ 我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\",\"MIN_PRIORITY 最低优先级\",\"MAX_PRIORITY 最高优先级\",\"NOM_PRIORITY 常规优先级\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } \",\"优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\"]},\"303\":{\"h\":\"线程的礼让和加入\"},\"304\":{\"h\":\"主动让出CPU资源\",\"t\":[\"我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { if(i % 5 == 0) { System.out.println(\\\"让位！\\\"); Thread.yield(); } System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); } }); t1.start(); t2.start(); } \",\"观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\"]},\"305\":{\"h\":\"\",\"t\":[\"当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入:\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); if(i == 10){ try { System.out.println(\\\"线程1加入到此线程！\\\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } \",\"我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！\"]},\"306\":{\"c\":[\"code\"]},\"307\":{\"c\":[\"java\"]},\"308\":{\"h\":\"Java - 多线程与反射\"},\"309\":{\"h\":\"多线程2\"},\"310\":{\"h\":\"线程锁和线程同步\"},\"311\":{\"h\":\"多线程下java内存管理\",\"t\":[\"20250226223324\",\"线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。\",\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：\",\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\",\"实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！ 好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\",\"比如我们可以来看看下面这个问题：\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\"]},\"312\":{\"h\":\"线程锁\",\"t\":[\"为了避免上面的这个现象，引入 线程锁 的概念\",\"synchronized(对象 | 类){ 代码块 } \",\"synchronized需要在括号中填入一个内容，必须是一个对象或是一个类，因此有对象锁和类锁区别（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\",\"当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC中我们还会讲到乐观锁，如CAS算法）\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\",\"synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\",\"private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"我们发现实际上效果是相同的，只不过这个锁不用你去给， 如果是静态方法，就是使用的类锁，\",\"public class Main { private static int i = 0; private static synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (Main.class){ // Main.class 就保证三个线程的锁是一致的 类锁 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"而如果是普通成员方法，就是使用的对象锁。\",\"public class Main { private static int i = 0; private synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { Main main = new Main(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (main){ // 使用 main 才正确 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。\"]},\"313\":{\"h\":\"死锁\",\"t\":[\"死锁是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\",\"20250226231025\",\"我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\\\"线程1\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\\\"线程2\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } \",\"所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？ 我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程号，然后 jstack pid 即可\",\"jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。\",\"因此，前面说不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\"]},\"314\":{\"c\":[\"code\"]},\"315\":{\"c\":[\"java\"]},\"316\":{\"h\":\"Java - 多线程与反射\"},\"317\":{\"h\":\"多线程3\"},\"318\":{\"h\":\"和 方法\",\"t\":[\"Object 类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()\",\"他们其实是需要配合synchronized来使用的，平常环境下是无法使用的，只有当对象作为锁时，才能用这三个方法。\",\"实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了。\",\"wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁。wait需要捕获 InterruptedException终止异常。\",\"当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\",\"notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\",\"wait()方法是让该线程从 运行态 -> 等待(waiting)态; notify()则是让处于 等待态的线程变为 阻塞态，所以仍然需要等在运行的线程结束才会转为运行态。\",\"wait()支持参数，可以给他传一个时间参数进去的，是一种自动唤醒机制：在指定时间内，如果没有其他线程唤醒自己，则主动唤醒自己。\",\"如果是 wait() | wait(0) 则表示永久等待，必须要有 notify()才会转换\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { System.out.println(\\\"开始等待\\\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\\\"等待结束！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o1){ System.out.println(\\\"开始唤醒！\\\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i < 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } \"]},\"319\":{\"h\":\"\",\"t\":[\"专门创建一个独属于某个线程的变量\",\"20250309155822\",\"我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部只能存储一个变量，不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。\",\"ThreadLocal定义在主线程中\",\"public static void main(String[] args) throws InterruptedException { ThreadLocal<String> local = new ThreadLocal<>(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -> { local.set(\\\"penguin\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程1变量值已设定！\\\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"线程1读取变量值：\\\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -> { local.set(\\\"pig\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程2变量值已设定！\\\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } \",\"不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\"]},\"320\":{\"h\":\"\",\"t\":[\"为子线程的 local 设置初始值，如果子线程修改了也是可以\",\"public static void main(String[] args) { ThreadLocal<String> local = new InheritableThreadLocal<>(); Thread t = new Thread(() -> { local.set(\\\"lbwnb\\\"); new Thread(() -> { System.out.println(local.get()); }).start(); }); t.start(); } \"]},\"321\":{\"h\":\"定时器\"},\"322\":{\"h\":\"自己定义的定时器\",\"t\":[\"public static void main(String[] args) { new TimerTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -> { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \",\"public static void main(String[] args) { new TimerLoopTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -> { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \"]},\"323\":{\"h\":\"\",\"t\":[\"我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等\",\"public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000, 500); //执行一个延时任务 // 运行函数，延迟，循环间隔 } \"]},\"324\":{\"h\":\"不会终止\",\"t\":[\"虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\",\"public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } \",\"TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\",\"public Timer(String name) { thread.setName(name); thread.start(); } \",\"而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\",\"public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() && newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } } } \",\"我们可以通过调用cancel()方法来关闭它的工作线程：\",\"public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } \"]},\"325\":{\"c\":[\"code\"]},\"326\":{\"c\":[\"java\"]},\"327\":{\"h\":\"Java - 多线程与反射\"},\"328\":{\"h\":\"多线程4\"},\"329\":{\"h\":\"守护线程\",\"t\":[\"t.setDaemon(true);\",\"守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。\",\"而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂。\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \",\"在守护线程中产生的新线程也是守护的：\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { Thread it = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \"]},\"330\":{\"h\":\"集合类\",\"t\":[\"java中也有些使用并行来进行操作的\",\"集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。\",\"并行流 parallelStream()\",\" default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作 } \",\"并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\",\" public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -> System.out.println(Thread.currentThread().getName()+\\\" -> \\\"+i)); } \",\"我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序。\",\"在Arrays数组工具类中，也包含大量的并行方法：\",\" public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } \",\"集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题\"]},\"331\":{\"h\":\"生产者与消费者\",\"t\":[\"所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\",\"通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\",\"public class Main { private static final Queue<Object> queue = new LinkedList<>(); public static void main(String[] args) { new Thread(Main::add, \\\"厨师1\\\").start(); new Thread(Main::add, \\\"厨师2\\\").start(); new Thread(Main::take, \\\"顾客1\\\").start(); new Thread(Main::take, \\\"顾客2\\\").start(); new Thread(Main::take, \\\"顾客3\\\").start(); } private static void add(){ while (true){ try { Thread.sleep(3000); synchronized (queue) { String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"put menu\\\"); queue.offer(new Object()); queue.notifyAll(); } } catch (InterruptedException e) { e.printStackTrace(); } } } private static void take(){ while (true) { try { synchronized (queue){ while(queue.isEmpty())queue.wait(); queue.poll(); String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"eat\\\"); } Thread.sleep(4000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \"]},\"332\":{\"c\":[\"code\"]},\"333\":{\"c\":[\"java\"]},\"334\":{\"h\":\"Java - 反射\"},\"335\":{\"h\":\"反射1\"},\"336\":{\"h\":\"反射\",\"t\":[\"反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\",\"简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\"]},\"337\":{\"h\":\"JAVA 类加载机制\",\"t\":[\"20250310160214\",\"在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\",\"简单理解为： 默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。\",\"Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。\"]},\"338\":{\"h\":\"Class 类\",\"t\":[\"在类加载过程的同时，会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。\"]},\"339\":{\"h\":\"获取相应类的Class对象\",\"t\":[\"共有三种方法，无论哪种方法所获取到的 Class 对象始终是相同的。 所以类锁本质上就是对应的类的 Class 对象。\",\"public static void main(String[] args) throws ClassNotFoundException { Class<String> clazz = String.class; //使用class关键字，通过类名获取 Class<?> clazz2 = Class.forName(\\\"java.lang.String\\\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class<?> Class<?> clazz3 = new String(\\\"cpdd\\\").getClass(); //通过实例对象获取 } \"]},\"340\":{\"h\":\"基本数据类型的 Class 对象\",\"t\":[\"基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的.\",\"/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\\\"unchecked\\\") public static final Class<Integer> TYPE = (Class<Integer>) Class.getPrimitiveClass(\\\"int\\\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class<?> getPrimitiveClass(String name); //C++实现，并非Java定义 \",\"每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\",\"包装类型都有一个TYPE，其实也就是基本类型的Class，但包装类的Class和基本类的Class显然是不同的。\",\"public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } \"]},\"341\":{\"h\":\"数组的 Class 对象\",\"t\":[\"数组类型也是一种类型，只是编程不可见\",\"public static void main(String[] args) { Class<String[]> clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\\\"10\\\"))); //强制类型转换（会报错） } \"]},\"342\":{\"h\":\"Class 对象与多态\"},\"343\":{\"h\":\"类型比较\",\"t\":[\"正常情况下，我们使用instanceof进行类型比较, 它可以判断一个对象是否为此接口或是类的实现或是子类：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str instanceof String); } \",\"有了 Class 后，可以有其他方式判断类型：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } \",\"asSubClass()，判断是否为子类或是接口/抽象类的实现\",\" public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } \",\"getSuperclass()，可以获取到父类的Class对象\",\" public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } \",\"getGenericSuperclass()，获取父类的原始类型的Type\",\" public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } \",\"我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class\",\" public static void main(String[] args) { Integer i = 10; for (Class<?> anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } \",\"泛型的参数获取 ParameterizedType | TypeVariableImpl\",\"如果一个类的父类是泛型，其对应的 class 就不是正常的 class， 而是一个参数化类型:\",\"class sun.reflect.generics.reflectiveObjects.TypeVariableImpl\",\"对应地，我们从 参数化类型中可以获取到泛型在定义过程中的参数类型 getActualTypeArguments。\",\" public static void main(String[] args) { ParameterizedType type = (ParameterizedType) ArrayList.class.getGenericSuperclass(); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"在这种情况下，对应的 type 由于泛型中未定义，所以是 E, 对应的class 类型为 TypeVariableImpl\",\"20250310165216\",\"如果我们已经明确了继承的泛型的类型，那么对应返回的就是确定的类型 class\",\" <!-- Test.class --> public class Test <T> { } <!-- Student.class --> public class Student extends Test<String> { String name; int age; } <!-- Main.class --> public static void main(String[] args) { ParameterizedType type = (ParameterizedType) Student.class.getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170039\",\"此外，如果这种情况，由于类型擦除机制，仍然是获取不到具体的 class 的, 返回的仍然是 E\",\" public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"ASDF\\\")); ParameterizedType type = (ParameterizedType) list.getClass().getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170551\"]},\"344\":{\"c\":[\"code\"]},\"345\":{\"c\":[\"java\"]},\"346\":{\"h\":\"Java - 类与对象3\"},\"347\":{\"h\":\"封装 继承和多态\",\"t\":[\"封装、继承和多态是面向对象编程的三大特性。\",\"封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\",\"继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\",\"多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\",\"正是这三大特性，让我们的Java程序更加生动形象。\"]},\"348\":{\"h\":\"封装\"},\"349\":{\"h\":\"继承\",\"t\":[\"父类是 super 子类是 this\"]},\"350\":{\"h\":\"Object 类\",\"t\":[\"Object 是最顶层的类，所有其他类都是继承它的 方法： euqals toString clone hashcode\",\"public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class<?> getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } \"]},\"351\":{\"h\":\"方法重写\",\"t\":[\"方法的重载是为某个方法提供更多种类 而方法的重写是覆盖原有的方法实现,重写方法要求与父类的定义完全一致 比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了\",\"public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) && //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age && //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } \",\"在修改后 即使强制类型转换 但实际上还是在调用本身的方法\",\" Person p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); Person p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 \",\"我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用 super 关键字： satic 成员方法中不能用 super\",\"@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } \",\"如果父类的方法是 private, 那么无法重写\"]},\"352\":{\"h\":\"控制符\",\"t\":[\"final 对于成员变量，则表示只能赋一次值。只能在构造函数进行赋值(如果有初始值，构造函数也不能赋值)，其他地方不能修改 对于成员方法，会限制其子类不允许其重写所对应的成员变量 在 类 上 加 final, 表示这个类不能再被继承了\"]},\"353\":{\"h\":\"抽象类\",\"t\":[\"抽象类具有 抽象方法，正常实例化方法是无法创造抽象类的实例\",\"抽象方法是指：只保留方法的定义，并不编写方法的主体，具体的实现由 子类 来实现.\",\"要使用抽象类，我们只能去创建它的子类对象。\",\"抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类\",\"抽象方法的访问权限不能为 private, 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\",\"public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } \",\"而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法 不过如果子类也是抽象类，就不一定需要实现。\",\"public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \\\"工人\\\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } } \",\"发现对于 抽象类 中定义的 抽象方法，其子类的对应的方法的访问权限需要高于抽象类中的方法，且同样不能使用 private。 即 如果抽象方法在抽象类定义的是 public, 子类对应必须是 public 不能是 protected; 而如果抽象类定义的是 protected，子类也可以定义 public\"]},\"354\":{\"h\":\"接口\",\"t\":[\"接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\",\"接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\",\"实际上接口的目标就是将类所具有某些的行为抽象出来。\",\"可以理解为 接口 相当于 只有抽象类中的抽象方法，甚至都不是一个类了。\",\"接口里只能定义对应的抽象方法，不过可以省略 abstract 定义 并且默认在类中实现的权限是 public\",\"定义接口 interface\",\"实现接口 implements\",\"接口可以实现很多个，只需要用 逗号 隔开即可，类只能继承一个、\",\"所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\",\"java8开始，接口中的方法可以存在默认实现，default 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\",\"接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法 接口中定义的静态变量只能是public static final的 接口中定义的静态方法也只能是public的 这些可以省 直接int a = 1static void test()这种即可 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容\",\"接口是可以继承 (extends) 自其他接口的, 并且接口没有继承数量限制，接口支持多继承 接口的继承相当于是对接口功能的融合罢了\",\"接口的默认方法是保底的，只要一个类的父类或者自身有对应方法，就不会执行接口的默认方法\",\"接口中如果定义了与 Object 同名的方法，不能使用默认，因为其他类就算继承这个接口，由于类本身都是继承 Object 的，这个默认方法没有任何作用\",\"比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\",\"接口定义:\",\"public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } \",\"让类来使用这个接口\",\"public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\\\"我会学习！\\\"); } } \",\"接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用，即\",\"public class Main { public static void main(String[] args) { Study study = new Teacher(\\\"penguin\\\",18,\\\"male\\\"); study.study() //这里的话只能使用接口中的方法，以及Object的方法 } } \",\"接口同样支持向下转型：\",\"public static void main(String[] args) { Study study = new Teacher(\\\"小王\\\", 27, \\\"男\\\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } \",\"从Java8开始，接口中可以存在让抽象方法的默认实现：\",\"public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\\\"我是默认实现\\\"); } } \"]},\"355\":{\"h\":\"Object类中的 克隆方法\",\"t\":[\"这是浅拷贝，克隆出来的与原来的对象不是一个对象，但对象中的属性都是同一个地址\",\"克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\",\"浅拷贝： 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。\",\"深拷贝： 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。\",\"package java.lang; public interface Cloneable { //这个接口中什么都没定义 } \",\"具体实现克隆:\",\"public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\\\"我会学习！\\\"); } } \",\"克隆实现：\",\"public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } \"]},\"356\":{\"h\":\"枚举类\",\"t\":[\"public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } \",\"使用枚举类也非常方便，就像使用普通类型那样：\",\"public class Student { private Status status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } \",\"使用就像对象的参数一样:\",\"Status.RUNNING Status.STUDY Status.SLEEP \",\"枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\",\"//这里使用javap命令对class文件进行反编译得到 Compiled from \\\"Status.java\\\" public final class com.test.Status extends java.lang.Enum<com.test.Status> { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } \",\"枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\",\"public enum Status { RUNNING(\\\"睡觉\\\"), STUDY(\\\"学习\\\"), SLEEP(\\\"睡觉\\\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } \",\"public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } \"]},\"357\":{\"c\":[\"code\"]},\"358\":{\"c\":[\"java\"]},\"359\":{\"h\":\"Java - 类与对象4\"},\"360\":{\"h\":\"面向对象高级篇1\"},\"361\":{\"h\":\"基本类型包装类\",\"t\":[\"Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\"]},\"362\":{\"h\":\"所有包装类如下\",\"t\":[\"20241017002218\",\"其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\",\"byte -> Byte\",\"boolean -> Boolean\",\"short -> Short\",\"char -> Character\",\"int -> Integer\",\"long -> Long\",\"float -> Float\",\"double -> Double\",\"包装类型的自动装箱和拆箱机制 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想） 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\",\" public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 // 不需要 Integer i = new Integer(10) // 这里本质上就是被自动包装成了一个Integer类型的对象， // 只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的 Integer i = 10; int a = i; } \",\"因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\",\" public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } \",\"那么自动装箱的呢？\",\" public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\",\"但是如果超出这个缓存范围的话，就会得到不同的对象了：\",\"public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制。\"]},\"363\":{\"h\":\"包装类的方法\",\"t\":[\"包装类支持字符串直接转换\",\" public static void main(String[] args) { Integer i = new Integer(\\\"666\\\"); //直接将字符串的666，转换为数字666 System.out.println(i); // 字符串转Integer有多个方法： Integer i = Integer.valueOf(\\\"5555\\\"); Integer i = Integer.decode(\\\"0xA6\\\"); Integer.toHexString(166) } \"]},\"364\":{\"h\":\"特殊包装类\",\"t\":[\"BigInteger 和 BigDecimal 都在 java.math 中\",\"Void类 没啥意义 不能 new 只能 Void v = null\",\"BigInteger import java.math.BigInteger 用于计算超大数字，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字。 但不支持 自动装箱|拆箱机制，计算的话也只能通过 BigInteger 提供的方法进行计算。 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\",\" public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); BigInteger h = BigInteger.valueOf(100) // 乘法 BigInteger a = h.multiply(BigInteger.TEN) } \",\"BigDecimal import java.math.BigDecimal 浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算\",\"public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } \"]},\"365\":{\"c\":[\"code\"]},\"366\":{\"c\":[\"java\"]},\"367\":{\"h\":\"Java - 数组 | 字符串 | 正则表达式\"},\"368\":{\"h\":\"面向对象高级篇 2\"},\"369\":{\"h\":\"数组\",\"t\":[\"数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素。\"]},\"370\":{\"h\":\"定义\",\"t\":[\"数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建） 即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用 new 关键字\",\"public static void main(String[] args) { int[] array = new int[10]; //类型[]就表示这个是一个数组类型 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } \",\"创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的 其他定义方法:\",\"类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 \"]},\"371\":{\"h\":\"方法\",\"t\":[\"数组的 length 是在一开始就确定的，而且是 final类型 的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\",\" public static void main(String[] args) { int[] array = new int[10]; System.out.println(\\\"当前数组长度为：\\\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } \",\"array 虽然是继承于 Object，但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现，所以可能不满足真实需求。\"]},\"372\":{\"h\":\"访问元素\",\"t\":[\"for 或者 foreach\",\" public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i < array.length; i++) { System.out.print(array[i] + \\\" \\\"); } for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\\\" \\\"); //每一轮循环，i都会更新成数组中下一个元素 } } \"]},\"373\":{\"h\":\"特性\",\"t\":[\"这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\",\" public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; // 这样是不能赋值的 会报错 } \",\"由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的, 即 int[] arr = new int[10] 是不能 Object[] arrav = arr 这样的\",\"但是如果是引用类型的话，是可以的,因为父类都是 Object\",\" public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } \"]},\"374\":{\"h\":\"性质\",\"t\":[\" public static void main(String[] args) { final int[] a = {1,2,3,4}; // 值还是可以修改，只是数组的地址不准修改 a[0] = 4; // 允许 a = {2,4,8,7}; //不允许 } \"]},\"375\":{\"h\":\"多维数组\",\"t\":[\"既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的\",\"public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } \"]},\"376\":{\"h\":\"可变长参数\",\"t\":[\"public void function(参数类型...参数名称) 这样参数名称所表示的就是一个数组\",\"public class Person { String name; int age; String sex; // 可以传入 0 - N 个类型的实参 public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } } public static void main(String[] args) { Person person = new Person(); person.test(\\\"1！\\\", \\\"5！\\\", \\\"哥们在这跟你说唱\\\"); //这里我们可以自由传入任意数量的字符串 } \",\"注意，如果同时存在其他参数，那么可变长参数只能放在最后：\",\"public void test(int a, int b, String... strings){ } \"]},\"377\":{\"h\":\"函数的\",\"t\":[\"public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } \",\"可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：java com/test/Main lbwnb aaaa xxxxx 因此会读取命令行中的指令参数进行存储到 args 中。\"]},\"378\":{\"h\":\"字符串\",\"t\":[\"字符串类是一个比较特殊的类，它用于保存字符串。 我们知道，基本类型 char 可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组） Java中没有字符串这种基本类型，因此只能使用类来进行定义。 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\"]},\"379\":{\"h\":\"String 类\",\"t\":[\"String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象, 也可以象征性 new 不过没必要 如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了\",\"public static void main(String[] args) { String str1 = \\\"Hello World\\\"; String str2 = \\\"Hello World\\\"; System.out.println(str1 == str2); // 这样就不同 String str3 = new String(\\\"Hello World\\\"); String str4 = new String(\\\"Hello World\\\"); System.out.println(str3 == str4); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } \",\"因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用 ==， String类重载了equals方法用于判断和比较内容是否相同\",\"获取长度 str.length()\",\"public static void main(String[] args) { String str = \\\"Hello World\\\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } \",\"字符串类中提供了很多方便我们操作的方法， 比如字符串的裁剪 (substring)、分割操作 (split)\",\" public static void main(String[] args) { String str = \\\"Hello World\\\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); String[] strings = str.split(\\\" \\\"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } \",\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组: char[] chars = str.toCharArray()字符数组转字符串: String str = new String(chars)\"]},\"380\":{\"h\":\"StringBuilder 类\",\"t\":[\"StringBuilder 就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足\",\"public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\\\"AAA\\\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\\\"BBB\\\"); builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } \",\"字符串支持使用 + 和 += 进行拼接操作, 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\",\"对于变量来说\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } \",\"如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？ 这种情况实际上会被优化为下面的写法：\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } \"]},\"381\":{\"h\":\"正则表达式\",\"t\":[\"str.match(正则表达式)\",\"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\",\"public static void main(String[] args) { String str = \\\"oooo\\\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\\\"o+\\\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } \",\"用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\",\"字符\",\"描述\",\"*\",\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \\\"z\\\" 以及 \\\"zoo\\\"。***** 等价于 {0,}。\",\"+\",\"匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \\\"zo\\\" 以及 \\\"zoo\\\"，但不能匹配 \\\"z\\\"。+ 等价于 {1,}。\",\"?\",\"匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \\\"do\\\" 、 \\\"does\\\"、 \\\"doxy\\\" 中的 \\\"do\\\" 。? 等价于 {0,1}。\",\"n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \\\"Bob\\\" 中的 o，但是能匹配 \\\"food\\\" 中的两个 o。\",\"n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \\\"Bob\\\" 中的 o，但能匹配 \\\"foooood\\\" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\",\"m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \\\"fooooood\\\" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\",\"如果我们想要表示一个范围内的字符，可以使用方括号：\",\"public static void main(String[] args) { String str = \\\"abcabccaa\\\"; System.out.println(str.matches(\\\"[abc]*\\\")); //表示abc这几个字符可以出现 0 - N 次 } \",\"对于普通字符来说，我们可以下面的方式实现多种字符匹配：\",\"字符\",\"描述\",\"[ABC]\",\"匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中所有的 e o u a 字母。\",\"[^ABC]\",\"匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中除了 e o u a 字母的所有字母。\",\"[A-Z]\",\"[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。\",\".\",\"匹配除换行符（\\\\n、\\\\r）之外的任何单个字符，相等于 [^\\\\n\\\\r]\",\"[\\\\s\\\\S]\",\"匹配所有。\\\\s 是匹配所有空白符，包括换行，\\\\S 非空白符，不包括换行。\",\"\\\\w\",\"匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\",\"当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\",\"正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\"]},\"382\":{\"c\":[\"code\"]},\"383\":{\"c\":[\"java\"]},\"384\":{\"h\":\"Java - 内部类\",\"t\":[\"静态 属于 类， 成员 属于 对象。\"]},\"385\":{\"h\":\"内部类\",\"t\":[\"内部类顾名思义，就是创建在内部的类。\"]},\"386\":{\"h\":\"成员内部类 (属于 对象)\",\"t\":[\"成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用\",\"成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的， 如果我们要使用成员内部类，那么就需要创造一个对象，才能去 new 一个成员内部类。\",\"我们可以直接在类的内部定义成员内部类：\",\"public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\\\"我是成员内部类！\\\"); } } } \",\"public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 inner.test(); } \",\"注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.\",\"这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\\\"我是成员内部类：\\\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } \",\"每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\",\"20241027012950\",\"public static void main(String[] args) { Test a = new Test(\\\"小明\\\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\\\"小红\\\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } \",\"那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个 (就近原则) 如果需要指定为外部的对象，那么需要在前面添加外部类型名称Test.this.\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\\\"方法参数的name = \\\"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\\\"成员内部类的name = \\\"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\\\"成员内部类的name = \\\"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } \",\"包括对方法的调用和super关键字的使用，也是一样的：\",\"public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } \"]},\"387\":{\"h\":\"静态内部类 (属于 类)\",\"t\":[\"静态内部类就像静态方法和静态变量一样，是属于类的，不需要，依附任何对象我们可以直接创建使用。\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\\\"我是静态内部类！\\\"); } } } \",\"不需要依附任何对象，我们可以直接创建静态内部类的对象：\",\"public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } \",\"静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的\"]},\"388\":{\"h\":\"局部内部类\",\"t\":[\"(这种局部内部类的形式，使用频率很低，基本上不会用到) 局部内部类就像局部变量一样，可以在方法中定义。 基本定义是：(不需要声明访问权限，因为它作用范围就只是方法内)\",\"public 方法名(){ class 局部内部类名 { 内容 } } \",\"既然是在方法中声明的类，那作用范围也就只能在方法中了\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 public void test(){ System.out.println(\\\"我是局部内部类\\\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } \"]},\"389\":{\"h\":\"静态内部类编译特性\",\"t\":[\"package com.test; import com.test.entity.Test; public class Main { public static void main(String[] args) { Test.Inner.test(); } } \",\"package com.test.entity; public class Test { static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"内部类静态方法\\\"); } } } \",\"结果是：\",\"20241027015244\",\"说明这种情况下，只是初始化了内部类的，并没有初始化内部类，因为并没有使用到外部类的任何静态变量，所以只初始化了内部类。 因为在编译的时候，类的内部类它会单独生成一个 .class，当你使用内部类静态方法，不会调用外部类的 class 只有在你使用到外部类的静态变量或方法后，才会初始化外部类, 但还是先初始化内部类。\",\"package com.test.entity; public class Test { public static String name = \\\"penguin\\\"; static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"使用外部静态变量\\\" + name); System.out.println(\\\"内部类静态方法\\\"); } } } \",\"输出为：\",\"20241027015718\"]},\"390\":{\"h\":\"匿名内部类\",\"t\":[\"匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\",\"不能直接通过 new 的方式去创建一个抽象类或是接口对象，正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\",\"但我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象\",\"public abstract class Student { public abstract void test(); } \",\"public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\\\"我是匿名内部类的实现!\\\"); } }; student.test(); } \",\"此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）\",\"同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类 这样就是一个实现 接口 中方法 的匿名类，但类名必须与接口一致。\",\"package com.test.entity; public interface Study { void study(); } \",\"public class Main { public static void main(String[] args) { Study ss = new Study() { @Override public void study() { System.out.println(\\\"penguin\\\"); } }; ss.study(); } } \",\"匿名对象本身不能定义新的属性。匿名对象的类是在创建时匿名生成的，但它继承自一个现有的类或实现了一个接口。因此，匿名类只能访问其父类的属性或方法，无法直接定义新的属性.\",\"在 Java 中，匿名对象通常不能直接给属性赋值，因为匿名对象没有类名，无法显式定义构造函数或初始化块 因此，为了在创建匿名对象时进行属性初始化，Java 提供了一种特殊的语法，即使用初始化块 {}。\",\"当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 类似：\",\"package com.test.entity; public class Penguin { protected String apple; public void test(){ System.out.println(apple); } } \",\"public class Main { public static void main(String[] args) { Penguin pp = new Penguin(){ { apple = \\\"ppp\\\"; } }; pp.test(); } } \"]},\"391\":{\"h\":\"匿名内部类特性\",\"t\":[\"对于 匿名内部类 或者 Lambda 中，如果想用外部变量，只能使用 final 的变量，如果不是 final，会隐式修改为 final 即之后不能修改\",\"public static void main(String[] args) { int a = 10; // a = 20; // 如果修改了a 就会报错 Study pp = new Study{ @Override public void study(){ System.out.println(a); } } pp.test(); } \"]},\"392\":{\"h\":\"Lambda表达式\",\"t\":[\"如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式\",\"public static void main(String[] args) { Study study = () -> System.out.println(\\\"我是学习方法！\\\"); //是不是感觉非常简洁！ study.study(); } \",\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda 仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"如果有一个参数和返回值的话：\",\"public static void main(String[] args) { Study study = (a) -> { System.out.println(\\\"我是学习方法\\\"); return \\\"今天学会了\\\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } \",\"如果参数只有一个，那么可以省去小括号 如果方法体中只有一个返回语句，可以直接省去花括号和return关键字\",\"Study study = (a) -> { return \\\"今天学会了\\\"+a; //这种情况是可以简化的 }; ==================================== Study study = (a) -> \\\"今天学会了\\\"+a; ==================================== Study study = a -> \\\"今天学会了\\\"+a; \",\"如果一个方法的参数需要的是一个接口的实现:\",\"public static void main(String[] args) { test(a -> \\\"今天学会了\\\"+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } \",\"对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\"]},\"393\":{\"h\":\"方法引用\",\"t\":[\"方法引用 类名::方法名 就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义 参数一样，返回值一样 一样才行）\",\"public interface Study { int sum(int a, int b); //待实现的求和方法 } \",\"那么使用时候，可以直接使用Lambda表达式：\",\"public static void main(String[] args) { Study study = (a, b) -> a + b; } \",\"只不过还能更简单，因为Integer类中默认提供了求两个int值之和的静态方法：\",\"public static void main(String[] args) { Study study = (a, b) -> Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } ================= 方法引用 类名::方法名 ========================= public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } \",\"方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。\",\"任何方法都可以通过方法引用作为实现：\",\"public interface Study { String study(); } \",\"如果是普通成员方法 (成员方法只能通过 对象 调用，不是静态方法)，我们同样需要使用对象来进行方法引用：\",\"public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \\\"卡布奇诺今犹在，不见当年倒茶人。\\\"; } \",\"因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\",\"public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } \",\"反正只要是符合接口中方法的定义的，都可以直接进行方法引用。\"]},\"394\":{\"c\":[\"code\"]},\"395\":{\"c\":[\"java\"]},\"396\":{\"h\":\"Java - 异常\"},\"397\":{\"h\":\"面向对象高级篇 4\"},\"398\":{\"h\":\"异常机制\"},\"399\":{\"h\":\"异常类型\",\"t\":[\"我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等. 他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自 Exception 类\",\"运行时异常 继承自 RuntimeException 在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。 所有的运行时异常都继承自 RuntimeExceptionRuntimeException 是继承 Exception\",\"编译时异常 继承 Exception 编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！ 默认继承自 Exception 类的异常都是编译时异常。 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\",\"protected native Object clone() throws CloneNotSupportedException; \",\"20241029001425\",\"错误 Error错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了。 比如 OutOfMemoryError 就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\"]},\"400\":{\"h\":\"自定义异常\",\"t\":[\"异常其实就两大类，一个是编译时异常 Exception，一个是运行时异常 RuntimeException。 我们自定义异常也是从这两类中进行选择。\",\"自定义编译时异常 编译时异常只需要继承 Exception 就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\",\"public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } \",\"自定义运行时异常 运行时异常只需要继承 RuntimeException 就行了\",\"public class TestException extends RuntimeException{ public TestException(String message){ super(message); } } \"]},\"401\":{\"h\":\"抛出异常\",\"t\":[\"当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\",\"public static int test(int a, int b) { if(b == 0) throw new ArithmeticException(\\\"被除数不能为0\\\"); //throw new RuntimeException(\\\"被除数不能为0\\\"); //使用throw关键字来抛出异常 return a / b; } \",\"异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在 RuntimeException 的构造方法中我们可以写入原因。\",\"注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以，因为不这样就无法编译了： throws Exception\",\"就是说如果这个函数结束时有异常，要么自己处理好，要么就往上一级函数上 throw\",\"private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\\\"我是编译时异常！\\\"); } \",\"如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\",\"private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } \",\"最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\",\"@Override protected Object clone() { return new Object(); } \"]},\"402\":{\"h\":\"异常的处理\",\"t\":[\"当程序没有按照我们理想的样子运行而出现异常时（默认会交给 JVM 来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息） 现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获\",\"异常处理：要么一直 throw 交给上一级函数 最终到 main 给 jvm 处理; 要么在当前函数通过 try-catch 进行捕获。\",\"无论是否出现异常，都会在最后执行任务，可以交给 finally 语句块来处理，可以只跟 try 使用。\",\"public static void main(String[] args) { // try...catch 进行异常捕获 try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\\\"异常错误信息：\\\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\\\"程序继续正常运行！\\\"); } \",\"如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用 try-catch 语句块进行异常的捕获，不然就无法通过编译.\",\"public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } \",\"当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\",\"public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } \",\"注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到\",\"public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\\\"捕获到异常\\\"); } } \",\"当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 但是要注意一下顺序 try {} catch { xxxException | xxxException e }{ }\",\"try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } // 可以简写为 try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } \"]},\"403\":{\"h\":\"断言表达式\",\"t\":[\"我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下。\",\"assert断言表达式，如果 assert 后面的表达式判断结果为 false，将抛出 AssertionError 错误。\",\"比如我们可以判断变量的值，如果大于10就抛出错误：\",\"public static void main(String[] args) { int a = 10; assert a > 10; } \"]},\"404\":{\"c\":[\"code\"]},\"405\":{\"c\":[\"java\"]},\"406\":{\"h\":\"Java - 工具类\"},\"407\":{\"h\":\"面向对象高级篇 6\",\"t\":[\"工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\"]},\"408\":{\"h\":\"常用工具类\"},\"409\":{\"h\":\"数学工具类\",\"t\":[\"Math类 是在 java.util 中，因此可以直接调用。\",\"public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } \",\"随机数生成 Random 类\",\"import java.util.Random; public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i < 30; i++) { System.out.print(random.nextInt(100)+\\\" \\\"); //nextInt方法可以指定创建0 - x之内的随机数 } } \"]},\"410\":{\"h\":\"数组工具类\",\"t\":[\"Arrays类 是在 java.util 中，因此可以直接调用。\",\"一些方法：Arrays.toString | Arrays.sort | Arrays.fill | Arrays.copyOfArrays.deepToString 可以对 多维数组 打印\",\"Arrays类 用于便捷操作数组，比如我们想要打印数组，可以直接通过 toString 方法转换字符串：\",\"public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } \"]},\"411\":{\"c\":[\"code\"]},\"412\":{\"c\":[\"java\"]},\"413\":{\"h\":\"Java - 泛型 1\"},\"414\":{\"h\":\"泛型 1\"},\"415\":{\"h\":\"使用泛型的原因\",\"t\":[\"为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个 Score 类呢？\",\"现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\",\"可以直接使用一个 Object 类进行存储成绩\",\"public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } \",\"以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\",\"public static void main(String[] args) { Score score = new Score(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", \\\"优秀\\\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } \",\"使用Object类型作为引用，对于使用者来说，由于是 Object 类型，所以说并不能直接判断存储的类型到底是 String 还是 Integer ，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\",\"所以说这种解决办法虽然可行，但并不是最好的方案。\",\"为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效 率。\"]},\"416\":{\"h\":\"泛型类\",\"t\":[\"泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\",\"我们可以将一个类定义为一个泛型类：\",\"public class Score<T> { //泛型类需要使用<>，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; } } \",\"具体使用:\",\"public static void main(String[] args) { Score<String> score = new Score<String>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); // 因为现在有了类型变量，在使用时同样需要跟上<>并在其中填写明确要使用的类型 // 这样我们就可以根据不同的类型进行选择了 // 这种形式也可以 Score<String> score = new Score<>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value); } \",\"泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！\",\"因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用对象定义的泛型的\",\"我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个 Object 类型的变量，因为无论具体类型是什么，一定是 Object 类的子类。\",\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组.\",\"具体类型不同的泛型类变量，不能使用不同的变量进行接收 \",\"如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 ? 通配符 就好像默认其是 Object 类型\",\" public static void main(String[] args) { Test<?> test = new Test<Integer>(); test = new Test<String>(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成 Object } \",\"泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个 那么在使用时，就需要将这三种类型都进行明确指定\",\" public class Test<A, B, C> { //多个类型变量使用逗号隔开 public A a; public B b; public C c; } ------------------------------------- public static void main(String[] args) { Test<String, Integer, Character> test = new Test<>(); //使用钻石运算符可以省略其中的类型 test.a = \\\"lbwnb\\\"; test.b = 10; test.c = '淦'; } \",\"泛型只能确定为一个引用类型，基本类型是不支持的, 如果要存放基本数据类型的值，我们只能使用对应的包装类\",\"当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的\"]},\"417\":{\"h\":\"泛型和多态\",\"t\":[\"不只是类，包括接口、抽象类，都是可以支持泛型的：\",\"public interface Study<T> { T test(); } \",\"当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：\",\"public class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study<Integer> { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } } } \",\"或者是继续摆烂，依然使用泛型：\",\"public class Main { public static void main(String[] args) { A<String> a = new A<>(); String i = a.test(); } static class A<T> implements Study<T> { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } } } \",\"继承也是同样的：\",\"static class A<T> { } static class B extends A<String> { } \"]},\"418\":{\"c\":[\"code\"]},\"419\":{\"c\":[\"java\"]},\"420\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"421\":{\"h\":\"Daily\"},\"422\":{\"h\":\"UAV\"},\"423\":{\"h\":\"Academic\"},\"424\":{\"h\":\"强化学习\"},\"425\":{\"h\":\"Java\"},\"426\":{\"h\":\"Code\"}},\"dirtCount\":0,\"index\":[[\"淦\",{\"1\":{\"416\":1}}],[\"率\",{\"1\":{\"415\":1}}],[\"项目中代码量非常之大\",{\"1\":{\"415\":1}}],[\"合格\",{\"1\":{\"415\":1}}],[\"良好\",{\"1\":{\"415\":1}}],[\"课程成绩\",{\"1\":{\"415\":1}}],[\"课程号\",{\"1\":{\"415\":1}}],[\"便于我们去使用的类\",{\"1\":{\"407\":1}}],[\"断言表达式\",{\"0\":{\"403\":1}}],[\"永远都不会被捕获\",{\"1\":{\"402\":2}}],[\"父类型在前\",{\"1\":{\"402\":1}}],[\"父类是\",{\"1\":{\"349\":1}}],[\"捕获到异常\",{\"1\":{\"402\":1}}],[\"捕获异常\",{\"1\":{\"399\":1}}],[\"抛给上一级\",{\"1\":{\"402\":1}}],[\"抛出异常\",{\"0\":{\"401\":1}}],[\"明确会抛出ioexception\",{\"1\":{\"402\":1}}],[\"处理\",{\"1\":{\"402\":1}}],[\"处理单位\",{\"1\":{\"245\":3}}],[\"给\",{\"1\":{\"402\":1}}],[\"给定的策略\",{\"1\":{\"154\":1}}],[\"给定策略\",{\"1\":{\"113\":1}}],[\"交给上一级函数\",{\"1\":{\"402\":1}}],[\"请调用方处理好\",{\"1\":{\"401\":1}}],[\"请注意在逗号和两个数之间不能有空格\",{\"1\":{\"381\":1}}],[\"函数调用方必须要对抛出的这个异常进行对应的处理才可以\",{\"1\":{\"401\":1}}],[\"函数的\",{\"0\":{\"377\":1}}],[\"错误\",{\"1\":{\"399\":1,\"403\":1}}],[\"算术异常等\",{\"1\":{\"399\":1}}],[\"算法是用来解决\",{\"1\":{\"119\":1}}],[\"算法是用来求解一个\",{\"1\":{\"113\":1}}],[\"算法如下来进行估计\",{\"1\":{\"116\":1}}],[\"算法同样是来求解\",{\"1\":{\"115\":1}}],[\"算法其目的是用于直接估计\",{\"1\":{\"115\":1}}],[\"算法分析\",{\"0\":{\"113\":1}}],[\"算法所需的数据\",{\"1\":{\"112\":1}}],[\"算法为\",{\"1\":{\"110\":1}}],[\"算法进行求解\",{\"1\":{\"110\":1}}],[\"算法进行求解g\",{\"1\":{\"104\":1}}],[\"算法\",{\"0\":{\"114\":1,\"157\":1},\"1\":{\"104\":2,\"105\":1,\"136\":1}}],[\"算法来进行求解\",{\"1\":{\"99\":1}}],[\"算法就可以用来求解当\",{\"1\":{\"97\":1}}],[\"算法介绍\",{\"0\":{\"97\":1}}],[\"算法流程\",{\"0\":{\"89\":1}}],[\"算法中\",{\"0\":{\"88\":1},\"1\":{\"138\":1}}],[\"算法的统一形式和总结\",{\"0\":{\"127\":1}}],[\"算法的比较\",{\"0\":{\"114\":1}}],[\"算法的问题描述中\",{\"1\":{\"105\":1}}],[\"算法的核心是\",{\"1\":{\"77\":1}}],[\"算法的基础上\",{\"1\":{\"23\":1}}],[\"算法思路\",{\"0\":{\"77\":1}}],[\"算法比较\",{\"0\":{\"70\":1}}],[\"算法描述\",{\"0\":{\"66\":1,\"112\":1}}],[\"算法迭代示意图\",{\"1\":{\"65\":1}}],[\"算法1\",{\"1\":{\"13\":1}}],[\"空指针异常\",{\"1\":{\"399\":1}}],[\"空集合\",{\"0\":{\"236\":1}}],[\"卡布奇诺今犹在\",{\"1\":{\"393\":1}}],[\"任何方法都可以通过方法引用作为实现\",{\"1\":{\"393\":1}}],[\"任何一种\",{\"1\":{\"155\":1}}],[\"待实现的求和方法\",{\"1\":{\"393\":1}}],[\"今天学会了\",{\"1\":{\"392\":5}}],[\"今年\",{\"1\":{\"162\":1}}],[\"代码的健壮性有所欠缺\",{\"1\":{\"415\":1}}],[\"代码语句\",{\"1\":{\"392\":1}}],[\"代码块\",{\"1\":{\"312\":1}}],[\"代码块中的内容会在对象创建时仅执行一次\",{\"1\":{\"166\":1}}],[\"代码块同样会在对象构造之前进行\",{\"1\":{\"166\":1}}],[\"标准格式为\",{\"1\":{\"392\":1}}],[\"标记为native的方法是本地方法\",{\"1\":{\"350\":1}}],[\"标记为公共的内容\",{\"1\":{\"278\":1}}],[\"标记为受保护的内容可以能被类本身和同包中的其他类访问\",{\"1\":{\"278\":1}}],[\"标记为私有的内容无法被除当前类以外的任何位置访问\",{\"1\":{\"278\":1}}],[\"标记位置\",{\"1\":{\"265\":1}}],[\"匿名类只能访问其父类的属性或方法\",{\"1\":{\"390\":1}}],[\"匿名对象通常不能直接给属性赋值\",{\"1\":{\"390\":1}}],[\"匿名对象的类是在创建时匿名生成的\",{\"1\":{\"390\":1}}],[\"匿名对象本身不能定义新的属性\",{\"1\":{\"390\":1}}],[\"匿名内部类特性\",{\"0\":{\"391\":1}}],[\"匿名内部类中同样可以使用类中的属性\",{\"1\":{\"390\":1}}],[\"匿名内部类是我们使用频率非常高的一种内部类\",{\"1\":{\"390\":1}}],[\"匿名内部类\",{\"0\":{\"390\":1},\"1\":{\"391\":1}}],[\"匿名内部类在java8无法使用钻石运算符\",{\"1\":{\"182\":1}}],[\"把未实现的方法实现了\",{\"1\":{\"390\":1}}],[\"把对象的属性和方法结合成一个独立的整体\",{\"1\":{\"347\":1}}],[\"局部内部类直接使用类名就行\",{\"1\":{\"388\":1}}],[\"局部内部类名\",{\"1\":{\"388\":1}}],[\"局部内部类就像局部变量一样\",{\"1\":{\"388\":1}}],[\"局部内部类\",{\"0\":{\"388\":1}}],[\"整个内部类中都处于静态上下文\",{\"1\":{\"387\":1}}],[\"整合\",{\"1\":{\"46\":1}}],[\"套娃了属于是\",{\"1\":{\"386\":1}}],[\"套壳实现的\",{\"1\":{\"224\":1}}],[\"属于\",{\"0\":{\"386\":1,\"387\":1},\"1\":{\"384\":2}}],[\"属性默认就是这个值\",{\"1\":{\"166\":1}}],[\"非空白符\",{\"1\":{\"381\":1}}],[\"非常耗时\",{\"1\":{\"295\":1}}],[\"非常方便\",{\"1\":{\"182\":1}}],[\"^\",{\"1\":{\"381\":1}}],[\"^aeiou\",{\"1\":{\"381\":1}}],[\"^abc\",{\"1\":{\"381\":1}}],[\"至少匹配n\",{\"1\":{\"381\":1}}],[\"至于为什么默认是0\",{\"1\":{\"217\":1}}],[\"至于为什么要这样设计\",{\"1\":{\"188\":1}}],[\"能匹配\",{\"1\":{\"381\":2}}],[\"例如\",{\"1\":{\"381\":8}}],[\"例如当向printstream流中写入一个字节数组后自动调用flush\",{\"1\":{\"284\":1}}],[\"匹配字母\",{\"1\":{\"381\":1}}],[\"匹配字符串\",{\"1\":{\"381\":2}}],[\"匹配所有\",{\"1\":{\"381\":1}}],[\"匹配所有大写字母\",{\"1\":{\"381\":1}}],[\"匹配除换行符\",{\"1\":{\"381\":1}}],[\"匹配除了\",{\"1\":{\"381\":1}}],[\"匹配\",{\"1\":{\"381\":1}}],[\"匹配确定的\",{\"1\":{\"381\":1}}],[\"匹配前面的子表达式零次或一次\",{\"1\":{\"381\":1}}],[\"匹配前面的子表达式零次或多次\",{\"1\":{\"381\":1}}],[\"匹配前面的子表达式一次或多次\",{\"1\":{\"381\":1}}],[\"匹配成功返回true\",{\"1\":{\"381\":1}}],[\"限定符表如下\",{\"1\":{\"381\":1}}],[\"描述\",{\"1\":{\"381\":2}}],[\"描述了一种字符串匹配的模式\",{\"1\":{\"381\":1}}],[\"描述如下\",{\"1\":{\"13\":1}}],[\"行不行\",{\"1\":{\"380\":2}}],[\"汉堡\",{\"1\":{\"380\":2}}],[\"汉堡做滴彳亍不彳亍\",{\"1\":{\"270\":1}}],[\"弥补了字符串不能修改的不足\",{\"1\":{\"380\":1}}],[\"裁剪等操作\",{\"1\":{\"380\":1}}],[\"哥们在这跟你说唱\",{\"1\":{\"376\":1}}],[\"答案是可以的\",{\"1\":{\"375\":1}}],[\"允许\",{\"1\":{\"374\":1}}],[\"允许在任何地方被访问\",{\"1\":{\"278\":1}}],[\"长度是在一开始创建数组的时候就确定好的\",{\"1\":{\"371\":1}}],[\"长度不超过\",{\"1\":{\"228\":1}}],[\"肯定是继承自object的\",{\"1\":{\"370\":1}}],[\"肯定的啊\",{\"1\":{\"172\":1}}],[\"面向对象高级篇\",{\"0\":{\"368\":1,\"397\":1,\"407\":1}}],[\"面向对象高级篇1\",{\"0\":{\"360\":1}}],[\"精确到小数点后100位\",{\"1\":{\"364\":1}}],[\"浮点类型精度有限\",{\"1\":{\"364\":1}}],[\"乘法\",{\"1\":{\"364\":1}}],[\"轻轻松松\",{\"1\":{\"364\":1}}],[\"轻松地就实现了\",{\"1\":{\"224\":1}}],[\"特性\",{\"0\":{\"373\":1}}],[\"特殊包装类\",{\"0\":{\"364\":1}}],[\"特别注意一下\",{\"1\":{\"182\":1}}],[\"覆盖原有构造方法\",{\"1\":{\"356\":1}}],[\"覆盖之后\",{\"1\":{\"216\":1}}],[\"枚举的成员变量\",{\"1\":{\"356\":1}}],[\"枚举类型是普通的类\",{\"1\":{\"356\":1}}],[\"枚举类型使用起来就非常方便了\",{\"1\":{\"356\":1}}],[\"枚举类的语法稍微有一些不一样\",{\"1\":{\"356\":1}}],[\"枚举类\",{\"0\":{\"356\":1}}],[\"睡觉\",{\"1\":{\"356\":2}}],[\"睡觉这三个之中的其中一种\",{\"1\":{\"356\":1}}],[\"学习\",{\"1\":{\"356\":2}}],[\"学生\",{\"1\":{\"354\":1,\"355\":1}}],[\"学生和老师来说\",{\"1\":{\"354\":1}}],[\"全部拷贝为一个新的对象\",{\"1\":{\"355\":1}}],[\"深拷贝会将引用类型的所有内容\",{\"1\":{\"355\":1}}],[\"深拷贝\",{\"1\":{\"355\":1}}],[\"拷贝个基莫\",{\"1\":{\"355\":1}}],[\"浅拷贝\",{\"1\":{\"355\":1}}],[\"克隆实现\",{\"1\":{\"355\":1}}],[\"克隆操作可以完全复制一个对象的所有属性\",{\"1\":{\"355\":1}}],[\"克隆出来的与原来的对象不是一个对象\",{\"1\":{\"355\":1}}],[\"克隆方法\",{\"0\":{\"355\":1}}],[\"克隆当前对象\",{\"1\":{\"350\":1}}],[\"既然是在方法中声明的类\",{\"1\":{\"388\":1}}],[\"既然数组可以是任何类型的\",{\"1\":{\"375\":1}}],[\"既然数组操作都这么方便了\",{\"1\":{\"232\":1}}],[\"既然能装箱\",{\"1\":{\"362\":1}}],[\"既然都有\",{\"1\":{\"354\":1}}],[\"顶多说是多继承的一种替代方案\",{\"1\":{\"354\":1}}],[\"隔开即可\",{\"1\":{\"354\":1}}],[\"逗号\",{\"1\":{\"354\":1}}],[\"甚至连名字都没有\",{\"1\":{\"390\":1}}],[\"甚至还可以继续套娃一个成员内部类\",{\"1\":{\"386\":1}}],[\"甚至还能获取到泛型\",{\"1\":{\"336\":1}}],[\"甚至都不是一个类了\",{\"1\":{\"354\":1}}],[\"甚至都不是一个类\",{\"1\":{\"354\":1}}],[\"他只代表某个确切的功能\",{\"1\":{\"354\":1}}],[\"他们都继承自\",{\"1\":{\"399\":1}}],[\"他们都具有学习这个能力\",{\"1\":{\"354\":1}}],[\"他们其实都是异常类型\",{\"1\":{\"399\":1}}],[\"他们其实是需要配合synchronized来使用的\",{\"1\":{\"318\":1}}],[\"他们可能会做不同的事情\",{\"1\":{\"277\":1}}],[\"抽象成接口来进行使用\",{\"1\":{\"354\":1}}],[\"抽象方法的访问权限不能为\",{\"1\":{\"353\":1}}],[\"抽象方法是指\",{\"1\":{\"353\":1}}],[\"抽象方法\",{\"1\":{\"353\":2}}],[\"抽象类中可以具有抽象方法\",{\"1\":{\"353\":1}}],[\"抽象类的子类也可以是一个抽象类\",{\"1\":{\"353\":1}}],[\"抽象类的实现\",{\"1\":{\"343\":1}}],[\"抽象类一般只用作继承使用\",{\"1\":{\"353\":1}}],[\"抽象类具有\",{\"1\":{\"353\":1}}],[\"抽象类\",{\"0\":{\"353\":1},\"1\":{\"353\":1,\"417\":1}}],[\"控制符\",{\"0\":{\"352\":1}}],[\"控制其一直待在target\",{\"1\":{\"19\":1}}],[\"做滴\",{\"1\":{\"380\":2}}],[\"做题我并不擅长\",{\"1\":{\"351\":1,\"353\":1}}],[\"做传输媒介\",{\"1\":{\"251\":1}}],[\"垃圾\",{\"1\":{\"350\":1}}],[\"十六进制哈希值\",{\"1\":{\"350\":1}}],[\"完整类名\",{\"1\":{\"350\":1}}],[\"完成自我介绍需要执行的所有代码就在这个花括号中编写\",{\"1\":{\"162\":1}}],[\"多个类型变量使用逗号隔开\",{\"1\":{\"416\":1}}],[\"多个异常使用逗号隔开\",{\"1\":{\"401\":1}}],[\"多个不同的对象对同一消息作出响应\",{\"1\":{\"347\":1}}],[\"多维数组\",{\"0\":{\"375\":1},\"1\":{\"410\":1}}],[\"多态\",{\"1\":{\"347\":1}}],[\"多线程4\",{\"0\":{\"328\":1}}],[\"多线程3\",{\"0\":{\"317\":1}}],[\"多线程下java内存管理\",{\"0\":{\"311\":1}}],[\"多线程2\",{\"0\":{\"309\":1}}],[\"多线程\",{\"0\":{\"294\":1}}],[\"多线程与反射\",{\"0\":{\"293\":1,\"308\":1,\"316\":1,\"327\":1}}],[\"叫子类\",{\"1\":{\"347\":1}}],[\"隐藏实现细节\",{\"1\":{\"347\":1}}],[\"隐式加载\",{\"1\":{\"275\":1}}],[\"封装成一个类\",{\"1\":{\"362\":1}}],[\"封装\",{\"0\":{\"347\":1,\"348\":1},\"1\":{\"347\":2}}],[\"仍然是获取不到具体的\",{\"1\":{\"343\":1}}],[\"参数一样\",{\"1\":{\"393\":1}}],[\"参数直接写成lambda表达式\",{\"1\":{\"392\":1}}],[\"参数名称\",{\"1\":{\"376\":1,\"392\":1}}],[\"参数类型\",{\"1\":{\"376\":1,\"392\":1}}],[\"参数类型可能会多种多样\",{\"1\":{\"165\":1}}],[\"参数化类型中可以获取到泛型在定义过程中的参数类型\",{\"1\":{\"343\":1}}],[\"哪些变量等等\",{\"1\":{\"337\":1}}],[\"堆内存\",{\"1\":{\"337\":1}}],[\"慎重使用\",{\"1\":{\"336\":1}}],[\"继续编写throws往上一级抛\",{\"1\":{\"402\":1}}],[\"继续读取会导致mark失效\",{\"1\":{\"265\":1}}],[\"继承也是同样的\",{\"1\":{\"417\":1}}],[\"继承自\",{\"1\":{\"399\":1}}],[\"继承自number类\",{\"1\":{\"362\":1}}],[\"继承自哪个类\",{\"1\":{\"336\":1}}],[\"继承\",{\"0\":{\"349\":1},\"1\":{\"347\":1,\"399\":1}}],[\"继承和多态是面向对象编程的三大特性\",{\"1\":{\"347\":1}}],[\"继承和多态\",{\"0\":{\"347\":1}}],[\"反正只要是符合接口中方法的定义的\",{\"1\":{\"393\":1}}],[\"反正作为新手\",{\"1\":{\"217\":1}}],[\"反射操作可能需要用到\",{\"1\":{\"340\":1}}],[\"反射就是把java类中的各个成分映射成一个个的java对象\",{\"1\":{\"336\":1}}],[\"反射1\",{\"0\":{\"335\":1}}],[\"反射\",{\"0\":{\"334\":1,\"336\":1}}],[\"顾客3\",{\"1\":{\"331\":1}}],[\"顾客2\",{\"1\":{\"331\":1}}],[\"顾客1\",{\"1\":{\"331\":1}}],[\"顾客吃掉菜品的时间为4秒\",{\"1\":{\"331\":1}}],[\"厨师2\",{\"1\":{\"331\":1}}],[\"厨师1\",{\"1\":{\"331\":1}}],[\"消费者可以从货架上拿走商品\",{\"1\":{\"331\":1}}],[\"消费者也在不断的消费\",{\"1\":{\"331\":1}}],[\"生产者此时等待货架出现空位\",{\"1\":{\"331\":1}}],[\"生产者要生产产品\",{\"1\":{\"331\":1}}],[\"生产者与消费者\",{\"0\":{\"331\":1}}],[\"生成流\",{\"1\":{\"228\":1}}],[\"生成\",{\"1\":{\"228\":1}}],[\"生成反向迭代器\",{\"1\":{\"201\":1}}],[\"生成一个匿名的iterator对象\",{\"1\":{\"193\":1}}],[\"生成当前集合的迭代器\",{\"1\":{\"193\":1}}],[\"生成当前集合的并行流\",{\"1\":{\"180\":1}}],[\"生成当前集合的流\",{\"1\":{\"180\":1}}],[\"翻译过来就是\",{\"1\":{\"330\":1}}],[\"程序继续正常运行\",{\"1\":{\"402\":1}}],[\"程序正常运行中\",{\"1\":{\"329\":2}}],[\"程序编译之后的样子是什么样的\",{\"1\":{\"173\":1}}],[\"守护进程在后台运行运行\",{\"1\":{\"329\":1}}],[\"守护线程自动结束\",{\"1\":{\"329\":2}}],[\"守护线程\",{\"0\":{\"329\":1}}],[\"循环间隔\",{\"1\":{\"323\":1}}],[\"循环定时任务等\",{\"1\":{\"323\":1}}],[\"延迟\",{\"1\":{\"323\":1}}],[\"执行一个延时任务\",{\"1\":{\"323\":1}}],[\"定时器\",{\"0\":{\"321\":1}}],[\"定义接口\",{\"1\":{\"354\":1}}],[\"定义可以先放在try外部\",{\"1\":{\"247\":1}}],[\"定义中提到\",{\"1\":{\"241\":1}}],[\"定义的全部功能\",{\"1\":{\"224\":1}}],[\"定义目标函数\",{\"1\":{\"132\":1}}],[\"定义\",{\"0\":{\"370\":1},\"1\":{\"48\":1,\"354\":1}}],[\"定义了agent与环境的交互行为\",{\"1\":{\"19\":1}}],[\"定义为ξ=\",{\"1\":{\"13\":1}}],[\"间隔1秒\",{\"1\":{\"319\":1}}],[\"间隔2秒\",{\"1\":{\"319\":1}}],[\"尝试获取threadlocal中存放的变量\",{\"1\":{\"319\":1}}],[\"尝试将\",{\"1\":{\"142\":1}}],[\"专门创建一个独属于某个线程的变量\",{\"1\":{\"319\":1}}],[\"专门用于表示一个文件或文件夹\",{\"1\":{\"255\":1}}],[\"专门用于处理文本数据\",{\"1\":{\"245\":1}}],[\"唤醒所有等待当前对象锁的线程\",{\"1\":{\"350\":1}}],[\"唤醒一个等待当前对象锁的线程\",{\"1\":{\"350\":1}}],[\"唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\",{\"1\":{\"318\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"318\":1}}],[\"开始唤醒\",{\"1\":{\"318\":1}}],[\"开始等待\",{\"1\":{\"318\":1}}],[\"态\",{\"1\":{\"318\":1}}],[\"平常环境下是无法使用的\",{\"1\":{\"318\":1}}],[\"导致程序卡住\",{\"1\":{\"313\":1}}],[\"导入我们需要使用的类\",{\"1\":{\"277\":1}}],[\"死锁是指两个线程相互持有对方需要的锁\",{\"1\":{\"313\":1}}],[\"死锁\",{\"0\":{\"313\":1}}],[\"传入的如果是对象\",{\"1\":{\"312\":1}}],[\"传入fileinputstream\",{\"1\":{\"262\":1}}],[\"难道取1000还可能吐2000出来吗\",{\"1\":{\"311\":1}}],[\"好比说一个银行\",{\"1\":{\"311\":1}}],[\"缓存一致性\",{\"1\":{\"311\":1}}],[\"缓冲字符输出流\",{\"0\":{\"270\":1}}],[\"缓冲字符读取流\",{\"0\":{\"269\":1}}],[\"缓冲字符流\",{\"0\":{\"268\":1}}],[\"缓冲字节输出流\",{\"0\":{\"267\":1}}],[\"缓冲字节读取流\",{\"0\":{\"262\":1}}],[\"缓冲字节流\",{\"0\":{\"261\":1}}],[\"缓冲机制\",{\"0\":{\"265\":1}}],[\"缓冲区\",{\"1\":{\"260\":1}}],[\"缓冲流可以叠加\",{\"0\":{\"266\":1}}],[\"缓冲流特性\",{\"0\":{\"263\":1}}],[\"缓冲流\",{\"0\":{\"260\":1}}],[\"称之为\",{\"1\":{\"311\":1}}],[\"称为\",{\"1\":{\"113\":1}}],[\"称为策略评估\",{\"1\":{\"45\":1}}],[\"写共享变量的副本\",{\"1\":{\"311\":1}}],[\"写入的是二进制数据\",{\"1\":{\"286\":1}}],[\"写入对应长度的数据到输出流\",{\"1\":{\"251\":1}}],[\"尽可能多的在执行线程2的内容\",{\"1\":{\"304\":1}}],[\"尽可能的扬长避短\",{\"1\":{\"182\":1}}],[\"观察结果\",{\"1\":{\"304\":1}}],[\"常用工具类\",{\"0\":{\"408\":1}}],[\"常规优先级\",{\"1\":{\"302\":1}}],[\"常数\",{\"1\":{\"9\":1}}],[\"复位中断标记\",{\"1\":{\"301\":2}}],[\"复制到\",{\"1\":{\"142\":1}}],[\"休眠后再运行\",{\"1\":{\"322\":2}}],[\"休眠3秒\",{\"1\":{\"301\":1}}],[\"休眠时间\",{\"1\":{\"299\":1}}],[\"响应中断\",{\"1\":{\"301\":1}}],[\"显示声明了会抛出一个interruptedexception异常\",{\"1\":{\"300\":1}}],[\"显然无法在编译期确定类型是否安全\",{\"1\":{\"415\":1}}],[\"显然是\",{\"1\":{\"150\":1}}],[\"显然是可以通过一个\",{\"1\":{\"66\":1}}],[\"显然我们仍然可以通过\",{\"1\":{\"110\":1}}],[\"显然我们可以将\",{\"1\":{\"104\":1}}],[\"显然ϵ=0\",{\"1\":{\"87\":1}}],[\"显然其核心关键就是在\",{\"1\":{\"77\":1}}],[\"显然在现实运行算法中是无法做到的\",{\"1\":{\"71\":1}}],[\"显然\",{\"1\":{\"19\":1,\"23\":1,\"63\":1,\"71\":1,\"78\":1,\"86\":1,\"96\":1,\"104\":1}}],[\"被除数不能为0\",{\"1\":{\"401\":2}}],[\"被挂起的线程才能继续\",{\"1\":{\"313\":1}}],[\"被\",{\"1\":{\"300\":1}}],[\"手动调用wait\",{\"1\":{\"300\":1}}],[\"阻塞态\",{\"1\":{\"318\":1}}],[\"阻塞\",{\"1\":{\"300\":1}}],[\"或是继续使用此泛型让具体创建的对象来确定类型\",{\"1\":{\"417\":1}}],[\"或是调用sleep\",{\"1\":{\"299\":1}}],[\"或者是继续摆烂\",{\"1\":{\"417\":1}}],[\"或者是false\",{\"1\":{\"370\":1}}],[\"或者为静态变量赋值\",{\"1\":{\"275\":1}}],[\"或者\",{\"1\":{\"23\":1,\"66\":1,\"131\":1,\"156\":1,\"372\":1,\"391\":1}}],[\"始终都是依次进行的\",{\"1\":{\"295\":1}}],[\"线程a和线程b都需要对方的锁\",{\"1\":{\"313\":1}}],[\"线程锁\",{\"0\":{\"312\":1},\"1\":{\"312\":1}}],[\"线程锁和线程同步\",{\"0\":{\"310\":1}}],[\"线程之间的共享变量\",{\"1\":{\"311\":1}}],[\"线程之间是同时运行的\",{\"1\":{\"296\":1}}],[\"线程2变量值已设定\",{\"1\":{\"319\":1}}],[\"线程2\",{\"1\":{\"313\":1}}],[\"线程2完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"线程2等待线程1待执行的内容全部执行完成之后\",{\"1\":{\"305\":1}}],[\"线程2开始运行\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程1读取变量值\",{\"1\":{\"319\":1}}],[\"线程1变量值已设定\",{\"1\":{\"319\":1}}],[\"线程1\",{\"1\":{\"313\":1}}],[\"线程1完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"线程1加入后\",{\"1\":{\"305\":1}}],[\"线程1加入到此线程\",{\"1\":{\"305\":1}}],[\"线程1结束\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程1开始运行\",{\"1\":{\"304\":1,\"305\":1}}],[\"线程优先级\",{\"0\":{\"302\":1}}],[\"线程被中断了\",{\"1\":{\"301\":1}}],[\"线程开始运行\",{\"1\":{\"301\":1,\"302\":1}}],[\"线程的加入只是等待另一个线程的完成\",{\"1\":{\"305\":1}}],[\"线程的礼让和加入\",{\"0\":{\"303\":1}}],[\"线程的优先级一般分为以下三种\",{\"1\":{\"302\":1}}],[\"线程的下一个状态会出现以下情况\",{\"1\":{\"300\":1}}],[\"线程的休眠和中断\",{\"0\":{\"300\":1}}],[\"线程的创建和启动\",{\"0\":{\"296\":1}}],[\"线程和进程差不多\",{\"1\":{\"299\":1}}],[\"线程是程序执行中一个单一的顺序控制流程\",{\"1\":{\"295\":1}}],[\"线程横空出世\",{\"1\":{\"295\":1}}],[\"线性表支持随机访问\",{\"1\":{\"181\":1}}],[\"线性表\",{\"1\":{\"181\":1}}],[\"网易云音乐等软件\",{\"1\":{\"295\":1}}],[\"网络的输入包括\",{\"1\":{\"142\":1}}],[\"浏览器\",{\"1\":{\"295\":1}}],[\"进而补货\",{\"1\":{\"331\":1}}],[\"进入等待状态并释放锁\",{\"1\":{\"318\":1}}],[\"进程之间的通信就变得非常麻烦\",{\"1\":{\"295\":1}}],[\"进程是拥有资源和独立运行的最小单位\",{\"1\":{\"295\":1}}],[\"进程是程序执行的实体\",{\"1\":{\"295\":1}}],[\"进程与线程概念\",{\"0\":{\"295\":1}}],[\"进行类型比较又会导致额外的开销和增加代码量\",{\"1\":{\"415\":1}}],[\"进行异常捕获\",{\"1\":{\"402\":1}}],[\"进行捕获\",{\"1\":{\"402\":1}}],[\"进行拼接操作\",{\"1\":{\"380\":1}}],[\"进行数据转换就会很麻烦\",{\"1\":{\"283\":1}}],[\"进行判断\",{\"1\":{\"241\":1}}],[\"进行判断来删除元素\",{\"1\":{\"241\":1}}],[\"进行判断的\",{\"1\":{\"241\":1}}],[\"进行分割\",{\"1\":{\"228\":1}}],[\"进行倒序排列\",{\"1\":{\"228\":1}}],[\"进行优化\",{\"1\":{\"148\":1}}],[\"进行训练\",{\"1\":{\"142\":1}}],[\"进行赋值\",{\"1\":{\"142\":1}}],[\"进行固定求解\",{\"1\":{\"142\":1}}],[\"进行生成数据\",{\"1\":{\"125\":1}}],[\"进行更新即可\",{\"1\":{\"115\":1}}],[\"进行的采样\",{\"1\":{\"84\":1}}],[\"进行估计\",{\"1\":{\"78\":1,\"94\":1}}],[\"进行了无穷多步来进行了真实的求解\",{\"1\":{\"71\":1}}],[\"进行迭代\",{\"1\":{\"70\":1,\"101\":1}}],[\"进行求解\",{\"1\":{\"47\":1,\"66\":1,\"103\":1}}],[\"取值只能进行强制类型转换\",{\"1\":{\"415\":1}}],[\"取值范围从1−4\",{\"1\":{\"10\":1}}],[\"取消这些不必要保存的属性\",{\"1\":{\"290\":1}}],[\"秘制小汉堡\",{\"1\":{\"285\":1}}],[\"系统输入流\",{\"1\":{\"285\":1}}],[\"系统结构\",{\"0\":{\"7\":1}}],[\"放入缓冲区再经过转换流输出到给定的输出流上\",{\"1\":{\"284\":1}}],[\"打印栈追踪信息\",{\"1\":{\"402\":1}}],[\"打印当前线程名称\",{\"1\":{\"323\":1}}],[\"打印\",{\"1\":{\"299\":1,\"410\":1}}],[\"打印流其实我们从一开始就在使用了\",{\"1\":{\"284\":1}}],[\"打印流\",{\"0\":{\"284\":1}}],[\"打印集合类\",{\"1\":{\"182\":1}}],[\"❌\",{\"1\":{\"278\":6}}],[\"✅\",{\"1\":{\"278\":10}}],[\"公共\",{\"1\":{\"278\":1}}],[\"子类也可以定义\",{\"1\":{\"353\":1}}],[\"子类对应必须是\",{\"1\":{\"353\":1}}],[\"子类必须要实现抽象类所有的抽象方法\",{\"1\":{\"353\":1}}],[\"子类\",{\"1\":{\"353\":1}}],[\"子类是\",{\"1\":{\"349\":1}}],[\"子类实现了父类所有非私有化的属性和方法\",{\"1\":{\"347\":1}}],[\"子类我们会在下一章介绍\",{\"1\":{\"278\":1}}],[\"子类初始化时\",{\"1\":{\"275\":1}}],[\"受保护\",{\"1\":{\"278\":1}}],[\"受限制的始终是底层哈希表的长度\",{\"1\":{\"217\":1}}],[\"什么都不写\",{\"1\":{\"278\":1}}],[\"什么时候更新策略也是一个影响效率的因素\",{\"1\":{\"82\":1}}],[\"私有\",{\"1\":{\"278\":1}}],[\"包装类支持字符串直接转换\",{\"1\":{\"363\":1}}],[\"包装类的方法\",{\"0\":{\"363\":1}}],[\"包装类实际上就是将我们的基本数据类型\",{\"1\":{\"362\":1}}],[\"包装类型支持自动装箱\",{\"1\":{\"362\":1}}],[\"包装类型的自动装箱和拆箱机制\",{\"1\":{\"362\":1}}],[\"包装类型都有一个type\",{\"1\":{\"340\":1}}],[\"包延时任务\",{\"1\":{\"323\":1}}],[\"包其实就是用来区分类位置的东西\",{\"1\":{\"277\":1}}],[\"包的命名规则同样是英文和数字的组合\",{\"1\":{\"277\":1}}],[\"包的声明和导入\",{\"0\":{\"277\":1}}],[\"包的访问与控制\",{\"0\":{\"276\":1}}],[\"包括接口\",{\"1\":{\"417\":1}}],[\"包括课程名称\",{\"1\":{\"415\":1}}],[\"包括返回值\",{\"1\":{\"392\":1}}],[\"包括对方法的调用和super关键字的使用\",{\"1\":{\"386\":1}}],[\"包括对象内部的所有成员变量\",{\"1\":{\"355\":1}}],[\"包括对象的各个属性\",{\"1\":{\"350\":1}}],[\"包括换行\",{\"1\":{\"381\":1}}],[\"包括引用类型和基本类型\",{\"1\":{\"369\":1}}],[\"包括void\",{\"1\":{\"340\":1}}],[\"包括类里面有哪些方法\",{\"1\":{\"337\":1}}],[\"包括类里面有哪些字段\",{\"1\":{\"336\":1}}],[\"包括文本\",{\"1\":{\"245\":1}}],[\"包括\",{\"1\":{\"223\":1}}],[\"包括列表\",{\"1\":{\"178\":1}}],[\"包括数组复制方法\",{\"1\":{\"171\":1}}],[\"静态内部类编译特性\",{\"0\":{\"389\":1}}],[\"静态内部类由于是静态的\",{\"1\":{\"387\":1}}],[\"静态内部类的类名同样是之前的格式\",{\"1\":{\"387\":1}}],[\"静态内部类就像静态方法和静态变量一样\",{\"1\":{\"387\":1}}],[\"静态内部类\",{\"0\":{\"387\":1}}],[\"静态\",{\"1\":{\"384\":1}}],[\"静态初始化\",{\"1\":{\"370\":1}}],[\"静态导入test方法\",{\"1\":{\"278\":1}}],[\"静态导入\",{\"1\":{\"278\":1}}],[\"静态方法使用\",{\"1\":{\"393\":1}}],[\"静态方法甚至是类指定访问权限\",{\"1\":{\"278\":1}}],[\"静态方法同样是属于类的\",{\"1\":{\"274\":1}}],[\"静态变量\",{\"1\":{\"278\":1}}],[\"静态变量初始化\",{\"0\":{\"275\":1}}],[\"静态变量和静态方法\",{\"0\":{\"274\":1}}],[\"静态的内容\",{\"1\":{\"274\":1}}],[\"静止\",{\"1\":{\"13\":1}}],[\"清空缓冲区\",{\"1\":{\"270\":1}}],[\"清空整个map\",{\"1\":{\"213\":1}}],[\"清空整个集合\",{\"1\":{\"180\":1}}],[\"读取后直接得到一个字符串\",{\"1\":{\"269\":1}}],[\"读取一个少一个\",{\"1\":{\"248\":1}}],[\"已经超过了readlimit\",{\"1\":{\"265\":1}}],[\"已知的情况\",{\"1\":{\"96\":1}}],[\"已知\",{\"1\":{\"77\":1}}],[\"回到mark时的位置\",{\"1\":{\"265\":1}}],[\"主线程停止1秒\",{\"1\":{\"311\":1,\"312\":2}}],[\"主动让出cpu资源\",{\"0\":{\"304\":1}}],[\"主方法的string参数是java\",{\"1\":{\"277\":1}}],[\"主机接收了就没了\",{\"1\":{\"265\":1}}],[\"主要区别\",{\"1\":{\"245\":1}}],[\"主要类\",{\"1\":{\"245\":2}}],[\"主要方法\",{\"1\":{\"189\":1}}],[\"主要框架\",{\"1\":{\"18\":1}}],[\"主要内容\",{\"0\":{\"6\":1}}],[\"主要贡献\",{\"0\":{\"5\":1}}],[\"主要动机\",{\"0\":{\"4\":1}}],[\"暂时不需要了解\",{\"1\":{\"264\":1}}],[\"暂时不做讲解\",{\"1\":{\"193\":1}}],[\"装饰着模式\",{\"0\":{\"264\":1}}],[\"很容易出现以下的情况\",{\"1\":{\"415\":1}}],[\"很遗憾\",{\"1\":{\"371\":1}}],[\"很有可能造成程序反应迟钝\",{\"1\":{\"260\":1}}],[\"很简单\",{\"1\":{\"182\":1}}],[\"虽然并不是一开始的类型\",{\"1\":{\"415\":1}}],[\"虽然是继承于\",{\"1\":{\"371\":1}}],[\"虽然我们目前还没有学习数组\",{\"1\":{\"362\":1}}],[\"虽然a和b的值相同\",{\"1\":{\"362\":1}}],[\"虽然java语言是一个面向对象的语言\",{\"1\":{\"361\":1}}],[\"虽然任务执行完成了\",{\"1\":{\"324\":1}}],[\"虽然stop\",{\"1\":{\"299\":1}}],[\"虽然能得到对象\",{\"1\":{\"290\":1}}],[\"虽然给定的是fileinputstream\",{\"1\":{\"283\":1}}],[\"虽然给定的是fileoutputstream\",{\"1\":{\"283\":1}}],[\"虽然普通的文件流读取文件数据非常便捷\",{\"1\":{\"260\":1}}],[\"虽然这两种列表的实现不同\",{\"1\":{\"190\":1}}],[\"刷新\",{\"1\":{\"254\":1}}],[\"牛\",{\"1\":{\"254\":2}}],[\"支持c语言样式\",{\"1\":{\"370\":1}}],[\"支持参数\",{\"1\":{\"318\":1}}],[\"支持\",{\"1\":{\"265\":1}}],[\"支持获取编码\",{\"1\":{\"254\":1}}],[\"支持泛型的数组转换\",{\"1\":{\"180\":1}}],[\"追加操作\",{\"0\":{\"250\":1}}],[\"强制类型转换\",{\"1\":{\"341\":1,\"354\":1}}],[\"强制写入\",{\"1\":{\"249\":1}}],[\"强化学习\",{\"0\":{\"424\":1},\"2\":{\"22\":1,\"35\":1,\"51\":1,\"60\":1,\"74\":1,\"91\":1,\"108\":1,\"129\":1,\"146\":1,\"159\":1}}],[\"强化学习框架图\",{\"0\":{\"18\":1}}],[\"建议在最后执行一次刷新操作\",{\"1\":{\"249\":1}}],[\"建议在finally中进行\",{\"1\":{\"247\":1}}],[\"操作出现在suspend\",{\"1\":{\"313\":1}}],[\"操作的都是同一个目标\",{\"1\":{\"274\":1}}],[\"操作和原来的流是一样的\",{\"1\":{\"262\":1}}],[\"操作\",{\"1\":{\"249\":1,\"265\":1,\"269\":1}}],[\"操作而是write\",{\"1\":{\"249\":1}}],[\"操作就是相同的\",{\"1\":{\"241\":1}}],[\"跳过了一个字节\",{\"1\":{\"248\":1}}],[\"尤其是在网络i\",{\"1\":{\"248\":1}}],[\"文件其实就是我们编写的一个类\",{\"1\":{\"275\":1}}],[\"文件丢给\",{\"1\":{\"275\":1}}],[\"文件字符流\",{\"0\":{\"252\":1}}],[\"文件字节流\",{\"0\":{\"246\":1}}],[\"文件拷贝操作实现\",{\"0\":{\"251\":1}}],[\"文件读取\",{\"0\":{\"248\":1}}],[\"路径\",{\"1\":{\"247\":2}}],[\"减少了字节到字符的转换时间\",{\"1\":{\"245\":1}}],[\"性质\",{\"0\":{\"374\":1}}],[\"性能\",{\"1\":{\"245\":1}}],[\"性别呢\",{\"1\":{\"166\":1}}],[\"性别\",{\"1\":{\"161\":1}}],[\"字母的所有字母\",{\"1\":{\"381\":1}}],[\"字母\",{\"1\":{\"381\":1}}],[\"字符\",{\"1\":{\"381\":2}}],[\"字符数组转字符串\",{\"1\":{\"379\":1}}],[\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组\",{\"1\":{\"379\":1}}],[\"字符串支持使用\",{\"1\":{\"380\":1}}],[\"字符串类中提供了很多方便我们操作的方法\",{\"1\":{\"379\":1}}],[\"字符串类是一个比较特殊的类\",{\"1\":{\"378\":1}}],[\"字符串的内容比较\",{\"1\":{\"379\":1}}],[\"字符串中的字符一旦确定\",{\"1\":{\"378\":1}}],[\"字符串\",{\"0\":{\"367\":1,\"378\":1}}],[\"字符串转integer有多个方法\",{\"1\":{\"363\":1}}],[\"字符串内容的比较\",{\"1\":{\"351\":1}}],[\"字符流只支持char\",{\"1\":{\"253\":1}}],[\"字符流是以一个具体的字符进行读取\",{\"1\":{\"253\":1}}],[\"字符流不同于字节\",{\"1\":{\"253\":1}}],[\"字符流在处理文本数据时通常更高效\",{\"1\":{\"245\":1}}],[\"字符流自动处理字符编码转换\",{\"1\":{\"245\":1}}],[\"字符流仅适用于文本数据\",{\"1\":{\"245\":1}}],[\"字符流以字符为单位\",{\"1\":{\"245\":1}}],[\"字符流\",{\"1\":{\"245\":1}}],[\"字节流不处理字符编码\",{\"1\":{\"245\":1}}],[\"字节流适用于所有类型的数据\",{\"1\":{\"245\":1}}],[\"字节流以字节为单位\",{\"1\":{\"245\":1}}],[\"字节流\",{\"1\":{\"245\":1}}],[\"编译时异常的子类有很多很多\",{\"1\":{\"400\":1}}],[\"编译时异常只需要继承\",{\"1\":{\"400\":1}}],[\"编译时异常明确指出可能会出现的异常\",{\"1\":{\"399\":1}}],[\"编译时异常\",{\"1\":{\"399\":1}}],[\"编译器是很聪明的\",{\"1\":{\"380\":1}}],[\"编译器不知道到底我们想用的是哪一个string类\",{\"1\":{\"277\":1}}],[\"编译出来就自带\",{\"1\":{\"166\":1}}],[\"编码处理\",{\"1\":{\"245\":3}}],[\"及其子类\",{\"1\":{\"245\":2}}],[\"视频等二进制数据\",{\"1\":{\"245\":1}}],[\"视为一个特殊情况下的\",{\"1\":{\"104\":1}}],[\"视为\",{\"1\":{\"104\":1,\"142\":1}}],[\"音频\",{\"1\":{\"245\":1}}],[\"图片\",{\"1\":{\"245\":1}}],[\"适用范围\",{\"1\":{\"245\":1}}],[\"适用于处理文本文件\",{\"1\":{\"245\":1}}],[\"适用于处理所有类型的数据\",{\"1\":{\"245\":1}}],[\"适用场景\",{\"1\":{\"245\":2}}],[\"位\",{\"1\":{\"245\":2}}],[\"判断当前对象和给定对象是否相等\",{\"1\":{\"350\":1}}],[\"判断是否为子类或是接口\",{\"1\":{\"343\":1}}],[\"判断是否存在中断标志\",{\"1\":{\"301\":1}}],[\"判断相同\",{\"1\":{\"241\":1}}],[\"判断修改成根据\",{\"1\":{\"241\":1}}],[\"判断两个元素是否相同\",{\"1\":{\"241\":1}}],[\"判断两个键值对是否相等\",{\"1\":{\"213\":1}}],[\"判断两个集合是否相等\",{\"1\":{\"180\":1}}],[\"元素中的\",{\"1\":{\"241\":1}}],[\"元素流在管道中经过\",{\"1\":{\"228\":1}}],[\"快速取最小值\",{\"1\":{\"409\":1}}],[\"快速取最大值\",{\"1\":{\"409\":1}}],[\"快速获取文件夹下的文件名称列表\",{\"1\":{\"255\":1}}],[\"快速获取最大值\",{\"1\":{\"228\":1}}],[\"快速填充\",{\"0\":{\"235\":1}}],[\"二分搜索\",{\"0\":{\"234\":1}}],[\"汇成新的list\",{\"1\":{\"228\":1}}],[\"变成独立的6个元素\",{\"1\":{\"228\":1}}],[\"变量名称\",{\"1\":{\"370\":4}}],[\"变量的值就是当前对象的存放值\",{\"1\":{\"162\":1}}],[\"变量的类型就是对应的类名\",{\"1\":{\"161\":1}}],[\"变量使用之前需要先赋值\",{\"1\":{\"161\":1}}],[\"依然使用泛型\",{\"1\":{\"417\":1}}],[\"依然是就近原则\",{\"1\":{\"386\":1}}],[\"依附任何对象我们可以直接创建使用\",{\"1\":{\"387\":1}}],[\"依附于b创建的对象\",{\"1\":{\"386\":1}}],[\"依附于a创建的对象\",{\"1\":{\"386\":1}}],[\"依次打印\",{\"1\":{\"228\":1}}],[\"依赖于当前状态和所采取的动作\",{\"1\":{\"19\":1}}],[\"本地方法不是我们se中需要学习的内容\",{\"1\":{\"350\":1}}],[\"本地内存\",{\"1\":{\"311\":1}}],[\"本来应该进行2次自增操作\",{\"1\":{\"311\":1}}],[\"本质就是调用的构造方法\",{\"1\":{\"356\":1}}],[\"本质和普通进程类似\",{\"1\":{\"329\":1}}],[\"本质也是reader和writer\",{\"1\":{\"283\":1}}],[\"本质上是一个intstream\",{\"1\":{\"228\":1}}],[\"本文目的是优化无人机在每个时隙的位置\",{\"1\":{\"11\":1}}],[\"没啥意义\",{\"1\":{\"364\":1}}],[\"没错\",{\"1\":{\"237\":1,\"393\":1}}],[\"没想到吧\",{\"1\":{\"228\":1}}],[\"没有方法体\",{\"1\":{\"353\":1}}],[\"没有的话就暂时处于休眠状态\",{\"1\":{\"324\":1}}],[\"没有使用哈希表\",{\"1\":{\"219\":1}}],[\"没有返回值\",{\"1\":{\"162\":1}}],[\"工人\",{\"1\":{\"353\":1}}],[\"工作内存中存储了该线程以读\",{\"1\":{\"311\":1}}],[\"工具类一般都会内置大量的静态方法\",{\"1\":{\"407\":1}}],[\"工具类就是专门为一些特定场景编写的\",{\"1\":{\"407\":1}}],[\"工具类\",{\"0\":{\"231\":1,\"232\":1,\"406\":1}}],[\"工具类中\",{\"1\":{\"182\":1}}],[\"工厂的机器才会按照预定的流程启动\",{\"1\":{\"228\":1}}],[\"z0\",{\"1\":{\"381\":1}}],[\"za\",{\"1\":{\"381\":1}}],[\"zo+\",{\"1\":{\"381\":1}}],[\"zoo\",{\"1\":{\"381\":2}}],[\"zo\",{\"1\":{\"381\":2}}],[\"z\",{\"1\":{\"228\":1,\"381\":5}}],[\"去挂起线程的原因\",{\"1\":{\"313\":1}}],[\"去执行的\",{\"1\":{\"275\":1}}],[\"去重\",{\"1\":{\"228\":2}}],[\"去除\",{\"1\":{\"228\":1}}],[\"里面条件为\",{\"1\":{\"228\":1}}],[\"首字母不是大写字母\",{\"1\":{\"228\":1}}],[\"首先实现cloneable接口\",{\"1\":{\"355\":1}}],[\"首先利用jps找到我们的java进程号\",{\"1\":{\"313\":1}}],[\"首先初始化一个随机的策略π0​\",{\"1\":{\"79\":1}}],[\"首先随机设计一个初始的策略π0​\",{\"1\":{\"66\":1}}],[\"过滤\",{\"1\":{\"228\":2}}],[\"过去研究主要考虑的是2d部署\",{\"1\":{\"4\":1}}],[\"过去研究大多没有基于用户的移动\",{\"1\":{\"4\":1}}],[\"聚合等\",{\"1\":{\"228\":1}}],[\"排序\",{\"1\":{\"228\":1}}],[\"流的内容是有限的\",{\"1\":{\"248\":1}}],[\"流在管道中传输\",{\"1\":{\"228\":1}}],[\"流stream\",{\"1\":{\"228\":1}}],[\"简单理解为\",{\"1\":{\"337\":1}}],[\"简而言之\",{\"1\":{\"336\":1}}],[\"简洁的代码\",{\"1\":{\"228\":1}}],[\"简介\",{\"0\":{\"188\":1}}],[\"干净\",{\"1\":{\"228\":1}}],[\"语句块进行异常的捕获\",{\"1\":{\"402\":1}}],[\"语句块来处理\",{\"1\":{\"402\":1}}],[\"语句从数据库查询数据的直观方式来提供一种对\",{\"1\":{\"228\":1}}],[\"语法\",{\"1\":{\"187\":1,\"193\":1}}],[\"利用了\",{\"1\":{\"224\":1}}],[\"利用这种特性\",{\"1\":{\"201\":1}}],[\"几乎都在操作内部维护的一个hashmap\",{\"1\":{\"224\":1}}],[\"你看\",{\"1\":{\"380\":2}}],[\"你会发现它更像一个sql语句\",{\"1\":{\"228\":1}}],[\"你会发现所有的方法全是替身攻击\",{\"1\":{\"224\":1}}],[\"你只需要坐着等别人写好然后你自己拿去交差就行了\",{\"1\":{\"224\":1}}],[\"你没看错\",{\"1\":{\"224\":1}}],[\"玛卡\",{\"1\":{\"223\":1}}],[\"巴卡\",{\"1\":{\"223\":1}}],[\"单走\",{\"1\":{\"223\":4}}],[\"若此文件不存在\",{\"1\":{\"249\":1}}],[\"若不存在则计算并插入新的值\",{\"1\":{\"221\":1}}],[\"若key不存在\",{\"1\":{\"221\":1}}],[\"若\",{\"1\":{\"221\":1}}],[\"若有一系列\",{\"1\":{\"75\":1}}],[\"顺序就同我们的插入顺序一致\",{\"1\":{\"218\":1}}],[\"具有\",{\"1\":{\"218\":1}}],[\"具体类型不同的泛型类变量\",{\"1\":{\"416\":1}}],[\"具体类型只能是我们指定的上界类型或是上界类型的子类\",{\"1\":{\"172\":1}}],[\"具体使用\",{\"1\":{\"416\":1}}],[\"具体实现克隆\",{\"1\":{\"355\":1}}],[\"具体的实现由\",{\"1\":{\"353\":1}}],[\"具体而言\",{\"1\":{\"162\":1}}],[\"具体推导过程\",{\"1\":{\"155\":1}}],[\"具体解决如下\",{\"1\":{\"97\":1}}],[\"具体求解方法\",{\"1\":{\"79\":1}}],[\"具体算法\",{\"0\":{\"79\":1}}],[\"具体步骤\",{\"0\":{\"63\":1}}],[\"具体分两步\",{\"1\":{\"56\":1}}],[\"具体代码\",{\"1\":{\"13\":1}}],[\"具体表述如下\",{\"1\":{\"11\":1}}],[\"具体如下\",{\"1\":{\"10\":1,\"142\":1}}],[\"详细过程就不介绍了\",{\"1\":{\"217\":1}}],[\"原因很多\",{\"1\":{\"217\":1}}],[\"原本就有的\",{\"1\":{\"194\":3}}],[\"阈值为负载因子乘以默认容量\",{\"1\":{\"217\":1}}],[\"旧容量不大于0只可能是还没初始化\",{\"1\":{\"217\":1}}],[\"新的容量直接等于默认容量16\",{\"1\":{\"217\":1}}],[\"新的容量等于旧容量的2倍\",{\"1\":{\"217\":1}}],[\"新的阈值也提升到原来的两倍\",{\"1\":{\"217\":1}}],[\"新增操作\",{\"1\":{\"214\":1}}],[\"此外\",{\"1\":{\"343\":1}}],[\"此外在每次扩容时会调用\",{\"1\":{\"217\":1}}],[\"此方法会直接终止此线程\",{\"1\":{\"299\":1}}],[\"此文件是否存在\",{\"1\":{\"255\":1}}],[\"此时发生异常再往上抛出的话\",{\"1\":{\"402\":1}}],[\"此时这里创建出来的student对象\",{\"1\":{\"390\":1}}],[\"此时我们怎么去明确要使用的是哪一个\",{\"1\":{\"386\":1}}],[\"此时由于三个属性完全一致\",{\"1\":{\"351\":1}}],[\"此时消费者在等待生产者往货架上生产产品\",{\"1\":{\"331\":1}}],[\"此时获取键为3的值\",{\"1\":{\"214\":1}}],[\"此时再调用next将不能再得到下一个元素\",{\"1\":{\"188\":1}}],[\"此时元素成功被移除\",{\"1\":{\"182\":1}}],[\"此时虽然使用的是通配符\",{\"1\":{\"172\":1}}],[\"此时this\",{\"1\":{\"166\":1}}],[\"此时变量没有引用任何对象\",{\"1\":{\"161\":1}}],[\"此时可以分析每一个状态在这个策略下的概率\",{\"1\":{\"135\":1}}],[\"此时也可以是\",{\"1\":{\"124\":1}}],[\"此时就是随机策略\",{\"1\":{\"87\":1}}],[\"此时\",{\"1\":{\"46\":1,\"77\":1,\"125\":1}}],[\"此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​\",{\"1\":{\"19\":1}}],[\"此时该trajectory的return=0+0+0+1+1+⋯=∞\",{\"1\":{\"19\":1}}],[\"此时的mos模型定义如下\",{\"1\":{\"10\":1}}],[\"正好可以匹配\",{\"1\":{\"381\":1}}],[\"正则表达式并不是只有java才支持\",{\"1\":{\"381\":1}}],[\"正则表达式\",{\"0\":{\"367\":1,\"381\":1},\"1\":{\"381\":2}}],[\"正是这三大特性\",{\"1\":{\"347\":1}}],[\"正常实例化方法是无法创造抽象类的实例\",{\"1\":{\"353\":1}}],[\"正常情况下是不会出错的\",{\"1\":{\"399\":1}}],[\"正常情况下\",{\"1\":{\"343\":1,\"390\":1}}],[\"正常插入键值对返回值为null\",{\"1\":{\"216\":1}}],[\"正确性和收敛性分析\",{\"0\":{\"104\":1}}],[\"键值对size计数自增\",{\"1\":{\"216\":1}}],[\"键也相同\",{\"1\":{\"216\":1}}],[\"达到了阈值\",{\"1\":{\"216\":1}}],[\"找到尾部\",{\"1\":{\"216\":1}}],[\"找的是在所有可能策略中的最优策略\",{\"1\":{\"88\":1}}],[\"普通的类也可以\",{\"1\":{\"390\":1}}],[\"普通的list只需要一个方法就可以直接转换到方便好用的intstream了\",{\"1\":{\"228\":1}}],[\"普通链表就直接在链表尾部插入\",{\"1\":{\"216\":1}}],[\"普通队列中从队尾入队\",{\"1\":{\"201\":1}}],[\"说明这种情况下\",{\"1\":{\"389\":1}}],[\"说明这个链表已经升级为红黑树了\",{\"1\":{\"216\":1}}],[\"说明外部希望当前线程立即停止\",{\"1\":{\"301\":1}}],[\"说明已经存放了相同键的键值对了\",{\"1\":{\"216\":1}}],[\"初始容量为16\",{\"1\":{\"216\":1}}],[\"先实现未实现的方法\",{\"1\":{\"390\":1}}],[\"先转换为当前类型\",{\"1\":{\"351\":1}}],[\"先加载\",{\"1\":{\"337\":1}}],[\"先完成线程1的内容\",{\"1\":{\"305\":1}}],[\"先把下面这几个旧的东西保存一下\",{\"1\":{\"217\":1}}],[\"先初始化\",{\"1\":{\"216\":1}}],[\"先根据当前策略计算出各个状态的\",{\"1\":{\"77\":1}}],[\"负载因子默认为0\",{\"1\":{\"217\":1}}],[\"负载因子\",{\"1\":{\"215\":1}}],[\"哈希表的大小并不是一直不变的\",{\"1\":{\"215\":1}}],[\"哈希表可能会出现哈希冲突\",{\"1\":{\"215\":1}}],[\"哈希表\",{\"1\":{\"215\":1}}],[\"备胎\",{\"1\":{\"214\":1}}],[\"批量操作\",{\"1\":{\"213\":1}}],[\"体系下的接口\",{\"1\":{\"212\":1}}],[\"映射指两个元素的之间相互\",{\"1\":{\"212\":1}}],[\"映射等数据结构\",{\"1\":{\"178\":1}}],[\"底层c++写的\",{\"1\":{\"370\":1}}],[\"底层是由c++实现的\",{\"1\":{\"350\":1}}],[\"底层是直接用\",{\"1\":{\"224\":1}}],[\"底层直接用\",{\"1\":{\"224\":1}}],[\"底层哈希表的长度永远是2的n次方\",{\"1\":{\"216\":1}}],[\"底层实现\",{\"0\":{\"215\":1,\"224\":1}}],[\"底层采用哈希表实现\",{\"1\":{\"214\":2}}],[\"底层维护的不再是一个\",{\"1\":{\"206\":1}}],[\"底层就是采用数组实现的\",{\"1\":{\"182\":1}}],[\"篇视频教程中学习大顶堆和小顶堆\",{\"1\":{\"203\":1}}],[\"想要了解优先级队列的具体是原理\",{\"1\":{\"203\":1}}],[\"栈相关操作已经帮助我们定义好了\",{\"1\":{\"201\":1}}],[\"队首出队\",{\"1\":{\"201\":1}}],[\"队列中继承下来的方法操作是一样的\",{\"1\":{\"201\":1}}],[\"队列的添加操作\",{\"1\":{\"200\":1}}],[\"队列\",{\"0\":{\"200\":1,\"202\":1},\"1\":{\"178\":1}}],[\"双端队列既可以当做普通队列使用\",{\"1\":{\"201\":1}}],[\"双端队列\",{\"0\":{\"201\":1}}],[\"插入新的元素到当前待遍历元素之前\",{\"1\":{\"194\":1}}],[\"插入元素默认是插入到尾部\",{\"1\":{\"181\":1}}],[\"测试\",{\"1\":{\"193\":1}}],[\"测试阶段\",{\"1\":{\"14\":1}}],[\"得益于泛型的类型擦除机制\",{\"1\":{\"237\":1}}],[\"得益于\",{\"1\":{\"193\":1}}],[\"得到一个字符串数组\",{\"1\":{\"379\":1}}],[\"得到一个克隆的对象\",{\"1\":{\"355\":1}}],[\"得到一个样本序列x1​\",{\"1\":{\"75\":1}}],[\"得到结果\",{\"1\":{\"228\":1}}],[\"得到前面处理的结果\",{\"1\":{\"228\":1}}],[\"得到含有噪音的观测值序列\",{\"1\":{\"97\":1}}],[\"得到的会是同一个对象\",{\"1\":{\"362\":1}}],[\"得到的是包名+类名的完整名称\",{\"1\":{\"341\":1}}],[\"得到的\",{\"1\":{\"84\":1,\"241\":1}}],[\"得到\",{\"1\":{\"68\":1}}],[\"介绍\",{\"0\":{\"193\":1,\"194\":1}}],[\"调用\",{\"1\":{\"393\":1}}],[\"调用clone方法\",{\"1\":{\"355\":1}}],[\"调用consumer的accept来对每一个元素进行消费\",{\"1\":{\"192\":1}}],[\"调用父类的实现\",{\"1\":{\"351\":1}}],[\"调用t的interrupt方法\",{\"1\":{\"301\":1}}],[\"调用此方法时也会获取锁\",{\"1\":{\"312\":1}}],[\"调用此方法后\",{\"1\":{\"301\":1}}],[\"调用此方法来开始执行此线程\",{\"1\":{\"297\":1}}],[\"调用类的静态方法\",{\"1\":{\"275\":1}}],[\"调用时的位置\",{\"1\":{\"265\":1}}],[\"调用resize进行扩容\",{\"1\":{\"216\":1}}],[\"调用的另一个方法进行映射关系存放\",{\"1\":{\"216\":1}}],[\"调整为限制的大小\",{\"1\":{\"182\":1}}],[\"自定义运行时异常\",{\"1\":{\"400\":1}}],[\"自定义编译时异常\",{\"1\":{\"400\":1}}],[\"自定义异常\",{\"0\":{\"400\":1}}],[\"自定义线程名称\",{\"1\":{\"297\":1}}],[\"自动装箱|拆箱机制\",{\"1\":{\"364\":1}}],[\"自动处理字符编码转换\",{\"1\":{\"245\":1}}],[\"自其他接口的\",{\"1\":{\"354\":1}}],[\"自己定义的定时器\",{\"0\":{\"322\":1}}],[\"自己定义的类要序列化保存\",{\"1\":{\"288\":1}}],[\"自身存在一个\",{\"1\":{\"192\":1}}],[\"自我介绍需要用到当前对象的名字和年龄\",{\"1\":{\"162\":1}}],[\"自我介绍只需要完成就行\",{\"1\":{\"162\":1}}],[\"表达式的\",{\"1\":{\"192\":1}}],[\"表示所有小写字母\",{\"1\":{\"381\":1}}],[\"表示abc这几个字符可以出现\",{\"1\":{\"381\":1}}],[\"表示当前数组长度\",{\"1\":{\"371\":1}}],[\"表示long的最大值\",{\"1\":{\"364\":1}}],[\"表示类支持接口代表的功能\",{\"1\":{\"354\":1}}],[\"表示类具有的属性\",{\"1\":{\"161\":1}}],[\"表示这个类具有克隆的功能\",{\"1\":{\"355\":1}}],[\"表示这个类是一个抽象类\",{\"1\":{\"353\":1}}],[\"表示这个类不能再被继承了\",{\"1\":{\"352\":1}}],[\"表示导入这个包中全部的类\",{\"1\":{\"277\":1}}],[\"表示integer这个类型\",{\"1\":{\"237\":1}}],[\"表示是\",{\"1\":{\"135\":1}}],[\"表示是一种长时间的交互行为\",{\"1\":{\"135\":1}}],[\"表示是最佳部署位置\",{\"1\":{\"13\":1}}],[\"表示一个区间\",{\"1\":{\"381\":1}}],[\"表示一个键值对\",{\"1\":{\"213\":1}}],[\"表示一个函数\",{\"1\":{\"110\":1}}],[\"表示一个给定的策略\",{\"1\":{\"45\":1}}],[\"表示对于对应\",{\"1\":{\"84\":1}}],[\"表示对于每一个\",{\"1\":{\"84\":1}}],[\"表示状态转移矩阵\",{\"1\":{\"46\":1}}],[\"表示为\",{\"1\":{\"40\":1,\"152\":3}}],[\"表示为rkn​​\",{\"1\":{\"9\":1}}],[\"表示在单步情况下\",{\"1\":{\"153\":1}}],[\"表示在策略π下\",{\"1\":{\"153\":1}}],[\"表示在一个\",{\"1\":{\"137\":1}}],[\"表示在各状态执行各动作的概率\",{\"1\":{\"20\":1}}],[\"表示在状态s下采取动作a\",{\"1\":{\"20\":2}}],[\"表示\",{\"1\":{\"10\":1,\"135\":1,\"142\":1,\"155\":1}}],[\"表示round\",{\"1\":{\"10\":1}}],[\"表示无人机与用户之间的仰角\",{\"1\":{\"9\":1}}],[\"遍历打印数组中每一个元素\",{\"1\":{\"376\":1}}],[\"遍历方式也不同\",{\"1\":{\"190\":1}}],[\"遍历当前元素\",{\"1\":{\"189\":1}}],[\"向map中添加新的映射关系\",{\"1\":{\"213\":1}}],[\"向后继续寻找结点\",{\"1\":{\"190\":1}}],[\"向集合中添加元素\",{\"1\":{\"180\":1}}],[\"移动指针\",{\"1\":{\"190\":1}}],[\"移除\",{\"1\":{\"241\":1}}],[\"移除其映射关系\",{\"1\":{\"213\":1}}],[\"移除队首元素\",{\"1\":{\"200\":1}}],[\"移除上一个被遍历的元素\",{\"1\":{\"189\":1}}],[\"移除指定位置上的元素\",{\"1\":{\"181\":1}}],[\"移除给定集合中出现的所有元素\",{\"1\":{\"180\":1}}],[\"移除成功返回true\",{\"1\":{\"180\":3}}],[\"实现接口时\",{\"1\":{\"354\":1}}],[\"实现接口\",{\"1\":{\"354\":1}}],[\"实现的\",{\"1\":{\"215\":1}}],[\"实现用例\",{\"0\":{\"190\":1}}],[\"实际上正则表达式内容非常多\",{\"1\":{\"381\":1}}],[\"实际上实现接口更像是一个类的功能列表\",{\"1\":{\"354\":1}}],[\"实际上接口的目标就是将类所具有某些的行为抽象出来\",{\"1\":{\"354\":1}}],[\"实际上锁就是依附于对象存在的\",{\"1\":{\"318\":1}}],[\"实际上synchronized是一种悲观锁\",{\"1\":{\"312\":1}}],[\"实际上类锁也是对象锁\",{\"1\":{\"312\":1}}],[\"实际上只执行了一次\",{\"1\":{\"311\":1}}],[\"实际上只要是实现了迭代器接口的类\",{\"1\":{\"193\":1}}],[\"实际上一个java程序启动后\",{\"1\":{\"295\":1}}],[\"实际上这里面就是方法体\",{\"1\":{\"392\":1}}],[\"实际上这种模式是父类filterinputstream提供的规范\",{\"1\":{\"264\":1}}],[\"实际上这个表就是一个存放头结点的数组+若干结点\",{\"1\":{\"215\":1}}],[\"实际上进行i\",{\"1\":{\"264\":1}}],[\"实际上在我们的开发中\",{\"1\":{\"237\":1}}],[\"实际上在java中并不是真的有泛型类型\",{\"1\":{\"173\":1}}],[\"实际上对应类型的集合类有可能会存放其他类型的值\",{\"1\":{\"237\":1}}],[\"实际上最后只要是object的实现类都可以保存到集合类中\",{\"1\":{\"237\":1}}],[\"实际上\",{\"1\":{\"228\":1,\"299\":1,\"311\":2}}],[\"实际上用的就是我们的\",{\"1\":{\"224\":1}}],[\"实际上底层大致结构跟我们之前学习的差不多\",{\"1\":{\"215\":1}}],[\"实际上就是存放的映射关系\",{\"1\":{\"215\":1}}],[\"实际上就像这样\",{\"1\":{\"172\":1}}],[\"实际上编译之后会修改为\",{\"1\":{\"187\":1}}],[\"实际上我们的集合类都是支持使用foreach语法\",{\"1\":{\"187\":1}}],[\"实际上会直接使用默认的类型\",{\"1\":{\"173\":1}}],[\"实际上泛型方法在很多工具类中也有\",{\"1\":{\"171\":1}}],[\"实际上main就是一个函数\",{\"1\":{\"162\":1}}],[\"实际传入的参数是一个字符串类型的值\",{\"1\":{\"171\":1}}],[\"实际不常用\",{\"1\":{\"68\":1}}],[\"实际意义的解释\",{\"1\":{\"48\":1}}],[\"实际意义是\",{\"1\":{\"48\":1}}],[\"某些集合不支持这种操作\",{\"1\":{\"189\":1}}],[\"看看是否还有下一个元素\",{\"1\":{\"189\":1}}],[\"源码定义\",{\"0\":{\"189\":1}}],[\"增加了更多方便的操作\",{\"1\":{\"194\":1}}],[\"增强\",{\"1\":{\"187\":1}}],[\"增量式的迭代算法\",{\"1\":{\"94\":1}}],[\"各个线程之间共享程序的内存空间\",{\"1\":{\"295\":1}}],[\"各项操作的结果也是一样的\",{\"1\":{\"182\":1}}],[\"各种属性都是默认值\",{\"1\":{\"166\":1}}],[\"内存占用已经超出限制\",{\"1\":{\"399\":1}}],[\"内存也会消耗更多\",{\"1\":{\"362\":1}}],[\"内容\",{\"1\":{\"388\":1}}],[\"内部类静态方法\",{\"1\":{\"389\":2}}],[\"内部类初始化\",{\"1\":{\"389\":2}}],[\"内部类父类的tostring方法\",{\"1\":{\"386\":1}}],[\"内部类自己的tostring方法\",{\"1\":{\"386\":1}}],[\"内部类名称\",{\"1\":{\"386\":1}}],[\"内部类也是类\",{\"1\":{\"386\":1}}],[\"内部类顾名思义\",{\"1\":{\"385\":1}}],[\"内部类\",{\"0\":{\"384\":1,\"385\":1}}],[\"内部什么都没有\",{\"1\":{\"380\":1}}],[\"内部的数据结构\",{\"1\":{\"224\":1}}],[\"内部使用结点\",{\"1\":{\"215\":1}}],[\"内部使用的结点类\",{\"1\":{\"182\":1}}],[\"内嵌迭代算法求解\",{\"1\":{\"70\":1}}],[\"异常错误信息\",{\"1\":{\"402\":1}}],[\"异常处理\",{\"1\":{\"402\":1}}],[\"异常的处理\",{\"0\":{\"402\":1}}],[\"异常的抛出同样需要创建一个异常对象出来\",{\"1\":{\"401\":1}}],[\"异常对象携带了我们抛出异常时的一些信息\",{\"1\":{\"401\":1}}],[\"异常其实就两大类\",{\"1\":{\"400\":1}}],[\"异常就是不同寻常\",{\"1\":{\"399\":1}}],[\"异常类型\",{\"0\":{\"399\":1}}],[\"异常机制\",{\"0\":{\"398\":1}}],[\"异常\",{\"0\":{\"396\":1},\"1\":{\"182\":1}}],[\"哟唉嘛干你\",{\"1\":{\"182\":2}}],[\"结果是\",{\"1\":{\"389\":1}}],[\"结果依然是删除成功\",{\"1\":{\"182\":1}}],[\"结束\",{\"1\":{\"324\":1}}],[\"结合去寻找最优策略\",{\"1\":{\"111\":1}}],[\"那作用范围也就只能在方法中了\",{\"1\":{\"388\":1}}],[\"那肯定不相等\",{\"1\":{\"351\":1}}],[\"那肯定是没有的\",{\"1\":{\"214\":1}}],[\"那必须的\",{\"1\":{\"232\":1}}],[\"那就是参数了\",{\"1\":{\"386\":1}}],[\"那就执行覆盖操作\",{\"1\":{\"216\":1}}],[\"那就直接放一个新的结点\",{\"1\":{\"216\":1}}],[\"那要是我们就是想要使用维持顺序的set集合呢\",{\"1\":{\"206\":1}}],[\"那要是此时我们删除对象呢\",{\"1\":{\"182\":1}}],[\"那要是这样写呢\",{\"1\":{\"182\":1}}],[\"那么在使用时\",{\"1\":{\"416\":1}}],[\"那么由于类型不确定\",{\"1\":{\"416\":1}}],[\"那么泛型就变成对应的类型了\",{\"1\":{\"416\":1}}],[\"那么泛型到底是如何实现的呢\",{\"1\":{\"173\":1}}],[\"那么现在该如何去设计这样的一个\",{\"1\":{\"415\":1}}],[\"那么当发生这个异常时\",{\"1\":{\"402\":1}}],[\"那么所有在方法中可能会抛出的异常都需要注明\",{\"1\":{\"401\":1}}],[\"那么必须告知函数的调用方我们会抛出某个异常\",{\"1\":{\"401\":1}}],[\"那么使用时候\",{\"1\":{\"393\":1}}],[\"那么需要在前面添加外部类型名称\",{\"1\":{\"386\":1}}],[\"那么需要在前面添加外部类型名称test\",{\"1\":{\"386\":1}}],[\"那么需要重新生成一个迭代器对象\",{\"1\":{\"191\":1}}],[\"那么如果内部类中也定义了同名的变量\",{\"1\":{\"386\":1}}],[\"那么中间就需要产生4个字符串对象出来\",{\"1\":{\"380\":1}}],[\"那么始终都是同一个对象\",{\"1\":{\"379\":1}}],[\"那么始终都会得到同一个对象\",{\"1\":{\"362\":1}}],[\"那么可以不用明确\",{\"1\":{\"417\":1}}],[\"那么可以直接明确对应类型\",{\"1\":{\"417\":1}}],[\"那么可以使用\",{\"1\":{\"416\":1}}],[\"那么可以使用this关键字\",{\"1\":{\"164\":1}}],[\"那么可以省去小括号\",{\"1\":{\"392\":1}}],[\"那么可变长参数只能放在最后\",{\"1\":{\"376\":1}}],[\"那么自动装箱的呢\",{\"1\":{\"362\":1}}],[\"那么是不相等的\",{\"1\":{\"362\":1}}],[\"那么实现类中不强制要求进行实现\",{\"1\":{\"354\":1}}],[\"那么实际上只是传递了对象的引用\",{\"1\":{\"161\":1}}],[\"那么还有什么意义呢\",{\"1\":{\"353\":1}}],[\"那么还需要将旧的数组中所有元素全部搬到新的里面去\",{\"1\":{\"217\":1}}],[\"那么无法重写\",{\"1\":{\"351\":1}}],[\"那么同样可以使用\",{\"1\":{\"351\":1}}],[\"那么有可能两个线程同一时间都执行同一个方法\",{\"1\":{\"330\":1}}],[\"那么有没有下界呢\",{\"1\":{\"172\":1}}],[\"那么线程将一直处于挂起状态\",{\"1\":{\"313\":1}}],[\"那么我们能否创建数组类型的数组呢\",{\"1\":{\"375\":1}}],[\"那么我们也可以给枚举类型添加独有的成员方法\",{\"1\":{\"356\":1}}],[\"那么我们就可以将学习这个能力\",{\"1\":{\"354\":1}}],[\"那么我们就可以将其重写了\",{\"1\":{\"351\":1}}],[\"那么我们如何去检测死锁呢\",{\"1\":{\"313\":1}}],[\"那么我们可以继续踢皮球\",{\"1\":{\"402\":1}}],[\"那么我们可以将匿名内部类简写为lambda表达式\",{\"1\":{\"392\":1}}],[\"那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用\",{\"1\":{\"278\":1}}],[\"那么我们可以使用emptyxxx来快速生成一个只读的空集合\",{\"1\":{\"236\":1}}],[\"那么我们可以对\",{\"1\":{\"78\":1}}],[\"那么此时就出现了歧义\",{\"1\":{\"277\":1}}],[\"那么此时的\",{\"1\":{\"135\":1}}],[\"那么这些类如果都放在一起的话\",{\"1\":{\"277\":1}}],[\"那么这称为\",{\"1\":{\"84\":1}}],[\"那么其他的对象读取的就是被改变的值\",{\"1\":{\"274\":1}}],[\"那么通过这个类创建的所有对象\",{\"1\":{\"274\":1}}],[\"那么它们的\",{\"1\":{\"241\":1}}],[\"那么fill操作不会生效\",{\"1\":{\"235\":1}}],[\"那么直接给到\",{\"1\":{\"217\":1}}],[\"那么直接扩容到最小的大小\",{\"1\":{\"182\":1}}],[\"那么就不能修改了\",{\"1\":{\"416\":1}}],[\"那么就相当于到顶层了\",{\"1\":{\"402\":1}}],[\"那么就是b的\",{\"1\":{\"386\":1}}],[\"那么就是a的\",{\"1\":{\"386\":1}}],[\"那么就是不同的对象了\",{\"1\":{\"379\":1}}],[\"那么就像我们把成员变量访问权限变成私有一样\",{\"1\":{\"386\":1}}],[\"那么就需要创造一个对象\",{\"1\":{\"386\":1}}],[\"那么就会出现这种情况\",{\"1\":{\"237\":1}}],[\"那么就可以像这样\",{\"1\":{\"222\":1}}],[\"那么就可以直接使用迭代器来完成\",{\"1\":{\"190\":1}}],[\"那么就进行扩容\",{\"1\":{\"217\":1}}],[\"那么就开始扩容\",{\"1\":{\"217\":1}}],[\"那么就转换为红黑树来存放\",{\"1\":{\"216\":1}}],[\"那么键就是integer类型的\",{\"1\":{\"213\":1}}],[\"那么会直接返回已经提前创建好的对象\",{\"1\":{\"362\":1}}],[\"那么会直接抛出类型转换异常\",{\"1\":{\"237\":1}}],[\"那么会覆盖掉之前的\",{\"1\":{\"214\":1}}],[\"那么会失败\",{\"1\":{\"204\":1}}],[\"那么会抛出异常\",{\"1\":{\"200\":2}}],[\"那么会从默认类型变成上界定义的类型\",{\"1\":{\"173\":1}}],[\"那么集合中就是相同的两个对象\",{\"1\":{\"182\":1}}],[\"那么忽略这个元素\",{\"1\":{\"180\":1}}],[\"那么编译之后\",{\"1\":{\"173\":1}}],[\"那么限定了上界后\",{\"1\":{\"172\":1}}],[\"那么既然泛型有上界\",{\"1\":{\"172\":1}}],[\"那么肯定应该排在前面\",{\"1\":{\"171\":1}}],[\"那么t就会自动变成\",{\"1\":{\"171\":1}}],[\"那么能否实现在对象创建时就为其指定名字\",{\"1\":{\"166\":1}}],[\"那么默认会认为这个变量是一个\",{\"1\":{\"416\":1}}],[\"那么默认情况下可以不使用this关键字来明确表示当前对象\",{\"1\":{\"164\":1}}],[\"那么默认是null\",{\"1\":{\"161\":1}}],[\"那么默认是统一为0\",{\"1\":{\"161\":1}}],[\"那么创建对象之后能否直接访问呢\",{\"1\":{\"161\":1}}],[\"那么对应返回的就是确定的类型\",{\"1\":{\"343\":1}}],[\"那么对应的损失函数求解为\",{\"1\":{\"142\":1}}],[\"那么对象构造好之后\",{\"1\":{\"166\":1}}],[\"那么对象的属性都会存在初始值\",{\"1\":{\"161\":1}}],[\"那么对于随机变量x的估计可以为\",{\"1\":{\"75\":1}}],[\"那么只要求解\",{\"1\":{\"99\":1}}],[\"那么\",{\"1\":{\"68\":1,\"94\":1,\"98\":1}}],[\"删除2到4这个范围内的字符\",{\"1\":{\"380\":1}}],[\"删除就完事\",{\"1\":{\"182\":1}}],[\"删除的是另一个对象\",{\"1\":{\"182\":1}}],[\"删除的是下标为10的元素\",{\"1\":{\"182\":1}}],[\"删除所有元素\",{\"1\":{\"180\":1}}],[\"科技与狠活\",{\"1\":{\"182\":1}}],[\"扩容规则跟我们之前的是一样的\",{\"1\":{\"182\":1}}],[\"扩展了collection接口中一些额外的操作\",{\"1\":{\"181\":1}}],[\"扩展了大量列表支持的操作\",{\"1\":{\"181\":1}}],[\"度\",{\"1\":{\"182\":1}}],[\"创建random对象\",{\"1\":{\"409\":1}}],[\"创建出来的数组每个位置上都有默认值\",{\"1\":{\"370\":1}}],[\"创建对象越多\",{\"1\":{\"362\":1}}],[\"创建枚举需要添加参数\",{\"1\":{\"356\":1}}],[\"创建定时器对象\",{\"1\":{\"323\":1}}],[\"创建并启动此定时任务\",{\"1\":{\"322\":2}}],[\"创建好后\",{\"1\":{\"297\":1}}],[\"创建类的实例\",{\"1\":{\"275\":1}}],[\"创建当前列表\",{\"1\":{\"182\":1}}],[\"创建一个变量指代我们刚刚创建好的对象\",{\"1\":{\"161\":1}}],[\"记录当前数组元素数的\",{\"1\":{\"182\":1}}],[\"记录在\",{\"1\":{\"81\":1}}],[\"存放在元空间中\",{\"1\":{\"337\":1}}],[\"存放数据的底层数组\",{\"1\":{\"182\":1}}],[\"存储类型为我们要存放的变量类型\",{\"1\":{\"319\":1}}],[\"存储在主内存\",{\"1\":{\"311\":1}}],[\"存储本地读取字节数\",{\"1\":{\"251\":1}}],[\"存在时存在则计算并赋予新的值\",{\"1\":{\"221\":1}}],[\"存在不动点x∗\",{\"1\":{\"58\":1}}],[\"存在\",{\"1\":{\"53\":1}}],[\"存在lemma1\",{\"1\":{\"9\":1}}],[\"接着我们对三个属性挨个进行比较\",{\"1\":{\"351\":1}}],[\"接下来\",{\"1\":{\"228\":1}}],[\"接口内部必须有且仅有一个抽象方法\",{\"1\":{\"392\":1}}],[\"接口也可以通过这种匿名内部类的形式\",{\"1\":{\"390\":1}}],[\"接口同样支持向下转型\",{\"1\":{\"354\":1}}],[\"接口跟抽象类一样\",{\"1\":{\"354\":1}}],[\"接口定义\",{\"1\":{\"354\":1}}],[\"接口支持多继承\",{\"1\":{\"354\":1}}],[\"接口是可以继承\",{\"1\":{\"354\":1}}],[\"接口不同于类\",{\"1\":{\"354\":1}}],[\"接口的默认方法是保底的\",{\"1\":{\"354\":1}}],[\"接口的继承相当于是对接口功能的融合罢了\",{\"1\":{\"354\":1}}],[\"接口的使用和继承的概念有一定的出入\",{\"1\":{\"354\":1}}],[\"接口的类\",{\"1\":{\"234\":1}}],[\"接口可以实现很多个\",{\"1\":{\"354\":1}}],[\"接口里只能定义对应的抽象方法\",{\"1\":{\"354\":1}}],[\"接口包含了一些列方法的定义\",{\"1\":{\"354\":1}}],[\"接口一般只代表某些功能的抽象\",{\"1\":{\"354\":1}}],[\"接口甚至比抽象类还抽象\",{\"1\":{\"354\":1}}],[\"接口中可以存在让抽象方法的默认实现\",{\"1\":{\"354\":1}}],[\"接口中只能定义访问权限为public抽象方法\",{\"1\":{\"354\":1}}],[\"接口中如果定义了与\",{\"1\":{\"354\":1}}],[\"接口中不允许存在成员变量和成员方法\",{\"1\":{\"354\":1}}],[\"接口中的方法可以存在默认实现\",{\"1\":{\"354\":1}}],[\"接口中并没有定义支持指定下标位置访问的添加和删除操作\",{\"1\":{\"205\":1}}],[\"接口中定义的静态方法也只能是public的\",{\"1\":{\"354\":1}}],[\"接口中定义的静态变量只能是public\",{\"1\":{\"354\":1}}],[\"接口中定义的操作\",{\"1\":{\"213\":1}}],[\"接口中定义的\",{\"1\":{\"192\":1}}],[\"接口中定义的方法都是\",{\"1\":{\"204\":1}}],[\"接口中定义的方法\",{\"1\":{\"181\":1}}],[\"接口\",{\"0\":{\"354\":1},\"1\":{\"181\":1,\"354\":1,\"390\":1}}],[\"接收端\",{\"1\":{\"10\":1}}],[\"按行读取\",{\"1\":{\"269\":1}}],[\"按照从大到小顺序出队\",{\"1\":{\"203\":1}}],[\"按照所给定策略j来执行一个动作at​∈a从而获得奖励rt​以及下一个状态st+1​\",{\"1\":{\"13\":1}}],[\"按顺序从前往后存放\",{\"1\":{\"181\":1}}],[\"功能还会更多一些\",{\"1\":{\"181\":1}}],[\"列表中允许存在相同元素\",{\"1\":{\"182\":1}}],[\"列表中允许存在重复元素\",{\"1\":{\"181\":1}}],[\"列表\",{\"0\":{\"181\":1},\"1\":{\"181\":1,\"241\":1}}],[\"添加点内容的话\",{\"1\":{\"377\":1}}],[\"添加元素只有在当前set集合中不存在此元素时才会成功\",{\"1\":{\"204\":1}}],[\"添加的是一个对象\",{\"1\":{\"182\":1}}],[\"添加integer的值10\",{\"1\":{\"182\":1}}],[\"添加成功返回true\",{\"1\":{\"180\":1}}],[\"添加给定集合中所有的元素\",{\"1\":{\"180\":1}}],[\"查找位置\",{\"0\":{\"237\":1}}],[\"查看map中是否包含指定的值\",{\"1\":{\"213\":1}}],[\"查看map中是否包含指定的键\",{\"1\":{\"213\":1}}],[\"查看前面是否有已经遍历的元素\",{\"1\":{\"194\":1}}],[\"查看当前集合是否为空\",{\"1\":{\"180\":1}}],[\"查询相关操作\",{\"1\":{\"213\":1}}],[\"查询某个元素在当前列表中的最后一次出现的下标位置\",{\"1\":{\"181\":1}}],[\"查询某个元素在当前列表中的第一次出现的下标位置\",{\"1\":{\"181\":1}}],[\"查询当前集合是否包含给定集合中所有的元素\",{\"1\":{\"180\":1}}],[\"查询当前集合中是否包含某个元素\",{\"1\":{\"180\":1}}],[\"获得并行流\",{\"1\":{\"330\":1}}],[\"获得cpu资源的概率会越大\",{\"1\":{\"302\":1}}],[\"获得reward\",{\"1\":{\"20\":1}}],[\"获取成绩需要进行强制类型转换\",{\"1\":{\"415\":1}}],[\"获取异常的错误信息\",{\"1\":{\"402\":1}}],[\"获取长度\",{\"1\":{\"379\":1}}],[\"获取封装的成员变量\",{\"1\":{\"356\":1}}],[\"获取对象的哈希值\",{\"1\":{\"350\":1}}],[\"获取对应下标位置上的元素\",{\"1\":{\"181\":1}}],[\"获取父类的原始类型的type\",{\"1\":{\"343\":1}}],[\"获取它的类加载器\",{\"1\":{\"341\":1}}],[\"获取类名称\",{\"1\":{\"341\":1}}],[\"获取相应类的class对象\",{\"0\":{\"339\":1}}],[\"获取到类的一些属性\",{\"1\":{\"336\":1}}],[\"获取到的是不同的锁\",{\"1\":{\"312\":1}}],[\"获取线程名称\",{\"1\":{\"297\":1}}],[\"获取文件的绝对路径\",{\"1\":{\"255\":1}}],[\"获取文件的大小\",{\"1\":{\"255\":1}}],[\"获取平均值\",{\"1\":{\"228\":1}}],[\"获取数量\",{\"1\":{\"228\":1}}],[\"获取语法统计实例\",{\"1\":{\"228\":1}}],[\"获取键值对的值\",{\"1\":{\"213\":1}}],[\"获取键值对的键\",{\"1\":{\"213\":1}}],[\"获取当前的类型class对象\",{\"1\":{\"350\":1}}],[\"获取当前线程对象\",{\"1\":{\"297\":1,\"299\":1}}],[\"获取当前存储的键值对数量\",{\"1\":{\"213\":1}}],[\"获取当前集合中的元素数量\",{\"1\":{\"180\":1}}],[\"获取队尾元素\",{\"1\":{\"201\":1}}],[\"获取队首元素\",{\"1\":{\"201\":1}}],[\"树脂666\",{\"1\":{\"180\":1}}],[\"相等于\",{\"1\":{\"381\":1}}],[\"相当于\",{\"1\":{\"354\":1}}],[\"相当于没有头结点的链表\",{\"1\":{\"215\":1}}],[\"相比reader更方便的是\",{\"1\":{\"269\":1}}],[\"相比之前的collection接口定义\",{\"1\":{\"181\":1}}],[\"相同之处\",{\"1\":{\"179\":1}}],[\"相应的算法是\",{\"1\":{\"112\":1}}],[\"相应的\",{\"1\":{\"104\":1,\"110\":1}}],[\"管理和操作我们的数据而存在的\",{\"1\":{\"178\":1}}],[\"集合操作能不能也安排点高级的玩法呢\",{\"1\":{\"232\":1}}],[\"集合运算和表达的高阶抽象\",{\"1\":{\"228\":1}}],[\"集合只是粗略的进行了讲解\",{\"1\":{\"207\":1}}],[\"集合中基本都是从\",{\"1\":{\"204\":1}}],[\"集合中的每一个元素就是一个集合\",{\"1\":{\"182\":1}}],[\"集合的具体类型\",{\"1\":{\"234\":1}}],[\"集合的各种功能我们都可以来测试一下\",{\"1\":{\"182\":1}}],[\"集合的\",{\"1\":{\"181\":1}}],[\"集合的大小是可变的\",{\"1\":{\"179\":1}}],[\"集合根接口\",{\"0\":{\"180\":1}}],[\"集合跟数组一样\",{\"1\":{\"179\":1}}],[\"集合\",{\"0\":{\"204\":1},\"1\":{\"178\":1}}],[\"集合表示一组对象\",{\"1\":{\"178\":1}}],[\"集合其实与我们数学中的集合是差不多的概念\",{\"1\":{\"178\":1}}],[\"集合类中有一个东西是java8新增的spliterator接口\",{\"1\":{\"330\":1}}],[\"集合类中并不是通过\",{\"1\":{\"241\":1}}],[\"集合类中继承的方法这里也不多种介绍了\",{\"1\":{\"201\":1}}],[\"集合类对象相等判定\",{\"0\":{\"240\":1,\"241\":1}}],[\"集合类同样支持这种语法\",{\"1\":{\"187\":1}}],[\"集合类是支持嵌套使用的\",{\"1\":{\"182\":1}}],[\"集合类是java中非常重要的存在\",{\"1\":{\"178\":1}}],[\"集合类基本都是在java\",{\"1\":{\"180\":1}}],[\"集合类与数组区别\",{\"0\":{\"179\":1}}],[\"集合类其实就是为了更好地组织\",{\"1\":{\"178\":1}}],[\"集合类\",{\"0\":{\"176\":1,\"177\":1,\"178\":1,\"185\":1,\"186\":1,\"192\":1,\"197\":1,\"198\":1,\"210\":1,\"211\":1,\"330\":1},\"1\":{\"192\":1,\"330\":1}}],[\"使得java能够更好的体现面向对象的思想\",{\"1\":{\"361\":1}}],[\"使得持有当前对象锁的线程进入等待状态\",{\"1\":{\"350\":1}}],[\"使得线程处于等待状态一段时间\",{\"1\":{\"300\":1}}],[\"使得某些属性不参与序列化\",{\"1\":{\"290\":1}}],[\"使得v^\",{\"1\":{\"132\":1}}],[\"使用钻石运算符可以省略其中的类型\",{\"1\":{\"416\":1}}],[\"使用object类型作为引用\",{\"1\":{\"415\":1}}],[\"使用泛型的原因\",{\"0\":{\"415\":1}}],[\"使用运行时异常同样可以捕获到\",{\"1\":{\"402\":1}}],[\"使用throws关键字告知调用方此方法会抛出哪些异常\",{\"1\":{\"401\":1}}],[\"使用throw关键字来抛出异常\",{\"1\":{\"401\":1}}],[\"使用new表示\",{\"1\":{\"393\":1}}],[\"使用newline进行换行\",{\"1\":{\"270\":1}}],[\"使用双冒号来进行方法引用\",{\"1\":{\"393\":1}}],[\"使用外部静态变量\",{\"1\":{\"389\":1}}],[\"使用频率很低\",{\"1\":{\"388\":1}}],[\"使用频率极高\",{\"1\":{\"178\":1}}],[\"使用split方法进行字符串分割\",{\"1\":{\"379\":1}}],[\"使用synchronized关键字创建同步代码块\",{\"1\":{\"312\":1}}],[\"使用就像对象的参数一样\",{\"1\":{\"356\":1}}],[\"使用枚举类也非常方便\",{\"1\":{\"356\":1}}],[\"使用default关键字为接口中的方法添加默认实现\",{\"1\":{\"354\":1}}],[\"使用datainputstream可以读取\",{\"1\":{\"286\":1}}],[\"使用implements关键字来实现接口\",{\"1\":{\"354\":1}}],[\"使用import关键字导入其他包中的类\",{\"1\":{\"277\":1}}],[\"使用interface表示这是一个接口\",{\"1\":{\"354\":1}}],[\"使用class类静态方法forname\",{\"1\":{\"339\":1}}],[\"使用class关键字\",{\"1\":{\"339\":1}}],[\"使用copyof快速将内容拷贝到扩容后的新数组中并设定为新的elementdata底层数组\",{\"1\":{\"182\":1}}],[\"使用多线程进行并行排序\",{\"1\":{\"330\":1}}],[\"使用jconsole也可以进行监测\",{\"1\":{\"313\":1}}],[\"使用\",{\"1\":{\"312\":1,\"402\":1}}],[\"使用的是系统提供的输入流\",{\"1\":{\"285\":1}}],[\"使用长度为10的byte\",{\"1\":{\"251\":1}}],[\"使用方法同输入流一样\",{\"1\":{\"249\":1}}],[\"使用available方法能查看当前可读的剩余字节数量\",{\"1\":{\"248\":1}}],[\"使用add添加元素\",{\"1\":{\"182\":1}}],[\"使用read可以直接读取一个字节的数据\",{\"1\":{\"248\":1}}],[\"使用reduce方法\",{\"1\":{\"228\":1}}],[\"使用原始类型接收一个integer类型的arraylist\",{\"1\":{\"237\":1}}],[\"使用equals判断\",{\"1\":{\"228\":1}}],[\"使用一种类似用\",{\"1\":{\"228\":1}}],[\"使用get方法根据键获取对应的值\",{\"1\":{\"214\":1}}],[\"使用put方法添加键值对\",{\"1\":{\"214\":1}}],[\"使用即可\",{\"1\":{\"207\":1}}],[\"使用示例\",{\"0\":{\"191\":1}}],[\"使用匿名内部类\",{\"1\":{\"182\":1}}],[\"使用接口的引用来操作具体的集合类实现\",{\"1\":{\"182\":1}}],[\"使用时\",{\"1\":{\"172\":1}}],[\"现在的问题就是\",{\"1\":{\"415\":1}}],[\"现在我们希望能够自己处理出现的问题\",{\"1\":{\"402\":1}}],[\"现在线程才是程序执行流的最小单元\",{\"1\":{\"295\":1}}],[\"现在是按字符进行读取\",{\"1\":{\"253\":1}}],[\"现在跳过的是一个字符\",{\"1\":{\"253\":1}}],[\"现在只会进行追加写入\",{\"1\":{\"250\":1}}],[\"现在没有\",{\"1\":{\"172\":1}}],[\"现在有一个新的需求\",{\"1\":{\"172\":1}}],[\"上\",{\"1\":{\"352\":1}}],[\"上下文切换速度也高于进程\",{\"1\":{\"295\":1}}],[\"上头啊\",{\"1\":{\"182\":1}}],[\"上界number\",{\"1\":{\"173\":1}}],[\"上界\",{\"1\":{\"172\":1}}],[\"上行\",{\"1\":{\"13\":1}}],[\"返回的仍然是\",{\"1\":{\"343\":1}}],[\"返回的类型就是什么\",{\"1\":{\"171\":1}}],[\"返回备选方案\",{\"1\":{\"214\":1}}],[\"返回值一样\",{\"1\":{\"393\":1}}],[\"返回值是当前是否有中断标记\",{\"1\":{\"301\":1}}],[\"返回值是读取的字节数\",{\"1\":{\"248\":1}}],[\"返回值\",{\"1\":{\"217\":1}}],[\"返回值我们会在后面讨论\",{\"1\":{\"214\":1}}],[\"返回值类型\",{\"1\":{\"162\":1}}],[\"返回当前键值对的哈希值\",{\"1\":{\"213\":1}}],[\"返回当前集合在指定范围内的子集\",{\"1\":{\"181\":1}}],[\"返回当前集合的迭代器\",{\"1\":{\"180\":1}}],[\"返回所有的键值对\",{\"1\":{\"213\":1}}],[\"返回map中存放的所有值\",{\"1\":{\"213\":1}}],[\"返回map中存放的所有键\",{\"1\":{\"213\":1}}],[\"返回其映射的值\",{\"1\":{\"213\":1}}],[\"返回上一个已遍历元素的下标\",{\"1\":{\"194\":1}}],[\"返回下一个待遍历元素的下标\",{\"1\":{\"194\":1}}],[\"返回结点内部存放的元素\",{\"1\":{\"190\":1}}],[\"效率更高\",{\"1\":{\"330\":1}}],[\"效率过低\",{\"1\":{\"76\":1}}],[\"效果是完全一样的\",{\"1\":{\"191\":1}}],[\"效果跟上面是一样的\",{\"1\":{\"171\":1}}],[\"瞬间变一行\",{\"1\":{\"171\":1}}],[\">=\",{\"1\":{\"216\":1,\"217\":2,\"228\":1,\"362\":1}}],[\">>>\",{\"1\":{\"223\":1}}],[\">>\",{\"1\":{\"182\":1}}],[\">\",{\"1\":{\"171\":1,\"180\":3,\"182\":2,\"203\":1,\"204\":3,\"207\":1,\"216\":1,\"217\":2,\"221\":3,\"222\":2,\"228\":9,\"297\":2,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"313\":2,\"318\":3,\"319\":2,\"320\":2,\"322\":4,\"329\":3,\"330\":2,\"339\":3,\"340\":1,\"341\":1,\"343\":4,\"350\":1,\"362\":8,\"392\":7,\"393\":2,\"403\":1,\"416\":1}}],[\"像这种只有一个方法需要实现的接口\",{\"1\":{\"171\":1}}],[\"大大提升开发效\",{\"1\":{\"415\":1}}],[\"大体内容其实普通类差不多\",{\"1\":{\"353\":1}}],[\"大于0表示大于\",{\"1\":{\"171\":1}}],[\"大数定理\",{\"1\":{\"75\":1}}],[\"两个方法同时在运行或者是两个计算同时在进行\",{\"1\":{\"295\":1}}],[\"两个对象只有\",{\"1\":{\"241\":1}}],[\"两个需要比较的数会在这里给出\",{\"1\":{\"171\":1}}],[\"两个算法迭代过程十分类似\",{\"1\":{\"70\":1}}],[\"别人来调用我们的实现\",{\"1\":{\"171\":1}}],[\"8之前存放在永久代\",{\"1\":{\"337\":1}}],[\"8已经为集合框架中包含的所有数据结构提供了一个默认的spliterator实现\",{\"1\":{\"330\":1}}],[\"89\",{\"1\":{\"222\":1}}],[\"88\",{\"1\":{\"222\":1}}],[\"80\",{\"1\":{\"222\":1}}],[\"8新增方法\",{\"1\":{\"181\":1}}],[\"8\",{\"1\":{\"171\":3,\"182\":2,\"228\":1,\"234\":2,\"245\":1,\"374\":1,\"410\":1}}],[\"92\",{\"1\":{\"222\":1,\"415\":1}}],[\"95\",{\"1\":{\"222\":1}}],[\"98\",{\"1\":{\"222\":1}}],[\"9\",{\"1\":{\"171\":3,\"234\":1,\"330\":2,\"381\":1,\"409\":1,\"410\":1}}],[\"7新增了try\",{\"1\":{\"247\":1}}],[\"72\",{\"1\":{\"222\":1}}],[\"75的hashmap\",{\"1\":{\"224\":1}}],[\"75\",{\"1\":{\"215\":1,\"217\":2,\"415\":1}}],[\"7\",{\"1\":{\"171\":3,\"374\":1,\"410\":1}}],[\"666\",{\"1\":{\"363\":1}}],[\"60\",{\"1\":{\"172\":1,\"415\":1}}],[\"6\",{\"0\":{\"407\":1},\"1\":{\"171\":3,\"235\":1,\"330\":2,\"375\":1,\"410\":1}}],[\"6746\",{\"1\":{\"10\":1}}],[\"比如是因为什么原因导致的异常\",{\"1\":{\"401\":1}}],[\"比如object类中定义的clone方法\",{\"1\":{\"399\":1}}],[\"比如数组越界异常\",{\"1\":{\"399\":1}}],[\"比如这里就是通过空格分隔\",{\"1\":{\"379\":1}}],[\"比如字符串的裁剪\",{\"1\":{\"379\":1}}],[\"比如之前悬念中的value变量\",{\"1\":{\"311\":1}}],[\"比如scanner获取输入的文本\",{\"1\":{\"299\":1}}],[\"比如system\",{\"1\":{\"284\":1}}],[\"比如要共享某些数据\",{\"1\":{\"295\":1}}],[\"比如com\",{\"1\":{\"277\":1}}],[\"比如键盘发送的信号\",{\"1\":{\"265\":1}}],[\"比如筛选\",{\"1\":{\"228\":1}}],[\"比如上面的学生信息\",{\"1\":{\"213\":1}}],[\"比如上我们定义的是类型\",{\"1\":{\"171\":1}}],[\"比如\",{\"1\":{\"180\":1,\"399\":1}}],[\"比如我们想要打印数组\",{\"1\":{\"410\":1}}],[\"比如我们想计算某个学生的所有科目分数之后\",{\"1\":{\"222\":1}}],[\"比如我们现在不希望使用object类中提供的equals方法\",{\"1\":{\"351\":1}}],[\"比如我们可以判断变量的值\",{\"1\":{\"403\":1}}],[\"比如我们可以来看看下面这个问题\",{\"1\":{\"311\":1}}],[\"比如我们可以直接当做栈来进行使用\",{\"1\":{\"201\":1}}],[\"比如我们运行qq\",{\"1\":{\"295\":1}}],[\"比如我们经常访问的\",{\"1\":{\"277\":1}}],[\"比如我们之前学习的顺序表\",{\"1\":{\"180\":1}}],[\"比如我们要估计某个随机变量x的\",{\"1\":{\"99\":1}}],[\"比如一些集合允许重复的元素\",{\"1\":{\"178\":1}}],[\"比如现在我们想要让数据从大到小排列\",{\"1\":{\"171\":1}}],[\"比如说\",{\"1\":{\"171\":1,\"354\":1}}],[\"<p>\",{\"1\":{\"296\":1}}],[\"<code>run<\",{\"1\":{\"296\":2}}],[\"<code>runnable<\",{\"1\":{\"296\":1}}],[\"<=\",{\"1\":{\"228\":1,\"362\":1,\"381\":1}}],[\"<<\",{\"1\":{\"217\":2}}],[\"<\",{\"1\":{\"182\":2,\"217\":1,\"228\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"318\":1,\"329\":2,\"343\":3,\"372\":1,\"409\":1}}],[\"<t\",{\"1\":{\"173\":1}}],[\"<t>\",{\"1\":{\"171\":2,\"173\":1,\"180\":1,\"204\":1,\"343\":1}}],[\"<∞\",{\"1\":{\"98\":1}}],[\"泛型和多态\",{\"0\":{\"417\":1}}],[\"泛型只能确定为一个引用类型\",{\"1\":{\"416\":1}}],[\"泛型变量不止可以只有一个\",{\"1\":{\"416\":1}}],[\"泛型将数据类型的确定控制在了编译阶段\",{\"1\":{\"416\":1}}],[\"泛型在定义时并不明确是什么类型\",{\"1\":{\"416\":1}}],[\"泛型其实就一个待定类型\",{\"1\":{\"416\":1}}],[\"泛型其实仅仅是在编译阶段进行类型检查\",{\"1\":{\"173\":1}}],[\"泛型类需要使用<>\",{\"1\":{\"416\":1}}],[\"泛型类\",{\"0\":{\"416\":1}}],[\"泛型的参数获取\",{\"1\":{\"343\":1}}],[\"泛型的类型检查只存在于编译阶段\",{\"1\":{\"237\":1}}],[\"泛型通配符也支持泛型的界限\",{\"1\":{\"172\":1}}],[\"泛型界限\",{\"0\":{\"172\":1}}],[\"泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计\",{\"1\":{\"171\":1}}],[\"泛型方法会在使用时自动确定泛型类型\",{\"1\":{\"171\":1}}],[\"泛型方法\",{\"0\":{\"171\":1}}],[\"泛型\",{\"0\":{\"169\":1,\"170\":1,\"413\":1,\"414\":1}}],[\"成绩可能是string类型\",{\"1\":{\"415\":1}}],[\"成员变量一样\",{\"1\":{\"386\":1}}],[\"成员变量的初始化\",{\"1\":{\"166\":1}}],[\"成员内部类的name\",{\"1\":{\"386\":2}}],[\"成员内部类的类型名称就是\",{\"1\":{\"386\":1}}],[\"成员内部类可以访问到外部的成员变量\",{\"1\":{\"386\":1}}],[\"成员内部类也可以使用访问权限控制\",{\"1\":{\"386\":1}}],[\"成员内部类和成员方法\",{\"1\":{\"386\":1}}],[\"成员内部类其实在某些情况下使用起来比较麻烦\",{\"1\":{\"386\":1}}],[\"成员内部类\",{\"0\":{\"386\":1}}],[\"成员\",{\"1\":{\"384\":1}}],[\"成员方法因为需要具体对象使用\",{\"1\":{\"393\":1}}],[\"成员方法只能通过\",{\"1\":{\"393\":1}}],[\"成员方法中不能用\",{\"1\":{\"351\":1}}],[\"成员方法\",{\"1\":{\"278\":1}}],[\"成比例等于\",{\"1\":{\"155\":1}}],[\"必须留一个抽象方法出来\",{\"1\":{\"392\":1}}],[\"必须要进行异常的捕获\",{\"1\":{\"402\":1}}],[\"必须要考虑到出现异常的情况\",{\"1\":{\"399\":1}}],[\"必须要实现抽象类中所有抽象方法\",{\"1\":{\"353\":1}}],[\"必须要有\",{\"1\":{\"318\":1}}],[\"必须使用equals方法\",{\"1\":{\"351\":1}}],[\"必须在开始之前\",{\"1\":{\"329\":2}}],[\"必须实现serializable接口才能被序列化\",{\"1\":{\"288\":1}}],[\"必须关闭这个流来完成对资源的释放\",{\"1\":{\"247\":1}}],[\"必须是在持有锁\",{\"1\":{\"318\":1}}],[\"必须是一个对象或是一个类\",{\"1\":{\"312\":1}}],[\"必须是实现\",{\"1\":{\"234\":1}}],[\"必须是number或是number的子类\",{\"1\":{\"172\":1}}],[\"必须是递增的\",{\"1\":{\"98\":1}}],[\"必须调用我们自己定义的构造方法\",{\"1\":{\"166\":1}}],[\"除非抛出的异常是一个运行时异常\",{\"1\":{\"402\":1}}],[\"除非我们手动重载一个无参构造\",{\"1\":{\"166\":1}}],[\"除了clone\",{\"1\":{\"371\":1}}],[\"除了linkedlist实现了队列接口之外\",{\"1\":{\"202\":1}}],[\"除了可以直接当做列表使用之外\",{\"1\":{\"199\":1}}],[\"除了需要求解\",{\"1\":{\"55\":1}}],[\"注解\",{\"1\":{\"351\":1}}],[\"注意只是相当于外部来说\",{\"1\":{\"387\":1}}],[\"注意返回值是class<\",{\"1\":{\"339\":1}}],[\"注意此class对象只会存在一个\",{\"1\":{\"337\":1}}],[\"注意这是一个泛型类\",{\"1\":{\"319\":1}}],[\"注意这个是一个抽象类\",{\"1\":{\"323\":1}}],[\"注意这个填充是对集合中已有的元素进行覆盖\",{\"1\":{\"235\":1}}],[\"注意这个接口是集合接口的父接口\",{\"1\":{\"193\":1}}],[\"注意\",{\"1\":{\"166\":1,\"182\":2,\"191\":1,\"228\":1,\"234\":1,\"247\":1,\"248\":2,\"249\":1,\"277\":1,\"286\":1,\"287\":1,\"305\":1,\"318\":1,\"340\":1,\"376\":1,\"378\":1,\"386\":1,\"401\":1,\"402\":2}}],[\"注重近期的reward\",{\"1\":{\"19\":1}}],[\"跟对象成员变量的默认值是一样的\",{\"1\":{\"370\":1}}],[\"跟普通的类一样\",{\"1\":{\"354\":1}}],[\"跟普通方法是一样的\",{\"1\":{\"166\":1}}],[\"跟之前的\",{\"1\":{\"219\":1}}],[\"跟next相反\",{\"1\":{\"194\":1}}],[\"跟我们之前不一样\",{\"1\":{\"215\":1}}],[\"跟我们之前的顺序表思路差不多\",{\"1\":{\"182\":1}}],[\"跟我们之前顺序表的插入是一样的\",{\"1\":{\"181\":1}}],[\"跟随一个\",{\"1\":{\"154\":1}}],[\"跟随策略π\",{\"1\":{\"81\":1}}],[\"男\",{\"1\":{\"166\":2,\"351\":4,\"354\":1,\"355\":1,\"356\":1}}],[\"默认会让整个程序终止并打印栈追踪信息\",{\"1\":{\"402\":1}}],[\"默认会交给\",{\"1\":{\"402\":1}}],[\"默认会返回\",{\"1\":{\"214\":1}}],[\"默认继承自\",{\"1\":{\"399\":1}}],[\"默认private\",{\"1\":{\"356\":1}}],[\"默认实现是直接用等号判断\",{\"1\":{\"350\":1}}],[\"默认是接收控制台输入\",{\"1\":{\"285\":1}}],[\"默认\",{\"1\":{\"278\":2}}],[\"默认从小到大排序\",{\"1\":{\"228\":1}}],[\"默认情况按照自然顺序\",{\"1\":{\"203\":1}}],[\"默认情况下直接运行什么都没有\",{\"1\":{\"377\":1}}],[\"默认情况下格式为\",{\"1\":{\"350\":1}}],[\"默认情况下\",{\"1\":{\"278\":1,\"337\":1}}],[\"默认情况下包名是可以省略的\",{\"1\":{\"277\":1}}],[\"默认情况下阈值也是0\",{\"1\":{\"217\":1}}],[\"默认情况下会认为传入的是int类型值\",{\"1\":{\"182\":1}}],[\"默认情况下每个类都会自带一个没有任何参数的无参构造方法\",{\"1\":{\"166\":1}}],[\"默认都是尾插\",{\"1\":{\"200\":1}}],[\"默认有一个指向集合中第一个元素的指针\",{\"1\":{\"188\":1}}],[\"默认的情况下\",{\"1\":{\"278\":1}}],[\"默认的列表最大长度为integer\",{\"1\":{\"182\":1}}],[\"默认的数组容量\",{\"1\":{\"182\":1}}],[\"默认就是原始类型\",{\"1\":{\"173\":1}}],[\"默认就是object\",{\"1\":{\"173\":1}}],[\"默认值为false\",{\"1\":{\"161\":1}}],[\"构造函数也不能赋值\",{\"1\":{\"352\":1}}],[\"构造器\",{\"1\":{\"166\":1}}],[\"构造方法也可以被引用\",{\"1\":{\"393\":1}}],[\"构造方法得到字符串\",{\"1\":{\"248\":1}}],[\"构造方法会在new的时候自动执行\",{\"1\":{\"166\":1}}],[\"构造方法会在对象创建时执行\",{\"1\":{\"166\":1}}],[\"构造方法不需要指定返回值\",{\"1\":{\"166\":1}}],[\"构造方法不需要填写返回值\",{\"1\":{\"166\":1}}],[\"构造方法\",{\"0\":{\"166\":1},\"1\":{\"166\":1,\"182\":1}}],[\"优秀\",{\"1\":{\"415\":1,\"416\":2}}],[\"优先使用cpu资源\",{\"1\":{\"302\":1}}],[\"优先使用作用域最接近的\",{\"1\":{\"164\":1}}],[\"优先级越高的线程\",{\"1\":{\"302\":2}}],[\"优先级队列只能保证出队顺序是按照优先级进行的\",{\"1\":{\"203\":1}}],[\"优先级队列并不是队列中所有的元素都是按照优先级排放的\",{\"1\":{\"203\":1}}],[\"优先级队列可以根据每一个元素的优先级\",{\"1\":{\"203\":1}}],[\"优先级队列\",{\"0\":{\"203\":1},\"1\":{\"202\":1}}],[\"优化\",{\"1\":{\"275\":1}}],[\"优化方法\",{\"0\":{\"142\":1}}],[\"优化算法\",{\"0\":{\"136\":1}}],[\"优化目标函数的算法\",{\"1\":{\"132\":1}}],[\"优化问题\",{\"1\":{\"103\":1}}],[\"优化问题建立\",{\"0\":{\"11\":1}}],[\"出来的时候\",{\"1\":{\"217\":1}}],[\"出现重名时\",{\"1\":{\"164\":1}}],[\"出发的\",{\"1\":{\"82\":1,\"137\":1}}],[\"出发\",{\"1\":{\"78\":2,\"84\":1}}],[\"运用了封装的思想\",{\"1\":{\"362\":1}}],[\"运用到\",{\"1\":{\"29\":1}}],[\"运行时异常只需要继承\",{\"1\":{\"400\":1}}],[\"运行时异常\",{\"1\":{\"399\":1}}],[\"运行函数\",{\"1\":{\"323\":1}}],[\"运行态\",{\"1\":{\"318\":1}}],[\"运行main\",{\"1\":{\"295\":1}}],[\"运算符\",{\"1\":{\"162\":1}}],[\"小王\",{\"1\":{\"354\":1}}],[\"小于0表示小于\",{\"1\":{\"171\":1}}],[\"小明\",{\"1\":{\"162\":1,\"166\":1,\"214\":4,\"351\":4,\"355\":1,\"356\":1,\"386\":1}}],[\"小红\",{\"1\":{\"161\":1,\"214\":2,\"386\":1}}],[\"岁了\",{\"1\":{\"162\":1}}],[\"果直接创建对象\",{\"1\":{\"161\":1}}],[\"它是运行时异常的子类\",{\"1\":{\"402\":1}}],[\"它是局部内部类的简化版\",{\"1\":{\"390\":1}}],[\"它是一个用于操作数组的工具类\",{\"1\":{\"232\":1}}],[\"它就像一个字符串编辑器\",{\"1\":{\"380\":1}}],[\"它用于保存字符串\",{\"1\":{\"378\":1}}],[\"它本身也是类\",{\"1\":{\"370\":1}}],[\"它可以判断一个对象是否为此接口或是类的实现或是子类\",{\"1\":{\"343\":1}}],[\"它可以提高你的多线程任务的速度\",{\"1\":{\"330\":1}}],[\"它通过默认的forkjoinpool实现\",{\"1\":{\"330\":1}}],[\"它将我们的变量值存储在内部只能存储一个变量\",{\"1\":{\"319\":1}}],[\"它代表当前类的版本\",{\"1\":{\"289\":1}}],[\"它不是继承自filterinputstream的\",{\"1\":{\"287\":1}}],[\"它会直接打印基本数据类型或是调用对象的tostring\",{\"1\":{\"284\":1}}],[\"它会在元素插入时进行排序\",{\"1\":{\"207\":1}}],[\"它会在\",{\"1\":{\"82\":1}}],[\"它同样也支持mark\",{\"1\":{\"269\":1}}],[\"它还能把每一行内容依次转换为集合类提到的stream流\",{\"1\":{\"269\":1}}],[\"它支持按行读取\",{\"1\":{\"269\":1}}],[\"它能够在编译阶段就检查类型安全\",{\"1\":{\"415\":1}}],[\"它能够在插入数据时利用链表自动维护顺序\",{\"1\":{\"206\":1}}],[\"它能够格式化任意的类型\",{\"1\":{\"284\":1}}],[\"它能够提供一个缓冲\",{\"1\":{\"260\":1}}],[\"它们通过\",{\"1\":{\"241\":1}}],[\"它们都是容器\",{\"1\":{\"179\":1}}],[\"它给我们提供了大量的工具方法\",{\"1\":{\"232\":1}}],[\"它扩展了大量队列相关操作\",{\"1\":{\"200\":1}}],[\"它的权限非常高\",{\"1\":{\"336\":1}}],[\"它的底层很简单\",{\"1\":{\"224\":1}}],[\"它的底层就是采用哈希表实现的\",{\"1\":{\"205\":1}}],[\"它的内部直接维护了一个红黑树\",{\"1\":{\"219\":1}}],[\"它的内部对插入顺序进行了维护\",{\"1\":{\"214\":1}}],[\"它的运作机制大概是\",{\"1\":{\"188\":1}}],[\"它的主要特性有\",{\"1\":{\"181\":1}}],[\"它的祖先就是collection接口\",{\"1\":{\"180\":1}}],[\"它的属性没有进行赋值\",{\"1\":{\"161\":1}}],[\"我会学习\",{\"1\":{\"354\":1,\"355\":1}}],[\"我这里读取的是一个字符串或是一个个字符\",{\"1\":{\"283\":1}}],[\"我是编译时异常\",{\"1\":{\"401\":1}}],[\"我是学习方法\",{\"1\":{\"392\":2}}],[\"我是匿名内部类的实现\",{\"1\":{\"390\":1}}],[\"我是局部内部类\",{\"1\":{\"388\":1}}],[\"我是静态内部类\",{\"1\":{\"387\":1}}],[\"我是静态方法\",{\"1\":{\"274\":1,\"278\":1}}],[\"我是成员内部类\",{\"1\":{\"386\":2}}],[\"我是默认实现\",{\"1\":{\"354\":1}}],[\"我是工人\",{\"1\":{\"351\":1,\"353\":1}}],[\"我是定时任务\",{\"1\":{\"322\":2}}],[\"我是另一个线程\",{\"1\":{\"297\":2}}],[\"我是代码块\",{\"1\":{\"166\":1}}],[\"我被构造了\",{\"1\":{\"166\":1}}],[\"我叫\",{\"1\":{\"162\":1}}],[\"我任性\",{\"1\":{\"161\":1}}],[\"我们希望能够分不同情况处理不同类型的异常\",{\"1\":{\"402\":1}}],[\"我们希望cpu花费更多的时间去处理更重要的任务\",{\"1\":{\"302\":1}}],[\"我们抛出异常实际上就是将这个异常对象抛出\",{\"1\":{\"401\":1}}],[\"我们自定义异常也是从这两类中进行选择\",{\"1\":{\"400\":1}}],[\"我们自己写的都行\",{\"1\":{\"193\":1}}],[\"我们同样需要使用对象来进行方法引用\",{\"1\":{\"393\":1}}],[\"我们同样可以使用\",{\"1\":{\"214\":1}}],[\"我们首先需要创建对象\",{\"1\":{\"386\":1}}],[\"我们一般只会在类的内部自己使用\",{\"1\":{\"386\":1}}],[\"我们一般称为限定符\",{\"1\":{\"381\":1}}],[\"我们知道\",{\"1\":{\"378\":1}}],[\"我们要创建一个数组\",{\"1\":{\"370\":1}}],[\"我们如果直接让\",{\"1\":{\"362\":1}}],[\"我们如果想一次性全部读取的话\",{\"1\":{\"248\":1}}],[\"我们如果想要在方法中访问到当前对象的属性\",{\"1\":{\"164\":1}}],[\"我们直接调用父类的实现就可以了\",{\"1\":{\"355\":1}}],[\"我们直接使用成员变量即可\",{\"1\":{\"162\":1}}],[\"我们从\",{\"1\":{\"343\":1}}],[\"我们从开始\",{\"1\":{\"295\":1}}],[\"我们使用instanceof进行类型比较\",{\"1\":{\"343\":1}}],[\"我们无论通过什么方式访问\",{\"1\":{\"337\":1}}],[\"我们前面提到的stop\",{\"1\":{\"301\":1}}],[\"我们前面创建对象\",{\"1\":{\"166\":1}}],[\"我们平时使用的println方法就是printstream中的方法\",{\"1\":{\"284\":1}}],[\"我们现在只拿到了一个inputstream\",{\"1\":{\"283\":1}}],[\"我们之前都是直接创建的类\",{\"1\":{\"277\":1}}],[\"我们之前一个结点只有键\",{\"1\":{\"215\":1}}],[\"我们实际上是将\",{\"1\":{\"275\":1}}],[\"我们并不会通过一个具体的对象去修改和使用静态属性\",{\"1\":{\"274\":1}}],[\"我们发现type实际上是class类的父接口\",{\"1\":{\"343\":1}}],[\"我们发现实际上效果是相同的\",{\"1\":{\"312\":1}}],[\"我们发现\",{\"1\":{\"304\":1,\"305\":1,\"313\":1,\"330\":1,\"362\":1}}],[\"我们发现虽然后面的部分没有保存\",{\"1\":{\"265\":1}}],[\"我们发现得到的是一个optional类实例\",{\"1\":{\"228\":1}}],[\"我们惊奇地发现\",{\"1\":{\"237\":1}}],[\"我们想快速求得list中的最大值和最小值\",{\"1\":{\"233\":1}}],[\"我们想让每一个元素通过\",{\"1\":{\"228\":1}}],[\"我们想要遍历一个集合中所有的元素\",{\"1\":{\"190\":1}}],[\"我们用一堆随机数来进行更多流操作的演示\",{\"1\":{\"228\":1}}],[\"我们用就完事\",{\"1\":{\"217\":1}}],[\"我们来看看以下这段代码会得到什么结果\",{\"1\":{\"313\":1}}],[\"我们来看看resize\",{\"1\":{\"217\":1}}],[\"我们来看看这里面是怎么定义的\",{\"1\":{\"215\":1}}],[\"我们通过使用\",{\"1\":{\"274\":1}}],[\"我们通过保存键值对的形式来存储映射关系\",{\"1\":{\"212\":1}}],[\"我们通常将\",{\"1\":{\"27\":1}}],[\"我们还可以使用方法引用\",{\"1\":{\"392\":1}}],[\"我们还可以在当前线程的工作不重要时\",{\"1\":{\"304\":1}}],[\"我们还可以通过flat来对整个流进行进一步细分\",{\"1\":{\"228\":1}}],[\"我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题\",{\"1\":{\"217\":1}}],[\"我们还需要理解其所描述的最优策略π∗\",{\"1\":{\"56\":1}}],[\"我们还会回来看我们\",{\"1\":{\"207\":1}}],[\"我们在方法中使用待确定类型的变量时\",{\"1\":{\"416\":1}}],[\"我们在重写方法时\",{\"1\":{\"401\":1}}],[\"我们在重写父类方法时\",{\"1\":{\"351\":1}}],[\"我们在之前其实已经接触过一些异常了\",{\"1\":{\"399\":1}}],[\"我们在编写程序时\",{\"1\":{\"313\":1}}],[\"我们在自己的包中也建一个名为string的类\",{\"1\":{\"277\":1}}],[\"我们在\",{\"1\":{\"275\":1}}],[\"我们在前面介绍了arrays\",{\"1\":{\"232\":1}}],[\"我们在创建时\",{\"1\":{\"219\":1}}],[\"我们在正常插入一个键值对时\",{\"1\":{\"217\":1}}],[\"我们在获取所有键和所有值时\",{\"1\":{\"214\":1}}],[\"我们在获取一个不存在的映射时\",{\"1\":{\"214\":1}}],[\"我们在这里先不去探讨实现原理\",{\"1\":{\"205\":1}}],[\"我们在使用\",{\"1\":{\"182\":1}}],[\"我们的每一个异常也是一个类\",{\"1\":{\"399\":1}}],[\"我们的包就可以命名为com\",{\"1\":{\"277\":1}}],[\"我们的元素之间是两两对应的\",{\"1\":{\"212\":1}}],[\"我们的插入顺序虽然是10\",{\"1\":{\"203\":1}}],[\"我们的方法需要能够同时应对多种情况\",{\"1\":{\"165\":1}}],[\"我们先来测试一下它的特性\",{\"1\":{\"205\":1}}],[\"我们先来看看队列接口\",{\"1\":{\"200\":1}}],[\"我们先直接求解\",{\"1\":{\"142\":1}}],[\"我们这里要删除的是刚刚传入的值为10的integer对象\",{\"1\":{\"182\":1}}],[\"我们这里强行初始化为vπ0​​\",{\"1\":{\"70\":1}}],[\"我们会使用接口的引用\",{\"1\":{\"182\":1}}],[\"我们会在第六章多线程部分中讲解\",{\"1\":{\"350\":1}}],[\"我们会在第五章集合类中使用到\",{\"1\":{\"350\":1}}],[\"我们会在jvm篇视频教程中进行介绍\",{\"1\":{\"350\":1}}],[\"我们会在下一章多线程部分中进行介绍\",{\"1\":{\"180\":2}}],[\"我们会在后面继续了解\",{\"1\":{\"299\":1}}],[\"我们会在后面进行详细介绍\",{\"1\":{\"182\":1}}],[\"我们会在后面进行讲解\",{\"1\":{\"180\":1}}],[\"我们会在后面进行介绍\",{\"1\":{\"180\":1}}],[\"我们会在后面介绍\",{\"1\":{\"180\":1}}],[\"我们再来使用这个对象的泛型成员\",{\"1\":{\"172\":1}}],[\"我们就能快速得到文件的所有信息\",{\"1\":{\"255\":1}}],[\"我们就需要使用到泛型的上界定义\",{\"1\":{\"172\":1}}],[\"我们就可以使用biginteger来完成\",{\"1\":{\"364\":1}}],[\"我们就可以使用inputstreamreader来帮助我们实现\",{\"1\":{\"283\":1}}],[\"我们就可以使用\",{\"1\":{\"228\":1}}],[\"我们就可以把一个\",{\"1\":{\"228\":1}}],[\"我们就可以实现对集合中的元素的进行遍历\",{\"1\":{\"188\":1}}],[\"我们就可以更加灵活地控制泛型的具体类型范围\",{\"1\":{\"172\":1}}],[\"我们就可以自定义\",{\"1\":{\"171\":1}}],[\"我们就可以通过\",{\"1\":{\"104\":1}}],[\"我们就可以得到\",{\"1\":{\"99\":1}}],[\"我们也可以定义多个\",{\"1\":{\"416\":1}}],[\"我们也可以定义泛型方法\",{\"1\":{\"171\":1}}],[\"我们也可以手动指定版本\",{\"1\":{\"289\":1}}],[\"我们也可以手动声明\",{\"1\":{\"166\":1}}],[\"我们也可以使用stop\",{\"1\":{\"299\":1}}],[\"我们也可以使用scanner来扫描其他的输入流\",{\"1\":{\"285\":1}}],[\"我们也可以使用泛型来表示\",{\"1\":{\"171\":1}}],[\"我们也可以让它向文件中打印\",{\"1\":{\"284\":1}}],[\"我们也可以寻找子集合的位置\",{\"1\":{\"237\":1}}],[\"我们也可以将一个可修改的集合变成只读的集合\",{\"1\":{\"236\":1}}],[\"我们也可以对集合的元素进行快速填充\",{\"1\":{\"235\":1}}],[\"我们也可以只通过stream来完成所有数字的和\",{\"1\":{\"228\":1}}],[\"我们也可以为这种情况添加一个预备方案\",{\"1\":{\"214\":1}}],[\"我们也可以为构造方法设定参数\",{\"1\":{\"166\":1}}],[\"我们也可以自定义排序规则\",{\"1\":{\"207\":1}}],[\"我们也可以自定义比较规则\",{\"1\":{\"203\":1}}],[\"我们也可以在类中添加代码块\",{\"1\":{\"166\":1}}],[\"我们也可以不对任何对象进行引用\",{\"1\":{\"161\":1}}],[\"我们也可以进行近似\",{\"1\":{\"156\":1}}],[\"我们便称为\",{\"1\":{\"156\":1}}],[\"我们定义的每一个状态其实就是一个public\",{\"1\":{\"356\":1}}],[\"我们定义\",{\"1\":{\"148\":1}}],[\"我们定义最优的策略为\",{\"1\":{\"148\":1}}],[\"我们将类放到包中\",{\"1\":{\"277\":1}}],[\"我们将变量p2赋值为p1的值\",{\"1\":{\"161\":1}}],[\"我们将\",{\"1\":{\"138\":1}}],[\"我们是无法估计的\",{\"1\":{\"136\":1}}],[\"我们是引入了\",{\"1\":{\"105\":1}}],[\"我们很难直接获得\",{\"1\":{\"101\":1}}],[\"我们有以下几种方法\",{\"1\":{\"101\":1}}],[\"我们得到的观测值是\",{\"1\":{\"99\":1}}],[\"我们只能使用对应的包装类\",{\"1\":{\"416\":1}}],[\"我们只能去创建它的子类对象\",{\"1\":{\"353\":1}}],[\"我们只能简单的删除\",{\"1\":{\"205\":1}}],[\"我们只能通过\",{\"1\":{\"97\":1}}],[\"我们只需要在类名前面把完整的包名也给写上\",{\"1\":{\"277\":1}}],[\"我们只需要在当前状态下\",{\"1\":{\"57\":1}}],[\"我们只需要直接拿来用就行了\",{\"1\":{\"180\":1}}],[\"我们只需要使用\",{\"1\":{\"162\":1}}],[\"我们只需要挑选在当前迭代下最大的\",{\"1\":{\"63\":1}}],[\"我们采用的是\",{\"1\":{\"87\":1}}],[\"我们不仅可以通过构造方法\",{\"1\":{\"166\":1}}],[\"我们不仅可以用来估计q\",{\"1\":{\"81\":1}}],[\"我们不断地与环境进行交互\",{\"1\":{\"135\":1}}],[\"我们不能直接得到随机变量的值\",{\"1\":{\"99\":1}}],[\"我们不能通过之前的方法来求出q\",{\"1\":{\"77\":1}}],[\"我们选取其\",{\"1\":{\"79\":1}}],[\"我们仍需要估计\",{\"1\":{\"79\":1}}],[\"我们需要在里面添加1\",{\"1\":{\"416\":1}}],[\"我们需要在虚拟机参数中手动开启一下\",{\"1\":{\"403\":1}}],[\"我们需要一种更加安全的机制来维持秩序\",{\"1\":{\"311\":1}}],[\"我们需要明确指定一下\",{\"1\":{\"277\":1}}],[\"我们需要结合具体的场景来决定\",{\"1\":{\"182\":1}}],[\"我们需要从经验池\",{\"1\":{\"142\":1}}],[\"我们需要思考使用\",{\"1\":{\"104\":1}}],[\"我们需要保证策略是不断提升\",{\"1\":{\"68\":1}}],[\"我们需要找到一个\",{\"1\":{\"26\":1}}],[\"我们可以选择在实现类明确泛型类型\",{\"1\":{\"417\":1}}],[\"我们可以下面的方式实现多种字符匹配\",{\"1\":{\"381\":1}}],[\"我们可以让他等于一个非常大的数字\",{\"1\":{\"364\":1}}],[\"我们可以把这个容器想象成是一个货架\",{\"1\":{\"331\":1}}],[\"我们可以利用jstack命令来检测死锁\",{\"1\":{\"313\":1}}],[\"我们可以在收到中断信号后\",{\"1\":{\"301\":1}}],[\"我们可以添加transient关键字\",{\"1\":{\"290\":1}}],[\"我们可以为成员变量\",{\"1\":{\"278\":1}}],[\"我们可以理解为是属于这个类的\",{\"1\":{\"274\":1}}],[\"我们可以提前准备好合适容量的byte数组来存放\",{\"1\":{\"248\":1}}],[\"我们可以对一个集合进行二分搜索\",{\"1\":{\"234\":1}}],[\"我们可以非常高效的从\",{\"1\":{\"205\":1}}],[\"我们可以来测试一下\",{\"1\":{\"201\":1}}],[\"我们可以直接创建静态内部类的对象\",{\"1\":{\"387\":1}}],[\"我们可以直接在类的内部定义成员内部类\",{\"1\":{\"386\":1}}],[\"我们可以直接通过接口名\",{\"1\":{\"354\":1}}],[\"我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值\",{\"1\":{\"362\":1}}],[\"我们可以直接将一个\",{\"1\":{\"200\":1}}],[\"我们可以直接使用foreach语法来快速遍历集合类\",{\"1\":{\"191\":1}}],[\"我们可以快速生成一个只读的list\",{\"1\":{\"182\":1}}],[\"我们可以使用一个特殊的名字表示泛型\",{\"1\":{\"416\":1}}],[\"我们可以使用pow方法直接计算a的b次方\",{\"1\":{\"409\":1}}],[\"我们可以使用断言表达式来对某些东西进行判断\",{\"1\":{\"403\":1}}],[\"我们可以使用append方法来讲字符串拼接到后面\",{\"1\":{\"380\":1}}],[\"我们可以使用它来对字符串进行拼接\",{\"1\":{\"380\":1}}],[\"我们可以使用threadlocal类\",{\"1\":{\"319\":1}}],[\"我们可以使用join\",{\"1\":{\"305\":1}}],[\"我们可以使用\",{\"1\":{\"166\":1,\"206\":1,\"214\":1,\"277\":1}}],[\"我们可以进行一次重载\",{\"1\":{\"165\":1}}],[\"我们可以认为\",{\"1\":{\"150\":1}}],[\"我们可以写出\",{\"1\":{\"113\":1}}],[\"我们可以将一个类定义为一个泛型类\",{\"1\":{\"416\":1}}],[\"我们可以将方法标记为静态\",{\"1\":{\"274\":1}}],[\"我们可以将这个只读的列表作为参数传入\",{\"1\":{\"182\":1}}],[\"我们可以将这个问题可以转化为一个随机变量的方法\",{\"1\":{\"105\":1}}],[\"我们可以将各种需要初始化的操作都在这里进行处理\",{\"1\":{\"166\":1}}],[\"我们可以将该问题定义为一个\",{\"1\":{\"110\":1}}],[\"我们可以将\",{\"1\":{\"101\":1,\"103\":1,\"104\":1}}],[\"我们可以修改为噪音\",{\"1\":{\"99\":1}}],[\"我们可以设计如下方程\",{\"1\":{\"99\":1}}],[\"我们可以确保其可以遍历所有的\",{\"1\":{\"86\":1}}],[\"我们可以生成一个统计实例来帮助我们快速进行统计\",{\"1\":{\"228\":1}}],[\"我们可以生成一个\",{\"1\":{\"78\":1}}],[\"我们可以通过类名直接使用\",{\"1\":{\"407\":1}}],[\"我们可以通过反射机制\",{\"1\":{\"336\":1}}],[\"我们可以通过调用foreachordered\",{\"1\":{\"330\":1}}],[\"我们可以通过调用cancel\",{\"1\":{\"324\":1}}],[\"我们可以通过此对象来创建任意类型的定时任务\",{\"1\":{\"323\":1}}],[\"我们可以通过创建一个timer类来让它进行定时任务调度\",{\"1\":{\"323\":1}}],[\"我们可以通过包的形式将这些类进行分类存放\",{\"1\":{\"277\":1}}],[\"我们可以通过它来获取文件的输入流\",{\"1\":{\"247\":1}}],[\"我们可以通过对象的引用来间接操作对象\",{\"1\":{\"161\":1}}],[\"我们可以通过对应的迭代算法来求解贝尔曼最优公式\",{\"1\":{\"62\":1}}],[\"我们可以通过一些特定的算法进行求解\",{\"1\":{\"96\":1}}],[\"我们可以通过前面所引入的\",{\"1\":{\"77\":1}}],[\"我们可以很轻松的求出各个情况下的q\",{\"1\":{\"77\":1}}],[\"我们可以分析出在该状态下采取哪个\",{\"1\":{\"48\":1}}],[\"我们对无人机的发射功率有一个约束\",{\"1\":{\"9\":1}}],[\"关键字\",{\"0\":{\"290\":1},\"1\":{\"351\":1,\"370\":1}}],[\"关键字来声明一个变量或一个方法为静态的\",{\"1\":{\"274\":1}}],[\"关键元素\",{\"1\":{\"20\":1}}],[\"关于对象类型的变量\",{\"1\":{\"161\":1}}],[\"修改键值对的值\",{\"1\":{\"213\":1}}],[\"修改相关操作\",{\"1\":{\"213\":1}}],[\"修改一个对象的属性并不会影响到其他对象\",{\"1\":{\"161\":1}}],[\"修改对象的属性\",{\"1\":{\"161\":1}}],[\"修改为\",{\"1\":{\"142\":1}}],[\"访问第三行第二列的元素\",{\"1\":{\"375\":1}}],[\"访问元素\",{\"0\":{\"372\":1}}],[\"访问权限控制\",{\"0\":{\"278\":1}}],[\"访问类的静态变量\",{\"1\":{\"275\":1}}],[\"访问\",{\"1\":{\"161\":1}}],[\"年龄\",{\"1\":{\"161\":1,\"166\":1}}],[\"名字\",{\"1\":{\"161\":1}}],[\"概念上的定义\",{\"1\":{\"161\":1}}],[\"概率分布\",{\"1\":{\"150\":1}}],[\"类进行存储成绩\",{\"1\":{\"415\":1}}],[\"类呢\",{\"1\":{\"415\":1}}],[\"类的子类\",{\"1\":{\"416\":1}}],[\"类的异常都是编译时异常\",{\"1\":{\"399\":1}}],[\"类的内部类它会单独生成一个\",{\"1\":{\"389\":1}}],[\"类的创建\",{\"1\":{\"161\":1}}],[\"类只能继承一个\",{\"1\":{\"354\":1}}],[\"类可以实现这个接口\",{\"1\":{\"354\":1}}],[\"类名\",{\"1\":{\"393\":3}}],[\"类名获取\",{\"1\":{\"339\":1}}],[\"类名的首字母通常是大写的\",{\"1\":{\"161\":1}}],[\"类加载机制\",{\"0\":{\"337\":1}}],[\"类还有三个方法我们从来没有使用过\",{\"1\":{\"318\":1}}],[\"类锁\",{\"1\":{\"312\":1}}],[\"类锁只有一个\",{\"1\":{\"312\":1}}],[\"类就是专用于集合的工具类\",{\"1\":{\"232\":1}}],[\"类似\",{\"1\":{\"228\":1,\"390\":1}}],[\"类似于一个插件\",{\"1\":{\"354\":1}}],[\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制\",{\"1\":{\"311\":1}}],[\"类似于c++中的namespace\",{\"1\":{\"277\":1}}],[\"类似于c++指针的情况\",{\"1\":{\"161\":1}}],[\"类似于vip用户可以优先结束排队\",{\"1\":{\"203\":1}}],[\"类型的变量\",{\"1\":{\"416\":1}}],[\"类型的\",{\"1\":{\"376\":1}}],[\"类型的成绩了\",{\"1\":{\"172\":1}}],[\"类型为\",{\"1\":{\"343\":1}}],[\"类型比较\",{\"0\":{\"343\":1}}],[\"类型作为存储\",{\"1\":{\"253\":1}}],[\"类型擦除\",{\"0\":{\"173\":1}}],[\"类型\",{\"1\":{\"171\":2,\"370\":8,\"415\":1,\"416\":1}}],[\"类型变量并不是只能在泛型类中才可以使用\",{\"1\":{\"171\":1}}],[\"类除了具有属性外\",{\"1\":{\"162\":1}}],[\"类\",{\"0\":{\"255\":1,\"338\":1,\"350\":1,\"379\":1,\"380\":1,\"387\":1},\"1\":{\"161\":1,\"180\":1,\"241\":1,\"312\":1,\"352\":1,\"384\":1,\"399\":1,\"409\":1}}],[\"类与对象4\",{\"0\":{\"359\":1}}],[\"类与对象3\",{\"0\":{\"346\":1}}],[\"类与对象2\",{\"0\":{\"273\":1}}],[\"类与对象\",{\"0\":{\"161\":1}}],[\"类与对象1\",{\"0\":{\"160\":1}}],[\"梯度上升算法的本质就是最大化目标函数\",{\"1\":{\"156\":1}}],[\"梯度上升算法\",{\"0\":{\"156\":1}}],[\"梯度下降\",{\"1\":{\"136\":1}}],[\"梯度下降法\",{\"1\":{\"101\":1}}],[\"近似\",{\"1\":{\"155\":1}}],[\"严格等于\",{\"1\":{\"155\":1}}],[\"时\",{\"1\":{\"182\":1,\"218\":1,\"350\":1}}],[\"时的平均reward\",{\"1\":{\"153\":1}}],[\"时wk​→w∗\",{\"1\":{\"104\":1}}],[\"确定\",{\"1\":{\"148\":1}}],[\"确保根是存在且唯一的\",{\"1\":{\"98\":1}}],[\"经验回放\",{\"0\":{\"143\":1}}],[\"然后创建子类对象\",{\"1\":{\"390\":1}}],[\"然后\",{\"1\":{\"313\":1}}],[\"然后继续做我们的事情\",{\"1\":{\"301\":1}}],[\"然后生成了一个\",{\"1\":{\"154\":1}}],[\"然后我们通过\",{\"1\":{\"142\":1}}],[\"然后在更新了一定次数之后\",{\"1\":{\"142\":1}}],[\"然后进行迭代\",{\"1\":{\"79\":1}}],[\"然后进行不断迭代\",{\"1\":{\"47\":1}}],[\"固定不动\",{\"1\":{\"142\":1}}],[\"固定\",{\"1\":{\"142\":1}}],[\"目前各位小伙伴就暂时理解为会返回对象存放的内存地址\",{\"1\":{\"350\":1}}],[\"目前暂时不会用到\",{\"1\":{\"350\":3}}],[\"目前\",{\"1\":{\"207\":1}}],[\"目前的优化算法只是在估计给定策略的\",{\"1\":{\"136\":1}}],[\"目的是最小化目标函数\",{\"1\":{\"141\":1}}],[\"目标函数梯度求解\",{\"0\":{\"155\":1}}],[\"目标函数定义\",{\"0\":{\"149\":1}}],[\"目标\",{\"1\":{\"132\":1}}],[\"目标是获得无人机的最佳3d位置\",{\"1\":{\"13\":1}}],[\"≥0\",{\"1\":{\"135\":1,\"150\":1,\"155\":1}}],[\"≥vπ​\",{\"1\":{\"53\":1}}],[\"下划线\",{\"1\":{\"381\":1}}],[\"下界限定就像这样\",{\"1\":{\"172\":1}}],[\"下界\",{\"1\":{\"172\":1}}],[\"下的\",{\"1\":{\"135\":1,\"152\":1}}],[\"下行\",{\"1\":{\"13\":1}}],[\"认为所有状态都是同等重要的\",{\"1\":{\"134\":1}}],[\"寻找一个最优的参数w\",{\"1\":{\"132\":1}}],[\"版本\",{\"0\":{\"125\":1,\"126\":1}}],[\"||\",{\"1\":{\"216\":4,\"241\":2}}],[\"|\",{\"0\":{\"121\":1,\"233\":1,\"367\":2},\"1\":{\"189\":2,\"268\":1,\"288\":1,\"290\":1,\"312\":1,\"318\":1,\"343\":1,\"402\":2,\"410\":3}}],[\"形式下的贝尔曼最优公式\",{\"1\":{\"119\":1}}],[\"≐e\",{\"1\":{\"155\":1}}],[\"≐g\",{\"1\":{\"110\":1}}],[\"≐w−x\",{\"1\":{\"99\":1}}],[\"≐w−e\",{\"1\":{\"99\":1}}],[\"ω=e\",{\"1\":{\"110\":1}}],[\"计算机网络\",{\"1\":{\"416\":2}}],[\"计算10\",{\"1\":{\"364\":1}}],[\"计算的话也只能通过\",{\"1\":{\"364\":1}}],[\"计算规则为\",{\"1\":{\"228\":1}}],[\"计算并将键值对放入map中\",{\"1\":{\"221\":1}}],[\"计算当前整个集合对象的哈希值\",{\"1\":{\"180\":1}}],[\"计算\",{\"1\":{\"110\":1}}],[\"期望的情况\",{\"1\":{\"105\":1}}],[\"另一种表达\",{\"0\":{\"151\":1,\"154\":1}}],[\"另一种问题描述方法\",{\"0\":{\"105\":1}}],[\"另一些则频繁被访问\",{\"1\":{\"134\":1}}],[\"另一分布下\",{\"1\":{\"29\":1}}],[\"∇w​f\",{\"1\":{\"104\":2}}],[\"让子类继续为一个泛型类\",{\"1\":{\"417\":1}}],[\"让程序继续运行下去\",{\"1\":{\"402\":1}}],[\"让程序员写出高效率\",{\"1\":{\"228\":1}}],[\"让类来使用这个接口\",{\"1\":{\"354\":1}}],[\"让我们的java程序更加生动形象\",{\"1\":{\"347\":1}}],[\"让我看看\",{\"1\":{\"274\":1}}],[\"让线程1加入\",{\"1\":{\"305\":1}}],[\"让线程自行处理后续\",{\"1\":{\"301\":1}}],[\"让位\",{\"1\":{\"304\":1}}],[\"让p等于e一会覆盖就行了\",{\"1\":{\"216\":1}}],[\"让其实现iterable接口\",{\"1\":{\"193\":1}}],[\"让当前对象的name变量值等于参数传入的值\",{\"1\":{\"164\":1}}],[\"让\",{\"1\":{\"104\":1}}],[\"往往可以转化为导数为\",{\"1\":{\"104\":1}}],[\"=\",{\"1\":{\"116\":1,\"120\":1}}],[\"=e\",{\"1\":{\"104\":1}}],[\"=n\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"含噪声\",{\"1\":{\"104\":1}}],[\"含噪音\",{\"1\":{\"97\":1}}],[\"⇓wk+1​=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"到\",{\"1\":{\"104\":1}}],[\"转化为\",{\"1\":{\"103\":1}}],[\"转换流\",{\"0\":{\"283\":1}}],[\"转换到\",{\"1\":{\"130\":1}}],[\"转换到状态s\",{\"1\":{\"20\":1}}],[\"转换为数字666\",{\"1\":{\"363\":1}}],[\"转换为\",{\"1\":{\"58\":1,\"76\":1,\"77\":1,\"148\":1}}],[\"均为非负整数\",{\"1\":{\"381\":1}}],[\"均是随机变量\",{\"1\":{\"110\":1,\"141\":1}}],[\"均值估计\",{\"1\":{\"103\":1}}],[\"均收集完\",{\"1\":{\"82\":1}}],[\"分割字符串\",{\"1\":{\"379\":1}}],[\"分割字符串并生成新的流\",{\"1\":{\"228\":1}}],[\"分割操作\",{\"1\":{\"379\":1}}],[\"分别是wait\",{\"1\":{\"318\":1}}],[\"分别设为1\",{\"1\":{\"10\":1}}],[\"分析随机变量\",{\"1\":{\"133\":1}}],[\"分析\",{\"0\":{\"102\":1}}],[\"借用\",{\"1\":{\"101\":1}}],[\"▽w​q^​\",{\"1\":{\"142\":2}}],[\"▽w​qt​^​\",{\"1\":{\"139\":1,\"140\":1}}],[\"▽w​vt​^​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"▽w​v^\",{\"1\":{\"136\":1}}],[\"▽w​\",{\"1\":{\"136\":1}}],[\"▽w​j​=e\",{\"1\":{\"142\":1}}],[\"▽w​j\",{\"1\":{\"104\":1,\"136\":1}}],[\"▽w​f\",{\"1\":{\"101\":2,\"104\":10}}],[\"▽θ​π\",{\"1\":{\"155\":1}}],[\"▽θ​lnπ\",{\"1\":{\"155\":6,\"156\":1}}],[\"▽θ​ln\",{\"1\":{\"26\":3}}],[\"▽θ​j\",{\"1\":{\"26\":1,\"155\":3}}],[\"输出为\",{\"1\":{\"389\":1}}],[\"输出为标量\",{\"1\":{\"101\":1}}],[\"输出流没有read\",{\"1\":{\"249\":1}}],[\"输出流也需要在最后调用close\",{\"1\":{\"249\":1}}],[\"输出流\",{\"0\":{\"249\":1}}],[\"输入流会以某种方式保留之后读取的readlimit\",{\"1\":{\"265\":1}}],[\"输入流\",{\"0\":{\"247\":1,\"285\":1}}],[\"输入序列\",{\"1\":{\"97\":1}}],[\"⋅▽w​q^​\",{\"1\":{\"142\":1}}],[\"⋅\",{\"1\":{\"101\":1,\"110\":1}}],[\"η\",{\"1\":{\"99\":2,\"104\":2,\"110\":1,\"155\":1}}],[\"ηk2​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​\",{\"1\":{\"97\":3,\"99\":1,\"104\":1,\"110\":1}}],[\"应用于\",{\"0\":{\"99\":1}}],[\"应该是无人机最终停的位置即是部署的最佳位置\",{\"1\":{\"13\":1}}],[\"保证两个线程执行完成\",{\"1\":{\"311\":1,\"312\":2}}],[\"保证数据的安全性\",{\"1\":{\"311\":1}}],[\"保证当两个对象通过\",{\"1\":{\"241\":1}}],[\"保证\",{\"1\":{\"98\":2}}],[\"保证选取最大的\",{\"1\":{\"57\":1}}],[\"要求设计一个score对象\",{\"1\":{\"415\":1}}],[\"要求g\",{\"1\":{\"98\":1}}],[\"要么在当前函数通过\",{\"1\":{\"402\":1}}],[\"要么一直\",{\"1\":{\"402\":1}}],[\"要么就往上一级函数上\",{\"1\":{\"401\":1}}],[\"要么自己处理好\",{\"1\":{\"401\":1}}],[\"要创建一个抽象类的实例对象\",{\"1\":{\"390\":1}}],[\"要创建一个缓冲字节流\",{\"1\":{\"262\":1}}],[\"要使用抽象类\",{\"1\":{\"353\":1}}],[\"要是都不是这个类型还比什么\",{\"1\":{\"351\":1}}],[\"要是扩容之后比最大的大小还大\",{\"1\":{\"182\":1}}],[\"要是扩容之后的大小还没最小的大小大\",{\"1\":{\"182\":1}}],[\"要解决这种问题很简单\",{\"1\":{\"237\":1}}],[\"要生成正常使用的\",{\"1\":{\"182\":1}}],[\"要注意传参问题\",{\"1\":{\"182\":1}}],[\"要给成员变量设定初始值\",{\"1\":{\"166\":1}}],[\"要在对象创建时进行处理\",{\"1\":{\"166\":1}}],[\"要证明加入baseline成立\",{\"1\":{\"26\":1}}],[\"收敛性情况\",{\"1\":{\"116\":1}}],[\"收敛性分析\",{\"0\":{\"98\":1}}],[\"收集完毕才能进行一次迭代\",{\"1\":{\"101\":1}}],[\"收益最大\",{\"1\":{\"48\":1}}],[\"次且最多匹配\",{\"1\":{\"381\":1}}],[\"次\",{\"1\":{\"381\":4}}],[\"次的观测值\",{\"1\":{\"97\":1}}],[\"次方程根的估计\",{\"1\":{\"97\":1}}],[\"问题\",{\"1\":{\"103\":1,\"104\":1,\"110\":1}}],[\"问题转化\",{\"0\":{\"103\":1}}],[\"问题引入\",{\"0\":{\"96\":1,\"101\":1}}],[\"问题进行研究\",{\"1\":{\"92\":1}}],[\"第三个参数是读取流中的字节数\",{\"1\":{\"248\":1}}],[\"第二个参数是从给定数组的哪个位置开始放入内容\",{\"1\":{\"248\":1}}],[\"第二种\",{\"1\":{\"94\":1}}],[\"第一种\",{\"1\":{\"94\":1}}],[\"引用尾结点\",{\"1\":{\"182\":1}}],[\"引用首结点\",{\"1\":{\"182\":1}}],[\"引言\",{\"0\":{\"93\":1}}],[\"引入两个网络\",{\"1\":{\"142\":1}}],[\"引入\",{\"0\":{\"88\":1,\"110\":1,\"131\":1},\"1\":{\"48\":1,\"312\":1}}],[\"引入随机变量后对应的discounted\",{\"1\":{\"39\":1}}],[\"引入discount\",{\"1\":{\"19\":1}}],[\"针对于这些特性\",{\"1\":{\"181\":1}}],[\"针对\",{\"1\":{\"92\":1}}],[\"随时都认为有其他线程在对数据进行修改\",{\"1\":{\"312\":1}}],[\"随着我们的程序不断变大\",{\"1\":{\"277\":1}}],[\"随着无人机与用户之间距离和发射功率的变化\",{\"1\":{\"9\":1}}],[\"随机数生成\",{\"1\":{\"409\":1}}],[\"随机int型数字\",{\"1\":{\"228\":1}}],[\"随机变量\",{\"1\":{\"105\":1}}],[\"随机梯度下降\",{\"1\":{\"101\":1}}],[\"随机近似理论与随机梯度下降算法\",{\"0\":{\"92\":1}}],[\"ϵ−greedy\",{\"1\":{\"125\":1}}],[\"ϵ∈\",{\"1\":{\"87\":1}}],[\"ϵ\",{\"1\":{\"87\":2}}],[\"足够长的情况下\",{\"1\":{\"86\":1}}],[\"条件转换掉\",{\"1\":{\"85\":1}}],[\"据目前而言\",{\"1\":{\"84\":1}}],[\"未能访问\",{\"1\":{\"84\":1}}],[\"未知时的情况\",{\"1\":{\"97\":1}}],[\"未知\",{\"1\":{\"77\":1,\"96\":1,\"166\":1}}],[\"直接作为接口中抽象方法的实现\",{\"1\":{\"393\":2}}],[\"直接指定值和大小\",{\"1\":{\"370\":1}}],[\"直接写每个状态的名字即可\",{\"1\":{\"356\":1}}],[\"直接判断引用的对象是不是teacher类型\",{\"1\":{\"354\":1}}],[\"直接判断是否为这个类型\",{\"1\":{\"343\":1}}],[\"直接int\",{\"1\":{\"354\":1}}],[\"直接==\",{\"1\":{\"351\":1}}],[\"直接编写逻辑\",{\"1\":{\"297\":1}}],[\"直接使用integer为我们通过好的求和方法\",{\"1\":{\"393\":1}}],[\"直接使用就可以\",{\"1\":{\"278\":1}}],[\"直接使用即可\",{\"1\":{\"277\":1}}],[\"直接做参数\",{\"1\":{\"255\":1}}],[\"直接读取到char\",{\"1\":{\"253\":1}}],[\"直接在方法中创建局部内部类\",{\"1\":{\"388\":1}}],[\"直接在try\",{\"1\":{\"247\":1}}],[\"直接在类中定义变量\",{\"1\":{\"161\":1}}],[\"直接处理原始字节数据\",{\"1\":{\"245\":1}}],[\"直接构造一个默认大小为16负载因子0\",{\"1\":{\"224\":1}}],[\"直接替换为新的\",{\"1\":{\"223\":1}}],[\"直接给予一个比较规则即可\",{\"1\":{\"219\":1}}],[\"直接将字符串的666\",{\"1\":{\"363\":1}}],[\"直接将数据读取为任意基本数据类型\",{\"1\":{\"286\":1}}],[\"直接将新的容量变成旧的阈值\",{\"1\":{\"217\":1}}],[\"直接将对应位置上的元素替换为给定元素\",{\"1\":{\"181\":1}}],[\"直接结束\",{\"1\":{\"216\":2}}],[\"直接创建一个匿名的接口实现类\",{\"1\":{\"390\":1}}],[\"直接创建文件对象\",{\"1\":{\"255\":1}}],[\"直接创建新的结点连在后面\",{\"1\":{\"216\":1}}],[\"直接创建就行了\",{\"1\":{\"182\":1}}],[\"直接继承过来的方法\",{\"1\":{\"204\":1}}],[\"直接继承自前面介绍的\",{\"1\":{\"181\":1}}],[\"直接返回true\",{\"1\":{\"193\":1}}],[\"直接返回指针所指元素\",{\"1\":{\"190\":1}}],[\"直接认为就是要删除的对象\",{\"1\":{\"182\":1}}],[\"直接安排了\",{\"1\":{\"171\":1}}],[\"直接赋值\",{\"1\":{\"166\":1}}],[\"直接估计的是\",{\"1\":{\"120\":1}}],[\"直接通过\",{\"1\":{\"94\":1}}],[\"直接\",{\"1\":{\"82\":1}}],[\"直到对应的线程执行resume\",{\"1\":{\"313\":1}}],[\"直到读取完成为止\",{\"1\":{\"251\":1}}],[\"直到完成每一个元素的遍历\",{\"1\":{\"188\":1}}],[\"直到设置的收敛条件为止\",{\"1\":{\"66\":1}}],[\"直到各个簇的成员没有太大变化\",{\"1\":{\"13\":1}}],[\"才会初始化外部类\",{\"1\":{\"389\":1}}],[\"才会转换\",{\"1\":{\"318\":1}}],[\"才会依次进行\",{\"1\":{\"228\":1}}],[\"才能去\",{\"1\":{\"386\":1}}],[\"才能用这三个方法\",{\"1\":{\"318\":1}}],[\"才能进行比较\",{\"1\":{\"351\":1}}],[\"才能进行\",{\"1\":{\"82\":1}}],[\"才正确\",{\"1\":{\"312\":1}}],[\"才认为这两个元素是相同的\",{\"1\":{\"241\":1}}],[\"才是灵魂\",{\"1\":{\"224\":1}}],[\"才进行替换\",{\"1\":{\"223\":1}}],[\"才进行更新\",{\"1\":{\"82\":1}}],[\"等待结束\",{\"1\":{\"318\":1}}],[\"等待态的线程变为\",{\"1\":{\"318\":1}}],[\"等待\",{\"1\":{\"318\":1}}],[\"等待下一次获得cpu资源\",{\"1\":{\"300\":1}}],[\"等待通知\",{\"1\":{\"299\":1}}],[\"等方法\",{\"1\":{\"241\":1}}],[\"等价于\",{\"1\":{\"216\":1,\"381\":6}}],[\"等候时间过长\",{\"1\":{\"82\":1}}],[\"等均未知\",{\"1\":{\"75\":1}}],[\"缺点\",{\"1\":{\"82\":1}}],[\"估计了q\",{\"1\":{\"82\":1}}],[\"估计中\",{\"1\":{\"81\":2}}],[\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问\",{\"1\":{\"311\":1}}],[\"高效地更新\",{\"0\":{\"82\":1}}],[\"高度h=hn​\",{\"1\":{\"11\":1}}],[\"高度的上界是最大发射功率pmax​的函数\",{\"1\":{\"9\":1}}],[\"都会在最后执行任务\",{\"1\":{\"402\":1}}],[\"都会将指针后移一位\",{\"1\":{\"188\":1}}],[\"都可以直接进行方法引用\",{\"1\":{\"393\":1}}],[\"都可以使用\",{\"1\":{\"193\":1}}],[\"都在\",{\"1\":{\"364\":1}}],[\"都能调用它的任意一个方法和属性\",{\"1\":{\"336\":1}}],[\"都能够知道这个类所有的属性和方法\",{\"1\":{\"336\":1}}],[\"都能够容纳一组元素\",{\"1\":{\"179\":1}}],[\"都只能获取到当前线程所属的变量\",{\"1\":{\"319\":1}}],[\"都有学习的能力\",{\"1\":{\"354\":1}}],[\"都有一个获取原始类型class方法\",{\"1\":{\"340\":1}}],[\"都有一个interrupt\",{\"1\":{\"301\":1}}],[\"都有自己的内存空间\",{\"1\":{\"295\":1}}],[\"都有可选择的动作\",{\"1\":{\"19\":1}}],[\"都是可以支持泛型的\",{\"1\":{\"417\":1}}],[\"都是string类型的一个实例对象\",{\"1\":{\"379\":1}}],[\"都是始终是那一个对象\",{\"1\":{\"337\":1}}],[\"都是根据\",{\"1\":{\"241\":1}}],[\"都是直接使用new关键字就能直接搞定了\",{\"1\":{\"166\":1}}],[\"都是最大的\",{\"1\":{\"148\":1}}],[\"都需要有多个\",{\"1\":{\"84\":1}}],[\"都记录\",{\"1\":{\"81\":1}}],[\"仅仅是se中就有700多个\",{\"1\":{\"400\":1}}],[\"仅支持接口\",{\"1\":{\"392\":1}}],[\"仅使用默认类加载器\",{\"1\":{\"337\":1}}],[\"仅获取队首元素\",{\"1\":{\"200\":1}}],[\"仅适用于通配符\",{\"1\":{\"172\":1}}],[\"仅用作估计\",{\"1\":{\"81\":1}}],[\"仅需要考虑无人机的7个移动方向即可\",{\"1\":{\"14\":1}}],[\"节所述\",{\"1\":{\"79\":1}}],[\"有了\",{\"1\":{\"343\":1}}],[\"有哪些方法\",{\"1\":{\"336\":1}}],[\"有可能会使得这个类的一些结构发生变化\",{\"1\":{\"289\":1}}],[\"有时会遇到这样一个很麻烦的问题\",{\"1\":{\"283\":1}}],[\"有时候我们的方法中可能会出现一些与成员变量重名的变量\",{\"1\":{\"164\":1}}],[\"有着不同程度的访问限制\",{\"1\":{\"278\":1}}],[\"有点混乱\",{\"1\":{\"277\":1}}],[\"有些时候并不需要创建那么多对象\",{\"1\":{\"362\":1}}],[\"有些时候我们可能需要生成一个空的集合类返回\",{\"1\":{\"236\":1}}],[\"有些时候\",{\"1\":{\"165\":1}}],[\"有表示\",{\"1\":{\"155\":1}}],[\"有\",{\"1\":{\"79\":1}}],[\"有关注解我们会在最后一章进行介绍\",{\"1\":{\"351\":1}}],[\"有关锁的内容\",{\"1\":{\"350\":1}}],[\"有关线程中断相关问题\",{\"1\":{\"299\":1}}],[\"有关\",{\"1\":{\"48\":1,\"152\":1}}],[\"迭代器的使用是一次性的\",{\"1\":{\"191\":1}}],[\"迭代器\",{\"0\":{\"187\":1,\"190\":1},\"1\":{\"187\":1}}],[\"迭代器我们会在下一个部分讲解\",{\"1\":{\"181\":2}}],[\"迭代\",{\"1\":{\"79\":1}}],[\"≈▽θ​lnπ\",{\"1\":{\"155\":1}}],[\"≈vπ​\",{\"1\":{\"131\":1}}],[\"≈n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"≈n1​i=1∑n​g\",{\"1\":{\"78\":1}}],[\"≈xˉ\",{\"1\":{\"94\":1}}],[\"≈xˉ=n1​j=1∑n​xj​\",{\"1\":{\"75\":1}}],[\"假设厨师炒出一个菜的时间为3秒\",{\"1\":{\"331\":1}}],[\"假设有\",{\"1\":{\"142\":1}}],[\"假设我们具有\",{\"1\":{\"116\":1}}],[\"假设我们可以得到有关随机变量\",{\"1\":{\"110\":1}}],[\"假设我们需要求解如下方程\",{\"1\":{\"96\":1}}],[\"假设我们有了一系列\",{\"1\":{\"78\":1}}],[\"假设\",{\"1\":{\"94\":1,\"154\":1}}],[\"假设功率q=qn​\",{\"1\":{\"11\":1}}],[\"样本\",{\"1\":{\"142\":1}}],[\"样本必须是独立同分布\",{\"1\":{\"75\":1}}],[\"样本采样\",{\"1\":{\"75\":1}}],[\"蒙特卡洛方法\",{\"0\":{\"75\":1}}],[\"就好像默认其是\",{\"1\":{\"416\":1}}],[\"就好了\",{\"1\":{\"63\":1}}],[\"就明确指出了在运行的时候会出现的异常\",{\"1\":{\"399\":1}}],[\"就近原则\",{\"1\":{\"386\":1}}],[\"就表示这个是一个数组类型\",{\"1\":{\"370\":1}}],[\"就没办法了\",{\"1\":{\"364\":1}}],[\"就支持像这样编写\",{\"1\":{\"362\":1}}],[\"就保证三个线程的锁是一致的\",{\"1\":{\"312\":1}}],[\"就必须等待当前同步代码块的内容执行完毕\",{\"1\":{\"312\":1}}],[\"就必须运行两个进程\",{\"1\":{\"295\":1}}],[\"就会直接交给jvm进行处理\",{\"1\":{\"402\":1}}],[\"就会报错\",{\"1\":{\"391\":1}}],[\"就会得到不同的对象了\",{\"1\":{\"362\":1}}],[\"就会结束循环\",{\"1\":{\"324\":1}}],[\"就会出现问题\",{\"1\":{\"311\":1}}],[\"就会暂时处于休眠状态\",{\"1\":{\"299\":1}}],[\"就可能导致各自的高速缓存数据不一致\",{\"1\":{\"311\":1}}],[\"就可以使用多重异常捕获\",{\"1\":{\"402\":1}}],[\"就可以使用tostring转换为字符串了\",{\"1\":{\"380\":1}}],[\"就可以直接就创出对象\",{\"1\":{\"390\":1}}],[\"就可以表示这个是哪一个包里的类了\",{\"1\":{\"277\":1}}],[\"就可以轻松地通过键找到对应的映射值\",{\"1\":{\"212\":1}}],[\"就可以执行定义好的方法了\",{\"1\":{\"162\":1}}],[\"就可以进行一定操作\",{\"1\":{\"161\":1}}],[\"就开始按顺序执行我们给定的程序\",{\"1\":{\"299\":1}}],[\"就需要将这三种类型都进行明确指定\",{\"1\":{\"416\":1}}],[\"就需要对异常进行捕获\",{\"1\":{\"402\":1}}],[\"就需要用到java多线程框架\",{\"1\":{\"295\":1}}],[\"就需要注意了\",{\"1\":{\"277\":1}}],[\"就需要新的算法进行解决\",{\"1\":{\"96\":1}}],[\"就像使用普通类型那样\",{\"1\":{\"356\":1}}],[\"就像在这个类定义的方法一样\",{\"1\":{\"278\":1}}],[\"就像下面这样\",{\"1\":{\"274\":1}}],[\"就像你进了公司\",{\"1\":{\"224\":1}}],[\"就像我们遍历数组那样\",{\"1\":{\"188\":1}}],[\"就行了\",{\"1\":{\"224\":2,\"400\":2}}],[\"就跟我们之前的顺序表插入是一样的\",{\"1\":{\"181\":1}}],[\"就不会执行接口的默认方法\",{\"1\":{\"354\":1}}],[\"就不一定需要实现\",{\"1\":{\"353\":1}}],[\"就不是正常的\",{\"1\":{\"343\":1}}],[\"就不太可行\",{\"1\":{\"134\":1}}],[\"就不需要是\",{\"1\":{\"125\":1}}],[\"就不能确保所选择的\",{\"1\":{\"84\":1}}],[\"就直接去更新策略\",{\"1\":{\"82\":1}}],[\"就是说如果这个函数结束时有异常\",{\"1\":{\"401\":1}}],[\"就是内存溢出错误\",{\"1\":{\"399\":1}}],[\"就是将一个已实现的方法\",{\"1\":{\"393\":1}}],[\"就是将当前集合变成当前集合与给定集合的并集\",{\"1\":{\"180\":1}}],[\"就是一个已经实现了抽象方法的对象\",{\"1\":{\"390\":1}}],[\"就是创建在内部的类\",{\"1\":{\"385\":1}}],[\"就是专门用于构造字符串的\",{\"1\":{\"380\":1}}],[\"就是0\",{\"1\":{\"370\":1}}],[\"就是null\",{\"1\":{\"370\":1}}],[\"就是精确到最后一位时\",{\"1\":{\"364\":1}}],[\"就是生产者在不断的生产\",{\"1\":{\"331\":1}}],[\"就是使用的对象锁\",{\"1\":{\"312\":1}}],[\"就是使用的类锁\",{\"1\":{\"312\":1}}],[\"就是类锁\",{\"1\":{\"312\":1}}],[\"就是对象锁\",{\"1\":{\"312\":1}}],[\"就是用于分割的\",{\"1\":{\"277\":1}}],[\"就是域名\",{\"1\":{\"277\":1}}],[\"就是在运行时进行类型检查\",{\"1\":{\"237\":1}}],[\"就是为了实现这种数据结构而存在的\",{\"1\":{\"212\":1}}],[\"就是不断向后寻找结点\",{\"1\":{\"190\":1}}],[\"就是直接按下标访问\",{\"1\":{\"190\":1}}],[\"就是重复\",{\"1\":{\"181\":1}}],[\"就是求当前集合与给定集合的交集\",{\"1\":{\"180\":1}}],[\"就是求当前集合与给定集合的差集\",{\"1\":{\"180\":1}}],[\"就是看给定集合是不是当前集合的子集\",{\"1\":{\"180\":1}}],[\"就是要操作\",{\"1\":{\"161\":1}}],[\"就是\",{\"1\":{\"87\":1}}],[\"就是前面\",{\"1\":{\"78\":1}}],[\"就是进行迭代\",{\"1\":{\"71\":1}}],[\"⋮\",{\"1\":{\"70\":4}}],[\"方便后续比较\",{\"1\":{\"70\":1}}],[\"方法转换字符串\",{\"1\":{\"410\":1}}],[\"方法引用其实本质上就相当于将其他方法的实现\",{\"1\":{\"393\":1}}],[\"方法引用\",{\"0\":{\"393\":1},\"1\":{\"393\":2}}],[\"方法名\",{\"1\":{\"388\":1,\"393\":4}}],[\"方法名称\",{\"1\":{\"162\":2}}],[\"方法名称同样可以随便起\",{\"1\":{\"162\":1}}],[\"方法参数的name\",{\"1\":{\"386\":1}}],[\"方法等\",{\"1\":{\"386\":1}}],[\"方法重写\",{\"0\":{\"351\":1}}],[\"方法用于获取可拆分迭代器\",{\"1\":{\"330\":1}}],[\"方法暂时处于等待状态\",{\"1\":{\"324\":1}}],[\"方法会暂时使得此线程进入等待状态\",{\"1\":{\"318\":1}}],[\"方法后\",{\"1\":{\"313\":1,\"318\":1}}],[\"方法是让该线程从\",{\"1\":{\"318\":1}}],[\"方法是强制终止线程\",{\"1\":{\"301\":1}}],[\"方法是语句的集合\",{\"1\":{\"162\":1}}],[\"方法可以将当前线程进入休眠\",{\"1\":{\"300\":1}}],[\"方法强行停止\",{\"1\":{\"300\":1}}],[\"方法能够终止此线程\",{\"1\":{\"299\":1}}],[\"方法来使用单线程维持原本的顺序\",{\"1\":{\"330\":1}}],[\"方法来关闭它的工作线程\",{\"1\":{\"324\":1}}],[\"方法来实现线程的加入\",{\"1\":{\"305\":1}}],[\"方法来将当前资源让位给其他同优先级线程\",{\"1\":{\"304\":1}}],[\"方法来强行终止此线程\",{\"1\":{\"299\":1}}],[\"方法来让当前线程休眠一段时间\",{\"1\":{\"299\":1}}],[\"方法来运行此线程\",{\"1\":{\"297\":1}}],[\"方法得到一个字符串\",{\"1\":{\"284\":1}}],[\"方法时\",{\"1\":{\"241\":1,\"300\":1}}],[\"方法也相同\",{\"1\":{\"241\":1}}],[\"方法判断相同时\",{\"1\":{\"241\":1}}],[\"方法判断相同后\",{\"1\":{\"241\":1}}],[\"方法判断的\",{\"1\":{\"241\":1}}],[\"方法判定为\",{\"1\":{\"181\":1}}],[\"方法进行错误检查\",{\"1\":{\"284\":1}}],[\"方法进行判断的\",{\"1\":{\"241\":1}}],[\"方法进行求解\",{\"1\":{\"136\":1}}],[\"方法比较的是地址\",{\"1\":{\"241\":1}}],[\"方法内部本质上也是迭代器在处理\",{\"1\":{\"192\":1}}],[\"方法体\",{\"1\":{\"162\":1}}],[\"方法的内容\",{\"1\":{\"295\":1}}],[\"方法的返回类型\",{\"1\":{\"165\":1}}],[\"方法的重载是为某个方法提供更多种类\",{\"1\":{\"351\":1}}],[\"方法的重载\",{\"0\":{\"165\":1}}],[\"方法的进阶使用\",{\"0\":{\"163\":1}}],[\"方法的调用\",{\"1\":{\"162\":1}}],[\"方法的定义如下\",{\"1\":{\"162\":1}}],[\"方法的创建与使用\",{\"0\":{\"162\":1}}],[\"方法2\",{\"1\":{\"82\":1}}],[\"方法1\",{\"1\":{\"82\":1}}],[\"方法\",{\"0\":{\"23\":1,\"216\":1,\"217\":1,\"297\":1,\"298\":1,\"299\":1,\"318\":1,\"371\":1},\"1\":{\"77\":1,\"155\":1,\"192\":1,\"217\":1,\"223\":1,\"241\":2,\"248\":3,\"249\":1,\"284\":1,\"301\":1,\"350\":1}}],[\"之外的任何单个字符\",{\"1\":{\"381\":1}}],[\"之外\",{\"1\":{\"371\":1}}],[\"之前执行\",{\"1\":{\"313\":1}}],[\"之前使用的scanner\",{\"1\":{\"285\":1}}],[\"之前就是直接使用的\",{\"1\":{\"277\":1}}],[\"之前介绍的方法都是\",{\"1\":{\"147\":1}}],[\"之后\",{\"1\":{\"207\":1,\"265\":2}}],[\"之后进行迭代\",{\"1\":{\"70\":1}}],[\"之间存在什么关系\",{\"1\":{\"68\":1}}],[\"一开始创建时\",{\"1\":{\"380\":1}}],[\"一定是\",{\"1\":{\"416\":1}}],[\"一定要用equals\",{\"1\":{\"379\":1}}],[\"一定要注意\",{\"1\":{\"313\":1}}],[\"一定比线程t先醒来\",{\"1\":{\"301\":1}}],[\"一定可以遍历所给定的\",{\"1\":{\"84\":1}}],[\"一旦类型明确\",{\"1\":{\"416\":1}}],[\"一旦获取到\",{\"1\":{\"299\":1}}],[\"一旦被声明为静态\",{\"1\":{\"274\":1}}],[\"一直以来编写的都是单线程应用程序\",{\"1\":{\"295\":1}}],[\"一部分内容可以被暂时保存bufferedinputstream\",{\"1\":{\"265\":1}}],[\"一次性读取全部内容\",{\"1\":{\"248\":1}}],[\"一致\",{\"1\":{\"241\":1}}],[\"一致也是可以的\",{\"1\":{\"124\":1}}],[\"一会直接覆盖\",{\"1\":{\"216\":1}}],[\"一般出现错误可能jvm就无法继续正常运行了\",{\"1\":{\"399\":1}}],[\"一般他们是配合一起使用的\",{\"1\":{\"286\":1}}],[\"一般遇到以下情况时才会会加载类\",{\"1\":{\"275\":1}}],[\"一般情况\",{\"1\":{\"364\":1}}],[\"一般情况下只是为了进行一些额外的初始化工作而已\",{\"1\":{\"390\":1}}],[\"一般情况下\",{\"1\":{\"274\":1}}],[\"一般情况都是真实的数据量\",{\"1\":{\"248\":1}}],[\"一般在java\",{\"1\":{\"245\":1}}],[\"一般的\",{\"1\":{\"182\":1}}],[\"一般使用驼峰命名法最规范\",{\"1\":{\"162\":1}}],[\"一般化的推广\",{\"1\":{\"69\":1}}],[\"一些方法\",{\"1\":{\"410\":1}}],[\"一些集合是有序的\",{\"1\":{\"178\":1}}],[\"一些特性\",{\"1\":{\"155\":1}}],[\"一些细节\",{\"1\":{\"142\":1,\"156\":1}}],[\"一些状态可能很少被访问\",{\"1\":{\"134\":1}}],[\"一些问题\",{\"0\":{\"68\":1}}],[\"一个是运行时异常\",{\"1\":{\"400\":1}}],[\"一个是编译时异常\",{\"1\":{\"400\":1}}],[\"一个成员内部类\",{\"1\":{\"386\":1}}],[\"一个三行两列的数组\",{\"1\":{\"375\":1}}],[\"一个类可以附加很多个功能\",{\"1\":{\"354\":1}}],[\"一个类中可以包含多个同名的方法\",{\"1\":{\"165\":1}}],[\"一个线程处于运行状态下\",{\"1\":{\"300\":1}}],[\"一个进程可以有多个线程\",{\"1\":{\"295\":1}}],[\"一个对象改变了静态变量的值\",{\"1\":{\"274\":1}}],[\"一个新的迭代器就像上面这样\",{\"1\":{\"188\":1}}],[\"一个集合中可以存放多个集合\",{\"1\":{\"182\":1}}],[\"一个泛型类型编译之后\",{\"1\":{\"173\":1}}],[\"一个\",{\"1\":{\"103\":1}}],[\"一样才行\",{\"1\":{\"393\":1}}],[\"一样\",{\"1\":{\"82\":1}}],[\"一种则是有所偏向\",{\"1\":{\"152\":1}}],[\"一种是以优秀\",{\"1\":{\"415\":1}}],[\"一种是将所有状态视为同等重要\",{\"1\":{\"152\":1}}],[\"一种是通过迭代算法来求解\",{\"1\":{\"68\":1}}],[\"一种是可以直接通过矩阵求逆进行求解\",{\"1\":{\"68\":1}}],[\"一种迭代策略\",{\"1\":{\"47\":1}}],[\"jdk\",{\"1\":{\"415\":1}}],[\"jdk1\",{\"1\":{\"337\":1,\"340\":1}}],[\"jdk为我们准备的\",{\"1\":{\"232\":1}}],[\"jstack自动帮助我们找到了一个死锁\",{\"1\":{\"313\":1}}],[\"jstack\",{\"1\":{\"313\":1}}],[\"j++\",{\"1\":{\"312\":6}}],[\"j+1\",{\"1\":{\"66\":2,\"68\":1}}],[\"join\",{\"1\":{\"305\":1}}],[\"jvm发现任何异常都会立即终止程序运行\",{\"1\":{\"402\":1}}],[\"jvm会将一部分类\",{\"1\":{\"337\":1}}],[\"jvm\",{\"1\":{\"275\":2,\"402\":2}}],[\"jvm都c++实现中\",{\"1\":{\"182\":1}}],[\"java提供的基本类型包装类\",{\"1\":{\"361\":1}}],[\"java并不是纯面向对象的语言\",{\"1\":{\"361\":1}}],[\"java中没有字符串这种基本类型\",{\"1\":{\"378\":1}}],[\"java中的基本类型\",{\"1\":{\"361\":1}}],[\"java中也有些使用并行来进行操作的\",{\"1\":{\"330\":1}}],[\"java中所有的线程都执行完毕后\",{\"1\":{\"329\":1}}],[\"java中引入了访问权限控制\",{\"1\":{\"278\":1}}],[\"java的内存模型也是这样类似设计的\",{\"1\":{\"311\":1}}],[\"java采用的是抢占式调度方式\",{\"1\":{\"302\":1}}],[\"java程序中的每个线程并不是平均分配cpu时间的\",{\"1\":{\"302\":1}}],[\"java会默认导入java\",{\"1\":{\"277\":1}}],[\"java8开始\",{\"1\":{\"354\":1}}],[\"java8新增操作\",{\"1\":{\"214\":1}}],[\"java8新增方法\",{\"1\":{\"180\":1,\"193\":1}}],[\"java8\",{\"1\":{\"192\":1,\"214\":1}}],[\"java\",{\"0\":{\"160\":1,\"169\":1,\"176\":1,\"185\":1,\"197\":1,\"210\":1,\"227\":1,\"231\":1,\"240\":1,\"244\":1,\"258\":1,\"273\":1,\"281\":1,\"293\":1,\"308\":1,\"316\":1,\"327\":1,\"334\":1,\"337\":1,\"346\":1,\"359\":1,\"367\":1,\"384\":1,\"396\":1,\"406\":1,\"413\":1,\"425\":1},\"1\":{\"180\":2,\"181\":1,\"182\":2,\"199\":1,\"224\":1,\"228\":2,\"252\":2,\"275\":1,\"277\":1,\"296\":1,\"330\":1,\"339\":1,\"355\":1,\"356\":3,\"364\":3,\"377\":1,\"390\":2,\"409\":2,\"410\":1},\"2\":{\"168\":1,\"175\":1,\"184\":1,\"196\":1,\"209\":1,\"226\":1,\"230\":1,\"239\":1,\"243\":1,\"257\":1,\"272\":1,\"280\":1,\"292\":1,\"307\":1,\"315\":1,\"326\":1,\"333\":1,\"345\":1,\"358\":1,\"366\":1,\"383\":1,\"395\":1,\"405\":1,\"412\":1,\"419\":1}}],[\"j\",{\"1\":{\"66\":2,\"68\":1,\"78\":1,\"101\":1,\"104\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"148\":1,\"151\":1,\"155\":1,\"156\":1,\"312\":12}}],[\"步骤类似\",{\"1\":{\"79\":1}}],[\"步骤中\",{\"1\":{\"68\":2}}],[\"步来求解\",{\"1\":{\"71\":1}}],[\"步\",{\"1\":{\"63\":1}}],[\"动态规划\",{\"0\":{\"61\":1}}],[\"动作\",{\"1\":{\"19\":1,\"142\":1}}],[\"动作空间包含两个部分\",{\"1\":{\"14\":1}}],[\"动作空间\",{\"1\":{\"13\":1}}],[\"满足f\",{\"1\":{\"58\":1}}],[\"区别于贝尔曼公式\",{\"1\":{\"56\":1}}],[\"外部类初始化\",{\"1\":{\"389\":2}}],[\"外部类父类的tostring方法\",{\"1\":{\"386\":1}}],[\"外部类的tosrting方法\",{\"1\":{\"386\":1}}],[\"外部是无法访问到这个内部类的\",{\"1\":{\"386\":1}}],[\"外层\",{\"1\":{\"386\":1}}],[\"外\",{\"1\":{\"55\":1}}],[\"作为附加功能存在\",{\"1\":{\"354\":1}}],[\"作为结果\",{\"1\":{\"214\":1}}],[\"作为返回值\",{\"1\":{\"171\":1}}],[\"作为参数\",{\"1\":{\"171\":1}}],[\"作为下一步的\",{\"1\":{\"53\":1}}],[\"作用\",{\"1\":{\"26\":1}}],[\"选择对应的动作\",{\"1\":{\"84\":1}}],[\"选择移动方向和选择关联用户\",{\"1\":{\"14\":1}}],[\"选取当前状态下最大的\",{\"1\":{\"70\":2}}],[\"选取状态中最大的\",{\"1\":{\"53\":1}}],[\"唯一\",{\"1\":{\"53\":1}}],[\"贝尔曼最优公式\",{\"0\":{\"52\":1},\"1\":{\"61\":1}}],[\"贝尔曼公式\",{\"0\":{\"36\":1}}],[\"总分\",{\"1\":{\"222\":1}}],[\"总结\",{\"0\":{\"49\":1}}],[\"总用户的mos取决于无人机的发射功率\",{\"1\":{\"11\":1}}],[\"加\",{\"1\":{\"352\":1}}],[\"加权均值\",{\"1\":{\"48\":1}}],[\"加上\",{\"1\":{\"48\":1}}],[\"和匿名内部类不同\",{\"1\":{\"392\":1}}],[\"和iterator一样\",{\"1\":{\"330\":1}}],[\"和reset\",{\"1\":{\"269\":1}}],[\"和\",{\"0\":{\"199\":1,\"318\":1},\"1\":{\"48\":1,\"82\":1,\"87\":1,\"101\":1,\"105\":1,\"122\":1,\"123\":1,\"142\":2,\"241\":2,\"245\":4,\"265\":1,\"283\":1,\"364\":1,\"380\":1,\"381\":1}}],[\"和动作\",{\"1\":{\"48\":1}}],[\"和e\",{\"1\":{\"42\":1}}],[\"采取动作\",{\"1\":{\"78\":1}}],[\"采取一个指定的action可以得到的平均return\",{\"1\":{\"48\":1}}],[\"采用梯度下降\",{\"1\":{\"142\":1}}],[\"采用\",{\"1\":{\"79\":1,\"136\":1}}],[\"采用的是the\",{\"1\":{\"14\":1}}],[\"采用q\",{\"1\":{\"13\":1}}],[\"采用基于遗传算法的gak\",{\"1\":{\"13\":1}}],[\"采用mos作为用户qos衡量的标准\",{\"1\":{\"10\":1}}],[\"killed\",{\"1\":{\"324\":1}}],[\"keyset\",{\"1\":{\"213\":1,\"224\":1}}],[\"key\",{\"1\":{\"213\":4,\"215\":1,\"216\":15,\"218\":2,\"221\":3,\"222\":1,\"224\":2}}],[\"k→0∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"k→∞\",{\"1\":{\"47\":1,\"58\":1,\"104\":1}}],[\"k\",{\"1\":{\"97\":2,\"213\":3,\"215\":1,\"216\":8,\"218\":1,\"221\":3,\"222\":2}}],[\"k−1\",{\"1\":{\"94\":1}}],[\"k=2\",{\"1\":{\"94\":1}}],[\"k=1∑n​rt+k​\",{\"1\":{\"154\":1}}],[\"k=1∑n​rt+k​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"k=1\",{\"1\":{\"62\":1,\"94\":1,\"97\":1}}],[\"kth\",{\"1\":{\"79\":1}}],[\"kn​∩kn\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"kn​\",{\"1\":{\"8\":1,\"9\":2}}],[\"无参构造方法被覆盖\",{\"1\":{\"356\":1}}],[\"无限循环执行\",{\"1\":{\"322\":1}}],[\"无限循环\",{\"1\":{\"301\":1}}],[\"无论哪种方法所获取到的\",{\"1\":{\"339\":1}}],[\"无论你是调用方法\",{\"1\":{\"295\":1}}],[\"无论是否出现异常\",{\"1\":{\"402\":1}}],[\"无论是基本类型还是引用类型\",{\"1\":{\"355\":1}}],[\"无论是静态方法还是成员方法\",{\"1\":{\"171\":1}}],[\"无论是\",{\"1\":{\"92\":1}}],[\"无法继续申请内存了\",{\"1\":{\"399\":1}}],[\"无法显式定义构造函数或初始化块\",{\"1\":{\"390\":1}}],[\"无法直接定义新的属性\",{\"1\":{\"390\":1}}],[\"无法进行修改\",{\"1\":{\"378\":1}}],[\"无法表示一个非常大的数\",{\"1\":{\"364\":1}}],[\"无法使用lambda表达式简化\",{\"1\":{\"323\":1}}],[\"无法使用this关键字\",{\"1\":{\"274\":1}}],[\"无法获取成员变量的值\",{\"1\":{\"274\":1}}],[\"无法reset\",{\"1\":{\"265\":1}}],[\"无需再编写finally语句块\",{\"1\":{\"247\":1}}],[\"无关\",{\"1\":{\"152\":1}}],[\"无记忆性\",{\"1\":{\"44\":1}}],[\"无人机需要进行移动\",{\"1\":{\"14\":1}}],[\"无人机的动态移动设计\",{\"0\":{\"14\":1}}],[\"无人机的位置初始化也是随机部署的\",{\"1\":{\"13\":1}}],[\"无人机的3d部署\",{\"0\":{\"13\":1}}],[\"无人机3d部署算法\",{\"1\":{\"13\":1}}],[\"无人机\",{\"1\":{\"13\":1}}],[\"无人机n以可变高度悬停在用户上方\",{\"1\":{\"13\":1}}],[\"无人机n的高度需满足\",{\"1\":{\"9\":1}}],[\"无人机n与用户kn​在时间t的距离表示为\",{\"1\":{\"8\":1}}],[\"无人机往往有更高的los链接概率\",{\"1\":{\"9\":1}}],[\"用|隔开每种类型即可\",{\"1\":{\"402\":1}}],[\"用的就是\",{\"1\":{\"224\":1}}],[\"用了之后就不能用了\",{\"1\":{\"191\":1}}],[\"用于便捷操作数组\",{\"1\":{\"410\":1}}],[\"用于规定给定组件必须要出现多少次才能满足匹配的\",{\"1\":{\"381\":1}}],[\"用于计算超大数字\",{\"1\":{\"364\":1}}],[\"用于写入基本数据类型\",{\"1\":{\"286\":1}}],[\"用于指定当前类所处的包的\",{\"1\":{\"277\":1}}],[\"用于简化这样的写法\",{\"1\":{\"247\":1}}],[\"用于记录数组的长\",{\"1\":{\"182\":1}}],[\"用于解释\",{\"1\":{\"76\":1}}],[\"用来描述所有状态的state\",{\"1\":{\"42\":1}}],[\"用户的速度设为\",{\"1\":{\"14\":1}}],[\"用户漫游模型\",{\"1\":{\"14\":1}}],[\"用户区域划分算法\",{\"1\":{\"13\":1}}],[\"用户关联策略\",{\"1\":{\"13\":1}}],[\"用户是保持静态的\",{\"1\":{\"13\":1}}],[\"用户rkn​​在一段时间ts​内的mos总和为\",{\"1\":{\"10\":1}}],[\"求一个数的算术平方根\",{\"1\":{\"409\":1}}],[\"求均值的方法\",{\"0\":{\"94\":1}}],[\"求在策略πk​下所有的\",{\"1\":{\"79\":1}}],[\"求解梯度还是很好求的\",{\"1\":{\"142\":1}}],[\"求解给定策略\",{\"1\":{\"111\":1}}],[\"求解当前策略的\",{\"1\":{\"70\":1}}],[\"求解下一步的vk+1​\",{\"1\":{\"63\":1}}],[\"求解方法\",{\"1\":{\"58\":1}}],[\"求解\",{\"0\":{\"58\":1},\"1\":{\"49\":1}}],[\"求解bellman\",{\"1\":{\"45\":1}}],[\"求出其对应状态的\",{\"1\":{\"47\":1}}],[\"求\",{\"1\":{\"41\":1}}],[\"也支持向下转型\",{\"1\":{\"373\":1}}],[\"也支持键值同时匹配\",{\"1\":{\"223\":1}}],[\"也只能表示64bit的数据\",{\"1\":{\"364\":1}}],[\"也只有这一个静态的变量或方法\",{\"1\":{\"274\":1}}],[\"也会进行拷贝\",{\"1\":{\"355\":1}}],[\"也会等待获取cpu资源\",{\"1\":{\"299\":1}}],[\"也包含大量的并行方法\",{\"1\":{\"330\":1}}],[\"也有可能是给当前线程发送一个其他的信号\",{\"1\":{\"301\":1}}],[\"也有可能是数组存储\",{\"1\":{\"188\":1}}],[\"也能执行线程里面定义的内容\",{\"1\":{\"298\":1}}],[\"也存在大量的transient关键字\",{\"1\":{\"290\":1}}],[\"也需要考虑重写\",{\"1\":{\"241\":1}}],[\"也需要相同\",{\"1\":{\"241\":1}}],[\"也就是只包含方法的定义\",{\"1\":{\"354\":1}}],[\"也就是直接判断是否为同一个对象\",{\"1\":{\"350\":1}}],[\"也就是结束工作线程\",{\"1\":{\"324\":1}}],[\"也就是异步的\",{\"1\":{\"295\":1}}],[\"也就是同步的\",{\"1\":{\"295\":1}}],[\"也就是同时保存两个方向\",{\"1\":{\"182\":1}}],[\"也就是所在进程的内存空间\",{\"1\":{\"295\":1}}],[\"也就是我们刚刚无参\",{\"1\":{\"217\":1}}],[\"也就是我们之前讲解的链表\",{\"1\":{\"182\":1}}],[\"也就是移除对应的键值对\",{\"1\":{\"213\":1}}],[\"也就是新的键值对\",{\"1\":{\"213\":1}}],[\"也就是说依然是采用的object中的默认实现\",{\"1\":{\"371\":1}}],[\"也就是说数组的长度一旦确定\",{\"1\":{\"371\":1}}],[\"也就是说这个方法只有定义\",{\"1\":{\"353\":1}}],[\"也就是说只能同时执行一个任务\",{\"1\":{\"295\":1}}],[\"也就是说只要整个哈希表用了75\",{\"1\":{\"217\":1}}],[\"也就是说需要的时候\",{\"1\":{\"228\":1}}],[\"也就是说对于刚访问过的元素\",{\"1\":{\"218\":1}}],[\"也就是说\",{\"1\":{\"212\":1,\"224\":1,\"274\":1,\"329\":1}}],[\"也就是对遍历的每一个元素进行的操作\",{\"1\":{\"192\":1}}],[\"也可能是integer类型\",{\"1\":{\"415\":1}}],[\"也可能是小数\",{\"1\":{\"172\":1}}],[\"也可以象征性\",{\"1\":{\"379\":1}}],[\"也可以被子类访问\",{\"1\":{\"278\":1}}],[\"也可以用来将我们的类进行分类\",{\"1\":{\"277\":1}}],[\"也可以理解为是所有对象共享的内容\",{\"1\":{\"274\":1}}],[\"也可以直接写入byte\",{\"1\":{\"249\":1}}],[\"也可以直接在定义时赋值\",{\"1\":{\"166\":1}}],[\"也可以控制读取的数量\",{\"1\":{\"248\":1}}],[\"也可以精准匹配\",{\"1\":{\"223\":1}}],[\"也可以使用访问顺序\",{\"1\":{\"218\":1}}],[\"也可以当做栈来使用\",{\"1\":{\"201\":1}}],[\"也可以当做双端队列使用\",{\"1\":{\"182\":1}}],[\"也可以从后向前\",{\"1\":{\"194\":1}}],[\"也可以利用静态代码块\",{\"1\":{\"182\":1}}],[\"也可以不同\",{\"1\":{\"165\":1}}],[\"也可以采用基于\",{\"1\":{\"156\":1}}],[\"也可以是绝对路径\",{\"1\":{\"255\":1}}],[\"也可以是向量\",{\"1\":{\"101\":1}}],[\"也可以是无限长的trajectory\",{\"1\":{\"19\":1}}],[\"也是一样的\",{\"1\":{\"386\":1}}],[\"也是以对象的形式存在的\",{\"1\":{\"370\":1}}],[\"也是支持拆箱的\",{\"1\":{\"362\":1}}],[\"也是用于唤醒\",{\"1\":{\"318\":1}}],[\"也是用到了泛型\",{\"1\":{\"171\":1}}],[\"也是同样的值\",{\"1\":{\"311\":1}}],[\"也是更加推荐的做法\",{\"1\":{\"301\":1}}],[\"也是程序执行的最小单位\",{\"1\":{\"295\":1}}],[\"也是不同的两个类\",{\"1\":{\"277\":1}}],[\"也是由缓冲区处理\",{\"1\":{\"260\":1}}],[\"也是根据\",{\"1\":{\"241\":1}}],[\"也是头结点数组\",{\"1\":{\"215\":1}}],[\"也是1\",{\"1\":{\"182\":1}}],[\"也是尽量使用小写字母开头的单词\",{\"1\":{\"162\":1}}],[\"也称为\",{\"1\":{\"40\":1}}],[\"核心内容\",{\"0\":{\"37\":1}}],[\"核心思想\",{\"1\":{\"25\":1,\"76\":1}}],[\"伪代码\",{\"0\":{\"32\":1,\"64\":1,\"67\":1,\"124\":1,\"144\":1},\"1\":{\"116\":1}}],[\"中方法\",{\"1\":{\"390\":1}}],[\"中除了\",{\"1\":{\"381\":1}}],[\"中字符的所有字符\",{\"1\":{\"381\":1}}],[\"中所有的\",{\"1\":{\"381\":1}}],[\"中途是不允许转换的\",{\"1\":{\"329\":2}}],[\"中断\",{\"0\":{\"301\":1}}],[\"中使用一个类之前\",{\"1\":{\"275\":1}}],[\"中定义的\",{\"1\":{\"353\":1}}],[\"中定义的差不多\",{\"1\":{\"204\":1}}],[\"中定义要在完成之后释放的资源\",{\"1\":{\"247\":1}}],[\"中间操作\",{\"1\":{\"228\":1}}],[\"中不存在时\",{\"1\":{\"214\":1}}],[\"中不断切换\",{\"1\":{\"82\":1}}],[\"中无法添加相同的键\",{\"1\":{\"214\":1}}],[\"中存取元素\",{\"1\":{\"205\":1}}],[\"中直接继承的\",{\"1\":{\"204\":1}}],[\"中直接根据\",{\"1\":{\"115\":1}}],[\"中已经帮我们将常用的集合类型都实现好了\",{\"1\":{\"180\":1}}],[\"中取出一定数量的样本\",{\"1\":{\"142\":1}}],[\"中采用一个\",{\"1\":{\"142\":1}}],[\"中的前三个\",{\"1\":{\"381\":1}}],[\"中的所有字符\",{\"1\":{\"381\":1}}],[\"中的所有\",{\"1\":{\"381\":1}}],[\"中的两个\",{\"1\":{\"381\":1}}],[\"中的某个对象\",{\"1\":{\"205\":1}}],[\"中的\",{\"1\":{\"88\":1,\"142\":2,\"381\":3}}],[\"中第一次出现的\",{\"1\":{\"81\":1}}],[\"中求解\",{\"1\":{\"68\":1}}],[\"中涉及的\",{\"1\":{\"62\":1}}],[\"中\",{\"0\":{\"99\":1},\"1\":{\"29\":1,\"71\":1,\"77\":1,\"88\":1,\"92\":1,\"137\":1,\"142\":1,\"182\":1,\"213\":1,\"253\":1,\"311\":1,\"364\":1,\"377\":1,\"390\":1,\"391\":1,\"409\":1,\"410\":1}}],[\"重写方法可以添加\",{\"1\":{\"351\":1}}],[\"重写方法要求与父类的定义完全一致\",{\"1\":{\"351\":2}}],[\"重复字符串\",{\"1\":{\"228\":1}}],[\"重复步骤\",{\"1\":{\"13\":1}}],[\"重新修改为\",{\"1\":{\"46\":1}}],[\"重要性采样\",{\"0\":{\"30\":1},\"1\":{\"29\":1}}],[\"30\",{\"1\":{\"409\":1}}],[\"3000\",{\"1\":{\"301\":1,\"322\":2,\"331\":1}}],[\"3的结果\",{\"1\":{\"364\":1}}],[\"3\",{\"0\":{\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":2,\"41\":1,\"45\":1,\"47\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"79\":1,\"83\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":2,\"89\":2,\"98\":1,\"100\":1,\"101\":1,\"102\":1,\"105\":2,\"106\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":2,\"124\":1,\"139\":1,\"155\":1,\"197\":1,\"198\":1,\"266\":1},\"1\":{\"62\":2,\"70\":1,\"94\":1,\"97\":1,\"101\":1,\"171\":4,\"207\":2,\"214\":2,\"228\":6,\"234\":1,\"235\":1,\"236\":1,\"237\":3,\"330\":2,\"364\":1,\"374\":1,\"375\":1,\"379\":1,\"381\":1,\"409\":1,\"410\":1}}],[\"3d部署和移动问题\",{\"1\":{\"5\":1}}],[\"3d位置进行优化处理\",{\"1\":{\"5\":1}}],[\"只适合打打杂\",{\"1\":{\"329\":1}}],[\"只能对其进行继承\",{\"1\":{\"390\":1}}],[\"只能表示内部类对象\",{\"1\":{\"386\":1}}],[\"只能重新创建\",{\"1\":{\"371\":1,\"378\":1}}],[\"只能\",{\"1\":{\"364\":1}}],[\"只能内部使用\",{\"1\":{\"356\":1}}],[\"只能作为一个附属功能加在主体上\",{\"1\":{\"354\":1}}],[\"只能在构造函数进行赋值\",{\"1\":{\"352\":1}}],[\"只能得到\",{\"1\":{\"351\":1,\"353\":1}}],[\"只能使用\",{\"1\":{\"391\":1}}],[\"只能使用匿名内部类\",{\"1\":{\"323\":1}}],[\"只能使用获取内容相关的方法\",{\"1\":{\"182\":1}}],[\"只能被类本身和同包中的其他类访问\",{\"1\":{\"278\":1}}],[\"只读集合\",{\"1\":{\"236\":1}}],[\"只保留方法的定义\",{\"1\":{\"353\":1}}],[\"只保留之后的1个字符\",{\"1\":{\"265\":2}}],[\"只保留小于0的数字\",{\"1\":{\"228\":1}}],[\"只保留当前集合中在给定集合中出现的元素\",{\"1\":{\"180\":1}}],[\"只获取前10个数字\",{\"1\":{\"228\":1}}],[\"只放行前两个元素\",{\"1\":{\"228\":1}}],[\"只有抽象类中的抽象方法\",{\"1\":{\"354\":1}}],[\"只有是当前类型的对象\",{\"1\":{\"351\":1}}],[\"只有在运行的时候才知道会不会出错\",{\"1\":{\"399\":1}}],[\"只有在你使用到外部类的静态变量或方法后\",{\"1\":{\"389\":1}}],[\"只有在类不在同一个包下时才需要进行导入\",{\"1\":{\"277\":1}}],[\"只有在不存在相同键的键值对时才会存放\",{\"1\":{\"214\":1}}],[\"只有同时匹配时才移除\",{\"1\":{\"223\":1}}],[\"只有键和值都匹配时\",{\"1\":{\"223\":1}}],[\"只有可能是前面出现了相同键的情况\",{\"1\":{\"216\":1}}],[\"只有当对象作为锁时\",{\"1\":{\"318\":1}}],[\"只有当样本全部收集完才能估计\",{\"1\":{\"94\":1}}],[\"只有当所有\",{\"1\":{\"82\":1}}],[\"只有当所有东西都是确定性的\",{\"1\":{\"41\":1}}],[\"只会复制对象的地址\",{\"1\":{\"355\":1}}],[\"只会存放在线程自己的工作空间中\",{\"1\":{\"319\":1}}],[\"只会删除排在前面的第一个元素\",{\"1\":{\"182\":1}}],[\"只会调用equals方法进行判断是否为指定元素\",{\"1\":{\"182\":1}}],[\"只要重写的内容中不会抛出对应的异常我们可以直接省去\",{\"1\":{\"401\":1}}],[\"只要是实现这个接口的类\",{\"1\":{\"354\":1}}],[\"只要一个类的父类或者自身有对应方法\",{\"1\":{\"354\":1}}],[\"只要我们绕过这个阶段\",{\"1\":{\"237\":1}}],[\"只要判断成功\",{\"1\":{\"182\":1}}],[\"只要\",{\"1\":{\"181\":1}}],[\"只需要用\",{\"1\":{\"354\":1}}],[\"只需要在类名前面添加包名就行了\",{\"1\":{\"277\":1}}],[\"只需要在泛型变量的后面添加extends关键字即可指定上界\",{\"1\":{\"172\":1}}],[\"只需要将原本的流作为构造参数传入bufferedinputstream即可\",{\"1\":{\"262\":1}}],[\"只需要存储\",{\"1\":{\"224\":2}}],[\"只需要各个集合类根据自己的情况进行对应实现就行了\",{\"1\":{\"188\":1}}],[\"只需要\",{\"1\":{\"162\":1}}],[\"只需要保证\",{\"1\":{\"26\":1}}],[\"只给出了梯度的公式\",{\"1\":{\"155\":1}}],[\"只不过默认情况下没有开启断言\",{\"1\":{\"403\":1}}],[\"只不过还能更简单\",{\"1\":{\"393\":1}}],[\"只不过意义不大\",{\"1\":{\"390\":1}}],[\"只不过这个锁不用你去给\",{\"1\":{\"312\":1}}],[\"只不过它比较特殊\",{\"1\":{\"379\":1}}],[\"只不过它只是代表这个文件\",{\"1\":{\"255\":1}}],[\"只不过它是一个双向链表\",{\"1\":{\"182\":1}}],[\"只不过它是采用的链式实现\",{\"1\":{\"182\":1}}],[\"只不过现在的方向变为我们向文件里写入内容\",{\"1\":{\"249\":1}}],[\"只不过多了一些特殊的东西\",{\"1\":{\"215\":1}}],[\"只不过hashmap中没有设计头结点\",{\"1\":{\"215\":1}}],[\"只不过对这些方法有更加特殊的定义\",{\"1\":{\"204\":1}}],[\"只不过\",{\"1\":{\"204\":1}}],[\"只不过需要注意的是\",{\"1\":{\"203\":1}}],[\"只不过list也是一样的\",{\"1\":{\"200\":1}}],[\"只不过linkedlist不仅可以当做list来使用\",{\"1\":{\"182\":1}}],[\"只不过此时编译器会给出警告\",{\"1\":{\"173\":1}}],[\"只不过下界仅适用于通配符\",{\"1\":{\"172\":1}}],[\"只不过我们此时需要遍历所有的\",{\"1\":{\"79\":1}}],[\"只不过根据区域划分\",{\"1\":{\"13\":1}}],[\"只是初始化了内部类的\",{\"1\":{\"389\":1}}],[\"只是数组的地址不准修改\",{\"1\":{\"374\":1}}],[\"只是语法上为了简单\",{\"1\":{\"362\":1}}],[\"只是编程不可见\",{\"1\":{\"341\":1}}],[\"只是可以使用包装类来表示\",{\"1\":{\"340\":1}}],[\"只是反向操作\",{\"1\":{\"267\":1}}],[\"只是一个表壳\",{\"1\":{\"224\":1}}],[\"只是不用我们去写\",{\"1\":{\"166\":1}}],[\"只是进行了一步求解\",{\"1\":{\"71\":1}}],[\"只是求解各状态的\",{\"1\":{\"56\":1}}],[\"证明\",{\"1\":{\"26\":1}}],[\"θt+1​=θt​+α▽θ​lnπ\",{\"1\":{\"156\":2}}],[\"θt+1​=θt​+α▽θ​j\",{\"1\":{\"148\":1}}],[\"θt+1​​=θt​+α▽θ​j\",{\"1\":{\"156\":1}}],[\"θt​\",{\"1\":{\"148\":1,\"156\":3}}],[\"θ∈rm表示参数向量\",{\"1\":{\"148\":1}}],[\"θ\",{\"1\":{\"26\":4,\"148\":2,\"151\":1,\"155\":20,\"156\":2}}],[\"θkn​​\",{\"1\":{\"9\":1}}],[\"提升clone方法的访问权限\",{\"1\":{\"355\":1}}],[\"提升采样的效率\",{\"1\":{\"25\":1}}],[\"提前将部分内容存入内存\",{\"1\":{\"260\":1}}],[\"提供了一种特殊的语法\",{\"1\":{\"390\":1}}],[\"提供了一个支持\",{\"1\":{\"192\":1}}],[\"提供的方法进行计算\",{\"1\":{\"364\":1}}],[\"提供的迭代器生成方法\",{\"1\":{\"193\":1}}],[\"提高泛化能力\",{\"1\":{\"131\":1}}],[\"提出解决总用户mos最大化问题的三步骤\",{\"1\":{\"5\":1}}],[\"提出了一个理想的由qoe驱动的多无人机协助通信框架\",{\"1\":{\"5\":1}}],[\"而计算机网络实验这门课是以等级进行结算\",{\"1\":{\"415\":1}}],[\"而错误是致命问题\",{\"1\":{\"399\":1}}],[\"而字符串则是一系列字符的序列\",{\"1\":{\"378\":1}}],[\"而bigdecimal可以实现小数的精确计算\",{\"1\":{\"364\":1}}],[\"而bufferedinputstream虽然有着同样的方法\",{\"1\":{\"264\":1}}],[\"而实际上指向的还是原来的那个对象\",{\"1\":{\"355\":1}}],[\"而具体的实现\",{\"1\":{\"353\":1}}],[\"而方法的重写是覆盖原有的方法实现\",{\"1\":{\"351\":1}}],[\"而反射机制其实就是利用这些存放的类信息\",{\"1\":{\"338\":1}}],[\"而当货架有货物的时候\",{\"1\":{\"331\":1}}],[\"而当我们需要使用其他包中的类时\",{\"1\":{\"277\":1}}],[\"而守护线程就不一样了\",{\"1\":{\"329\":1}}],[\"而它的run方法会循环地读取队列中是否还有任务\",{\"1\":{\"324\":1}}],[\"而后者是看运气随机选择一个\",{\"1\":{\"318\":1}}],[\"而如果抽象类定义的是\",{\"1\":{\"353\":1}}],[\"而如果是普通成员方法\",{\"1\":{\"312\":1}}],[\"而如果我们希望同时执行多个任务\",{\"1\":{\"295\":1}}],[\"而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容\",{\"1\":{\"312\":1}}],[\"而其他则是无序的\",{\"1\":{\"178\":1}}],[\"而这时如果其他使用同样的锁的同步代码块也想执行内容\",{\"1\":{\"312\":1}}],[\"而这里的结点既存放键也存放值\",{\"1\":{\"215\":1}}],[\"而进行自增操作之后\",{\"1\":{\"311\":1}}],[\"而类似这样的发送通知来告知线程需要中断\",{\"1\":{\"301\":1}}],[\"而原来保存的数据只适用于之前版本的这个类\",{\"1\":{\"289\":1}}],[\"而每一个\",{\"1\":{\"275\":1}}],[\"而并非完全由readlimit确定\",{\"1\":{\"265\":1}}],[\"而缓冲流提供了缓冲机制\",{\"1\":{\"265\":1}}],[\"而缓冲流正如其名称一样\",{\"1\":{\"260\":1}}],[\"而filenotfoundexception是继承自ioexception的\",{\"1\":{\"247\":1}}],[\"而且是\",{\"1\":{\"371\":1}}],[\"而且如果是子类\",{\"1\":{\"353\":1}}],[\"而且我们不仅可以通过class关键字获取\",{\"1\":{\"340\":1}}],[\"而且执行不同进程会产生上下文切换\",{\"1\":{\"295\":1}}],[\"而且通过对对象的序列化操作\",{\"1\":{\"287\":1}}],[\"而且逻辑也更加清晰明了\",{\"1\":{\"228\":1}}],[\"而且接口中本身就已经定义了主要的方法\",{\"1\":{\"182\":1}}],[\"而内部维护的\",{\"1\":{\"224\":1}}],[\"而冲突时会得到一个被覆盖的值\",{\"1\":{\"217\":1}}],[\"而hashmap也是这样的\",{\"1\":{\"215\":1}}],[\"而我们可以通过连地址法解决这种问题\",{\"1\":{\"215\":1}}],[\"而值就是学生信息\",{\"1\":{\"213\":1}}],[\"而双端队列允许在队列的两端进行入队和出队操作\",{\"1\":{\"201\":1}}],[\"而不会直接存放到主内存中\",{\"1\":{\"319\":1}}],[\"而不太重要的任务\",{\"1\":{\"302\":1}}],[\"而不需要关心集合类是如何实现\",{\"1\":{\"190\":1}}],[\"而不是类所有的\",{\"1\":{\"386\":1}}],[\"而不是在对象创建的时候分配\",{\"1\":{\"275\":1}}],[\"而不是具体的某个对象\",{\"1\":{\"274\":1}}],[\"而不是字节\",{\"1\":{\"253\":1}}],[\"而不是直接向外部设备写入\",{\"1\":{\"260\":1}}],[\"而不是直接替换原文件内容\",{\"1\":{\"250\":1}}],[\"而不是直接开始执行内容\",{\"1\":{\"228\":1}}],[\"而不是进行等号判断\",{\"1\":{\"182\":1}}],[\"而不是对象本身的复制\",{\"1\":{\"161\":1}}],[\"而不是本体\",{\"1\":{\"161\":1}}],[\"而不是仅考虑吞吐量\",{\"1\":{\"4\":1}}],[\"而迭代器则可以将多种多样不同的集合类遍历方式进行统一\",{\"1\":{\"188\":1}}],[\"而另一些则不允许\",{\"1\":{\"178\":1}}],[\"而非\",{\"1\":{\"166\":1}}],[\"而对应的真实梯度可以用一个估计的梯度来替代\",{\"1\":{\"156\":1}}],[\"而对应的策略梯度上升算法就是对应\",{\"1\":{\"23\":1}}],[\"而是需要到使用时才会确定对应的泛型类型\",{\"1\":{\"416\":1}}],[\"而是一个参数化类型\",{\"1\":{\"343\":1}}],[\"而是通知程序做其他事情\",{\"1\":{\"301\":1}}],[\"而是通过这个类去使用\",{\"1\":{\"274\":1}}],[\"而是使用内部检查机制checkerror\",{\"1\":{\"284\":1}}],[\"而是在需要时才会去加载\",{\"1\":{\"275\":1}}],[\"而是在这之前就已经完成了\",{\"1\":{\"166\":1}}],[\"而是我们传入的fileinputstream\",{\"1\":{\"264\":1}}],[\"而是单独的一个体系\",{\"1\":{\"212\":1,\"213\":1}}],[\"而是按照数字的大小进行排列\",{\"1\":{\"207\":1}}],[\"而是\",{\"1\":{\"206\":1}}],[\"而是对应的上界\",{\"1\":{\"172\":1}}],[\"而是对应的样本\",{\"1\":{\"99\":1}}],[\"而是等\",{\"1\":{\"142\":1}}],[\"而最小值问题\",{\"1\":{\"104\":1}}],[\"而言\",{\"1\":{\"70\":1,\"241\":1}}],[\"而\",{\"1\":{\"41\":1,\"70\":1,\"71\":1}}],[\"策略梯度法\",{\"0\":{\"147\":1}}],[\"策略梯度上升\",{\"1\":{\"23\":1}}],[\"策略了\",{\"1\":{\"125\":1}}],[\"策略求解\",{\"1\":{\"70\":2}}],[\"策略提升\",{\"1\":{\"66\":1}}],[\"策略评估\",{\"1\":{\"66\":1}}],[\"策略更新\",{\"1\":{\"29\":1,\"82\":1}}],[\"策略为贪心策略\",{\"1\":{\"13\":1}}],[\"virtual\",{\"1\":{\"340\":1}}],[\"via\",{\"1\":{\"324\":1}}],[\"visit\",{\"1\":{\"81\":4,\"84\":2}}],[\"v+\",{\"1\":{\"221\":2}}],[\"v会返回null\",{\"1\":{\"221\":1}}],[\"v>>\",{\"1\":{\"213\":1}}],[\"v>\",{\"1\":{\"213\":3,\"215\":7,\"216\":4,\"217\":4,\"218\":4}}],[\"v就是值的类型\",{\"1\":{\"213\":1}}],[\"various\",{\"1\":{\"324\":1}}],[\"var2\",{\"1\":{\"187\":3}}],[\"valueof\",{\"1\":{\"356\":1,\"362\":1,\"363\":1,\"364\":4}}],[\"value++\",{\"1\":{\"311\":2,\"312\":3}}],[\"values\",{\"1\":{\"131\":2,\"213\":1,\"356\":1}}],[\"value后\",{\"1\":{\"77\":1}}],[\"value的关系\",{\"1\":{\"42\":1}}],[\"value\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1,\"58\":1,\"62\":1,\"70\":1,\"111\":1,\"115\":1,\"119\":1,\"130\":1,\"132\":1,\"150\":1,\"153\":1},\"1\":{\"23\":1,\"37\":1,\"40\":5,\"41\":3,\"42\":1,\"45\":1,\"47\":1,\"48\":10,\"49\":4,\"52\":1,\"53\":1,\"55\":1,\"56\":1,\"57\":2,\"62\":1,\"63\":3,\"66\":3,\"68\":2,\"69\":1,\"70\":12,\"71\":2,\"75\":2,\"77\":6,\"79\":6,\"81\":3,\"82\":2,\"84\":1,\"92\":2,\"111\":1,\"113\":2,\"115\":2,\"116\":1,\"119\":2,\"120\":1,\"130\":1,\"147\":1,\"148\":1,\"150\":1,\"172\":5,\"182\":2,\"213\":3,\"215\":1,\"216\":9,\"217\":2,\"218\":2,\"222\":1,\"224\":2,\"311\":2,\"312\":4,\"364\":1,\"415\":3,\"416\":8}}],[\"void类\",{\"1\":{\"364\":1}}],[\"void\",{\"1\":{\"161\":3,\"162\":2,\"164\":2,\"171\":6,\"172\":3,\"173\":1,\"180\":2,\"181\":3,\"182\":10,\"187\":2,\"189\":2,\"191\":2,\"192\":2,\"193\":1,\"194\":3,\"200\":1,\"201\":4,\"202\":1,\"203\":2,\"204\":1,\"205\":3,\"206\":1,\"207\":2,\"213\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":2,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":2,\"277\":2,\"278\":2,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"296\":1,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":7,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":4,\"323\":2,\"324\":4,\"329\":2,\"330\":2,\"331\":3,\"339\":1,\"340\":1,\"341\":1,\"343\":9,\"350\":7,\"351\":1,\"353\":2,\"354\":7,\"355\":2,\"356\":2,\"362\":4,\"363\":1,\"364\":3,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":1,\"375\":1,\"376\":4,\"377\":1,\"379\":3,\"380\":3,\"381\":2,\"386\":6,\"387\":2,\"388\":2,\"389\":3,\"390\":8,\"391\":2,\"392\":4,\"393\":5,\"401\":2,\"402\":6,\"403\":1,\"409\":2,\"410\":1,\"415\":1,\"416\":3,\"417\":2}}],[\"vˉπ0​\",{\"1\":{\"152\":1,\"155\":1}}],[\"vˉπ​=es∼d​\",{\"1\":{\"150\":1}}],[\"vˉπ​=s∈s∑​d\",{\"1\":{\"150\":1}}],[\"vˉπ​\",{\"1\":{\"150\":1,\"152\":1,\"155\":1}}],[\"v^\",{\"1\":{\"131\":1}}],[\"vt​\",{\"1\":{\"112\":3}}],[\"vt+1​\",{\"1\":{\"112\":2}}],[\"vu\",{\"1\":{\"70\":1}}],[\"v0​\",{\"1\":{\"70\":2}}],[\"vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ1​​=rπ1​​+γpπ1​​vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ0​​是通过迭代算法来求的\",{\"1\":{\"70\":1}}],[\"vπ0​​=rπ0​​+γpπ0​​vπ0​​\",{\"1\":{\"70\":1}}],[\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",{\"1\":{\"68\":1}}],[\"vπk​​=\",{\"1\":{\"68\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​policyimprovement\",{\"1\":{\"77\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​\",{\"1\":{\"66\":1,\"70\":1}}],[\"vπk​​\",{\"1\":{\"66\":1,\"68\":1,\"77\":1}}],[\"vπk​\",{\"1\":{\"66\":2,\"68\":1}}],[\"vπ​=\",{\"1\":{\"46\":1,\"47\":1}}],[\"vπ​=rπ​+γpπ​vπ​​\",{\"1\":{\"46\":1}}],[\"vπ​\",{\"1\":{\"27\":1,\"40\":2,\"42\":1,\"44\":1,\"45\":3,\"46\":4,\"48\":5,\"49\":1,\"55\":2,\"57\":1,\"75\":1,\"112\":1,\"113\":4,\"133\":1,\"134\":2,\"135\":2,\"136\":5,\"137\":1,\"138\":1,\"150\":2}}],[\"v\",{\"1\":{\"58\":5,\"61\":1,\"63\":2,\"110\":1,\"213\":7,\"215\":1,\"216\":5,\"218\":1,\"221\":3,\"222\":2,\"364\":1}}],[\"v=f\",{\"1\":{\"58\":1,\"61\":1}}],[\"v=πmax​\",{\"1\":{\"55\":1}}],[\"vk​\",{\"1\":{\"62\":1}}],[\"vk​→vπ​=\",{\"1\":{\"47\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​\",{\"1\":{\"70\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​这里的vk​并不是\",{\"1\":{\"63\":1}}],[\"vk+1​=rπ​+γpπ​vk​​\",{\"1\":{\"47\":1}}],[\"vk+1​=f\",{\"1\":{\"62\":1}}],[\"v2​\",{\"1\":{\"47\":1}}],[\"v1​=rπ1​​+γpπ1​​v0​\",{\"1\":{\"70\":1}}],[\"v1​\",{\"1\":{\"47\":1}}],[\"vector\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"very\",{\"1\":{\"10\":1}}],[\"vehicles\",{\"1\":{\"4\":1}}],[\"vehicular\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"∣\",{\"1\":{\"87\":1}}],[\"∣−1action\",{\"1\":{\"87\":1}}],[\"∣−1\",{\"1\":{\"87\":1}}],[\"∣a\",{\"1\":{\"87\":3}}],[\"∣ϵ​\",{\"1\":{\"87\":2}}],[\"∣∣≤δ\",{\"1\":{\"66\":1}}],[\"∣∣≤γ∣∣x1​−x2​∣∣\",{\"1\":{\"58\":1}}],[\"∣∣vπk+1​\",{\"1\":{\"66\":1}}],[\"∣∣f\",{\"1\":{\"58\":1}}],[\"∣st​=s\",{\"1\":{\"119\":1}}],[\"∣s=s\",{\"1\":{\"113\":2}}],[\"∣s\",{\"1\":{\"20\":1,\"41\":1,\"44\":4,\"45\":3,\"46\":1,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"113\":1,\"115\":1}}],[\"∣kn​∣为第n个簇的用户总数\",{\"1\":{\"14\":1}}],[\"会隐式修改为\",{\"1\":{\"391\":1}}],[\"会限制其子类不允许其重写所对应的成员变量\",{\"1\":{\"352\":1}}],[\"会由jvm来调用一次此方法进行资源释放之类的操作\",{\"1\":{\"350\":1}}],[\"会产生异常\",{\"1\":{\"343\":1}}],[\"会报错\",{\"1\":{\"341\":1,\"373\":1}}],[\"会提取一个类的信息生成class对象存放在内存中\",{\"1\":{\"338\":1}}],[\"会调用wait\",{\"1\":{\"324\":1}}],[\"会唤醒刚才变成等待状态的线程\",{\"1\":{\"318\":1}}],[\"会获取到当前的锁\",{\"1\":{\"312\":1}}],[\"会更加合理一些\",{\"1\":{\"301\":1}}],[\"会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作\",{\"1\":{\"301\":1}}],[\"会从运行状态回到就绪\",{\"1\":{\"300\":1}}],[\"会创建很多线程\",{\"1\":{\"295\":1}}],[\"会被唤醒\",{\"1\":{\"324\":1}}],[\"会被自动添加这个属性\",{\"1\":{\"289\":1}}],[\"会被排到最后一位\",{\"1\":{\"218\":1}}],[\"会在类刚加载的时候就分配\",{\"1\":{\"275\":1}}],[\"会使得线程的运行终止\",{\"1\":{\"300\":1}}],[\"会使得线程处于等待状态\",{\"1\":{\"300\":1}}],[\"会使得当前的读取位置回到\",{\"1\":{\"265\":1}}],[\"会使用默认的负载因子\",{\"1\":{\"215\":1}}],[\"会直接复制值给拷贝对象\",{\"1\":{\"355\":1}}],[\"会直接创建这个文件\",{\"1\":{\"249\":1}}],[\"会直接抛出异常\",{\"1\":{\"200\":1,\"236\":2}}],[\"会生成一个只有一个元素的list\",{\"1\":{\"236\":1}}],[\"会先记录每一步操作\",{\"1\":{\"228\":1}}],[\"会将子类的也捕获\",{\"1\":{\"402\":1}}],[\"会将类的信息提取出来\",{\"1\":{\"337\":1}}],[\"会将指定key的值进行重新计算\",{\"1\":{\"221\":1}}],[\"会将指定\",{\"1\":{\"221\":1}}],[\"会将其划分为n个簇\",{\"1\":{\"8\":1}}],[\"会自动转换为红黑树\",{\"1\":{\"217\":1}}],[\"会得到\",{\"1\":{\"217\":1}}],[\"会对底层哈希表数组进行扩容\",{\"1\":{\"216\":1}}],[\"会返回\",{\"1\":{\"221\":1}}],[\"会返回原本的被覆盖值\",{\"1\":{\"216\":1}}],[\"会返回null\",{\"1\":{\"200\":2}}],[\"会转变为效率更高的红黑树结构\",{\"1\":{\"215\":1}}],[\"会变成什么类型呢\",{\"1\":{\"172\":1}}],[\"会覆盖掉默认的那一个无参构造方法\",{\"1\":{\"166\":1}}],[\"会出现异常\",{\"1\":{\"161\":1}}],[\"会一直进行更新\",{\"1\":{\"142\":1}}],[\"会与环境一直交互下去\",{\"1\":{\"19\":1}}],[\"这两种分数类型都有可能出现\",{\"1\":{\"415\":1}}],[\"这两个算法是一致的\",{\"1\":{\"70\":1}}],[\"这\",{\"1\":{\"380\":2}}],[\"这同样不是se中需要学习的内容\",{\"1\":{\"350\":1}}],[\"这时我们就可以手动抛出一个异常来终止程序继续运行下去\",{\"1\":{\"401\":1}}],[\"这时我们不希望用户将泛型指定为除数字类型外的其他类型\",{\"1\":{\"172\":1}}],[\"这时并没有立即释放锁\",{\"1\":{\"318\":1}}],[\"这时其他线程可以获取到此对象的锁\",{\"1\":{\"318\":1}}],[\"这就必然存在一个中间容器\",{\"1\":{\"331\":1}}],[\"这就产生了死锁\",{\"1\":{\"313\":1}}],[\"这就是引入高速缓存引发的新问题\",{\"1\":{\"311\":1}}],[\"这玩意居然能存字符串进去\",{\"1\":{\"237\":1}}],[\"这些方法并没有被重写\",{\"1\":{\"371\":1}}],[\"这些可以省\",{\"1\":{\"354\":1}}],[\"这些都是大佬写出来的\",{\"1\":{\"217\":1}}],[\"这些映射关系被存储为键值对\",{\"1\":{\"213\":1}}],[\"这些是新的容量和扩容阈值\",{\"1\":{\"217\":1}}],[\"这些是list的特殊转换\",{\"1\":{\"181\":1}}],[\"这些是list的专用迭代器\",{\"1\":{\"181\":1}}],[\"这些是list中独特的搜索操作\",{\"1\":{\"181\":1}}],[\"这些是list中独特的位置直接访问操作\",{\"1\":{\"181\":1}}],[\"这些是比较以及哈希计算相关的操作\",{\"1\":{\"180\":1}}],[\"这些是批量执行的操作\",{\"1\":{\"180\":1}}],[\"这些是修改相关的操作\",{\"1\":{\"180\":1}}],[\"这些是查询相关的操作\",{\"1\":{\"180\":1}}],[\"这将会导致无限循环\",{\"1\":{\"193\":1}}],[\"这种形式也可以\",{\"1\":{\"416\":1}}],[\"这种局部内部类的形式\",{\"1\":{\"388\":1}}],[\"这种即可\",{\"1\":{\"354\":1}}],[\"这种动态获取信息及动态调用对象方法的功能叫java的反射机制\",{\"1\":{\"336\":1}}],[\"这种语法只支持实现了autocloseable接口的类\",{\"1\":{\"247\":2}}],[\"这种风格将要处理的元素集合看作一种流\",{\"1\":{\"228\":1}}],[\"这种集合类型比较特殊\",{\"1\":{\"204\":1}}],[\"这种迭代器因为能够双向遍历\",{\"1\":{\"194\":1}}],[\"这种迭代算法称为\",{\"1\":{\"62\":1}}],[\"这种情况是可以简化的\",{\"1\":{\"392\":1}}],[\"这种情况实际上会被优化为下面的写法\",{\"1\":{\"380\":1}}],[\"这种情况不用扩了\",{\"1\":{\"217\":1}}],[\"这种情况就是哈希冲突了\",{\"1\":{\"216\":1}}],[\"这种情况下就很容易出问题\",{\"1\":{\"330\":1}}],[\"这种情况下\",{\"1\":{\"182\":1}}],[\"这种情况下的\",{\"1\":{\"152\":1}}],[\"这种情况我们将\",{\"1\":{\"152\":1}}],[\"这是为了提升效率\",{\"1\":{\"362\":1}}],[\"这是浅拷贝\",{\"1\":{\"355\":1}}],[\"这是强制要求的\",{\"1\":{\"353\":1}}],[\"这是因为\",{\"1\":{\"362\":1}}],[\"这是因为timer内存维护了一个任务队列和一个工作线程\",{\"1\":{\"324\":1}}],[\"这是因为集合类在删除元素时\",{\"1\":{\"182\":1}}],[\"这是一个无限制的流\",{\"1\":{\"228\":1}}],[\"这是arraylist的其中一个构造方法\",{\"1\":{\"182\":1}}],[\"这是我们所求的量\",{\"1\":{\"136\":1}}],[\"这是来求解\",{\"1\":{\"79\":1}}],[\"这另一个策略会更新到最优的策略\",{\"1\":{\"123\":1}}],[\"这类算法统称为\",{\"1\":{\"82\":1}}],[\"这样我们就可以根据不同的类型进行选择了\",{\"1\":{\"416\":1}}],[\"这样我们在遍历\",{\"1\":{\"218\":1}}],[\"这样参数名称所表示的就是一个数组\",{\"1\":{\"376\":1}}],[\"这样是不能赋值的\",{\"1\":{\"373\":1}}],[\"这样就是一个实现\",{\"1\":{\"390\":1}}],[\"这样就不同\",{\"1\":{\"379\":1}}],[\"这样就不会得到同一个对象了\",{\"1\":{\"362\":1}}],[\"这样就可以与\",{\"1\":{\"111\":1}}],[\"这样不断的循环\",{\"1\":{\"331\":1}}],[\"这样不仅代码量大幅度减少\",{\"1\":{\"228\":1}}],[\"这样的数字分数\",{\"1\":{\"415\":1}}],[\"这样的异常称为运行时异常\",{\"1\":{\"399\":1}}],[\"这样的\",{\"1\":{\"373\":1}}],[\"这样的做法虽然简单粗暴\",{\"1\":{\"301\":1}}],[\"这样的写法称为装饰者模式\",{\"1\":{\"264\":1}}],[\"这样的任务称为episodic\",{\"1\":{\"19\":1}}],[\"这样会把\",{\"1\":{\"241\":1}}],[\"这样保存的元素数量就会存在限制\",{\"1\":{\"215\":1}}],[\"这样做是为了更加明确方法的具体功能\",{\"1\":{\"181\":1}}],[\"这样才能去估计相应的qπ​\",{\"1\":{\"84\":1}}],[\"这样\",{\"1\":{\"81\":1}}],[\"这一条\",{\"1\":{\"81\":1}}],[\"这个参数就是异常的原因\",{\"1\":{\"400\":1}}],[\"这个抽象类直接就定义好了\",{\"1\":{\"390\":1}}],[\"这个长度是字符的数量\",{\"1\":{\"379\":1}}],[\"这个接口中什么都没定义\",{\"1\":{\"355\":1}}],[\"这个默认方法没有任何作用\",{\"1\":{\"354\":1}}],[\"这个注解默认情况下可以省略\",{\"1\":{\"351\":1}}],[\"这个我们会在最后一章的反射中进行讲解\",{\"1\":{\"350\":1}}],[\"这个类在初始化时会对类中其他本地方法进行注册\",{\"1\":{\"350\":1}}],[\"这个工具类也经常被使用到\",{\"1\":{\"237\":1}}],[\"这个时候如果阈值大于0\",{\"1\":{\"217\":1}}],[\"这个东西决定了hashmap的扩容效果\",{\"1\":{\"215\":1}}],[\"这个就是哈希表本体了\",{\"1\":{\"215\":1}}],[\"这个是内部接口entry\",{\"1\":{\"213\":1}}],[\"这个需要我们学习了map之后再来讨论\",{\"1\":{\"205\":1}}],[\"这个同样是删除指定元素\",{\"1\":{\"204\":1}}],[\"这个迭代器也是单向的\",{\"1\":{\"201\":1}}],[\"这个迭代器是针对于list的强化版本\",{\"1\":{\"194\":1}}],[\"这个效果跟上面的写法是完全一样的\",{\"1\":{\"192\":1}}],[\"这个方法我们会在jvm篇视频教程中详细介绍\",{\"1\":{\"350\":1}}],[\"这个方法我们同样会放到多线程中进行介绍\",{\"1\":{\"204\":1}}],[\"这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量\",{\"1\":{\"248\":1}}],[\"这个方法会在多线程部分中进行介绍\",{\"1\":{\"193\":1}}],[\"这个方法会在执行排序时被调用\",{\"1\":{\"171\":1}}],[\"这个方法是在\",{\"1\":{\"192\":1}}],[\"这个方法接受一个consumer\",{\"1\":{\"192\":1}}],[\"这个生成的list是只读的\",{\"1\":{\"182\":1}}],[\"这个套娃是可以一直套下去的\",{\"1\":{\"182\":1}}],[\"这个只做了解就行\",{\"1\":{\"182\":1}}],[\"这个操作并不是一定会添加成功\",{\"1\":{\"180\":1}}],[\"这个仍然与之前一致\",{\"1\":{\"79\":1}}],[\"这个\",{\"1\":{\"78\":1}}],[\"这个便成为\",{\"1\":{\"23\":1}}],[\"这步是更新策略π\",{\"1\":{\"63\":1}}],[\"这里t可以是任何类型\",{\"1\":{\"416\":1}}],[\"这里发生的是数组越界异常\",{\"1\":{\"402\":1}}],[\"这里仅仅是对正则表达式的简单使用\",{\"1\":{\"381\":1}}],[\"这里字符串是oooo\",{\"1\":{\"381\":1}}],[\"这里进行4次加法运算\",{\"1\":{\"380\":1}}],[\"这里ceiling表示向上取整\",{\"1\":{\"364\":1}}],[\"这里会有一个integercache\",{\"1\":{\"362\":1}}],[\"这里会判断容量是否充足\",{\"1\":{\"182\":1}}],[\"这里本质上就是被自动包装成了一个integer类型的对象\",{\"1\":{\"362\":1}}],[\"这里使用javap命令对class文件进行反编译得到\",{\"1\":{\"356\":1}}],[\"这里使用的是list的迭代器在进行遍历操作\",{\"1\":{\"187\":1}}],[\"这里向上抛出一下异常\",{\"1\":{\"355\":1}}],[\"这里不讲解原理\",{\"1\":{\"330\":1}}],[\"这里变成ioexception是因为调用close\",{\"1\":{\"247\":1}}],[\"这里因为本来就是integer\",{\"1\":{\"228\":1}}],[\"这里返回m\",{\"1\":{\"221\":1}}],[\"这里返回原来的value+m\",{\"1\":{\"221\":2}}],[\"这里多了一个指向前一个结点和后一个结点的引用\",{\"1\":{\"218\":1}}],[\"这里就不解释了\",{\"1\":{\"217\":1}}],[\"这里就不列出了\",{\"1\":{\"201\":1}}],[\"这里直接将待插入结点等于原本冲突的结点\",{\"1\":{\"216\":1}}],[\"这里直接o2\",{\"1\":{\"171\":1}}],[\"这里计算完键的哈希值之后\",{\"1\":{\"216\":1}}],[\"这里用的是内部类entry在表示\",{\"1\":{\"213\":1}}],[\"这里用到了迭代器\",{\"1\":{\"180\":1}}],[\"这里做了解就行了\",{\"1\":{\"202\":1}}],[\"这里随便写的\",{\"1\":{\"193\":1}}],[\"这里我们选择使用父类的带参构造\",{\"1\":{\"400\":1}}],[\"这里我们需要特别注意一下\",{\"1\":{\"386\":1}}],[\"这里我们可以自由传入任意数量的字符串\",{\"1\":{\"376\":1}}],[\"这里我们定义一个info静态变量\",{\"1\":{\"274\":1}}],[\"这里我们连续插入两个同样的字符串\",{\"1\":{\"205\":1}}],[\"这里我们随便写一个类\",{\"1\":{\"193\":1}}],[\"这里我们接着介绍另一个列表实现类\",{\"1\":{\"182\":1}}],[\"这里只是对两个对象进行equals判断\",{\"1\":{\"182\":1}}],[\"这里同样是进行取余操作\",{\"1\":{\"216\":1}}],[\"这里同样只需要一个comparator就行了\",{\"1\":{\"181\":1}}],[\"这里同样用到了迭代器\",{\"1\":{\"181\":1}}],[\"这里传入的类型是什么\",{\"1\":{\"171\":1}}],[\"这里是求和\",{\"1\":{\"228\":1}}],[\"这里是倒着往回遍历\",{\"1\":{\"194\":1}}],[\"这里是\",{\"1\":{\"166\":1}}],[\"这里是每个无人机都有一张自己的q\",{\"1\":{\"13\":1}}],[\"这里需要特别说一下\",{\"1\":{\"373\":1}}],[\"这里需要特别注意\",{\"1\":{\"166\":1}}],[\"这里需要填写两个泛型参数\",{\"1\":{\"213\":1}}],[\"这里需要介绍一下优先级队列\",{\"1\":{\"203\":1}}],[\"这里需要通过迭代算法来精确求出\",{\"1\":{\"70\":1}}],[\"这里没有使用this\",{\"1\":{\"164\":1}}],[\"这里实际上是将方法参数的局部变量name赋值为本身\",{\"1\":{\"164\":1}}],[\"这里编写代码跟我们之前在main中是一样的\",{\"1\":{\"162\":1}}],[\"这里定义的人类具有三个属性\",{\"1\":{\"161\":1}}],[\"这里可以用不同的方法来近似\",{\"1\":{\"156\":1}}],[\"这里的name是其所依附对象的\",{\"1\":{\"386\":1}}],[\"这里的话只能使用接口中的方法\",{\"1\":{\"354\":1}}],[\"这里的\",{\"1\":{\"237\":1}}],[\"这里的i就是最终得到的下标位置了\",{\"1\":{\"216\":1}}],[\"这里的transient关键字我们会在后面i\",{\"1\":{\"182\":1}}],[\"这里的p1存放的是对象的引用\",{\"1\":{\"161\":1}}],[\"这里的a存放的是具体的某个值\",{\"1\":{\"161\":1}}],[\"这里的策略是随机性\",{\"1\":{\"155\":1}}],[\"这里的最优策略πk+1​是一个\",{\"1\":{\"63\":1}}],[\"这里在视频没有详细介绍\",{\"1\":{\"155\":1}}],[\"这里包含了一个\",{\"1\":{\"136\":1}}],[\"这里\",{\"1\":{\"66\":1}}],[\"这里有多种mobility\",{\"1\":{\"14\":1}}],[\"这里采用离散化空间坐标\",{\"1\":{\"13\":1}}],[\"通配符\",{\"1\":{\"416\":1}}],[\"通俗的讲\",{\"1\":{\"331\":1}}],[\"通常也称为\",{\"1\":{\"135\":1}}],[\"通常是具有有限步长的trajectory\",{\"1\":{\"19\":1}}],[\"通过自动装箱转换的integer对象\",{\"1\":{\"362\":1}}],[\"通过添加abstract关键字\",{\"1\":{\"353\":1}}],[\"通过实例对象获取\",{\"1\":{\"339\":1}}],[\"通过包名\",{\"1\":{\"339\":1}}],[\"通过类名获取\",{\"1\":{\"339\":1}}],[\"通过classloader将类加载\",{\"1\":{\"337\":1}}],[\"通过多线程编程\",{\"1\":{\"331\":1}}],[\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了\",{\"1\":{\"312\":1}}],[\"通过isinterrupted\",{\"1\":{\"301\":1}}],[\"通过调用sleep\",{\"1\":{\"300\":1}}],[\"通过调用start\",{\"1\":{\"297\":1}}],[\"通过创建thread对象来创建一个新的线程\",{\"1\":{\"296\":1}}],[\"通过创建泛型接口的匿名内部类\",{\"1\":{\"171\":1}}],[\"通过file对象\",{\"1\":{\"255\":2}}],[\"通过string\",{\"1\":{\"248\":1}}],[\"通过while循环来一次性读完内容\",{\"1\":{\"248\":1}}],[\"通过get方法返回得到的值\",{\"1\":{\"228\":1}}],[\"通过gak\",{\"1\":{\"5\":1}}],[\"通过观察\",{\"1\":{\"224\":1}}],[\"通过resize方法初始化底层哈希表\",{\"1\":{\"216\":1}}],[\"通过给定的键\",{\"1\":{\"213\":1}}],[\"通过给设定泛型上限\",{\"1\":{\"172\":1}}],[\"通过使用yield\",{\"1\":{\"304\":1}}],[\"通过使用setpriority方法来设定优先级\",{\"1\":{\"302\":1}}],[\"通过使用迭代器\",{\"1\":{\"188\":1}}],[\"通过使用一个函数来进行拟合\",{\"1\":{\"131\":1}}],[\"通过梯度的算法来最小化对应的损失函数\",{\"1\":{\"142\":1}}],[\"通过采取\",{\"1\":{\"85\":1}}],[\"通过迭代算法求解\",{\"1\":{\"77\":1}}],[\"通过求解\",{\"1\":{\"48\":1}}],[\"通过\",{\"1\":{\"29\":1,\"45\":1,\"47\":1,\"70\":1,\"75\":1,\"82\":1,\"241\":1}}],[\"通过k\",{\"1\":{\"13\":1}}],[\"通过优化无人机的部署和动态移动来解决总用户mos最大化问题\",{\"1\":{\"5\":1}}],[\"更新一定次数后\",{\"1\":{\"142\":1}}],[\"更新策略的步骤就是选择此时\",{\"1\":{\"77\":1}}],[\"更加高效利用\",{\"1\":{\"80\":1}}],[\"更注重长远的reward\",{\"1\":{\"19\":1}}],[\"更远视\",{\"1\":{\"19\":1}}],[\"更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署\",{\"1\":{\"4\":1}}],[\"γa∑​π\",{\"1\":{\"45\":1}}],[\"γ\",{\"1\":{\"39\":1,\"48\":1,\"110\":1}}],[\"γ接近1\",{\"1\":{\"19\":1}}],[\"γ∈\",{\"1\":{\"19\":1}}],[\"γkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"γkn​​\",{\"1\":{\"9\":1}}],[\"γk0​σ2μlos​pmax​​\",{\"1\":{\"9\":1}}],[\"指导agent在当前状态下选择哪个动作\",{\"1\":{\"19\":1}}],[\"π2\",{\"1\":{\"70\":1}}],[\"π2​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"π1​=argmaxπ​\",{\"1\":{\"70\":2}}],[\"π180​θkn​​−ζ\",{\"1\":{\"9\":1}}],[\"π0​\",{\"1\":{\"70\":1}}],[\"π0​pe​vπ0​​pi​π1​pe​vπ1​​pi​π2​pe​vπ2​​pi​\",{\"1\":{\"65\":1,\"70\":1}}],[\"πk​的\",{\"1\":{\"68\":1}}],[\"πk​\",{\"1\":{\"66\":2,\"78\":1}}],[\"πk+1​=πargmax​\",{\"1\":{\"66\":1,\"70\":2}}],[\"πk+1​=argmaxπ​\",{\"1\":{\"63\":1,\"77\":1}}],[\"πk+1​\",{\"1\":{\"63\":2,\"66\":2,\"68\":1,\"79\":2}}],[\"π∗\",{\"1\":{\"53\":2}}],[\"π\",{\"1\":{\"19\":1,\"20\":1,\"40\":1,\"41\":1,\"44\":1,\"45\":1,\"48\":1,\"53\":1,\"57\":1,\"87\":1,\"111\":1,\"112\":1,\"113\":2,\"135\":1,\"148\":2,\"152\":3,\"155\":1}}],[\"所谓的生产者消费者模型\",{\"1\":{\"331\":1}}],[\"所处的包和对应的目录是一一对应的\",{\"1\":{\"277\":1}}],[\"所生成的数据\",{\"1\":{\"112\":1}}],[\"所求出的\",{\"1\":{\"66\":1}}],[\"所有包装类如下\",{\"0\":{\"362\":1}}],[\"所有其他类都是继承它的\",{\"1\":{\"350\":1}}],[\"所有代码执行结束时\",{\"1\":{\"300\":1}}],[\"所有被标记为静态的内容\",{\"1\":{\"275\":1}}],[\"所有子文件的file对象\",{\"1\":{\"255\":1}}],[\"所有直接覆盖就行\",{\"1\":{\"216\":1}}],[\"所有的运行时异常都继承自\",{\"1\":{\"399\":1}}],[\"所有的操作都有分别对应队首和队尾的\",{\"1\":{\"201\":1}}],[\"所有的集合类最终都是实现自集合根接口的\",{\"1\":{\"180\":1}}],[\"所有可能动作的\",{\"1\":{\"48\":1}}],[\"所有状态的集合\",{\"1\":{\"19\":1}}],[\"所获得的均值\",{\"1\":{\"48\":1}}],[\"所得到的\",{\"1\":{\"40\":1}}],[\"所以只初始化了内部类\",{\"1\":{\"389\":1}}],[\"所以只要\",{\"1\":{\"241\":1}}],[\"所以相对外部来说\",{\"1\":{\"387\":1}}],[\"所以可能不满足真实需求\",{\"1\":{\"371\":1}}],[\"所以是\",{\"1\":{\"343\":1}}],[\"所以类锁本质上就是对应的类的\",{\"1\":{\"339\":1}}],[\"所以仍然需要等在运行的线程结束才会转为运行态\",{\"1\":{\"318\":1}}],[\"所以自己定义的类要自己重写\",{\"1\":{\"241\":1}}],[\"所以不维护顺序\",{\"1\":{\"214\":1}}],[\"所以它支持两种方向的遍历操作\",{\"1\":{\"194\":1}}],[\"所以这个8就是存了数组\",{\"1\":{\"182\":1}}],[\"所以添加成功返回true\",{\"1\":{\"180\":1}}],[\"所以说是可以的\",{\"1\":{\"416\":1}}],[\"所以说具体类型同样会变成\",{\"1\":{\"416\":1}}],[\"所以说静态方法中是不能用对象定义的泛型的\",{\"1\":{\"416\":1}}],[\"所以说静态内容一定会在第一个对象初始化之前完成加载\",{\"1\":{\"275\":1}}],[\"所以说并不能直接判断存储的类型到底是\",{\"1\":{\"415\":1}}],[\"所以说默认就可以直接使用\",{\"1\":{\"409\":1}}],[\"所以说只能使用\",{\"1\":{\"393\":1}}],[\"所以说里面也可以有成员变量\",{\"1\":{\"386\":1}}],[\"所以说int类型的数组时不能被object类型的数组变量接收的\",{\"1\":{\"373\":1}}],[\"所以说可以直接向上转型\",{\"1\":{\"370\":1}}],[\"所以说可以反复使用\",{\"1\":{\"194\":1}}],[\"所以说==判断为假\",{\"1\":{\"362\":1}}],[\"所以说两个不同的对象\",{\"1\":{\"362\":1}}],[\"所以说照着写就行了\",{\"1\":{\"355\":1}}],[\"所以说有些人说接口其实就是java中的多继承\",{\"1\":{\"354\":1}}],[\"所以说不能为私有\",{\"1\":{\"353\":1}}],[\"所以说判断结果为真\",{\"1\":{\"351\":1}}],[\"所以说就这样设计了\",{\"1\":{\"318\":1}}],[\"所以说没有包这个概念\",{\"1\":{\"277\":1}}],[\"所以说没必要直接用实现类\",{\"1\":{\"182\":1}}],[\"所以说我们需要明确指定\",{\"1\":{\"277\":1}}],[\"所以说我们在静态方法中\",{\"1\":{\"274\":1}}],[\"所以说我们可以添加两个一模一样的\",{\"1\":{\"182\":1}}],[\"所以说这种解决办法虽然可行\",{\"1\":{\"415\":1}}],[\"所以说这个对象当做每一个键值对的共享\",{\"1\":{\"224\":2}}],[\"所以说这里就明确了类型\",{\"1\":{\"171\":1}}],[\"所以说直接采用红黑树会更好\",{\"1\":{\"219\":1}}],[\"所以说直接就使用了\",{\"1\":{\"164\":1}}],[\"所以说返回null\",{\"1\":{\"214\":1}}],[\"所以说返回正数表示大于\",{\"1\":{\"171\":1}}],[\"所以说值是学生对象类型的\",{\"1\":{\"213\":1}}],[\"所以说最重要的还是\",{\"1\":{\"207\":1}}],[\"所以说无法维持插入元素的顺序\",{\"1\":{\"205\":1}}],[\"所以说\",{\"1\":{\"190\":1,\"224\":1,\"274\":1,\"393\":1}}],[\"所以说一定要注意\",{\"1\":{\"182\":1}}],[\"所以说哪怕是我们不去指定类型也可以直接使用\",{\"1\":{\"173\":1}}],[\"所以说依然是跟之前一样\",{\"1\":{\"172\":1}}],[\"所以说使用void\",{\"1\":{\"162\":1}}],[\"所以\",{\"1\":{\"48\":1,\"313\":1,\"370\":1}}],[\"所以状态其实共有\",{\"1\":{\"13\":1}}],[\"所以在无人机辅助通信网络中我们需要考虑qoe模型\",{\"1\":{\"10\":1}}],[\"error错误比异常更严重\",{\"1\":{\"399\":1}}],[\"euqals\",{\"1\":{\"350\":1}}],[\"euqation\",{\"1\":{\"47\":1}}],[\"eat\",{\"1\":{\"331\":1}}],[\"each\",{\"1\":{\"180\":4}}],[\"e+1\",{\"1\":{\"228\":1}}],[\"e+γvπ​\",{\"1\":{\"113\":1}}],[\"enum<com\",{\"1\":{\"356\":1}}],[\"enum表示这是一个枚举类\",{\"1\":{\"356\":1}}],[\"enum\",{\"1\":{\"356\":2}}],[\"entity\",{\"1\":{\"277\":5,\"278\":1,\"389\":3,\"390\":2}}],[\"entry\",{\"1\":{\"218\":1}}],[\"entryset\",{\"1\":{\"213\":1}}],[\"entry<k\",{\"1\":{\"213\":2,\"215\":1,\"218\":2}}],[\"english\",{\"1\":{\"222\":3}}],[\"ensurecapacityinternal\",{\"1\":{\"182\":1}}],[\"environment\",{\"1\":{\"19\":2}}],[\"emptylist\",{\"1\":{\"236\":1}}],[\"empty\",{\"1\":{\"182\":1,\"324\":1}}],[\"eliminate\",{\"1\":{\"324\":1}}],[\"else\",{\"1\":{\"182\":3,\"216\":3,\"217\":3,\"264\":1,\"401\":1}}],[\"elementdata\",{\"1\":{\"182\":9,\"190\":1}}],[\"element\",{\"1\":{\"181\":2,\"182\":2,\"200\":1}}],[\"elementwise\",{\"1\":{\"49\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"equal\",{\"1\":{\"181\":1}}],[\"equals\",{\"1\":{\"180\":1,\"182\":1,\"204\":1,\"213\":1,\"216\":2,\"241\":16,\"350\":1,\"351\":4,\"379\":1}}],[\"equation\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"45\":1,\"46\":2,\"49\":2,\"52\":1,\"58\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"e>\",{\"1\":{\"180\":2,\"181\":2,\"189\":1,\"204\":1}}],[\"ep074512\",{\"1\":{\"172\":3,\"415\":1,\"416\":2}}],[\"eplison\",{\"0\":{\"85\":1}}],[\"episodestartingfrom\",{\"1\":{\"81\":4}}],[\"episodes\",{\"1\":{\"78\":1,\"82\":2,\"84\":2}}],[\"episode\",{\"0\":{\"81\":1},\"1\":{\"19\":2,\"78\":2,\"81\":6,\"82\":1,\"84\":1,\"86\":1,\"137\":1}}],[\"efficient\",{\"1\":{\"81\":1}}],[\"evict\",{\"1\":{\"216\":2}}],[\"every\",{\"1\":{\"81\":2}}],[\"evaluation\",{\"1\":{\"23\":2,\"45\":1,\"47\":1,\"66\":1,\"70\":1,\"79\":1,\"82\":1}}],[\"es\",{\"1\":{\"381\":1}}],[\"estimation\",{\"0\":{\"99\":1,\"103\":1,\"132\":1},\"1\":{\"75\":2,\"77\":1,\"82\":1,\"92\":1}}],[\"es∼η\",{\"1\":{\"26\":1}}],[\"e\",{\"1\":{\"43\":2,\"44\":4,\"48\":2,\"75\":1,\"94\":1,\"98\":2,\"99\":3,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"180\":2,\"181\":8,\"182\":5,\"189\":1,\"190\":3,\"194\":6,\"200\":8,\"201\":19,\"204\":2,\"216\":11,\"228\":4,\"247\":6,\"248\":6,\"249\":4,\"250\":2,\"251\":2,\"253\":4,\"254\":2,\"255\":2,\"262\":2,\"265\":4,\"267\":2,\"269\":6,\"270\":2,\"283\":4,\"284\":2,\"286\":4,\"288\":2,\"290\":2,\"301\":2,\"305\":2,\"313\":4,\"318\":2,\"319\":2,\"322\":4,\"329\":4,\"331\":4,\"343\":2,\"381\":2,\"402\":8}}],[\"exception\",{\"1\":{\"399\":4,\"400\":3,\"401\":3}}],[\"excellent\",{\"1\":{\"10\":1}}],[\"exam\",{\"1\":{\"351\":2,\"353\":2}}],[\"executing\",{\"1\":{\"296\":1,\"324\":1}}],[\"exists\",{\"1\":{\"255\":1}}],[\"existence\",{\"1\":{\"58\":1}}],[\"extends\",{\"1\":{\"172\":3,\"173\":1,\"180\":2,\"181\":2,\"182\":2,\"194\":1,\"199\":1,\"200\":1,\"201\":1,\"204\":2,\"213\":2,\"215\":1,\"218\":1,\"224\":1,\"343\":1,\"353\":1,\"354\":2,\"355\":1,\"356\":1,\"400\":2,\"417\":1}}],[\"extend\",{\"1\":{\"172\":1}}],[\"expression\",{\"1\":{\"381\":1}}],[\"exploration\",{\"1\":{\"87\":1}}],[\"exploring\",{\"0\":{\"80\":1,\"83\":1,\"84\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1,\"88\":1}}],[\"exploitation\",{\"1\":{\"87\":1}}],[\"exponentially\",{\"1\":{\"58\":1}}],[\"expected\",{\"0\":{\"118\":1},\"1\":{\"40\":1}}],[\"expection\",{\"1\":{\"40\":1,\"113\":1,\"133\":1,\"136\":1}}],[\"experience\",{\"0\":{\"10\":1},\"1\":{\"4\":1,\"80\":1,\"112\":1,\"116\":1}}],[\"训练阶段\",{\"1\":{\"14\":1}}],[\"与加载的类唯一对应\",{\"1\":{\"337\":1}}],[\"与迭代器作用相同\",{\"1\":{\"180\":1}}],[\"与策略\",{\"1\":{\"152\":2}}],[\"与\",{\"0\":{\"41\":1,\"70\":1,\"114\":1},\"1\":{\"41\":1,\"68\":1,\"79\":1,\"124\":1}}],[\"与基于q\",{\"1\":{\"14\":1}}],[\"与k\",{\"1\":{\"5\":1}}],[\"基于函数表示的策略\",{\"1\":{\"148\":1}}],[\"基于函数的\",{\"1\":{\"130\":1}}],[\"基于策略\",{\"1\":{\"135\":1}}],[\"基于给定策略下\",{\"1\":{\"134\":1}}],[\"基于表格的\",{\"1\":{\"130\":1}}],[\"基于q\",{\"1\":{\"14\":1}}],[\"基本上不会用到\",{\"1\":{\"388\":1}}],[\"基本类型是不支持的\",{\"1\":{\"416\":1}}],[\"基本类型\",{\"1\":{\"378\":1}}],[\"基本类型包装类\",{\"0\":{\"361\":1}}],[\"基本类型的比较跟之前一样\",{\"1\":{\"351\":1}}],[\"基本数据类型也有对应的class对象\",{\"1\":{\"340\":1}}],[\"基本数据类型的\",{\"0\":{\"340\":1}}],[\"基本示例\",{\"1\":{\"214\":1}}],[\"基本定义是\",{\"1\":{\"388\":1}}],[\"基本定义\",{\"0\":{\"213\":1}}],[\"基本思路\",{\"0\":{\"148\":1}}],[\"基本形式\",{\"0\":{\"55\":1}}],[\"基本概念\",{\"0\":{\"17\":1,\"19\":1}}],[\"基本设置\",{\"0\":{\"8\":1}}],[\"后处于等待的线程\",{\"1\":{\"318\":1}}],[\"后面加上花括号\",{\"1\":{\"390\":1}}],[\"后面在juc中我们还会讲到乐观锁\",{\"1\":{\"312\":1}}],[\"后面的表达式判断结果为\",{\"1\":{\"403\":1}}],[\"后面的\",{\"1\":{\"277\":1}}],[\"后面的元素就被挤到后面去了\",{\"1\":{\"181\":1}}],[\"后保存的读取内容是取readlimit和bufferedinputstream类的缓冲区大小两者中的最大值\",{\"1\":{\"265\":1}}],[\"后续会根据情况扩容\",{\"1\":{\"216\":1}}],[\"后续可能是未知的\",{\"1\":{\"45\":1}}],[\"后\",{\"1\":{\"48\":1,\"82\":2,\"343\":1}}],[\"后四个方向\",{\"1\":{\"14\":1}}],[\"后退\",{\"1\":{\"13\":1}}],[\"前面说不推荐使用\",{\"1\":{\"313\":1}}],[\"前面我们已经了解如何使用泛型\",{\"1\":{\"173\":1}}],[\"前\",{\"1\":{\"14\":1}}],[\"前进\",{\"1\":{\"13\":1}}],[\"右\",{\"1\":{\"14\":1}}],[\"右转\",{\"1\":{\"13\":1}}],[\"worker\",{\"1\":{\"353\":2}}],[\"world\",{\"1\":{\"171\":1,\"379\":6}}],[\"www\",{\"1\":{\"277\":1,\"381\":1}}],[\"writeobject\",{\"1\":{\"288\":1,\"290\":1}}],[\"writeboolean\",{\"1\":{\"286\":1}}],[\"write\",{\"1\":{\"249\":3,\"250\":1,\"251\":1,\"254\":1,\"267\":1,\"270\":1,\"283\":1}}],[\"writer除了write方法外\",{\"1\":{\"254\":1}}],[\"writer\",{\"1\":{\"245\":1,\"254\":5,\"283\":2}}],[\"wt+1​=wt​+αt​n1​i=1∑n​\",{\"1\":{\"142\":1}}],[\"wt​=w\",{\"1\":{\"142\":1}}],[\"wt​\",{\"1\":{\"136\":2,\"137\":2,\"138\":4,\"139\":3,\"140\":3,\"142\":10}}],[\"waiting\",{\"1\":{\"318\":1}}],[\"wait需要捕获\",{\"1\":{\"318\":1}}],[\"wait\",{\"1\":{\"318\":6,\"324\":2,\"331\":1,\"350\":3}}],[\"was\",{\"1\":{\"264\":1}}],[\"wang\",{\"1\":{\"222\":3}}],[\"wargmin​j\",{\"1\":{\"101\":1}}],[\"walk\",{\"1\":{\"14\":2}}],[\"w−e\",{\"1\":{\"99\":1,\"110\":1}}],[\"w∗\",{\"1\":{\"98\":2}}],[\"w∈r\",{\"1\":{\"96\":1}}],[\"w\",{\"1\":{\"96\":3,\"97\":2,\"98\":3,\"99\":5,\"101\":5,\"104\":15,\"110\":4,\"131\":1,\"132\":1,\"133\":2,\"134\":3,\"135\":3,\"136\":6,\"141\":3,\"142\":21,\"381\":1}}],[\"wk−1​\",{\"1\":{\"98\":1}}],[\"wk​−\",{\"1\":{\"110\":1}}],[\"wk​−xk​\",{\"1\":{\"94\":2,\"99\":1}}],[\"wk​\",{\"1\":{\"97\":6,\"98\":1,\"99\":1,\"101\":6,\"104\":12,\"110\":1,\"136\":1}}],[\"wk​+xk​\",{\"1\":{\"94\":1}}],[\"wk​=k−11​i=1∑k−1​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​=wk​+αk​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1}}],[\"wk+1​=wk​−αk​g~​\",{\"1\":{\"110\":1}}],[\"wk+1​=wk​−αk​g​\",{\"1\":{\"99\":1,\"104\":1}}],[\"wk+1​=wk​−αk​e\",{\"1\":{\"104\":1}}],[\"wk+1​=wk​−αk​▽w​j\",{\"1\":{\"136\":1}}],[\"wk+1​=wk​−αk​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​▽w​e\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−ak​g​\",{\"1\":{\"97\":1}}],[\"wk+1​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"wk+1​=k1​i=1∑k​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​​=k1​∑i=1k​xi​​=k1​\",{\"1\":{\"94\":1}}],[\"wk+1​可以由wk​推导出来\",{\"1\":{\"94\":1}}],[\"whatsoever\",{\"1\":{\"296\":1}}],[\"while\",{\"1\":{\"180\":1,\"181\":1,\"187\":1,\"189\":1,\"191\":1,\"248\":1,\"251\":1,\"264\":1,\"301\":1,\"322\":1,\"324\":1,\"329\":2,\"331\":3}}],[\"why\",{\"0\":{\"47\":1}}],[\"where\",{\"1\":{\"46\":1,\"58\":1}}],[\"when\",{\"1\":{\"19\":1,\"296\":1,\"324\":1}}],[\"with\",{\"0\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"10\":1,\"19\":2,\"98\":1,\"247\":1,\"249\":1,\"324\":1}}],[\"wireless\",{\"1\":{\"4\":1}}],[\"如cas算法\",{\"1\":{\"312\":1}}],[\"如等待io请求\",{\"1\":{\"300\":1}}],[\"如读取和写入文本文件\",{\"1\":{\"245\":1}}],[\"如下\",{\"1\":{\"241\":1}}],[\"如梯度上升算法\",{\"1\":{\"148\":1}}],[\"如\",{\"1\":{\"79\":1,\"82\":1,\"161\":1,\"245\":2}}],[\"如何才能很好的去存可能出现的两种类型呢\",{\"1\":{\"415\":1}}],[\"如何估计\",{\"0\":{\"78\":1}}],[\"如何将\",{\"1\":{\"76\":1}}],[\"如何在没有模型\",{\"1\":{\"75\":1}}],[\"如何确保策略\",{\"1\":{\"68\":1}}],[\"如何通过\",{\"1\":{\"68\":1}}],[\"如何处理等式右边的\",{\"0\":{\"57\":1}}],[\"如何求解\",{\"0\":{\"56\":1}}],[\"如何得到最优策略\",{\"1\":{\"53\":1}}],[\"如可以在target\",{\"1\":{\"19\":1}}],[\"如果使用通配符\",{\"1\":{\"416\":1}}],[\"如果要存放基本数据类型的值\",{\"1\":{\"416\":1}}],[\"如果要让某个变量支持引用确定了任意类型的泛型\",{\"1\":{\"416\":1}}],[\"如果要往里面写入内容\",{\"1\":{\"283\":1}}],[\"如果类型不符合\",{\"1\":{\"416\":1}}],[\"如果大于10就抛出错误\",{\"1\":{\"403\":1}}],[\"如果判断失败会抛出错误\",{\"1\":{\"403\":1}}],[\"如果已经是主方法了\",{\"1\":{\"402\":1}}],[\"如果父类中的方法表明了会抛出某个异常\",{\"1\":{\"401\":1}}],[\"如果父类的方法是\",{\"1\":{\"351\":1}}],[\"如果传入了错误的参数导致程序无法正常运行\",{\"1\":{\"401\":1}}],[\"如果传入的对象为null\",{\"1\":{\"351\":1}}],[\"如果参数只有一个\",{\"1\":{\"392\":1}}],[\"如果修改了a\",{\"1\":{\"391\":1}}],[\"如果不经比较就很容易出现类型转换异常\",{\"1\":{\"415\":1}}],[\"如果不同的分支条件会出现不同的异常\",{\"1\":{\"401\":1}}],[\"如果不进行处理\",{\"1\":{\"399\":1}}],[\"如果不是\",{\"1\":{\"391\":1}}],[\"如果不加以限制\",{\"1\":{\"228\":1}}],[\"如果想用外部变量\",{\"1\":{\"391\":1}}],[\"如果想通过对象的形式去使用他们\",{\"1\":{\"361\":1}}],[\"如果直接使用加的话\",{\"1\":{\"380\":1}}],[\"如果程序中大量进行字符串的拼接似乎不太好\",{\"1\":{\"380\":1}}],[\"如果内容相同\",{\"1\":{\"379\":1}}],[\"如果同时存在其他参数\",{\"1\":{\"376\":1}}],[\"如果在范围内\",{\"1\":{\"362\":1}}],[\"如果在向下找的过程中发现已经存在相同键的键值对了\",{\"1\":{\"216\":1}}],[\"如果值相同\",{\"1\":{\"362\":1}}],[\"如果方法体中只有一个返回语句\",{\"1\":{\"392\":1}}],[\"如果方法在接口中存在默认实现\",{\"1\":{\"354\":1}}],[\"如果方法内没有变量出现重名的情况\",{\"1\":{\"164\":1}}],[\"如果抽象方法在抽象类定义的是\",{\"1\":{\"353\":1}}],[\"如果子类是一个普通类\",{\"1\":{\"417\":1}}],[\"如果子类都访问不了\",{\"1\":{\"353\":1}}],[\"如果子线程修改了也是可以\",{\"1\":{\"320\":1}}],[\"如果希望调用父类原本的方法实现\",{\"1\":{\"351\":1}}],[\"如果这种情况\",{\"1\":{\"343\":1}}],[\"如果这个位置上什么都没有\",{\"1\":{\"216\":1}}],[\"如果一个方法的参数需要的是一个接口的实现\",{\"1\":{\"392\":1}}],[\"如果一个接口中有且只有一个待实现的抽象方法\",{\"1\":{\"392\":1}}],[\"如果一个类的父类是泛型\",{\"1\":{\"343\":1}}],[\"如果一个包中有多个类\",{\"1\":{\"277\":1}}],[\"如果两个线程同时执行\",{\"1\":{\"330\":1}}],[\"如果两个对象通过\",{\"1\":{\"241\":1}}],[\"如果两个对象使用equals方法相等\",{\"1\":{\"182\":1}}],[\"如果有一个参数和返回值的话\",{\"1\":{\"392\":1}}],[\"如果有初始值\",{\"1\":{\"352\":1}}],[\"如果有任务依次执行\",{\"1\":{\"324\":1}}],[\"如果有就可以继续获取到下一个元素\",{\"1\":{\"191\":1}}],[\"如果没有其他线程唤醒自己\",{\"1\":{\"318\":1}}],[\"如果没有出现歧义\",{\"1\":{\"277\":1}}],[\"如果resume\",{\"1\":{\"313\":1}}],[\"如果仅仅是读取还好\",{\"1\":{\"311\":1}}],[\"如果存在\",{\"1\":{\"301\":1}}],[\"如果存在一个\",{\"1\":{\"84\":1}}],[\"如果我和我的朋友同时在银行取我账户里面的钱\",{\"1\":{\"311\":1}}],[\"如果我希望两个任务同时进行\",{\"1\":{\"295\":1}}],[\"如果我们要捕获的异常\",{\"1\":{\"402\":1}}],[\"如果我们要使用成员内部类\",{\"1\":{\"386\":1}}],[\"如果我们要使用一个集合类\",{\"1\":{\"182\":1}}],[\"如果我们确实不想在当前这个方法中进行处理\",{\"1\":{\"402\":1}}],[\"如果我们在方法中抛出了一个非运行时异常\",{\"1\":{\"401\":1}}],[\"如果我们想直接作为接口抽象方法的实现\",{\"1\":{\"392\":1}}],[\"如果我们想要表示一个范围内的字符\",{\"1\":{\"381\":1}}],[\"如果我们我们将其权限改为private\",{\"1\":{\"386\":1}}],[\"如果我们仅仅是想要判断两个字符串的内容是否相同\",{\"1\":{\"379\":1}}],[\"如果我们已经明确了继承的泛型的类型\",{\"1\":{\"343\":1}}],[\"如果我们并不是希望收到中断信号就是结束程序\",{\"1\":{\"301\":1}}],[\"如果我们不希望某些属性参与到序列化中进行保存\",{\"1\":{\"290\":1}}],[\"如果我们希望读取某个文件的内容\",{\"1\":{\"255\":1}}],[\"如果我们给类型变量设定了上界\",{\"1\":{\"173\":1}}],[\"如果我们强制让\",{\"1\":{\"124\":1}}],[\"如果某个方法明确指出会抛出哪些异常\",{\"1\":{\"402\":1}}],[\"如果某个类中存在静态方法或是静态变量\",{\"1\":{\"278\":1}}],[\"如果某个元素在当前集合中不存在\",{\"1\":{\"180\":1}}],[\"如果缓冲区中存在此数据\",{\"1\":{\"260\":1}}],[\"如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型\",{\"1\":{\"237\":1}}],[\"如果集合中本身没有元素\",{\"1\":{\"235\":1}}],[\"如果你学习过sql的话\",{\"1\":{\"228\":1}}],[\"如果旧的数组不为空\",{\"1\":{\"217\":1}}],[\"如果旧的容量已经大于最大限制了\",{\"1\":{\"217\":1}}],[\"如果旧容量大于0\",{\"1\":{\"217\":1}}],[\"如果超过阈值\",{\"1\":{\"216\":1}}],[\"如果e不为空\",{\"1\":{\"216\":1}}],[\"如果当前链表的长度已经很长了\",{\"1\":{\"216\":1}}],[\"如果第一个结点是treenode类型的\",{\"1\":{\"216\":1}}],[\"如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同\",{\"1\":{\"216\":1}}],[\"如果底层哈希表没初始化\",{\"1\":{\"216\":1}}],[\"如果需要使用多个的话\",{\"1\":{\"416\":1}}],[\"如果需要使用更大的数组\",{\"1\":{\"371\":1}}],[\"如果需要指定为外部的对象\",{\"1\":{\"386\":2}}],[\"如果需要完整学习正则表达式\",{\"1\":{\"381\":1}}],[\"如果需要维护顺序\",{\"1\":{\"214\":1}}],[\"如果需要再次进行遍历操作\",{\"1\":{\"191\":1}}],[\"如果出现键相同的情况\",{\"1\":{\"214\":1}}],[\"如果插入重复元素\",{\"1\":{\"204\":1}}],[\"如果插入失败\",{\"1\":{\"200\":1}}],[\"如果o2比o1大\",{\"1\":{\"171\":1}}],[\"如果是普通成员方法\",{\"1\":{\"393\":1}}],[\"如果是直接使用双引号创建的字符串\",{\"1\":{\"379\":1}}],[\"如果是基本数据类型\",{\"1\":{\"370\":1}}],[\"如果是基本类型的数组\",{\"1\":{\"416\":1}}],[\"如果是基本类型\",{\"1\":{\"161\":1}}],[\"如果是\",{\"1\":{\"318\":1}}],[\"如果是静态方法\",{\"1\":{\"312\":1}}],[\"如果是类\",{\"1\":{\"312\":1}}],[\"如果是文件夹\",{\"1\":{\"255\":1}}],[\"如果是其他类型的文件不适用\",{\"1\":{\"253\":1}}],[\"如果是多个单词\",{\"1\":{\"162\":1}}],[\"如果是引用类型\",{\"1\":{\"161\":1,\"370\":1}}],[\"如果是boolean的话\",{\"1\":{\"161\":1}}],[\"如果\",{\"1\":{\"96\":1,\"403\":1}}],[\"如果对于\",{\"1\":{\"96\":1}}],[\"如果ϵ=1\",{\"1\":{\"87\":1}}],[\"如果经过了\",{\"1\":{\"84\":1}}],[\"如果从其他状态出发\",{\"1\":{\"84\":1}}],[\"如果该\",{\"1\":{\"81\":1}}],[\"如果γ接近0\",{\"1\":{\"19\":1}}],[\"如果agent在当前时刻t所执行的动作能够提高总mos\",{\"1\":{\"13\":1}}],[\"如p\",{\"1\":{\"19\":1}}],[\"如a\",{\"1\":{\"14\":1}}],[\"需考虑用户的移动性\",{\"1\":{\"14\":1}}],[\"需要由子类来完成\",{\"1\":{\"353\":1}}],[\"需要先进行导入才可以\",{\"1\":{\"277\":1}}],[\"需要在类的最上面添加package关键字来指明当前类所处的包\",{\"1\":{\"277\":1}}],[\"需要通过关键字\",{\"1\":{\"277\":2}}],[\"需要通过采样解决\",{\"1\":{\"45\":1}}],[\"需要进行大小限制\",{\"1\":{\"182\":1}}],[\"需要接受的参数类型并不确定时\",{\"1\":{\"171\":1}}],[\"需要考虑怎样对状态进行平均\",{\"1\":{\"133\":1}}],[\"需要求解一个优化问题\",{\"1\":{\"101\":1}}],[\"需要从\",{\"1\":{\"77\":1}}],[\"需要初始化猜测的\",{\"1\":{\"70\":1}}],[\"需要初始化策略π0​\",{\"1\":{\"70\":1}}],[\"需要确定几件事\",{\"1\":{\"53\":1}}],[\"需要推导e\",{\"1\":{\"42\":1}}],[\"需要调整相应无人机的高度\",{\"1\":{\"9\":1}}],[\"需要合理选择无人机n的垂直高度hn​\",{\"1\":{\"9\":1}}],[\"∑s∈s​d\",{\"1\":{\"150\":1}}],[\"∑s∈s​dπ​\",{\"1\":{\"135\":1}}],[\"∑k=1∞​ak2​=∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak2​<∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"∑kn​=1kn​​pkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"∑i=1k−1​xi​+xk​\",{\"1\":{\"94\":1}}],[\"∑​pπ​\",{\"1\":{\"46\":1}}],[\"∑​p\",{\"1\":{\"44\":2,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2,\"77\":1,\"113\":1}}],[\"∑​vπ​\",{\"1\":{\"44\":2}}],[\"∑​e\",{\"1\":{\"44\":3}}],[\"∑n=1n​∣kn​∣是总用户数\",{\"1\":{\"14\":1}}],[\"则等价于\",{\"1\":{\"381\":1}}],[\"则表示只能赋一次值\",{\"1\":{\"352\":1}}],[\"则表示永久等待\",{\"1\":{\"318\":1}}],[\"则主动唤醒自己\",{\"1\":{\"318\":1}}],[\"则是让处于\",{\"1\":{\"318\":1}}],[\"则是对多个\",{\"1\":{\"41\":1}}],[\"则可以先让出一部分资源\",{\"1\":{\"302\":1}}],[\"则必须实现serializable接口才能被序列化\",{\"1\":{\"288\":1}}],[\"则之后的内容不会被保留\",{\"1\":{\"265\":1}}],[\"则无需再去请求外部设备\",{\"1\":{\"260\":1}}],[\"则无人机将获得正奖励\",{\"1\":{\"13\":1}}],[\"则只是进行一次带入求解\",{\"1\":{\"70\":1}}],[\"则总动作空间的大小为7+2n∑n=1n​∣kn​∣会导致动作空间过大\",{\"1\":{\"14\":1}}],[\"则用户的关联动作数为2n∑n=1n​∣kn​∣\",{\"1\":{\"14\":1}}],[\"设置初始值\",{\"1\":{\"320\":1}}],[\"设置为守护线程\",{\"1\":{\"329\":2}}],[\"设置为\",{\"1\":{\"27\":1}}],[\"设定上界为number\",{\"1\":{\"173\":1}}],[\"设定类型参数上界\",{\"1\":{\"172\":1}}],[\"设\",{\"1\":{\"135\":1,\"137\":1}}],[\"设无人机总数为n\",{\"1\":{\"14\":1}}],[\"设计一种基于\",{\"1\":{\"5\":2}}],[\"对\",{\"1\":{\"224\":1}}],[\"对出队顺序进行调整\",{\"1\":{\"203\":1}}],[\"对剩下的元素进行自定义遍历操作\",{\"1\":{\"189\":1}}],[\"对当前集合按照给定的规则进行排序操作\",{\"1\":{\"181\":1}}],[\"对其进行修改\",{\"1\":{\"166\":1}}],[\"对象与多态\",{\"0\":{\"342\":1}}],[\"对象始终是相同的\",{\"1\":{\"339\":1}}],[\"对象序列化\",{\"0\":{\"288\":1}}],[\"对象流\",{\"0\":{\"287\":1}}],[\"对象再多\",{\"1\":{\"274\":1}}],[\"对象在创建之后\",{\"1\":{\"166\":1}}],[\"对象创建成功之后\",{\"1\":{\"161\":1}}],[\"对象实例的创建\",{\"1\":{\"161\":1}}],[\"对象\",{\"0\":{\"340\":1,\"341\":1,\"386\":1},\"1\":{\"161\":1,\"312\":1,\"339\":1,\"384\":1,\"393\":2}}],[\"对应关系如下表\",{\"1\":{\"362\":1}}],[\"对应地\",{\"1\":{\"343\":1}}],[\"对应多个文件夹\",{\"1\":{\"277\":1}}],[\"对应缓冲流的close源码\",{\"1\":{\"264\":1}}],[\"对应目标函数的真实梯度是\",{\"1\":{\"136\":1}}],[\"对应收敛性证明\",{\"1\":{\"104\":1}}],[\"对应一个向量\",{\"1\":{\"58\":1}}],[\"对应策略表示为\",{\"1\":{\"57\":1}}],[\"对应的class\",{\"1\":{\"343\":1}}],[\"对应的vk+1​\",{\"1\":{\"63\":1}}],[\"对应的动作\",{\"1\":{\"57\":1}}],[\"对应的\",{\"1\":{\"42\":2,\"46\":1,\"66\":1,\"94\":1,\"116\":1,\"343\":1}}],[\"对应的discounted\",{\"1\":{\"39\":1}}],[\"对应算法\",{\"0\":{\"28\":1}}],[\"对应\",{\"1\":{\"23\":2,\"154\":1,\"212\":1}}],[\"对应状态中所有可选择的动作集合\",{\"1\":{\"19\":1}}],[\"对应s就是uav的部署位置\",{\"1\":{\"13\":1}}],[\"对于使用者来说\",{\"1\":{\"415\":1}}],[\"对于已经实现的方法\",{\"1\":{\"392\":1}}],[\"对于这种成员内部类\",{\"1\":{\"386\":1}}],[\"对于这个问题\",{\"1\":{\"101\":1}}],[\"对于普通字符来说\",{\"1\":{\"381\":1}}],[\"对于变量来说\",{\"1\":{\"380\":1}}],[\"对于基本类型的数组来说\",{\"1\":{\"373\":1}}],[\"对于需要精确计算的场景\",{\"1\":{\"364\":1}}],[\"对于非常大的整数计算\",{\"1\":{\"364\":1}}],[\"对于引用类型\",{\"1\":{\"355\":1}}],[\"对于类中基本数据类型\",{\"1\":{\"355\":1}}],[\"对于类型变量来说是不支持的\",{\"1\":{\"172\":2}}],[\"对于人类的不同子类\",{\"1\":{\"354\":1}}],[\"对于成员方法\",{\"1\":{\"352\":1}}],[\"对于成员变量\",{\"1\":{\"352\":1}}],[\"对于任意一个对象\",{\"1\":{\"336\":1}}],[\"对于任意一个类\",{\"1\":{\"336\":1}}],[\"对于泛型类test\",{\"1\":{\"173\":1}}],[\"对于对象而言\",{\"1\":{\"161\":1}}],[\"对于策略\",{\"1\":{\"113\":1}}],[\"对于观测值g​\",{\"1\":{\"104\":1}}],[\"对于函数\",{\"1\":{\"101\":1}}],[\"对于一个\",{\"1\":{\"81\":1}}],[\"对于贝尔曼最优公式而言\",{\"1\":{\"55\":1,\"56\":1}}],[\"对于\",{\"1\":{\"48\":1,\"70\":3,\"77\":2,\"79\":1,\"81\":1,\"88\":1,\"130\":1,\"142\":1,\"241\":3,\"391\":1}}],[\"对于所有状态s\",{\"1\":{\"46\":1}}],[\"对于不同的策略\",{\"1\":{\"40\":1}}],[\"对于每个\",{\"1\":{\"81\":1}}],[\"对于每个智能体\",{\"1\":{\"13\":1}}],[\"对于每一个状态\",{\"1\":{\"19\":1}}],[\"对于动作空间而言\",{\"1\":{\"14\":1}}],[\"对于用户kn​存在特定的信噪比目标γkn​​\",{\"1\":{\"9\":1}}],[\"对于用户kn​∈kn​\",{\"1\":{\"8\":1}}],[\"对于无人机的总发射功率也均匀地分配给每个用户\",{\"1\":{\"9\":1}}],[\"对于无人机n\",{\"1\":{\"8\":1,\"9\":1}}],[\"对于指定区域\",{\"1\":{\"8\":1}}],[\"值还是可以修改\",{\"1\":{\"374\":1}}],[\"值也相同\",{\"1\":{\"241\":1}}],[\"值为0\",{\"1\":{\"215\":1}}],[\"值函数近似\",{\"0\":{\"130\":1}}],[\"值迭代和策略迭代\",{\"0\":{\"61\":1}}],[\"值的估计通过一个网络来进行描述\",{\"1\":{\"23\":1}}],[\"值\",{\"1\":{\"13\":1}}],[\"最近的是参数\",{\"1\":{\"386\":1}}],[\"最少匹配\",{\"1\":{\"381\":1}}],[\"最高优先级\",{\"1\":{\"302\":1}}],[\"最低优先级\",{\"1\":{\"302\":1}}],[\"最方便的是\",{\"1\":{\"284\":1}}],[\"最好是一个域名的格式\",{\"1\":{\"277\":1}}],[\"最好的\",{\"0\":{\"27\":1}}],[\"最小\",{\"0\":{\"233\":1}}],[\"最大\",{\"0\":{\"233\":1}}],[\"最大的不同是它支持基本数据类型的直接读取\",{\"1\":{\"286\":1}}],[\"最大的\",{\"1\":{\"77\":1,\"79\":1}}],[\"最大的q\",{\"1\":{\"13\":1}}],[\"最后再提一下\",{\"1\":{\"401\":1}}],[\"最后面分号可以不打\",{\"1\":{\"356\":1}}],[\"最后也得不到我们想要的结果\",{\"1\":{\"312\":1}}],[\"最后由\",{\"1\":{\"228\":1}}],[\"最后哈希表就长这样了\",{\"1\":{\"215\":1}}],[\"最后得到的结果并不是我们插入顺序\",{\"1\":{\"207\":1}}],[\"最后实际上只有一个成功插入了\",{\"1\":{\"205\":1}}],[\"最优的策略\",{\"1\":{\"148\":1}}],[\"最优策略\",{\"0\":{\"57\":1}}],[\"最优策略是\",{\"1\":{\"53\":1}}],[\"最优策略是否唯一\",{\"1\":{\"53\":1}}],[\"最优策略是否存在\",{\"1\":{\"53\":1}}],[\"最优策略的定义\",{\"1\":{\"53\":1}}],[\"最接近真实的vπ​\",{\"1\":{\"132\":1}}],[\"最简单的示例算法\",{\"1\":{\"76\":1}}],[\"最终到\",{\"1\":{\"402\":1}}],[\"最终操作\",{\"1\":{\"228\":1}}],[\"最终会达到一个平稳的状态\",{\"1\":{\"135\":1}}],[\"最终优化的策略\",{\"1\":{\"121\":1}}],[\"最终可以证明\",{\"1\":{\"47\":1}}],[\"最终输出结果\",{\"1\":{\"13\":1}}],[\"最终输出的结果\",{\"1\":{\"13\":1}}],[\"当子类实现此接口时\",{\"1\":{\"417\":1}}],[\"当代码可能出现多种类型的异常时\",{\"1\":{\"402\":1}}],[\"当程序没有按照我们理想的样子运行而出现异常时\",{\"1\":{\"402\":1}}],[\"当程序在运行时\",{\"1\":{\"173\":1}}],[\"当别人调用我们的方法时\",{\"1\":{\"401\":1}}],[\"当你使用内部类静态方法\",{\"1\":{\"389\":1}}],[\"当前数组长度为\",{\"1\":{\"371\":1}}],[\"当前类\",{\"1\":{\"278\":1}}],[\"当对象被判定为已经不再使用的\",{\"1\":{\"350\":1}}],[\"当对象不同时\",{\"1\":{\"312\":1}}],[\"当integer不是number的子类时\",{\"1\":{\"343\":1}}],[\"当货架空的时候\",{\"1\":{\"331\":1}}],[\"当其他所有的非守护线程结束之后\",{\"1\":{\"329\":1}}],[\"当其他线程调用对象的notify\",{\"1\":{\"318\":1}}],[\"当被唤醒后都没有任务时\",{\"1\":{\"324\":1}}],[\"当有新的任务时\",{\"1\":{\"324\":1}}],[\"当队列为空同时没有被关闭时\",{\"1\":{\"324\":1}}],[\"当一个线程进入到同步代码块时\",{\"1\":{\"312\":1}}],[\"当两个线程同时读取value的时候\",{\"1\":{\"311\":1}}],[\"当线程出现异常或错误\",{\"1\":{\"300\":1}}],[\"当线程进入休眠\",{\"1\":{\"300\":1}}],[\"当等待状态结束后会回到就绪状态\",{\"1\":{\"300\":1}}],[\"当cpu给予的运行时间结束时\",{\"1\":{\"300\":1}}],[\"当需要等待外部io操作\",{\"1\":{\"299\":1}}],[\"当出现多个进程需要同时运行时\",{\"1\":{\"295\":1}}],[\"当读取的内容数量超过\",{\"1\":{\"265\":1}}],[\"当调用\",{\"1\":{\"265\":2}}],[\"当向外部设备写入数据时\",{\"1\":{\"260\":1}}],[\"当整个链式调用完成后\",{\"1\":{\"228\":1}}],[\"当遇到大量的复杂操作时\",{\"1\":{\"228\":1}}],[\"当key存在时存在则计算并赋予新的值\",{\"1\":{\"221\":1}}],[\"当链表长度到达一定限制时\",{\"1\":{\"215\":1}}],[\"当我们字符串编辑完成之后\",{\"1\":{\"380\":1}}],[\"当我们同时去操作一个共享变量时\",{\"1\":{\"311\":1}}],[\"当我们希望一个线程等待另一个线程执行完成后再继续进行\",{\"1\":{\"305\":1}}],[\"当我们使用同一个包中的类时\",{\"1\":{\"277\":1}}],[\"当我们创建对象时\",{\"1\":{\"215\":1}}],[\"当我们在使用变量时\",{\"1\":{\"172\":1}}],[\"当不存在对应的键值对时\",{\"1\":{\"214\":1}}],[\"当\",{\"1\":{\"214\":1,\"221\":1}}],[\"当做流水线处理\",{\"1\":{\"228\":1}}],[\"当做队列使用\",{\"1\":{\"200\":1}}],[\"当做一个队列来使用\",{\"1\":{\"200\":1}}],[\"当某个方法\",{\"1\":{\"171\":1}}],[\"当然前提是方法定义\",{\"1\":{\"393\":1}}],[\"当然在磁盘io下\",{\"1\":{\"248\":1}}],[\"当然计算哈希还是使用键\",{\"1\":{\"215\":1}}],[\"当然\",{\"1\":{\"164\":1,\"166\":3,\"171\":1,\"173\":1,\"182\":1,\"202\":1,\"207\":1,\"218\":1,\"269\":1,\"277\":2,\"353\":1,\"381\":1,\"390\":1,\"402\":1,\"416\":1}}],[\"当策略是以函数的形式存在时\",{\"1\":{\"148\":1}}],[\"当策略是以表格的形式保存时\",{\"1\":{\"148\":1}}],[\"当a为静止时\",{\"1\":{\"13\":1}}],[\"当执行动作at​时\",{\"1\":{\"13\":1}}],[\"发现对于\",{\"1\":{\"353\":1}}],[\"发现在该位置静止是最优的\",{\"1\":{\"13\":1}}],[\"发送端的时间\",{\"1\":{\"10\":1}}],[\"不只是类\",{\"1\":{\"417\":1}}],[\"不然就无法通过编译\",{\"1\":{\"402\":1}}],[\"不见当年倒茶人\",{\"1\":{\"393\":1}}],[\"不包括换行\",{\"1\":{\"381\":1}}],[\"不是静态方法\",{\"1\":{\"393\":1}}],[\"不是基本类型\",{\"1\":{\"362\":1}}],[\"不是接口\",{\"1\":{\"323\":1}}],[\"不需要声明访问权限\",{\"1\":{\"388\":1}}],[\"不需要依附任何对象\",{\"1\":{\"387\":1}}],[\"不需要\",{\"1\":{\"362\":1,\"387\":1}}],[\"不需要和用户交互\",{\"1\":{\"329\":1}}],[\"不会调用外部类的\",{\"1\":{\"389\":1}}],[\"不会终止\",{\"0\":{\"324\":1}}],[\"不会影响所求的梯度\",{\"1\":{\"26\":1}}],[\"不要使用\",{\"1\":{\"379\":1}}],[\"不要出现这种死锁的情况\",{\"1\":{\"313\":1}}],[\"不要跟之前的迭代器接口搞混了\",{\"1\":{\"193\":1}}],[\"不过没必要\",{\"1\":{\"379\":1}}],[\"不过可以省略\",{\"1\":{\"354\":1}}],[\"不过如果子类也是抽象类\",{\"1\":{\"353\":1}}],[\"不过默认是向控制台打印\",{\"1\":{\"284\":1}}],[\"不过上面写法比较繁琐\",{\"1\":{\"247\":1}}],[\"不涉及字符编码转换\",{\"1\":{\"245\":1}}],[\"不支持抽象类\",{\"1\":{\"392\":1}}],[\"不支持\",{\"1\":{\"236\":2}}],[\"不支持随机访问\",{\"1\":{\"204\":1}}],[\"不存在key时\",{\"1\":{\"221\":1}}],[\"不存在\",{\"1\":{\"221\":1}}],[\"不允许\",{\"1\":{\"374\":1}}],[\"不允许进行修改\",{\"1\":{\"371\":1}}],[\"不允许通过下标访问\",{\"1\":{\"204\":1}}],[\"不允许出现重复元素\",{\"1\":{\"204\":1}}],[\"不用多说了吧\",{\"1\":{\"201\":3}}],[\"不用进行求导\",{\"1\":{\"142\":1}}],[\"不进行出队操作\",{\"1\":{\"200\":1}}],[\"不仅仅只运行一个主线程\",{\"1\":{\"295\":1}}],[\"不仅能从前向后\",{\"1\":{\"194\":1}}],[\"不仅保存指向下一个结点的引用\",{\"1\":{\"182\":1}}],[\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组\",{\"1\":{\"416\":1}}],[\"不能匹配\",{\"1\":{\"381\":2}}],[\"不能随便进行修改\",{\"1\":{\"371\":1}}],[\"不能\",{\"1\":{\"364\":1}}],[\"不能直接通过\",{\"1\":{\"390\":1}}],[\"不能直接创建对象\",{\"1\":{\"354\":1}}],[\"不能直接用10\",{\"1\":{\"182\":1}}],[\"不能使用不同的变量进行接收\",{\"1\":{\"416\":1}}],[\"不能使用默认\",{\"1\":{\"354\":1}}],[\"不能使用==\",{\"1\":{\"351\":1}}],[\"不能是\",{\"1\":{\"353\":1}}],[\"不能认为每一步是直接依次执行的\",{\"1\":{\"228\":1}}],[\"不能进行修改操作\",{\"1\":{\"182\":1}}],[\"不能用同一个q\",{\"1\":{\"13\":1}}],[\"不充足需要扩容\",{\"1\":{\"182\":1}}],[\"不指定具体类型也是可以的\",{\"1\":{\"173\":1}}],[\"不得是其他类型\",{\"1\":{\"172\":1}}],[\"不同线程向threadlocal存放数据\",{\"1\":{\"319\":1}}],[\"不同包下的类\",{\"1\":{\"278\":1}}],[\"不同包下的子类\",{\"1\":{\"278\":1}}],[\"不同类的重名问题\",{\"1\":{\"277\":1}}],[\"不同集合类\",{\"0\":{\"190\":1}}],[\"不同之处\",{\"1\":{\"179\":1}}],[\"不同的线程访问到threadlocal对象时\",{\"1\":{\"319\":1}}],[\"不同的对象代表不同的对象锁\",{\"1\":{\"312\":1}}],[\"不同的访问权限\",{\"1\":{\"278\":1}}],[\"不同的文本文件可能会有不同的编码类型\",{\"1\":{\"254\":1}}],[\"不同的实现有着不同的遍历方式\",{\"1\":{\"188\":1}}],[\"不同的集合类具体实现可能会对插入的元素有要求\",{\"1\":{\"180\":1}}],[\"不同的集合有着不同的性质\",{\"1\":{\"178\":1}}],[\"不同的无人机agent的q\",{\"1\":{\"13\":1}}],[\"不同对象的属性是分开独立存放的\",{\"1\":{\"161\":1}}],[\"不太一样\",{\"1\":{\"144\":1}}],[\"不记录\",{\"1\":{\"81\":1}}],[\"不动点x∗是唯一的\",{\"1\":{\"58\":1}}],[\"不常用\",{\"1\":{\"47\":1}}],[\"还没学异常\",{\"1\":{\"355\":1}}],[\"还有一种就是\",{\"1\":{\"415\":1}}],[\"还有一种set叫做treeset\",{\"1\":{\"207\":1}}],[\"还有一个append方法\",{\"1\":{\"254\":1}}],[\"还有其他的实现类\",{\"1\":{\"202\":1}}],[\"还保存指向上一个结点的引用\",{\"1\":{\"182\":1}}],[\"还可以获取文件夹内部的文件列表等内容\",{\"1\":{\"255\":1}}],[\"还可以当做其他的数据结构使用\",{\"1\":{\"199\":1}}],[\"还可以定义一些方法来描述同一类的行为\",{\"1\":{\"162\":1}}],[\"还可以估计q\",{\"1\":{\"81\":1}}],[\"还需要判断\",{\"1\":{\"241\":1}}],[\"还需要求解最优策略π\",{\"1\":{\"55\":1}}],[\"还需要考虑所有用户的2d位置\",{\"1\":{\"14\":1}}],[\"还是进行计算\",{\"1\":{\"295\":1}}],[\"还是很方便的\",{\"1\":{\"200\":1}}],[\"还是\",{\"1\":{\"53\":1,\"75\":1,\"92\":1,\"415\":1}}],[\"还是同一张q\",{\"1\":{\"13\":1}}],[\"还与los的概率有关\",{\"1\":{\"13\":1}}],[\"但并不是最好的方案\",{\"1\":{\"415\":1}}],[\"但并不是这个文件本身\",{\"1\":{\"255\":1}}],[\"但它继承自一个现有的类或实现了一个接口\",{\"1\":{\"390\":1}}],[\"但它是为了并行执行而设计的\",{\"1\":{\"330\":1}}],[\"但类名必须与接口一致\",{\"1\":{\"390\":1}}],[\"但我们可以在方法中使用匿名内部类\",{\"1\":{\"390\":1}}],[\"但能匹配\",{\"1\":{\"381\":1}}],[\"但能否保证其精确度\",{\"1\":{\"101\":1}}],[\"但不一定会导致致命的问题\",{\"1\":{\"399\":1}}],[\"但不能匹配\",{\"1\":{\"381\":1}}],[\"但不推荐\",{\"1\":{\"370\":1}}],[\"但不支持\",{\"1\":{\"364\":1}}],[\"但对象中的属性都是同一个地址\",{\"1\":{\"355\":1}}],[\"但对于\",{\"1\":{\"142\":1}}],[\"但包装类的class和基本类的class显然是不同的\",{\"1\":{\"340\":1}}],[\"但效果是一致的\",{\"1\":{\"254\":1}}],[\"但集合可以有不同种类的元素\",{\"1\":{\"179\":1}}],[\"但集合只能存放对象\",{\"1\":{\"179\":1}}],[\"但还是先初始化内部类\",{\"1\":{\"389\":1}}],[\"但还未复制\",{\"1\":{\"166\":1}}],[\"但还存在\",{\"1\":{\"156\":1}}],[\"但是注意\",{\"1\":{\"416\":1}}],[\"但是注意两个线程必须使用同一把锁\",{\"1\":{\"312\":1}}],[\"但是一旦确定\",{\"1\":{\"416\":1}}],[\"但是编译不会报错\",{\"1\":{\"415\":1}}],[\"但是编程不可见\",{\"1\":{\"370\":1}}],[\"但是object类型在编译阶段并不具有良好的类型判断能力\",{\"1\":{\"415\":1}}],[\"但是outputstream又只支持byte类型\",{\"1\":{\"283\":1}}],[\"但是成绩分为两种\",{\"1\":{\"415\":1}}],[\"但是成绩依然可能是整数\",{\"1\":{\"172\":1}}],[\"但是要注意一下顺序\",{\"1\":{\"402\":1}}],[\"但是必须保证其他方法有默认实现\",{\"1\":{\"392\":1}}],[\"但是可以直接new了\",{\"1\":{\"387\":1}}],[\"但是可以存在静态变量和静态方法\",{\"1\":{\"354\":1}}],[\"但是能匹配\",{\"1\":{\"381\":1}}],[\"但是拼接字符串实际上底层需要进行很多操作\",{\"1\":{\"380\":1}}],[\"但是只能在定义时赋值\",{\"1\":{\"370\":1}}],[\"但是biginteger没有这些限制\",{\"1\":{\"364\":1}}],[\"但是各位小伙伴只需要知道\",{\"1\":{\"362\":1}}],[\"但是java中的基本数据类型却不是面向对象的\",{\"1\":{\"361\":1}}],[\"但是它继承自enum类\",{\"1\":{\"356\":1}}],[\"但是它存在自动刷新机制\",{\"1\":{\"284\":1}}],[\"但是推荐打上\",{\"1\":{\"356\":1}}],[\"但是像这样的拷贝操作其实也分为浅拷贝和深拷贝\",{\"1\":{\"355\":1}}],[\"但是获取到的type的实现并不一定是class\",{\"1\":{\"343\":1}}],[\"但是前者是唤醒所有调用wait\",{\"1\":{\"318\":1}}],[\"但是又被对方牢牢把握\",{\"1\":{\"313\":1}}],[\"但是又迟迟不释放\",{\"1\":{\"313\":1}}],[\"但是class类实例同样的类无论怎么获取都是同一个\",{\"1\":{\"312\":1}}],[\"但是如果我们使用构造方法主动创建两个新的对象\",{\"1\":{\"379\":1}}],[\"但是如果我们在运行时\",{\"1\":{\"377\":1}}],[\"但是如果是引用类型的话\",{\"1\":{\"373\":1}}],[\"但是如果超出这个缓存范围的话\",{\"1\":{\"362\":1}}],[\"但是如果同时写入内容\",{\"1\":{\"311\":1}}],[\"但是如果多个处理器的运算任务都涉及同一块内存区域\",{\"1\":{\"311\":1}}],[\"但是如果队列为空\",{\"1\":{\"200\":2}}],[\"但是如果队列已经为空\",{\"1\":{\"200\":2}}],[\"但是很有可能导致资源不能完全释放\",{\"1\":{\"301\":1}}],[\"但是并不是同一个对象\",{\"1\":{\"362\":1}}],[\"但是并不是所推荐的做法\",{\"1\":{\"299\":1}}],[\"但是并不是很常用\",{\"1\":{\"202\":1}}],[\"但是run是直接在当前线程执行\",{\"1\":{\"298\":1}}],[\"但是\",{\"1\":{\"295\":1,\"313\":1,\"371\":1}}],[\"但是name属性并没有保存\",{\"1\":{\"290\":1}}],[\"但是我个人认为这种说法是错的\",{\"1\":{\"354\":1}}],[\"但是我只能往一个outputstream里输出\",{\"1\":{\"283\":1}}],[\"但是我们也可以将接口实现类的对象以接口的形式去使用\",{\"1\":{\"354\":1}}],[\"但是我们的程序并没有停止\",{\"1\":{\"324\":1}}],[\"但是我们希望能够按字符的方式读取\",{\"1\":{\"283\":1}}],[\"但是我们限定下界的话\",{\"1\":{\"172\":1}}],[\"但是我们发现\",{\"1\":{\"166\":1}}],[\"但是我们前面说了\",{\"1\":{\"161\":1}}],[\"但是同样需要有访问权限的情况下才可以\",{\"1\":{\"278\":1}}],[\"但是现在支持以reader的方式进行读取\",{\"1\":{\"283\":1}}],[\"但是现在支持以writer的方式进行写入\",{\"1\":{\"283\":1}}],[\"但是现在\",{\"1\":{\"277\":1}}],[\"但是静态方法是可以访问到静态变量的\",{\"1\":{\"274\":1}}],[\"但是依然能够正常读取\",{\"1\":{\"265\":1}}],[\"但是进行了一些额外的处理然后再调用fileinputstream的同名方法\",{\"1\":{\"264\":1}}],[\"但是每次都需要从外部i\",{\"1\":{\"260\":1}}],[\"但是这样始终治标不治本\",{\"1\":{\"217\":1}}],[\"但是学习\",{\"1\":{\"207\":1}}],[\"但是出队顺序是按照优先级来的\",{\"1\":{\"203\":1}}],[\"但是是next方法是从后往前进行遍历的\",{\"1\":{\"201\":1}}],[\"但是是并行执行的\",{\"1\":{\"180\":1}}],[\"但是插入失败不会抛出异常\",{\"1\":{\"200\":1}}],[\"但是都是按照迭代器的标准进行了实现\",{\"1\":{\"190\":1}}],[\"但是由于仅仅是语法糖\",{\"1\":{\"187\":1}}],[\"但是之后的版本可以\",{\"1\":{\"182\":1}}],[\"但是他们的相同和不同之处在于\",{\"1\":{\"179\":1}}],[\"但是不再是object类型\",{\"1\":{\"172\":1}}],[\"但是仅返回类型不同\",{\"1\":{\"165\":1}}],[\"但是需要的形式参数不一样\",{\"1\":{\"165\":1}}],[\"但是当前作用域下只有对象属性的name变量\",{\"1\":{\"164\":1}}],[\"但是规则跟变量的命名差不多\",{\"1\":{\"162\":1}}],[\"但在发表\",{\"1\":{\"144\":1}}],[\"但这里还有一个难点\",{\"1\":{\"136\":1}}],[\"但实际上还是在调用本身的方法\",{\"1\":{\"351\":1}}],[\"但实际上我们往往是选择一个非常小的常数\",{\"1\":{\"98\":1}}],[\"但实际情况可能并不是所有状态的概率都是一致的\",{\"1\":{\"134\":1}}],[\"但需要大量的\",{\"1\":{\"101\":1}}],[\"但由于\",{\"1\":{\"101\":1}}],[\"但目前无法保证\",{\"1\":{\"84\":1}}],[\"但存在一定的浪费\",{\"1\":{\"81\":1}}],[\"但现实场景中不太经常使用\",{\"1\":{\"76\":1}}],[\"但若考虑集群情况\",{\"1\":{\"14\":1}}],[\"但每个无人机所管理的用户不同\",{\"1\":{\"13\":1}}],[\"但即使仅考虑用户聚类\",{\"1\":{\"13\":1}}],[\"否则报错\",{\"1\":{\"402\":1}}],[\"否则我们必须要使用\",{\"1\":{\"402\":1}}],[\"否则会无法通过编译\",{\"1\":{\"353\":1}}],[\"否则会抛出异常\",{\"1\":{\"318\":1}}],[\"否则资源会被一直占用\",{\"1\":{\"247\":1}}],[\"否则给你当成\",{\"1\":{\"241\":1}}],[\"否则太过死板\",{\"1\":{\"215\":1}}],[\"否则抛出\",{\"1\":{\"182\":1}}],[\"否则false\",{\"1\":{\"180\":3}}],[\"否则返回false\",{\"1\":{\"180\":2,\"381\":1}}],[\"否则一律报错\",{\"1\":{\"172\":1}}],[\"否则要创建这个类的对象\",{\"1\":{\"166\":1}}],[\"否则\",{\"1\":{\"13\":1}}],[\"奖励\",{\"1\":{\"13\":1,\"19\":1}}],[\"并在控制台打印栈追踪信息\",{\"1\":{\"402\":1}}],[\"并直接创建实例对象\",{\"1\":{\"390\":1}}],[\"并没有初始化内部类\",{\"1\":{\"389\":1}}],[\"并没有考虑到多线程运行的情况\",{\"1\":{\"330\":1}}],[\"并返回一个新的子串对象\",{\"1\":{\"379\":1}}],[\"并根据实际需求扩展出新的行为\",{\"1\":{\"347\":1}}],[\"并提供对外访问的接口\",{\"1\":{\"347\":1}}],[\"并行流\",{\"1\":{\"330\":2}}],[\"并打印出了相关线程的栈追踪信息\",{\"1\":{\"313\":1}}],[\"并发会用到\",{\"1\":{\"264\":1}}],[\"并将字符串转换为字符\",{\"1\":{\"284\":1}}],[\"并将下一个元素作为待遍历元素\",{\"1\":{\"189\":1}}],[\"并将元素替换为处理之后的结果\",{\"1\":{\"181\":1}}],[\"并不编写方法的主体\",{\"1\":{\"353\":1}}],[\"并不一定真实的数据量就是这么多\",{\"1\":{\"248\":1}}],[\"并不会去释放任何锁资源\",{\"1\":{\"313\":1}}],[\"并不会在一开始就去加载它\",{\"1\":{\"275\":1}}],[\"并不会真的进行类型检查\",{\"1\":{\"237\":1}}],[\"并不会真的去检查对应类型\",{\"1\":{\"173\":1}}],[\"并不会维持插入的顺序\",{\"1\":{\"218\":1}}],[\"并不是说只有抽象类和接口才可以像这样创建匿名内部类\",{\"1\":{\"390\":1}}],[\"并不是说一定优先级越高的线程越先执行\",{\"1\":{\"302\":1}}],[\"并不是基本数据类型\",{\"1\":{\"370\":1}}],[\"并不是包装类型\",{\"1\":{\"340\":1}}],[\"并不是所有的类都会在一开始加载\",{\"1\":{\"337\":1}}],[\"并不是我们实际list中的顺序\",{\"1\":{\"330\":1}}],[\"并不是将另一个线程和当前线程合并\",{\"1\":{\"305\":1}}],[\"并不是创建一个线程执行\",{\"1\":{\"298\":1}}],[\"并不是写入的字符串\",{\"1\":{\"286\":1}}],[\"并不是\",{\"1\":{\"212\":1}}],[\"并不是在构造方法之后\",{\"1\":{\"166\":1}}],[\"并不是一直进行更新\",{\"1\":{\"142\":1}}],[\"并非java定义\",{\"1\":{\"340\":1}}],[\"并非是所对应的对象本身\",{\"1\":{\"161\":1}}],[\"并非只是一个单一的轨迹\",{\"1\":{\"19\":1}}],[\"并且接口没有继承数量限制\",{\"1\":{\"354\":1}}],[\"并且默认在类中实现的权限是\",{\"1\":{\"354\":1}}],[\"并且也导入了我们自己定义的string类\",{\"1\":{\"277\":1}}],[\"并且同样支持try\",{\"1\":{\"249\":1}}],[\"并且可以在管道的节点上进行处理\",{\"1\":{\"228\":1}}],[\"并且方法名称与类名相同\",{\"1\":{\"166\":2}}],[\"并且如果按照这样一个策略\",{\"1\":{\"86\":1}}],[\"并且与状态\",{\"1\":{\"48\":1}}],[\"并获得奖励rt​的这一过程可以用条件转移概率p\",{\"1\":{\"13\":1}}],[\"并与传统的基于遗传的学习算法进行对比\",{\"1\":{\"5\":1}}],[\"左转\",{\"1\":{\"13\":1}}],[\"共有三种方法\",{\"1\":{\"339\":1}}],[\"共两步\",{\"1\":{\"132\":1}}],[\"共分为\",{\"1\":{\"63\":1}}],[\"共考虑7个方向\",{\"1\":{\"13\":1}}],[\"共划分5个等级\",{\"1\":{\"10\":1}}],[\"个类型的实参\",{\"1\":{\"376\":1}}],[\"个样本\",{\"1\":{\"142\":1}}],[\"个人推导\",{\"1\":{\"44\":1}}],[\"个人感觉是这个\",{\"1\":{\"13\":1}}],[\"个人理解\",{\"1\":{\"13\":1,\"19\":1}}],[\"个\",{\"1\":{\"13\":1}}],[\"×\",{\"1\":{\"13\":2}}],[\"0xa6\",{\"1\":{\"363\":1}}],[\"0<c1​≤▽w​g\",{\"1\":{\"98\":1}}],[\"0\",{\"1\":{\"13\":17,\"14\":1,\"19\":1,\"47\":1,\"87\":1,\"104\":1,\"166\":1,\"171\":5,\"180\":1,\"182\":7,\"193\":1,\"205\":1,\"206\":1,\"216\":2,\"217\":4,\"221\":1,\"223\":6,\"228\":4,\"249\":1,\"251\":1,\"296\":1,\"299\":1,\"304\":3,\"305\":2,\"311\":3,\"312\":14,\"318\":2,\"329\":2,\"330\":2,\"372\":1,\"374\":1,\"376\":1,\"379\":1,\"381\":5,\"401\":1,\"409\":1,\"410\":1,\"415\":1}}],[\"0≤t≤ts​\",{\"1\":{\"8\":2,\"11\":2}}],[\"状态s时可以得到的平均reward\",{\"1\":{\"153\":1}}],[\"状态转换\",{\"1\":{\"19\":1}}],[\"状态转换模型\",{\"1\":{\"13\":1}}],[\"状态除了要考虑无人机的3d位置外\",{\"1\":{\"14\":1}}],[\"状态空间\",{\"1\":{\"13\":1,\"19\":1}}],[\"状态\",{\"1\":{\"13\":1,\"19\":1,\"135\":1,\"142\":1,\"300\":1,\"356\":1}}],[\"智能体\",{\"1\":{\"13\":1}}],[\"来作为结果\",{\"1\":{\"415\":1}}],[\"来处理\",{\"1\":{\"402\":1}}],[\"来获取类的信息和操作类\",{\"1\":{\"338\":1}}],[\"来模拟一个餐厅的2个厨师和3个顾客\",{\"1\":{\"331\":1}}],[\"来创建工作内存中的变量\",{\"1\":{\"319\":1}}],[\"来实现\",{\"1\":{\"353\":1}}],[\"来实现多个进程的同时运行\",{\"1\":{\"295\":1}}],[\"来实现更加方便的操作\",{\"1\":{\"283\":1}}],[\"来支持对象类型的io\",{\"1\":{\"287\":1}}],[\"来保证数据正确写入到硬盘文件中\",{\"1\":{\"249\":1}}],[\"来保证这个梯度的方差最小即可\",{\"1\":{\"26\":1}}],[\"来快速编写代码\",{\"1\":{\"228\":1}}],[\"来做事\",{\"1\":{\"224\":1}}],[\"来自定义排序规则\",{\"1\":{\"171\":1}}],[\"来完成\",{\"1\":{\"166\":1}}],[\"来明确表示当前类的示例对象本身\",{\"1\":{\"164\":1}}],[\"来定义最优的策略\",{\"1\":{\"148\":1}}],[\"来更新参数值\",{\"1\":{\"142\":1}}],[\"来近似\",{\"1\":{\"137\":1,\"138\":1}}],[\"来进行求解\",{\"1\":{\"77\":1}}],[\"来进行迭代\",{\"1\":{\"13\":1}}],[\"来提升当前策略\",{\"1\":{\"66\":1}}],[\"来表示\",{\"1\":{\"13\":1}}],[\"来最大化mos总和\",{\"1\":{\"13\":1}}],[\"来考虑无人机的机动性\",{\"1\":{\"4\":1}}],[\"划分完毕\",{\"1\":{\"13\":1}}],[\"再写回主内存后\",{\"1\":{\"311\":1}}],[\"再继续执行的线程2内容\",{\"1\":{\"305\":1}}],[\"再来看\",{\"1\":{\"224\":1}}],[\"再通过这些经验来不断改进更新另一个策略\",{\"1\":{\"123\":1}}],[\"再次出现\",{\"1\":{\"81\":1}}],[\"再将\",{\"1\":{\"77\":1}}],[\"再将用户划分给距离最近的无人机\",{\"1\":{\"13\":1}}],[\"再求平均值\",{\"1\":{\"41\":1}}],[\"再根据欧几里得距离重新划分\",{\"1\":{\"13\":1}}],[\"再找到新的簇的各中心\",{\"1\":{\"13\":1}}],[\"每一轮循环\",{\"1\":{\"372\":1}}],[\"每一个thread对象中\",{\"1\":{\"301\":1}}],[\"每一个进程都是一个应用程序\",{\"1\":{\"295\":1}}],[\"每一个对象我们都可以称其为元素\",{\"1\":{\"178\":1}}],[\"每一次next操作\",{\"1\":{\"188\":1}}],[\"每次运算都会生成一个新的对象\",{\"1\":{\"380\":1}}],[\"每次就直接返回一个字符串吧\",{\"1\":{\"193\":1}}],[\"每次循环一定要判断是否还有元素剩余\",{\"1\":{\"191\":1}}],[\"每次都是从对应的状态\",{\"1\":{\"84\":1}}],[\"每次迭代都会使得策略进行提升\",{\"1\":{\"68\":1}}],[\"每次无人机会根据当前状态st​∈s\",{\"1\":{\"13\":1}}],[\"每个对象中都有一个单独的类定义\",{\"1\":{\"386\":1}}],[\"每个对象都有这样的一个类定义\",{\"1\":{\"386\":1}}],[\"每个对象都有一个自己的空间\",{\"1\":{\"161\":1}}],[\"每个对象都应该有针对于锁的一些操作\",{\"1\":{\"318\":1}}],[\"每个类可以创建一个对象\",{\"1\":{\"386\":1}}],[\"每个类都有且只有一个唯一的class对象存放在jvm中\",{\"1\":{\"337\":1}}],[\"每个用双引号括起来的字符串\",{\"1\":{\"379\":1}}],[\"每个用户的移动方向均匀分布在左\",{\"1\":{\"14\":1}}],[\"每个用户都需要判断是否与每个无人机关联\",{\"1\":{\"14\":1}}],[\"每个用户只能属于一个集群\",{\"1\":{\"8\":1}}],[\"每个包装类中\",{\"1\":{\"340\":1}}],[\"每个线程都有一个私有的工作内存\",{\"1\":{\"311\":1}}],[\"每个元素都要执行+1操作\",{\"1\":{\"228\":1}}],[\"每个元素都有一个自己的下标位置\",{\"1\":{\"181\":2}}],[\"每个集群中无人机的最优位置也会发生变化\",{\"1\":{\"14\":1}}],[\"每架无人机的带宽和发射功率都均匀分配给每个用户\",{\"1\":{\"13\":1}}],[\"将抛出\",{\"1\":{\"403\":1}}],[\"将无法通过编译\",{\"1\":{\"399\":1,\"416\":1}}],[\"将无人机部署在每个中心内\",{\"1\":{\"13\":1}}],[\"将其中的抽象方法实现\",{\"1\":{\"390\":1}}],[\"将其平均分配给其∣kn​∣个关联用户\",{\"1\":{\"9\":1}}],[\"将匹配\",{\"1\":{\"381\":1}}],[\"将匹配的子串替换或者从某个串中取出符合某个条件的子串等\",{\"1\":{\"381\":1}}],[\"将这些值提前做成包装类放在数组中存放\",{\"1\":{\"362\":1}}],[\"将int类型值作为包装类型使用\",{\"1\":{\"362\":1}}],[\"将当前对象转换为string的形式\",{\"1\":{\"350\":1}}],[\"将变量的值给予threadlocal\",{\"1\":{\"319\":2}}],[\"将cpu资源让位给其他线程\",{\"1\":{\"304\":1}}],[\"将文件内容作为输入流进行扫描\",{\"1\":{\"285\":1}}],[\"将它们以字符串的形式写入到输出流\",{\"1\":{\"284\":1}}],[\"将main类放到com\",{\"1\":{\"277\":1}}],[\"将缓冲区大小设置为1\",{\"1\":{\"265\":1}}],[\"将每一个元素映射为integer类型\",{\"1\":{\"228\":1}}],[\"将会无限进行下去\",{\"1\":{\"228\":1}}],[\"将底层数组变成新的扩容之后的数组\",{\"1\":{\"217\":1}}],[\"将另一个map中的所有键值对添加到当前map中\",{\"1\":{\"213\":1}}],[\"将元素从栈顶出栈\",{\"1\":{\"201\":1}}],[\"将元素推向栈顶\",{\"1\":{\"201\":1}}],[\"将上一个已遍历元素修改为新的元素\",{\"1\":{\"194\":1}}],[\"将上述优化问题简化\",{\"1\":{\"13\":1}}],[\"将给定集合中所有元素插入到当前结合的给定位置上\",{\"1\":{\"181\":1}}],[\"将集合转换为数组的形式\",{\"1\":{\"180\":1}}],[\"将基于表格表示的策略\",{\"1\":{\"148\":1}}],[\"将该网络的\",{\"1\":{\"142\":1}}],[\"将\",{\"1\":{\"58\":1,\"85\":1,\"142\":2}}],[\"将所有状态的\",{\"1\":{\"46\":1}}],[\"将处于\",{\"1\":{\"29\":1}}],[\"将对于\",{\"1\":{\"23\":1}}],[\"将对应的轨迹所获得的所有reward的总和\",{\"1\":{\"19\":1}}],[\"解决方案\",{\"0\":{\"12\":1}}],[\"水平位置和高度\",{\"1\":{\"11\":1}}],[\"数学工具类\",{\"0\":{\"409\":1}}],[\"数字\",{\"1\":{\"381\":1}}],[\"数量的内容\",{\"1\":{\"265\":1}}],[\"数量和位置\",{\"1\":{\"11\":1}}],[\"数组工具类\",{\"0\":{\"410\":1}}],[\"数组同样支持向上转型\",{\"1\":{\"373\":1}}],[\"数组大小\",{\"1\":{\"370\":2}}],[\"数组类型比较特殊\",{\"1\":{\"370\":1}}],[\"数组类型也是一种类型\",{\"1\":{\"341\":1}}],[\"数组可以代表任何相同类型的一组内容\",{\"1\":{\"369\":1}}],[\"数组可以存放基本数据类型\",{\"1\":{\"179\":1}}],[\"数组是相同类型数据的有序集合\",{\"1\":{\"369\":1}}],[\"数组\",{\"0\":{\"367\":1,\"369\":1}}],[\"数组的\",{\"0\":{\"341\":1},\"1\":{\"371\":1}}],[\"数组的大小是固定的\",{\"1\":{\"179\":1}}],[\"数组实现的栈和队列\",{\"1\":{\"202\":1}}],[\"数组存放的类型只能是一种\",{\"1\":{\"179\":1}}],[\"数据流datainputstream也是filterinputstream的子类\",{\"1\":{\"286\":1}}],[\"数据流\",{\"0\":{\"286\":1}}],[\"数据结构与算法基础\",{\"1\":{\"172\":2,\"415\":1}}],[\"数据结构与算法\",{\"1\":{\"172\":1,\"203\":1}}],[\"数据包从发送端\",{\"1\":{\"10\":1}}],[\"因而也被称为实例\",{\"1\":{\"161\":1}}],[\"因为数组本身是引用类型\",{\"1\":{\"416\":1}}],[\"因为无论具体类型是什么\",{\"1\":{\"416\":1}}],[\"因为无论是\",{\"1\":{\"75\":1}}],[\"因为此时并不明确具体是什么类型\",{\"1\":{\"416\":1}}],[\"因为是具体使用对象时才会明确具体类型\",{\"1\":{\"416\":1}}],[\"因为是在顶层接口中定义的\",{\"1\":{\"193\":1}}],[\"因为现在有了类型变量\",{\"1\":{\"416\":1}}],[\"因为现在只需要一个string类型的返回值\",{\"1\":{\"393\":1}}],[\"因为现在只可能出现number的子类\",{\"1\":{\"173\":1}}],[\"因为object是所有类型的父类\",{\"1\":{\"415\":1}}],[\"因为不这样就无法编译了\",{\"1\":{\"401\":1}}],[\"因为不需要\",{\"1\":{\"125\":1}}],[\"因为integer类中默认提供了求两个int值之和的静态方法\",{\"1\":{\"393\":1}}],[\"因为匿名对象没有类名\",{\"1\":{\"390\":1}}],[\"因为匿名内部类就是接口的实现类\",{\"1\":{\"171\":1}}],[\"因为并没有使用到外部类的任何静态变量\",{\"1\":{\"389\":1}}],[\"因为成员内部类本身就是某个对象所有的\",{\"1\":{\"386\":1}}],[\"因为父类都是\",{\"1\":{\"373\":1}}],[\"因为同样是类\",{\"1\":{\"370\":1}}],[\"因为超出了缓存的范围\",{\"1\":{\"362\":1}}],[\"因为小的数使用频率非常高\",{\"1\":{\"362\":1}}],[\"因为包装类是一个类\",{\"1\":{\"362\":1}}],[\"因为底层是c++实现\",{\"1\":{\"355\":1}}],[\"因为底层实质上是借用的一个\",{\"1\":{\"205\":1}}],[\"因为其他类就算继承这个接口\",{\"1\":{\"354\":1}}],[\"因为其满足该理论\",{\"1\":{\"58\":1}}],[\"因为抽象方法一定要由子类实现\",{\"1\":{\"353\":1}}],[\"因为都直接在一个缺省的包中\",{\"1\":{\"277\":1}}],[\"因为this关键字代表的是当前的对象本身\",{\"1\":{\"274\":1}}],[\"因为静态方法属于类的\",{\"1\":{\"274\":1}}],[\"因为关闭流是任何情况都必须要执行的\",{\"1\":{\"247\":1}}],[\"因为它本质上就相当于是对应类型的子类\",{\"1\":{\"390\":1}}],[\"因为它作用范围就只是方法内\",{\"1\":{\"388\":1}}],[\"因为它们直接操作字符\",{\"1\":{\"245\":1}}],[\"因为它会将我们插入的结点按照规则进行排序\",{\"1\":{\"219\":1}}],[\"因为重写了\",{\"1\":{\"241\":1}}],[\"因为传入的哈希值可能会很大\",{\"1\":{\"216\":1}}],[\"因为操作特殊\",{\"1\":{\"212\":1,\"213\":1}}],[\"因为list是有序集合\",{\"1\":{\"194\":1}}],[\"因为所有的对象都是属于一个普通的类型\",{\"1\":{\"173\":1}}],[\"因为还是有可能是\",{\"1\":{\"172\":1}}],[\"因为我们前面学习了lambda表达式\",{\"1\":{\"171\":1}}],[\"因为我们需要计算的是\",{\"1\":{\"155\":1}}],[\"因为在编译的时候\",{\"1\":{\"389\":1}}],[\"因为在最后自动帮我们调用了close\",{\"1\":{\"247\":1}}],[\"因为在\",{\"1\":{\"92\":1}}],[\"因为在不考虑用户自由穿梭集群的情况\",{\"1\":{\"14\":1}}],[\"因为最终策略更新的核心仍然是\",{\"1\":{\"79\":1}}],[\"因为\",{\"1\":{\"77\":1,\"104\":1,\"124\":1,\"192\":1,\"214\":1,\"224\":2,\"241\":1}}],[\"因为q\",{\"1\":{\"13\":1}}],[\"因为目标函数对于无人机的3d坐标是非凸的\",{\"1\":{\"11\":1}}],[\"因此既可以存放integer也能存放string\",{\"1\":{\"415\":1}}],[\"因此只能使用类来进行定义\",{\"1\":{\"378\":1}}],[\"因此会读取命令行中的指令参数进行存储到\",{\"1\":{\"377\":1}}],[\"因此守护线程不适合进行io操作\",{\"1\":{\"329\":1}}],[\"因此各个线程直接存放的内容互不干扰\",{\"1\":{\"319\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"313\":1}}],[\"因此并不能保证自增操作的原子性\",{\"1\":{\"312\":1}}],[\"因此有对象锁和类锁区别\",{\"1\":{\"312\":1}}],[\"因此为null\",{\"1\":{\"290\":1}}],[\"因此依然是装饰我们传入的输出流\",{\"1\":{\"284\":1}}],[\"因此性能还不够高\",{\"1\":{\"260\":1}}],[\"因此可以直接调用\",{\"1\":{\"409\":1,\"410\":1}}],[\"因此可以直接使用lambda表达式\",{\"1\":{\"296\":1}}],[\"因此可以直接放入\",{\"1\":{\"283\":1}}],[\"因此可以直接读取到中文字符\",{\"1\":{\"253\":1}}],[\"因此可以考虑\",{\"1\":{\"136\":1}}],[\"因此它只适合读纯文本的文件\",{\"1\":{\"253\":1}}],[\"因此与read结合\",{\"1\":{\"248\":1}}],[\"因此这样就能够保证我们插入顺序和最后的迭代顺序一致了\",{\"1\":{\"206\":1}}],[\"因此这种情况下的\",{\"1\":{\"134\":1}}],[\"因此所有的集合类都有这个方法\",{\"1\":{\"193\":1}}],[\"因此返回值也是\",{\"1\":{\"171\":1}}],[\"因此该指标可以描述为\",{\"1\":{\"150\":1}}],[\"因此左侧那个类似\",{\"1\":{\"142\":1}}],[\"因此对应的损失函数的梯度可以修改为\",{\"1\":{\"142\":1}}],[\"因此对应算法为\",{\"1\":{\"138\":1}}],[\"因此对于用户kn​的在时刻t的传输速率rkn​​\",{\"1\":{\"9\":1}}],[\"因此需要用近似算法来进行替代\",{\"1\":{\"136\":1}}],[\"因此采用这种\",{\"1\":{\"134\":1}}],[\"因此不需要进行\",{\"1\":{\"120\":1}}],[\"因此我们需要一种方法来区分类的不同版本\",{\"1\":{\"289\":1}}],[\"因此我们需要保证对于所有的\",{\"1\":{\"155\":1}}],[\"因此我们不需要手动指定\",{\"1\":{\"277\":1}}],[\"因此我们用\",{\"1\":{\"137\":1}}],[\"因此我们可以通过\",{\"1\":{\"99\":1}}],[\"因此我们将优化问题简化为区域分割问题\",{\"1\":{\"13\":1}}],[\"因此是一个确定的贪心策略\",{\"1\":{\"88\":1}}],[\"因此是2n\",{\"1\":{\"14\":1}}],[\"因此随着用户位置的变化\",{\"1\":{\"14\":1}}],[\"因此mos不仅与欧氏距离有关\",{\"1\":{\"13\":1}}],[\"因此moskn​​delay\",{\"1\":{\"10\":1}}],[\"因此gak\",{\"1\":{\"13\":1}}],[\"因此\",{\"1\":{\"9\":2,\"10\":1,\"26\":1,\"42\":1,\"48\":1,\"58\":1,\"71\":1,\"94\":1,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"124\":1,\"171\":1,\"173\":1,\"204\":1,\"241\":1,\"313\":1,\"379\":1,\"390\":2}}],[\"∀\",{\"1\":{\"116\":1,\"120\":1}}],[\"∀s\",{\"1\":{\"115\":1,\"119\":1}}],[\"∀s=st​\",{\"1\":{\"112\":1}}],[\"∀s∈s​\",{\"1\":{\"55\":1}}],[\"∀s∈s=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"∀s∈s\",{\"1\":{\"45\":1,\"58\":1}}],[\"∀kn​\",{\"1\":{\"11\":3,\"13\":3}}],[\"∀t\",{\"1\":{\"11\":4,\"13\":4}}],[\"∀n\",{\"1\":{\"11\":2,\"13\":2}}],[\"从java8开始\",{\"1\":{\"354\":1}}],[\"从已知的一个类中派生出一个新的类\",{\"1\":{\"347\":1}}],[\"从队列中删除最后一个出现的指定元素\",{\"1\":{\"201\":1}}],[\"从队列中删除第一个出现的指定元素\",{\"1\":{\"201\":1}}],[\"从数学角度来说\",{\"1\":{\"180\":4}}],[\"从集合中移除某个元素\",{\"1\":{\"180\":1}}],[\"从这章开始时基于\",{\"1\":{\"147\":1}}],[\"从\",{\"1\":{\"104\":1}}],[\"从给定的\",{\"1\":{\"82\":1}}],[\"从状态\",{\"1\":{\"78\":1,\"137\":1}}],[\"从状态st​到st+1​\",{\"1\":{\"13\":1}}],[\"从指定的\",{\"1\":{\"78\":1}}],[\"从此可以发现\",{\"1\":{\"77\":1}}],[\"从而其它被阻塞在这个锁的线程才可以继续执行\",{\"1\":{\"313\":1}}],[\"从而可以进行近似求解\",{\"1\":{\"155\":1}}],[\"从而可以在\",{\"1\":{\"115\":1}}],[\"从而方便计算\",{\"1\":{\"142\":1}}],[\"从而使得算法可行\",{\"1\":{\"136\":1}}],[\"从而生成经验数据的策略\",{\"1\":{\"121\":1}}],[\"从而引入\",{\"1\":{\"105\":1}}],[\"从而转换为一个\",{\"1\":{\"104\":1}}],[\"从而进行多次利用\",{\"1\":{\"81\":1}}],[\"从而选择每个状态下最大的\",{\"1\":{\"77\":1}}],[\"从而减小方差\",{\"1\":{\"25\":1}}],[\"从而最大化所有用户的总mos值\",{\"1\":{\"11\":1}}],[\"从无人机n到用户kn​的信道功率增益\",{\"1\":{\"9\":1}}],[\"是string类型的\",{\"1\":{\"415\":1}}],[\"是某个异常的父类\",{\"1\":{\"402\":1}}],[\"是某一类事物实际存在的每个个体\",{\"1\":{\"161\":1}}],[\"是继承\",{\"1\":{\"399\":1}}],[\"是无法访问到外部类的非静态内容的\",{\"1\":{\"387\":1}}],[\"是属于类的\",{\"1\":{\"387\":1}}],[\"是可以访问到外层的变量的\",{\"1\":{\"386\":1}}],[\"是可以的\",{\"1\":{\"373\":1}}],[\"是对象所有的\",{\"1\":{\"386\":1}}],[\"是对一类事物的描述\",{\"1\":{\"161\":1}}],[\"是匹配所有空白符\",{\"1\":{\"381\":1}}],[\"是通过一个容器来解决生产者和消费者的强耦合问题\",{\"1\":{\"331\":1}}],[\"是因为suspend\",{\"1\":{\"313\":1}}],[\"是因为集合类的实现方案有很多\",{\"1\":{\"188\":1}}],[\"是class类实例\",{\"1\":{\"312\":1}}],[\"是根据\",{\"1\":{\"241\":1}}],[\"是根据q\",{\"1\":{\"13\":1}}],[\"是直接继承自hashmap\",{\"1\":{\"218\":1}}],[\"是直接建立一个基于策略的目标函数来进行梯度上升的优化\",{\"1\":{\"147\":1}}],[\"是以键值对的形式存在\",{\"1\":{\"212\":1}}],[\"是在\",{\"1\":{\"409\":1,\"410\":1}}],[\"是在一开始就确定的\",{\"1\":{\"371\":1}}],[\"是在队尾进行插入\",{\"1\":{\"200\":1}}],[\"是在基于\",{\"1\":{\"23\":1}}],[\"是为了方便日后如果我们想要更换不同的集合类实现\",{\"1\":{\"182\":1}}],[\"是为了完成某件事情而存在的\",{\"1\":{\"162\":1}}],[\"是集合类型的一个分支\",{\"1\":{\"181\":1}}],[\"是不是感觉非常简洁\",{\"1\":{\"392\":1}}],[\"是不是感觉这个工具类好像还挺好用的\",{\"1\":{\"237\":1}}],[\"是不是有点太浪费了\",{\"1\":{\"380\":1}}],[\"是不能\",{\"1\":{\"373\":1}}],[\"是不支持自动装箱和拆箱的\",{\"1\":{\"373\":1}}],[\"是不允许的\",{\"1\":{\"165\":1}}],[\"是不同的\",{\"1\":{\"40\":1,\"123\":1}}],[\"是类的一个具体化个体\",{\"1\":{\"161\":1}}],[\"是抽象的\",{\"1\":{\"161\":1}}],[\"是未知的\",{\"1\":{\"156\":1}}],[\"是各个\",{\"1\":{\"150\":1}}],[\"是我们需要进行优化的\",{\"1\":{\"148\":1}}],[\"是我们不断进行更新的策略\",{\"1\":{\"121\":1}}],[\"是用来与环境进行交互\",{\"1\":{\"121\":1}}],[\"是qπ​\",{\"1\":{\"116\":1}}],[\"是关于\",{\"1\":{\"112\":1}}],[\"是常数\",{\"1\":{\"110\":1}}],[\"是否可执行\",{\"1\":{\"255\":1}}],[\"是否可写\",{\"1\":{\"255\":1}}],[\"是否可读\",{\"1\":{\"255\":1}}],[\"是否为一个文件夹\",{\"1\":{\"255\":1}}],[\"是否为空\",{\"1\":{\"213\":1}}],[\"是否成立\",{\"1\":{\"104\":1}}],[\"是否是收敛的\",{\"0\":{\"72\":1}}],[\"是需要被优化的参数\",{\"1\":{\"101\":1}}],[\"是第\",{\"1\":{\"97\":2}}],[\"是最顶层的类\",{\"1\":{\"350\":1}}],[\"是最优的\",{\"1\":{\"84\":1}}],[\"是最大报文长度\",{\"1\":{\"10\":1}}],[\"是针对\",{\"1\":{\"80\":1}}],[\"是针对一条trajectory所求的\",{\"1\":{\"41\":1}}],[\"是优于\",{\"1\":{\"68\":1}}],[\"是已知的\",{\"1\":{\"63\":1}}],[\"是依赖于策略π的\",{\"1\":{\"48\":1}}],[\"是由环境决定的\",{\"1\":{\"45\":1}}],[\"是一种自动唤醒机制\",{\"1\":{\"318\":1}}],[\"是一样的\",{\"1\":{\"219\":1}}],[\"是一起删除还是只删除一个呢\",{\"1\":{\"182\":1}}],[\"是一个非负整数\",{\"1\":{\"381\":2}}],[\"是一个新创建的线程\",{\"1\":{\"324\":1}}],[\"是一个有序的集合\",{\"1\":{\"181\":1}}],[\"是一个有关状态s的函数\",{\"1\":{\"40\":1}}],[\"是一个期望值\",{\"1\":{\"101\":1}}],[\"是一个随机变量\",{\"1\":{\"101\":1}}],[\"是一个\",{\"1\":{\"97\":1}}],[\"是一个黑盒\",{\"1\":{\"97\":1}}],[\"是一个必要条件\",{\"1\":{\"84\":1}}],[\"是一个contraction\",{\"1\":{\"58\":1}}],[\"是一致的\",{\"1\":{\"41\":1,\"122\":1}}],[\"是基于一个给定策略\",{\"1\":{\"40\":1}}],[\"是\",{\"1\":{\"40\":1,\"49\":1,\"86\":1,\"113\":1,\"123\":2,\"124\":1,\"150\":1}}],[\"是网页大小\",{\"1\":{\"10\":1}}],[\"是与传输速率有关的延迟时间\",{\"1\":{\"10\":1}}],[\"rˉπ​\",{\"1\":{\"155\":1}}],[\"rˉπ​​\",{\"1\":{\"154\":1}}],[\"rˉπ​=s∈s∑​dπ​\",{\"1\":{\"153\":1}}],[\"runoob\",{\"1\":{\"381\":3}}],[\"running\",{\"1\":{\"356\":5}}],[\"runnable\",{\"1\":{\"296\":3,\"322\":8}}],[\"run方法\",{\"1\":{\"298\":1}}],[\"runtimeexceptionruntimeexception\",{\"1\":{\"399\":1}}],[\"runtimeexception\",{\"1\":{\"267\":1,\"331\":1,\"399\":1,\"400\":3,\"401\":2,\"402\":2}}],[\"run\",{\"1\":{\"135\":1,\"296\":2,\"322\":2,\"323\":1,\"324\":2}}],[\"r1​\",{\"1\":{\"112\":1}}],[\"rk​+γv\",{\"1\":{\"110\":1}}],[\"rkn​​mss​\",{\"1\":{\"10\":1}}],[\"rkn​​\",{\"1\":{\"10\":3}}],[\"r→r\",{\"1\":{\"96\":1}}],[\"rm\",{\"0\":{\"95\":1},\"1\":{\"97\":1,\"99\":1,\"104\":3,\"110\":2}}],[\"roundingmode是舍入模式\",{\"1\":{\"364\":1}}],[\"roundingmode\",{\"1\":{\"364\":1}}],[\"robbins\",{\"0\":{\"95\":1},\"1\":{\"98\":2}}],[\"root\",{\"1\":{\"92\":1,\"98\":1,\"104\":1,\"110\":1}}],[\"r+s\",{\"1\":{\"66\":2}}],[\"r+γa∈a\",{\"1\":{\"141\":1,\"142\":3}}],[\"r+γqπ​\",{\"1\":{\"115\":1}}],[\"r+γg∣s=s\",{\"1\":{\"113\":1}}],[\"r+γv\",{\"1\":{\"110\":6}}],[\"r+γ∑s\",{\"1\":{\"48\":1}}],[\"r+γs\",{\"1\":{\"45\":1,\"48\":1,\"55\":1,\"63\":1}}],[\"rπ​+γpπ​v1​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ1​​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ0​​\",{\"1\":{\"70\":2}}],[\"rπ​+γpπ​vπk​​\",{\"1\":{\"66\":1,\"70\":1,\"77\":1}}],[\"rπ​+γpπ​vk​\",{\"1\":{\"62\":1,\"63\":1,\"70\":1}}],[\"rπ​+γpπ​v\",{\"1\":{\"55\":1,\"58\":1,\"61\":1}}],[\"rπ​\",{\"1\":{\"46\":2,\"153\":4,\"154\":1}}],[\"rπ​=\",{\"1\":{\"46\":1}}],[\"r​​+mean\",{\"1\":{\"45\":1}}],[\"r​\",{\"1\":{\"43\":1}}],[\"r∑​p\",{\"1\":{\"43\":1,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"rl9\",{\"0\":{\"147\":1}}],[\"rl8\",{\"0\":{\"130\":1}}],[\"rl7\",{\"0\":{\"109\":1}}],[\"rl\",{\"1\":{\"92\":1}}],[\"rl6\",{\"0\":{\"92\":1}}],[\"rl5\",{\"0\":{\"75\":1}}],[\"rl4\",{\"0\":{\"61\":1}}],[\"rl3\",{\"0\":{\"52\":1}}],[\"rl2\",{\"0\":{\"36\":1}}],[\"rl10\",{\"0\":{\"23\":1}}],[\"rl1\",{\"0\":{\"17\":1}}],[\"r∣s\",{\"1\":{\"20\":1,\"41\":1,\"43\":1,\"45\":3,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"153\":2}}],[\"r\",{\"1\":{\"20\":3,\"110\":3,\"141\":1,\"142\":1,\"153\":3,\"381\":2}}],[\"rawtypes\",{\"1\":{\"181\":1,\"217\":1}}],[\"rate\",{\"1\":{\"19\":1,\"39\":1,\"58\":1}}],[\"random是一个随机数工具类\",{\"1\":{\"228\":1}}],[\"random支持直接生成随机数的流\",{\"1\":{\"228\":1}}],[\"randomaccess\",{\"1\":{\"182\":1}}],[\"random\",{\"1\":{\"14\":2,\"42\":1,\"228\":8,\"409\":6}}],[\"r=1∣s1​\",{\"1\":{\"19\":1}}],[\"regexp\",{\"1\":{\"381\":2}}],[\"regular\",{\"1\":{\"381\":1}}],[\"registernatives\",{\"1\":{\"350\":2}}],[\"reflectiveobjects\",{\"1\":{\"343\":1}}],[\"reflect\",{\"1\":{\"343\":1}}],[\"references\",{\"1\":{\"324\":1}}],[\"refers\",{\"1\":{\"92\":1}}],[\"re\",{\"1\":{\"324\":1}}],[\"removing\",{\"1\":{\"324\":1}}],[\"removelastoccurrence\",{\"1\":{\"201\":1}}],[\"removelast\",{\"1\":{\"201\":1}}],[\"removefirstoccurrence\",{\"1\":{\"201\":1}}],[\"removefirst\",{\"1\":{\"201\":1}}],[\"removed\",{\"1\":{\"180\":3}}],[\"removeif\",{\"1\":{\"180\":1}}],[\"removeall\",{\"1\":{\"180\":1,\"204\":1}}],[\"remove\",{\"1\":{\"180\":2,\"181\":1,\"182\":4,\"189\":3,\"194\":1,\"200\":1,\"204\":1,\"205\":1,\"213\":1,\"223\":2,\"241\":2}}],[\"readobject\",{\"1\":{\"288\":1,\"290\":1}}],[\"readboolean\",{\"1\":{\"286\":1}}],[\"readline\",{\"1\":{\"269\":1}}],[\"readlimit\",{\"1\":{\"265\":2}}],[\"read\",{\"1\":{\"248\":5,\"251\":1,\"253\":2,\"262\":1,\"265\":8,\"269\":1,\"283\":1}}],[\"reader\",{\"1\":{\"245\":1,\"253\":5,\"269\":6,\"270\":4,\"283\":2}}],[\"reduce\",{\"1\":{\"228\":1}}],[\"retry\",{\"1\":{\"264\":1}}],[\"retainall\",{\"1\":{\"180\":1,\"204\":1}}],[\"returns\",{\"1\":{\"41\":1}}],[\"return为\",{\"1\":{\"39\":1}}],[\"return的描述\",{\"1\":{\"39\":1}}],[\"return越短视\",{\"1\":{\"19\":1}}],[\"return\",{\"0\":{\"41\":1,\"153\":1},\"1\":{\"19\":2,\"39\":1,\"41\":3,\"42\":1,\"48\":2,\"78\":1,\"82\":1,\"113\":1,\"137\":1,\"164\":1,\"165\":2,\"171\":3,\"172\":1,\"180\":4,\"182\":3,\"190\":2,\"193\":4,\"204\":1,\"216\":3,\"217\":1,\"221\":3,\"222\":3,\"224\":3,\"241\":7,\"264\":1,\"330\":1,\"340\":1,\"350\":2,\"351\":3,\"355\":1,\"356\":2,\"362\":2,\"392\":2,\"393\":1,\"401\":2,\"417\":2}}],[\"requirenonnull\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1}}],[\"reinforce\",{\"0\":{\"156\":1,\"157\":1},\"1\":{\"156\":1}}],[\"reinforcement\",{\"0\":{\"3\":1}}],[\"representing\",{\"1\":{\"340\":1}}],[\"representation\",{\"1\":{\"130\":2}}],[\"replace\",{\"1\":{\"223\":2}}],[\"replace方法可以快速替换某个映射的值\",{\"1\":{\"223\":1}}],[\"replaceall\",{\"1\":{\"181\":1}}],[\"replay\",{\"0\":{\"143\":1},\"1\":{\"142\":1}}],[\"result\",{\"1\":{\"380\":2}}],[\"resulting\",{\"1\":{\"19\":1}}],[\"reset\",{\"1\":{\"265\":5}}],[\"resource\",{\"1\":{\"249\":1}}],[\"resource语法\",{\"1\":{\"247\":1}}],[\"resize\",{\"0\":{\"217\":1},\"1\":{\"216\":2,\"217\":2}}],[\"respect\",{\"1\":{\"19\":1}}],[\"rewards\",{\"0\":{\"43\":1,\"44\":1},\"1\":{\"20\":1,\"45\":2,\"154\":1}}],[\"reward\",{\"1\":{\"13\":1,\"19\":2,\"20\":2,\"115\":1,\"154\":1}}],[\"rt+2​\",{\"1\":{\"154\":1}}],[\"rt+2​+γrt+3​+\",{\"1\":{\"42\":1}}],[\"rt+1​+rt+2​+⋯+rt+n​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"rt+1​+γq^​\",{\"1\":{\"139\":1}}],[\"rt+1​+γqt​\",{\"1\":{\"116\":1}}],[\"rt+1​+γv^\",{\"1\":{\"138\":2}}],[\"rt+1​+γvt​\",{\"1\":{\"112\":2}}],[\"rt+1​+γa∈a\",{\"1\":{\"140\":1}}],[\"rt+1​+γa∈amax​qt​\",{\"1\":{\"120\":1}}],[\"rt+1​+γamax​q\",{\"1\":{\"119\":1}}],[\"rt+1​+γgt+1​∣st​=s\",{\"1\":{\"42\":1}}],[\"rt+1​\",{\"1\":{\"112\":2,\"116\":1,\"154\":1}}],[\"rt+1​∣st​=s\",{\"1\":{\"42\":2,\"43\":2,\"45\":1}}],[\"rt+1​∣at+1​\",{\"1\":{\"20\":1}}],[\"rt​∣st​\",{\"1\":{\"13\":1}}],[\"rtt\",{\"1\":{\"10\":1}}],[\"5新增了泛型\",{\"1\":{\"415\":1}}],[\"5个变量连续加\",{\"1\":{\"380\":1}}],[\"5555\",{\"1\":{\"363\":1}}],[\"500\",{\"1\":{\"323\":1}}],[\"50\",{\"1\":{\"222\":1,\"299\":1,\"304\":2,\"305\":2,\"318\":1}}],[\"5倍\",{\"1\":{\"182\":1}}],[\"5\",{\"0\":{\"49\":1,\"127\":1,\"141\":1},\"1\":{\"10\":3,\"70\":1,\"171\":3,\"203\":5,\"235\":1,\"236\":1,\"237\":4,\"304\":1,\"329\":2,\"330\":2,\"375\":1,\"376\":1,\"409\":1,\"410\":1,\"415\":2}}],[\"404\",{\"1\":{\"420\":1}}],[\"4000\",{\"1\":{\"331\":1}}],[\"41\",{\"1\":{\"222\":1}}],[\"4\",{\"0\":{\"33\":1,\"46\":1,\"48\":1,\"84\":1,\"99\":1,\"106\":1,\"119\":1,\"120\":1,\"121\":1,\"124\":1,\"140\":1,\"156\":1,\"210\":1,\"211\":1,\"397\":1},\"1\":{\"10\":1,\"70\":1,\"171\":3,\"203\":5,\"228\":1,\"235\":1,\"236\":1,\"237\":4,\"330\":2,\"374\":3,\"375\":1,\"380\":1,\"409\":1,\"410\":1}}],[\"根据上面的推导\",{\"1\":{\"217\":1}}],[\"根据初始化大小\",{\"1\":{\"182\":1}}],[\"根据给定的键\",{\"1\":{\"213\":1}}],[\"根据给定的predicate条件进行元素移除操作\",{\"1\":{\"180\":1}}],[\"根据给定的策略\",{\"1\":{\"112\":1}}],[\"根据这个式子我们就可以通过\",{\"1\":{\"155\":1}}],[\"根据梯度下降的公式\",{\"1\":{\"142\":1}}],[\"根据策略\",{\"1\":{\"78\":1}}],[\"根据策略π\",{\"1\":{\"48\":1}}],[\"根据对应的\",{\"1\":{\"66\":1}}],[\"根据\",{\"1\":{\"53\":2,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"113\":1}}],[\"根据一个\",{\"1\":{\"42\":1}}],[\"根据所给定的用户划分情况\",{\"1\":{\"13\":1}}],[\"根据遗传算法找到cn​个最优个体作为簇的中心\",{\"1\":{\"13\":1}}],[\"根据n个用户\",{\"1\":{\"13\":1}}],[\"根据mos数值\",{\"1\":{\"10\":1}}],[\"根据香农定理\",{\"1\":{\"9\":1}}],[\"可变长参数\",{\"0\":{\"376\":1}}],[\"可是消费者消费的产品是生产者生产的\",{\"1\":{\"331\":1}}],[\"可拆分迭代器\",{\"1\":{\"330\":1}}],[\"可运行\",{\"1\":{\"300\":1}}],[\"可见性\",{\"1\":{\"278\":1}}],[\"可写可不写\",{\"1\":{\"277\":1}}],[\"可能高等数学这门课是以数字成绩进行结算\",{\"1\":{\"415\":1}}],[\"可能会同时拿到同样的值\",{\"1\":{\"311\":1}}],[\"可能会创建各种各样的类\",{\"1\":{\"277\":1}}],[\"可能会出现\",{\"1\":{\"247\":1}}],[\"可能会是乱序的\",{\"1\":{\"214\":1}}],[\"可能是链式存储\",{\"1\":{\"188\":1}}],[\"可知\",{\"1\":{\"9\":1}}],[\"可以对\",{\"1\":{\"410\":1}}],[\"可以对列表中每个元素都进行处理\",{\"1\":{\"181\":1}}],[\"可以简写为\",{\"1\":{\"402\":1}}],[\"可以只跟\",{\"1\":{\"402\":1}}],[\"可以交给\",{\"1\":{\"402\":1}}],[\"可以到\",{\"1\":{\"381\":1}}],[\"可以使用方括号\",{\"1\":{\"381\":1}}],[\"可以匹配\",{\"1\":{\"381\":1}}],[\"可以用来检查一个串是否含有某种子串\",{\"1\":{\"381\":1}}],[\"可以用来衡量一个状态的价值\",{\"1\":{\"40\":1}}],[\"可以保存一个2字节的unicode字符\",{\"1\":{\"378\":1}}],[\"可以传入\",{\"1\":{\"376\":1}}],[\"可以理解为\",{\"1\":{\"354\":1}}],[\"可以将复制一个完全一样的对象出来\",{\"1\":{\"350\":1}}],[\"可以获取到父类的class对象\",{\"1\":{\"343\":1}}],[\"可以有多个方法\",{\"1\":{\"392\":1}}],[\"可以有其他方式判断类型\",{\"1\":{\"343\":1}}],[\"可以有限\",{\"1\":{\"19\":1}}],[\"可以给他传一个时间参数进去的\",{\"1\":{\"318\":1}}],[\"可以判断线程是否存在中断标志\",{\"1\":{\"301\":1}}],[\"可以节省数据空间占用以及减少序列化时间\",{\"1\":{\"290\":1}}],[\"可以返回之前标记过的位置\",{\"1\":{\"265\":1}}],[\"可以返回一个备选的返回值\",{\"1\":{\"214\":1}}],[\"可以更好地管理和操作硬盘上的文件\",{\"1\":{\"255\":1}}],[\"可以写入多个\",{\"1\":{\"251\":1}}],[\"可以写成\",{\"1\":{\"134\":1}}],[\"可以直接通过\",{\"1\":{\"410\":1}}],[\"可以直接使用一个\",{\"1\":{\"415\":1}}],[\"可以直接使用一个while循环来完成\",{\"1\":{\"248\":1}}],[\"可以直接使用lambda表达式\",{\"1\":{\"393\":1}}],[\"可以直接省去花括号和return关键字\",{\"1\":{\"392\":1}}],[\"可以直接写入一个字符串\",{\"1\":{\"270\":1}}],[\"可以直接写入内容\",{\"1\":{\"249\":1}}],[\"可以直接将file作为参数传入字节流或是字符流\",{\"1\":{\"255\":1}}],[\"可以跳过指定数量的字节\",{\"1\":{\"248\":1}}],[\"可以一次直接读取全部数据\",{\"1\":{\"248\":1}}],[\"可以极大提高java程序员的生产力\",{\"1\":{\"228\":1}}],[\"可以让你以一种声明的方式处理数据\",{\"1\":{\"228\":1}}],[\"可以在方法中定义\",{\"1\":{\"388\":1}}],[\"可以在\",{\"1\":{\"203\":1}}],[\"可以得到一个非常规范的结果\",{\"1\":{\"182\":1}}],[\"可以得到一个序列v0​\",{\"1\":{\"47\":1}}],[\"可以表示同样的一组元素\",{\"1\":{\"179\":1}}],[\"可以表示为\",{\"1\":{\"9\":1,\"135\":1}}],[\"可以看到system\",{\"1\":{\"284\":1}}],[\"可以看到跟我们之前的写法是一样的\",{\"1\":{\"215\":1}}],[\"可以看到它不仅仅实现了list接口\",{\"1\":{\"199\":1}}],[\"可以看到\",{\"1\":{\"172\":1,\"181\":1,\"182\":2,\"203\":1,\"205\":1,\"215\":1,\"377\":1}}],[\"可以相同\",{\"1\":{\"165\":1}}],[\"可以是跑步\",{\"1\":{\"356\":1}}],[\"可以是相对路径\",{\"1\":{\"255\":1}}],[\"可以是\",{\"1\":{\"155\":1}}],[\"可以是标量\",{\"1\":{\"101\":1}}],[\"可以根据对各个状态的重要程度进行选择\",{\"1\":{\"152\":1}}],[\"可以最大化一个确定的常数指标\",{\"1\":{\"148\":1}}],[\"可以最开始均初始化为\",{\"1\":{\"47\":1}}],[\"可以描述为\",{\"1\":{\"148\":1}}],[\"可以提高存储效率\",{\"1\":{\"131\":1}}],[\"可以参考\",{\"1\":{\"104\":1}}],[\"可以平衡\",{\"1\":{\"87\":1}}],[\"可以拆分为多个\",{\"1\":{\"81\":1}}],[\"可以通过这个成员内部类又创建出更多对象\",{\"1\":{\"386\":1}}],[\"可以通过\",{\"1\":{\"66\":1}}],[\"可以通过contraction\",{\"1\":{\"58\":1}}],[\"可以通过设置将episodic\",{\"1\":{\"19\":1}}],[\"可以互相转化\",{\"1\":{\"48\":1}}],[\"可以求解\",{\"1\":{\"45\":1}}],[\"可以粗步衡量一个策略的好坏\",{\"1\":{\"19\":1}}],[\"可以忽略\",{\"1\":{\"10\":1}}],[\"可以减轻无人机对用户接收到的干扰\",{\"1\":{\"9\":1}}],[\"≤c2​\",{\"1\":{\"98\":1}}],[\"≤pmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hn​\",{\"1\":{\"9\":1}}],[\"≤\",{\"1\":{\"9\":1}}],[\"ζ2​是系数\",{\"1\":{\"10\":1}}],[\"ζ1​\",{\"1\":{\"10\":1}}],[\"ζ+em\",{\"1\":{\"9\":1}}],[\"ζ是由环境决定的常数\",{\"1\":{\"9\":1}}],[\"19\",{\"1\":{\"409\":1}}],[\"1打印\",{\"1\":{\"304\":1,\"305\":1}}],[\"1static\",{\"1\":{\"354\":1}}],[\"1s\",{\"1\":{\"299\":1}}],[\"166\",{\"1\":{\"363\":1}}],[\"16\",{\"1\":{\"245\":1}}],[\"13\",{\"1\":{\"234\":1}}],[\"18\",{\"1\":{\"162\":1,\"166\":1,\"351\":4,\"354\":1,\"355\":1,\"356\":1}}],[\"180π​\",{\"1\":{\"9\":1}}],[\"100000\",{\"1\":{\"312\":6}}],[\"10000\",{\"1\":{\"311\":2,\"312\":4}}],[\"1000ms\",{\"1\":{\"299\":1}}],[\"1000\",{\"1\":{\"299\":1,\"311\":1,\"312\":4,\"313\":2,\"318\":1,\"319\":1,\"323\":1,\"324\":1,\"329\":4}}],[\"100~100之间的\",{\"1\":{\"228\":1}}],[\"100\",{\"1\":{\"228\":4,\"364\":2,\"402\":1,\"409\":1}}],[\"10\",{\"1\":{\"161\":1,\"166\":1,\"172\":2,\"182\":5,\"203\":4,\"228\":1,\"234\":1,\"236\":2,\"251\":1,\"253\":1,\"305\":1,\"341\":1,\"343\":4,\"362\":5,\"364\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":4,\"391\":1,\"392\":2,\"393\":2,\"402\":2,\"403\":2,\"416\":1}}],[\"10​a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"10​a=a∗a=a∗​\",{\"1\":{\"57\":1}}],[\"1−∣a\",{\"1\":{\"87\":1}}],[\"128~127之间的值自动装箱为integer类型的对象\",{\"1\":{\"362\":1}}],[\"128~127之间的所有值\",{\"1\":{\"362\":1}}],[\"128\",{\"1\":{\"362\":4}}],[\"1234567\",{\"1\":{\"290\":1}}],[\"123456\",{\"1\":{\"289\":1}}],[\"1234\",{\"1\":{\"33\":1}}],[\"120和4\",{\"1\":{\"10\":1}}],[\"1\",{\"0\":{\"19\":1,\"24\":1,\"26\":1,\"30\":1,\"38\":1,\"39\":2,\"40\":1,\"41\":1,\"43\":1,\"53\":1,\"55\":1,\"57\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"70\":1,\"76\":1,\"77\":2,\"78\":1,\"79\":1,\"81\":1,\"86\":1,\"93\":1,\"94\":2,\"96\":1,\"101\":1,\"110\":1,\"112\":1,\"116\":1,\"120\":1,\"131\":1,\"133\":1,\"148\":1,\"150\":1,\"176\":1,\"177\":1,\"264\":1,\"413\":1,\"414\":1},\"1\":{\"10\":1,\"13\":7,\"14\":1,\"19\":1,\"66\":1,\"70\":1,\"79\":2,\"87\":1,\"98\":2,\"101\":1,\"112\":1,\"116\":1,\"171\":4,\"182\":2,\"190\":1,\"207\":2,\"214\":6,\"216\":3,\"217\":2,\"221\":4,\"228\":4,\"235\":1,\"236\":1,\"237\":3,\"248\":3,\"249\":1,\"251\":1,\"253\":1,\"265\":3,\"267\":1,\"330\":2,\"340\":1,\"374\":1,\"375\":2,\"376\":1,\"381\":5,\"401\":1,\"402\":2,\"409\":1,\"410\":1}}],[\"1~2\",{\"1\":{\"10\":1}}],[\"1+σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"1+ns​\",{\"1\":{\"9\":1}}],[\"且同样不能使用\",{\"1\":{\"353\":1}}],[\"且需要被求解出来\",{\"1\":{\"96\":1}}],[\"且最终会收敛到最优策略v∗\",{\"1\":{\"68\":1}}],[\"且\",{\"1\":{\"53\":1,\"87\":1,\"98\":2,\"135\":1,\"144\":1}}],[\"且ζ1​+ζ2​=1\",{\"1\":{\"10\":1}}],[\"且传输率永远都不可能超过信道容量c\",{\"1\":{\"9\":1}}],[\"且无人机向关联用户的发射功率是恒定的\",{\"1\":{\"9\":1}}],[\"信道容量c=b∗log\",{\"1\":{\"9\":1}}],[\"信号模型\",{\"0\":{\"9\":1}}],[\"由线程来响应此中断并进行相应的处理\",{\"1\":{\"301\":1}}],[\"由无人机的位置和它们在最后时隙采取的动作决定\",{\"1\":{\"14\":1}}],[\"由用户的初始位置和运动模型决定\",{\"1\":{\"14\":1}}],[\"由于是\",{\"1\":{\"415\":1}}],[\"由于string的构造方法在创建对象时也会得到一个string类型的结果\",{\"1\":{\"393\":1}}],[\"由于基本数据类型和引用类型不同\",{\"1\":{\"373\":1}}],[\"由于类本身都是继承\",{\"1\":{\"354\":1}}],[\"由于类型擦除机制\",{\"1\":{\"343\":1}}],[\"由于泛型中未定义\",{\"1\":{\"343\":1}}],[\"由于泛型机制上的一些漏洞\",{\"1\":{\"237\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"313\":1}}],[\"由于每个进程都有一个自己的内存空间\",{\"1\":{\"295\":1}}],[\"由于默认导入了系统自带的string类\",{\"1\":{\"277\":1}}],[\"由于外部i\",{\"1\":{\"260\":1}}],[\"由于底层采用哈希表实现\",{\"1\":{\"205\":1}}],[\"由于πk+1​是\",{\"1\":{\"63\":1}}],[\"由于\",{\"1\":{\"48\":1,\"63\":1}}],[\"由于用户在每个时隙都处于漫游状态\",{\"1\":{\"14\":1}}],[\"由于gak\",{\"1\":{\"13\":1}}],[\"由于特定用户的mos与该用户与无人机之间的距离有关\",{\"1\":{\"13\":1}}],[\"由于不同用户对于传输速率的需求是不同的\",{\"1\":{\"10\":1}}],[\"由于不同集群的频谱不同\",{\"1\":{\"9\":1}}],[\"由此进行迭代\",{\"1\":{\"66\":1}}],[\"由此可以根据contraction\",{\"1\":{\"58\":1}}],[\"由此可以推导出一个多步的trajectory\",{\"1\":{\"39\":1}}],[\"由此\",{\"1\":{\"9\":1}}],[\"同名的方法\",{\"1\":{\"354\":1}}],[\"同步代码块内部\",{\"1\":{\"318\":1}}],[\"同一消息根据不同的对象而采用各种不同的方法\",{\"1\":{\"347\":1}}],[\"同一个包下的类\",{\"1\":{\"278\":1}}],[\"同一无人机通过fdma同时为同一集群中的多个用户提供服务\",{\"1\":{\"8\":1}}],[\"同read一样\",{\"1\":{\"249\":1}}],[\"同时告知上一级方法执行出现了问题\",{\"1\":{\"401\":1}}],[\"同时也使得基本类型能够支持对象操作\",{\"1\":{\"361\":1}}],[\"同时也会生成一个class对象存放在内存\",{\"1\":{\"337\":1}}],[\"同时具体实现还需要由主体来实现\",{\"1\":{\"354\":1}}],[\"同时每次打印也是不同的线程在执行\",{\"1\":{\"330\":1}}],[\"同时会释放当前代码块持有的锁\",{\"1\":{\"318\":1}}],[\"同时一直占用锁\",{\"1\":{\"313\":1}}],[\"同时runnable只有一个未实现方法\",{\"1\":{\"296\":1}}],[\"同时保存了插入顺序\",{\"1\":{\"218\":1}}],[\"同时得益于每一个节点都是一个双向链表\",{\"1\":{\"218\":1}}],[\"同上输入流\",{\"1\":{\"249\":1}}],[\"同上\",{\"1\":{\"180\":1,\"350\":4,\"370\":1}}],[\"同理\",{\"1\":{\"19\":1,\"253\":1,\"260\":1}}],[\"同样可以捕获到\",{\"1\":{\"402\":1}}],[\"同样可以用条件概率的形式进行描述\",{\"1\":{\"19\":1}}],[\"同样需要使用\",{\"1\":{\"370\":1}}],[\"同样需要将接口中所有的抽象方法全部实现\",{\"1\":{\"354\":1}}],[\"同样需要给一个\",{\"1\":{\"203\":1}}],[\"同样采用装饰者模式\",{\"1\":{\"286\":1}}],[\"同样不能超过最大值\",{\"1\":{\"217\":1}}],[\"同样是一个comparator\",{\"1\":{\"207\":1}}],[\"同样是只能插入那些不重复的元素\",{\"1\":{\"204\":1}}],[\"同样是仅获取队首元素\",{\"1\":{\"200\":1}}],[\"同样是移除队首元素\",{\"1\":{\"200\":1}}],[\"同样是添加操作\",{\"1\":{\"200\":1}}],[\"同样是list的实现类\",{\"1\":{\"182\":1}}],[\"同样的键只能存在一个\",{\"1\":{\"214\":1}}],[\"同样的\",{\"1\":{\"172\":1,\"180\":1,\"216\":1,\"234\":1,\"274\":2,\"283\":1,\"313\":1,\"362\":1,\"390\":1}}],[\"同样的类型\",{\"1\":{\"171\":1}}],[\"同样地\",{\"1\":{\"48\":1}}],[\"同样\",{\"1\":{\"9\":1,\"99\":1}}],[\"μnlos​\",{\"1\":{\"9\":1}}],[\"μnlos​是表示los和nlos链路的衰减因子\",{\"1\":{\"9\":1}}],[\"μlos​−μnlos​\",{\"1\":{\"9\":1}}],[\"μlos​\",{\"1\":{\"9\":1}}],[\"α是表示路径损耗指数\",{\"1\":{\"9\":1}}],[\"google\",{\"1\":{\"381\":2}}],[\"good\",{\"1\":{\"10\":1}}],[\"given\",{\"1\":{\"296\":1}}],[\"g∣s=s\",{\"1\":{\"113\":1}}],[\"g~​\",{\"1\":{\"104\":1,\"110\":1}}],[\"gd\",{\"1\":{\"101\":1,\"104\":1}}],[\"grow\",{\"1\":{\"182\":1}}],[\"gradient\",{\"0\":{\"100\":1,\"147\":1},\"1\":{\"101\":2,\"148\":1}}],[\"greedy\",{\"0\":{\"85\":1,\"87\":1,\"88\":1},\"1\":{\"53\":1,\"63\":2,\"66\":1,\"70\":2,\"79\":1,\"87\":3}}],[\"g​\",{\"1\":{\"97\":2,\"99\":2}}],[\"gpi\",{\"1\":{\"82\":1}}],[\"generics\",{\"1\":{\"343\":1}}],[\"genericinterface\",{\"1\":{\"343\":2}}],[\"general\",{\"1\":{\"296\":1}}],[\"generalized\",{\"1\":{\"82\":1}}],[\"getmessage\",{\"1\":{\"402\":1}}],[\"getmax\",{\"1\":{\"228\":1}}],[\"getgenericinterfaces\",{\"1\":{\"343\":1}}],[\"getgenericsuperclass\",{\"1\":{\"343\":5}}],[\"getinterfaces\",{\"1\":{\"343\":1}}],[\"getstatus\",{\"1\":{\"356\":2}}],[\"getsuperclass\",{\"1\":{\"343\":2}}],[\"getsimplename\",{\"1\":{\"341\":1}}],[\"getscore\",{\"1\":{\"222\":2}}],[\"getprimitiveclass获取的是原始类型\",{\"1\":{\"340\":1}}],[\"getprimitiveclass\",{\"1\":{\"340\":2}}],[\"getthreadname\",{\"1\":{\"295\":1}}],[\"getthreadinfo\",{\"1\":{\"295\":1}}],[\"getthreadmxbean\",{\"1\":{\"295\":1}}],[\"gettypename\",{\"1\":{\"341\":1,\"343\":1}}],[\"gettype\",{\"1\":{\"222\":1}}],[\"getactualtypearguments\",{\"1\":{\"343\":4}}],[\"getallthreadids\",{\"1\":{\"295\":1}}],[\"getabsolutepath\",{\"1\":{\"255\":1}}],[\"getaverage\",{\"1\":{\"228\":1}}],[\"getencoding\",{\"1\":{\"254\":1}}],[\"getbytes\",{\"1\":{\"249\":2,\"250\":1,\"267\":1}}],[\"getclassloader\",{\"1\":{\"341\":1}}],[\"getclass\",{\"1\":{\"241\":4,\"339\":1,\"343\":10,\"350\":2}}],[\"getcount\",{\"1\":{\"228\":1}}],[\"getordefault\",{\"1\":{\"214\":2}}],[\"getkey\",{\"1\":{\"213\":1}}],[\"getlast\",{\"1\":{\"201\":1}}],[\"getfirst\",{\"1\":{\"201\":1}}],[\"getvalue\",{\"1\":{\"172\":3,\"213\":1}}],[\"getname\",{\"1\":{\"164\":1,\"222\":2,\"297\":1,\"323\":1,\"324\":1,\"330\":1,\"331\":2,\"341\":1,\"343\":1,\"350\":1,\"356\":2}}],[\"get\",{\"1\":{\"48\":2,\"181\":1,\"182\":1,\"213\":1,\"214\":3,\"228\":1,\"241\":1,\"267\":1,\"319\":1,\"320\":1}}],[\"g\",{\"1\":{\"78\":3,\"96\":4,\"97\":2,\"98\":1,\"99\":2,\"104\":1,\"110\":2,\"113\":1}}],[\"gt+1​∣st+1​=s\",{\"1\":{\"44\":2}}],[\"gt+1​∣st​=s\",{\"1\":{\"42\":2,\"44\":5,\"45\":1}}],[\"gt​−v^\",{\"1\":{\"137\":1}}],[\"gt​​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"42\":1}}],[\"gt​∣st​=s\",{\"1\":{\"40\":1,\"42\":1,\"48\":3,\"49\":2,\"75\":2,\"77\":1,\"78\":1}}],[\"gt​\",{\"1\":{\"40\":2,\"42\":1,\"78\":1,\"137\":2}}],[\"gt​也是一个随机变量\",{\"1\":{\"39\":1}}],[\"gt​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"39\":1}}],[\"gt​=e\",{\"1\":{\"13\":1}}],[\"gkn​​\",{\"1\":{\"9\":1}}],[\"gain\",{\"1\":{\"9\":1}}],[\"c>\",{\"1\":{\"416\":1}}],[\"ceiling\",{\"1\":{\"364\":1}}],[\"certain\",{\"1\":{\"148\":1}}],[\"c++实现\",{\"1\":{\"340\":1}}],[\"cpdd\",{\"1\":{\"339\":1}}],[\"cpu一般通过时间片轮转调度算法\",{\"1\":{\"295\":1}}],[\"cpu一个核心同时只能处理一件事情\",{\"1\":{\"295\":1}}],[\"currentthread\",{\"1\":{\"297\":2,\"299\":1,\"301\":1,\"323\":1,\"324\":1,\"330\":1,\"331\":2}}],[\"cursor\",{\"1\":{\"190\":1}}],[\"create\",{\"1\":{\"296\":1}}],[\"creates\",{\"1\":{\"296\":1}}],[\"critic\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"ccc\",{\"1\":{\"171\":1}}],[\"clazz3\",{\"1\":{\"339\":1}}],[\"clazz2\",{\"1\":{\"339\":1}}],[\"clazz\",{\"1\":{\"339\":1,\"341\":6}}],[\"class<string\",{\"1\":{\"341\":1}}],[\"class<string>\",{\"1\":{\"339\":1}}],[\"class<integer>\",{\"1\":{\"340\":2}}],[\"class<\",{\"1\":{\"339\":2,\"340\":1,\"343\":1,\"350\":1}}],[\"class对象中包含我们类的一些信息\",{\"1\":{\"337\":1}}],[\"class文件\",{\"1\":{\"337\":1}}],[\"classnotfoundexception\",{\"1\":{\"288\":1,\"290\":1,\"339\":1,\"401\":2}}],[\"class关键字我们会在后面反射中介绍\",{\"1\":{\"237\":1}}],[\"class\",{\"0\":{\"338\":1,\"340\":1,\"341\":1,\"342\":1},\"1\":{\"92\":1,\"161\":1,\"162\":1,\"166\":4,\"171\":1,\"172\":1,\"173\":4,\"180\":1,\"182\":3,\"193\":1,\"199\":1,\"215\":2,\"218\":1,\"222\":1,\"224\":1,\"237\":1,\"241\":4,\"274\":1,\"275\":2,\"277\":3,\"278\":2,\"288\":1,\"289\":1,\"290\":1,\"312\":6,\"322\":2,\"324\":2,\"331\":1,\"339\":4,\"340\":4,\"341\":1,\"343\":16,\"350\":1,\"351\":1,\"353\":2,\"354\":2,\"355\":1,\"356\":2,\"376\":1,\"386\":7,\"387\":2,\"388\":3,\"389\":7,\"390\":4,\"400\":2,\"415\":1,\"416\":2,\"417\":6}}],[\"clonenotsupportedexception\",{\"1\":{\"350\":1,\"355\":2,\"399\":1}}],[\"clone\",{\"1\":{\"350\":2,\"355\":6,\"399\":1,\"401\":1}}],[\"cloneable\",{\"1\":{\"182\":2,\"199\":1,\"215\":1,\"224\":1,\"355\":2}}],[\"close\",{\"1\":{\"247\":1,\"264\":2}}],[\"closed\",{\"1\":{\"47\":1}}],[\"clear\",{\"1\":{\"180\":1,\"204\":1,\"213\":1,\"324\":1}}],[\"collocations\",{\"1\":{\"232\":1}}],[\"collectors\",{\"1\":{\"228\":3}}],[\"collect\",{\"1\":{\"228\":3}}],[\"collections\",{\"0\":{\"231\":1,\"232\":1},\"1\":{\"233\":2,\"234\":1,\"235\":1,\"236\":3,\"237\":2}}],[\"collection\",{\"1\":{\"181\":2,\"204\":3,\"212\":1}}],[\"collection<v>\",{\"1\":{\"213\":1}}],[\"collection<\",{\"1\":{\"180\":4,\"181\":1,\"204\":4}}],[\"collection<e>\",{\"1\":{\"180\":1,\"181\":1,\"200\":1,\"204\":1}}],[\"copyofarrays\",{\"1\":{\"410\":1}}],[\"copyof\",{\"1\":{\"171\":1,\"182\":1}}],[\"comment\",{\"1\":{\"324\":1}}],[\"comments\",{\"1\":{\"70\":1}}],[\"com\",{\"1\":{\"277\":8,\"278\":1,\"356\":6,\"377\":1,\"381\":1,\"389\":4,\"390\":2}}],[\"compiled\",{\"1\":{\"356\":1}}],[\"computeifabsent\",{\"1\":{\"221\":2}}],[\"computeifpresent\",{\"1\":{\"221\":2}}],[\"compute\",{\"1\":{\"221\":3}}],[\"comparable\",{\"1\":{\"234\":1}}],[\"comparator\",{\"1\":{\"181\":1,\"203\":1}}],[\"comparator<\",{\"1\":{\"181\":1}}],[\"comparator<integer>\",{\"1\":{\"171\":2}}],[\"compareandset\",{\"1\":{\"264\":1}}],[\"compare方法要求返回一个int来表示两个数的大小关系\",{\"1\":{\"171\":1}}],[\"compare\",{\"1\":{\"171\":2}}],[\"code>\",{\"1\":{\"296\":3}}],[\"code\",{\"0\":{\"426\":1},\"1\":{\"340\":2},\"2\":{\"167\":1,\"174\":1,\"183\":1,\"195\":1,\"208\":1,\"225\":1,\"229\":1,\"238\":1,\"242\":1,\"256\":1,\"271\":1,\"279\":1,\"291\":1,\"306\":1,\"314\":1,\"325\":1,\"332\":1,\"344\":1,\"357\":1,\"365\":1,\"382\":1,\"394\":1,\"404\":1,\"411\":1,\"418\":1}}],[\"coefficient\",{\"1\":{\"97\":1}}],[\"core\",{\"1\":{\"52\":1}}],[\"consumes\",{\"1\":{\"324\":1}}],[\"consumer<\",{\"1\":{\"189\":1,\"192\":1,\"193\":1}}],[\"constructor\",{\"1\":{\"296\":1}}],[\"consider\",{\"1\":{\"58\":1}}],[\"considered\",{\"1\":{\"4\":1}}],[\"converges\",{\"1\":{\"98\":1}}],[\"convergence\",{\"1\":{\"58\":1}}],[\"convex问题\",{\"1\":{\"11\":1}}],[\"contract\",{\"1\":{\"296\":1}}],[\"contractive\",{\"1\":{\"58\":1}}],[\"contraction\",{\"1\":{\"53\":2,\"58\":2,\"62\":1}}],[\"containsvalue\",{\"1\":{\"213\":1}}],[\"containskey\",{\"1\":{\"213\":1}}],[\"containsall\",{\"1\":{\"180\":1,\"204\":1}}],[\"contains\",{\"1\":{\"180\":1,\"204\":1}}],[\"continuing\",{\"1\":{\"19\":1}}],[\"concepts\",{\"1\":{\"52\":1}}],[\"cache\",{\"1\":{\"362\":1}}],[\"calls\",{\"1\":{\"324\":1}}],[\"called\",{\"1\":{\"19\":1,\"81\":1,\"86\":1,\"296\":1}}],[\"causes\",{\"1\":{\"296\":1}}],[\"cast\",{\"1\":{\"341\":1}}],[\"cased\",{\"1\":{\"264\":1}}],[\"case\",{\"1\":{\"264\":1}}],[\"cas无锁算法\",{\"1\":{\"264\":1}}],[\"catch\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"329\":2,\"331\":2,\"402\":10}}],[\"capacity\",{\"1\":{\"182\":2,\"217\":5}}],[\"carlo\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"cancel\",{\"1\":{\"324\":1}}],[\"cancelled\",{\"1\":{\"324\":1}}],[\"canexecute\",{\"1\":{\"255\":1}}],[\"canwrite\",{\"1\":{\"255\":1}}],[\"canread\",{\"1\":{\"255\":1}}],[\"can\",{\"1\":{\"41\":1,\"48\":2}}],[\"checkedxxx可以将给定集合类进行包装\",{\"1\":{\"237\":1}}],[\"checkedlist\",{\"1\":{\"237\":1}}],[\"chiness\",{\"1\":{\"222\":3}}],[\"choose\",{\"1\":{\"20\":1}}],[\"chars\",{\"1\":{\"379\":2}}],[\"character>\",{\"1\":{\"416\":1}}],[\"character\",{\"1\":{\"362\":1}}],[\"charat\",{\"1\":{\"228\":2}}],[\"char\",{\"1\":{\"248\":2,\"253\":3,\"262\":1,\"265\":8,\"269\":1,\"283\":1,\"362\":1,\"378\":1,\"379\":1}}],[\"chapter\",{\"1\":{\"62\":1,\"68\":1}}],[\"chain\",{\"1\":{\"19\":1}}],[\"channel\",{\"1\":{\"9\":1}}],[\"cmax​\",{\"1\":{\"14\":1}}],[\"c\",{\"1\":{\"11\":1,\"13\":1,\"180\":4,\"181\":3,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"204\":4,\"228\":1,\"249\":1,\"416\":3}}],[\"cycles\",{\"1\":{\"10\":1}}],[\"c1​和c2​是通过分析web浏览应用程序的实验结果确定的常数\",{\"1\":{\"10\":1}}],[\"c是光速\",{\"1\":{\"9\":1}}],[\"c4πfc​​\",{\"1\":{\"9\":1}}],[\"为子线程的\",{\"1\":{\"320\":1}}],[\"为单位进行读写操作\",{\"1\":{\"245\":2}}],[\"为一个函数方程\",{\"1\":{\"96\":1}}],[\"为状态\",{\"1\":{\"87\":1}}],[\"为什么不去求\",{\"1\":{\"79\":1}}],[\"为什么考虑\",{\"1\":{\"75\":1}}],[\"为什么这个迭代算法最终可以找到最优策略\",{\"1\":{\"68\":1}}],[\"为discounted\",{\"1\":{\"39\":1}}],[\"为t时刻的mos评分\",{\"1\":{\"10\":1}}],[\"为了解决以上问题\",{\"1\":{\"415\":1}}],[\"为了统计学生成绩\",{\"1\":{\"415\":1}}],[\"为了在创建匿名对象时进行属性初始化\",{\"1\":{\"390\":1}}],[\"为了在los信道概率和路径损耗之间取得平衡\",{\"1\":{\"9\":1}}],[\"为了优化效率\",{\"1\":{\"379\":1}}],[\"为了避免上面的这个现象\",{\"1\":{\"312\":1}}],[\"为了使得线程资源分配更加合理\",{\"1\":{\"302\":1}}],[\"为了防止意外将之前的键值对覆盖掉\",{\"1\":{\"214\":1}}],[\"为了简便\",{\"1\":{\"191\":1}}],[\"为了兼容之前的java版本\",{\"1\":{\"173\":1}}],[\"为了支持小数加法\",{\"1\":{\"165\":1}}],[\"为了让右边取到最大值的情况\",{\"1\":{\"57\":1}}],[\"为了进行\",{\"1\":{\"47\":1}}],[\"为了应对具有无限步的trajectory的return=∞的情况\",{\"1\":{\"19\":1}}],[\"为了保证所有用户都能连接到网络\",{\"1\":{\"9\":1}}],[\"为了满足不同用户传输速率要求\",{\"1\":{\"9\":1}}],[\"为\",{\"1\":{\"9\":1,\"42\":2,\"46\":1,\"78\":1,\"148\":1}}],[\"为指标\",{\"1\":{\"5\":1}}],[\"​≐a∈a∑​π\",{\"1\":{\"153\":1}}],[\"​≐g\",{\"1\":{\"99\":1}}],[\"​q^​\",{\"1\":{\"142\":3}}],[\"​tderrorδt​​\",{\"1\":{\"112\":1}}],[\"​forthegreedyaction\",{\"1\":{\"87\":1}}],[\"​vu​u2​pu​\",{\"1\":{\"70\":1}}],[\"​vu​u1​pu​π2\",{\"1\":{\"70\":1}}],[\"​p\",{\"1\":{\"48\":1}}],[\"​​−αt​\",{\"1\":{\"112\":1}}],[\"​​=currentestimatevt​\",{\"1\":{\"112\":1}}],[\"​​=a∑​qπ​\",{\"1\":{\"48\":1}}],[\"​​+η∇w​f\",{\"1\":{\"104\":1}}],[\"​​π\",{\"1\":{\"48\":1}}],[\"​​\",{\"1\":{\"45\":1,\"66\":1,\"104\":2,\"112\":1}}],[\"​=π\",{\"1\":{\"155\":1}}],[\"​=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"​=▽w​e\",{\"1\":{\"136\":1}}],[\"​=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"​=vt​\",{\"1\":{\"112\":1}}],[\"​=∇w​f\",{\"1\":{\"104\":1}}],[\"​=w−e\",{\"1\":{\"110\":1}}],[\"​=w−x​=w−x+e\",{\"1\":{\"99\":1}}],[\"​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"​=a∑​π\",{\"1\":{\"43\":1,\"44\":1}}],[\"​=rπk​​+γpπk​​vπk​\",{\"1\":{\"68\":1}}],[\"​=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"​=s∈s∑​η\",{\"1\":{\"155\":1}}],[\"​=s\",{\"1\":{\"44\":1}}],[\"​=e\",{\"1\":{\"42\":1,\"45\":1}}],[\"​=es∼η\",{\"1\":{\"26\":1}}],[\"​=ϕ\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"​ifmosnew​>mosold​ifmosnew​=mosold​ifmosnew​<mosold​​\",{\"1\":{\"13\":1}}],[\"​≥0\",{\"1\":{\"11\":1,\"13\":1}}],[\"​≥γkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"​−μlos​−μnlos​μnlos​​​s\",{\"1\":{\"9\":1}}],[\"​\",{\"1\":{\"9\":3,\"10\":1,\"11\":1,\"13\":1,\"26\":1,\"42\":1,\"44\":2,\"45\":1,\"46\":1,\"48\":2,\"55\":1,\"63\":1,\"66\":5,\"68\":1,\"77\":1,\"81\":2,\"87\":1,\"94\":1,\"104\":2,\"112\":1,\"116\":1,\"120\":1,\"136\":1,\"142\":1,\"153\":1,\"155\":2,\"156\":1}}],[\"​hn​\",{\"1\":{\"9\":1}}],[\"builder\",{\"1\":{\"380\":8}}],[\"bufupdater\",{\"1\":{\"264\":1}}],[\"buf\",{\"1\":{\"264\":2}}],[\"bufferedwriter\",{\"1\":{\"268\":1,\"270\":2}}],[\"bufferedreader\",{\"1\":{\"268\":1,\"269\":6,\"283\":1}}],[\"bufferedoutputstream\",{\"1\":{\"267\":2}}],[\"bufferedinputstream\",{\"1\":{\"262\":4,\"265\":18,\"266\":3}}],[\"buffer\",{\"0\":{\"143\":1},\"1\":{\"142\":1,\"264\":3}}],[\"byte类型的包装类也有类似的机制\",{\"1\":{\"362\":1}}],[\"bytes\",{\"1\":{\"248\":4,\"251\":3}}],[\"byte\",{\"1\":{\"248\":3,\"251\":2,\"264\":1,\"362\":2}}],[\"b是当前要计算的参数\",{\"1\":{\"228\":1}}],[\"break\",{\"1\":{\"216\":2,\"301\":1,\"324\":1}}],[\"broad\",{\"1\":{\"92\":1}}],[\"bigdecimal\",{\"1\":{\"364\":6}}],[\"biginteger\",{\"1\":{\"364\":10}}],[\"binarysearch\",{\"1\":{\"234\":1}}],[\"bincount\",{\"1\":{\"216\":2}}],[\"bit\",{\"1\":{\"10\":2}}],[\"bbb\",{\"1\":{\"171\":1,\"200\":1,\"201\":1,\"380\":1}}],[\"bgd\",{\"0\":{\"106\":1},\"1\":{\"101\":1}}],[\"baidu\",{\"1\":{\"277\":3}}],[\"batch\",{\"1\":{\"101\":1,\"142\":2}}],[\"based\",{\"0\":{\"88\":1},\"1\":{\"77\":1,\"82\":1,\"147\":2,\"156\":1}}],[\"baseline\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"25\":1,\"26\":2,\"27\":1}}],[\"basic\",{\"0\":{\"76\":1},\"1\":{\"80\":1,\"81\":1,\"88\":1}}],[\"bob\",{\"1\":{\"381\":2}}],[\"boolean\",{\"1\":{\"180\":11,\"181\":1,\"182\":2,\"189\":1,\"193\":1,\"194\":2,\"200\":2,\"201\":4,\"204\":9,\"213\":4,\"216\":2,\"224\":1,\"241\":2,\"324\":1,\"350\":1,\"351\":1,\"362\":2}}],[\"bootstrapping\",{\"1\":{\"45\":1}}],[\"boe\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"58\":1}}],[\"b\",{\"1\":{\"26\":1,\"165\":4,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"203\":2,\"207\":2,\"221\":2,\"228\":5,\"362\":6,\"376\":1,\"386\":2,\"393\":5,\"401\":3,\"416\":4,\"417\":1}}],[\"bkn​​=bn​\",{\"1\":{\"9\":1}}],[\"b2​\",{\"1\":{\"9\":1}}],[\"b2​pnlos​=1−plos​\",{\"1\":{\"9\":1}}],[\"b1​\",{\"1\":{\"9\":2}}],[\"become\",{\"1\":{\"324\":1}}],[\"behave\",{\"1\":{\"324\":1}}],[\"behavior\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"135\":1}}],[\"bean\",{\"1\":{\"295\":3}}],[\"before\",{\"1\":{\"218\":1}}],[\"bellman\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"46\":2,\"47\":1,\"49\":2,\"52\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"be\",{\"1\":{\"4\":1,\"41\":1,\"296\":1}}],[\"ppp\",{\"1\":{\"390\":1}}],[\"pp\",{\"1\":{\"390\":2,\"391\":2}}],[\"ppolicy\",{\"1\":{\"124\":1}}],[\"python等等都是支持正则表达式的\",{\"1\":{\"381\":1}}],[\"pattern\",{\"1\":{\"381\":1}}],[\"paths\",{\"1\":{\"267\":1}}],[\"parameterizedtype\",{\"1\":{\"343\":7}}],[\"parallelsort\",{\"1\":{\"330\":1}}],[\"parallelstream就是利用了可拆分迭代器进行多线程操作\",{\"1\":{\"330\":1}}],[\"parallelstream\",{\"1\":{\"180\":1,\"330\":3}}],[\"package\",{\"1\":{\"277\":3,\"355\":1,\"389\":3,\"390\":2}}],[\"pair\",{\"1\":{\"79\":1,\"81\":6,\"82\":1,\"84\":2,\"86\":1}}],[\"present\",{\"1\":{\"224\":1}}],[\"previousindex\",{\"1\":{\"194\":1}}],[\"previous\",{\"1\":{\"194\":1}}],[\"prev\",{\"1\":{\"182\":4}}],[\"predicate<\",{\"1\":{\"180\":1}}],[\"primitive\",{\"1\":{\"340\":2}}],[\"priority\",{\"1\":{\"302\":4}}],[\"priorityqueue<>\",{\"1\":{\"202\":1,\"203\":2}}],[\"print\",{\"1\":{\"372\":2,\"409\":1}}],[\"printstream也永远不会抛出异常\",{\"1\":{\"284\":1}}],[\"printstream也继承自filteroutputstream类\",{\"1\":{\"284\":1}}],[\"printstream\",{\"1\":{\"284\":3}}],[\"printstacktrace\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"329\":2,\"331\":1,\"402\":1}}],[\"println\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"351\":2,\"353\":1,\"354\":2,\"355\":4,\"356\":1,\"362\":3,\"363\":1,\"364\":2,\"371\":1,\"375\":1,\"376\":1,\"377\":1,\"379\":6,\"380\":3,\"381\":2,\"386\":5,\"387\":1,\"388\":1,\"389\":7,\"390\":3,\"391\":1,\"392\":3,\"393\":2,\"402\":3,\"409\":1,\"410\":1,\"416\":1}}],[\"private\",{\"1\":{\"171\":2,\"172\":3,\"182\":5,\"222\":3,\"224\":2,\"278\":2,\"289\":1,\"290\":1,\"311\":1,\"312\":7,\"324\":3,\"331\":3,\"350\":1,\"351\":1,\"353\":2,\"356\":2,\"386\":2,\"387\":1,\"388\":1,\"392\":1,\"401\":2,\"402\":2}}],[\"profession\",{\"1\":{\"353\":4}}],[\"produces\",{\"1\":{\"324\":1}}],[\"protected\",{\"1\":{\"278\":2,\"350\":2,\"353\":7,\"390\":1,\"399\":1,\"401\":1}}],[\"problems\",{\"1\":{\"92\":1}}],[\"probability\",{\"1\":{\"19\":1,\"20\":4,\"86\":1,\"98\":1,\"133\":1}}],[\"property\",{\"1\":{\"20\":1}}],[\"proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件\",{\"1\":{\"9\":1}}],[\"proposition1\",{\"1\":{\"9\":1}}],[\"proposed\",{\"1\":{\"4\":1}}],[\"process\",{\"0\":{\"20\":1},\"1\":{\"20\":1,\"135\":1}}],[\"p2\",{\"1\":{\"161\":1,\"351\":3}}],[\"p1\",{\"1\":{\"161\":2,\"351\":3}}],[\"puttreeval\",{\"1\":{\"216\":1}}],[\"putval\",{\"1\":{\"216\":2}}],[\"putifabsent\",{\"1\":{\"214\":2}}],[\"putall\",{\"1\":{\"213\":1}}],[\"put\",{\"0\":{\"216\":1},\"1\":{\"213\":1,\"214\":5,\"216\":1,\"221\":4,\"223\":3,\"241\":1,\"331\":1}}],[\"push\",{\"1\":{\"201\":3}}],[\"public\",{\"1\":{\"161\":4,\"162\":2,\"166\":4,\"171\":8,\"172\":6,\"173\":5,\"180\":3,\"181\":1,\"182\":15,\"187\":2,\"189\":1,\"190\":2,\"191\":2,\"192\":1,\"193\":5,\"194\":1,\"199\":1,\"200\":2,\"201\":2,\"202\":1,\"203\":2,\"204\":1,\"205\":3,\"206\":1,\"207\":2,\"213\":1,\"214\":4,\"215\":2,\"216\":1,\"221\":1,\"222\":5,\"223\":3,\"224\":5,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":9,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":2,\"277\":5,\"278\":6,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":2,\"289\":1,\"290\":2,\"295\":1,\"296\":3,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":6,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":6,\"323\":2,\"324\":5,\"329\":2,\"330\":2,\"331\":2,\"339\":1,\"340\":2,\"341\":1,\"343\":11,\"350\":10,\"351\":3,\"353\":8,\"354\":9,\"355\":6,\"356\":13,\"362\":5,\"363\":1,\"364\":2,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":1,\"375\":1,\"376\":5,\"377\":1,\"379\":3,\"380\":3,\"381\":2,\"386\":15,\"387\":5,\"388\":5,\"389\":9,\"390\":12,\"391\":2,\"392\":3,\"393\":8,\"400\":4,\"401\":1,\"402\":4,\"403\":1,\"409\":2,\"410\":1,\"415\":3,\"416\":9,\"417\":7}}],[\"pu\",{\"1\":{\"70\":1}}],[\"pig\",{\"1\":{\"319\":1}}],[\"pid\",{\"1\":{\"313\":1}}],[\"pi\",{\"1\":{\"66\":1,\"68\":1,\"70\":1}}],[\"people\",{\"1\":{\"288\":9,\"289\":2,\"290\":9}}],[\"penguin\",{\"1\":{\"267\":1,\"284\":1,\"288\":1,\"319\":1,\"354\":1,\"389\":1,\"390\":4}}],[\"peeklast\",{\"1\":{\"201\":1}}],[\"peekfirst\",{\"1\":{\"201\":1}}],[\"peek\",{\"1\":{\"200\":1}}],[\"person\",{\"1\":{\"161\":8,\"162\":3,\"166\":8,\"274\":3,\"277\":1,\"278\":2,\"351\":10,\"353\":3,\"354\":1,\"355\":1,\"376\":5}}],[\"periods\",{\"1\":{\"10\":1}}],[\"pe\",{\"1\":{\"66\":2,\"68\":1,\"70\":1,\"77\":1}}],[\"pπ​\",{\"1\":{\"46\":1}}],[\"pπ​∈rn×n\",{\"1\":{\"46\":1}}],[\"p\",{\"1\":{\"19\":1,\"20\":3,\"41\":2,\"44\":1,\"45\":2,\"63\":2,\"75\":1,\"77\":4,\"98\":1,\"161\":4,\"162\":4,\"216\":10}}],[\"pkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"pkn​​=pmax​\",{\"1\":{\"9\":1}}],[\"pow\",{\"1\":{\"409\":1}}],[\"power\",{\"1\":{\"9\":1}}],[\"pop\",{\"1\":{\"201\":3}}],[\"polllast\",{\"1\":{\"201\":1}}],[\"pollfirst\",{\"1\":{\"201\":1}}],[\"poll\",{\"1\":{\"200\":3,\"203\":6,\"331\":1}}],[\"policies\",{\"1\":{\"85\":1,\"87\":2}}],[\"policy版本\",{\"1\":{\"140\":1}}],[\"policyevaluation\",{\"1\":{\"77\":1}}],[\"policy\",{\"0\":{\"29\":1,\"31\":1,\"53\":1,\"65\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"86\":1,\"87\":1,\"88\":1,\"121\":2,\"122\":1,\"123\":1,\"126\":1,\"147\":1},\"1\":{\"19\":2,\"20\":1,\"23\":2,\"45\":1,\"47\":1,\"52\":1,\"53\":2,\"63\":3,\"66\":2,\"68\":1,\"69\":1,\"70\":11,\"71\":2,\"76\":1,\"77\":1,\"79\":4,\"82\":3,\"86\":2,\"87\":2,\"88\":1,\"111\":1,\"115\":1,\"120\":1,\"121\":2,\"122\":2,\"123\":4,\"124\":3,\"125\":2,\"144\":1,\"147\":2,\"148\":1}}],[\"poicy\",{\"0\":{\"125\":1}}],[\"point\",{\"1\":{\"58\":1}}],[\"positive\",{\"1\":{\"86\":1,\"97\":1}}],[\"possible\",{\"1\":{\"41\":1}}],[\"poor\",{\"1\":{\"10\":1}}],[\"pm​ax​\",{\"1\":{\"9\":1}}],[\"pmax​≥γσ2k0​dkn​​α\",{\"1\":{\"9\":1}}],[\"plos​μlos​+pnlos​μnlos​\",{\"1\":{\"9\":1}}],[\"plos​\",{\"1\":{\"9\":1}}],[\"−2\",{\"1\":{\"142\":2}}],[\"−q^​\",{\"1\":{\"139\":1,\"140\":1,\"141\":1,\"142\":3}}],[\"−v^\",{\"1\":{\"133\":1,\"134\":2,\"135\":2,\"136\":4,\"138\":1}}],[\"−vπk​\",{\"1\":{\"66\":1}}],[\"−tdtargetvt​ˉ​\",{\"1\":{\"112\":1}}],[\"−αt​\",{\"1\":{\"112\":1,\"116\":1,\"120\":1}}],[\"−\",{\"1\":{\"110\":1,\"112\":1,\"116\":1,\"120\":1}}],[\"−x\",{\"1\":{\"99\":1}}],[\"−xkn​​\",{\"1\":{\"8\":1}}],[\"−e\",{\"1\":{\"99\":1,\"104\":2}}],[\"−f\",{\"1\":{\"58\":1}}],[\"−b\",{\"1\":{\"26\":1}}],[\"−0\",{\"1\":{\"13\":1}}],[\"−1rπk​​\",{\"1\":{\"68\":1}}],[\"−1rπ​\",{\"1\":{\"47\":1}}],[\"−1rπ​​\",{\"1\":{\"47\":1}}],[\"−1\",{\"1\":{\"9\":1,\"10\":2,\"13\":4}}],[\"−ykn​​\",{\"1\":{\"8\":1}}],[\"+e\",{\"1\":{\"402\":1}}],[\"+test\",{\"1\":{\"386\":1}}],[\"+this\",{\"1\":{\"386\":1}}],[\"+name\",{\"1\":{\"386\":2}}],[\"+name+\",{\"1\":{\"162\":1}}],[\"+表示对前面这个字符匹配一次或多次\",{\"1\":{\"381\":1}}],[\"+=\",{\"1\":{\"380\":1}}],[\"+a\",{\"1\":{\"392\":5}}],[\"+array\",{\"1\":{\"371\":1}}],[\"+age+\",{\"1\":{\"162\":1}}],[\"+i\",{\"1\":{\"299\":1,\"304\":2,\"305\":2,\"330\":1}}],[\"++size\",{\"1\":{\"216\":1}}],[\"++modcount\",{\"1\":{\"216\":1}}],[\"++bincount\",{\"1\":{\"216\":1}}],[\"+η▽w​f\",{\"1\":{\"104\":1}}],[\"+η​\",{\"1\":{\"99\":1,\"110\":1}}],[\"+ηk​\",{\"1\":{\"97\":1}}],[\"+γs\",{\"1\":{\"46\":1,\"77\":1}}],[\"+γe\",{\"1\":{\"42\":1,\"45\":1}}],[\"+rtt−rkn​​\",{\"1\":{\"10\":1}}],[\"+c2​\",{\"1\":{\"10\":1}}],[\"+ζ2​moskn​​rate\",{\"1\":{\"10\":1}}],[\"+\",{\"1\":{\"8\":1,\"99\":1,\"110\":1,\"165\":2,\"182\":3,\"190\":1,\"205\":1,\"206\":1,\"222\":4,\"228\":1,\"296\":1,\"330\":1,\"331\":6,\"350\":2,\"362\":1,\"372\":1,\"380\":5,\"381\":2,\"389\":1,\"393\":1,\"409\":1}}],[\"yield\",{\"1\":{\"304\":1}}],[\"yoni\",{\"1\":{\"222\":3}}],[\"yt​\",{\"1\":{\"142\":1}}],[\"yt​≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yt​−q^​\",{\"1\":{\"142\":2}}],[\"y≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yuser​\",{\"1\":{\"14\":2}}],[\"yuav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"yd​+1\",{\"1\":{\"13\":1}}],[\"yd​\",{\"1\":{\"13\":1}}],[\"yn​\",{\"1\":{\"8\":2}}],[\"ykn​​\",{\"1\":{\"8\":1}}],[\"x之内的随机数\",{\"1\":{\"409\":1}}],[\"xss\",{\"1\":{\"228\":1}}],[\"xxxexception\",{\"1\":{\"402\":2}}],[\"xxxxx\",{\"1\":{\"377\":1}}],[\"xx\",{\"1\":{\"228\":1}}],[\"xi​\",{\"1\":{\"101\":2}}],[\"xk+1​=f\",{\"1\":{\"58\":1}}],[\"xk​→x∗\",{\"1\":{\"58\":1}}],[\"xk​\",{\"1\":{\"58\":2,\"101\":1,\"104\":1,\"110\":1}}],[\"xkn​​\",{\"1\":{\"8\":1}}],[\"x∗\",{\"1\":{\"58\":1}}],[\"x=f\",{\"1\":{\"58\":1}}],[\"x2​\",{\"1\":{\"58\":1,\"75\":1}}],[\"x1​\",{\"1\":{\"58\":1}}],[\"x\",{\"1\":{\"58\":2,\"75\":1,\"94\":1,\"99\":10,\"101\":6,\"104\":17,\"110\":9}}],[\"xuser​\",{\"1\":{\"14\":2}}],[\"xuav​\",{\"1\":{\"13\":1,\"14\":2}}],[\"xt​=⎩⎨⎧​1\",{\"1\":{\"13\":1}}],[\"xd​+1\",{\"1\":{\"13\":1}}],[\"xd​\",{\"1\":{\"13\":1}}],[\"xn​\",{\"1\":{\"8\":2,\"75\":1}}],[\"=========================\",{\"1\":{\"393\":1}}],[\"====================================\",{\"1\":{\"392\":2}}],[\"=================\",{\"1\":{\"393\":1}}],[\"====​n→∞lim​n1​e\",{\"1\":{\"154\":1}}],[\"==\",{\"1\":{\"182\":2,\"216\":9,\"217\":1,\"241\":6,\"299\":1,\"304\":1,\"305\":1,\"340\":1,\"343\":1,\"350\":1,\"351\":2,\"355\":1,\"362\":3,\"379\":3,\"401\":2}}],[\"=θt​+αe\",{\"1\":{\"156\":1}}],[\"=dtvπ​\",{\"1\":{\"150\":1}}],[\"=i=1∑n​yt​−q^​\",{\"1\":{\"142\":1}}],[\"=−2e\",{\"1\":{\"136\":1}}],[\"=−c1​ln\",{\"1\":{\"10\":1}}],[\"=∣s∣1​s∈s∑​\",{\"1\":{\"134\":1}}],[\"=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"=vt​\",{\"1\":{\"112\":1}}],[\"=vπ0​​\",{\"1\":{\"70\":1}}],[\"=w−\",{\"1\":{\"110\":1}}],[\"=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"=wk​−αk​e\",{\"1\":{\"101\":1}}],[\"=wk​−αk​\",{\"1\":{\"99\":1,\"110\":1}}],[\"=▽w​j\",{\"1\":{\"104\":1}}],[\"=g\",{\"1\":{\"97\":1,\"104\":1}}],[\"=k1​\",{\"1\":{\"94\":1}}],[\"=k0​−1dkn​​−α\",{\"1\":{\"9\":1}}],[\"=n1​∑i=1n​xi​\",{\"1\":{\"94\":1}}],[\"=1\",{\"1\":{\"79\":1,\"135\":1,\"150\":1}}],[\"=argmaxπ​∑a​π\",{\"1\":{\"79\":1}}],[\"=argmaxa​qπk​​\",{\"1\":{\"66\":1}}],[\"=argmaxa​qk​\",{\"1\":{\"63\":1}}],[\"=a∑​πk​\",{\"1\":{\"66\":1}}],[\"=a∑​π\",{\"1\":{\"43\":1,\"44\":3,\"45\":1,\"48\":1,\"113\":1}}],[\"=πargmax​a∑​πk​\",{\"1\":{\"66\":1}}],[\"=πargmax​a∑​π\",{\"1\":{\"63\":1}}],[\"=πmax​\",{\"1\":{\"61\":1,\"62\":1}}],[\"=x∗\",{\"1\":{\"58\":1}}],[\"=x\",{\"1\":{\"58\":1}}],[\"=maxa​qk​\",{\"1\":{\"63\":1}}],[\"=maxπ​\",{\"1\":{\"58\":1}}],[\"=maxπ​∑a​π\",{\"1\":{\"57\":1}}],[\"=mean\",{\"1\":{\"45\":1}}],[\"=∑a​π\",{\"1\":{\"49\":1}}],[\"=∑a​qπ​\",{\"1\":{\"48\":1}}],[\"=∑r​p\",{\"1\":{\"48\":1}}],[\"=r∑​rp\",{\"1\":{\"153\":1}}],[\"=r∑​p\",{\"1\":{\"77\":1}}],[\"=rπ​\",{\"1\":{\"46\":1}}],[\"=rt+1​+γgt+1​​\",{\"1\":{\"42\":1}}],[\"=rt+1​+γ\",{\"1\":{\"42\":1}}],[\"=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"=s∈s∑​dπ​\",{\"1\":{\"135\":1}}],[\"=s\",{\"1\":{\"44\":3}}],[\"=sin−1\",{\"1\":{\"9\":1}}],[\"=es∼d\",{\"1\":{\"155\":1}}],[\"=es∼d​\",{\"1\":{\"153\":1,\"155\":1}}],[\"=es∼η\",{\"1\":{\"26\":1}}],[\"=e\",{\"1\":{\"40\":1,\"42\":2,\"48\":1,\"49\":2,\"75\":2,\"77\":1,\"78\":1,\"101\":1,\"104\":4,\"113\":3,\"115\":1,\"119\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"151\":1,\"153\":1,\"155\":1}}],[\"=0\",{\"1\":{\"26\":1,\"96\":1,\"98\":2,\"99\":1,\"104\":2,\"110\":1}}],[\"=p\",{\"1\":{\"20\":2}}],[\"=3rtt+rkn​​\",{\"1\":{\"10\":1}}],[\"=ζ1​moskn​​delay\",{\"1\":{\"10\":1}}],[\"=γk0​σ2dkn​​α\",{\"1\":{\"9\":1}}],[\"=b2​ln\",{\"1\":{\"9\":1}}],[\"=bkn​​log2​\",{\"1\":{\"9\":1}}],[\"=b1​\",{\"1\":{\"9\":1}}],[\"=σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"=\",{\"1\":{\"8\":1,\"19\":1,\"57\":1,\"63\":1,\"66\":1,\"87\":1,\"99\":1,\"110\":1,\"155\":1,\"161\":6,\"162\":3,\"164\":2,\"166\":16,\"171\":9,\"172\":8,\"173\":1,\"180\":4,\"181\":3,\"182\":26,\"187\":4,\"190\":3,\"191\":3,\"192\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"215\":1,\"216\":20,\"217\":14,\"221\":1,\"222\":5,\"223\":3,\"224\":2,\"228\":12,\"233\":1,\"234\":1,\"235\":1,\"236\":3,\"237\":4,\"241\":12,\"247\":4,\"248\":6,\"249\":2,\"250\":1,\"251\":5,\"253\":3,\"254\":1,\"255\":4,\"262\":1,\"264\":5,\"265\":2,\"266\":1,\"267\":1,\"269\":3,\"270\":1,\"274\":1,\"277\":1,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":5,\"289\":2,\"290\":6,\"295\":3,\"297\":2,\"299\":4,\"301\":1,\"302\":1,\"304\":4,\"305\":4,\"311\":5,\"312\":19,\"313\":4,\"318\":4,\"319\":3,\"320\":2,\"322\":4,\"323\":1,\"324\":4,\"329\":5,\"330\":2,\"331\":3,\"339\":3,\"340\":1,\"341\":1,\"343\":14,\"351\":5,\"353\":4,\"354\":4,\"355\":2,\"356\":3,\"362\":10,\"363\":3,\"364\":6,\"370\":6,\"371\":1,\"372\":2,\"373\":8,\"374\":3,\"375\":1,\"376\":1,\"379\":10,\"380\":13,\"381\":2,\"386\":11,\"387\":2,\"388\":2,\"389\":1,\"390\":4,\"391\":3,\"392\":5,\"393\":6,\"402\":3,\"403\":1,\"409\":2,\"410\":1,\"415\":5,\"416\":13,\"417\":4}}],[\"html\",{\"1\":{\"381\":1}}],[\"https\",{\"1\":{\"381\":1}}],[\"h\",{\"1\":{\"364\":2}}],[\"high\",{\"1\":{\"362\":1}}],[\"hugecapacity\",{\"1\":{\"182\":1}}],[\"huav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"hello\",{\"1\":{\"162\":2,\"171\":2,\"267\":1,\"379\":6,\"388\":1}}],[\"hash\",{\"1\":{\"215\":1,\"216\":13,\"218\":2,\"241\":1}}],[\"hashmap的一个链表长度过大时\",{\"1\":{\"217\":1}}],[\"hashmap并不是只使用简单的链地址法\",{\"1\":{\"215\":1}}],[\"hashmap支持自动扩容\",{\"1\":{\"215\":1}}],[\"hashmap<e\",{\"1\":{\"224\":1}}],[\"hashmap<k\",{\"1\":{\"215\":1}}],[\"hashmap<>\",{\"1\":{\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"224\":1,\"241\":1}}],[\"hashmap\",{\"0\":{\"214\":1,\"215\":1},\"1\":{\"205\":1,\"206\":1,\"214\":1,\"215\":2,\"218\":3,\"224\":3}}],[\"hashset<e>\",{\"1\":{\"224\":1}}],[\"hashset<>\",{\"1\":{\"205\":3}}],[\"hashset\",{\"0\":{\"205\":1,\"224\":1},\"1\":{\"205\":1,\"224\":5}}],[\"hashcode\",{\"1\":{\"180\":1,\"204\":1,\"213\":1,\"241\":7,\"350\":3}}],[\"hasprevious\",{\"1\":{\"194\":1}}],[\"hasnext\",{\"1\":{\"180\":1,\"181\":1,\"187\":1,\"189\":3,\"191\":1,\"193\":1,\"194\":1}}],[\"has\",{\"1\":{\"58\":1}}],[\"hard问题\",{\"1\":{\"13\":1}}],[\"hard\",{\"1\":{\"5\":1}}],[\"hybrid\",{\"1\":{\"14\":1}}],[\"hmax​−hmin​+1\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​moskn​​\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​∑t=0ts​​moskn​​\",{\"1\":{\"11\":1}}],[\"hmax​\",{\"1\":{\"8\":1,\"13\":1}}],[\"hmin​≤hn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"hmin​\",{\"1\":{\"8\":1,\"13\":1}}],[\"∈\",{\"1\":{\"8\":1}}],[\"飞行速度恒定\",{\"1\":{\"8\":1}}],[\"其子类的对应的方法的访问权限需要高于抽象类中的方法\",{\"1\":{\"353\":1}}],[\"其实枚举类型的本质就是一个普通的类\",{\"1\":{\"356\":1}}],[\"其实也就是基本类型的class\",{\"1\":{\"340\":1}}],[\"其实本质上是定义在对应的包装类中的\",{\"1\":{\"340\":1}}],[\"其实就是一个多线程执行的流\",{\"1\":{\"330\":1}}],[\"其实就是编写要在另一个线程执行的内容逻辑\",{\"1\":{\"296\":1}}],[\"其实我们可以看到\",{\"1\":{\"290\":1}}],[\"其实system\",{\"1\":{\"284\":1}}],[\"其实和bufferedinputstream原理差不多\",{\"1\":{\"267\":1}}],[\"其实mark\",{\"1\":{\"265\":1}}],[\"其实功能和write一样\",{\"1\":{\"254\":1}}],[\"其他很多语言比如javascript\",{\"1\":{\"381\":1}}],[\"其他定义方法\",{\"1\":{\"370\":1}}],[\"其他地方不能修改\",{\"1\":{\"352\":1}}],[\"其他线程都无法访问被它占用的锁\",{\"1\":{\"313\":1}}],[\"其他的情况会在讲到反射时介绍\",{\"1\":{\"275\":1}}],[\"其他的算法\",{\"1\":{\"156\":1}}],[\"其他情况e都是null\",{\"1\":{\"216\":1}}],[\"其他视图操作\",{\"1\":{\"213\":1}}],[\"其他集合类实现\",{\"0\":{\"202\":1}}],[\"其他遍历\",{\"0\":{\"192\":1}}],[\"其他元素一律移除\",{\"1\":{\"180\":1}}],[\"其变量名存储的是对象的引用\",{\"1\":{\"161\":1}}],[\"其求解梯度比较难求\",{\"1\":{\"142\":1}}],[\"其定义都是一个均值\",{\"1\":{\"92\":1}}],[\"其探索性就很强\",{\"1\":{\"87\":1}}],[\"其属于\",{\"1\":{\"87\":1}}],[\"其原始定义都是从期望出发的\",{\"1\":{\"75\":1}}],[\"其核心思想是\",{\"1\":{\"75\":1}}],[\"其对应的\",{\"1\":{\"63\":1,\"343\":1}}],[\"其策略π表示的是最优策略\",{\"1\":{\"55\":1}}],[\"其目标也应该不一样\",{\"1\":{\"13\":1}}],[\"其状态为其3d坐标\",{\"1\":{\"13\":1}}],[\"其高度的下界是距离dkn​​\",{\"1\":{\"9\":1}}],[\"其每个用户带宽表示为\",{\"1\":{\"9\":1}}],[\"其可用带宽为bn​\",{\"1\":{\"9\":1}}],[\"其水平坐标表示为qn​\",{\"1\":{\"8\":1}}],[\"其垂直高度表示为hn​\",{\"1\":{\"8\":1}}],[\"其坐标表示为wkn​​=\",{\"1\":{\"8\":1}}],[\"其中存放的每一个数据称为数组的一个元素\",{\"1\":{\"369\":1}}],[\"其中能够表示数字的基本类型包装类\",{\"1\":{\"362\":1}}],[\"其中public和abstract关键字可以省略\",{\"1\":{\"354\":1}}],[\"其中的\",{\"1\":{\"277\":1}}],[\"其中最突出的就是直接根据下标位置进行的增删改查操作\",{\"1\":{\"181\":1}}],[\"其中很多地方重新定义了一次\",{\"1\":{\"181\":1}}],[\"其中st​是随机变量s的一个样本\",{\"1\":{\"136\":1}}],[\"其中w∈rm是参数向量\",{\"1\":{\"131\":1}}],[\"其中hk​=wk​\",{\"1\":{\"98\":1}}],[\"其中ak∗​=argmaxa​qπk​​\",{\"1\":{\"79\":1}}],[\"其中ak∗​\",{\"1\":{\"63\":1}}],[\"其中a∗表示在该状态下计算出来的最大\",{\"1\":{\"57\":1}}],[\"其中vk​是给定的\",{\"1\":{\"63\":1}}],[\"其中f\",{\"1\":{\"58\":1}}],[\"其中cmax​表示用户的最大速度\",{\"1\":{\"14\":1}}],[\"其中\",{\"1\":{\"9\":1,\"10\":2,\"46\":1,\"66\":1,\"87\":1,\"96\":1,\"97\":1,\"101\":1,\"110\":1,\"112\":1,\"113\":1,\"116\":1,\"135\":1,\"141\":1,\"148\":1,\"153\":1,\"155\":1,\"199\":1,\"381\":1}}],[\"其中σ2=bkn​​n0​\",{\"1\":{\"9\":1}}],[\"其中k就是键的类型\",{\"1\":{\"213\":1}}],[\"其中k0​=\",{\"1\":{\"9\":1}}],[\"其中kn​表示划分到集群n的用户\",{\"1\":{\"8\":1}}],[\"其中θkn​​\",{\"1\":{\"9\":1}}],[\"其中用户表示为k=k1​\",{\"1\":{\"8\":1}}],[\"在编写代码的时候就能明确泛型的类型\",{\"1\":{\"416\":1}}],[\"在编译阶段就需要进行处理\",{\"1\":{\"399\":1}}],[\"在编译阶段无法感知代码是否会出现问题\",{\"1\":{\"399\":1}}],[\"在new的时候\",{\"1\":{\"390\":1}}],[\"在内部类中使用this关键字\",{\"1\":{\"386\":1}}],[\"在成员内部类中\",{\"1\":{\"386\":1}}],[\"在成员变量初始化之后执行\",{\"1\":{\"166\":1}}],[\"在c中就是一个字符数组\",{\"1\":{\"378\":1}}],[\"在collection接口中重复定义了一次\",{\"1\":{\"193\":1}}],[\"在运行时动态创建\",{\"1\":{\"370\":1}}],[\"在运行时同样会进行类型检查\",{\"1\":{\"237\":1}}],[\"在修改后\",{\"1\":{\"351\":1}}],[\"在回收之前\",{\"1\":{\"350\":1}}],[\"在这种情况下\",{\"1\":{\"343\":1}}],[\"在这里\",{\"1\":{\"87\":1}}],[\"在类加载过程的同时\",{\"1\":{\"338\":1}}],[\"在加载过程中\",{\"1\":{\"337\":1}}],[\"在arrays数组工具类中\",{\"1\":{\"330\":1}}],[\"在集合跟接口collection中提供了一个spliterator\",{\"1\":{\"330\":1}}],[\"在守护线程中产生的新线程也是守护的\",{\"1\":{\"329\":1}}],[\"在构造时自动启动\",{\"1\":{\"324\":1}}],[\"在指定时间内\",{\"1\":{\"318\":1}}],[\"在指定位置上插入元素\",{\"1\":{\"181\":1}}],[\"在使用时同样需要跟上<>并在其中填写明确要使用的类型\",{\"1\":{\"416\":1}}],[\"在使用完成一个流之后\",{\"1\":{\"247\":1}}],[\"在使线程暂停的同时\",{\"1\":{\"313\":1}}],[\"在执行完毕后会自动释放这把锁\",{\"1\":{\"312\":1}}],[\"在执行一个动作后获得的一个常数\",{\"1\":{\"19\":1}}],[\"在写回主内存时就会发生冲突\",{\"1\":{\"311\":1}}],[\"在继续当前内容\",{\"1\":{\"305\":1}}],[\"在i==10时\",{\"1\":{\"305\":1}}],[\"在让位之后\",{\"1\":{\"304\":1}}],[\"在sleep代码中可以发现\",{\"1\":{\"300\":1}}],[\"在java程序启动时\",{\"1\":{\"337\":1}}],[\"在java中\",{\"1\":{\"295\":1}}],[\"在jdk1\",{\"1\":{\"247\":1}}],[\"在早期的计算机中\",{\"1\":{\"295\":1}}],[\"在一些jdk内部的源码中\",{\"1\":{\"290\":1}}],[\"在序列化时\",{\"1\":{\"289\":1}}],[\"在我们后续的操作中\",{\"1\":{\"289\":1}}],[\"在我们自己定义一个构造方法之后\",{\"1\":{\"166\":1}}],[\"在当前包以外的其他包中无法访问\",{\"1\":{\"278\":1}}],[\"在当前状态s下\",{\"1\":{\"48\":1}}],[\"在当前状态s下采取动作\",{\"1\":{\"48\":1}}],[\"在不同包下的类\",{\"1\":{\"277\":1}}],[\"在放入包中\",{\"1\":{\"277\":1}}],[\"在静态方法中\",{\"1\":{\"274\":1}}],[\"在下次读取时\",{\"1\":{\"260\":1}}],[\"在重写\",{\"1\":{\"241\":1}}],[\"在外面花钱请别人帮你写公司的业务\",{\"1\":{\"224\":1}}],[\"在插入键值对时\",{\"1\":{\"218\":1}}],[\"在红黑树中插入新的结点\",{\"1\":{\"216\":1}}],[\"在实现接口或是继承父类时\",{\"1\":{\"417\":1}}],[\"在实现\",{\"1\":{\"205\":1}}],[\"在实际运行时\",{\"1\":{\"237\":1}}],[\"在实际情况中\",{\"1\":{\"27\":1}}],[\"在实际应用中\",{\"1\":{\"9\":1}}],[\"在队尾进行移除操作\",{\"1\":{\"201\":1}}],[\"在队尾进行插入操作\",{\"1\":{\"201\":1}}],[\"在队首进行移除操作\",{\"1\":{\"201\":1}}],[\"在队首进行插入操作\",{\"1\":{\"201\":1}}],[\"在双端队列中\",{\"1\":{\"201\":1}}],[\"在遍历过程中\",{\"1\":{\"194\":1}}],[\"在什么使用使用arraylist和linkedlist\",{\"1\":{\"182\":1}}],[\"在数组的对象头中有一个\",{\"1\":{\"182\":1}}],[\"在list接口中\",{\"1\":{\"181\":1}}],[\"在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法\",{\"1\":{\"171\":1}}],[\"在赋值之前看看是否有初始值\",{\"1\":{\"166\":1}}],[\"在创建了对象之后\",{\"1\":{\"161\":1}}],[\"在状态s采用动作a\",{\"1\":{\"153\":1}}],[\"在该策略下的所有\",{\"1\":{\"148\":1}}],[\"在该文中考虑的是网页浏览应用传输情况\",{\"1\":{\"10\":1}}],[\"在该文中\",{\"1\":{\"10\":1}}],[\"在原文是\",{\"1\":{\"144\":1}}],[\"在训练求解梯度时\",{\"1\":{\"142\":1}}],[\"在每一次迭代时\",{\"1\":{\"142\":1}}],[\"在初始化时会调用一次\",{\"1\":{\"217\":1}}],[\"在初始化的时候是设为相同的\",{\"1\":{\"142\":1}}],[\"在初始时间假设用户处于静止下不断调整\",{\"1\":{\"5\":1}}],[\"在将\",{\"1\":{\"142\":1}}],[\"在计算\",{\"1\":{\"142\":1}}],[\"在通过经验来更新这个策略\",{\"1\":{\"122\":1}}],[\"在之前关于使用\",{\"1\":{\"105\":1}}],[\"在收集到了足够多的\",{\"1\":{\"82\":1}}],[\"在求解\",{\"1\":{\"71\":1}}],[\"在策略更新上\",{\"1\":{\"70\":1}}],[\"在策略梯度算法中引入一个\",{\"1\":{\"26\":1}}],[\"在\",{\"1\":{\"25\":1,\"68\":2,\"86\":1,\"138\":1,\"142\":1,\"182\":2,\"192\":1,\"205\":1,\"213\":1,\"352\":1,\"390\":1,\"401\":1}}],[\"在policy是确定的情况下\",{\"1\":{\"20\":1}}],[\"在此情况下\",{\"1\":{\"14\":1}}],[\"在本文中\",{\"1\":{\"14\":1}}],[\"在本文中不考虑用户移动到其他集群的情况\",{\"1\":{\"14\":1}}],[\"在设计无人机的移动之前\",{\"1\":{\"14\":1}}],[\"在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为\",{\"1\":{\"9\":1}}],[\"在时间t\",{\"1\":{\"9\":1}}],[\"在任意时刻t\",{\"1\":{\"8\":1}}],[\"27\",{\"1\":{\"354\":1}}],[\"2打印\",{\"1\":{\"304\":1,\"305\":1}}],[\"2种方法\",{\"1\":{\"49\":1}}],[\"2000\",{\"1\":{\"319\":1}}],[\"20\",{\"1\":{\"299\":1,\"391\":1,\"393\":2,\"409\":1}}],[\"20250310170551\",{\"1\":{\"343\":1}}],[\"20250310170039\",{\"1\":{\"343\":1}}],[\"20250310165216\",{\"1\":{\"343\":1}}],[\"20250310160214\",{\"1\":{\"337\":1}}],[\"20250309155822\",{\"1\":{\"319\":1}}],[\"20250226231025\",{\"1\":{\"313\":1}}],[\"20250226223324\",{\"1\":{\"311\":1}}],[\"20250226175843\",{\"1\":{\"297\":1,\"300\":1}}],[\"20250226173747\",{\"1\":{\"295\":1}}],[\"20250225192918\",{\"1\":{\"284\":1}}],[\"20250225181159\",{\"1\":{\"260\":1}}],[\"20241029001425\",{\"1\":{\"399\":1}}],[\"20241027015718\",{\"1\":{\"389\":1}}],[\"20241027015244\",{\"1\":{\"389\":1}}],[\"20241027012950\",{\"1\":{\"386\":1}}],[\"20241017002218\",{\"1\":{\"362\":1}}],[\"20241130012855\",{\"1\":{\"241\":1}}],[\"20241130005736\",{\"1\":{\"237\":1}}],[\"20241130004116\",{\"1\":{\"228\":1}}],[\"20241130001811\",{\"1\":{\"217\":1}}],[\"20241130000528\",{\"1\":{\"215\":1}}],[\"20241127001435\",{\"1\":{\"200\":1}}],[\"20241126232128\",{\"1\":{\"188\":1}}],[\"20241126232114\",{\"1\":{\"188\":1}}],[\"20241120130452\",{\"1\":{\"180\":1,\"193\":1}}],[\"20241106133211\",{\"1\":{\"172\":1}}],[\"20241106133159\",{\"1\":{\"172\":1}}],[\"20241106133117\",{\"1\":{\"172\":1}}],[\"20240826181712\",{\"1\":{\"157\":1}}],[\"20240826181638\",{\"1\":{\"156\":1}}],[\"20240826181538\",{\"1\":{\"156\":1}}],[\"20240826181340\",{\"1\":{\"156\":1}}],[\"20240826180244\",{\"1\":{\"155\":1}}],[\"20240826173749\",{\"1\":{\"151\":1}}],[\"20240820231205\",{\"1\":{\"144\":1}}],[\"20240820231024\",{\"1\":{\"144\":1}}],[\"20240820230944\",{\"1\":{\"143\":1}}],[\"20240820230920\",{\"1\":{\"143\":1}}],[\"20240820230827\",{\"1\":{\"143\":1}}],[\"20240820184405\",{\"1\":{\"140\":1}}],[\"20240820184127\",{\"1\":{\"139\":1}}],[\"20240820181718\",{\"1\":{\"135\":1}}],[\"20240820181406\",{\"1\":{\"135\":1}}],[\"20240815234719\",{\"1\":{\"277\":1}}],[\"20240818182231\",{\"1\":{\"127\":1}}],[\"20240818182301\",{\"1\":{\"127\":1}}],[\"20240818182057\",{\"1\":{\"125\":1}}],[\"20240818181917\",{\"1\":{\"126\":1}}],[\"20240817000409\",{\"1\":{\"118\":1}}],[\"20240817000331\",{\"1\":{\"118\":1}}],[\"20240817000642\",{\"1\":{\"117\":1}}],[\"20240817000601\",{\"1\":{\"117\":1}}],[\"20240817000500\",{\"1\":{\"117\":1}}],[\"20240817000230\",{\"1\":{\"116\":1}}],[\"20240817000134\",{\"1\":{\"116\":1}}],[\"20240817000114\",{\"1\":{\"116\":1}}],[\"20240814230747\",{\"1\":{\"106\":1}}],[\"20240814014058\",{\"1\":{\"103\":1}}],[\"20240812010538\",{\"1\":{\"89\":1}}],[\"20240812011140\",{\"1\":{\"88\":1}}],[\"20240812004534\",{\"1\":{\"83\":1}}],[\"20240811233346\",{\"1\":{\"79\":1}}],[\"20240811011334\",{\"1\":{\"72\":1}}],[\"20240811010933\",{\"1\":{\"71\":1}}],[\"20240811002219\",{\"1\":{\"67\":1}}],[\"20240810190018\",{\"1\":{\"64\":1}}],[\"20240830200624\",{\"1\":{\"33\":1}}],[\"20240830200608\",{\"1\":{\"33\":1}}],[\"20240830200406\",{\"1\":{\"32\":1}}],[\"20240830200343\",{\"1\":{\"31\":1}}],[\"20240830200320\",{\"1\":{\"31\":1}}],[\"20240830200305\",{\"1\":{\"31\":1}}],[\"20240830200248\",{\"1\":{\"31\":1}}],[\"20240830200138\",{\"1\":{\"30\":1}}],[\"20240830200118\",{\"1\":{\"30\":1}}],[\"20240830200056\",{\"1\":{\"30\":1}}],[\"20240830185629\",{\"1\":{\"28\":1}}],[\"20240830185556\",{\"1\":{\"28\":1}}],[\"20240830185537\",{\"1\":{\"28\":1}}],[\"20240830185324\",{\"1\":{\"27\":1}}],[\"20240830185127\",{\"1\":{\"26\":1}}],[\"20240830184424\",{\"1\":{\"24\":1}}],[\"20240830184330\",{\"1\":{\"24\":1}}],[\"20240830184312\",{\"1\":{\"23\":1}}],[\"20240830184236\",{\"1\":{\"23\":1}}],[\"2019\",{\"1\":{\"3\":1}}],[\"2l−1\",{\"1\":{\"10\":1}}],[\"2mssfs​+1\",{\"1\":{\"10\":1}}],[\"2mss\",{\"1\":{\"10\":1}}],[\"2~3\",{\"1\":{\"10\":1}}],[\"2​\",{\"1\":{\"8\":1}}],[\"2+\",{\"1\":{\"8\":1}}],[\"2\",{\"0\":{\"20\":1,\"25\":1,\"26\":1,\"27\":2,\"28\":1,\"31\":1,\"40\":1,\"42\":1,\"43\":1,\"44\":2,\"45\":1,\"46\":1,\"54\":1,\"55\":1,\"56\":2,\"57\":2,\"58\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":2,\"68\":1,\"71\":1,\"78\":1,\"80\":1,\"81\":1,\"82\":2,\"83\":1,\"84\":1,\"87\":1,\"95\":1,\"96\":1,\"97\":2,\"98\":1,\"99\":1,\"102\":1,\"111\":1,\"112\":1,\"113\":2,\"114\":1,\"117\":1,\"121\":1,\"132\":1,\"133\":1,\"136\":2,\"149\":1,\"150\":1,\"153\":2,\"169\":1,\"170\":1,\"185\":1,\"186\":1,\"265\":1,\"368\":1},\"1\":{\"8\":1,\"9\":1,\"13\":1,\"14\":1,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"70\":1,\"79\":2,\"94\":1,\"97\":1,\"101\":1,\"112\":1,\"116\":1,\"133\":1,\"134\":2,\"135\":2,\"136\":2,\"141\":1,\"142\":2,\"171\":3,\"207\":2,\"214\":2,\"221\":2,\"228\":4,\"234\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":1,\"248\":1,\"269\":1,\"330\":2,\"374\":2,\"375\":2,\"380\":1,\"381\":2,\"409\":1,\"410\":1}}],[\"即之后不能修改\",{\"1\":{\"391\":1}}],[\"即通过\",{\"1\":{\"265\":1}}],[\"即使用初始化块\",{\"1\":{\"390\":1}}],[\"即使是基本类型的数组\",{\"1\":{\"370\":1}}],[\"即使是最大的long类型\",{\"1\":{\"364\":1}}],[\"即使是两个不同的对象\",{\"1\":{\"351\":1}}],[\"即使强制类型转换\",{\"1\":{\"351\":1}}],[\"即使类名相同\",{\"1\":{\"277\":1}}],[\"即使值不同\",{\"1\":{\"214\":1}}],[\"即使先估计了\",{\"1\":{\"79\":1}}],[\"即空指针异常\",{\"1\":{\"161\":1}}],[\"即在运行状态中\",{\"1\":{\"336\":1}}],[\"即在策略\",{\"1\":{\"152\":1}}],[\"即在状态s1​下采用动作a1​获得的奖励r=1的概率\",{\"1\":{\"19\":1}}],[\"即此时策略\",{\"1\":{\"148\":1}}],[\"即此时的discounted\",{\"1\":{\"19\":1}}],[\"即基于一个策略\",{\"1\":{\"135\":1}}],[\"即各个状态的可能性为∣s∣1​\",{\"1\":{\"134\":1}}],[\"即我通过一个策略与环境进行交互生成一系列经验\",{\"1\":{\"123\":1}}],[\"即我通过这个策略与环境进行交互生成一系列经验\",{\"1\":{\"122\":1}}],[\"即函数\",{\"1\":{\"97\":1}}],[\"即不需要完全精确地求出\",{\"1\":{\"82\":1}}],[\"即不具备terminal\",{\"1\":{\"19\":1}}],[\"即对于\",{\"1\":{\"192\":1}}],[\"即对于损失函数中的\",{\"1\":{\"133\":1}}],[\"即对于数据\",{\"1\":{\"80\":1}}],[\"即对于每个状态\",{\"1\":{\"79\":1}}],[\"即对于给定策略\",{\"1\":{\"47\":1}}],[\"即p\",{\"1\":{\"75\":1}}],[\"即j→∞\",{\"1\":{\"66\":1}}],[\"即求解右边的式子\",{\"1\":{\"63\":1}}],[\"即f\",{\"1\":{\"58\":1}}],[\"即a∗=argmaxa​q\",{\"1\":{\"57\":1}}],[\"即可以进行套娃\",{\"1\":{\"266\":1}}],[\"即可以通过梯度下降\",{\"1\":{\"142\":1}}],[\"即可\",{\"1\":{\"57\":1,\"77\":1,\"162\":1,\"313\":1}}],[\"即vπ​\",{\"1\":{\"49\":1}}],[\"即一个trajectory下的discounted\",{\"1\":{\"39\":1}}],[\"即\",{\"1\":{\"26\":1,\"63\":2,\"66\":2,\"68\":1,\"77\":1,\"78\":2,\"94\":1,\"99\":1,\"137\":1,\"161\":1,\"353\":1,\"354\":1,\"373\":1}}],[\"即无记忆的特性\",{\"1\":{\"20\":1}}],[\"即无人机作为空中基站\",{\"1\":{\"8\":1}}],[\"即表示具有终止状态terminal\",{\"1\":{\"19\":1}}],[\"即状态s1​采用动作a1​转到状态s2​的概率\",{\"1\":{\"19\":1}}],[\"即ξ=\",{\"1\":{\"14\":1}}],[\"即xuav​\",{\"1\":{\"13\":1}}],[\"即γ≥γkn​​\",{\"1\":{\"9\":1}}],[\"即需要考虑地面不同用户的具体需求\",{\"1\":{\"4\":1}}],[\"lbw\",{\"1\":{\"290\":1}}],[\"lbwnb\",{\"1\":{\"249\":2,\"283\":1,\"320\":1,\"377\":1,\"393\":2,\"416\":1}}],[\"lb\",{\"1\":{\"250\":1}}],[\"length方法可以求字符串长度\",{\"1\":{\"379\":1}}],[\"length属性是int类型的值\",{\"1\":{\"371\":1}}],[\"length\",{\"1\":{\"182\":1,\"216\":2,\"217\":1,\"228\":1,\"255\":1,\"371\":2,\"372\":1,\"379\":2}}],[\"length字段\",{\"1\":{\"182\":2}}],[\"learning是优化长期目标\",{\"1\":{\"13\":1}}],[\"learning的部署算法不同的是\",{\"1\":{\"14\":1}}],[\"learning的移动算法\",{\"1\":{\"14\":1}}],[\"learning的优化目标是最大化长期收益\",{\"1\":{\"13\":1}}],[\"learning的方案来解决无人机的np\",{\"1\":{\"5\":1}}],[\"learning算法\",{\"1\":{\"13\":1}}],[\"learning\",{\"0\":{\"3\":1,\"109\":1,\"111\":1,\"115\":1,\"119\":1,\"120\":1,\"124\":1,\"137\":1,\"138\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"119\":1,\"120\":1,\"123\":1,\"124\":1,\"141\":1}}],[\"lnπ\",{\"1\":{\"155\":1}}],[\"low\",{\"1\":{\"362\":2}}],[\"loop\",{\"1\":{\"324\":1}}],[\"looptime\",{\"1\":{\"322\":5}}],[\"local\",{\"1\":{\"319\":4,\"320\":4}}],[\"lol\",{\"1\":{\"295\":1}}],[\"load\",{\"1\":{\"215\":1,\"217\":1}}],[\"loadfactor\",{\"1\":{\"215\":2}}],[\"loss\",{\"1\":{\"141\":1}}],[\"long\",{\"1\":{\"135\":1,\"289\":1,\"290\":1,\"295\":1,\"300\":1,\"322\":4,\"350\":2,\"362\":3,\"364\":1}}],[\"lines\",{\"1\":{\"269\":1}}],[\"linkedmap\",{\"1\":{\"224\":1}}],[\"linkedset\",{\"1\":{\"224\":1}}],[\"linkedhashmap中的结点实现\",{\"1\":{\"218\":1}}],[\"linkedhashmap\",{\"0\":{\"218\":1},\"1\":{\"206\":1,\"214\":1,\"218\":2}}],[\"linkedhashset<>\",{\"1\":{\"206\":1}}],[\"linkedhashset\",{\"0\":{\"206\":1},\"1\":{\"206\":2}}],[\"linkedlist<e>\",{\"1\":{\"182\":1,\"199\":1}}],[\"linkedlist<>\",{\"1\":{\"182\":2,\"200\":1,\"201\":1,\"331\":1}}],[\"linkedlist\",{\"1\":{\"182\":3,\"190\":1,\"199\":1,\"200\":1}}],[\"link\",{\"1\":{\"8\":1}}],[\"limit\",{\"1\":{\"228\":3,\"269\":1}}],[\"limiting\",{\"1\":{\"135\":1}}],[\"li\",{\"1\":{\"181\":4}}],[\"listfiles\",{\"1\":{\"255\":1}}],[\"list<test>\",{\"1\":{\"241\":1}}],[\"list<student>\",{\"1\":{\"222\":1}}],[\"list<string>\",{\"1\":{\"182\":6,\"187\":2,\"191\":2,\"192\":1,\"228\":2,\"343\":1}}],[\"list<list<string>>\",{\"1\":{\"182\":1}}],[\"list<integer>\",{\"1\":{\"182\":2,\"228\":3,\"233\":1,\"234\":1,\"235\":1,\"236\":3,\"237\":1,\"330\":1}}],[\"list<e>\",{\"1\":{\"181\":2,\"182\":2,\"199\":1}}],[\"listiterator\",{\"1\":{\"181\":4}}],[\"listiterator<e>\",{\"1\":{\"181\":4,\"194\":1}}],[\"list中可插入重复元素\",{\"1\":{\"181\":1}}],[\"list是一个有序的集合类\",{\"1\":{\"181\":1}}],[\"list\",{\"0\":{\"181\":1},\"1\":{\"180\":2,\"181\":3,\"182\":30,\"187\":4,\"191\":4,\"192\":2,\"228\":31,\"233\":3,\"234\":2,\"235\":3,\"236\":4,\"237\":12,\"241\":4,\"255\":1,\"330\":2,\"343\":2}}],[\"lang包下的类\",{\"1\":{\"409\":1}}],[\"lang包下的\",{\"1\":{\"277\":1}}],[\"lang\",{\"1\":{\"277\":1,\"296\":1,\"339\":1,\"355\":1,\"356\":2}}],[\"lang这个包下的所有类\",{\"1\":{\"277\":1}}],[\"lambda表达式的具体规范\",{\"1\":{\"392\":1}}],[\"lambda表达式\",{\"0\":{\"392\":1}}],[\"lambda\",{\"1\":{\"192\":1,\"391\":1,\"392\":1}}],[\"lastreturned\",{\"1\":{\"190\":1}}],[\"lastret\",{\"1\":{\"190\":1}}],[\"last\",{\"1\":{\"182\":1}}],[\"lastindexof\",{\"1\":{\"181\":1}}],[\"large\",{\"1\":{\"75\":1}}],[\"law\",{\"1\":{\"75\":1}}],[\"l2​=log2​\",{\"1\":{\"10\":1}}],[\"l2​\",{\"1\":{\"10\":1}}],[\"l1​=log2​\",{\"1\":{\"10\":1}}],[\"l1​\",{\"1\":{\"10\":1}}],[\"l=min\",{\"1\":{\"10\":1}}],[\"考虑能否仅用一次\",{\"1\":{\"101\":1}}],[\"考虑一个复杂的均值估计问题\",{\"1\":{\"110\":1}}],[\"考虑一个\",{\"1\":{\"81\":1}}],[\"考虑\",{\"1\":{\"70\":2}}],[\"考虑用户在每个时隙移动的情况\",{\"1\":{\"14\":1}}],[\"考虑以下场景\",{\"1\":{\"13\":1}}],[\"考虑无人机辅助无线网络的下行链路传输\",{\"1\":{\"8\":1}}],[\"考虑qoe\",{\"1\":{\"4\":1}}],[\"的构造方法中我们可以写入原因\",{\"1\":{\"401\":1}}],[\"的变量\",{\"1\":{\"391\":1}}],[\"的匿名类\",{\"1\":{\"390\":1}}],[\"的概念\",{\"1\":{\"312\":1}}],[\"的概率\",{\"1\":{\"20\":2}}],[\"的会保留\",{\"1\":{\"228\":1}}],[\"的处理\",{\"1\":{\"228\":1}}],[\"的源码发现\",{\"1\":{\"224\":1}}],[\"的全部性质\",{\"1\":{\"218\":1}}],[\"的容量\",{\"1\":{\"217\":1}}],[\"的关系\",{\"1\":{\"212\":1}}],[\"的性质\",{\"1\":{\"207\":1}}],[\"的底层实现是由\",{\"1\":{\"215\":1}}],[\"的底层实现\",{\"1\":{\"207\":1}}],[\"的实现\",{\"1\":{\"203\":1}}],[\"的方式去创建一个抽象类或是接口对象\",{\"1\":{\"390\":1}}],[\"的方式使用静态内容\",{\"1\":{\"354\":1}}],[\"的方式\",{\"0\":{\"192\":1}}],[\"的方法进行解决\",{\"1\":{\"142\":1}}],[\"的方法\",{\"1\":{\"29\":1,\"68\":1,\"85\":1,\"147\":2,\"192\":1}}],[\"的排序方法\",{\"1\":{\"171\":1}}],[\"的使用几乎相同\",{\"1\":{\"182\":1}}],[\"的使用和\",{\"1\":{\"182\":1}}],[\"的使用\",{\"0\":{\"164\":1}}],[\"的算法\",{\"1\":{\"156\":1}}],[\"的选择\",{\"0\":{\"152\":1}}],[\"的权重或者分布\",{\"1\":{\"155\":1}}],[\"的权重\",{\"1\":{\"150\":1}}],[\"的加权平均\",{\"1\":{\"150\":1}}],[\"的加权均值\",{\"1\":{\"48\":1}}],[\"的基本步骤\",{\"1\":{\"148\":1}}],[\"的基础上来引入偏置量\",{\"1\":{\"25\":1}}],[\"的文章中\",{\"1\":{\"144\":1}}],[\"的输出是不一样的\",{\"1\":{\"144\":1}}],[\"的输出\",{\"1\":{\"142\":1}}],[\"的参数\",{\"1\":{\"142\":1}}],[\"的就不是有关\",{\"1\":{\"142\":1}}],[\"的梯度时\",{\"1\":{\"142\":1}}],[\"的分布\",{\"1\":{\"135\":1}}],[\"的新形式\",{\"1\":{\"113\":1}}],[\"的定义\",{\"1\":{\"113\":1}}],[\"的定义出发\",{\"1\":{\"77\":1}}],[\"的估计从\",{\"1\":{\"130\":1}}],[\"的估计\",{\"1\":{\"112\":1,\"116\":1}}],[\"的采样\",{\"1\":{\"110\":1}}],[\"的思想\",{\"1\":{\"101\":1}}],[\"的值进行重新计算\",{\"1\":{\"221\":1}}],[\"的值\",{\"1\":{\"99\":1}}],[\"的动作数量\",{\"1\":{\"87\":1}}],[\"的高效利用\",{\"0\":{\"81\":1}}],[\"的一些方法\",{\"0\":{\"220\":1}}],[\"的一些改进\",{\"1\":{\"80\":1}}],[\"的一个观测值\",{\"1\":{\"104\":1}}],[\"的一个\",{\"1\":{\"78\":1}}],[\"的情况下使用\",{\"1\":{\"318\":1}}],[\"的情况下进行估计\",{\"1\":{\"75\":1}}],[\"的情况\",{\"1\":{\"76\":1,\"77\":2,\"104\":1}}],[\"的原理\",{\"1\":{\"76\":1}}],[\"的\",{\"1\":{\"63\":1,\"66\":1,\"77\":1,\"78\":2,\"81\":1,\"84\":1,\"86\":1,\"87\":1,\"111\":1,\"113\":2,\"123\":2,\"124\":2,\"133\":1,\"155\":1,\"187\":1,\"241\":1,\"343\":1,\"354\":1,\"371\":1}}],[\"的策略来进行选择\",{\"1\":{\"66\":1}}],[\"的策略πk+1​\",{\"1\":{\"63\":1}}],[\"的策略所采集的数据来\",{\"1\":{\"29\":1}}],[\"的形式\",{\"1\":{\"58\":1,\"99\":1,\"187\":1,\"393\":2}}],[\"的根据策略π加权平均\",{\"1\":{\"49\":1}}],[\"的转到下一个状态的\",{\"1\":{\"48\":1}}],[\"的过程\",{\"1\":{\"47\":1}}],[\"的计算即可\",{\"1\":{\"42\":1}}],[\"的区别\",{\"0\":{\"41\":1},\"1\":{\"241\":1}}],[\"的期望\",{\"1\":{\"40\":1}}],[\"的s是有范围的\",{\"1\":{\"13\":1}}],[\"的函数\",{\"1\":{\"9\":1,\"142\":1}}],[\"的功率谱密度\",{\"1\":{\"9\":1}}],[\"的无人机3d动态运动设计算法\",{\"1\":{\"5\":1}}],[\"的部署方法\",{\"1\":{\"5\":1}}],[\"以上的方法虽然很好地解决了多种类型存储问题\",{\"1\":{\"415\":1}}],[\"以毫秒为单位\",{\"1\":{\"299\":1}}],[\"以某种格式保存对象\",{\"1\":{\"287\":1}}],[\"以操作writer的样子写入outputstream\",{\"1\":{\"283\":1}}],[\"以字符\",{\"1\":{\"245\":1}}],[\"以字节\",{\"1\":{\"245\":1}}],[\"以set形式返回\",{\"1\":{\"213\":1}}],[\"以及object的方法\",{\"1\":{\"354\":1}}],[\"以及notifyall\",{\"1\":{\"318\":1}}],[\"以及是否可以到最后优化的成果\",{\"1\":{\"101\":1}}],[\"以及\",{\"1\":{\"69\":1,\"88\":1,\"155\":1,\"241\":1,\"381\":2}}],[\"以向用户提供可靠的服务\",{\"1\":{\"9\":1}}],[\"以\",{\"1\":{\"5\":1}}],[\"该咋写咋写\",{\"1\":{\"392\":1}}],[\"该怎么处理\",{\"1\":{\"364\":1}}],[\"该算法中\",{\"1\":{\"122\":1,\"123\":1}}],[\"该算法是\",{\"1\":{\"69\":1}}],[\"该方法成立的数学依据是\",{\"1\":{\"75\":1}}],[\"该步骤是根据\",{\"1\":{\"66\":1}}],[\"该步骤是用来计算当前策略\",{\"1\":{\"66\":1}}],[\"该式子针对状态空间中的所有状态均成立\",{\"1\":{\"45\":1}}],[\"该论文中在精度和模型复杂型上作出平衡\",{\"1\":{\"13\":1}}],[\"该问题依然是np\",{\"1\":{\"13\":1}}],[\"该优化问题是一个non\",{\"1\":{\"11\":1}}],[\"该文中不同集群所利用的频谱是不同的\",{\"1\":{\"9\":1}}],[\"该文中表示为\",{\"1\":{\"9\":1}}],[\"该文提出的算法具较快的收敛性\",{\"1\":{\"5\":1}}],[\"该文基于q\",{\"1\":{\"5\":1}}],[\"该文设计的是3d部署\",{\"1\":{\"4\":1}}],[\"该框架将无人机部署在三维空间内\",{\"1\":{\"5\":1}}],[\"sqrt\",{\"1\":{\"409\":1}}],[\"sql\",{\"1\":{\"228\":1}}],[\"ss\",{\"1\":{\"390\":2}}],[\"short\",{\"1\":{\"362\":3}}],[\"shared\",{\"1\":{\"324\":1}}],[\"syntax\",{\"1\":{\"381\":1}}],[\"synchronized关键字也可以作用于方法上\",{\"1\":{\"312\":1}}],[\"synchronized需要在括号中填入一个内容\",{\"1\":{\"312\":1}}],[\"synchronized\",{\"1\":{\"312\":8,\"313\":4,\"318\":2,\"324\":2,\"331\":2}}],[\"system\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"285\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"351\":2,\"353\":1,\"354\":2,\"355\":4,\"356\":1,\"362\":3,\"363\":1,\"364\":2,\"371\":1,\"372\":2,\"375\":1,\"376\":1,\"377\":1,\"379\":6,\"380\":3,\"381\":2,\"386\":5,\"387\":1,\"388\":1,\"389\":7,\"390\":3,\"391\":1,\"392\":3,\"393\":2,\"402\":3,\"409\":2,\"410\":1,\"416\":1}}],[\"sleep\",{\"1\":{\"299\":1,\"300\":1,\"301\":1,\"311\":1,\"312\":4,\"313\":2,\"318\":1,\"319\":2,\"322\":2,\"329\":4,\"331\":2,\"356\":4}}],[\"slove\",{\"0\":{\"47\":1}}],[\"slow\",{\"1\":{\"10\":1}}],[\"src\",{\"1\":{\"267\":1}}],[\"skip\",{\"1\":{\"248\":2,\"253\":1}}],[\"sdawers\",{\"1\":{\"228\":1}}],[\"splitable\",{\"1\":{\"330\":1}}],[\"split\",{\"1\":{\"228\":1,\"379\":2}}],[\"spliterator也用于遍历数据源中的元素\",{\"1\":{\"330\":1}}],[\"spliteratorunknownsize\",{\"1\":{\"193\":1}}],[\"spliterator<t>\",{\"1\":{\"193\":1}}],[\"spliterator<e>\",{\"1\":{\"180\":1,\"204\":1}}],[\"spliterators\",{\"1\":{\"180\":1,\"193\":1,\"204\":1}}],[\"spliterator\",{\"1\":{\"180\":4,\"193\":1,\"204\":3,\"330\":1}}],[\"space\",{\"1\":{\"13\":2,\"19\":3}}],[\"sub\",{\"1\":{\"379\":2}}],[\"substring\",{\"1\":{\"379\":2}}],[\"sublist\",{\"1\":{\"181\":1}}],[\"sun\",{\"1\":{\"343\":1}}],[\"suspend\",{\"1\":{\"313\":1}}],[\"suppresswarnings\",{\"1\":{\"181\":1,\"217\":1,\"340\":1}}],[\"supposed\",{\"1\":{\"4\":1}}],[\"super\",{\"1\":{\"172\":2,\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1,\"218\":1,\"349\":1,\"351\":3,\"353\":1,\"354\":1,\"355\":2,\"386\":2,\"400\":2}}],[\"summarystatistics\",{\"1\":{\"228\":2}}],[\"sum\",{\"1\":{\"165\":2,\"222\":1,\"228\":2,\"393\":5}}],[\"s∣s\",{\"1\":{\"155\":1}}],[\"s∣a\",{\"1\":{\"57\":1,\"58\":1}}],[\"s∑​dπ​\",{\"1\":{\"154\":1}}],[\"schedule\",{\"1\":{\"323\":1,\"324\":2}}],[\"scanner\",{\"1\":{\"285\":6}}],[\"scalar\",{\"1\":{\"148\":1}}],[\"scoremap\",{\"1\":{\"222\":3}}],[\"score<string>\",{\"1\":{\"416\":3}}],[\"score<>\",{\"1\":{\"172\":3,\"416\":1}}],[\"score<\",{\"1\":{\"172\":3}}],[\"score<t>\",{\"1\":{\"416\":1}}],[\"score<t\",{\"1\":{\"172\":1}}],[\"score\",{\"1\":{\"5\":1,\"172\":6,\"222\":5,\"415\":9,\"416\":4}}],[\"sgdw\",{\"0\":{\"106\":1}}],[\"sgd的目标是\",{\"1\":{\"104\":1}}],[\"sgd\",{\"0\":{\"102\":1,\"104\":1,\"105\":1},\"1\":{\"101\":1,\"104\":3,\"105\":2,\"136\":1,\"155\":1}}],[\"s5​\",{\"1\":{\"81\":1}}],[\"s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​\",{\"1\":{\"81\":4}}],[\"s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​∣s1​\",{\"1\":{\"19\":1}}],[\"see\",{\"1\":{\"296\":1,\"324\":1}}],[\"seely\",{\"1\":{\"222\":3}}],[\"separately\",{\"1\":{\"296\":1}}],[\"serialversionuid\",{\"1\":{\"289\":1,\"290\":1}}],[\"serializable\",{\"1\":{\"182\":2,\"199\":1,\"215\":1,\"224\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"sex\",{\"1\":{\"161\":1,\"162\":1,\"166\":14,\"274\":1,\"278\":1,\"351\":2,\"353\":6,\"354\":2,\"355\":2,\"376\":1}}],[\"sequence\",{\"1\":{\"58\":1}}],[\"setdaemon\",{\"1\":{\"329\":3}}],[\"setpriority\",{\"1\":{\"302\":1}}],[\"setvalue\",{\"1\":{\"213\":1}}],[\"set<map\",{\"1\":{\"213\":1}}],[\"set<k>\",{\"1\":{\"213\":1}}],[\"set<string>\",{\"1\":{\"205\":3,\"206\":1}}],[\"set<e>\",{\"1\":{\"204\":1,\"224\":1}}],[\"set支持的功能其实也就和\",{\"1\":{\"204\":1}}],[\"set集合\",{\"1\":{\"204\":1}}],[\"setname\",{\"1\":{\"164\":2,\"324\":1}}],[\"set\",{\"0\":{\"204\":1},\"1\":{\"20\":3,\"181\":3,\"194\":1,\"204\":2,\"205\":13,\"206\":3,\"207\":13,\"224\":3,\"241\":1,\"319\":2,\"320\":1}}],[\"setstatus\",{\"1\":{\"356\":2}}],[\"sets\",{\"1\":{\"20\":1}}],[\"s​=maxπ​∑a​π\",{\"1\":{\"58\":1}}],[\"sorted\",{\"1\":{\"228\":2,\"269\":1}}],[\"sort\",{\"1\":{\"171\":3,\"181\":2,\"410\":1}}],[\"soloving\",{\"1\":{\"92\":1}}],[\"solution\",{\"1\":{\"47\":2}}],[\"soft\",{\"0\":{\"86\":1},\"1\":{\"85\":1,\"86\":2,\"87\":1}}],[\"someone\",{\"1\":{\"324\":1}}],[\"some\",{\"1\":{\"19\":1,\"116\":1}}],[\"sj​∣si​\",{\"1\":{\"46\":1}}],[\"sn​\",{\"1\":{\"46\":2}}],[\"satic\",{\"1\":{\"351\":1}}],[\"satisfying\",{\"1\":{\"98\":1}}],[\"satisfaction\",{\"1\":{\"4\":1}}],[\"sa​\",{\"1\":{\"116\":2}}],[\"sarsa\",{\"0\":{\"116\":1,\"117\":1,\"118\":1,\"139\":1},\"1\":{\"115\":3,\"116\":1,\"123\":1}}],[\"sa\",{\"1\":{\"92\":2}}],[\"samples\",{\"1\":{\"101\":1,\"142\":1}}],[\"sample\",{\"1\":{\"78\":1,\"99\":1,\"101\":1}}],[\"sampling\",{\"0\":{\"30\":1}}],[\"s0​\",{\"1\":{\"20\":2,\"112\":1}}],[\"s∈s​\",{\"1\":{\"135\":1}}],[\"s∈s\",{\"1\":{\"20\":1,\"63\":1,\"66\":2,\"113\":2}}],[\"s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":2}}],[\"s1​\",{\"1\":{\"46\":2,\"81\":4,\"112\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​→a1​s2​\",{\"1\":{\"19\":1}}],[\"size++\",{\"1\":{\"182\":1}}],[\"size\",{\"1\":{\"180\":1,\"182\":6,\"204\":1,\"213\":1,\"224\":2}}],[\"simplest\",{\"0\":{\"24\":1}}],[\"si​\",{\"1\":{\"19\":2,\"142\":2}}],[\"since\",{\"1\":{\"340\":1}}],[\"singletonlist\",{\"1\":{\"236\":1}}],[\"single\",{\"1\":{\"82\":1,\"154\":1}}],[\"sin\",{\"1\":{\"9\":1}}],[\"s=\",{\"1\":{\"19\":1}}],[\"study<integer>\",{\"1\":{\"417\":1}}],[\"study<t>\",{\"1\":{\"417\":2}}],[\"study\",{\"1\":{\"354\":15,\"355\":2,\"356\":4,\"390\":6,\"391\":3,\"392\":18,\"393\":15}}],[\"student\",{\"1\":{\"222\":14,\"343\":3,\"351\":4,\"354\":2,\"355\":10,\"356\":6,\"390\":5}}],[\"students\",{\"1\":{\"222\":2}}],[\"str5\",{\"1\":{\"380\":4}}],[\"str4\",{\"1\":{\"379\":2,\"380\":4}}],[\"str3\",{\"1\":{\"379\":2,\"380\":4}}],[\"str2\",{\"1\":{\"379\":3,\"380\":4}}],[\"str1\",{\"1\":{\"379\":3,\"380\":4}}],[\"structure\",{\"1\":{\"324\":1}}],[\"stream流\",{\"0\":{\"227\":1,\"228\":1}}],[\"streamsupport\",{\"1\":{\"180\":2,\"330\":1}}],[\"stream\",{\"1\":{\"180\":3,\"228\":11,\"266\":1,\"267\":2,\"284\":2,\"330\":1}}],[\"stream<e>\",{\"1\":{\"180\":2,\"330\":1}}],[\"str\",{\"1\":{\"171\":1,\"182\":7,\"228\":5,\"253\":3,\"343\":4,\"379\":8,\"381\":5}}],[\"string的拼接会在编译时进行各种优化\",{\"1\":{\"380\":1}}],[\"stringbuilder\",{\"0\":{\"380\":1},\"1\":{\"380\":5}}],[\"string类重载了equals方法用于判断和比较内容是否相同\",{\"1\":{\"379\":1}}],[\"string本身也是一个类\",{\"1\":{\"379\":1}}],[\"string>\",{\"1\":{\"214\":4,\"221\":1,\"223\":3}}],[\"strings这个变量就是一个string\",{\"1\":{\"376\":1}}],[\"strings\",{\"1\":{\"171\":3,\"376\":3,\"379\":2}}],[\"string\",{\"0\":{\"379\":1},\"1\":{\"161\":5,\"162\":3,\"164\":3,\"166\":14,\"171\":12,\"172\":8,\"173\":1,\"180\":1,\"182\":11,\"187\":5,\"191\":3,\"192\":1,\"193\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":7,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":6,\"247\":2,\"248\":4,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":4,\"277\":6,\"278\":3,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":3,\"289\":2,\"290\":3,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":2,\"329\":2,\"330\":2,\"331\":3,\"339\":4,\"340\":2,\"341\":2,\"343\":14,\"350\":1,\"353\":8,\"354\":4,\"355\":3,\"356\":5,\"362\":4,\"363\":1,\"364\":2,\"370\":1,\"371\":1,\"372\":1,\"373\":6,\"374\":1,\"375\":1,\"376\":8,\"377\":2,\"379\":18,\"380\":14,\"381\":4,\"386\":10,\"387\":3,\"388\":2,\"389\":2,\"390\":4,\"391\":1,\"392\":3,\"393\":8,\"400\":2,\"402\":4,\"403\":1,\"409\":2,\"410\":1,\"415\":6,\"416\":8,\"417\":3}}],[\"steady\",{\"1\":{\"135\":1}}],[\"step\",{\"0\":{\"117\":1},\"1\":{\"66\":2,\"79\":2,\"154\":1}}],[\"st+2​→at+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+2​→at+2​rt+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​=s\",{\"1\":{\"44\":2}}],[\"st+1​→at+1​rt+2​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​∣at+1​\",{\"1\":{\"20\":3}}],[\"st+1​\",{\"1\":{\"13\":1,\"112\":4,\"116\":2,\"119\":1,\"120\":1,\"138\":2,\"139\":1,\"140\":2}}],[\"st​→at​rt+1​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st​\",{\"1\":{\"20\":4,\"112\":12,\"116\":6,\"120\":5,\"136\":4,\"137\":4,\"138\":3,\"139\":2,\"140\":2,\"156\":1}}],[\"stochastic\",{\"0\":{\"100\":1},\"1\":{\"19\":1,\"53\":1,\"86\":1,\"92\":2}}],[\"stop\",{\"1\":{\"19\":1,\"299\":1,\"300\":1}}],[\"statistics\",{\"1\":{\"228\":4}}],[\"static\",{\"1\":{\"161\":3,\"162\":1,\"171\":6,\"172\":3,\"173\":1,\"180\":1,\"182\":12,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"215\":1,\"218\":1,\"221\":1,\"222\":2,\"223\":3,\"224\":1,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":4,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":5,\"277\":2,\"278\":3,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"288\":2,\"289\":2,\"290\":3,\"295\":1,\"297\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":2,\"312\":10,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":4,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":4,\"339\":1,\"340\":3,\"341\":1,\"343\":9,\"350\":2,\"354\":3,\"355\":1,\"356\":8,\"362\":5,\"363\":1,\"364\":2,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"379\":3,\"380\":3,\"381\":2,\"386\":2,\"387\":2,\"389\":10,\"390\":3,\"391\":1,\"392\":4,\"393\":5,\"401\":3,\"402\":6,\"403\":1,\"409\":2,\"410\":1,\"415\":1,\"416\":3,\"417\":6}}],[\"stationary\",{\"0\":{\"135\":1},\"1\":{\"135\":2,\"152\":1}}],[\"statrts的解释\",{\"0\":{\"84\":1}}],[\"status>\",{\"1\":{\"356\":1}}],[\"status\",{\"1\":{\"19\":1,\"356\":22}}],[\"statevalue\",{\"1\":{\"136\":1}}],[\"states中\",{\"1\":{\"19\":1}}],[\"states中限制action\",{\"1\":{\"19\":1}}],[\"states的任务\",{\"1\":{\"19\":1}}],[\"states的trajectory\",{\"1\":{\"19\":1}}],[\"states\",{\"1\":{\"19\":1,\"20\":1}}],[\"state\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"58\":1,\"111\":1,\"132\":1,\"150\":1},\"1\":{\"13\":2,\"19\":6,\"20\":4,\"37\":1,\"40\":4,\"41\":4,\"42\":1,\"45\":1,\"47\":1,\"48\":6,\"49\":2,\"52\":1,\"55\":1,\"56\":1,\"63\":1,\"66\":2,\"68\":1,\"70\":2,\"71\":1,\"75\":1,\"77\":3,\"79\":3,\"81\":6,\"82\":1,\"84\":2,\"86\":1,\"92\":1,\"111\":1,\"113\":2,\"115\":2,\"131\":1,\"135\":1,\"148\":1,\"150\":2,\"155\":1}}],[\"starts\",{\"0\":{\"80\":1,\"83\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1}}],[\"starting\",{\"1\":{\"41\":1,\"48\":2,\"296\":1}}],[\"start\",{\"1\":{\"10\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"313\":2,\"318\":2,\"319\":2,\"320\":2,\"322\":6,\"324\":1,\"329\":3,\"331\":5}}],[\"s\",{\"0\":{\"152\":1},\"1\":{\"9\":1,\"10\":1,\"11\":1,\"13\":5,\"20\":5,\"26\":4,\"27\":1,\"40\":2,\"41\":1,\"42\":1,\"44\":10,\"45\":7,\"46\":4,\"48\":13,\"49\":4,\"53\":3,\"55\":4,\"57\":2,\"63\":11,\"66\":13,\"75\":3,\"77\":9,\"78\":8,\"79\":4,\"82\":1,\"84\":6,\"87\":6,\"112\":2,\"113\":7,\"115\":2,\"116\":3,\"119\":1,\"120\":3,\"131\":2,\"132\":2,\"133\":3,\"134\":4,\"135\":8,\"136\":7,\"141\":5,\"142\":28,\"150\":6,\"152\":1,\"153\":8,\"154\":2,\"155\":12,\"156\":4,\"187\":4,\"191\":2,\"296\":1,\"340\":1,\"381\":4}}],[\"queue\",{\"1\":{\"200\":5,\"202\":1,\"203\":14,\"324\":11,\"331\":8}}],[\"queue<object>\",{\"1\":{\"331\":1}}],[\"queue<integer>\",{\"1\":{\"203\":2}}],[\"queue<string>\",{\"1\":{\"200\":1,\"202\":1}}],[\"queue<e>\",{\"1\":{\"200\":1,\"201\":1}}],[\"quene\",{\"0\":{\"199\":1,\"200\":1}}],[\"quality\",{\"0\":{\"10\":1},\"1\":{\"4\":1}}],[\"q^​\",{\"1\":{\"142\":5}}],[\"qt​\",{\"1\":{\"116\":2,\"120\":1,\"156\":1}}],[\"qt+1​\",{\"1\":{\"116\":2,\"120\":2}}],[\"qπk​​\",{\"1\":{\"66\":1,\"77\":2,\"78\":2,\"79\":1}}],[\"qπ​\",{\"1\":{\"26\":2,\"48\":3,\"49\":1,\"75\":1,\"115\":1,\"155\":8,\"156\":4}}],[\"qac\",{\"0\":{\"24\":1},\"1\":{\"25\":1}}],[\"q\",{\"0\":{\"120\":1,\"124\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"11\":1,\"13\":2,\"14\":1,\"23\":1,\"49\":1,\"55\":1,\"57\":1,\"58\":1,\"77\":1,\"79\":1,\"81\":2,\"119\":2,\"120\":1,\"123\":1,\"124\":1,\"130\":1,\"141\":1}}],[\"qoe\",{\"1\":{\"4\":1}}],[\"u\",{\"1\":{\"381\":2}}],[\"util包下定义的\",{\"1\":{\"180\":1}}],[\"util\",{\"1\":{\"180\":1,\"409\":2,\"410\":1}}],[\"used\",{\"1\":{\"296\":1}}],[\"uses\",{\"1\":{\"82\":1}}],[\"users\",{\"1\":{\"4\":2}}],[\"u0​pu​π1\",{\"1\":{\"70\":1}}],[\"unmodifiablelist\",{\"1\":{\"236\":1}}],[\"unmanned\",{\"1\":{\"4\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"182\":1,\"189\":1}}],[\"unchecked\",{\"1\":{\"181\":1,\"217\":1,\"340\":1}}],[\"unaryoperator<e>\",{\"1\":{\"181\":1}}],[\"uniform\",{\"0\":{\"134\":1}}],[\"uniqueness\",{\"1\":{\"58\":1}}],[\"update\",{\"1\":{\"23\":1,\"63\":3,\"70\":2}}],[\"uavn\",{\"1\":{\"13\":1}}],[\"uavs\",{\"1\":{\"4\":1,\"5\":1}}],[\"uav\",{\"0\":{\"3\":1,\"422\":1},\"1\":{\"4\":1},\"2\":{\"16\":1}}],[\"o+\",{\"1\":{\"381\":2}}],[\"oooo\",{\"1\":{\"381\":1}}],[\"o操作一般不能重复读取内容\",{\"1\":{\"265\":1}}],[\"o操作的并不是bufferedinputstream\",{\"1\":{\"264\":1}}],[\"o操作时\",{\"1\":{\"248\":1}}],[\"o设备的速度一般都达不到内存的读取速度\",{\"1\":{\"260\":1}}],[\"o设备去获取数据\",{\"1\":{\"260\":1}}],[\"oject类中的\",{\"1\":{\"241\":1}}],[\"oldthr\",{\"1\":{\"217\":4}}],[\"oldtab\",{\"1\":{\"217\":5}}],[\"oldcap\",{\"1\":{\"217\":5}}],[\"oldcapacity\",{\"1\":{\"182\":3}}],[\"oldvalue\",{\"1\":{\"216\":3}}],[\"o中介绍用途\",{\"1\":{\"182\":1}}],[\"o\",{\"1\":{\"172\":2,\"180\":3,\"181\":2,\"182\":3,\"201\":2,\"204\":3,\"213\":1,\"241\":10,\"381\":15,\"416\":1}}],[\"o2\",{\"1\":{\"171\":5,\"313\":3}}],[\"o1就行\",{\"1\":{\"171\":1}}],[\"o1\",{\"1\":{\"171\":5,\"313\":3,\"318\":5}}],[\"override\",{\"1\":{\"171\":2,\"180\":1,\"193\":3,\"204\":1,\"241\":3,\"323\":1,\"324\":1,\"351\":3,\"353\":1,\"354\":1,\"355\":2,\"390\":2,\"391\":1,\"401\":1,\"417\":2}}],[\"outofmemoryerror\",{\"1\":{\"399\":1}}],[\"out也是printstream\",{\"1\":{\"284\":1}}],[\"out就是一个printstream\",{\"1\":{\"284\":2}}],[\"output\",{\"1\":{\"249\":2,\"250\":1,\"251\":1,\"254\":1,\"270\":1,\"286\":1,\"288\":2,\"290\":2}}],[\"outputstreamwriter\",{\"1\":{\"283\":3}}],[\"outputstream\",{\"1\":{\"245\":1,\"249\":6,\"250\":3,\"251\":2,\"288\":3,\"290\":3}}],[\"out\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"171\":4,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":2,\"201\":2,\"203\":6,\"205\":7,\"206\":1,\"207\":2,\"214\":4,\"221\":2,\"222\":1,\"223\":3,\"228\":8,\"234\":1,\"235\":1,\"237\":3,\"241\":2,\"248\":6,\"253\":2,\"255\":9,\"262\":1,\"265\":8,\"269\":3,\"274\":2,\"278\":1,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1,\"295\":1,\"297\":2,\"299\":1,\"301\":2,\"302\":1,\"304\":6,\"305\":6,\"311\":3,\"312\":8,\"313\":2,\"318\":4,\"319\":4,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":2,\"340\":1,\"341\":5,\"343\":15,\"351\":2,\"353\":1,\"354\":2,\"355\":4,\"356\":1,\"362\":3,\"363\":1,\"364\":2,\"371\":1,\"372\":2,\"375\":1,\"376\":1,\"377\":1,\"379\":6,\"380\":3,\"381\":2,\"386\":5,\"387\":1,\"388\":1,\"389\":7,\"390\":3,\"391\":1,\"392\":3,\"393\":2,\"402\":3,\"409\":2,\"410\":1,\"416\":1}}],[\"obj\",{\"1\":{\"350\":2,\"351\":4,\"370\":1}}],[\"object类中的\",{\"0\":{\"355\":1}}],[\"objectinputstream\",{\"1\":{\"288\":2,\"290\":2}}],[\"objective\",{\"1\":{\"134\":2,\"135\":1,\"141\":1,\"142\":1,\"148\":1}}],[\"objectoutputstream\",{\"1\":{\"288\":2,\"290\":2}}],[\"objectoutputstream不仅支持基本数据类型\",{\"1\":{\"287\":1}}],[\"object>\",{\"1\":{\"224\":1}}],[\"objects\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"192\":1,\"193\":1,\"241\":3}}],[\"object\",{\"0\":{\"350\":1},\"1\":{\"172\":2,\"173\":2,\"180\":4,\"181\":4,\"182\":3,\"201\":2,\"204\":4,\"213\":5,\"224\":2,\"241\":4,\"296\":2,\"313\":4,\"318\":3,\"331\":1,\"340\":1,\"350\":4,\"351\":3,\"354\":2,\"355\":1,\"370\":1,\"371\":1,\"373\":5,\"399\":1,\"401\":2,\"402\":3,\"415\":4,\"416\":5}}],[\"obsolete\",{\"1\":{\"324\":2}}],[\"obejctive\",{\"0\":{\"133\":1},\"1\":{\"136\":1}}],[\"obtained\",{\"1\":{\"41\":1}}],[\"other\",{\"1\":{\"53\":1}}],[\"operation\",{\"1\":{\"228\":2}}],[\"operator\",{\"1\":{\"181\":3}}],[\"optimization\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"optimality\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"119\":1}}],[\"optimal\",{\"0\":{\"53\":1,\"119\":1},\"1\":{\"52\":2,\"53\":1,\"120\":1}}],[\"opinion\",{\"1\":{\"5\":1}}],[\"originalepisode\",{\"1\":{\"81\":1}}],[\"or\",{\"1\":{\"19\":1,\"40\":1,\"92\":1,\"112\":1,\"135\":1}}],[\"offerlast\",{\"1\":{\"201\":1}}],[\"offerfirst\",{\"1\":{\"201\":1}}],[\"offer\",{\"1\":{\"200\":3,\"203\":6,\"331\":1}}],[\"off\",{\"0\":{\"29\":1,\"31\":1,\"121\":1,\"123\":1,\"125\":1},\"1\":{\"123\":1,\"124\":1}}],[\"of\",{\"0\":{\"10\":1,\"43\":1,\"44\":1,\"111\":1,\"115\":1,\"119\":1,\"132\":1},\"1\":{\"4\":3,\"10\":1,\"19\":4,\"20\":3,\"40\":1,\"41\":1,\"45\":2,\"58\":1,\"75\":1,\"81\":1,\"82\":1,\"92\":1,\"99\":1,\"119\":1,\"135\":1,\"142\":1,\"296\":1}}],[\"onlyifabsent\",{\"1\":{\"216\":2}}],[\"on\",{\"0\":{\"121\":1,\"122\":1,\"126\":1},\"1\":{\"3\":1,\"123\":1,\"124\":1,\"140\":1,\"144\":1},\"2\":{\"16\":1}}],[\"flush\",{\"1\":{\"249\":1,\"250\":1,\"254\":1,\"270\":1,\"288\":1,\"290\":1}}],[\"flatmap\",{\"1\":{\"228\":1}}],[\"float\",{\"1\":{\"215\":1,\"362\":2}}],[\"files\",{\"1\":{\"267\":1}}],[\"file\",{\"1\":{\"255\":19}}],[\"filenotfoundexception\",{\"1\":{\"247\":1,\"285\":1,\"401\":2}}],[\"filewriter\",{\"1\":{\"245\":1,\"252\":1,\"254\":2,\"270\":1}}],[\"filereader\",{\"1\":{\"245\":1,\"252\":1,\"253\":4,\"269\":3}}],[\"fileoutputstream\",{\"1\":{\"245\":1,\"249\":4,\"250\":2,\"251\":2,\"283\":1,\"284\":1,\"286\":1,\"288\":1,\"290\":1}}],[\"fileinputstream\",{\"1\":{\"245\":1,\"247\":4,\"248\":6,\"251\":2,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"283\":1,\"285\":1,\"286\":1,\"288\":1,\"290\":1}}],[\"fill\",{\"1\":{\"235\":1,\"264\":1,\"410\":1}}],[\"filter\",{\"1\":{\"180\":3,\"228\":4}}],[\"final类型\",{\"1\":{\"371\":1}}],[\"final的status类型成员变量\",{\"1\":{\"356\":1}}],[\"final的\",{\"1\":{\"354\":1}}],[\"finalize\",{\"1\":{\"350\":1}}],[\"finally\",{\"1\":{\"247\":1,\"324\":1,\"402\":1}}],[\"final\",{\"1\":{\"172\":3,\"180\":1,\"181\":1,\"182\":2,\"215\":3,\"216\":1,\"217\":1,\"222\":3,\"224\":1,\"284\":1,\"289\":1,\"290\":1,\"324\":2,\"331\":1,\"340\":1,\"350\":6,\"352\":2,\"356\":5,\"374\":1,\"386\":2,\"387\":1,\"388\":1,\"391\":3}}],[\"finding\",{\"1\":{\"92\":1,\"104\":1,\"110\":1}}],[\"first\",{\"1\":{\"81\":1,\"182\":1}}],[\"fix\",{\"1\":{\"58\":1}}],[\"factor\",{\"1\":{\"215\":1,\"217\":1}}],[\"false\",{\"1\":{\"180\":2,\"182\":1,\"216\":1,\"241\":2,\"286\":1,\"296\":1,\"324\":1,\"351\":2,\"403\":1}}],[\"fastremove\",{\"1\":{\"182\":1}}],[\"fast\",{\"1\":{\"58\":1}}],[\"fair\",{\"1\":{\"10\":1}}],[\"f\",{\"1\":{\"58\":4,\"101\":3,\"104\":1,\"228\":1,\"255\":2}}],[\"fundamental\",{\"1\":{\"52\":1}}],[\"functionalinterface\",{\"1\":{\"296\":1}}],[\"function\",{\"0\":{\"130\":1,\"133\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"40\":1,\"58\":1,\"130\":1,\"134\":2,\"135\":1,\"136\":1,\"141\":1,\"142\":1,\"147\":1,\"148\":1,\"376\":1}}],[\"future\",{\"0\":{\"44\":1},\"1\":{\"45\":1}}],[\"free\",{\"0\":{\"75\":1},\"1\":{\"45\":1,\"76\":1,\"77\":1}}],[\"fromindex\",{\"1\":{\"181\":1}}],[\"from\",{\"1\":{\"41\":1,\"48\":2,\"324\":1,\"356\":1}}],[\"framework\",{\"1\":{\"4\":1}}],[\"found\",{\"1\":{\"420\":1}}],[\"fooooood\",{\"1\":{\"381\":1}}],[\"foooood\",{\"1\":{\"381\":1}}],[\"food\",{\"1\":{\"381\":1}}],[\"foem\",{\"1\":{\"55\":1}}],[\"following\",{\"1\":{\"19\":1}}],[\"forname\",{\"1\":{\"339\":1}}],[\"foreach操作的顺序\",{\"1\":{\"330\":1}}],[\"foreach语法遍历每一个元素\",{\"1\":{\"192\":1}}],[\"foreach\",{\"1\":{\"192\":5,\"193\":2,\"222\":2,\"228\":1,\"269\":1,\"330\":1,\"372\":1}}],[\"foreachremaining\",{\"1\":{\"189\":1}}],[\"forallw\",{\"1\":{\"98\":1}}],[\"foralls∈s\",{\"1\":{\"79\":1}}],[\"fortheother∣a\",{\"1\":{\"87\":1}}],[\"formulation\",{\"0\":{\"105\":1}}],[\"form\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"47\":1,\"49\":2,\"55\":1,\"58\":1,\"63\":1,\"66\":2}}],[\"for\",{\"1\":{\"4\":2,\"20\":1,\"53\":2,\"58\":1,\"181\":1,\"182\":1,\"187\":2,\"191\":1,\"192\":1,\"193\":1,\"216\":1,\"255\":1,\"295\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":10,\"318\":1,\"324\":1,\"329\":2,\"340\":1,\"343\":5,\"372\":3,\"376\":1,\"377\":1,\"379\":1,\"409\":1}}],[\"fs\",{\"1\":{\"10\":1}}],[\"fs​+l\",{\"1\":{\"10\":1}}],[\"fc​是载波频率\",{\"1\":{\"9\":1}}],[\"n个类型变量\",{\"1\":{\"416\":1}}],[\"nanos\",{\"1\":{\"350\":1}}],[\"native\",{\"1\":{\"300\":1,\"340\":1,\"350\":7,\"399\":1}}],[\"named\",{\"1\":{\"340\":1}}],[\"name\",{\"1\":{\"161\":3,\"162\":2,\"164\":7,\"166\":14,\"172\":4,\"222\":5,\"241\":15,\"274\":1,\"278\":1,\"288\":5,\"289\":4,\"290\":5,\"297\":1,\"324\":2,\"331\":4,\"340\":1,\"343\":1,\"351\":2,\"353\":6,\"354\":2,\"355\":2,\"356\":5,\"376\":1,\"386\":14,\"387\":4,\"388\":4,\"389\":2,\"415\":4,\"416\":4}}],[\"non\",{\"1\":{\"324\":1}}],[\"nom\",{\"1\":{\"302\":1}}],[\"notifyall\",{\"1\":{\"331\":1,\"350\":1}}],[\"notifyall其实和notify一样\",{\"1\":{\"318\":1}}],[\"notify\",{\"1\":{\"318\":4,\"350\":1}}],[\"not\",{\"1\":{\"296\":1,\"420\":1}}],[\"node<k\",{\"1\":{\"215\":3,\"216\":3,\"217\":4,\"218\":2}}],[\"node<e>\",{\"1\":{\"182\":7}}],[\"node\",{\"1\":{\"182\":1,\"217\":1}}],[\"novel\",{\"1\":{\"4\":1}}],[\"nullpointerexception\",{\"1\":{\"402\":3}}],[\"null\",{\"1\":{\"161\":1,\"182\":1,\"214\":1,\"216\":10,\"217\":3,\"221\":1,\"241\":2,\"247\":2,\"264\":4,\"284\":1,\"296\":1,\"351\":1,\"364\":1,\"402\":1,\"417\":2}}],[\"number>\",{\"1\":{\"172\":3,\"173\":1}}],[\"numbers\",{\"1\":{\"75\":1}}],[\"number\",{\"1\":{\"10\":1,\"172\":1,\"173\":2,\"343\":1,\"415\":1}}],[\"n→∞lim​n1​e\",{\"1\":{\"154\":2}}],[\"nextint方法可以指定创建0\",{\"1\":{\"409\":1}}],[\"nextint\",{\"1\":{\"409\":1}}],[\"nextindex\",{\"1\":{\"194\":1}}],[\"nextindex++\",{\"1\":{\"190\":1}}],[\"nextthreadnum\",{\"1\":{\"296\":1}}],[\"next\",{\"1\":{\"180\":1,\"181\":2,\"182\":4,\"187\":1,\"189\":3,\"190\":5,\"191\":1,\"193\":1,\"194\":1,\"215\":1,\"216\":2,\"218\":2}}],[\"newline\",{\"1\":{\"270\":1}}],[\"newlist\",{\"1\":{\"236\":2}}],[\"newoutputstream\",{\"1\":{\"267\":1}}],[\"newtasksmaybescheduled\",{\"1\":{\"324\":2}}],[\"newtab\",{\"1\":{\"217\":2}}],[\"newthr\",{\"1\":{\"217\":4}}],[\"newcap\",{\"1\":{\"217\":5}}],[\"newcapacity\",{\"1\":{\"182\":6}}],[\"newnode\",{\"1\":{\"216\":2}}],[\"newarr\",{\"1\":{\"171\":2}}],[\"new\",{\"1\":{\"161\":3,\"162\":1,\"171\":4,\"172\":3,\"173\":1,\"180\":1,\"182\":13,\"189\":1,\"193\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"217\":2,\"221\":1,\"222\":10,\"223\":3,\"224\":2,\"228\":7,\"233\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":6,\"247\":2,\"248\":5,\"249\":2,\"250\":1,\"251\":3,\"253\":3,\"254\":1,\"255\":4,\"262\":2,\"264\":1,\"265\":4,\"266\":3,\"267\":2,\"269\":6,\"270\":2,\"275\":1,\"277\":1,\"283\":4,\"284\":2,\"285\":3,\"286\":4,\"288\":5,\"290\":5,\"296\":1,\"297\":2,\"299\":1,\"301\":1,\"302\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":11,\"313\":4,\"318\":3,\"319\":3,\"320\":3,\"322\":4,\"323\":2,\"324\":4,\"329\":3,\"330\":2,\"331\":10,\"339\":1,\"341\":1,\"343\":1,\"351\":4,\"354\":2,\"355\":1,\"356\":1,\"362\":4,\"363\":1,\"364\":1,\"370\":5,\"371\":1,\"372\":1,\"373\":4,\"376\":1,\"379\":4,\"380\":2,\"386\":7,\"387\":1,\"388\":1,\"390\":4,\"391\":1,\"393\":2,\"401\":6,\"402\":3,\"409\":1,\"410\":1,\"415\":1,\"416\":5,\"417\":2}}],[\"newestimatevt+1​\",{\"1\":{\"112\":1}}],[\"network\",{\"1\":{\"142\":5,\"144\":1}}],[\"networks\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"142\":1}}],[\"n=0∑∞​βnrt+n​\",{\"1\":{\"13\":1}}],[\"n∈n=\",{\"1\":{\"13\":1}}],[\"n∈1\",{\"1\":{\"8\":1}}],[\"n0​为用户所在位置的加性高斯白噪声\",{\"1\":{\"9\":1}}],[\"n\",{\"0\":{\"117\":1},\"1\":{\"8\":2,\"11\":1,\"13\":2,\"70\":1,\"71\":1,\"142\":1,\"216\":6,\"376\":1,\"381\":9}}],[\"t会根据使用时提供的类型自动变成对应类型\",{\"1\":{\"416\":1}}],[\"tmp\",{\"1\":{\"248\":3,\"251\":3}}],[\"txt\",{\"1\":{\"248\":6,\"249\":2,\"250\":1,\"251\":2,\"253\":2,\"254\":1,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"285\":1,\"286\":2,\"288\":2,\"290\":2}}],[\"t2\",{\"1\":{\"241\":4,\"304\":2,\"305\":2,\"311\":2,\"312\":4,\"313\":2,\"318\":2,\"319\":2}}],[\"t1\",{\"1\":{\"241\":5,\"304\":2,\"305\":3,\"311\":2,\"312\":4,\"313\":2,\"318\":2,\"319\":2}}],[\"type1\",{\"1\":{\"343\":9}}],[\"types\",{\"1\":{\"343\":6}}],[\"typevariableimpl\",{\"1\":{\"343\":3}}],[\"type\",{\"1\":{\"222\":5,\"340\":4,\"343\":20}}],[\"t>\",{\"1\":{\"192\":1,\"193\":1}}],[\"t=0∑∞​γtrt+1​\",{\"1\":{\"151\":1}}],[\"t=0\",{\"1\":{\"112\":1,\"116\":1}}],[\"td\",{\"0\":{\"111\":1,\"114\":1,\"115\":1,\"119\":1,\"127\":1,\"138\":1},\"1\":{\"113\":1,\"138\":1,\"142\":1,\"156\":1}}],[\"t∈rn\",{\"1\":{\"46\":2}}],[\"t∈r2×1\",{\"1\":{\"8\":2}}],[\"taobao\",{\"1\":{\"381\":2}}],[\"taohai\",{\"1\":{\"222\":3}}],[\"taskfired\",{\"1\":{\"324\":1}}],[\"taskqueue\",{\"1\":{\"324\":2}}],[\"task\",{\"1\":{\"322\":6,\"324\":2}}],[\"tasks转换成continuing\",{\"1\":{\"19\":1}}],[\"tasks\",{\"1\":{\"19\":3,\"324\":2}}],[\"tab\",{\"1\":{\"216\":8}}],[\"tabular\",{\"1\":{\"130\":1}}],[\"table过大\",{\"1\":{\"14\":1}}],[\"table来找出对应q\",{\"1\":{\"13\":1}}],[\"table\",{\"1\":{\"13\":2,\"215\":1,\"216\":1,\"217\":2}}],[\"table管理\",{\"1\":{\"13\":1}}],[\"target\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":2,\"142\":4,\"296\":2}}],[\"take\",{\"1\":{\"86\":1,\"296\":1,\"331\":4}}],[\"taking\",{\"1\":{\"48\":1}}],[\"ten\",{\"1\":{\"364\":1}}],[\"teacher\",{\"1\":{\"354\":7}}],[\"test<>\",{\"1\":{\"416\":1}}],[\"test<string\",{\"1\":{\"416\":1}}],[\"test<string>\",{\"1\":{\"343\":1,\"416\":1}}],[\"test<a\",{\"1\":{\"416\":1}}],[\"test<integer>\",{\"1\":{\"416\":1}}],[\"test<\",{\"1\":{\"416\":1}}],[\"testexception\",{\"1\":{\"400\":4}}],[\"test这个包中\",{\"1\":{\"277\":1}}],[\"test\",{\"1\":{\"171\":2,\"173\":7,\"180\":1,\"193\":1,\"241\":21,\"248\":6,\"251\":1,\"253\":2,\"255\":2,\"262\":1,\"265\":2,\"266\":1,\"269\":3,\"274\":1,\"277\":7,\"278\":4,\"283\":2,\"284\":1,\"286\":1,\"343\":2,\"354\":2,\"356\":7,\"373\":1,\"376\":3,\"377\":1,\"386\":25,\"387\":6,\"388\":4,\"389\":11,\"390\":7,\"391\":1,\"392\":2,\"401\":3,\"402\":4,\"416\":7,\"417\":5}}],[\"terms\",{\"1\":{\"119\":1}}],[\"terminal\",{\"1\":{\"19\":1,\"228\":1}}],[\"temporal\",{\"0\":{\"109\":1}}],[\"technology\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"timeout\",{\"1\":{\"350\":2}}],[\"timerthread继承自thread\",{\"1\":{\"324\":1}}],[\"timerthread\",{\"1\":{\"324\":2}}],[\"timertask\",{\"1\":{\"322\":3,\"323\":1,\"324\":2}}],[\"timer\",{\"1\":{\"323\":4,\"324\":15}}],[\"timerlooptask\",{\"1\":{\"322\":3}}],[\"time\",{\"1\":{\"10\":1,\"81\":1,\"322\":5}}],[\"try\",{\"1\":{\"247\":3,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"301\":1,\"305\":1,\"313\":2,\"318\":1,\"319\":1,\"322\":2,\"324\":2,\"329\":2,\"331\":2,\"402\":9}}],[\"treemap\",{\"0\":{\"219\":1},\"1\":{\"224\":1}}],[\"treeifybin\",{\"1\":{\"216\":1}}],[\"treeify\",{\"1\":{\"216\":1}}],[\"treenode<k\",{\"1\":{\"216\":1}}],[\"treenode\",{\"1\":{\"216\":1}}],[\"treeset<>\",{\"1\":{\"207\":2}}],[\"treeset<integer>\",{\"1\":{\"207\":2}}],[\"treeset\",{\"0\":{\"207\":1},\"1\":{\"219\":1,\"224\":1}}],[\"true表示开启追加模式\",{\"1\":{\"250\":1}}],[\"true\",{\"1\":{\"180\":2,\"181\":1,\"182\":2,\"193\":1,\"216\":1,\"228\":1,\"241\":2,\"250\":1,\"301\":1,\"322\":1,\"329\":5,\"330\":1,\"331\":2}}],[\"truncated\",{\"0\":{\"69\":1,\"71\":1,\"72\":1},\"1\":{\"71\":1}}],[\"trial\",{\"1\":{\"19\":2}}],[\"trip\",{\"1\":{\"10\":1}}],[\"trajectory以及对应的\",{\"1\":{\"154\":1}}],[\"trajectory是在策略给定下\",{\"1\":{\"19\":1}}],[\"trajectory\",{\"1\":{\"19\":4,\"41\":1,\"42\":1,\"154\":1}}],[\"transient\",{\"1\":{\"182\":4,\"215\":1,\"224\":1,\"290\":1}}],[\"transition\",{\"1\":{\"19\":2,\"20\":1}}],[\"transmission\",{\"1\":{\"8\":1}}],[\"transactions\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"t\",{\"1\":{\"8\":11,\"9\":20,\"10\":12,\"11\":8,\"13\":6,\"171\":10,\"172\":3,\"173\":8,\"180\":2,\"192\":3,\"193\":3,\"204\":2,\"297\":3,\"299\":2,\"301\":3,\"302\":3,\"320\":2,\"329\":7,\"416\":2,\"417\":2}}],[\"tochararray\",{\"1\":{\"379\":1}}],[\"tohexstring\",{\"1\":{\"350\":1,\"363\":1}}],[\"tolist\",{\"1\":{\"228\":3}}],[\"toindex\",{\"1\":{\"181\":1}}],[\"toarray\",{\"1\":{\"180\":2,\"181\":1,\"204\":2}}],[\"tostring\",{\"1\":{\"171\":4,\"255\":1,\"330\":1,\"350\":2,\"380\":2,\"386\":4,\"402\":1,\"410\":3}}],[\"tool\",{\"1\":{\"52\":1}}],[\"to\",{\"0\":{\"47\":1},\"1\":{\"4\":1,\"19\":1,\"20\":1,\"82\":1,\"86\":1,\"92\":1,\"98\":1,\"296\":2,\"324\":1}}],[\"threadlocal<>\",{\"1\":{\"319\":1}}],[\"threadlocal<string>\",{\"1\":{\"319\":1,\"320\":1}}],[\"threadlocal定义在主线程中\",{\"1\":{\"319\":1}}],[\"thread\",{\"1\":{\"296\":7,\"297\":6,\"299\":5,\"301\":5,\"302\":3,\"304\":5,\"305\":4,\"311\":5,\"312\":18,\"313\":6,\"318\":5,\"319\":6,\"320\":3,\"322\":4,\"323\":1,\"324\":8,\"329\":10,\"330\":1,\"331\":9}}],[\"thread构造方法中需要传入一个runnable接口的实现\",{\"1\":{\"296\":1}}],[\"threadinfo\",{\"1\":{\"295\":2}}],[\"threadmxbean\",{\"1\":{\"295\":1}}],[\"threshold\",{\"1\":{\"216\":2,\"217\":3}}],[\"throwable\",{\"1\":{\"350\":1}}],[\"throws\",{\"1\":{\"264\":1,\"285\":1,\"299\":1,\"300\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"329\":2,\"339\":1,\"350\":5,\"355\":2,\"399\":1,\"401\":3,\"402\":4}}],[\"throw\",{\"1\":{\"182\":1,\"189\":1,\"267\":1,\"331\":1,\"401\":6,\"402\":3}}],[\"throughput\",{\"1\":{\"4\":1}}],[\"this\",{\"0\":{\"164\":1},\"1\":{\"154\":1,\"164\":1,\"166\":12,\"172\":3,\"180\":1,\"181\":3,\"182\":5,\"192\":1,\"193\":1,\"204\":1,\"215\":1,\"216\":1,\"222\":3,\"241\":4,\"264\":1,\"288\":1,\"289\":1,\"290\":1,\"296\":1,\"322\":4,\"324\":2,\"349\":1,\"350\":1,\"351\":3,\"353\":4,\"356\":2,\"386\":6,\"387\":1,\"388\":1,\"415\":3,\"416\":3}}],[\"that\",{\"1\":{\"41\":1,\"58\":1,\"81\":1,\"296\":3}}],[\"they\",{\"1\":{\"324\":1}}],[\"them\",{\"1\":{\"324\":1}}],[\"then\",{\"1\":{\"58\":2}}],[\"theorem来求解贝尔曼最优公式\",{\"1\":{\"58\":1}}],[\"theorem\",{\"1\":{\"53\":2,\"58\":1,\"62\":1,\"98\":1}}],[\"the\",{\"0\":{\"24\":1,\"43\":1,\"44\":1},\"1\":{\"4\":1,\"9\":1,\"10\":1,\"19\":6,\"20\":4,\"37\":1,\"40\":1,\"41\":2,\"47\":1,\"48\":4,\"49\":2,\"52\":1,\"53\":2,\"58\":2,\"81\":1,\"82\":2,\"86\":1,\"98\":2,\"135\":1,\"142\":2,\"296\":5,\"324\":7,\"340\":4}}],[\"i都会更新成数组中下一个元素\",{\"1\":{\"372\":1}}],[\"i+\",{\"1\":{\"372\":1}}],[\"i++\",{\"1\":{\"299\":1,\"304\":2,\"305\":2,\"311\":2,\"312\":8,\"318\":1,\"329\":2,\"372\":1,\"409\":1}}],[\"i就是每一个数组中的元素\",{\"1\":{\"372\":1}}],[\"illegal\",{\"1\":{\"182\":1}}],[\"illegalargumentexception\",{\"1\":{\"182\":1}}],[\"io流3\",{\"0\":{\"282\":1}}],[\"io流2\",{\"0\":{\"259\":1}}],[\"io流1\",{\"0\":{\"245\":1}}],[\"ioexception\",{\"1\":{\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"264\":1,\"265\":2,\"267\":1,\"269\":3,\"270\":1,\"283\":2,\"284\":1,\"286\":2,\"288\":1,\"290\":1,\"402\":6}}],[\"io中\",{\"1\":{\"245\":1}}],[\"io\",{\"0\":{\"244\":1,\"258\":1,\"281\":1},\"1\":{\"182\":2,\"199\":1,\"224\":1,\"252\":2}}],[\"ids\",{\"1\":{\"295\":2}}],[\"id一般是int\",{\"1\":{\"213\":1}}],[\"id\",{\"1\":{\"172\":4,\"415\":4,\"416\":4}}],[\"identically\",{\"1\":{\"75\":1}}],[\"idle\",{\"1\":{\"10\":1}}],[\"iid\",{\"1\":{\"75\":1}}],[\"i\",{\"1\":{\"75\":2,\"78\":1,\"181\":3,\"190\":2,\"216\":3,\"228\":4,\"265\":1,\"299\":3,\"304\":5,\"305\":5,\"311\":4,\"312\":12,\"318\":3,\"329\":4,\"330\":1,\"343\":9,\"362\":9,\"363\":4,\"364\":6,\"372\":4,\"409\":2,\"417\":2}}],[\"i−γpπk​​\",{\"1\":{\"68\":1}}],[\"i−γpπ​\",{\"1\":{\"47\":2}}],[\"if\",{\"1\":{\"53\":1,\"58\":1,\"86\":1,\"98\":1,\"180\":1,\"182\":6,\"216\":10,\"217\":5,\"241\":4,\"247\":1,\"264\":2,\"299\":1,\"301\":1,\"304\":1,\"305\":1,\"324\":2,\"351\":2,\"354\":1,\"362\":1,\"401\":2}}],[\"ij​=pπ​\",{\"1\":{\"46\":1}}],[\"implementing\",{\"1\":{\"296\":1}}],[\"implements\",{\"1\":{\"182\":2,\"193\":1,\"199\":1,\"215\":2,\"224\":1,\"288\":1,\"289\":1,\"290\":1,\"354\":2,\"355\":1,\"417\":2}}],[\"import\",{\"1\":{\"180\":1,\"277\":3,\"278\":1,\"364\":2,\"389\":1,\"409\":1}}],[\"importance\",{\"0\":{\"30\":1}}],[\"improvement\",{\"1\":{\"66\":1,\"70\":1,\"79\":1,\"82\":1,\"88\":1,\"111\":1,\"115\":1,\"120\":1}}],[\"immediate\",{\"0\":{\"43\":1},\"1\":{\"45\":1}}],[\"i=1n​\",{\"1\":{\"19\":2}}],[\"its\",{\"1\":{\"324\":1}}],[\"item\",{\"1\":{\"182\":2,\"190\":1}}],[\"iterable<string>\",{\"1\":{\"193\":1}}],[\"iterable<t>\",{\"1\":{\"193\":1}}],[\"iterable<e>\",{\"1\":{\"180\":1}}],[\"iterable\",{\"1\":{\"192\":1,\"193\":1}}],[\"iterator<t>\",{\"1\":{\"193\":1}}],[\"iterator<string>\",{\"1\":{\"191\":1,\"193\":2}}],[\"iterator<e>\",{\"1\":{\"180\":2,\"189\":1,\"194\":1,\"201\":1,\"204\":1,\"224\":1}}],[\"iterator\",{\"1\":{\"180\":2,\"187\":3,\"191\":4,\"193\":3,\"204\":1,\"224\":2,\"330\":1}}],[\"iteration\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"70\":2,\"71\":1,\"72\":1},\"1\":{\"62\":1,\"68\":2,\"69\":2,\"70\":10,\"71\":3,\"76\":1,\"77\":1,\"79\":1,\"82\":1}}],[\"iterative\",{\"1\":{\"47\":1,\"92\":1}}],[\"it\",{\"1\":{\"4\":1,\"81\":1,\"296\":1,\"329\":2}}],[\"isinterrupted\",{\"1\":{\"301\":1}}],[\"isdirectory\",{\"1\":{\"255\":1}}],[\"isempty\",{\"1\":{\"180\":1,\"182\":1,\"204\":1,\"213\":1,\"224\":2,\"324\":2,\"331\":1}}],[\"is\",{\"1\":{\"4\":3,\"19\":1,\"20\":2,\"41\":1,\"53\":1,\"58\":2,\"81\":1,\"86\":2,\"154\":1,\"296\":3,\"324\":1}}],[\"ieee\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"inner2\",{\"1\":{\"386\":2}}],[\"inner1\",{\"1\":{\"386\":2}}],[\"inner\",{\"1\":{\"386\":12,\"387\":5,\"388\":5,\"389\":3}}],[\"inheritablethreadlocal<>\",{\"1\":{\"320\":1}}],[\"inherits\",{\"1\":{\"296\":1}}],[\"init\",{\"1\":{\"296\":1}}],[\"initial\",{\"1\":{\"217\":3}}],[\"initialcapacity\",{\"1\":{\"182\":5}}],[\"infos\",{\"1\":{\"295\":2}}],[\"info\",{\"1\":{\"274\":3,\"295\":2}}],[\"input\",{\"1\":{\"264\":3}}],[\"inputstreamreader\",{\"1\":{\"283\":3}}],[\"inputstream\",{\"1\":{\"245\":1,\"247\":5,\"248\":9,\"251\":2,\"255\":2,\"264\":1,\"288\":2,\"290\":2}}],[\"indexoutofboundsexception\",{\"1\":{\"402\":2}}],[\"indexofsublist\",{\"1\":{\"237\":1}}],[\"indexof\",{\"1\":{\"181\":1}}],[\"index++\",{\"1\":{\"182\":1}}],[\"index\",{\"1\":{\"181\":6,\"182\":4}}],[\"independent\",{\"1\":{\"75\":1}}],[\"intsummarystatistics\",{\"1\":{\"228\":1}}],[\"ints\",{\"1\":{\"228\":2}}],[\"interrupted\",{\"1\":{\"301\":1}}],[\"interruptedexception终止异常\",{\"1\":{\"318\":1}}],[\"interruptedexception\",{\"1\":{\"299\":1,\"300\":1,\"301\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":3,\"318\":2,\"319\":2,\"322\":2,\"329\":4,\"331\":2,\"350\":3}}],[\"interrupt\",{\"1\":{\"301\":1}}],[\"interrupt用法\",{\"1\":{\"301\":1}}],[\"intermediate\",{\"1\":{\"228\":1}}],[\"interface\",{\"1\":{\"180\":1,\"181\":1,\"189\":1,\"193\":1,\"194\":1,\"200\":1,\"201\":1,\"204\":1,\"213\":2,\"296\":2,\"354\":3,\"355\":1,\"390\":1,\"393\":2,\"417\":1}}],[\"interacting\",{\"1\":{\"19\":1}}],[\"integercache会默认缓存\",{\"1\":{\"362\":1}}],[\"integercache\",{\"1\":{\"362\":4}}],[\"integer>\",{\"1\":{\"172\":1,\"222\":1,\"241\":1}}],[\"integer\",{\"1\":{\"171\":7,\"182\":5,\"217\":2,\"222\":1,\"237\":1,\"340\":2,\"341\":1,\"343\":4,\"350\":1,\"362\":13,\"363\":7,\"373\":1,\"393\":2,\"415\":3,\"416\":1,\"417\":2}}],[\"int\",{\"1\":{\"161\":2,\"162\":1,\"165\":3,\"166\":7,\"171\":2,\"180\":2,\"181\":10,\"182\":9,\"194\":2,\"204\":2,\"213\":2,\"215\":1,\"216\":3,\"217\":4,\"218\":1,\"222\":3,\"224\":1,\"228\":1,\"241\":1,\"248\":1,\"251\":1,\"274\":1,\"278\":1,\"299\":1,\"304\":2,\"305\":2,\"311\":3,\"312\":14,\"318\":1,\"329\":2,\"330\":2,\"340\":2,\"343\":1,\"350\":2,\"353\":3,\"354\":1,\"355\":1,\"362\":3,\"370\":2,\"371\":2,\"372\":5,\"373\":4,\"374\":1,\"375\":1,\"376\":3,\"391\":1,\"393\":3,\"401\":4,\"402\":4,\"403\":1,\"409\":1,\"410\":2}}],[\"instanceof\",{\"1\":{\"216\":1,\"343\":2,\"351\":1,\"354\":1}}],[\"instance\",{\"1\":{\"161\":1,\"340\":1}}],[\"invoked\",{\"1\":{\"4\":1}}],[\"in\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"81\":1,\"98\":1,\"119\":1,\"264\":4,\"285\":1,\"296\":1}}],[\"multiply\",{\"1\":{\"364\":1}}],[\"multiple\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"millis\",{\"1\":{\"300\":1}}],[\"min\",{\"1\":{\"233\":1,\"302\":2,\"409\":1}}],[\"mincapacity\",{\"1\":{\"182\":4}}],[\"mini\",{\"1\":{\"142\":2}}],[\"minisize\",{\"1\":{\"136\":1}}],[\"minimize\",{\"1\":{\"104\":1}}],[\"mbgd\",{\"0\":{\"106\":1}}],[\"message\",{\"1\":{\"400\":4}}],[\"menu\",{\"1\":{\"331\":1}}],[\"memory\",{\"1\":{\"311\":1}}],[\"me\",{\"1\":{\"299\":2}}],[\"merge\",{\"1\":{\"222\":1}}],[\"merge方法可以对重复键的值进行特殊操作\",{\"1\":{\"222\":1}}],[\"merge方法用于处理数据\",{\"1\":{\"222\":1}}],[\"metrics\",{\"1\":{\"148\":2}}],[\"method\",{\"1\":{\"81\":2,\"101\":3,\"156\":1,\"296\":2}}],[\"methods\",{\"1\":{\"81\":1}}],[\"means\",{\"1\":{\"92\":1}}],[\"means来划分各个无人机所管理的用户簇\",{\"1\":{\"13\":1}}],[\"means的优化目标是最小化无人机与对应集群用户的欧氏距离\",{\"1\":{\"13\":1}}],[\"means可以视为获得无人机部署的低复杂度方案\",{\"1\":{\"13\":1}}],[\"means算法\",{\"1\":{\"13\":1}}],[\"means和igk算法比具有较低的复杂度\",{\"1\":{\"5\":1}}],[\"mean算法获得初始单元划分\",{\"1\":{\"5\":1}}],[\"mean\",{\"0\":{\"43\":1,\"44\":1,\"99\":1,\"103\":1},\"1\":{\"5\":1,\"40\":1,\"41\":1,\"75\":1,\"77\":1,\"82\":1,\"92\":1}}],[\"mc\",{\"0\":{\"76\":1,\"80\":1,\"83\":1,\"85\":1,\"88\":1,\"114\":1},\"1\":{\"76\":1,\"80\":2,\"81\":1,\"82\":1,\"88\":2,\"101\":1,\"123\":1}}],[\"mdp就变为mp\",{\"1\":{\"20\":1}}],[\"mdp\",{\"0\":{\"20\":1}}],[\"male\",{\"1\":{\"354\":1}}],[\"machine\",{\"1\":{\"340\":1}}],[\"managementfactory\",{\"1\":{\"295\":1}}],[\"mark已经失效\",{\"1\":{\"265\":1}}],[\"mark\",{\"1\":{\"265\":6}}],[\"markov\",{\"0\":{\"20\":1},\"1\":{\"20\":2,\"135\":1}}],[\"markovian\",{\"1\":{\"14\":1}}],[\"matches\",{\"1\":{\"381\":2}}],[\"matches方法用于对给定正则表达式进行匹配\",{\"1\":{\"381\":1}}],[\"match\",{\"1\":{\"381\":1}}],[\"math也是java\",{\"1\":{\"409\":1}}],[\"math类\",{\"1\":{\"409\":1}}],[\"math\",{\"1\":{\"222\":3,\"364\":3,\"409\":5}}],[\"matrix\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"maptoint\",{\"1\":{\"228\":1}}],[\"map中只有键为1的映射\",{\"1\":{\"214\":1}}],[\"map<test\",{\"1\":{\"241\":1}}],[\"map<string\",{\"1\":{\"222\":1}}],[\"map<integer\",{\"1\":{\"214\":4,\"221\":1,\"223\":3}}],[\"map<\",{\"1\":{\"213\":1}}],[\"map<k\",{\"1\":{\"213\":1,\"215\":1}}],[\"map并不是collection体系下的接口\",{\"1\":{\"213\":1}}],[\"map目前只需要记住\",{\"1\":{\"207\":1}}],[\"map\",{\"0\":{\"212\":1,\"213\":1,\"220\":1},\"1\":{\"207\":1,\"212\":2,\"213\":2,\"214\":16,\"215\":1,\"221\":10,\"223\":12,\"224\":6,\"228\":1,\"241\":5}}],[\"mapping\",{\"1\":{\"53\":2,\"58\":5,\"62\":1}}],[\"mainloop\",{\"1\":{\"324\":2}}],[\"main\",{\"1\":{\"142\":4,\"144\":1,\"161\":3,\"162\":1,\"171\":10,\"172\":3,\"173\":1,\"180\":2,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":4,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":1,\"277\":4,\"278\":2,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":2,\"312\":17,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":2,\"329\":2,\"330\":2,\"331\":7,\"339\":1,\"340\":1,\"341\":1,\"343\":10,\"354\":3,\"355\":1,\"356\":1,\"362\":4,\"363\":1,\"364\":2,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":1,\"375\":1,\"376\":1,\"377\":2,\"379\":3,\"380\":3,\"381\":2,\"386\":2,\"387\":1,\"389\":2,\"390\":5,\"391\":1,\"392\":3,\"393\":9,\"402\":5,\"403\":1,\"409\":2,\"410\":1,\"415\":1,\"416\":3,\"417\":4}}],[\"maximum\",{\"1\":{\"217\":2}}],[\"max\",{\"1\":{\"182\":4,\"217\":2,\"233\":1,\"302\":1,\"364\":1,\"409\":1}}],[\"maxa∈a\",{\"1\":{\"142\":1}}],[\"max​q^​\",{\"1\":{\"140\":1,\"141\":1,\"142\":3}}],[\"may\",{\"1\":{\"19\":1,\"296\":1}}],[\"mssrkn​​rtt​+1\",{\"1\":{\"10\":1}}],[\"mss\",{\"1\":{\"10\":1}}],[\"m\",{\"1\":{\"9\":1,\"213\":1,\"221\":3,\"381\":3}}],[\"monro\",{\"1\":{\"98\":2}}],[\"monto\",{\"0\":{\"95\":1}}],[\"monte\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"moreover\",{\"1\":{\"58\":1}}],[\"mobility\",{\"1\":{\"14\":1}}],[\"modles可选择\",{\"1\":{\"14\":1}}],[\"model|environment\",{\"1\":{\"45\":1}}],[\"model\",{\"0\":{\"10\":1,\"75\":1},\"1\":{\"14\":3,\"45\":2,\"76\":1,\"77\":2}}],[\"mos主要是有关传输速率rkn​​的函数\",{\"1\":{\"13\":1}}],[\"mosrkn​​​=t=0∑ts​​moskn​​\",{\"1\":{\"10\":1}}],[\"moskn​​\",{\"1\":{\"10\":3}}],[\"mos\",{\"1\":{\"5\":1}}],[\"movement\",{\"0\":{\"3\":1},\"1\":{\"4\":2}}],[\"a<t>\",{\"1\":{\"417\":2}}],[\"a<>\",{\"1\":{\"417\":1}}],[\"a<string>\",{\"1\":{\"417\":2}}],[\"aeiou\",{\"1\":{\"381\":1}}],[\"aerial\",{\"1\":{\"4\":1}}],[\"available\",{\"1\":{\"248\":2,\"255\":1}}],[\"average\",{\"0\":{\"150\":1,\"153\":1},\"1\":{\"48\":2,\"154\":1}}],[\"abs方法可以求绝对值\",{\"1\":{\"409\":1}}],[\"abs\",{\"1\":{\"409\":1}}],[\"abstractset<e>\",{\"1\":{\"224\":1}}],[\"abstractsequentiallist<e>\",{\"1\":{\"182\":1,\"199\":1}}],[\"abstractmap<k\",{\"1\":{\"215\":1}}],[\"abstractlist<e>\",{\"1\":{\"182\":1}}],[\"abstract\",{\"1\":{\"173\":8,\"296\":1,\"353\":2,\"354\":1,\"390\":2}}],[\"abc\",{\"1\":{\"381\":2}}],[\"abcabccaa\",{\"1\":{\"381\":1}}],[\"abcd\",{\"1\":{\"248\":3}}],[\"a是上一次计算的值\",{\"1\":{\"228\":1}}],[\"api\",{\"1\":{\"228\":1}}],[\"api添加了一个新的抽象称为\",{\"1\":{\"228\":1}}],[\"apple\",{\"1\":{\"390\":3}}],[\"apply\",{\"1\":{\"181\":1}}],[\"append\",{\"1\":{\"254\":1,\"380\":7}}],[\"appears\",{\"1\":{\"81\":1}}],[\"appropriate\",{\"1\":{\"324\":1}}],[\"approximation\",{\"0\":{\"130\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"92\":1,\"147\":1}}],[\"approximate\",{\"1\":{\"82\":1}}],[\"approach\",{\"1\":{\"14\":2}}],[\"after\",{\"1\":{\"218\":1}}],[\"afternodeinsertion\",{\"1\":{\"216\":1}}],[\"afternodeaccess\",{\"1\":{\"216\":1}}],[\"aaaa\",{\"1\":{\"228\":1,\"377\":1}}],[\"aaa\",{\"1\":{\"171\":1,\"200\":1,\"201\":1,\"205\":4,\"237\":2,\"380\":1}}],[\"arithmeticexception\",{\"1\":{\"401\":1}}],[\"arg\",{\"1\":{\"377\":2}}],[\"args\",{\"1\":{\"161\":3,\"162\":1,\"171\":5,\"172\":3,\"173\":1,\"180\":1,\"182\":9,\"187\":2,\"191\":2,\"192\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":3,\"206\":1,\"207\":2,\"214\":4,\"221\":1,\"222\":1,\"223\":3,\"228\":7,\"233\":1,\"234\":1,\"235\":1,\"236\":2,\"237\":3,\"241\":2,\"247\":2,\"248\":3,\"249\":2,\"250\":1,\"251\":1,\"253\":2,\"254\":1,\"255\":1,\"262\":1,\"265\":2,\"269\":3,\"270\":1,\"274\":1,\"277\":2,\"278\":1,\"283\":2,\"284\":1,\"285\":2,\"286\":2,\"288\":1,\"290\":1,\"295\":1,\"297\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":4,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":2,\"323\":1,\"324\":1,\"329\":2,\"330\":2,\"331\":1,\"339\":1,\"340\":1,\"341\":1,\"343\":9,\"354\":2,\"355\":1,\"356\":1,\"362\":4,\"363\":1,\"364\":2,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":1,\"375\":1,\"376\":1,\"377\":3,\"379\":3,\"380\":3,\"381\":2,\"386\":2,\"387\":1,\"389\":1,\"390\":3,\"391\":1,\"392\":3,\"393\":5,\"402\":4,\"403\":1,\"409\":2,\"410\":1,\"415\":1,\"416\":3,\"417\":2}}],[\"arrav\",{\"1\":{\"373\":1}}],[\"array就是我们要遍历的数组\",{\"1\":{\"372\":1}}],[\"arraydeque<>\",{\"1\":{\"202\":1}}],[\"array\",{\"1\":{\"182\":2,\"370\":2,\"371\":2,\"372\":4,\"373\":2}}],[\"arraylist源码部分\",{\"1\":{\"182\":1}}],[\"arraylist<e>\",{\"1\":{\"182\":1}}],[\"arraylist<>\",{\"1\":{\"180\":1,\"182\":6,\"228\":5,\"233\":1,\"235\":1,\"236\":1,\"237\":3,\"241\":1,\"330\":1,\"343\":1}}],[\"arraylist<string>\",{\"1\":{\"180\":1,\"182\":1}}],[\"arraylist\",{\"0\":{\"182\":1},\"1\":{\"180\":2,\"182\":3,\"190\":1,\"343\":1}}],[\"arrays类\",{\"1\":{\"410\":2}}],[\"arrays\",{\"1\":{\"171\":9,\"181\":1,\"182\":4,\"187\":2,\"191\":2,\"192\":1,\"205\":1,\"206\":1,\"222\":1,\"228\":2,\"234\":1,\"235\":1,\"236\":1,\"237\":4,\"255\":1,\"330\":3,\"343\":1,\"410\":5}}],[\"arr\",{\"1\":{\"171\":12,\"330\":3,\"373\":8,\"375\":2,\"402\":2,\"410\":2}}],[\"addlast\",{\"1\":{\"201\":1}}],[\"addfirst\",{\"1\":{\"201\":1}}],[\"addall\",{\"1\":{\"180\":1,\"181\":1,\"204\":1,\"205\":1,\"206\":1}}],[\"add\",{\"1\":{\"171\":2,\"180\":2,\"181\":1,\"182\":13,\"194\":1,\"200\":1,\"204\":1,\"205\":3,\"207\":6,\"228\":16,\"236\":2,\"237\":2,\"241\":1,\"312\":9,\"331\":3}}],[\"advantage\",{\"0\":{\"25\":1}}],[\"age已经初始化完\",{\"1\":{\"166\":1}}],[\"age\",{\"1\":{\"161\":1,\"162\":2,\"166\":18,\"274\":1,\"278\":1,\"343\":1,\"351\":2,\"353\":6,\"354\":2,\"355\":2,\"376\":1}}],[\"agent从一个状态出发\",{\"1\":{\"48\":1}}],[\"agent从一个状态出发可以得到的平均return\",{\"1\":{\"48\":1}}],[\"agent可能走出的全部轨迹\",{\"1\":{\"19\":1}}],[\"agent将获得负奖励\",{\"1\":{\"13\":1}}],[\"agent\",{\"1\":{\"13\":1,\"19\":2,\"48\":2,\"154\":1}}],[\"a∈a∑​π\",{\"1\":{\"155\":1}}],[\"a∈a∑​▽θ​π\",{\"1\":{\"155\":2}}],[\"ak​=k1​是满足上面三个条件的\",{\"1\":{\"98\":1}}],[\"ak​→0不要过快\",{\"1\":{\"98\":1}}],[\"ak​→0\",{\"1\":{\"98\":1}}],[\"ak​\",{\"1\":{\"97\":1}}],[\"ak∗​∣s\",{\"1\":{\"79\":1}}],[\"ak∗​\",{\"1\":{\"66\":1}}],[\"a3​\",{\"1\":{\"81\":2}}],[\"a4​\",{\"1\":{\"81\":2}}],[\"a2​\",{\"1\":{\"81\":4}}],[\"a2c\",{\"0\":{\"25\":1}}],[\"a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"asdf\",{\"1\":{\"343\":1}}],[\"asdasda\",{\"1\":{\"228\":1}}],[\"aslist\",{\"1\":{\"182\":2,\"187\":2,\"191\":2,\"192\":1,\"205\":1,\"206\":1,\"222\":1,\"228\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":4,\"330\":1,\"343\":1}}],[\"as\",{\"1\":{\"58\":1,\"104\":1,\"324\":2}}],[\"assertionerror\",{\"1\":{\"403\":1}}],[\"assert\",{\"1\":{\"403\":2}}],[\"assert断言表达式\",{\"1\":{\"403\":1}}],[\"assubclass\",{\"1\":{\"343\":2}}],[\"assdw\",{\"1\":{\"228\":1}}],[\"associate\",{\"1\":{\"20\":1}}],[\"assisted\",{\"1\":{\"4\":1}}],[\"along\",{\"1\":{\"154\":1}}],[\"alogorithm\",{\"0\":{\"132\":1}}],[\"algorithms\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"algorithm\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"71\":1,\"72\":1,\"95\":1},\"1\":{\"58\":1,\"68\":2,\"70\":2,\"71\":1,\"76\":1,\"79\":1,\"98\":1}}],[\"all\",{\"1\":{\"41\":1,\"53\":1}}],[\"a∑​π\",{\"1\":{\"45\":1,\"155\":1}}],[\"a∑​p\",{\"1\":{\"44\":1}}],[\"a∼π​\",{\"1\":{\"26\":3,\"155\":1}}],[\"a∣s\",{\"1\":{\"20\":1,\"26\":3,\"41\":1,\"43\":2,\"44\":5,\"45\":4,\"48\":3,\"49\":1,\"55\":2,\"57\":2,\"58\":1,\"63\":2,\"66\":3,\"79\":1,\"87\":1,\"113\":1,\"148\":1,\"153\":1,\"155\":14,\"156\":2}}],[\"aninterface\",{\"1\":{\"343\":2}}],[\"any\",{\"1\":{\"53\":1,\"58\":1,\"86\":1,\"296\":1}}],[\"an\",{\"1\":{\"19\":1,\"47\":1,\"48\":1,\"296\":1}}],[\"and\",{\"0\":{\"3\":1},\"1\":{\"4\":2,\"14\":1,\"48\":1,\"49\":1,\"52\":1,\"53\":1,\"75\":1,\"142\":1,\"324\":2}}],[\"at+1​\",{\"1\":{\"116\":2,\"139\":1,\"140\":1}}],[\"at\",{\"1\":{\"19\":1,\"20\":1}}],[\"at​∣st​\",{\"1\":{\"156\":1}}],[\"at​=a\",{\"1\":{\"43\":1,\"44\":2,\"48\":2,\"49\":1,\"75\":1,\"77\":1,\"78\":1,\"119\":1}}],[\"at​\",{\"1\":{\"13\":1,\"116\":8,\"120\":5,\"139\":2,\"140\":2,\"156\":1}}],[\"a1​\",{\"1\":{\"19\":2,\"20\":2,\"81\":1}}],[\"ai​\",{\"1\":{\"19\":1,\"142\":2}}],[\"acc\",{\"1\":{\"296\":2}}],[\"accesscontrolcontext\",{\"1\":{\"296\":2}}],[\"accept\",{\"1\":{\"189\":1,\"192\":1,\"193\":1}}],[\"actor\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"actions\",{\"1\":{\"20\":1}}],[\"action\",{\"0\":{\"48\":1,\"115\":1,\"119\":1},\"1\":{\"13\":1,\"19\":3,\"20\":2,\"48\":8,\"49\":2,\"53\":2,\"57\":2,\"63\":1,\"66\":1,\"70\":2,\"75\":1,\"77\":5,\"79\":6,\"81\":9,\"82\":3,\"84\":4,\"86\":2,\"92\":1,\"115\":4,\"116\":1,\"119\":2,\"120\":1,\"131\":1,\"189\":3,\"192\":3,\"193\":3,\"296\":1}}],[\"academic\",{\"0\":{\"423\":1},\"2\":{\"15\":1,\"21\":1,\"34\":1,\"50\":1,\"59\":1,\"73\":1,\"90\":1,\"107\":1,\"128\":1,\"145\":1,\"158\":1}}],[\"awgn\",{\"1\":{\"9\":1}}],[\"a\",{\"1\":{\"4\":1,\"13\":3,\"14\":2,\"19\":7,\"20\":5,\"26\":2,\"41\":3,\"43\":1,\"44\":3,\"45\":6,\"48\":13,\"49\":2,\"52\":1,\"53\":1,\"55\":3,\"57\":1,\"58\":2,\"63\":6,\"66\":6,\"70\":1,\"75\":3,\"77\":11,\"78\":8,\"79\":3,\"81\":2,\"82\":2,\"84\":6,\"86\":1,\"92\":1,\"113\":1,\"115\":4,\"116\":3,\"119\":3,\"120\":4,\"135\":1,\"141\":3,\"142\":22,\"153\":5,\"155\":9,\"156\":4,\"161\":1,\"165\":4,\"173\":4,\"180\":1,\"181\":3,\"182\":3,\"187\":2,\"191\":2,\"192\":1,\"203\":2,\"204\":1,\"205\":1,\"206\":1,\"207\":2,\"221\":2,\"228\":6,\"241\":4,\"264\":1,\"296\":3,\"354\":1,\"362\":7,\"364\":1,\"374\":3,\"376\":1,\"381\":6,\"386\":2,\"391\":3,\"392\":5,\"393\":5,\"401\":4,\"402\":2,\"403\":2,\"416\":3,\"417\":7}}],[\"a+b=c\",{\"1\":{\"0\":1}}],[\"doxy\",{\"1\":{\"381\":1}}],[\"does\",{\"1\":{\"381\":1}}],[\"do\",{\"1\":{\"381\":3}}],[\"double\",{\"1\":{\"165\":3,\"362\":2}}],[\"down\",{\"1\":{\"8\":1}}],[\"d0​\",{\"1\":{\"152\":1}}],[\"dqn\",{\"0\":{\"141\":1},\"1\":{\"142\":1,\"144\":1}}],[\"dπ​\",{\"1\":{\"135\":2,\"152\":1}}],[\"divide\",{\"1\":{\"364\":1}}],[\"difference\",{\"0\":{\"109\":1}}],[\"distinct\",{\"1\":{\"204\":1,\"228\":3,\"269\":1}}],[\"distributon\",{\"0\":{\"134\":1},\"1\":{\"135\":3}}],[\"distributed\",{\"1\":{\"75\":1}}],[\"distribution\",{\"0\":{\"135\":1},\"1\":{\"20\":1,\"133\":1,\"135\":1,\"152\":1}}],[\"discounted\",{\"1\":{\"19\":1,\"42\":1,\"113\":1,\"137\":1}}],[\"date\",{\"1\":{\"331\":2}}],[\"dataoutputstream\",{\"1\":{\"286\":4}}],[\"datainputstream\",{\"1\":{\"286\":4}}],[\"data\",{\"1\":{\"81\":1,\"324\":1}}],[\"daily\",{\"0\":{\"421\":1},\"2\":{\"1\":1}}],[\"daily1\",{\"0\":{\"0\":1}}],[\"dpg\",{\"0\":{\"33\":1}}],[\"d\",{\"0\":{\"152\":1},\"1\":{\"10\":3,\"75\":1,\"150\":2,\"152\":5,\"228\":1,\"351\":1,\"353\":1}}],[\"dkn​​\",{\"1\":{\"9\":1}}],[\"dkn​​=hn2​\",{\"1\":{\"8\":1}}],[\"dkn​\",{\"1\":{\"9\":1}}],[\"dynamic\",{\"1\":{\"4\":1,\"45\":1}}],[\"driven\",{\"1\":{\"4\":1}}],[\"delete\",{\"1\":{\"380\":1}}],[\"decode\",{\"1\":{\"363\":1}}],[\"decision\",{\"0\":{\"20\":1}}],[\"deque<string>\",{\"1\":{\"201\":1,\"202\":1}}],[\"deque<e>\",{\"1\":{\"182\":1,\"199\":1,\"201\":1}}],[\"deque\",{\"0\":{\"199\":1,\"201\":1},\"1\":{\"201\":5,\"202\":1}}],[\"default\",{\"1\":{\"180\":4,\"181\":2,\"182\":1,\"189\":2,\"192\":1,\"193\":2,\"204\":1,\"215\":1,\"217\":4,\"330\":1,\"354\":2}}],[\"deeptostring\",{\"1\":{\"410\":1}}],[\"deep\",{\"0\":{\"141\":1},\"1\":{\"141\":1}}],[\"descendingiterator\",{\"1\":{\"201\":1}}],[\"descent\",{\"0\":{\"100\":1},\"1\":{\"101\":2}}],[\"describes\",{\"1\":{\"135\":1}}],[\"design\",{\"0\":{\"3\":1}}],[\"deterministic\",{\"0\":{\"33\":1,\"105\":1},\"1\":{\"14\":1,\"19\":1,\"53\":2}}],[\"demonstrating\",{\"1\":{\"4\":1}}],[\"deployment\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"d1\",{\"2\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
