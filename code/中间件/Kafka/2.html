<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="keywords" content="EkkoSonya's Blog" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #252232);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="http://ekkosonya.cn/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html"><meta property="og:site_name" content="EkkoSonya's Blog"><meta property="og:title" content="Kafka - 2 客户端工作机制1"><meta property="og:description" content="客户端工作机制 其实Kafka的设计精髓，是在网络不稳定，服务也随时会崩溃的这些作死的复杂场景下，如何保证消息的高并发、高吞吐，那才是Kafka最为精妙的地方。但是要理解那些复杂的问题，都是需要建立在这个基础模型基础上的 消费者分组消费机制 GROUP_ID_CONFIG ​在Consumer中，都需要指定一个 GROUP_ID_CONFIG 属性，这..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2026-01-20T14:16:53.000Z"><meta property="article:author" content="EkkoSonya"><meta property="article:tag" content="中间件"><meta property="article:tag" content="Kafka"><meta property="article:modified_time" content="2026-01-20T14:16:53.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Kafka - 2 客户端工作机制1","image":[""],"dateModified":"2026-01-20T14:16:53.000Z","author":[{"@type":"Person","name":"EkkoSonya","url":"http://ekkosonya.cn"}]}</script><link rel="alternate" type="application/rss+xml" href="http://ekkosonya.cn/rss.xml" title="EkkoSonya's Blog RSS Feed"><title>Kafka - 2 客户端工作机制1 | EkkoSonya's Blog</title><meta name="description" content="客户端工作机制 其实Kafka的设计精髓，是在网络不稳定，服务也随时会崩溃的这些作死的复杂场景下，如何保证消息的高并发、高吞吐，那才是Kafka最为精妙的地方。但是要理解那些复杂的问题，都是需要建立在这个基础模型基础上的 消费者分组消费机制 GROUP_ID_CONFIG ​在Consumer中，都需要指定一个 GROUP_ID_CONFIG 属性，这...">
    <link rel="stylesheet" href="/assets/css/styles.f179cd96.css">
    <link rel="preload" href="/assets/js/runtime~app.e5d268a3.js" as="script"><link rel="preload" href="/assets/css/styles.f179cd96.css" as="style"><link rel="preload" href="/assets/js/731.ee5b1103.js" as="script"><link rel="preload" href="/assets/js/app.4d24e321.js" as="script">
    
    <!-- 统计代码区域-->
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/penguin1.png" alt><!----><span class="vp-site-name hide-in-pad">EkkoSonya&#39;s Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/" aria-label="主页"><!---->主页<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/academic/" aria-label="学术"><!---->学术<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link active" href="/code/" aria-label="代码"><!---->代码<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/daily/" aria-label="随笔"><!---->随笔<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="工具"><span class="title"><span class="font-icon icon iconfont icon-tool" style=""></span>工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="https://www.aishort.top/" rel="noopener noreferrer" target="_blank" aria-label="ChatGPT SC" class="nav-link"><span class="font-icon icon iconfont icon-creative" style=""></span>ChatGPT SC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://prompt.newzone.top/" rel="noopener noreferrer" target="_blank" aria-label="IMGPrompt" class="nav-link"><span class="font-icon icon iconfont icon-pic" style=""></span>IMGPrompt<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://tools.newzone.top/json-translate" rel="noopener noreferrer" target="_blank" aria-label="多语言处理" class="nav-link"><span class="font-icon icon iconfont icon-others" style=""></span>多语言处理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://nav.newzone.top/" rel="noopener noreferrer" target="_blank" aria-label="工具收藏" class="nav-link"><span class="font-icon icon iconfont icon-categoryselected" style=""></span>工具收藏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/EkkoSonya" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">学术</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">代码</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java 9 17</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java Hint</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java Item</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java Ssm</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Javaweb</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">中间件</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Kafka</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/1.html" aria-label="Kafka - 1"><!---->Kafka - 1<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html" aria-label="Kafka - 2 客户端工作机制1"><!---->Kafka - 2 客户端工作机制1<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#客户端工作机制" aria-label="客户端工作机制"><!---->客户端工作机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#消费者分组消费机制" aria-label="消费者分组消费机制"><!---->消费者分组消费机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#group-id-config" aria-label="GROUP_ID_CONFIG"><!---->GROUP_ID_CONFIG<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#rebalance" aria-label="rebalance"><!---->rebalance<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#偏移量-offset" aria-label="偏移量 offset"><!---->偏移量 offset<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#可能解决方案" aria-label="可能解决方案"><!---->可能解决方案<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#生产者拦截器机制" aria-label="生产者拦截器机制"><!---->生产者拦截器机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#消息序列化机制" aria-label="消息序列化机制"><!---->消息序列化机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#producer的序列化" aria-label="Producer的序列化"><!---->Producer的序列化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#consumer的反序列化" aria-label="Consumer的反序列化"><!---->Consumer的反序列化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#自定义序列化" aria-label="自定义序列化"><!---->自定义序列化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#消息分区路由机制" aria-label="消息分区路由机制"><!---->消息分区路由机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#producer-发送消息的路由机制-partitioner-class-config" aria-label="Producer 发送消息的路由机制 PARTITIONER_CLASS_CONFIG"><!---->Producer 发送消息的路由机制 PARTITIONER_CLASS_CONFIG<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#partitioner接口" aria-label="Partitioner接口"><!---->Partitioner接口<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#defaultpartitioner" aria-label="DefaultPartitioner"><!---->DefaultPartitioner<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#roundrobinpartitioner" aria-label="RoundRobinPartitioner"><!---->RoundRobinPartitioner<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#consumer-接受消息的路由机制-partition-assignment-strategy" aria-label="Consumer 接受消息的路由机制 PARTITION_ASSIGNMENT_STRATEGY"><!---->Consumer 接受消息的路由机制 PARTITION_ASSIGNMENT_STRATEGY<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/2.html#消费者组如何确定分区" aria-label="消费者组如何确定分区"><!---->消费者组如何确定分区<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul></li></ul></li></ul><!--]--></li><li><!--[--><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/4.html" aria-label="Kafka - 3"><!---->Kafka - 3<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/3.html" aria-label="Kafka - 3 客户端工作机制2"><!---->Kafka - 3 客户端工作机制2<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">八股</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">随笔</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Kafka - 2 客户端工作机制1</h1><div class="page-info"><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category6 clickable" role="navigation">code</span><!--]--><meta property="articleSection" content="code"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag5 clickable" role="navigation">中间件</span><span class="page-tag-item tag2 clickable" role="navigation">Kafka</span><!--]--><meta property="keywords" content="中间件,Kafka"></span><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 6202 字</span><meta property="wordCount" content="6202"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 21 分钟</span><meta property="timeRequired" content="PT21M"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#客户端工作机制">客户端工作机制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level3" href="/#消费者分组消费机制">消费者分组消费机制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#group-id-config">GROUP_ID_CONFIG</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#rebalance">rebalance</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#偏移量-offset">偏移量 offset</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level5" href="/#可能解决方案">可能解决方案</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level3" href="/#生产者拦截器机制">生产者拦截器机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level3" href="/#消息序列化机制">消息序列化机制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#producer的序列化">Producer的序列化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#consumer的反序列化">Consumer的反序列化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#自定义序列化">自定义序列化</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level3" href="/#消息分区路由机制">消息分区路由机制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#producer-发送消息的路由机制-partitioner-class-config">Producer 发送消息的路由机制 PARTITIONER_CLASS_CONFIG</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level5" href="/#partitioner接口">Partitioner接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level5" href="/#defaultpartitioner">DefaultPartitioner</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level5" href="/#roundrobinpartitioner">RoundRobinPartitioner</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level4" href="/#consumer-接受消息的路由机制-partition-assignment-strategy">Consumer 接受消息的路由机制 PARTITION_ASSIGNMENT_STRATEGY</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level5" href="/#消费者组如何确定分区">消费者组如何确定分区</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="客户端工作机制" tabindex="-1"><a class="header-anchor" href="#客户端工作机制"><span>客户端工作机制</span></a></h2><p>其实Kafka的设计精髓，是在网络不稳定，服务也随时会崩溃的这些作死的复杂场景下，如何保证消息的高并发、高吞吐，那才是Kafka最为精妙的地方。但是要理解那些复杂的问题，都是需要建立在这个基础模型基础上的</p><h3 id="消费者分组消费机制" tabindex="-1"><a class="header-anchor" href="#消费者分组消费机制"><span>消费者分组消费机制</span></a></h3><h4 id="group-id-config" tabindex="-1"><a class="header-anchor" href="#group-id-config"><span><code>GROUP_ID_CONFIG</code></span></a></h4><p>​在Consumer中，都需要指定一个 <code>GROUP_ID_CONFIG</code> 属性，这表示当前Consumer所属的消费者组</p><p>对应的 <code>ConsumerConfig</code> 对应的配置</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">GROUP_ID_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;group.id&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">GROUP_ID_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;A unique string that identifies the consumer group this consumer belongs to. This property is required if the consumer uses either the group management functionality by using &lt;code&gt;subscribe(topic)&lt;/code&gt; or the Kafka-based offset management strategy.&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>既然这里提到了kafka-based offset management strategy，那是不是也有非Kafka管理Offset的策略呢？</p><p>另外，还有一个相关的参数 <code>GROUP_INSTANCE_ID_CONFIG</code>, 可以给组成员设置一个固定的instanceId，这个参数通常可以用来减少Kafka不必要的rebalance</p><p>如果没设置，就按照动态的来进行分配member，设置了这个consumer就被视为一个静态的member，可以用来减少 Kafka 组的不必要的rebalance</p></blockquote><p>对于Consumer，如果需要在subcribe时使用组管理功能以及Kafka提供的offset管理策略，那就必须要配置 <code>GROUP_ID_CONFIG</code> 属性</p><p>这个分组消费机制简单描述就是这样的：</p><figure><img src="/assets/img/3.7d8dac58.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>​生产者往Topic下发消息时，会尽量均匀的将消息发送到Topic下的各个Partition当中。而这个消息，会向所有订阅了该Topic的消费者推送。推送时，每个ConsumerGroup中只会推送一份。也就是同一个消费者组中的多个消费者实例，只会共同消费一个消息副本。而不同消费者组之间，会重复消费消息副本。这就是消费者组的作用。</p><h4 id="rebalance" tabindex="-1"><a class="header-anchor" href="#rebalance"><span>rebalance</span></a></h4><p>rebalance 就是 kafka 会合理平衡地为一个消费者组里的消费者分配对应的partition</p><p>一个消费者组 是由多个 消费者 组成的，消费者组会共同消费一个或多个 topic 下的所有 分区。但是，当消费者组中的消费者数量发生变化，或者当 Kafka 集群中的分区数量变化时，就会触发 rebalance，即重新分配分区</p><p>分区是消费的基本单位，每个分区只能被 一个消费者组内的一个消费者 消费。当消费者组的成员发生变化时，比如增加/减少了消费者，或者 Kafka 中的 topic 分区发生了变化，Kafka 需要通过 rebalance 来确保每个分区有且仅有一个消费者负责消费。</p><p>一个 Kafka partition 通常 对应一个 consumer，但这是 针对同一个消费者组（Consumer Group） 的情况</p><p>只要不属于同一个消费者组，就可以同时消费同一个partition</p><h4 id="偏移量-offset" tabindex="-1"><a class="header-anchor" href="#偏移量-offset"><span>偏移量 offset</span></a></h4><p>与之相关的还有Offset偏移量。这个偏移量表示每个消费者组在每个Partiton中已经消费处理的进度。在Kafka中，可以看到消费者组的Offset记录情况。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>./kafka-consumer-groups.sh --bootstrap-server worker1:9092 <span class="token parameter variable">--describe</span> <span class="token parameter variable">--group</span> <span class="token builtin class-name">test</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​这个Offset偏移量，需要消费者处理完成后主动向Kafka的Broker提交</p><p>提交完成后，Broker就会更新消费进度，表示这个消息已经被这个消费者组处理完了</p><p>但是如果消费者没有提交Offset，Broker就会认为这个消息还没有被处理过，就会重新往对应的消费者组进行推送，不过这次，一般会尽量推送给同一个消费者组当中的其他消费者实例</p><p>​在示例当中，是通过业务端主动调用Consumer的<code>commitAsync</code>方法或者<code>commitSync</code>方法主动提交的，Kafka中自然也提供了自动提交Offset的方式</p><p>使用自动提交，只需要在Comsumer中配置ENABLE_AUTO_COMMIT_CONFIG属性即可</p><p>从这里可以看到，Offset是Kafka进行消息推送控制的关键之处。这里需要思考两个问题：</p><ul><li><p><code>Offset</code>是根据<code>Group</code>、<code>Partition</code>分开记录的。消费者如果一个Partition对应多个Consumer消费者实例，那么每个Consumer实例都会往Broker提交同一个Partition的不同Offset，这时候Broker要听谁的？</p><p>所以一个Partition最多只能同时被一个Consumer消费。也就是说，示例中四个Partition的Topic，那么同一个消费者组中最多就只能配置四个消费者实例</p></li><li><p>这么关键的Offset数据，保存在Broker端，但是却是由&quot;不靠谱&quot;的消费者主导推进，这显然是不够安全的。那么应该如何提高Offset数据的安全性呢？</p><p>如果你有兴趣自己观察，会发现在Consumer中，实际上也提供了<code>AUTO_OFFSET_RESET_CONFIG</code>参数，来指定消费者组在服务端的Offset不存在时如何进行后续消费。(有可能服务端初始化Consumer Group的Offset失败，也有可能Consumer Group当前的Offset对应的数据文件被过期删除了)这就相当于服务端做的兜底保障</p></li></ul><blockquote><p>ConsumerConfig.AUTO_OFFSET_RESEWT_CONFIG ：当Server端没有对应的Offset时，要如何处理。 可选项：</p><ul><li>earliest： 自动设置为当前最早的offset</li><li>latest：自动设置为当前最晚的offset</li><li>none： 如果消费者组对应的offset找不到，就向Consumer抛异常</li></ul></blockquote><p>有了服务端兜底后，消费者应该要如何保证offset的安全性呢？</p><p>异步提交 (效率高，但可能会发生消息丢失)</p><p>同步提交 (可靠性高，但效率相对低，可能发生重复处理)</p><p>有两种方式：</p><p>一种是异步提交。就是消费者在处理业务的同时，异步向Broker提交Offset</p><p>这样好处是消费者的效率会比较高，但是如果消费者的消息处理失败了，而offset又成功提交了, 这就会造成<strong>消息丢失</strong>。</p><p>另一种方式是同步提交。消费者保证处理完所有业务后，再提交Offset</p><p>这样的好处自然是消息不会因为offset丢失了。因为如果业务处理失败，消费者就可以不去提交Offset，这样消息还可以重试。</p><p>但是坏处是消费者处理信息自然就慢了。另外还会产生消息重复。</p><p>因为Broker端不可能一直等待消费者提交, 如果消费者的业务处理时间比较长，这时在消费者正常处理消息的过程中，Broker端就已经等不下去了，认为这个消费者处理失败了。</p><p>这时就会往同组的其他消费者实例投递消息，这就造成了<strong>消息重复处理</strong></p><h5 id="可能解决方案" tabindex="-1"><a class="header-anchor" href="#可能解决方案"><span>可能解决方案</span></a></h5><p>其实这类问题的根源在于Offset反映的是消息的处理进度。而消息处理进度跟业务的处理进度又是不同步的。所有我们可以换一种思路，将Offset从Broker端抽取出来，放到第三方存储比如Redis里自行管理。这样就可以自己控制用业务的处理进度推进Offset往前更新。</p><h3 id="生产者拦截器机制" tabindex="-1"><a class="header-anchor" href="#生产者拦截器机制"><span>生产者拦截器机制</span></a></h3><p>​生产者拦截机制允许客户端在生产者在消息发送到Kafka集群之前，对消息进行拦截，甚至可以修改消息内容</p><p>这涉及到Producer中指定的一个参数：<code>INTERCEPTOR_CLASSES_CONFIG</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">INTERCEPTOR_CLASSES_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;interceptor.classes&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">INTERCEPTOR_CLASSES_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;A list of classes to use as interceptors. Implementing the &lt;code&gt;org.apache.kafka.clients.producer.ProducerInterceptor&lt;/code&gt; interface allows you to intercept (and possibly mutate) the records received by the producer before they are published to the Kafka cluster. By default, there are no interceptors.&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>按照他的说明，我们可以定义一个自己的拦截器实现类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ProducerInterceptor</span> <span class="token punctuation">{</span>
  <span class="token comment">//发送消息时触发</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token class-name">ProducerRecord</span> <span class="token function">onSend</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span> producerRecord<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;prudocerRecord : &quot;</span> <span class="token operator">+</span> producerRecord<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> producerRecord<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//收到服务端响应时触发</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAcknowledgement</span><span class="token punctuation">(</span><span class="token class-name">RecordMetadata</span> recordMetadata<span class="token punctuation">,</span> <span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;acknowledgement recordMetadata:&quot;</span><span class="token operator">+</span>recordMetadata<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//连接关闭时触发</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;producer closed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//整理配置项</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;=====config start======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;entry.key:&quot;</span><span class="token operator">+</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot; === entry.value: &quot;</span><span class="token operator">+</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;=====config end======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在生产者中指定拦截器类（多个拦截器类，用逗号隔开）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">INTERCEPTOR_CLASSES_CONFIG</span><span class="token punctuation">,</span><span class="token string">&quot;com.roy.kfk.basic.MyInterceptor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>拦截器机制一般用得比较少，主要用在一些统一添加时间等类似的业务场景。比如，用Kafka传递一些POJO，就可以用拦截器统一添加时间属性。但是我们平常用Kafka传递的都是String类型的消息，POJO类型的消息，Kafka可以传吗？这就要用到下面的消息序列化机制</p><h3 id="消息序列化机制" tabindex="-1"><a class="header-anchor" href="#消息序列化机制"><span>消息序列化机制</span></a></h3><h4 id="producer的序列化" tabindex="-1"><a class="header-anchor" href="#producer的序列化"><span>Producer的序列化</span></a></h4><p>​在之前的简单示例中，Producer指定了两个属性<code>KEY_SERIALIZER_CLASS_CONFIG</code>和<code>VALUE_SERIALIZER_CLASS_CONFIG</code>，对于这两个属性，在ProducerConfig中都有配套的说明属性</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_SERIALIZER_CLASS_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;key.serializer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_SERIALIZER_CLASS_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;Serializer class for key that implements the &lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt; interface.&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">VALUE_SERIALIZER_CLASS_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;value.serializer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">VALUE_SERIALIZER_CLASS_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;Serializer class for value that implements the &lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt; interface.&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这两个参数，可以指定消息生产者如何将消息的key和value序列化成二进制数据</p><p>在Kafka的消息定义中，key和value的作用是不同的</p><ul><li>key是用来进行分区的可选项。Kafka通过key来判断消息要分发到哪个Partition</li><li>Value是业务上比较关心的消息。Kafka同样需要将Value对象通过Serializer序列化接口，将Key转换成byte[]数组，这样才能比较好的在网络上传输Value信息，以及将Value信息落盘到操作系统的文件当中</li></ul><p>如果没有填写key，那么Kafka会自动选择Partition</p><p>如果填写了key，那么会通过声明的Serializer序列化接口，将key转换成一个byte[]数组，然后对key进行hash，选择Partition。这样可以保证key相同的消息会分配到相同的Partition中</p><h4 id="consumer的反序列化" tabindex="-1"><a class="header-anchor" href="#consumer的反序列化"><span>Consumer的反序列化</span></a></h4><p>生产者要对消息进行序列化，那么消费者拉取消息时，自然需要进行反序列化</p><p>所以，在Consumer中，也有反序列化的两个配置</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_DESERIALIZER_CLASS_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;key.deserializer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_DESERIALIZER_CLASS_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;Deserializer class for key that implements the &lt;code&gt;org.apache.kafka.common.serialization.Deserializer&lt;/code&gt; interface.&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">VALUE_DESERIALIZER_CLASS_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;value.deserializer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">VALUE_DESERIALIZER_CLASS_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;Deserializer class for value that implements the &lt;code&gt;org.apache.kafka.common.serialization.Deserializer&lt;/code&gt; interface.&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与 Producer 的序列化机制相反，Consumer的反序列化是将从Kafka得到的消息二进制数据反序列化为对应的 key 和 value，以便后续的业务操作</p><h4 id="自定义序列化" tabindex="-1"><a class="header-anchor" href="#自定义序列化"><span>自定义序列化</span></a></h4><p>在Kafka中，对于常用的一些基础数据类型，都已经提供了对应的实现类。但是，如果需要使用一些自定义的消息格式，比如自己定制的POJO，就需要定制具体的实现类了</p><figure><img src="/assets/img/4.79449d67.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>​在自己进行序列化机制时，需要考虑的是如何用二进制来描述业务数据</p><p>例如对于一个通常的POJO类型，可以将他的属性拆分成两种类型：</p><p>一种类型是定长的基础类型，比如Integer,Long,Double等</p><p>这些基础类型转化成二进制数组都是定长的。这类属性可以直接转成序列化数组，在反序列化时，只要按照定长去读取二进制数据就可以反序列化了</p><p>另一种是不定长的浮动类型，比如String，或者基于String的JSON类型等</p><p>这种浮动类型的基础数据转化成二进制数组，长度都是不一定的</p><p>对于这类数据，通常的处理方式都是先往二进制数组中写入一个定长的数据的长度数据(Integer或者Long类型)，然后再继续写入数据本身</p><p>这样，反序列化时，就可以先读取一个定长的长度，再按照这个长度去读取对应长度的二进制数据，这样就能读取到数据的完整二进制内容</p><blockquote><p>序列化机制是在高并发场景中非常重要的一个优化机制</p><p>高效的系列化实现能够极大的提升分布式系统的网络传输以及数据落盘的能力</p><p>例如对于一个User对象，即可以使用JSON字符串这种简单粗暴的序列化方式，也可以选择按照各个字段进行组合序列化的方式。但是显然后者的占用空间比较小，序列化速度也会比较快。而Kafka在文件落盘时，也设计了非常高效的数据序列化实现，这也是Kafka高效运行的一大支撑。</p><p>在很多其他业务场景中，也需要我们提供更高效的序列化实现</p><p>例如使用MapReduce框架时，就需要自行定义数据的序列化方式。使用Netty框架进行网络调用时，为了防止粘包，也需要定制数据的序列化机制。在这些场景下，进行序列化的基础思想，和我们这里介绍的也是一样的。当然，如果我们可以进一步设计出更简短高效的数据压缩算法，那也就能更进一步提高数据传输的效率。比如对二进制数据进行压缩。而这就是算法最直接的作用</p></blockquote><h3 id="消息分区路由机制" tabindex="-1"><a class="header-anchor" href="#消息分区路由机制"><span>消息分区路由机制</span></a></h3><p>消息如何进行路由，也就是发送的消息到底是根据什么来存储到对应的Topic的指定Partition下的呢</p><ul><li>对于 Producer，会根据消息的key选择Partition，那具体如何通过key找Partition呢？</li><li>一个消费者组会共同消费一个Topic下的多个Partition中的同一套消息副本，那具体到对应的Consumer节点是不是可以决定自己消费哪些Partition的消息呢？</li></ul><figure><img src="/assets/img/5.56edafb7.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>这两个问题不难，同样的方法，依旧去对应的Config类进行查找即可</p><h4 id="producer-发送消息的路由机制-partitioner-class-config" tabindex="-1"><a class="header-anchor" href="#producer-发送消息的路由机制-partitioner-class-config"><span>Producer 发送消息的路由机制 <code>PARTITIONER_CLASS_CONFIG</code></span></a></h4><p>当给定了 <code>PARTITIONER_CLASS_CONFIG</code> 的属性就可以自定义Producer的分区机制(决定发送的消息到哪个Partition)</p><p>具体说明如下</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PARTITIONER_CLASS_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;partitioner.class&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PARTITIONER_CLASS_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;Determines which partition to send a record to when records are produced. Available options are: &quot;</span> <span class="token operator">+</span> 
<span class="token string">&quot;&lt;ul&gt;&quot;</span> <span class="token operator">+</span> 
<span class="token string">&quot;&lt;li&gt;If not set, the default partitioning logic is used. This strategy send records to a partition until at least batch.size bytes is produced to the partition.&quot;</span> <span class="token operator">+</span> 
<span class="token string">&quot;It works with the strategy:&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;ol&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;If no partition is specified but a key is present, choose a partition based on a hash of the key.&lt;/li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;If no partition or key is present, choose the sticky partition that changes when at least batch.size bytes are produced to the partition.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;&lt;code&gt;org.apache.kafka.clients.producer.RoundRobinPartitioner&lt;/code&gt;:&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;A partitioning strategy where each record in a series of consecutive records is sent to a different partition, regardless of whether the &#39;key&#39; is provided or not, until partitions run out and the process starts over again.&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;Note: There&#39;s a known issue that will cause uneven distribution when a new batch is created. See KAFKA-9965 for more detail.&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;/li&gt;&lt;/ul&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;p&gt;Implementing the &lt;code&gt;org.apache.kafka.clients.producer.Partitioner&lt;/code&gt; interface allows you to plug in a custom partitioner.&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有设置该属性，那么会采用默认的分区机制</p><table><thead><tr><th><strong>场景</strong></th><th><strong>策略名称</strong></th><th><strong>行为逻辑</strong></th></tr></thead><tbody><tr><td><strong>默认 (有 Key)</strong></td><td>Hash 策略</td><td>相同 Key -&gt; 相同分区</td></tr><tr><td><strong>默认 (无 Key)</strong></td><td><strong>Sticky 策略</strong></td><td>填满一个 batch.size 后再换分区</td></tr><tr><td><strong>指定 RoundRobin</strong></td><td>轮询策略</td><td>强制轮流发，忽略 Key (绝对均衡，但可能牺牲性能)</td></tr><tr><td><strong>自定义</strong></td><td>Custom</td><td>你通过代码自己决定</td></tr></tbody></table><h5 id="partitioner接口" tabindex="-1"><a class="header-anchor" href="#partitioner接口"><span><code>Partitioner</code>接口</span></a></h5><p>如果我们要自定义分区策略，那么就需要实现 <code>org.apache.kafka.clients.producer.Partitioner</code> 接口，并在传参数时指定 <code>PARTITIONER_CLASS_CONFIG</code> 为我们自定义实现类</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Partitioner</span> <span class="token keyword">extends</span> <span class="token class-name">Configurable</span><span class="token punctuation">,</span> <span class="token class-name">Closeable</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">,</span> <span class="token class-name">Object</span> var2<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var3<span class="token punctuation">,</span> <span class="token class-name">Object</span> var4<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var5<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token doc-comment comment">/** <span class="token keyword">@deprecated</span> */</span>
  <span class="token annotation punctuation">@Deprecated</span>
  <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onNewBatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">,</span> <span class="token keyword">int</span> prevPartition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里就说明了Kafka是通过一个Partitioner接口的具体实现来决定一个消息如何根据Key分配到对应的Partition上的。你甚至可以很简单的实现一个自己的分配策略。</p><p>​在之前的3.2.0版本，Kafka提供了三种默认的Partitioner实现类，<code>RoundRobinPartitioner</code>，<code>DefaultPartitioner</code>和<code>UniformStickyPartitioner</code></p><p>目前后面两种实现已经标记为过期，被替换成了默认的实现机制</p><p>对于生产者，默认的Sticky策略在给一个生产者分配了一个分区后，会尽可能一直使用这个分区</p><p>等待该分区的batch.size(默认16K)已满，或者这个分区的消息已完成 linger.ms(默认0毫秒，表示如果batch.size迟迟没有满后的等待时间)</p><p>RoundRobinPartitioner是在各个Partition中进行轮询发送，这种方式没有考虑到消息大小以及各个Broker性能差异，用得比较少。</p><p>​另外可以自行指定一个Partitioner实现类，定制分区逻辑。</p><p>在Partitioner接口中，核心要实现的就是partition方法。根据相关信息，选择一个Partition。比如用key对partition的个数取模之类的。而Topic下的所有Partition信息都在cluster参数中。</p><h5 id="defaultpartitioner" tabindex="-1"><a class="header-anchor" href="#defaultpartitioner"><span><code>DefaultPartitioner</code></span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/** <span class="token keyword">@deprecated</span> */</span>
<span class="token annotation punctuation">@Deprecated</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultPartitioner</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StickyPartitionCache</span> stickyPartitionCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StickyPartitionCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> key<span class="token punctuation">,</span> keyBytes<span class="token punctuation">,</span> value<span class="token punctuation">,</span> valueBytes<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">,</span> <span class="token keyword">int</span> numPartitions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> keyBytes <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stickyPartitionCache<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> cluster<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">BuiltInPartitioner</span><span class="token punctuation">.</span><span class="token function">partitionForKey</span><span class="token punctuation">(</span>keyBytes<span class="token punctuation">,</span> numPartitions<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNewBatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">,</span> <span class="token keyword">int</span> prevPartition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stickyPartitionCache<span class="token punctuation">.</span><span class="token function">nextPartition</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> prevPartition<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认方法同样是 如果没有 Key -&gt; 走 sticky 如果有 Key -&gt; 走 BuiltInPartitioner.partitionForKey (哈希)</p><p>但可以看到有标注注解 <code>@Deprecated</code></p><p>问 Gemini 是说性能优化</p><p>在旧版本（Kafka 3.3 之前），默认流程是这样的：</p><ol><li>你没配 partitioner.class。</li><li>Kafka 默认帮你把 partitioner.class 设置为 DefaultPartitioner。</li><li>Kafka 通过反射加载这个类，实例化它。</li></ol><p>每发一条消息，都要通过 Partitioner 接口调用 这个类的方法</p><p>现在（Kafka 3.3+）的流程是这样的：</p><p>Kafka 团队认为：既然 99% 的人都在用默认策略，为什么还要走“反射加载”和“接口虚方法调用”这种甚至有点慢的“插件化”流程呢？</p><p>于是他们做了一个改动：</p><ol><li>如果你不配置 partitioner.class（留空）。</li><li>Kafka Producer 不会再去加载 DefaultPartitioner 这个类了。</li><li>Producer 内部会直接调用内置的高效逻辑（逻辑和 DefaultPartitioner 一模一样，但不需要经过这个类的包装）</li></ol><p>去 <code>org.apache.kafka.clients.producer.KafkaProducer</code> 类中可以找到对应的方法</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> serializedKey<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> serializedValue<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 【情况 1：指定分区】</span>
  <span class="token comment">// 如果你在发消息时代码里写死了分区：new ProducerRecord(topic, partition, key, value)</span>
  <span class="token comment">// 优先级最高，直接用，不走任何计算逻辑。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> record<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
  
  <span class="token comment">// 【情况 2：外包模式 (Plugin Path)】</span>
  <span class="token comment">// 这里就是重点！如果你在配置里设置了 partitioner.class = ...</span>
  <span class="token comment">// 不管你是设置了自定义的类，还是显式设置了那个过时的 DefaultPartitioner，</span>
  <span class="token comment">// this.partitioner 都不会是 null。</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>partitioner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 于是这里会走“接口调用”，进入你指定的类里去算。</span>
      <span class="token keyword">int</span> customPartition <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>partitioner<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> serializedKey<span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> serializedValue<span class="token punctuation">,</span> cluster<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>customPartition <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;The partitioner generated an invalid partition number: %d. Partition number should always be non-negative.&quot;</span><span class="token punctuation">,</span> customPartition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> customPartition<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  
  <span class="token comment">// 【情况 3：直营模式 (Internal Fast Path)】</span>
  <span class="token comment">// 这就是现在默认的高效路径！</span>
  <span class="token comment">// 如果你没配 partitioner.class，this.partitioner 就是 null，直接进这里。</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 逻辑：</span>
    <span class="token comment">// 1. 如果有 Key (serializedKey != null) 且没忽略 Key：直接调用内置静态方法算 Hash。</span>
    <span class="token comment">// 2. 如果没有 Key：返回 -1。</span>
    <span class="token keyword">return</span> serializedKey <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>partitionerIgnoreKeys <span class="token operator">?</span> 
            <span class="token class-name">BuiltInPartitioner</span><span class="token punctuation">.</span><span class="token function">partitionForKey</span><span class="token punctuation">(</span>serializedKey<span class="token punctuation">,</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> 
            <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在【情况 3】中，如果没有 Key，它竟然返回了-1</p><p>这就是性能优化的核心所在：</p><ul><li>以前 (DefaultPartitioner)： 如果没有 Key，DefaultPartitioner 会在一个外部类里算好“当前应该粘在哪个分区”，然后把计算好的分区号（比如 3）返回给 Producer。</li><li>现在 (返回 -1)： Producer 拿到 -1，并不是报错，而是代表一个信号：“我不在这一层决定分区”。 它会把消息传给下游的 RecordAccumulator（消息累加器）。累加器发现分区是 -1，就会直接根据当前哪个批次（Batch）没满，直接塞进去。</li></ul><p>优势： 这种判断逻辑更靠近底层的数据结构，减少了上层不必要的计算和锁竞争，这就是为什么它被称为“直营模式”更高效的原因</p><h5 id="roundrobinpartitioner" tabindex="-1"><a class="header-anchor" href="#roundrobinpartitioner"><span><code>RoundRobinPartitioner</code></span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoundRobinPartitioner</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义了一个自增器</span>
  <span class="token comment">// key: Topic value: 当前的partition (原子类实现并发)</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">&gt;</span></span> topicCounterMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 得到当前的分区原始索引值</span>
    <span class="token keyword">int</span> nextValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">nextValue</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取当前Topic的总分区数</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> availablePartitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">availablePartitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>availablePartitions<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 优先在“活着”的分区里轮询</span>
      <span class="token comment">// 取模运算，转到对应分区</span>
      <span class="token keyword">int</span> part <span class="token operator">=</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">toPositive</span><span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token operator">%</span> availablePartitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">)</span>availablePartitions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果所有分区都挂了（或者不可用），那就死马当活马医，在“所有”分区里轮询</span>
      <span class="token keyword">int</span> numPartitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">toPositive</span><span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span> <span class="token operator">%</span> numPartitions<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">nextValue</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是第一次见这个 topic，创建一个新的计数器（从0开始）</span>
    <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>topicCounterMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回当前值，并加 1</span>
    <span class="token keyword">return</span> counter<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种策略极其简单且公平，但正如官方文档提到的，它有一个致命缺点：它破坏了“粘性（Sticky）”。如果并发量大，它会导致 Producer 无法有效地将消息打包成 Batch（因为每条消息都换了地方），从而导致网络请求次数激增，效率下降</p><h4 id="consumer-接受消息的路由机制-partition-assignment-strategy" tabindex="-1"><a class="header-anchor" href="#consumer-接受消息的路由机制-partition-assignment-strategy"><span>Consumer 接受消息的路由机制 <code>PARTITION_ASSIGNMENT_STRATEGY</code></span></a></h4><p>在Consumer中，可以指定一个PARTITION_ASSIGNMENT_STRATEGY分区分配策略，决定如何在多个Consumer实例和多个Partitioner之间建立关联关系</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PARTITION_ASSIGNMENT_STRATEGY_CONFIG</span> <span class="token operator">=</span> <span class="token string">&quot;partition.assignment.strategy&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PARTITION_ASSIGNMENT_STRATEGY_DOC</span> <span class="token operator">=</span> <span class="token string">&quot;A list of class names or class types, ordered by preference, of supported partition assignment strategies that the client will use to distribute partition ownership amongst consumer instances when group management is used.&quot;</span> <span class="token operator">+</span> 
<span class="token string">&quot;Available options are:&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;ul&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;code&gt;org.apache.kafka.clients.consumer.RangeAssignor&lt;/code&gt;:&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;Assigns partitions on a per-topic basis.&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;/li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;code&gt;org.apache.kafka.clients.consumer.RoundRobinAssignor&lt;/code&gt;:&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;Assigns partitions to consumers in a round-robin fashion.&lt;/li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;code&gt;org.apache.kafka.clients.consumer.StickyAssignor&lt;/code&gt;:&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;Guarantees an assignment that is maximally balanced while preserving as many existing partition assignments as possible.&lt;/li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;li&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;code&gt;org.apache.kafka.clients.consumer.CooperativeStickyAssignor&lt;/code&gt;: Follows the same StickyAssignor logic, but allows for cooperative rebalancing.&lt;/li&gt;&lt;/ul&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;p&gt;The default assignor is [RangeAssignor, CooperativeStickyAssignor], which will use the RangeAssignor by default, but allows upgrading to the CooperativeStickyAssignor with just a single rolling bounce that removes the RangeAssignor from the list.&lt;/p&gt;&quot;</span><span class="token operator">+</span>
<span class="token string">&quot;&lt;p&gt;Implementing the &lt;code&gt;org.apache.kafka.clients.consumer.ConsumerPartitionAssignor&lt;/code&gt; interface allows you to plug in a custom assignment strategy.&lt;/p&gt;&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，Kafka内置了一些实现方式，在通常情况下也都是最优的选择。你也可以实现自己的分配策略。</p><p>​从上面介绍可以看到Kafka默认提供了三种消费者的分区分配策略</p><ul><li><code>RangeAssignor</code>策略: 比如一个Topic有10个Partiton(partition 0-9) 一个消费者组下有三个Consumer(consumer1-3)。Range策略就会将分区0-3分给一个Consumer，4-6给一个Consumer，7-9给一个Consumer。</li><li><code>RoundRobinAssignor</code>策略：轮询分配策略，可以理解为在Consumer中一个一个轮流分配分区。比如0，3，6，9分区给一个Consumer1，1，4，7分区给一个Consumer2，然后2，5，8给一个Consumer3</li><li><code>CooperativeStickyAssignor</code>策略：粘性策略, 这个策略有两个原则： <ol><li>在开始分区时，尽量保持分区的分配均匀。比如按照Range策略分(这一步实际上是随机的)。</li><li>分区的分配尽可能的与上一次分配的保持一致。比如在range分区的情况下，第三个Consumer的服务宕机了，那么按照sticky策略，就会保持consumer1和consumer2原有的分区分配情况。然后将consumer3分配的7~9分区尽量平均的分配到另外两个consumer上。这种粘性策略可以很好的保持Consumer的数据稳定性。</li></ol></li><li>可以通过继承<code>AbstractPartitionAssignor</code>抽象类自定义消费者的订阅方式</li></ul><p>官方默认提供的生产者端的默认分区器以及消费者端的RangeAssignor+CooperativeStickyAssignor分配策略，在大部分场景下都是非常高效的算法。深入理解这些算法，对于你深入理解MQ场景，以及借此去横向对比理解其他的MQ产品，都是非常有帮助的。</p><h5 id="消费者组如何确定分区" tabindex="-1"><a class="header-anchor" href="#消费者组如何确定分区"><span>消费者组如何确定分区</span></a></h5><p>Consumer 确定分区的过程，实际上就是 Consumer Group Leader（消费者组中的一个主节点）运行对应分区策略代码，计算好分配方案，然后同步给组内其他 Consumer 的过程</p><p>以 <code>RangeAssignor</code> 策略分析</p><p>核心逻辑可以总结为：按 Topic 独立计算，将分区按数字顺序切分成段，依次分给排序后的消费者</p></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/1.html" aria-label="Kafka - 1"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Kafka - 1</div></a><a class="route-link nav-link next" href="/code/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/4.html" aria-label="Kafka - 3"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Kafka - 3<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><img src="/beian.png" style="width:1.2rem;margin-right:2px;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=33019202000049" rel="noopener noreferrer" target="_blank">浙公网安备33019202000049</a></div><div class="vp-copyright">Copyright © 2024-present <a href="http://ekkosonya.cn/" target="_blank" rel="noopener noreferrer">EkkoSonya's Blog</a></div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.e5d268a3.js" defer></script><script src="/assets/js/731.ee5b1103.js" defer></script><script src="/assets/js/app.4d24e321.js" defer></script>
    <!-- 看板娘区块 -->
    <!-- <script src="/live2d-widget/autoload.js"></script> -->
    <!-- End 看板娘区块 -->
  </body>
</html>
