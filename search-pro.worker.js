const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":696,\"nextId\":696,\"documentIds\":{\"0\":\"2\",\"1\":\"2@0\",\"2\":\"2@1\",\"3\":\"3\",\"4\":\"3#类与对象\",\"5\":\"3#方法的创建与使用\",\"6\":\"3#方法的进阶使用\",\"7\":\"3#this-的使用\",\"8\":\"3#方法的重载\",\"9\":\"3#构造方法\",\"10\":\"3@0\",\"11\":\"3@1\",\"12\":\"4\",\"13\":\"4#泛型-2\",\"14\":\"4#泛型方法\",\"15\":\"4#泛型界限\",\"16\":\"4#类型擦除\",\"17\":\"4@0\",\"18\":\"4@1\",\"19\":\"5\",\"20\":\"5#集合类-1\",\"21\":\"5#集合类\",\"22\":\"5#集合类与数组区别\",\"23\":\"5#集合根接口\",\"24\":\"5#list-列表\",\"25\":\"5#arraylist\",\"26\":\"5@0\",\"27\":\"5@1\",\"28\":\"6\",\"29\":\"6#集合类-2\",\"30\":\"6#迭代器\",\"31\":\"6#iterator-简介\",\"32\":\"6#源码定义\",\"33\":\"6#不同集合类-迭代器-实现用例\",\"34\":\"6#使用示例\",\"35\":\"6#其他遍历-集合类-的方式\",\"36\":\"6#iterable-介绍\",\"37\":\"6#listiterator-介绍\",\"38\":\"6@0\",\"39\":\"6@1\",\"40\":\"7\",\"41\":\"7#集合类-3\",\"42\":\"7#quene-和-deque\",\"43\":\"7#quene-队列\",\"44\":\"7#deque-双端队列\",\"45\":\"7#其他集合类实现-队列\",\"46\":\"7#优先级队列\",\"47\":\"7#set-集合\",\"48\":\"7#hashset\",\"49\":\"7#linkedhashset\",\"50\":\"7#treeset\",\"51\":\"7@0\",\"52\":\"7@1\",\"53\":\"8\",\"54\":\"8#集合类-4\",\"55\":\"8#map\",\"56\":\"8#map-基本定义\",\"57\":\"8#hashmap\",\"58\":\"8#hashmap-底层实现\",\"59\":\"8#put-方法\",\"60\":\"8#resize-方法\",\"61\":\"8#linkedhashmap\",\"62\":\"8#treemap\",\"63\":\"8#map-的一些方法\",\"64\":\"8#compute\",\"65\":\"8#merge\",\"66\":\"8#replace\",\"67\":\"8#hashset-底层实现\",\"68\":\"8@0\",\"69\":\"8@1\",\"70\":\"9\",\"71\":\"9#stream流\",\"72\":\"9@0\",\"73\":\"9@1\",\"74\":\"10\",\"75\":\"10#collections-工具类\",\"76\":\"10#最大-最小\",\"77\":\"10#二分搜索\",\"78\":\"10#快速填充\",\"79\":\"10#空集合\",\"80\":\"10#查找位置\",\"81\":\"10@0\",\"82\":\"10@1\",\"83\":\"11\",\"84\":\"11#集合类对象相等判定\",\"85\":\"11@0\",\"86\":\"11@1\",\"87\":\"12\",\"88\":\"12#io流1\",\"89\":\"12#文件字节流\",\"90\":\"12#输入流-java-io-fileinputstream\",\"91\":\"12#文件读取\",\"92\":\"12#输出流-java-io-fileoutputstream\",\"93\":\"12#追加操作\",\"94\":\"12#文件拷贝操作实现\",\"95\":\"12#文件字符流\",\"96\":\"12#filereader\",\"97\":\"12#filewriter\",\"98\":\"12#file类\",\"99\":\"12@0\",\"100\":\"12@1\",\"101\":\"13\",\"102\":\"13#io流2\",\"103\":\"13#缓冲流\",\"104\":\"13#缓冲字节流\",\"105\":\"13#缓冲字节读取流-bufferedinputstream\",\"106\":\"13#缓冲流特性\",\"107\":\"13#_1-装饰着模式\",\"108\":\"13#_2-缓冲机制\",\"109\":\"13#_3-缓冲流可以叠加\",\"110\":\"13#缓冲字节输出流-bufferedoutputstream\",\"111\":\"13#缓冲字符流\",\"112\":\"13#缓冲字符读取流-bufferedreader\",\"113\":\"13#缓冲字符输出流-bufferedwriter\",\"114\":\"13@0\",\"115\":\"13@1\",\"116\":\"14\",\"117\":\"14#静态变量和静态方法\",\"118\":\"14#静态变量初始化\",\"119\":\"14#包的访问与控制\",\"120\":\"14#包的声明和导入\",\"121\":\"14#访问权限控制\",\"122\":\"14@0\",\"123\":\"14@1\",\"124\":\"15\",\"125\":\"15#io流3\",\"126\":\"15#转换流\",\"127\":\"15#打印流-printstream\",\"128\":\"15#输入流\",\"129\":\"15#数据流-datainputstream\",\"130\":\"15#对象流\",\"131\":\"15#对象序列化\",\"132\":\"15#serialversionuid\",\"133\":\"15#transient关键字\",\"134\":\"15@0\",\"135\":\"15@1\",\"136\":\"16\",\"137\":\"16#多线程\",\"138\":\"16#进程与线程概念\",\"139\":\"16#线程的创建和启动\",\"140\":\"16#start方法\",\"141\":\"16#run方法\",\"142\":\"16#sleep方法\",\"143\":\"16#线程的休眠和中断\",\"144\":\"16#中断\",\"145\":\"16#线程优先级\",\"146\":\"16#线程的礼让和加入\",\"147\":\"16#yield-主动让出cpu资源\",\"148\":\"16#join\",\"149\":\"16@0\",\"150\":\"16@1\",\"151\":\"17\",\"152\":\"17#多线程2\",\"153\":\"17#线程锁和线程同步\",\"154\":\"17#多线程下java内存管理\",\"155\":\"17#线程锁-synchronized\",\"156\":\"17#死锁\",\"157\":\"17@0\",\"158\":\"17@1\",\"159\":\"18\",\"160\":\"18#多线程3\",\"161\":\"18#wait-和-notify-方法\",\"162\":\"18#threadlocal\",\"163\":\"18#inheritablethreadlocal\",\"164\":\"18#定时器-timer\",\"165\":\"18#自己定义的定时器\",\"166\":\"18#timer\",\"167\":\"18#timer-不会终止\",\"168\":\"18@0\",\"169\":\"18@1\",\"170\":\"19\",\"171\":\"19#多线程4\",\"172\":\"19#守护线程\",\"173\":\"19#集合类\",\"174\":\"19#生产者与消费者\",\"175\":\"19@0\",\"176\":\"19@1\",\"177\":\"20\",\"178\":\"20#反射1\",\"179\":\"20#反射\",\"180\":\"20#java-类加载机制\",\"181\":\"20#class-类\",\"182\":\"20#获取相应类的class对象\",\"183\":\"20#基本数据类型的-class-对象\",\"184\":\"20#数组的-class-对象\",\"185\":\"20#class-对象与多态\",\"186\":\"20#类型比较\",\"187\":\"20@0\",\"188\":\"20@1\",\"189\":\"21\",\"190\":\"21#反射2\",\"191\":\"21#创建类对象-getconstructor-newinstance\",\"192\":\"21#调用类方法-getmethod-getdeclaredmethod\",\"193\":\"21#修改类的属性-getfield\",\"194\":\"21@0\",\"195\":\"21@1\",\"196\":\"22\",\"197\":\"22#反射3\",\"198\":\"22#类加载器-appclassloader-extclassloader-bootstarpclassloader\",\"199\":\"22#自己编译的类加载到-jvm-中\",\"200\":\"22@0\",\"201\":\"22@1\",\"202\":\"23\",\"203\":\"23#注解\",\"204\":\"23#预设注解\",\"205\":\"23#元注解\",\"206\":\"23#override定义\",\"207\":\"23#注解的使用\",\"208\":\"23#反射获取注解-getannotation\",\"209\":\"23@0\",\"210\":\"23@1\",\"211\":\"24\",\"212\":\"24#封装-继承和多态\",\"213\":\"24#封装\",\"214\":\"24#继承\",\"215\":\"24#object-类\",\"216\":\"24#方法重写-override\",\"217\":\"24#控制符-final\",\"218\":\"24#抽象类-abstract\",\"219\":\"24#接口-interface\",\"220\":\"24#object类中的-克隆方法\",\"221\":\"24#枚举类-enum\",\"222\":\"24@0\",\"223\":\"24@1\",\"224\":\"25\",\"225\":\"25#面向对象高级篇1\",\"226\":\"25#基本类型包装类\",\"227\":\"25#所有包装类如下\",\"228\":\"25#包装类的方法\",\"229\":\"25#特殊包装类\",\"230\":\"25@0\",\"231\":\"25@1\",\"232\":\"26\",\"233\":\"26#面向对象高级篇-2\",\"234\":\"26#数组\",\"235\":\"26#定义\",\"236\":\"26#方法\",\"237\":\"26#访问元素\",\"238\":\"26#特性\",\"239\":\"26#final性质\",\"240\":\"26#多维数组\",\"241\":\"26#可变长参数\",\"242\":\"26#main函数的-string-args\",\"243\":\"26#字符串\",\"244\":\"26#string-类\",\"245\":\"26#stringbuilder-类\",\"246\":\"26#正则表达式\",\"247\":\"26@0\",\"248\":\"26@1\",\"249\":\"27\",\"250\":\"27#内部类\",\"251\":\"27#成员内部类-属于-对象\",\"252\":\"27#静态内部类-属于-类\",\"253\":\"27#局部内部类\",\"254\":\"27#静态内部类编译特性\",\"255\":\"27#匿名内部类\",\"256\":\"27#匿名内部类特性\",\"257\":\"27#lambda表达式\",\"258\":\"27#方法引用\",\"259\":\"27@0\",\"260\":\"27@1\",\"261\":\"28\",\"262\":\"28#面向对象高级篇-4\",\"263\":\"28#异常机制\",\"264\":\"28#异常类型\",\"265\":\"28#自定义异常\",\"266\":\"28#抛出异常-throw\",\"267\":\"28#异常的处理-try-catch-finally\",\"268\":\"28#断言表达式-assert\",\"269\":\"28@0\",\"270\":\"28@1\",\"271\":\"29\",\"272\":\"29#面向对象高级篇-6\",\"273\":\"29#常用工具类\",\"274\":\"29#数学工具类-math\",\"275\":\"29#数组工具类-arrays\",\"276\":\"29@0\",\"277\":\"29@1\",\"278\":\"30\",\"279\":\"30#泛型-1\",\"280\":\"30#使用泛型的原因\",\"281\":\"30#泛型类-classname-t\",\"282\":\"30#泛型和多态\",\"283\":\"30@0\",\"284\":\"30@1\",\"285\":\"31\",\"286\":\"31@0\",\"287\":\"31@1\",\"288\":\"32\",\"289\":\"32#主要动机\",\"290\":\"32#主要贡献\",\"291\":\"32#主要内容\",\"292\":\"32#系统结构\",\"293\":\"32#基本设置\",\"294\":\"32#信号模型\",\"295\":\"32#quality-of-experience-model\",\"296\":\"32#优化问题建立\",\"297\":\"32#解决方案\",\"298\":\"32#无人机的3d部署\",\"299\":\"32#无人机的动态移动设计\",\"300\":\"32@0\",\"301\":\"32@1\",\"302\":\"33\",\"303\":\"33#强化学习框架图\",\"304\":\"33#_1-基本概念\",\"305\":\"33#_2-markov-decision-process-mdp\",\"306\":\"33@0\",\"307\":\"33@1\",\"308\":\"34\",\"309\":\"34#_1-the-simplest-actor-critic-qac\",\"310\":\"34#_2-advantage-actor-critic-a2c\",\"311\":\"34#_2-1-baseline\",\"312\":\"34#_2-2-最好的-baseline\",\"313\":\"34#_2-3-对应算法\",\"314\":\"34#_3-off-policy-actor-critic\",\"315\":\"34#_3-1-重要性采样-importance-sampling\",\"316\":\"34#_3-2-off-policy\",\"317\":\"34#_3-3-伪代码\",\"318\":\"34#_4-deterministic-actor-critic-dpg\",\"319\":\"34@0\",\"320\":\"34@1\",\"321\":\"35\",\"322\":\"35#核心内容\",\"323\":\"35#_1-state-value\",\"324\":\"35#_1-1\",\"325\":\"35#_1-2-state-value\",\"326\":\"35#_1-3-state-value-与-return-的区别\",\"327\":\"35#_2-bellman-equation\",\"328\":\"35#_2-1-the-mean-of-immediate-rewards\",\"329\":\"35#_2-2-the-mean-of-future-rewards\",\"330\":\"35#_2-3-bellman-equation\",\"331\":\"35#_2-4-bellman-equation-matrix-vector-form\",\"332\":\"35#_3-why-to-slove-state-value\",\"333\":\"35#_4-action-value\",\"334\":\"35#_5-总结\",\"335\":\"35@0\",\"336\":\"35@1\",\"337\":\"36\",\"338\":\"36#_1-optimal-policy\",\"339\":\"36#_2-bellman-optimality-equation-boe\",\"340\":\"36#_2-1-基本形式\",\"341\":\"36#_2-2-如何求解\",\"342\":\"36#_2-2-1-如何处理等式右边的-最优策略\",\"343\":\"36#_2-求解-state-value\",\"344\":\"36@0\",\"345\":\"36@1\",\"346\":\"37\",\"347\":\"37#_1-value-iteration-algorithm\",\"348\":\"37#_1-1-具体步骤\",\"349\":\"37#_1-2-伪代码\",\"350\":\"37#_2-policy-iteration-algorithm\",\"351\":\"37#_2-1-算法描述\",\"352\":\"37#_2-2-伪代码\",\"353\":\"37#_2-3-一些问题\",\"354\":\"37#_3-truncated-policy-iteration-algorithm\",\"355\":\"37#_3-1-value-iteration-与-policy-iteration-算法比较\",\"356\":\"37#_3-2-truncated-policy-iteration-algorithm\",\"357\":\"37#truncated-policy-iteration-algorithm-是否是收敛的\",\"358\":\"37@0\",\"359\":\"37@1\",\"360\":\"38\",\"361\":\"38#_1-mc-basic\",\"362\":\"38#_1-1-算法思路\",\"363\":\"38#_1-2-如何估计\",\"364\":\"38#_1-3-具体算法\",\"365\":\"38#_2-mc-exploring-starts\",\"366\":\"38#_2-1-episode-的高效利用\",\"367\":\"38#_2-2-高效地更新-policy\",\"368\":\"38#_2-3-mc-exploring-starts\",\"369\":\"38#_2-4-exploring-statrts的解释\",\"370\":\"38#_3-mc-eplison-greedy\",\"371\":\"38#_3-1-soft-policy\",\"372\":\"38#_3-2-greedy-policy\",\"373\":\"38#_3-3-greedy-policy-引入-mc-based-算法中\",\"374\":\"38#_3-3-算法流程\",\"375\":\"38@0\",\"376\":\"38@1\",\"377\":\"39\",\"378\":\"39#_1-引言\",\"379\":\"39#_1-1-求均值的方法\",\"380\":\"39#_2-robbins-monto-rm-algorithm\",\"381\":\"39#_2-1-问题引入\",\"382\":\"39#_2-2-算法介绍\",\"383\":\"39#_2-3-收敛性分析\",\"384\":\"39#_2-4-应用于-mean-estimation-中\",\"385\":\"39#_3-stochastic-gradient-descent\",\"386\":\"39#_3-1-问题引入\",\"387\":\"39#_3-2-sgd-分析\",\"388\":\"39#mean-estimation-问题转化\",\"389\":\"39#sgd-正确性和收敛性分析\",\"390\":\"39#_3-3-sgd-另一种问题描述方法-deterministic-formulation\",\"391\":\"39#_3-4-bgd-mbgd-sgdw\",\"392\":\"39@0\",\"393\":\"39@1\",\"394\":\"40\",\"395\":\"40#_1-引入\",\"396\":\"40#_2-td-learning-of-state-value\",\"397\":\"40#_2-1-算法描述\",\"398\":\"40#_2-2-算法分析\",\"399\":\"40#_2-3-td-算法-与-mc-算法的比较\",\"400\":\"40#_3-td-learning-of-action-value\",\"401\":\"40#_3-1-sarsa\",\"402\":\"40#_3-2-n-step-sarsa\",\"403\":\"40#_3-3-expected-sarsa\",\"404\":\"40#_4-td-learning-of-optimal-action-value\",\"405\":\"40#_4-1-q-learning\",\"406\":\"40#_4-2-off-policy-on-policy\",\"407\":\"40#on-policy\",\"408\":\"40#off-policy\",\"409\":\"40#_4-3-q-learning-伪代码\",\"410\":\"40#off-poicy-版本\",\"411\":\"40#on-policy-版本\",\"412\":\"40#_5-td-算法的统一形式和总结\",\"413\":\"40@0\",\"414\":\"40@1\",\"415\":\"41\",\"416\":\"41#_1-引入\",\"417\":\"41#_2-alogorithm-of-state-value-estimation\",\"418\":\"41#_2-1-obejctive-function\",\"419\":\"41#uniform-distributon\",\"420\":\"41#stationary-distribution\",\"421\":\"41#_2-2-optimization-algorithms-优化算法\",\"422\":\"41#monte-carlo-learning-with-function-approximation\",\"423\":\"41#td-learning-with-function-approximation\",\"424\":\"41#_3-sarsa-with-function-approximation\",\"425\":\"41#_4-q-learning-with-function-approximation\",\"426\":\"41#_5-deep-q-learning-dqn\",\"427\":\"41#优化方法\",\"428\":\"41#经验回放-replay-buffer\",\"429\":\"41#伪代码\",\"430\":\"41@0\",\"431\":\"41@1\",\"432\":\"42\",\"433\":\"42#_1-基本思路\",\"434\":\"42#_2-目标函数定义\",\"435\":\"42#_2-1-average-state-value\",\"436\":\"42#另一种表达\",\"437\":\"42#d-s-的选择\",\"438\":\"42#_2-2-average-return-value\",\"439\":\"42#另一种表达-1\",\"440\":\"42#_3-目标函数梯度求解\",\"441\":\"42#_4-reinforce-梯度上升算法\",\"442\":\"42#reinforce-算法\",\"443\":\"42@0\",\"444\":\"42@1\",\"445\":\"43\",\"446\":\"43#socket\",\"447\":\"43#socket-连接示例\",\"448\":\"43#使用socket进行数据传输\",\"449\":\"43#杂项\",\"450\":\"43@0\",\"451\":\"43@1\",\"452\":\"44\",\"453\":\"44#socket2\",\"454\":\"44#socket-传输文件\",\"455\":\"44#使用浏览器访问socket服务器\",\"456\":\"44@0\",\"457\":\"44@1\",\"458\":\"45\",\"459\":\"45#数据库-1\",\"460\":\"45#简介\",\"461\":\"45#数据模型\",\"462\":\"45#数据库创建\",\"463\":\"45#数据库的规范化\",\"464\":\"45#第一范式-1nf\",\"465\":\"45#第二范式-2nf\",\"466\":\"45#第三范式-3nf\",\"467\":\"45#bcnf\",\"468\":\"45@0\",\"469\":\"45@1\",\"470\":\"46\",\"471\":\"46#数据库-2\",\"472\":\"46#sql-语句\",\"473\":\"46#数据库定义语言-ddl\",\"474\":\"46#sql数据类型\",\"475\":\"46#列级约束条件\",\"476\":\"46#表级约束条件\",\"477\":\"46#数据库操作\",\"478\":\"46#创建表-create\",\"479\":\"46#修改表-alter\",\"480\":\"46#删除表-drop\",\"481\":\"46#数据库操纵语言-dml\",\"482\":\"46#插入数据-insert-into\",\"483\":\"46#修改数据-update\",\"484\":\"46#删除数据\",\"485\":\"46@0\",\"486\":\"46@1\",\"487\":\"47\",\"488\":\"47#数据库-3\",\"489\":\"47#数据库查询语言-dql\",\"490\":\"47#单表查询-selecet\",\"491\":\"47#常用where查询条件\",\"492\":\"47#排序查询-order-by\",\"493\":\"47#聚集函数\",\"494\":\"47#分组和分页查询\",\"495\":\"47#多表查询\",\"496\":\"47#自身连接查询\",\"497\":\"47#外连接查询\",\"498\":\"47#嵌套查询\",\"499\":\"47#数据库控制语言-dcl\",\"500\":\"47#创建用户\",\"501\":\"47#登陆用户\",\"502\":\"47#用户授权\",\"503\":\"47@0\",\"504\":\"47@1\",\"505\":\"48\",\"506\":\"48#数据库-4\",\"507\":\"48#视图\",\"508\":\"48#索引\",\"509\":\"48#触发器\",\"510\":\"48#事务\",\"511\":\"48@0\",\"512\":\"48@1\",\"513\":\"49\",\"514\":\"49#主要内容\",\"515\":\"49#jdbc\",\"516\":\"49#使用jdbc连接数据库\",\"517\":\"49#drivermanager\",\"518\":\"49#了解connection\",\"519\":\"49#了解statement\",\"520\":\"49@0\",\"521\":\"49@1\",\"522\":\"50\",\"523\":\"50#jdbc\",\"524\":\"50#执行dml操作-executeupdate\",\"525\":\"50#执行dql操作-executequery\",\"526\":\"50#执行批处理操作-addbatch\",\"527\":\"50#将查询结果映射为对象\",\"528\":\"50@0\",\"529\":\"50@1\",\"530\":\"51\",\"531\":\"51#jdbc\",\"532\":\"51#实现登陆与sql注入攻击\",\"533\":\"51#使用preparedstatement\",\"534\":\"51#管理事务\",\"535\":\"51@0\",\"536\":\"51@1\",\"537\":\"52\",\"538\":\"52#lombok1\",\"539\":\"52#配置lombok\",\"540\":\"52#使用lombok\",\"541\":\"52@0\",\"542\":\"52@1\",\"543\":\"53\",\"544\":\"53#mybatis1\",\"545\":\"53#xml语言\",\"546\":\"53#转义字符\",\"547\":\"53#解析xml文件\",\"548\":\"53@0\",\"549\":\"53@1\",\"550\":\"54\",\"551\":\"54#mybatis2\",\"552\":\"54#初次使用-mybatis\",\"553\":\"54#sqlsessionfactory\",\"554\":\"54#直接读取实体类\",\"555\":\"54@0\",\"556\":\"54@1\",\"557\":\"55\",\"558\":\"55#mybatis详解1\",\"559\":\"55#查询操作\",\"560\":\"55#别名\",\"561\":\"55#hashmap-转换\",\"562\":\"55#多参数查询\",\"563\":\"55#resultmap\",\"564\":\"55#查询列表操作\",\"565\":\"55@0\",\"566\":\"55@1\",\"567\":\"56\",\"568\":\"56#mybatis详解2\",\"569\":\"56#指定构造方法\",\"570\":\"56#接口绑定-sqlsession-getmapper-xxx-class\",\"571\":\"56#多参数表示\",\"572\":\"56@0\",\"573\":\"56@1\",\"574\":\"57\",\"575\":\"57#mybatis详解3\",\"576\":\"57#复杂查询\",\"577\":\"57#一对一查询\",\"578\":\"57#嵌套结果映射-association\",\"579\":\"57#嵌套-select-查询-select-association\",\"580\":\"57#mybatis日志\",\"581\":\"57#一对多查询-查询一个-返回多个\",\"582\":\"57#嵌套查询\",\"583\":\"57#多对一查询-多-多\",\"584\":\"57@0\",\"585\":\"57@1\",\"586\":\"58\",\"587\":\"58#mybatis详解4\",\"588\":\"58#dml-操作\",\"589\":\"58#插入-insert标签\",\"590\":\"58#自增主键id-usegeneratedkeys\",\"591\":\"58#修改-update标签\",\"592\":\"58#删除\",\"593\":\"58#事务操作\",\"594\":\"58@0\",\"595\":\"58@1\",\"596\":\"59\",\"597\":\"59#mybatis详解5\",\"598\":\"59#动态sql\",\"599\":\"59#批处理-executortype-batch\",\"600\":\"59#动态sql介绍\",\"601\":\"59#条件判断-if标签\",\"602\":\"59#选择判断-choose\",\"603\":\"59#实现批量处理-foreach\",\"604\":\"59#批量删除\",\"605\":\"59#批量插入\",\"606\":\"59@0\",\"607\":\"59@1\",\"608\":\"60\",\"609\":\"60#mybatis详解6\",\"610\":\"60#缓存机制\",\"611\":\"60#一级缓存-作用在sqlsession\",\"612\":\"60#二级缓存-作用在mapper\",\"613\":\"60#查找顺序\",\"614\":\"60#单独配置取消二级缓存-usecache-false\",\"615\":\"60#操作结束-清除所有缓存-flushcache\",\"616\":\"60#缓存一致性问题\",\"617\":\"60@0\",\"618\":\"60@1\",\"619\":\"61\",\"620\":\"61#mybatis详解7\",\"621\":\"61#使用注解开发\",\"622\":\"61#调整-mybatis-config-xml\",\"623\":\"61#修改对应接口-注解\",\"624\":\"61#举例\",\"625\":\"61#配置这些额外的参数-options\",\"626\":\"61#实体类字段名称与数据库不同-results\",\"627\":\"61#结合xml配置\",\"628\":\"61#指定构造方法-constructorargs\",\"629\":\"61#关联查询-注解只支持嵌套查询\",\"630\":\"61#动态sql配置-selectprovider注解\",\"631\":\"61#二级缓存配置-cachenamespace\",\"632\":\"61#configuration\",\"633\":\"61@0\",\"634\":\"61@1\",\"635\":\"62\",\"636\":\"62#jul日志系统\",\"637\":\"62#jul基本使用\",\"638\":\"62#级别划分\",\"639\":\"62#自定义级别设置-logger-log\",\"640\":\"62#修改日志的默认打印级别\",\"641\":\"62@0\",\"642\":\"62@1\",\"643\":\"63\",\"644\":\"63#jul日志系统2\",\"645\":\"63#日志核心内容\",\"646\":\"63#核心部分-handler\",\"647\":\"63#consolehandler\",\"648\":\"63#filehandler\",\"649\":\"63#修改输出格式-formatter\",\"650\":\"63@0\",\"651\":\"63@1\",\"652\":\"64\",\"653\":\"64#jul日志系统3\",\"654\":\"64#日志继承关系\",\"655\":\"64#rootlogger\",\"656\":\"64#修改默认情况下的打印等级\",\"657\":\"64#重复logger问题\",\"658\":\"64#名称分级-自动构建继承关系\",\"659\":\"64@0\",\"660\":\"64@1\",\"661\":\"65\",\"662\":\"65#jul日志系统4\",\"663\":\"65#日志默认配置\",\"664\":\"65#properties-格式\",\"665\":\"65#java读取properties\",\"666\":\"65#获取系统数据getproperties\",\"667\":\"65#jul设置默认配置-logmanger\",\"668\":\"65@0\",\"669\":\"65@1\",\"670\":\"66\",\"671\":\"66#jul日志系统5\",\"672\":\"66#自定义日志格式\",\"673\":\"66#修改对应formatter\",\"674\":\"66#手动修改-setformatter\",\"675\":\"66#配置文件修改\",\"676\":\"66#自定义例子\",\"677\":\"66#第三方框架兼容性\",\"678\":\"66#lombok日志注解\",\"679\":\"66#mybatis日志\",\"680\":\"66@0\",\"681\":\"66@1\",\"682\":\"67\",\"683\":\"68\",\"684\":\"69\",\"685\":\"70\",\"686\":\"71\",\"687\":\"72\",\"688\":\"73\",\"689\":\"74\",\"690\":\"75\",\"691\":\"76\",\"692\":\"77\",\"693\":\"78\",\"694\":\"79\",\"695\":\"80\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[2],\"4\":[1,85],\"5\":[1,56],\"6\":[1],\"7\":[2,23],\"8\":[1,20],\"9\":[1,75],\"10\":[null,null,1],\"11\":[null,null,1],\"12\":[3],\"13\":[2],\"14\":[1,100],\"15\":[1,79],\"16\":[1,46],\"17\":[null,null,1],\"18\":[null,null,1],\"19\":[3],\"20\":[2],\"21\":[1,17],\"22\":[1,14],\"23\":[1,138],\"24\":[2,112],\"25\":[1,229],\"26\":[null,null,1],\"27\":[null,null,1],\"28\":[3],\"29\":[2],\"30\":[1,36],\"31\":[1,20],\"32\":[1,31],\"33\":[3,30],\"34\":[1,35],\"35\":[3,51],\"36\":[1,64],\"37\":[1,37],\"38\":[null,null,1],\"39\":[null,null,1],\"40\":[3],\"41\":[2],\"42\":[3,18],\"43\":[2,55],\"44\":[2,72],\"45\":[2,22],\"46\":[1,43],\"47\":[2,67],\"48\":[1,44],\"49\":[1,30],\"50\":[1,41],\"51\":[null,null,1],\"52\":[null,null,1],\"53\":[3],\"54\":[2],\"55\":[1,15],\"56\":[2,84],\"57\":[1,65],\"58\":[2,69],\"59\":[2,104],\"60\":[2,89],\"61\":[1,36],\"62\":[1,9],\"63\":[2],\"64\":[1,49],\"65\":[1,65],\"66\":[1,33],\"67\":[2,72],\"68\":[null,null,1],\"69\":[null,null,1],\"70\":[2],\"71\":[1,181],\"72\":[null,null,1],\"73\":[null,null,1],\"74\":[3],\"75\":[2,9],\"76\":[3,16],\"77\":[1,30],\"78\":[1,29],\"79\":[1,33],\"80\":[1,57],\"81\":[null,null,1],\"82\":[null,null,1],\"83\":[2],\"84\":[1,108],\"85\":[null,null,1],\"86\":[null,null,1],\"87\":[2],\"88\":[1,49],\"89\":[1],\"90\":[1,43],\"91\":[1,60],\"92\":[1,45],\"93\":[1,26],\"94\":[1,37],\"95\":[1,4],\"96\":[1,40],\"97\":[1,30],\"98\":[1,60],\"99\":[null,null,1],\"100\":[null,null,1],\"101\":[2],\"102\":[1],\"103\":[1,19],\"104\":[1],\"105\":[1,28],\"106\":[1],\"107\":[2,38],\"108\":[2,60],\"109\":[2,9],\"110\":[1,24],\"111\":[1,3],\"112\":[1,39],\"113\":[1,26],\"114\":[null,null,1],\"115\":[null,null,1],\"116\":[2],\"117\":[1,52],\"118\":[1,27],\"119\":[1],\"120\":[1,90],\"121\":[1,60],\"122\":[null,null,1],\"123\":[null,null,1],\"124\":[2],\"125\":[1],\"126\":[1,49],\"127\":[1,48],\"128\":[1,24],\"129\":[1,39],\"130\":[1,7],\"131\":[1,41],\"132\":[1,24],\"133\":[1,55],\"134\":[null,null,1],\"135\":[null,null,1],\"136\":[2],\"137\":[1],\"138\":[1,71],\"139\":[1,69],\"140\":[1,29],\"141\":[1,5],\"142\":[1,59],\"143\":[1,36],\"144\":[1,65],\"145\":[1,37],\"146\":[1],\"147\":[1,43],\"148\":[1,54],\"149\":[null,null,1],\"150\":[null,null,1],\"151\":[2],\"152\":[1],\"153\":[1],\"154\":[1,72],\"155\":[1,91],\"156\":[1,75],\"157\":[null,null,1],\"158\":[null,null,1],\"159\":[2],\"160\":[1],\"161\":[2,92],\"162\":[1,54],\"163\":[1,25],\"164\":[1],\"165\":[1,39],\"166\":[1,37],\"167\":[1,110],\"168\":[null,null,1],\"169\":[null,null,1],\"170\":[2],\"171\":[1],\"172\":[1,50],\"173\":[1,79],\"174\":[1,75],\"175\":[null,null,1],\"176\":[null,null,1],\"177\":[2],\"178\":[1],\"179\":[1,17],\"180\":[2,26],\"181\":[2,5],\"182\":[1,36],\"183\":[3,59],\"184\":[3,30],\"185\":[2],\"186\":[1,105],\"187\":[null,null,1],\"188\":[null,null,1],\"189\":[2],\"190\":[1],\"191\":[1,81],\"192\":[1,123],\"193\":[1,81],\"194\":[null,null,1],\"195\":[null,null,1],\"196\":[2],\"197\":[1],\"198\":[1,50],\"199\":[3,106],\"200\":[null,null,1],\"201\":[null,null,1],\"202\":[2],\"203\":[1,18],\"204\":[1,26],\"205\":[1,22],\"206\":[1,39],\"207\":[1,50],\"208\":[1,65],\"209\":[null,null,1],\"210\":[null,null,1],\"211\":[2],\"212\":[2,16],\"213\":[1],\"214\":[1,4],\"215\":[2,79],\"216\":[1,74],\"217\":[1,14],\"218\":[1,73],\"219\":[1,141],\"220\":[2,73],\"221\":[1,72],\"222\":[null,null,1],\"223\":[null,null,1],\"224\":[2],\"225\":[1],\"226\":[1,9],\"227\":[1,97],\"228\":[1,25],\"229\":[1,69],\"230\":[null,null,1],\"231\":[null,null,1],\"232\":[5],\"233\":[2],\"234\":[1,5],\"235\":[1,47],\"236\":[1,40],\"237\":[1,29],\"238\":[1,32],\"239\":[1,22],\"240\":[1,24],\"241\":[1,43],\"242\":[1,25],\"243\":[1,15],\"244\":[2,65],\"245\":[2,60],\"246\":[1,148],\"247\":[null,null,1],\"248\":[null,null,1],\"249\":[2,6],\"250\":[1,3],\"251\":[4,93],\"252\":[4,34],\"253\":[1,35],\"254\":[1,42],\"255\":[1,84],\"256\":[1,35],\"257\":[1,53],\"258\":[1,67],\"259\":[null,null,1],\"260\":[null,null,1],\"261\":[2],\"262\":[2],\"263\":[1],\"264\":[1,50],\"265\":[1,23],\"266\":[1,57],\"267\":[1,104],\"268\":[1,26],\"269\":[null,null,1],\"270\":[null,null,1],\"271\":[2],\"272\":[2,5],\"273\":[1],\"274\":[1,59],\"275\":[1,45],\"276\":[null,null,1],\"277\":[null,null,1],\"278\":[3],\"279\":[2],\"280\":[1,79],\"281\":[1,106],\"282\":[1,44],\"283\":[null,null,1],\"284\":[null,null,1],\"285\":[2,76],\"286\":[null,null,1],\"287\":[null,null,2],\"288\":[10,6],\"289\":[1,45],\"290\":[1,29],\"291\":[1],\"292\":[1],\"293\":[1,44],\"294\":[1,105],\"295\":[4,82],\"296\":[1,34],\"297\":[1],\"298\":[1,157],\"299\":[1,67],\"300\":[null,null,1],\"301\":[null,null,6],\"302\":[2],\"303\":[1,1],\"304\":[2,118],\"305\":[6,54],\"306\":[null,null,1],\"307\":[null,null,1],\"308\":[4,19],\"309\":[7,2],\"310\":[6,8],\"311\":[3,28],\"312\":[3,8],\"313\":[3,3],\"314\":[5,10],\"315\":[6,3],\"316\":[4,4],\"317\":[2,1],\"318\":[6,3],\"319\":[null,null,1],\"320\":[null,null,1],\"321\":[2],\"322\":[1,5],\"323\":[3],\"324\":[1,16],\"325\":[4,27],\"326\":[7,36],\"327\":[3,35],\"328\":[8,10],\"329\":[7,23],\"330\":[4,47],\"331\":[8,34],\"332\":[6,34],\"333\":[3,72],\"334\":[2,29],\"335\":[null,null,1],\"336\":[null,null,1],\"337\":[2,16],\"338\":[3,36],\"339\":[6],\"340\":[3,28],\"341\":[2,8],\"342\":[5,21],\"343\":[4,75],\"344\":[null,null,1],\"345\":[null,null,1],\"346\":[4,6],\"347\":[4,18],\"348\":[2,53],\"349\":[3,1],\"350\":[4,3],\"351\":[3,70],\"352\":[2,1],\"353\":[3,44],\"354\":[5,6],\"355\":[7,71],\"356\":[6,23],\"357\":[5,1],\"358\":[null,null,1],\"359\":[null,null,1],\"360\":[6,51],\"361\":[3,16],\"362\":[2,61],\"363\":[3,33],\"364\":[3,49],\"365\":[4,10],\"366\":[4,63],\"367\":[3,52],\"368\":[5,1],\"369\":[4,33],\"370\":[4,9],\"371\":[4,25],\"372\":[4,39],\"373\":[7,12],\"374\":[2,1],\"375\":[null,null,1],\"376\":[null,null,1],\"377\":[2,33],\"378\":[2],\"379\":[2,32],\"380\":[5],\"381\":[3,17],\"382\":[2,31],\"383\":[3,44],\"384\":[6,41],\"385\":[4],\"386\":[3,57],\"387\":[4],\"388\":[3,8],\"389\":[2,67],\"390\":[6,11],\"391\":[5,1],\"392\":[null,null,1],\"393\":[null,null,1],\"394\":[4],\"395\":[2,50],\"396\":[6,10],\"397\":[3,36],\"398\":[2,37],\"399\":[7],\"400\":[6,23],\"401\":[3,37],\"402\":[5,3],\"403\":[3,2],\"404\":[7,21],\"405\":[4,24],\"406\":[6,7],\"407\":[2,9],\"408\":[2,17],\"409\":[5,17],\"410\":[3,10],\"411\":[3,1],\"412\":[3,2],\"413\":[null,null,1],\"414\":[null,null,1],\"415\":[6,11],\"416\":[2,12],\"417\":[6,9],\"418\":[4,15],\"419\":[2,22],\"420\":[2,52],\"421\":[4,40],\"422\":[6,19],\"423\":[5,15],\"424\":[5,10],\"425\":[6,13],\"426\":[6,21],\"427\":[1,110],\"428\":[4,3],\"429\":[1,13],\"430\":[null,null,1],\"431\":[null,null,1],\"432\":[5,10],\"433\":[2,38],\"434\":[2],\"435\":[5,22],\"436\":[1,5],\"437\":[3,21],\"438\":[4,20],\"439\":[1,27],\"440\":[2,60],\"441\":[3,40],\"442\":[2,1],\"443\":[null,null,1],\"444\":[null,null,1],\"445\":[2],\"446\":[1,9],\"447\":[2,52],\"448\":[1,83],\"449\":[1,64],\"450\":[null,null,1],\"451\":[null,null,1],\"452\":[2],\"453\":[1],\"454\":[2,65],\"455\":[1,179],\"456\":[null,null,1],\"457\":[null,null,1],\"458\":[2],\"459\":[2],\"460\":[1,24],\"461\":[1,37],\"462\":[1,24],\"463\":[1,12],\"464\":[3,11],\"465\":[3,15],\"466\":[3,17],\"467\":[1,22],\"468\":[null,null,1],\"469\":[null,null,2],\"470\":[2],\"471\":[2],\"472\":[2,64],\"473\":[3],\"474\":[1,36],\"475\":[1,82],\"476\":[1,52],\"477\":[1,22],\"478\":[1,16],\"479\":[1,25],\"480\":[1,8],\"481\":[3],\"482\":[1,19],\"483\":[1,13],\"484\":[1,11],\"485\":[null,null,1],\"486\":[null,null,2],\"487\":[2],\"488\":[2],\"489\":[3],\"490\":[1,17],\"491\":[2,19],\"492\":[1,20],\"493\":[1,26],\"494\":[1,22],\"495\":[1,24],\"496\":[1,13],\"497\":[1,32],\"498\":[1,11],\"499\":[3,3],\"500\":[1,14],\"501\":[1,15],\"502\":[1,21],\"503\":[null,null,1],\"504\":[null,null,2],\"505\":[2],\"506\":[2],\"507\":[1,62],\"508\":[1,35],\"509\":[1,49],\"510\":[1,72],\"511\":[null,null,1],\"512\":[null,null,2],\"513\":[2],\"514\":[1,1],\"515\":[1,34],\"516\":[1,90],\"517\":[1,157],\"518\":[1,17],\"519\":[1,19],\"520\":[null,null,1],\"521\":[null,null,2],\"522\":[2],\"523\":[1],\"524\":[1,64],\"525\":[1,16],\"526\":[1,36],\"527\":[1,94],\"528\":[null,null,1],\"529\":[null,null,2],\"530\":[2],\"531\":[1],\"532\":[1,64],\"533\":[1,81],\"534\":[1,85],\"535\":[null,null,1],\"536\":[null,null,2],\"537\":[2],\"538\":[1,48],\"539\":[1,33],\"540\":[1,44],\"541\":[null,null,1],\"542\":[null,null,2],\"543\":[2],\"544\":[1,39],\"545\":[1,49],\"546\":[1,15],\"547\":[1,77],\"548\":[null,null,1],\"549\":[null,null,2],\"550\":[2],\"551\":[1],\"552\":[2,116],\"553\":[1,19],\"554\":[1,110],\"555\":[null,null,1],\"556\":[null,null,2],\"557\":[2],\"558\":[1,53],\"559\":[1,61],\"560\":[1,35],\"561\":[2,31],\"562\":[1,34],\"563\":[1,62],\"564\":[1,88],\"565\":[null,null,1],\"566\":[null,null,2],\"567\":[2],\"568\":[1],\"569\":[1,153],\"570\":[1,89],\"571\":[1,87],\"572\":[null,null,1],\"573\":[null,null,2],\"574\":[2],\"575\":[1],\"576\":[1],\"577\":[1,51],\"578\":[1,47],\"579\":[3,42],\"580\":[1,79],\"581\":[4,64],\"582\":[1,41],\"583\":[3,77],\"584\":[null,null,1],\"585\":[null,null,2],\"586\":[2],\"587\":[1],\"588\":[2,19],\"589\":[2,40],\"590\":[1,40],\"591\":[2,23],\"592\":[1,17],\"593\":[1,50],\"594\":[null,null,1],\"595\":[null,null,2],\"596\":[2],\"597\":[1],\"598\":[1],\"599\":[1,77],\"600\":[1,21],\"601\":[2,43],\"602\":[1,40],\"603\":[1,5],\"604\":[1,56],\"605\":[1,53],\"606\":[null,null,1],\"607\":[null,null,2],\"608\":[2],\"609\":[1],\"610\":[1,21],\"611\":[3,74],\"612\":[3,98],\"613\":[1,8],\"614\":[1,23],\"615\":[2,26],\"616\":[1,55],\"617\":[null,null,1],\"618\":[null,null,2],\"619\":[2],\"620\":[1],\"621\":[1,14],\"622\":[1,21],\"623\":[1,20],\"624\":[1,29],\"625\":[1,56],\"626\":[1,39],\"627\":[2,13],\"628\":[1,38],\"629\":[3,41],\"630\":[4,80],\"631\":[1,32],\"632\":[1,45],\"633\":[null,null,1],\"634\":[null,null,2],\"635\":[2],\"636\":[1,41],\"637\":[1,4],\"638\":[1,61],\"639\":[1,27],\"640\":[1,41],\"641\":[null,null,1],\"642\":[null,null,2],\"643\":[2],\"644\":[1],\"645\":[1],\"646\":[1,46],\"647\":[1,24],\"648\":[1,22],\"649\":[1,24],\"650\":[null,null,1],\"651\":[null,null,2],\"652\":[2],\"653\":[1],\"654\":[1],\"655\":[1,31],\"656\":[1,15],\"657\":[2,30],\"658\":[2,27],\"659\":[null,null,1],\"660\":[null,null,2],\"661\":[2],\"662\":[1],\"663\":[1],\"664\":[1,30],\"665\":[1,24],\"666\":[1,24],\"667\":[1,59],\"668\":[null,null,1],\"669\":[null,null,2],\"670\":[2],\"671\":[1],\"672\":[1,35],\"673\":[1],\"674\":[1,13],\"675\":[1,9],\"676\":[1,45],\"677\":[1,10],\"678\":[1,30],\"679\":[1,48],\"680\":[null,null,1],\"681\":[null,null,2],\"682\":[1,3],\"683\":[1],\"684\":[1],\"685\":[1],\"686\":[2],\"687\":[1],\"688\":[1],\"689\":[1],\"690\":[2],\"691\":[1],\"692\":[2],\"693\":[2],\"694\":[2],\"695\":[2]},\"averageFieldLength\":[1.8875899199058925,42.53814579130357,0.9228144681003307],\"storedFields\":{\"0\":{\"h\":\"daily1\",\"t\":[\"a+b=c\"]},\"1\":{\"c\":[\"daily\"]},\"2\":{\"c\":[\"d1\"]},\"3\":{\"h\":\"Java - 类与对象1\"},\"4\":{\"h\":\"类与对象\",\"t\":[\"类: 是对一类事物的描述，是抽象的、概念上的定义.对象: 是某一类事物实际存在的每个个体，因而也被称为实例（instance）， 是类的一个具体化个体.\",\"类的创建: 类名的首字母通常是大写的.\",\"public class Person {//这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } \",\"对象实例的创建 new Person() :\",\"public static void main(String[] args) { Person p = new Person(); } \",\"对于对象而言，其变量名存储的是对象的引用（类似于c++指针的情况），并非是所对应的对象本身，即\",\"public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p1存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p1 = new Person(); Person p2 = p1; // 我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制 } \",\"在创建了对象之后，就可以进行一定操作，如: 访问、修改对象的属性. 不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象. 关于对象类型的变量，我们也可以不对任何对象进行引用：\",\"public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \\\"小红\\\"; //我任性，就是要操作 System.out.println(p.name); } \",\"会出现异常，即空指针异常. 对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\"]},\"5\":{\"h\":\"方法的创建与使用\",\"t\":[\"类除了具有属性外，还可以定义一些方法来描述同一类的行为。 方法是语句的集合，是为了完成某件事情而存在的。 方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\",\"方法的定义如下:\",\"返回值类型 方法名称() { 方法体... } \",\"具体而言:\",\"public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\\\"我叫 \\\"+name+\\\" 今年 \\\"+age+\\\" 岁了！\\\"); } } \",\"方法的调用:\",\"public static void main(String[] args) { Person p = new Person(); p.name = \\\"小明\\\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } \"]},\"6\":{\"h\":\"方法的进阶使用\"},\"7\":{\"h\":\"this 的使用\",\"t\":[\"有时候我们的方法中可能会出现一些与成员变量重名的变量：\",\"void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的 //这里实际上是将方法参数的局部变量name赋值为本身 } \",\"我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\",\"void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } \",\"当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\",\"String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } \"]},\"8\":{\"h\":\"方法的重载\",\"t\":[\"有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况。\",\"一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\",\"int sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } \"]},\"9\":{\"h\":\"构造方法\",\"t\":[\"我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？ 要在对象创建时进行处理，我们可以使用**构造方法（构造器）**来完成。\",\"构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\",\"public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \\\"小明\\\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \\\"男\\\"; } } \",\"构造方法会在new的时候自动执行, 当然，我们也可以为构造方法设定参数：\",\"public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } \",\"注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法.\",\"当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\",\"public class Person { String name = \\\"未知\\\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \\\"男\\\"; } \",\"这里需要特别注意，成员变量的初始化，并不是在构造方法之后，而是在这之前就已经完成了.\",\"Person(String name, int age, String sex){ System.out.println(this.age); // 在赋值之前看看是否有初始值 // 这里是 this.age 而非 age // 此时this.age已经初始化完，但还未复制，this.age = 0 this.name = name; this.age = age; this.sex = sex; } \",\"我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\",\"public class Person { String name; int age; String sex; { System.out.println(\\\"我是代码块\\\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\\\"我被构造了\\\"); this.name = name; this.age = age; this.sex = sex; } } \"]},\"10\":{\"c\":[\"code\"]},\"11\":{\"c\":[\"java\"]},\"12\":{\"h\":\"Java - 泛型 2\"},\"13\":{\"h\":\"泛型 2\"},\"14\":{\"h\":\"泛型方法\",\"t\":[\"当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。\",\"当某个方法（无论是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：\",\"public class Main { public static void main(String[] args) { String str = test(\\\"Hello World!\\\"); } private static <T> T test(T t){ //在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法 return t; } } \",\"泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型 T 作为参数，同样的类型 T 作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成 String 类型，因此返回值也是 String 类型。\",\"public static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \\\"Hello\\\"); System.out.println(Arrays.toString(strings)); } private <T> void add(T[] arr, T t){ arr[0] = t; } \",\"实际上泛型方法在很多工具类中也有，比如说 Arrays 的排序方法：\",\"Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; } }); \",\"比如现在我们想要让数据从大到小排列，我们就可以自定义：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr)); } \",\"因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：\",\"public static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -> o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr)); } \",\"包括数组复制方法：\",\"public static void main(String[] args) { String[] arr = {\\\"AAA\\\", \\\"BBB\\\", \\\"CCC\\\"}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr)); } \",\"因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。\"]},\"15\":{\"h\":\"泛型界限\",\"t\":[\"上界 extend\",\"下界 super 仅适用于通配符，对于类型变量来说是不支持的\",\"现在有一个新的需求，现在没有 String 类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\",\"public class Score<T extends Number> { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; } } \",\"只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：\",\"实际上就像这样：\",\"20241106133117\",\"同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：\",\"public static void main(String[] args) { Score<? extends Integer> score = new Score<>(\\\"数据结构与算法\\\", \\\"EP074512\\\", 60); } \",\"那么既然泛型有上界，那么有没有下界呢？肯定的啊：\",\"20241106133159\",\"只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：\",\"20241106133211\",\"那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\",\"public static void main(String[] args) { Score<? extends Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 } \",\"但是我们限定下界的话，因为还是有可能是 Object，所以说依然是跟之前一样：\",\"public static void main(String[] args) { Score<? super Number> score = new Score<>(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", 10); Object o = score.getValue(); } \",\"通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。\"]},\"16\":{\"h\":\"类型擦除\",\"t\":[\"前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？\",\"public abstract class A <T>{ abstract T test(T t); } \",\"实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：\",\"public abstract class A { abstract Object test(Object t); //默认就是Object } \",\"当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：\",\"public abstract class A <T extends Number>{ //设定上界为Number abstract T test(T t); } \",\"那么编译之后：\",\"public abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类 } \",\"因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：\",\"public static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型 } \",\"只不过此时编译器会给出警告\"]},\"17\":{\"c\":[\"code\"]},\"18\":{\"c\":[\"java\"]},\"19\":{\"h\":\"Java - 集合类 1\"},\"20\":{\"h\":\"集合类 1\"},\"21\":{\"h\":\"集合类\",\"t\":[\"集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\",\"集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。\"]},\"22\":{\"h\":\"集合类与数组区别\",\"t\":[\"集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\",\"相同之处：\",\"它们都是容器，都能够容纳一组元素。\",\"不同之处：\",\"数组的大小是固定的，集合的大小是可变的。\",\"数组可以存放基本数据类型，但集合只能存放对象。\",\"数组存放的类型只能是一种，但集合可以有不同种类的元素。\"]},\"23\":{\"h\":\"集合根接口\",\"t\":[\"所有的集合类最终都是实现自集合根接口的\",\"Java 中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\",\"import java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"树脂666\\\"); } } \",\"比如 ArrayList 类，它的祖先就是Collection接口：\",\"20241120130452\",\"public interface Collection<E> extends Iterable<E> { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator<E> iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 <T> T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection<?> c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection<? extends E> c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection<?> c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate<? super E> filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator<E> each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection<?> c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); } } \"]},\"24\":{\"h\":\"List 列表\",\"t\":[\"List 列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。\",\"List 是集合类型的一个分支，它的主要特性有：\",\"是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置\",\"列表中允许存在重复元素 (只要 集合的 equal 方法判定为 True 就是重复)\",\"List 直接继承自前面介绍的 Collection 接口，其中很多地方重新定义了一次 Collection 接口中定义的方法，这样做是为了更加明确方法的具体功能\",\"可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作\",\"//List是一个有序的集合类，每个元素都有一个自己的下标位置 //List中可插入重复元素 //针对于这些特性，扩展了Collection接口中一些额外的操作 public interface List<E> extends Collection<E> { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection<? extends E> c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator<E> operator) { Objects.requireNonNull(operator); final ListIterator<E> li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\\\"unchecked\\\", \\\"rawtypes\\\"}) default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(); //迭代器我们会在下一个部分讲解 ListIterator<E> listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List<E> subList(int fromIndex, int toIndex); ... } \"]},\"25\":{\"h\":\"ArrayList\",\"t\":[\"在 ArrayList 中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity < 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 } } \",\"一般的，如果我们要使用一个集合类，我们会使用接口的引用：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\\\"科技与狠活\\\"); //使用add添加元素 list.add(\\\"上头啊\\\"); System.out.println(list); //打印集合类，可以得到一个非常规范的结果 } \",\"集合的各种功能我们都可以来测试一下\",\"特别注意一下，我们在使用 Integer 时，要注意传参问题：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除 } \",\"那要是这样写呢？\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list); } \",\"可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象：\",\"//ArrayList源码部分 public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false; } \",\"列表中允许存在相同元素，所以说我们可以添加两个一模一样的：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); System.out.println(list); } \",\"那要是此时我们删除对象呢，是一起删除还是只删除一个呢？\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); String str = \\\"哟唉嘛干你\\\"; list.add(str); list.add(str); list.remove(str); System.out.println(list); } \",\"这种情况下，只会删除排在前面的第一个元素。\",\"集合类是支持嵌套使用的，一个集合中可以存放多个集合\",\"public static void main(String[] args) { List<List<String>> list = new LinkedList<>(); list.add(new LinkedList<>()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty()); } \",\"在 Arrays 工具类中，我们可以快速生成一个只读的List：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); //非常方便 System.out.println(list); } \",\"注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\")); System.out.println(list); } \",\"当然，也可以利用静态代码块：\",\"public static void main(String[] args) { List<String> list = new ArrayList<String>() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\\\"A\\\"); add(\\\"B\\\"); add(\\\"C\\\"); }}; System.out.println(list); } \",\"这里我们接着介绍另一个列表实现类，LinkedList 同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { transient int size = 0; //引用首结点 transient Node<E> first; //引用尾结点 transient Node<E> last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node<E> { //内部使用的结点类 E item; Node<E> next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node<E> prev; Node(Node<E> prev, E element, Node<E> next) { this.item = element; this.next = next; this.prev = prev; } } ... } \",\"LinkedList 的使用和 ArrayList 的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。\",\"只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。\"]},\"26\":{\"c\":[\"code\"]},\"27\":{\"c\":[\"java\"]},\"28\":{\"h\":\"Java - 集合类 2\"},\"29\":{\"h\":\"集合类 2\"},\"30\":{\"h\":\"迭代器\",\"t\":[\"实际上我们的集合类都是支持使用foreach语法 (增强 for 语法) 的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); } } \",\"但是由于仅仅是语法糖，实际上编译之后会修改为 迭代器 iterator 的形式：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } \"]},\"31\":{\"h\":\"简介\",\"t\":[\"通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：\",\"20241126232114\",\"一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：\",\"20241126232128\",\"每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。\",\"至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。\"]},\"32\":{\"h\":\"源码定义\",\"t\":[\"主要方法： next() | hasNext() | remove()\",\"public interface Iterator<E> { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\\\"remove\\\"); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } } \"]},\"33\":{\"h\":\"不同集合类 迭代器 实现用例\",\"t\":[\"ArrayList 就是直接按下标访问：\",\"public E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素 } \",\"LinkedList 就是不断向后寻找结点：\",\"public E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素 } \",\"虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现.\"]},\"34\":{\"h\":\"使用示例\",\"t\":[\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 } } \",\"注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。\",\"为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); for (String s : list) { System.out.println(s); } } \"]},\"35\":{\"h\":\"其他遍历 集合类 的方式\",\"t\":[\"在 Java8 提供了一个支持 Lambda 表达式的 forEach 方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作\",\"即对于 集合类 自身存在一个 forEach 的方法：\",\"public static void main(String[] args) { List<String> list = Arrays.asList(\\\"A\\\", \\\"B\\\", \\\"C\\\"); list.forEach(System.out::println); } \",\"这个效果跟上面的写法是完全一样的，因为 forEach 方法内部本质上也是迭代器在处理，这个方法是在 Iterable 接口中定义的：\",\"default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 } } \"]},\"36\":{\"h\":\"介绍\",\"t\":[\"20241120130452\",\"//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了 public interface Iterable<T> { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator<T> iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator<T> spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } \",\"得益于 Iterable 提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用 foreach 语法：\",\"public class Test implements Iterable<String>{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator<String> iterator() { return new Iterator<String>() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \\\"测试\\\"; } }; } } \"]},\"37\":{\"h\":\"介绍\",\"t\":[\"这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：\",\"这种迭代器因为能够双向遍历，所以说可以反复使用。\",\"public interface ListIterator<E> extends Iterator<E> { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e); } \"]},\"38\":{\"c\":[\"code\"]},\"39\":{\"c\":[\"java\"]},\"40\":{\"h\":\"Java - 集合类 3\"},\"41\":{\"h\":\"集合类 3\"},\"42\":{\"h\":\"Quene 和 Deque\",\"t\":[\"其中 LinkedList 除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable \"]},\"43\":{\"h\":\"Quene 队列\",\"t\":[\"20241127001435\",\"我们先来看看队列接口，它扩展了大量队列相关操作：\",\"public interface Queue<E> extends Collection<E> { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek(); } \",\"我们可以直接将一个 LinkedList 当做一个队列来使用：\",\"public static void main(String[] args) { Queue<String> queue = new LinkedList<>(); //当做队列使用，还是很方便的 queue.offer(\\\"AAA\\\"); queue.offer(\\\"BBB\\\"); System.out.println(queue.poll()); System.out.println(queue.poll()); } \"]},\"44\":{\"h\":\"Deque 双端队列\",\"t\":[\"普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作\",\"利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用\",\"//在双端队列中，所有的操作都有分别对应队首和队尾的 public interface Deque<E> extends Queue<E> { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator<E> descendingIterator(); } \",\"我们可以来测试一下，比如我们可以直接当做栈来进行使用：\",\"public static void main(String[] args) { Deque<String> deque = new LinkedList<>(); deque.push(\\\"AAA\\\"); deque.push(\\\"BBB\\\"); System.out.println(deque.pop()); System.out.println(deque.pop()); } \"]},\"45\":{\"h\":\"其他集合类实现 队列\",\"t\":[\"当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：\",\"public static void main(String[] args) { Deque<String> deque = new ArrayDeque<>(); //数组实现的栈和队列 Queue<String> queue = new PriorityQueue<>(); //优先级队列 } \"]},\"46\":{\"h\":\"优先级队列\",\"t\":[\"这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的(4/5/10)，类似于VIP用户可以优先结束排队。\",\"我们也可以自定义比较规则，同样需要给一个 Comparator 的实现(10/5/4)：\",\"public static void main(String[] args) { Queue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } \",\"只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的\",\"想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。\"]},\"47\":{\"h\":\"Set 集合\",\"t\":[\"Set集合，这种集合类型比较特殊\",\"set 接口中定义的方法都是 Collection 中直接继承的，因此，Set支持的功能其实也就和 Collection 中定义的差不多，只不过：\",\"不允许出现重复元素\",\"不支持随机访问（不允许通过下标访问）\",\"public interface Set<E> extends Collection<E> { // Set 集合中基本都是从 Collection 直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator<E> iterator(); Object[] toArray(); <T> T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection<?> c); //同样是只能插入那些不重复的元素 boolean addAll(Collection<? extends E> c); boolean retainAll(Collection<?> c); boolean removeAll(Collection<?> c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator<E> spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); } } \"]},\"48\":{\"h\":\"HashSet\",\"t\":[\"它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个 HashMap 在实现，这个需要我们学习了Map之后再来讨论）\",\"我们可以非常高效的从 HashSet 中存取元素，我们先来测试一下它的特性：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\\\"AAA\\\")); System.out.println(set); //可以看到，最后实际上只有一个成功插入了 } \",\"在 Set 接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除 Set 中的某个对象：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); System.out.println(set.add(\\\"AAA\\\")); System.out.println(set.remove(\\\"AAA\\\")); System.out.println(set); } \",\"由于底层采用哈希表实现，所以说无法维持插入元素的顺序：\",\"public static void main(String[] args) { Set<String> set = new HashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"49\":{\"h\":\"LinkedHashSet\",\"t\":[\"那要是我们就是想要使用维持顺序的Set集合呢？\",\"我们可以使用 LinkedHashSet，LinkedHashSet 底层维护的不再是一个 HashMap，而是 LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\",\"public static void main(String[] args) { Set<String> set = new LinkedHashSet<>(); set.addAll(Arrays.asList(\\\"A\\\", \\\"0\\\", \\\"-\\\", \\\"+\\\")); System.out.println(set); } \"]},\"50\":{\"h\":\"TreeSet\",\"t\":[\"还有一种Set叫做TreeSet，它会在元素插入时进行排序：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>(); set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\",\"public static void main(String[] args) { TreeSet<Integer> set = new TreeSet<>((a, b) -> b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set); } \",\"目前，Set 集合只是粗略的进行了讲解，但是学习 Map 之后，我们还会回来看我们 Set 的底层实现，所以说最重要的还是 Map目前只需要记住 Set 的性质、使用即可。\"]},\"51\":{\"c\":[\"code\"]},\"52\":{\"c\":[\"java\"]},\"53\":{\"h\":\"Java - 集合类 4\"},\"54\":{\"h\":\"集合类 4\"},\"55\":{\"h\":\"Map\",\"t\":[\"映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\",\"Map 就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值\",\"Map 并不是 Collection 体系下的接口，而是单独的一个体系，因为操作特殊\"]},\"56\":{\"h\":\"Map 基本定义\",\"t\":[\"在 Map 中，这些映射关系被存储为键值对，Map 接口中定义的操作：\",\"// Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊 // 这里需要填写两个泛型参数， // 其中K就是键的类型，V就是值的类型， // 比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的 public interface Map<K,V> { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map<? extends K, ? extends V> m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set<K> keySet(); //返回Map中存放的所有值 Collection<V> values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set<Map.Entry<K, V>> entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry<K,V> { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ... } \"]},\"57\":{\"h\":\"HashMap\",\"t\":[\"底层采用哈希表实现\",\"基本示例\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \\\"小红\\\"); System.out.println(map.get(2)); //使用get方法根据键获取对应的值 } \",\"Map 中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的\",\"为了防止意外将之前的键值对覆盖掉，我们可以使用 putIfAbsent：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); map.putIfAbsent(1, \\\"小红\\\"); //Java8 新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); } \",\"我们在获取一个不存在的映射时，默认会返回 null 作为结果：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null } \",\"我们也可以为这种情况添加一个预备方案 getOrDefault，当 Map 中不存在时，可以返回一个备选的返回值：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"小明\\\"); System.out.println(map.getOrDefault(3, \\\"备胎\\\")); //Java8新增操作，当不存在对应的键值对时，返回备选方案 } \",\"因为 HashMap 底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的\",\"如果需要维护顺序，我们同样可以使用 LinkedHashMap，它的内部对插入顺序进行了维护\"]},\"58\":{\"h\":\"HashMap 底层实现\",\"t\":[\"HashMap 的底层实现是由 哈希表 实现的。\",\"哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：\",\"20241130000528\",\"实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... static class Node<K,V> implements Map.Entry<K,V> { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node<K,V> next; ... } ... transient Node<K,V>[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } \",\"可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：\",\"HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板\",\"HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构\"]},\"59\":{\"h\":\"put 方法\",\"t\":[\"public V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; // 通过resize方法初始化底层哈希表，初始容量为16， // 后续会根据情况扩容，底层哈希表的长度永远是2的n次方 // 因为传入的哈希值可能会很大，这里同样是进行取余操作 // (n - 1) & hash 等价于 hash % n // 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果这个位置上什么都没有，那就直接放一个新的结点 else { // 这种情况就是哈希冲突了 Node<K,V> e; K k; // 如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount >= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash); //那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size > threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null } \"]},\"60\":{\"h\":\"resize 方法\",\"t\":[\"resize 在初始化时会调用一次，此外在每次扩容时会调用。\",\"根据上面的推导，我们在正常插入一个键值对时，会得到 null 返回值，而冲突时会得到一个被覆盖的值.\",\"HashMap的一个链表长度过大时，会自动转换为红黑树：\",\"20241130001811\",\"但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap > 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap >= MAXIMUM_CAPACITY) { // 如果旧的容量已经大于最大限制了， // 那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr << 1; //新的阈值也提升到原来的两倍 } else if (oldThr > 0) // 旧容量不大于0只可能是还没初始化 // 这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参 new 出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; // 新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值为负载因子乘以默认容量，负载因子默认为0.75 // 也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了， // 反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 } } \"]},\"61\":{\"h\":\"LinkedHashMap\",\"t\":[\"HashMap 并不会维持插入的顺序，LinkedHashMap 是直接继承自HashMap，具有 HashMap 的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序\",\"static class Entry<K,V> extends HashMap.Node<K,V> { // LinkedHashMap中的结点实现 Entry<K,V> before, after; // 这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); } } \",\"这样我们在遍历 LinkedHashMap 时，顺序就同我们的插入顺序一致。\",\"当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\"]},\"62\":{\"h\":\"TreeMap\",\"t\":[\"它的内部直接维护了一个红黑树（没有使用哈希表）\",\"因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的 TreeSet 是一样的\"]},\"63\":{\"h\":\"Map 的一些方法\"},\"64\":{\"h\":\"\",\"t\":[\"compute 会将指定 Key 的值进行重新计算，若 Key 不存在，v 会返回 null\",\"computeIfPresent 当 Key 存在时存在则计算并赋予新的值\",\"computeIfAbsent 不存在Key时，计算并将键值对放入Map中：\",\"public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.compute(1, (k, v) -> { //compute 会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\\\"M\\\"; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -> { // 当Key存在时存在则计算并赋予新的值 return v+\\\"M\\\"; //这里返回原来的value+M }); System.out.println(map); map.put(1, \\\"A\\\"); map.put(2, \\\"B\\\"); map.computeIfAbsent(0, (k) -> { //若不存在则计算并插入新的值 return \\\"M\\\"; //这里返回M }); System.out.println(map); } \"]},\"65\":{\"h\":\"\",\"t\":[\"merge方法用于处理数据：\",\"public static void main(String[] args) { List<Student> students = Arrays.asList( new Student(\\\"yoni\\\", \\\"English\\\", 80), new Student(\\\"yoni\\\", \\\"Chiness\\\", 98), new Student(\\\"yoni\\\", \\\"Math\\\", 95), new Student(\\\"taohai.wang\\\", \\\"English\\\", 50), new Student(\\\"taohai.wang\\\", \\\"Chiness\\\", 72), new Student(\\\"taohai.wang\\\", \\\"Math\\\", 41), new Student(\\\"Seely\\\", \\\"English\\\", 88), new Student(\\\"Seely\\\", \\\"Chiness\\\", 89), new Student(\\\"Seely\\\", \\\"Math\\\", 92) ); Map<String, Integer> scoreMap = new HashMap<>(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -> scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -> System.out.println(\\\"key:\\\" + k + \\\"总分\\\" + \\\"value:\\\" + v)); } static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; } } \"]},\"66\":{\"h\":\"\",\"t\":[\"replace方法可以快速替换某个映射的值\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\">>>\\\"); //直接替换为新的 System.out.println(map); } \",\"也可以精准匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.replace(0, \\\"巴卡\\\", \\\"玛卡\\\"); //只有键和值都匹配时，才进行替换 System.out.println(map); } \",\"包括 remove 方法，也支持键值同时匹配：\",\"public static void main(String[] args) { Map<Integer , String> map = new HashMap<>(); map.put(0, \\\"单走\\\"); map.remove(0, \\\"单走\\\"); //只有同时匹配时才移除 System.out.println(map); } \"]},\"67\":{\"h\":\"HashSet 底层实现\",\"t\":[\"它的底层很简单，底层是直接用 HashMap 套壳实现的。\",\"因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value\",\"public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable { private transient HashMap<E,Object> map; //对，你没看错，底层直接用 map 来做事 // 因为 Set 只需要存储 Key 就行了，所以说这个对象当做每一个键值对的共享 Value private static final Object PRESENT = new Object(); // 直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap<>(); } ... // 你会发现所有的方法全是替身攻击 public Iterator<E> iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } } \",\"通过观察 HashSet 的源码发现，HashSet 几乎都在操作内部维护的一个HashMap ，也就是说，HashSet 只是一个表壳，而内部维护的 HashMap 才是灵魂！\",\"就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。\",\"所以说，HashSet 利用了 HashMap 内部的数据结构，轻松地就实现了 Set 定义的全部功能！\",\"再来看 TreeSet，实际上用的就是我们的 TreeMap\",\"LinkedSet 用的就是 LinkedMap\"]},\"68\":{\"c\":[\"code\"]},\"69\":{\"c\":[\"java\"]},\"70\":{\"h\":\"Java - Stream流\"},\"71\":{\"h\":\"Stream流\",\"t\":[\"Java 8 API添加了一个新的抽象称为 流Stream，可以让你以一种声明的方式处理数据。\",\"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\",\"Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\",\"这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\",\"元素流在管道中经过 中间操作（intermediate operation）的处理，最后由 最终操作(terminal operation)得到前面处理的结果。\",\"20241130004116\",\"我们就可以把一个 Stream 当做流水线处理：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"aaaa\\\", \\\"asdasda\\\", \\\"AssdW\\\", \\\"xx\\\", \\\"add\\\", \\\"Xss\\\", \\\"sdawErs\\\")); // 过滤 长度不超过 3 // 过滤 首字母不是大写字母 // 去除 重复字符串 // filter(...) 里面条件为 true 的会保留 // distinct 去重 list = list.stream() .filter(str -> str.length() > 3) .filter(str -> str.charAt(0) >= 'A' && str.charAt(0) <= 'Z') .distinct() .collect(Collectors.toList()); System.out.println(list); } \",\"类似\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); list.add(3); list = list.stream() .distinct() //去重（使用equals判断） .sorted((a, b) -> b - a) //进行倒序排列 .map(e -> e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } \",\"当遇到大量的复杂操作时，我们就可以使用 Stream 来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\",\"注意：不能认为每一步是直接依次执行的！\",\"实际上，stream 会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。\",\"接下来，我们用一堆随机数来进行更多流操作的演示：\",\"public static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random.ints(-100, 100) // 生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -> i < 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } \",\"我们可以生成一个统计实例来帮助我们快速进行统计：\",\"public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } \",\"普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -> i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } \",\"我们还可以通过flat来对整个流进行进一步细分：\",\"public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"A,B\\\"); list.add(\\\"C,D\\\"); list.add(\\\"E,F\\\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -> Arrays.stream(e.split(\\\",\\\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } \",\"我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -> a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum); } \"]},\"72\":{\"c\":[\"code\"]},\"73\":{\"c\":[\"java\"]},\"74\":{\"h\":\"Java - Collections 工具类\"},\"75\":{\"h\":\"Collections 工具类\",\"t\":[\"我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。\",\"既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的 Collocations 类就是专用于集合的工具类\"]},\"76\":{\"h\":\"最大 | 最小\",\"t\":[\"我们想快速求得List中的最大值和最小值：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(); Collections.max(list); Collections.min(list); } \"]},\"77\":{\"h\":\"二分搜索\",\"t\":[\"同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现 Comparable 接口的类）：\",\"public static void main(String[] args) { List<Integer> list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8)); } \"]},\"78\":{\"h\":\"快速填充\",\"t\":[\"我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list); } \",\"如果集合中本身没有元素，那么fill操作不会生效。\"]},\"79\":{\"h\":\"空集合\",\"t\":[\"有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：\",\"public static void main(String[] args) { List<Integer> list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常 } \",\"### 只读集合\",\"我们也可以将一个可修改的集合变成只读的集合：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); List<Integer> newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常 } \"]},\"80\":{\"h\":\"查找位置\",\"t\":[\"我们也可以寻找子集合的位置：\",\"public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5))); } \",\"得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：\",\"public static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list.add(\\\"aaa\\\"); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list); } \",\"没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：\",\"public static void main(String[] args) { List list = new ArrayList<>(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\\\"aaa\\\"); System.out.println(list); } \",\"checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：\",\"20241130005736\",\"是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。\"]},\"81\":{\"c\":[\"code\"]},\"82\":{\"c\":[\"java\"]},\"83\":{\"h\":\"Java - 集合类对象相等判定\"},\"84\":{\"h\":\"集合类对象相等判定\",\"t\":[\"Oject类中的 equals 方法比较的是地址，所以自己定义的类要自己重写 equals 等方法，否则给你当成 Object 类\",\"equals 方法 和 == 的区别\",\"集合类中并不是通过 == 进行判断的，都是根据 equals 方法进行判断的\",\"remove 也是根据 equals 进行判断来删除元素\",\"20241130012855\",\"对于 List 列表 判断两个元素是否相同，是根据 元素中的 equals 方法判断的\",\"public class Main { public static void main(String[] args) { List<Test> list = new ArrayList<>(); Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); list.add(t1); System.out.println(list.remove(t2)); // 这样会把 t1 移除，因为 Test 的 equals 判断修改成根据 name 进行判断 } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } } } \",\"对于 Map 以及 Set 而言 两个对象只有 equals 方法判断相同后，还需要判断 hashCode 方法也相同，才认为这两个元素是相同的\",\"对于 Object 定义中提到，如果两个对象通过 equals 判断相同，那么它们的 hashCode 也需要相同。\",\"因此，在重写 equals 方法时，也需要考虑重写 hashCode 方法，保证当两个对象通过 equals 方法判断相同时，它们通过 hashCode 得到的 hash 值也相同\",\"如下，因为重写了 equals 和 hashCode 所以只要 name 一致，通过 map 操作就是相同的\",\"public class Main { public static void main(String[] args) { Test t1 = new Test(\\\"A\\\"); Test t2 = new Test(\\\"A\\\"); Map<Test, Integer> map = new HashMap<>(); map.put(t1, 2); System.out.println(map.get(t2)); } static class Test { String name; public Test(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Test test = (Test) o; return Objects.equals(name, test.name); } @Override public int hashCode() { return Objects.hashCode(name); } } } \"]},\"85\":{\"c\":[\"code\"]},\"86\":{\"c\":[\"java\"]},\"87\":{\"h\":\"Java - IO1\"},\"88\":{\"h\":\"IO流1\",\"t\":[\"一般在java.io中\",\"字节流：\",\"处理单位：以字节（8 位）为单位进行读写操作。\",\"适用场景：适用于处理所有类型的数据，包括文本、图片、音频、视频等二进制数据。\",\"主要类：InputStream 和 OutputStream 及其子类，如 FileInputStream 和 FileOutputStream。\",\"编码处理：不涉及字符编码转换，直接处理原始字节数据。\",\"字符流：\",\"处理单位：以字符（16 位）为单位进行读写操作。\",\"适用场景：专门用于处理文本数据，如读取和写入文本文件。\",\"主要类：Reader 和 Writer 及其子类，如 FileReader 和 FileWriter。\",\"编码处理：自动处理字符编码转换，适用于处理文本文件。\",\"主要区别：处理单位：字节流以字节为单位，字符流以字符为单位。 适用范围：字节流适用于所有类型的数据，字符流仅适用于文本数据。 编码处理：字节流不处理字符编码，字符流自动处理字符编码转换。 性能：字符流在处理文本数据时通常更高效，因为它们直接操作字符，减少了字节到字符的转换时间。\"]},\"89\":{\"h\":\"文件字节流\"},\"90\":{\"h\":\"输入流\",\"t\":[\"我们可以通过它来获取文件的输入流： 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用\",\"public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\\\"路径\\\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } \",\"不过上面写法比较繁琐，在JDK1.7新增了try-with-resource语法，用于简化这样的写法：\",\"public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\\\"路径\\\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } \",\"这种语法只支持实现了AutoCloseable接口的类\"]},\"91\":{\"h\":\"文件读取\",\"t\":[\"read 方法 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } \",\"available 方法 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量） 因此与read结合，可以一次直接读取全部数据：\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } \",\"也可以控制读取的数量：\",\"System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 \",\"skip 方法 可以跳过指定数量的字节\",\"public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } \"]},\"92\":{\"h\":\"输出流\",\"t\":[\"public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } \",\"输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容:\",\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\\\"lbwnb\\\".getBytes()); //也可以直接写入byte[] outputStream.write(\\\"lbwnb\\\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"93\":{\"h\":\"追加操作\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\", true)) { //true表示开启追加模式 outputStream.write(\\\"lb\\\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } \"]},\"94\":{\"h\":\"文件拷贝操作实现\",\"t\":[\"public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\\\"output.txt\\\"); FileInputStream inputStream = new FileInputStream(\\\"test.txt\\\")) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); } } \"]},\"95\":{\"h\":\"文件字符流\",\"t\":[\"java.io.FileReader & java.io.FileWriter\"]},\"96\":{\"h\":\"\",\"t\":[\"字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用.\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } \",\"同理，字符流只支持char[]类型作为存储：\",\"public static void main(String[] args) { try(FileReader reader = new FileReader(\\\"test.txt\\\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } \"]},\"97\":{\"h\":\"\",\"t\":[\"writer除了write方法外，还有一个append方法，但效果是一致的\",\"public static void main(String[] args) { try(FileWriter writer = new FileWriter(\\\"output.txt\\\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } \"]},\"98\":{\"h\":\"类\",\"t\":[\"专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\",\"public static void main(String[] args) { File file = new File(\\\"test.txt\\\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } \",\"通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容:\",\"File file = new File(\\\"/\\\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } \",\"如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\",\"File file = new File(\\\"test.txt\\\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } \"]},\"99\":{\"c\":[\"code\"]},\"100\":{\"c\":[\"java\"]},\"101\":{\"h\":\"Java - IO2\"},\"102\":{\"h\":\"IO流2\"},\"103\":{\"h\":\"缓冲流\",\"t\":[\"虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，**提前将部分内容存入内存（缓冲区）**在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\",\"20250225181159\"]},\"104\":{\"h\":\"缓冲字节流\"},\"105\":{\"h\":\"缓冲字节读取流\",\"t\":[\"要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可:\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } \"]},\"106\":{\"h\":\"缓冲流特性\"},\"107\":{\"h\":\"1. 装饰着模式\",\"t\":[\"实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式\",\"对应缓冲流的close源码：\",\"public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } \",\"实际上这种模式是父类FilterInputStream提供的规范\"]},\"108\":{\"h\":\"2. 缓冲机制\",\"t\":[\"I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存BufferedInputStream 支持 reset() 和 mark() 操作 即通过 mark 标记位置, reset 可以返回之前标记过的位置。\",\"当调用 mark(readlimit) 之后，输入流会以某种方式保留之后读取的readlimit 数量的内容，当读取的内容数量超过 readlimit 则之后的内容不会被保留，当调用 reset() 之后，会使得当前的读取位置回到 mark() 调用时的位置。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。\",\"public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\\\"test.txt\\\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } \"]},\"109\":{\"h\":\"3. 缓冲流可以叠加\",\"t\":[\"即可以进行套娃：BufferedInputStream stream = new BufferedInputStream(new BufferedInputStream(new FileInputStream(\\\"test.txt\\\")))\"]},\"110\":{\"h\":\"缓冲字节输出流\",\"t\":[\"其实和BufferedInputStream原理差不多，只是反向操作\",\"try (BufferedOutputStream stream = new BufferedOutputStream(Files.newOutputStream(Paths.get(\\\"src/1.txt\\\")))){ stream.write(\\\"Hello Penguin!\\\".getBytes()); } catch (IOException e) { throw new RuntimeException(e); } \"]},\"111\":{\"h\":\"缓冲字符流\",\"t\":[\"BufferedReader | BufferedWriter\"]},\"112\":{\"h\":\"缓冲字符读取流\",\"t\":[\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } \",\"相比Reader更方便的是，它支持按行读取\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } \",\"读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流\",\"public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\\\"test.txt\\\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } \",\"它同样也支持mark()和reset()操作\"]},\"113\":{\"h\":\"缓冲字符输出流\",\"t\":[\"public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\\\"output.txt\\\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\\\"汉堡做滴彳亍不彳亍\\\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } \"]},\"114\":{\"c\":[\"code\"]},\"115\":{\"c\":[\"java\"]},\"116\":{\"h\":\"Java - 类与对象2\"},\"117\":{\"h\":\"静态变量和静态方法\",\"t\":[\"Static 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。 我们通过使用 static 关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\",\"一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\",\"public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } \",\"public static void main(String[] args) { Person.info = \\\"让我看看\\\"; System.out.println(Person.info); } \",\"同样的，我们可以将方法标记为静态：\",\"static void test(){ System.out.println(\\\"我是静态方法\\\"); } \",\"静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样:\",\"因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值, 同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的.\"]},\"118\":{\"h\":\"静态变量初始化\",\"t\":[\"我们实际上是将 .class 文件丢给 JVM 去执行的，而每一个 .class 文件其实就是我们编写的一个类，我们在 Java 中使用一个类之前， JVM 并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\",\"访问类的静态变量，或者为静态变量赋值\",\"new 创建类的实例（隐式加载）\",\"调用类的静态方法\",\"子类初始化时\",\"其他的情况会在讲到反射时介绍\",\"所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\"]},\"119\":{\"h\":\"包的访问与控制\"},\"120\":{\"h\":\"包的声明和导入\",\"t\":[\"包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\",\"包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的 www.baidu.com ，后面的 baidu.com 就是域名，我们的包就可以命名为com.baidu，其中的.就是用于分割的，对应多个文件夹，比如com.test\",\"20240815234719\",\"我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 需要通过关键字 package，用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\",\"package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } \",\"当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中） 而当我们需要使用其他包中的类时，需要先进行导入才可以： 需要通过关键字 import 导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类:\",\"import com.test.entity.Person; //使用import关键字导入其他包中的类 import com.test.entity.*; \",\"Java会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\",\"不同类的重名问题 在不同包下的类，即使类名相同，也是不同的两个类：\",\"package com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } \",\"由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\",\"public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } \",\"我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\"]},\"121\":{\"h\":\"访问权限控制\",\"t\":[\"Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\",\"private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。\",\"什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。\",\"protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）\",\"public - 公共，标记为公共的内容，允许在任何地方被访问。\",\"当前类\",\"同一个包下的类\",\"不同包下的子类\",\"不同包下的类\",\"public\",\"✅\",\"✅\",\"✅\",\"✅\",\"protected\",\"✅\",\"✅\",\"✅\",\"❌\",\"默认\",\"✅\",\"✅\",\"❌\",\"❌\",\"private\",\"✅\",\"❌\",\"❌\",\"❌\",\"默认的情况下，在当前包以外的其他包中无法访问。\",\"如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\",\"public class Person { String name; int age; String sex; public static void test(){ System.out.println(\\\"我是静态方法！\\\"); } } \",\"静态导入：\",\"import static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } \"]},\"122\":{\"c\":[\"code\"]},\"123\":{\"c\":[\"java\"]},\"124\":{\"h\":\"Java - IO3\"},\"125\":{\"h\":\"IO流3\"},\"126\":{\"h\":\"转换流\",\"t\":[\"有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦\",\"public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\\\"test.txt\\\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\\\"lbwnb\\\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } \",\"同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现\",\"public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\\\"test.txt\\\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } \",\"InputStreamReader 和 OutputStreamWriter 本质也是Reader和Writer，因此可以直接放入 BufferedReader 来实现更加方便的操作。\"]},\"127\":{\"h\":\"打印流\",\"t\":[\"打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类\",\"public final static PrintStream out = null; \",\"因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。\",\"PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\",\"可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\",\"public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\\\"test.txt\\\"))){ stream.println(\\\"penguin\\\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } \",\"我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\",\"20250225192918\"]},\"128\":{\"h\":\"输入流\",\"t\":[\"之前使用的Scanner，使用的是系统提供的输入流\",\"public static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入 } \",\"我们也可以使用Scanner来扫描其他的输入流：\",\"public static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\\\"秘制小汉堡.txt\\\")); //将文件内容作为输入流进行扫描 } \"]},\"129\":{\"h\":\"数据流\",\"t\":[\"数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\",\"public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\\\"test.txt\\\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } \",\"用于写入基本数据类型:\",\"public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\\\"output.txt\\\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } \",\"注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\"]},\"130\":{\"h\":\"对象流\",\"t\":[\"ObjectOutputStream不仅支持基本数据类型，而且通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\"]},\"131\":{\"h\":\"对象序列化\",\"t\":[\"自己定义的类要序列化保存，则必须实现Serializable接口才能被序列化\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"penguin\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } \"]},\"132\":{\"h\":\"\",\"t\":[\"在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\",\"static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } \"]},\"133\":{\"h\":\"关键字\",\"t\":[\"如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\",\"public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\\\"output.txt\\\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\\\"output.txt\\\"))){ People people = new People(\\\"lbw\\\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } \",\"其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\"]},\"134\":{\"c\":[\"code\"]},\"135\":{\"c\":[\"java\"]},\"136\":{\"h\":\"Java - 多线程与反射1\"},\"137\":{\"h\":\"多线程\"},\"138\":{\"h\":\"进程与线程概念\",\"t\":[\"进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\",\"20250226173747\",\"在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时。\",\"线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\",\"在Java中，我们从开始，一直以来编写的都是单线程应用程序(运行main()方法的内容), 也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程:\",\"public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } \"]},\"139\":{\"h\":\"线程的创建和启动\",\"t\":[\"线程之间是同时运行的 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式\",\" /** * Creates a new Thread that inherits the given AccessControlContext. * This is not a public constructor. */ Thread(Runnable target, AccessControlContext acc) { init(null, target, \\\"Thread-\\\" + nextThreadNum(), 0, acc, false); } //Runnable @FunctionalInterface public interface Runnable { /** * When an object implementing interface <code>Runnable</code> is used * to create a thread, starting the thread causes the object's * <code>run</code> method to be called in that separately executing * thread. * <p> * The general contract of the method <code>run</code> is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } \"]},\"140\":{\"h\":\"方法\",\"t\":[\"20250226175843\",\"创建好后，通过调用start()方法来运行此线程:\",\"public static void main(String[] args) { Thread t = new Thread(() -> { //直接编写逻辑 System.out.println(\\\"我是另一个线程！\\\"); }); t.start(); //调用此方法来开始执行此线程 } \",\"Thread.currentThread() // 获取当前线程对象 Thread t = new Thread(() -> { //自定义线程名称 System.out.println(\\\"我是另一个线程！\\\"); }, \\\"name\\\"); Thread.currentThread().getName() // 获取线程名称 \"]},\"141\":{\"h\":\"方法\",\"t\":[\"run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\"]},\"142\":{\"h\":\"方法\",\"t\":[\"实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间\",\"Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s \",\"我们也可以使用stop()方法来强行终止此线程\",\"public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i < 50; i++) { System.out.println(\\\"打印:\\\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } \",\"虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\"]},\"143\":{\"h\":\"线程的休眠和中断\",\"t\":[\"20250226175843\",\"一个线程处于运行状态下，线程的下一个状态会出现以下情况：\",\"当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。\",\"当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。\",\"当线程出现异常或错误 / 被 stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。\",\"通过调用sleep()方法可以将当前线程进入休眠，使得线程处于等待状态一段时间。\",\"在sleep代码中可以发现，显示声明了会抛出一个InterruptedException异常\",\"public static native void sleep(long millis) throws InterruptedException; \"]},\"144\":{\"h\":\"中断\",\"t\":[\"每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。\",\"interrupt用法：\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\\\"线程被中断了！\\\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } \",\"通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\",\"Thread.interrupted(); /复位中断标记（返回值是当前是否有中断标记） \"]},\"145\":{\"h\":\"线程优先级\",\"t\":[\"Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！ 我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\",\"MIN_PRIORITY 最低优先级\",\"MAX_PRIORITY 最高优先级\",\"NOM_PRIORITY 常规优先级\",\"public static void main(String[] args) { Thread t = new Thread(() -> { System.out.println(\\\"线程开始运行！\\\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } \",\"优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\"]},\"146\":{\"h\":\"线程的礼让和加入\"},\"147\":{\"h\":\"主动让出CPU资源\",\"t\":[\"我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { if(i % 5 == 0) { System.out.println(\\\"让位！\\\"); Thread.yield(); } System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); } }); t1.start(); t2.start(); } \",\"观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\"]},\"148\":{\"h\":\"\",\"t\":[\"当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入:\",\"public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(\\\"线程1开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"1打印：\\\"+i); } System.out.println(\\\"线程1结束！\\\"); }); Thread t2 = new Thread(() -> { System.out.println(\\\"线程2开始运行！\\\"); for (int i = 0; i < 50; i++) { System.out.println(\\\"2打印：\\\"+i); if(i == 10){ try { System.out.println(\\\"线程1加入到此线程！\\\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } \",\"我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！\"]},\"149\":{\"c\":[\"code\"]},\"150\":{\"c\":[\"java\"]},\"151\":{\"h\":\"Java - 多线程与反射2\"},\"152\":{\"h\":\"多线程2\"},\"153\":{\"h\":\"线程锁和线程同步\"},\"154\":{\"h\":\"多线程下java内存管理\",\"t\":[\"20250226223324\",\"线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。\",\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：\",\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\",\"实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！ 好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\",\"比如我们可以来看看下面这个问题：\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) value++; System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\"]},\"155\":{\"h\":\"线程锁\",\"t\":[\"为了避免上面的这个现象，引入 线程锁 的概念\",\"synchronized(对象 | 类){ 代码块 } \",\"synchronized需要在括号中填入一个内容，必须是一个对象或是一个类，因此有对象锁和类锁区别（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\",\"当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC中我们还会讲到乐观锁，如CAS算法）\",\"private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\",\"synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\",\"private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程1完成\\\"); }); Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) add(); System.out.println(\\\"线程2完成\\\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } \",\"我们发现实际上效果是相同的，只不过这个锁不用你去给， 如果是静态方法，就是使用的类锁，\",\"public class Main { private static int i = 0; private static synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (Main.class){ // Main.class 就保证三个线程的锁是一致的 类锁 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"而如果是普通成员方法，就是使用的对象锁。\",\"public class Main { private static int i = 0; private synchronized void add(){ i++; } public static void main(String[] args) throws InterruptedException { Main main = new Main(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) main.add(); }).start(); new Thread(()->{ for(int j = 0;j < 100000;j++) synchronized (main){ // 使用 main 才正确 i++; } }).start(); Thread.sleep(1000); System.out.println(i); } } \",\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。\"]},\"156\":{\"h\":\"死锁\",\"t\":[\"死锁是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\",\"20250226231025\",\"我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\\\"线程1\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\\\"线程2\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } \",\"所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？ 我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程号，然后 jstack pid 即可\",\"jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。\",\"因此，前面说不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\"]},\"157\":{\"c\":[\"code\"]},\"158\":{\"c\":[\"java\"]},\"159\":{\"h\":\"Java - 多线程与反射3\"},\"160\":{\"h\":\"多线程3\"},\"161\":{\"h\":\"和 方法\",\"t\":[\"Object 类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()\",\"他们其实是需要配合synchronized来使用的，平常环境下是无法使用的，只有当对象作为锁时，才能用这三个方法。\",\"实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了。\",\"wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁。wait需要捕获 InterruptedException终止异常。\",\"当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\",\"notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\",\"wait()方法是让该线程从 运行态 -> 等待(waiting)态; notify()则是让处于 等待态的线程变为 阻塞态，所以仍然需要等在运行的线程结束才会转为运行态。\",\"wait()支持参数，可以给他传一个时间参数进去的，是一种自动唤醒机制：在指定时间内，如果没有其他线程唤醒自己，则主动唤醒自己。\",\"如果是 wait() | wait(0) 则表示永久等待，必须要有 notify()才会转换\",\"public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1){ try { System.out.println(\\\"开始等待\\\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\\\"等待结束！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -> { synchronized (o1){ System.out.println(\\\"开始唤醒！\\\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i < 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } \"]},\"162\":{\"h\":\"\",\"t\":[\"专门创建一个独属于某个线程的变量\",\"20250309155822\",\"我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部只能存储一个变量，不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。\",\"ThreadLocal定义在主线程中\",\"public static void main(String[] args) throws InterruptedException { ThreadLocal<String> local = new ThreadLocal<>(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -> { local.set(\\\"penguin\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程1变量值已设定！\\\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"线程1读取变量值：\\\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -> { local.set(\\\"pig\\\"); //将变量的值给予ThreadLocal System.out.println(\\\"线程2变量值已设定！\\\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } \",\"不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\"]},\"163\":{\"h\":\"\",\"t\":[\"为子线程的 local 设置初始值，如果子线程修改了也是可以\",\"public static void main(String[] args) { ThreadLocal<String> local = new InheritableThreadLocal<>(); Thread t = new Thread(() -> { local.set(\\\"lbwnb\\\"); new Thread(() -> { System.out.println(local.get()); }).start(); }); t.start(); } \"]},\"164\":{\"h\":\"定时器\"},\"165\":{\"h\":\"自己定义的定时器\",\"t\":[\"public static void main(String[] args) { new TimerTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -> { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \",\"public static void main(String[] args) { new TimerLoopTask(() -> System.out.println(\\\"我是定时任务！\\\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -> { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } \"]},\"166\":{\"h\":\"\",\"t\":[\"我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等\",\"public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000, 500); //执行一个延时任务 // 运行函数，延迟，循环间隔 } \"]},\"167\":{\"h\":\"不会终止\",\"t\":[\"虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\",\"public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } \",\"TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\",\"public Timer(String name) { thread.setName(name); thread.start(); } \",\"而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\",\"public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() && newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } } } \",\"我们可以通过调用cancel()方法来关闭它的工作线程：\",\"public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } \"]},\"168\":{\"c\":[\"code\"]},\"169\":{\"c\":[\"java\"]},\"170\":{\"h\":\"Java - 多线程与反射4\"},\"171\":{\"h\":\"多线程4\"},\"172\":{\"h\":\"守护线程\",\"t\":[\"t.setDaemon(true);\",\"守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。\",\"而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂。\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \",\"在守护线程中产生的新线程也是守护的：\",\"public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -> { Thread it = new Thread(() -> { while (true){ try { System.out.println(\\\"程序正常运行中...\\\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i < 5; i++) { Thread.sleep(1000); } } \"]},\"173\":{\"h\":\"集合类\",\"t\":[\"java中也有些使用并行来进行操作的\",\"集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。\",\"并行流 parallelStream()\",\" default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作 } \",\"并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\",\" public static void main(String[] args) { List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -> System.out.println(Thread.currentThread().getName()+\\\" -> \\\"+i)); } \",\"我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序。\",\"在Arrays数组工具类中，也包含大量的并行方法：\",\" public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } \",\"集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题\"]},\"174\":{\"h\":\"生产者与消费者\",\"t\":[\"所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\",\"通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\",\"public class Main { private static final Queue<Object> queue = new LinkedList<>(); public static void main(String[] args) { new Thread(Main::add, \\\"厨师1\\\").start(); new Thread(Main::add, \\\"厨师2\\\").start(); new Thread(Main::take, \\\"顾客1\\\").start(); new Thread(Main::take, \\\"顾客2\\\").start(); new Thread(Main::take, \\\"顾客3\\\").start(); } private static void add(){ while (true){ try { Thread.sleep(3000); synchronized (queue) { String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"put menu\\\"); queue.offer(new Object()); queue.notifyAll(); } } catch (InterruptedException e) { e.printStackTrace(); } } } private static void take(){ while (true) { try { synchronized (queue){ while(queue.isEmpty())queue.wait(); queue.poll(); String name = Thread.currentThread().getName(); System.out.println(new Date() + \\\" \\\" + name + \\\"eat\\\"); } Thread.sleep(4000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \"]},\"175\":{\"c\":[\"code\"]},\"176\":{\"c\":[\"java\"]},\"177\":{\"h\":\"Java - 反射1\"},\"178\":{\"h\":\"反射1\"},\"179\":{\"h\":\"反射\",\"t\":[\"反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\",\"简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\"]},\"180\":{\"h\":\"JAVA 类加载机制\",\"t\":[\"20250310160214\",\"在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\",\"简单理解为： 默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。\",\"Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。\"]},\"181\":{\"h\":\"Class 类\",\"t\":[\"在类加载过程的同时，会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。\"]},\"182\":{\"h\":\"获取相应类的Class对象\",\"t\":[\"共有三种方法，无论哪种方法所获取到的 Class 对象始终是相同的。 所以类锁本质上就是对应的类的 Class 对象。\",\"public static void main(String[] args) throws ClassNotFoundException { Class<String> clazz = String.class; //使用class关键字，通过类名获取 Class<?> clazz2 = Class.forName(\\\"java.lang.String\\\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class<?> Class<?> clazz3 = new String(\\\"cpdd\\\").getClass(); //通过实例对象获取 } \"]},\"183\":{\"h\":\"基本数据类型的 Class 对象\",\"t\":[\"基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的.\",\"/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\\\"unchecked\\\") public static final Class<Integer> TYPE = (Class<Integer>) Class.getPrimitiveClass(\\\"int\\\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class<?> getPrimitiveClass(String name); //C++实现，并非Java定义 \",\"每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\",\"包装类型都有一个TYPE，其实也就是基本类型的Class，但包装类的Class和基本类的Class显然是不同的。\",\"public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } \"]},\"184\":{\"h\":\"数组的 Class 对象\",\"t\":[\"数组类型也是一种类型，只是编程不可见\",\"public static void main(String[] args) { Class<String[]> clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\\\"10\\\"))); //强制类型转换（会报错） } \"]},\"185\":{\"h\":\"Class 对象与多态\"},\"186\":{\"h\":\"类型比较\",\"t\":[\"正常情况下，我们使用instanceof进行类型比较, 它可以判断一个对象是否为此接口或是类的实现或是子类：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str instanceof String); } \",\"有了 Class 后，可以有其他方式判断类型：\",\"public static void main(String[] args) { String str = \\\"\\\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } \",\"asSubClass()，判断是否为子类或是接口/抽象类的实现\",\" public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } \",\"getSuperclass()，可以获取到父类的Class对象\",\" public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } \",\"getGenericSuperclass()，获取父类的原始类型的Type\",\" public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } \",\"我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class\",\" public static void main(String[] args) { Integer i = 10; for (Class<?> anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } \",\"泛型的参数获取 ParameterizedType | TypeVariableImpl\",\"如果一个类的父类是泛型，其对应的 class 就不是正常的 class， 而是一个参数化类型:\",\"class sun.reflect.generics.reflectiveObjects.TypeVariableImpl\",\"对应地，我们从 参数化类型中可以获取到泛型在定义过程中的参数类型 getActualTypeArguments。\",\" public static void main(String[] args) { ParameterizedType type = (ParameterizedType) ArrayList.class.getGenericSuperclass(); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"在这种情况下，对应的 type 由于泛型中未定义，所以是 E, 对应的class 类型为 TypeVariableImpl\",\"20250310165216\",\"如果我们已经明确了继承的泛型的类型，那么对应返回的就是确定的类型 class\",\" <!-- Test.java --> public class Test <T> { } <!-- Student.java --> public class Student extends Test<String> { String name; int age; } <!-- Main.java --> public static void main(String[] args) { ParameterizedType type = (ParameterizedType) Student.class.getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170039\",\"此外，如果这种情况，由于类型擦除机制，仍然是获取不到具体的 class 的, 返回的仍然是 E\",\" public static void main(String[] args) { List<String> list = new ArrayList<>(Arrays.asList(\\\"ASDF\\\")); ParameterizedType type = (ParameterizedType) list.getClass().getGenericSuperclass(); System.out.println(type); Type[] types = type.getActualTypeArguments(); for (Type type1 : types) { System.out.println(type1); System.out.println(type1.getClass()); } } \",\"20250310170551\"]},\"187\":{\"c\":[\"code\"]},\"188\":{\"c\":[\"java\"]},\"189\":{\"h\":\"Java - 反射2\"},\"190\":{\"h\":\"反射2\"},\"191\":{\"h\":\"创建类对象\",\"t\":[\"可以通过Class对象来创建对象、调用方法、修改变量。\",\"我们通过 newInstance() 即可创建对应的对象实例。\",\"通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常\",\"当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。\",\"当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class<Student> clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\\\"萨日朗\\\"); } } \",\"在JDK9之后，不再推荐使用newInstance()方法, 而是通过获取构造器 getConstructor()，来实例化对象，通过获取类的构造方法（构造器）来创建对象实例，会更加合理。 我们可以使用getConstructor()方法来获取类的权限为 public 的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型\",\" public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getConstructor(String.class); Student student = constructor.newInstance(\\\"penguin\\\"); student.test(); } public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(){ System.out.println(this.name); } } \",\"当访问权限不是public的时候, 会无法找到此构造方法, 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）.\",\" Class<Student> clazz = Student.class; Constructor<Student> constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\\\"what's up\\\"); student.test(); \"]},\"192\":{\"h\":\"调用类方法\",\"t\":[\"我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用。\",\"通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。\",\"// Student.java package com.test; public class Student { public void test(String str){ System.out.println(\\\"Penguin \\\"+str); } } // Main.java public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \\\"!!!\\\"); //通过Method对象的invoke方法来调用方法 } \",\"我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。\",\"同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用, 即通过 getDeclaredMethod + setAccessible 组合。\",\"// 将test()方法的权限修饰符改为private后 public static void main(String[] args) throws ReflectiveOperationException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\\\"test\\\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \\\"what's up\\\"); //通过Method对象的invoke方法来调用方法 } \",\"Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息(``)：\",\"// Student.java public class Student extends Test<String> { String name; int age; public Student(String name){ this.name = name; } public void test(String s, int i){ System.out.println(this.name); } } // Main.java public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException { Class<?> clazz = Class.forName(\\\"com.test.Student\\\"); Constructor<?> constructor = clazz.getConstructor(String.class); Object penguin = constructor.newInstance(\\\"penguin\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class, int.class); method.invoke(penguin, \\\"qq\\\", 123); System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 for (Parameter parameter : method.getParameters()) { System.out.println(parameter); } } \",\"20250312002044\",\"当方法的参数为可变参数时, 变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：\",\"Method method = clazz.getDeclaredMethod(\\\"test\\\", String[].class); \",\"当方法是静态方法时，invoke不需要对象参数，因为是属于类的。\",\"反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。\"]},\"193\":{\"h\":\"修改类的属性\",\"t\":[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段，在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，当访问private字段时，同样可以按照上面的操作进行越权访问（JAVA高版本不行，对反射进行了限制）\",\"public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, NoSuchFieldException { Integer i = 10; Field value = Integer.class.getDeclaredField(\\\"value\\\"); value.setAccessible(true); System.out.println(value.get(i)); value.set(i, 20); System.out.println(i); } \",\"通过反射可以直接将final修饰符直接去除\",\"public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\\\"value\\\"); Field modifiersField = Field.class.getDeclaredField(\\\"modifiers\\\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()&~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } \",\"我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：\",\"public static void main(String[] args) throws ReflectiveOperationException { List<String> i = new ArrayList<>(); Field field = ArrayList.class.getDeclaredField(\\\"size\\\"); field.setAccessible(true); field.set(i, 10); i.add(\\\"测试\\\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } \",\"实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！\",\"再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！\"]},\"194\":{\"c\":[\"code\"]},\"195\":{\"c\":[\"java\"]},\"196\":{\"h\":\"Java - 反射3\"},\"197\":{\"h\":\"反射3\"},\"198\":{\"h\":\"类加载器\",\"t\":[\"类加载器就是用于加载一个类的，但是类加载器并不是只有一个。\",\"思考： 既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？\",\"package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\\\"我姓🐴，我叫🐴nb\\\"); } } \",\"会出现以下报错：\",\"错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) \",\"但是我们明明在自己写的String类中定义了main方法，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行\",\"20250312005934\",\"实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了。\",\"public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } \"]},\"199\":{\"h\":\"自己编译的类加载到 JVM 中\",\"t\":[\"既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：\",\"package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\\\" > 我是测试方法！\\\"+str); } } \",\"通过javac命令，手动编译一个.class文件：\",\"javac src/main/java/com/test/Test.java \",\"编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：\",\"//定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class<?> defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\\\"Test.class\\\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class<?> clazz = classLoader.defineClass(\\\"com.test.Test\\\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } \",\"现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：\",\"try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"我们来试试看修改成员字段之后，再来调用此方法：\",\"try { Object obj = clazz.newInstance(); Field field = clazz.getField(\\\"text\\\"); //获取成员变量 String text; field.set(obj, \\\"华强\\\"); Method method = clazz.getMethod(\\\"test\\\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \\\"哥们这瓜多少钱一斤？\\\"); }catch (Exception e){ e.printStackTrace(); } \",\"通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。\"]},\"200\":{\"c\":[\"code\"]},\"201\":{\"c\":[\"java\"]},\"202\":{\"h\":\"Java - 注解\"},\"203\":{\"h\":\"注解\",\"t\":[\"注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。\",\"比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。\"]},\"204\":{\"h\":\"预设注解\",\"t\":[\"JDK预设了以下注解，作用于代码：\",\"@Override- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\",\"@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。\",\"@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）\",\"@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。\",\"@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\"]},\"205\":{\"h\":\"元注解\",\"t\":[\"元注解是作用于注解上的注解，用于我们编写自定义的注解：\",\"@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\",\"@Documented - 标记这些注解是否包含在用户文档中。\",\"@Target - 标记这个注解应该是哪种 Java 成员。\",\"@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\",\"@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\"]},\"206\":{\"h\":\"定义\",\"t\":[\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。\",\"@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。\",\"既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } \",\"这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：\",\"@Test public class Main { @Test public static void main(String[] args) { } } \",\"这样，一个最简单的注解就被我们创建了。\"]},\"207\":{\"h\":\"注解的使用\",\"t\":[\"我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } \",\"默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } \",\"public class Main { @Test(test = \\\"\\\") public static void main(String[] args) { } } \",\"我们也可以使用default关键字来为这些属性指定默认值：\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \\\"ppenguin！\\\"; } \",\"当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } \",\"当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：\",\"@Test(\\\"aasd\\\") public static void main(String[] args) { } \",\"public class Main { @Test({\\\"value1\\\", \\\"value2\\\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } \"]},\"208\":{\"h\":\"反射获取注解\",\"t\":[\"既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：\",\" // Test.java import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } // Main.java public static void main(String[] args) { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：\",\"public static void main(String[] args) throws NoSuchMethodException { Class<Student> clazz = Student.class; for (Annotation annotation : clazz.getMethod(\\\"test\\\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } \",\"无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。\",\"所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。\"]},\"209\":{\"c\":[\"code\"]},\"210\":{\"c\":[\"java\"]},\"211\":{\"h\":\"Java - 类与对象3\"},\"212\":{\"h\":\"封装 继承和多态\",\"t\":[\"封装、继承和多态是面向对象编程的三大特性。\",\"封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\",\"继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\",\"多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\",\"正是这三大特性，让我们的Java程序更加生动形象。\"]},\"213\":{\"h\":\"封装\"},\"214\":{\"h\":\"继承\",\"t\":[\"父类是 super 子类是 this\"]},\"215\":{\"h\":\"Object 类\",\"t\":[\"Object 是最顶层的类，所有其他类都是继承它的 方法： euqals toString clone hashcode\",\"public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class<?> getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } \"]},\"216\":{\"h\":\"方法重写\",\"t\":[\"方法的重载是为某个方法提供更多种类 而方法的重写是覆盖原有的方法实现,重写方法要求与父类的定义完全一致 比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了\",\"public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) && //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age && //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } \",\"在修改后 即使强制类型转换 但实际上还是在调用本身的方法\",\" Person p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); Person p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 \",\"我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用 super 关键字： satic 成员方法中不能用 super\",\"@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } \",\"如果父类的方法是 private, 那么无法重写\"]},\"217\":{\"h\":\"控制符\",\"t\":[\"final 对于成员变量，则表示只能赋一次值。只能在构造函数进行赋值(如果有初始值，构造函数也不能赋值)，其他地方不能修改 对于成员方法，会限制其子类不允许其重写所对应的成员变量 在 类 上 加 final, 表示这个类不能再被继承了\"]},\"218\":{\"h\":\"抽象类\",\"t\":[\"抽象类具有 抽象方法，正常实例化方法是无法创造抽象类的实例\",\"抽象方法是指：只保留方法的定义，并不编写方法的主体，具体的实现由 子类 来实现.\",\"要使用抽象类，我们只能去创建它的子类对象。\",\"抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类\",\"抽象方法的访问权限不能为 private, 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\",\"public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } \",\"而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法 不过如果子类也是抽象类，就不一定需要实现。\",\"public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \\\"工人\\\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } } \",\"发现对于 抽象类 中定义的 抽象方法，其子类的对应的方法的访问权限需要高于抽象类中的方法，且同样不能使用 private。 即 如果抽象方法在抽象类定义的是 public, 子类对应必须是 public 不能是 protected; 而如果抽象类定义的是 protected，子类也可以定义 public\"]},\"219\":{\"h\":\"接口\",\"t\":[\"接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\",\"接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\",\"实际上接口的目标就是将类所具有某些的行为抽象出来。\",\"可以理解为 接口 相当于 只有抽象类中的抽象方法，甚至都不是一个类了。\",\"接口里只能定义对应的抽象方法，不过可以省略 abstract 定义 并且默认在类中实现的权限是 public\",\"定义接口 interface\",\"实现接口 implements\",\"接口可以实现很多个，只需要用 逗号 隔开即可，类只能继承一个、\",\"所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\",\"java8开始，接口中的方法可以存在默认实现，default 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\",\"接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法 接口中定义的静态变量只能是public static final的 接口中定义的静态方法也只能是public的 这些可以省 直接int a = 1static void test()这种即可 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容\",\"接口是可以继承 (extends) 自其他接口的, 并且接口没有继承数量限制，接口支持多继承 接口的继承相当于是对接口功能的融合罢了\",\"接口的默认方法是保底的，只要一个类的父类或者自身有对应方法，就不会执行接口的默认方法\",\"接口中如果定义了与 Object 同名的方法，不能使用默认，因为其他类就算继承这个接口，由于类本身都是继承 Object 的，这个默认方法没有任何作用\",\"比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\",\"接口定义:\",\"public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } \",\"让类来使用这个接口\",\"public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\\\"我会学习！\\\"); } } \",\"接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用，即\",\"public class Main { public static void main(String[] args) { Study study = new Teacher(\\\"penguin\\\",18,\\\"male\\\"); study.study() //这里的话只能使用接口中的方法，以及Object的方法 } } \",\"接口同样支持向下转型：\",\"public static void main(String[] args) { Study study = new Teacher(\\\"小王\\\", 27, \\\"男\\\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } \",\"从Java8开始，接口中可以存在让抽象方法的默认实现：\",\"public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\\\"我是默认实现\\\"); } } \"]},\"220\":{\"h\":\"Object类中的 克隆方法\",\"t\":[\"这是浅拷贝，克隆出来的与原来的对象不是一个对象，但对象中的属性都是同一个地址\",\"克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\",\"浅拷贝： 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。\",\"深拷贝： 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。\",\"package java.lang; public interface Cloneable { //这个接口中什么都没定义 } \",\"具体实现克隆:\",\"public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\\\"我会学习！\\\"); } } \",\"克隆实现：\",\"public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } \"]},\"221\":{\"h\":\"枚举类\",\"t\":[\"public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } \",\"使用枚举类也非常方便，就像使用普通类型那样：\",\"public class Student { private Status status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } \",\"使用就像对象的参数一样:\",\"Status.RUNNING Status.STUDY Status.SLEEP \",\"枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\",\"//这里使用javap命令对class文件进行反编译得到 Compiled from \\\"Status.java\\\" public final class com.test.Status extends java.lang.Enum<com.test.Status> { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } \",\"枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\",\"public enum Status { RUNNING(\\\"睡觉\\\"), STUDY(\\\"学习\\\"), SLEEP(\\\"睡觉\\\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } \",\"public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } \"]},\"222\":{\"c\":[\"code\"]},\"223\":{\"c\":[\"java\"]},\"224\":{\"h\":\"Java - 类与对象4\"},\"225\":{\"h\":\"面向对象高级篇1\"},\"226\":{\"h\":\"基本类型包装类\",\"t\":[\"Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\"]},\"227\":{\"h\":\"所有包装类如下\",\"t\":[\"20241017002218\",\"其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\",\"byte -> Byte\",\"boolean -> Boolean\",\"short -> Short\",\"char -> Character\",\"int -> Integer\",\"long -> Long\",\"float -> Float\",\"double -> Double\",\"包装类型的自动装箱和拆箱机制 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想） 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\",\" public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 // 不需要 Integer i = new Integer(10) // 这里本质上就是被自动包装成了一个Integer类型的对象， // 只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的 Integer i = 10; int a = i; } \",\"因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\",\" public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } \",\"那么自动装箱的呢？\",\" public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\",\"但是如果超出这个缓存范围的话，就会得到不同的对象了：\",\"public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制。\"]},\"228\":{\"h\":\"包装类的方法\",\"t\":[\"包装类支持字符串直接转换\",\" public static void main(String[] args) { Integer i = new Integer(\\\"666\\\"); //直接将字符串的666，转换为数字666 System.out.println(i); // 字符串转Integer有多个方法： Integer i = Integer.valueOf(\\\"5555\\\"); Integer i = Integer.decode(\\\"0xA6\\\"); Integer.toHexString(166) } \"]},\"229\":{\"h\":\"特殊包装类\",\"t\":[\"BigInteger 和 BigDecimal 都在 java.math 中\",\"Void类 没啥意义 不能 new 只能 Void v = null\",\"BigInteger import java.math.BigInteger 用于计算超大数字，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字。 但不支持 自动装箱|拆箱机制，计算的话也只能通过 BigInteger 提供的方法进行计算。 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\",\" public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); BigInteger h = BigInteger.valueOf(100) // 乘法 BigInteger a = h.multiply(BigInteger.TEN) } \",\"BigDecimal import java.math.BigDecimal 浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算\",\"public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } \"]},\"230\":{\"c\":[\"code\"]},\"231\":{\"c\":[\"java\"]},\"232\":{\"h\":\"Java - 数组 | 字符串 | 正则表达式\"},\"233\":{\"h\":\"面向对象高级篇 2\"},\"234\":{\"h\":\"数组\",\"t\":[\"数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素。\"]},\"235\":{\"h\":\"定义\",\"t\":[\"数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建） 即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用 new 关键字\",\"public static void main(String[] args) { int[] array = new int[10]; //类型[]就表示这个是一个数组类型 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } \",\"创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的 其他定义方法:\",\"类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 \"]},\"236\":{\"h\":\"方法\",\"t\":[\"数组的 length 是在一开始就确定的，而且是 final类型 的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\",\" public static void main(String[] args) { int[] array = new int[10]; System.out.println(\\\"当前数组长度为：\\\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } \",\"array 虽然是继承于 Object，但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现，所以可能不满足真实需求。\"]},\"237\":{\"h\":\"访问元素\",\"t\":[\"for 或者 foreach\",\" public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i < array.length; i++) { System.out.print(array[i] + \\\" \\\"); } for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\\\" \\\"); //每一轮循环，i都会更新成数组中下一个元素 } } \"]},\"238\":{\"h\":\"特性\",\"t\":[\"这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\",\" public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; // 这样是不能赋值的 会报错 } \",\"由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的, 即 int[] arr = new int[10] 是不能 Object[] arrav = arr 这样的\",\"但是如果是引用类型的话，是可以的,因为父类都是 Object\",\" public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } \"]},\"239\":{\"h\":\"性质\",\"t\":[\" public static void main(String[] args) { final int[] a = {1,2,3,4}; // 值还是可以修改，只是数组的地址不准修改 a[0] = 4; // 允许 a = {2,4,8,7}; //不允许 } \"]},\"240\":{\"h\":\"多维数组\",\"t\":[\"既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的\",\"public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } \"]},\"241\":{\"h\":\"可变长参数\",\"t\":[\"public void function(参数类型...参数名称) 这样参数名称所表示的就是一个数组\",\"public class Person { String name; int age; String sex; // 可以传入 0 - N 个类型的实参 public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } } public static void main(String[] args) { Person person = new Person(); person.test(\\\"1！\\\", \\\"5！\\\", \\\"哥们在这跟你说唱\\\"); //这里我们可以自由传入任意数量的字符串 } \",\"注意，如果同时存在其他参数，那么可变长参数只能放在最后：\",\"public void test(int a, int b, String... strings){ } \"]},\"242\":{\"h\":\"函数的\",\"t\":[\"public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } \",\"可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：java com/test/Main lbwnb aaaa xxxxx 因此会读取命令行中的指令参数进行存储到 args 中。\"]},\"243\":{\"h\":\"字符串\",\"t\":[\"字符串类是一个比较特殊的类，它用于保存字符串。 我们知道，基本类型 char 可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组） Java中没有字符串这种基本类型，因此只能使用类来进行定义。 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\"]},\"244\":{\"h\":\"String 类\",\"t\":[\"String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象, 也可以象征性 new 不过没必要 如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了\",\"public static void main(String[] args) { String str1 = \\\"Hello World\\\"; String str2 = \\\"Hello World\\\"; System.out.println(str1 == str2); // 这样就不同 String str3 = new String(\\\"Hello World\\\"); String str4 = new String(\\\"Hello World\\\"); System.out.println(str3 == str4); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } \",\"因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用 ==， String类重载了equals方法用于判断和比较内容是否相同\",\"获取长度 str.length()\",\"public static void main(String[] args) { String str = \\\"Hello World\\\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } \",\"字符串类中提供了很多方便我们操作的方法， 比如字符串的裁剪 (substring)、分割操作 (split)\",\" public static void main(String[] args) { String str = \\\"Hello World\\\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); String[] strings = str.split(\\\" \\\"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } \",\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组: char[] chars = str.toCharArray()字符数组转字符串: String str = new String(chars)\"]},\"245\":{\"h\":\"StringBuilder 类\",\"t\":[\"StringBuilder 就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足\",\"public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\\\"AAA\\\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\\\"BBB\\\"); builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } \",\"字符串支持使用 + 和 += 进行拼接操作, 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\",\"对于变量来说\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } \",\"如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？ 这种情况实际上会被优化为下面的写法：\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } \"]},\"246\":{\"h\":\"正则表达式\",\"t\":[\"str.match(正则表达式)\",\"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\",\"public static void main(String[] args) { String str = \\\"oooo\\\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\\\"o+\\\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } \",\"用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\",\"字符\",\"描述\",\"*\",\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \\\"z\\\" 以及 \\\"zoo\\\"。***** 等价于 {0,}。\",\"+\",\"匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \\\"zo\\\" 以及 \\\"zoo\\\"，但不能匹配 \\\"z\\\"。+ 等价于 {1,}。\",\"?\",\"匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \\\"do\\\" 、 \\\"does\\\"、 \\\"doxy\\\" 中的 \\\"do\\\" 。? 等价于 {0,1}。\",\"{n}\",\"n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \\\"Bob\\\" 中的 o，但是能匹配 \\\"food\\\" 中的两个 o。\",\"{n,}\",\"n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \\\"Bob\\\" 中的 o，但能匹配 \\\"foooood\\\" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\",\"{n,m}\",\"m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \\\"fooooood\\\" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\",\"如果我们想要表示一个范围内的字符，可以使用方括号：\",\"public static void main(String[] args) { String str = \\\"abcabccaa\\\"; System.out.println(str.matches(\\\"[abc]*\\\")); //表示abc这几个字符可以出现 0 - N 次 } \",\"对于普通字符来说，我们可以下面的方式实现多种字符匹配：\",\"字符\",\"描述\",\"[ABC]\",\"匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中所有的 e o u a 字母。\",\"[^ABC]\",\"匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中除了 e o u a 字母的所有字母。\",\"[A-Z]\",\"[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。\",\".\",\"匹配除换行符（\\\\n、\\\\r）之外的任何单个字符，相等于 [^\\\\n\\\\r]\",\"[\\\\s\\\\S]\",\"匹配所有。\\\\s 是匹配所有空白符，包括换行，\\\\S 非空白符，不包括换行。\",\"\\\\w\",\"匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\",\"当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\",\"正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\"]},\"247\":{\"c\":[\"code\"]},\"248\":{\"c\":[\"java\"]},\"249\":{\"h\":\"Java - 内部类\",\"t\":[\"静态 属于 类， 成员 属于 对象。\"]},\"250\":{\"h\":\"内部类\",\"t\":[\"内部类顾名思义，就是创建在内部的类。\"]},\"251\":{\"h\":\"成员内部类 (属于 对象)\",\"t\":[\"成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用\",\"成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的， 如果我们要使用成员内部类，那么就需要创造一个对象，才能去 new 一个成员内部类。\",\"我们可以直接在类的内部定义成员内部类：\",\"public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\\\"我是成员内部类！\\\"); } } } \",\"public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 inner.test(); } \",\"注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.\",\"这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\\\"我是成员内部类：\\\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } \",\"每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\",\"20241027012950\",\"public static void main(String[] args) { Test a = new Test(\\\"小明\\\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\\\"小红\\\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } \",\"那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个 (就近原则) 如果需要指定为外部的对象，那么需要在前面添加外部类型名称Test.this.\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\\\"方法参数的name = \\\"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\\\"成员内部类的name = \\\"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\\\"成员内部类的name = \\\"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } \",\"包括对方法的调用和super关键字的使用，也是一样的：\",\"public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } \"]},\"252\":{\"h\":\"静态内部类 (属于 类)\",\"t\":[\"静态内部类就像静态方法和静态变量一样，是属于类的，不需要，依附任何对象我们可以直接创建使用。\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\\\"我是静态内部类！\\\"); } } } \",\"不需要依附任何对象，我们可以直接创建静态内部类的对象：\",\"public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } \",\"静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的\"]},\"253\":{\"h\":\"局部内部类\",\"t\":[\"(这种局部内部类的形式，使用频率很低，基本上不会用到) 局部内部类就像局部变量一样，可以在方法中定义。 基本定义是：(不需要声明访问权限，因为它作用范围就只是方法内)\",\"public 方法名(){ class 局部内部类名 { 内容 } } \",\"既然是在方法中声明的类，那作用范围也就只能在方法中了\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 public void test(){ System.out.println(\\\"我是局部内部类\\\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } \"]},\"254\":{\"h\":\"静态内部类编译特性\",\"t\":[\"package com.test; import com.test.entity.Test; public class Main { public static void main(String[] args) { Test.Inner.test(); } } \",\"package com.test.entity; public class Test { static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"内部类静态方法\\\"); } } } \",\"结果是：\",\"20241027015244\",\"说明这种情况下，只是初始化了内部类的，并没有初始化内部类，因为并没有使用到外部类的任何静态变量，所以只初始化了内部类。 因为在编译的时候，类的内部类它会单独生成一个 .class，当你使用内部类静态方法，不会调用外部类的 class 只有在你使用到外部类的静态变量或方法后，才会初始化外部类, 但还是先初始化内部类。\",\"package com.test.entity; public class Test { public static String name = \\\"penguin\\\"; static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"使用外部静态变量\\\" + name); System.out.println(\\\"内部类静态方法\\\"); } } } \",\"输出为：\",\"20241027015718\"]},\"255\":{\"h\":\"匿名内部类\",\"t\":[\"匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\",\"不能直接通过 new 的方式去创建一个抽象类或是接口对象，正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\",\"但我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象\",\"public abstract class Student { public abstract void test(); } \",\"public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\\\"我是匿名内部类的实现!\\\"); } }; student.test(); } \",\"此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）\",\"同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类 这样就是一个实现 接口 中方法 的匿名类，但类名必须与接口一致。\",\"package com.test.entity; public interface Study { void study(); } \",\"public class Main { public static void main(String[] args) { Study ss = new Study() { @Override public void study() { System.out.println(\\\"penguin\\\"); } }; ss.study(); } } \",\"匿名对象本身不能定义新的属性。匿名对象的类是在创建时匿名生成的，但它继承自一个现有的类或实现了一个接口。因此，匿名类只能访问其父类的属性或方法，无法直接定义新的属性.\",\"在 Java 中，匿名对象通常不能直接给属性赋值，因为匿名对象没有类名，无法显式定义构造函数或初始化块 因此，为了在创建匿名对象时进行属性初始化，Java 提供了一种特殊的语法，即使用初始化块 {}。\",\"当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 类似：\",\"package com.test.entity; public class Penguin { protected String apple; public void test(){ System.out.println(apple); } } \",\"public class Main { public static void main(String[] args) { Penguin pp = new Penguin(){ { apple = \\\"ppp\\\"; } }; pp.test(); } } \"]},\"256\":{\"h\":\"匿名内部类特性\",\"t\":[\"对于 匿名内部类 或者 Lambda 中，如果想用外部变量，只能使用 final 的变量，如果不是 final，会隐式修改为 final 即之后不能修改\",\"public static void main(String[] args) { int a = 10; // a = 20; // 如果修改了a 就会报错 Study pp = new Study{ @Override public void study(){ System.out.println(a); } } pp.test(); } \"]},\"257\":{\"h\":\"Lambda表达式\",\"t\":[\"如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式\",\"public static void main(String[] args) { Study study = () -> System.out.println(\\\"我是学习方法！\\\"); //是不是感觉非常简洁！ study.study(); } \",\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda 仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"如果有一个参数和返回值的话：\",\"public static void main(String[] args) { Study study = (a) -> { System.out.println(\\\"我是学习方法\\\"); return \\\"今天学会了\\\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } \",\"如果参数只有一个，那么可以省去小括号 如果方法体中只有一个返回语句，可以直接省去花括号和return关键字\",\"Study study = (a) -> { return \\\"今天学会了\\\"+a; //这种情况是可以简化的 }; ==================================== Study study = (a) -> \\\"今天学会了\\\"+a; ==================================== Study study = a -> \\\"今天学会了\\\"+a; \",\"如果一个方法的参数需要的是一个接口的实现:\",\"public static void main(String[] args) { test(a -> \\\"今天学会了\\\"+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } \",\"对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\"]},\"258\":{\"h\":\"方法引用\",\"t\":[\"方法引用 类名::方法名 就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义 参数一样，返回值一样 一样才行）\",\"public interface Study { int sum(int a, int b); //待实现的求和方法 } \",\"那么使用时候，可以直接使用Lambda表达式：\",\"public static void main(String[] args) { Study study = (a, b) -> a + b; } \",\"只不过还能更简单，因为Integer类中默认提供了求两个int值之和的静态方法：\",\"public static void main(String[] args) { Study study = (a, b) -> Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } ================= 方法引用 类名::方法名 ========================= public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } \",\"方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。\",\"任何方法都可以通过方法引用作为实现：\",\"public interface Study { String study(); } \",\"如果是普通成员方法 (成员方法只能通过 对象 调用，不是静态方法)，我们同样需要使用对象来进行方法引用：\",\"public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \\\"卡布奇诺今犹在，不见当年倒茶人。\\\"; } \",\"因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\",\"public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } \",\"反正只要是符合接口中方法的定义的，都可以直接进行方法引用。\"]},\"259\":{\"c\":[\"code\"]},\"260\":{\"c\":[\"java\"]},\"261\":{\"h\":\"Java - 异常\"},\"262\":{\"h\":\"面向对象高级篇 4\"},\"263\":{\"h\":\"异常机制\"},\"264\":{\"h\":\"异常类型\",\"t\":[\"我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等. 他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自 Exception 类\",\"运行时异常 继承自 RuntimeException 在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。 所有的运行时异常都继承自 RuntimeExceptionRuntimeException 是继承 Exception\",\"编译时异常 继承 Exception 编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！ 默认继承自 Exception 类的异常都是编译时异常。 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\",\"protected native Object clone() throws CloneNotSupportedException; \",\"20241029001425\",\"错误 Error错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了。 比如 OutOfMemoryError 就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\"]},\"265\":{\"h\":\"自定义异常\",\"t\":[\"异常其实就两大类，一个是编译时异常 Exception，一个是运行时异常 RuntimeException。 我们自定义异常也是从这两类中进行选择。\",\"自定义编译时异常 编译时异常只需要继承 Exception 就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\",\"public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } \",\"自定义运行时异常 运行时异常只需要继承 RuntimeException 就行了\",\"public class TestException extends RuntimeException{ public TestException(String message){ super(message); } } \"]},\"266\":{\"h\":\"抛出异常\",\"t\":[\"当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\",\"public static int test(int a, int b) { if(b == 0) throw new ArithmeticException(\\\"被除数不能为0\\\"); //throw new RuntimeException(\\\"被除数不能为0\\\"); //使用throw关键字来抛出异常 return a / b; } \",\"异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在 RuntimeException 的构造方法中我们可以写入原因。\",\"注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以，因为不这样就无法编译了： throws Exception\",\"就是说如果这个函数结束时有异常，要么自己处理好，要么就往上一级函数上 throw\",\"private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\\\"我是编译时异常！\\\"); } \",\"如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\",\"private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } \",\"最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\",\"@Override protected Object clone() { return new Object(); } \"]},\"267\":{\"h\":\"异常的处理\",\"t\":[\"当程序没有按照我们理想的样子运行而出现异常时（默认会交给 JVM 来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息） 现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获\",\"异常处理：要么一直 throw 交给上一级函数 最终到 main 给 jvm 处理; 要么在当前函数通过 try-catch 进行捕获。\",\"无论是否出现异常，都会在最后执行任务，可以交给 finally 语句块来处理，可以只跟 try 使用。\",\"public static void main(String[] args) { // try...catch 进行异常捕获 try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\\\"异常错误信息：\\\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\\\"程序继续正常运行！\\\"); } \",\"如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用 try-catch 语句块进行异常的捕获，不然就无法通过编译.\",\"public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } \",\"当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\",\"public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } \",\"注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到\",\"public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\\\"捕获到异常\\\"); } } \",\"当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 但是要注意一下顺序 try {} catch { xxxException | xxxException e }{ }\",\"try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } // 可以简写为 try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } \"]},\"268\":{\"h\":\"断言表达式\",\"t\":[\"我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下。\",\"assert断言表达式，如果 assert 后面的表达式判断结果为 false，将抛出 AssertionError 错误。\",\"比如我们可以判断变量的值，如果大于10就抛出错误：\",\"public static void main(String[] args) { int a = 10; assert a > 10; } \"]},\"269\":{\"c\":[\"code\"]},\"270\":{\"c\":[\"java\"]},\"271\":{\"h\":\"Java - 工具类\"},\"272\":{\"h\":\"面向对象高级篇 6\",\"t\":[\"工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\"]},\"273\":{\"h\":\"常用工具类\"},\"274\":{\"h\":\"数学工具类\",\"t\":[\"Math类 是在 java.util 中，因此可以直接调用。\",\"public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } \",\"随机数生成 Random 类\",\"import java.util.Random; public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i < 30; i++) { System.out.print(random.nextInt(100)+\\\" \\\"); //nextInt方法可以指定创建0 - x之内的随机数 } } \"]},\"275\":{\"h\":\"数组工具类\",\"t\":[\"Arrays类 是在 java.util 中，因此可以直接调用。\",\"一些方法：Arrays.toString | Arrays.sort | Arrays.fill | Arrays.copyOfArrays.deepToString 可以对 多维数组 打印\",\"Arrays类 用于便捷操作数组，比如我们想要打印数组，可以直接通过 toString 方法转换字符串：\",\"public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } \"]},\"276\":{\"c\":[\"code\"]},\"277\":{\"c\":[\"java\"]},\"278\":{\"h\":\"Java - 泛型 1\"},\"279\":{\"h\":\"泛型 1\"},\"280\":{\"h\":\"使用泛型的原因\",\"t\":[\"为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个 Score 类呢？\",\"现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\",\"可以直接使用一个 Object 类进行存储成绩\",\"public class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } \",\"以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\",\"public static void main(String[] args) { Score score = new Score(\\\"数据结构与算法基础\\\", \\\"EP074512\\\", \\\"优秀\\\"); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } \",\"使用Object类型作为引用，对于使用者来说，由于是 Object 类型，所以说并不能直接判断存储的类型到底是 String 还是 Integer ，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\",\"所以说这种解决办法虽然可行，但并不是最好的方案。\",\"为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效 率。\"]},\"281\":{\"h\":\"泛型类\",\"t\":[\"泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\",\"我们可以将一个类定义为一个泛型类：\",\"public class Score<T> { //泛型类需要使用<>，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; } } \",\"具体使用:\",\"public static void main(String[] args) { Score<String> score = new Score<String>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); // 因为现在有了类型变量，在使用时同样需要跟上<>并在其中填写明确要使用的类型 // 这样我们就可以根据不同的类型进行选择了 // 这种形式也可以 Score<String> score = new Score<>(\\\"计算机网络\\\", \\\"EP074512\\\", \\\"优秀\\\"); String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value); } \",\"泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！\",\"因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用对象定义的泛型的\",\"我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个 Object 类型的变量，因为无论具体类型是什么，一定是 Object 类的子类。\",\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组.\",\"具体类型不同的泛型类变量，不能使用不同的变量进行接收 \",\"如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 ? 通配符 就好像默认其是 Object 类型\",\" public static void main(String[] args) { Test<?> test = new Test<Integer>(); test = new Test<String>(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成 Object } \",\"泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个 那么在使用时，就需要将这三种类型都进行明确指定\",\" public class Test<A, B, C> { //多个类型变量使用逗号隔开 public A a; public B b; public C c; } ------------------------------------- public static void main(String[] args) { Test<String, Integer, Character> test = new Test<>(); //使用钻石运算符可以省略其中的类型 test.a = \\\"lbwnb\\\"; test.b = 10; test.c = '淦'; } \",\"泛型只能确定为一个引用类型，基本类型是不支持的, 如果要存放基本数据类型的值，我们只能使用对应的包装类\",\"当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的\"]},\"282\":{\"h\":\"泛型和多态\",\"t\":[\"不只是类，包括接口、抽象类，都是可以支持泛型的：\",\"public interface Study<T> { T test(); } \",\"当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：\",\"public class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study<Integer> { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } } } \",\"或者是继续摆烂，依然使用泛型：\",\"public class Main { public static void main(String[] args) { A<String> a = new A<>(); String i = a.test(); } static class A<T> implements Study<T> { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } } } \",\"继承也是同样的：\",\"static class A<T> { } static class B extends A<String> { } \"]},\"283\":{\"c\":[\"code\"]},\"284\":{\"c\":[\"java\"]},\"285\":{\"h\":\"hint - List初始化\",\"t\":[\"带初始值的初始化\",\"如果是 java 9+, 可以直接使用 list.of\",\"List<String> list = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"); \",\"List<String> list = List.of( new Student(\\\"aaa\\\",1), new Student(\\\"bbb\\\",2), new Student(\\\"ccc\\\",3), ); \",\"这种方式创建的列表 不可修改，add() 和 remove() 都会抛出 UnsupportedOperationException。\",\"但如果是 java 8，就没有这个，可以使用 Stream\",\" List<Student> list1 = Stream.of( new Student(\\\"Alice\\\", 20), new Student(\\\"Bob\\\", 21), new Student(\\\"Charlie\\\", 22) ).collect(Collectors.toList()); \",\"特性\",\"List.of(...)\",\"Stream.of(...).collect(Collectors.toList())\",\"Java 版本要求\",\"Java 9 及以上\",\"Java 8 及以上\",\"是否可变\",\"❌ 不可变（immutable）\",\"✅ 可变（mutable）\",\"是否支持增删元素\",\"❌ 抛出 UnsupportedOperationException\",\"✅ 支持 .add() / .remove() 等操作\",\"是否允许包含 null\",\"❌ 不允许，包含会抛出 NullPointerException\",\"✅ 允许包含 null\",\"是否简洁\",\"✅ 更简洁\",\"较繁琐，但功能灵活\",\"实际返回的 List 类型\",\"通常为 ImmutableCollections.ListN\",\"通常为 ArrayList\"]},\"286\":{\"c\":[\"code\"]},\"287\":{\"c\":[\"java hint\"]},\"288\":{\"h\":\"Reinforcement Learning in Multiple-UAV Networks:Deployment and Movement Design\",\"t\":[\"2019 IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"289\":{\"h\":\"主要动机\",\"t\":[\"A novel framework is proposed for quality of experience driven deployment and dynamic movement of multiple unmanned aerial vehicles (UAVs).\",\"过去研究大多没有基于用户的移动(movement of users)来考虑无人机的机动性，更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署。\",\"考虑QoE, 而不是仅考虑吞吐量(throughput)，即需要考虑地面不同用户的具体需求。(QoE is invoked for demonstrating the users’ satisfaction, and it is supposed to be considered in UAV-assisted wireless networks)\",\"该文设计的是3D部署，过去研究主要考虑的是2D部署。\"]},\"290\":{\"h\":\"主要贡献\",\"t\":[\"提出了一个理想的由QoE驱动的多无人机协助通信框架。该框架将无人机部署在三维空间内，以 mean opinion score(MOS) 为指标。通过优化无人机的部署和动态移动来解决总用户MOS最大化问题。\",\"提出解决总用户MOS最大化问题的三步骤: \",\"通过GAK-mean算法获得初始单元划分。\",\"设计一种基于 q-learning 的部署方法，在初始时间假设用户处于静止下不断调整 UAVs 3D位置进行优化处理。\",\"设计一种基于 q-learning 的无人机3D动态运动设计算法。\",\"该文基于q-learning的方案来解决无人机的NP-hard 3D部署和移动问题，并与传统的基于遗传的学习算法进行对比。\",\"该文提出的算法具较快的收敛性，与K-means和IGK算法比具有较低的复杂度。\"]},\"291\":{\"h\":\"主要内容\"},\"292\":{\"h\":\"系统结构\"},\"293\":{\"h\":\"基本设置\",\"t\":[\"考虑无人机辅助无线网络的下行链路传输(down-link transmission)，即无人机作为空中基站。\",\"对于指定区域，会将其划分为N个簇，其中用户表示为K=K1​,…,KN​，其中KN​表示划分到集群N的用户，N∈1,2,…,N。\",\"每个用户只能属于一个集群，Kn​∩Kn′​=ϕ,n′=n,\",\"在任意时刻t，同一无人机通过FDMA同时为同一集群中的多个用户提供服务\",\"对于用户kn​∈Kn​，其坐标表示为wkn​​=[xkn​​(t),ykn​​(t)]T∈R2×1\",\"对于无人机n(飞行速度恒定)，其垂直高度表示为hn​(t)∈[hmin​,hmax​],0≤t≤Ts​，其水平坐标表示为qn​(t)=[xn​(t),yn​(t)]T∈R2×1,0≤t≤Ts​\",\"无人机n与用户kn​在时间t的距离表示为:\",\"dkn​​=hn2​(t)+[xn​(t)−xkn​​(t)]2+[yn​(t)−ykn​​(t)]2​\"]},\"294\":{\"h\":\"信号模型\",\"t\":[\"无人机往往有更高的LoS链接概率，该文中表示为:\",\"PLoS​(θkn​​)=b1​(π180​θkn​​−ζ)b2​PNLoS​=1−PLoS​\",\"其中θkn​​(t)=sin−1[dkn​(t)​hn​(t)​]，表示无人机与用户之间的仰角。b1​,b2​,ζ是由环境决定的常数。在实际应用中，为了在LoS信道概率和路径损耗之间取得平衡，需要合理选择无人机n的垂直高度hn​(t)。\",\"在时间t，从无人机n到用户kn​的信道功率增益(the channel power gain)为:\",\"gkn​​(t)=K0​−1dkn​​−α[t](PLos​μLoS​+PNLos​μNLoS​)−1\",\"其中K0​=(c4πfc​​)2，α是表示路径损耗指数(常数)，μLoS​,μNLoS​是表示LoS和NLoS链路的衰减因子，fc​是载波频率，c是光速。\",\"对于无人机n，其可用带宽为Bn​，将其平均分配给其∣Kn​∣个关联用户，其每个用户带宽表示为: Bkn​​=Bn​/Kn​. 该文中不同集群所利用的频谱是不同的，且无人机向关联用户的发射功率是恒定的。 同样，对于无人机的总发射功率也均匀地分配给每个用户，pkn​​=Pmax​/Kn​\",\"由于不同集群的频谱不同，可以减轻无人机对用户接收到的干扰。因此，在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为:\",\"Γkn​​(t)=σ2pkn​​gkn​​(t)​\",\"其中σ2=Bkn​​N0​, N0​为用户所在位置的加性高斯白噪声(AWGN)的功率谱密度。\",\"为了满足不同用户传输速率要求，对于用户kn​存在特定的信噪比目标γkn​​, 即Γ≥γkn​​.\",\"由此，存在Lemma1： 为了保证所有用户都能连接到网络，我们对无人机的发射功率有一个约束，可以表示为\",\"Pmax​≥γσ2K0​dkn​​α(t)μNLoS​\",\"根据香农定理: 信道容量C=B∗log(1+NS​)，且传输率永远都不可能超过信道容量C。 因此对于用户kn​的在时刻t的传输速率rkn​​(t)，表示为rkn​​(t)=Bkn​​log2​[1+σ2pkn​​gkn​​(t)​].\",\"Proposition1: 无人机n的高度需满足:\",\"dkn​​(t)sin[180π​(ζ+eM(t))]≤hn​(t)≤(γK0​σ2μLoS​Pmax​​)\",\"其中\",\"M(t)=b2​ln(b1​(μLoS​−μNLoS​)S(t)​−μLoS​−μNLoS​μNLoS​​​S(t)=γK0​σ2dkn​​α(t)Pm​ax​\",\"Proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件。 可知，其高度的下界是距离dkn​​(t)的函数；高度的上界是最大发射功率Pmax​的函数。 因此，随着无人机与用户之间距离和发射功率的变化，需要调整相应无人机的高度，以向用户提供可靠的服务。\"]},\"295\":{\"h\":\"Quality-of-Experience Model\",\"t\":[\"由于不同用户对于传输速率的需求是不同的，所以在无人机辅助通信网络中我们需要考虑QoE模型。\",\"在该文中，采用MOS作为用户QoS衡量的标准，具体如下:\",\"MOSkn​​(t)=ζ1​MOSkn​​delay(t)+ζ2​MOSkn​​rate(t)\",\"其中，ζ1​,ζ2​是系数，且ζ1​+ζ2​=1。\",\"根据MOS数值，共划分5个等级: excellent(4.5) very good(2~3.5) fair(1~2) poor(1)。\",\"在该文中考虑的是网页浏览应用传输情况，因此MOSkn​​delay(t)可以忽略，因此，此时的MOS模型定义如下:\",\"MOSkn​​(t)=−C1​ln[d(rkn​​(t))]+C2​\",\"d(rkn​​(t))是与传输速率有关的延迟时间，MOSkn​​(t)为t时刻的MOS评分，取值范围从1−4.5。C1​和C2​是通过分析web浏览应用程序的实验结果确定的常数，分别设为1.120和4.6746。\",\"d(rkn​​(t))=3RTT+rkn​​(t)FS​+L(rkn​​MSS​)+RTT−rkn​​(t)2MSS(2L−1)​\",\"其中，RTT[s]表示round trip time(数据包从发送端-接收端-发送端的时间)，FS[bit]是网页大小，MSS[bit]是最大报文长度，L=min[L1​,L2​]表示 the number of slow start cycles with idle periods。\",\"L1​=log2​(MSSrkn​​RTT​+1)−1,L2​=log2​(2MSSFS​+1)−1.\",\"用户rkn​​在一段时间Ts​内的MOS总和为:\",\"MOSrkn​​​=t=0∑Ts​​MOSkn​​(t)\"]},\"296\":{\"h\":\"优化问题建立\",\"t\":[\"假设功率Q=qn​(t),0≤t≤Ts​, 高度H=hn​(t),0≤t≤Ts​\",\"本文目的是优化无人机在每个时隙的位置，从而最大化所有用户的总MOS值。具体表述如下:\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​∑t=0Ts​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"该优化问题是一个non-convex问题，因为目标函数对于无人机的3D坐标是非凸的。\",\"总用户的MOS取决于无人机的发射功率、数量和位置(水平位置和高度)。\"]},\"297\":{\"h\":\"解决方案\"},\"298\":{\"h\":\"无人机的3D部署\",\"t\":[\"考虑以下场景，将上述优化问题简化:\",\"无人机n以可变高度悬停在用户上方，用户是保持静态的。 每架无人机的带宽和发射功率都均匀分配给每个用户。 因此我们将优化问题简化为区域分割问题。\",\"描述如下: 但即使仅考虑用户聚类，该问题依然是NP-hard问题\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"无人机-用户关联策略(用户区域划分算法)\",\"采用基于遗传算法的GAK-means算法 由于特定用户的MOS与该用户与无人机之间的距离有关，因此GAK-means可以视为获得无人机部署的低复杂度方案。\",\"根据N个用户，根据遗传算法找到CN​个最优个体作为簇的中心。\",\"将无人机部署在每个中心内，再将用户划分给距离最近的无人机\",\"重复步骤，再找到新的簇的各中心，再根据欧几里得距离重新划分，直到各个簇的成员没有太大变化，划分完毕。\",\"无人机3D部署算法\",\"根据所给定的用户划分情况，目标是获得无人机的最佳3D位置，来最大化MOS总和。 由于GAK-means的优化目标是最小化无人机与对应集群用户的欧氏距离，MOS主要是有关传输速率rkn​​的函数，因此MOS不仅与欧氏距离有关，还与LoS的概率有关。\",\"采用Q-learning算法\",\"智能体(agent): UAVn,n∈N={1,2,…,N}\",\"状态(state): 对于每个智能体，其状态为其3D坐标，定义为ξ=(xUAV​,yUAV​,hUAV​)\",\"状态空间(state space S): 这里采用离散化空间坐标，即xUAV​:{0,1,…,Xd​},yUAV​:0,1,…,Yd​,hUAV​:{hmin​,…,hmax​}，所以状态其实共有(XD​+1)×(Yd​+1)×(hmax​−hmin​+1)个\",\"动作空间(action space): 每次无人机会根据当前状态st​∈S，按照所给定策略J来执行一个动作at​∈A从而获得奖励rt​以及下一个状态st+1​ 该论文中在精度和模型复杂型上作出平衡，共考虑7个方向。 (1,0,0)：右转 (−1,0,0)：左转 (0,1,0)：前进 (0,−1,0)：后退 (0,0,1)：上行 (0,0,−1)：下行 (0,0,0)：静止\",\"状态转换模型: 当执行动作at​时，从状态st​到st+1​，并获得奖励rt​的这一过程可以用条件转移概率p(st+1​,rt​∣st​,at​)来表示。 Q-learning的优化目标是最大化长期收益\",\"Gt​=E[n=0∑∞​βnrt+n​]\",\"奖励(reward): 如果agent在当前时刻t所执行的动作能够提高总MOS，则无人机将获得正奖励。否则，agent将获得负奖励。\",\"xt​=⎩⎨⎧​1,−0.1,−1,​ifMOSnew​>MOSold​ifMOSnew​=MOSold​ifMOSnew​<MOSold​​\",\"具体代码：（策略为贪心策略）\",\"算法1\",\"个人理解：\",\"通过K-means来划分各个无人机所管理的用户簇。无人机的位置初始化也是随机部署的\",\"但每个无人机所管理的用户不同，其目标也应该不一样，不能用同一个Q-table管理，这里是每个无人机都有一张自己的Q-table，来进行迭代？ 还是同一张Q-table，只不过根据区域划分，不同的无人机agent的Q(s,a)的s是有范围的？(个人感觉是这个)\",\"最终输出的结果，应该是无人机最终停的位置即是部署的最佳位置(因为q-learning是优化长期目标)，发现在该位置静止是最优的，表示是最佳部署位置。\",\"最终输出结果，是根据Q-table来找出对应q(s,a)当a为静止时，最大的q(s,a)值，对应s就是UAV的部署位置\"]},\"299\":{\"h\":\"无人机的动态移动设计\",\"t\":[\"考虑用户在每个时隙移动的情况，由于用户在每个时隙都处于漫游状态，因此随着用户位置的变化，每个集群中无人机的最优位置也会发生变化，无人机需要进行移动。\",\"在本文中不考虑用户移动到其他集群的情况 因为在不考虑用户自由穿梭集群的情况，对于动作空间而言，仅需要考虑无人机的7个移动方向即可；但若考虑集群情况，动作空间包含两个部分：选择移动方向和选择关联用户。设无人机总数为N，∣Kn​∣为第n个簇的用户总数，则用户的关联动作数为2N∑n=1N​∣Kn​∣，∑n=1N​∣Kn​∣是总用户数，每个用户都需要判断是否与每个无人机关联，因此是2N 则总动作空间的大小为7+2N∑n=1N​∣Kn​∣会导致动作空间过大，Q-table过大。\",\"1.用户漫游模型 在设计无人机的移动之前，需考虑用户的移动性，这里有多种mobility modles可选择，如a deterministic approach, a hybrid approach, and a random walk model. 在本文中，采用的是the random walk model(Markovian mobility model) 每个用户的移动方向均匀分布在左、右、前、后四个方向。 用户的速度设为[0,cmax​]，其中cmax​表示用户的最大速度。\",\"2.基于q-learning的移动算法 与基于q-learning的部署算法不同的是，在此情况下，状态除了要考虑无人机的3D位置外，还需要考虑所有用户的2D位置。即ξ={xUAV​,yUAV​,hUAV​,xuser​,yuser​}(xuser​,yuser​)由用户的初始位置和运动模型决定，(xUAV​,yUAV​,hUAV​)由无人机的位置和它们在最后时隙采取的动作决定.\",\"训练阶段: \",\"测试阶段:\\n\"]},\"300\":{\"c\":[\"academic\"]},\"301\":{\"c\":[\"UAV\",\"IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"302\":{\"h\":\"RL1 - 基本概念\"},\"303\":{\"h\":\"强化学习框架图\",\"t\":[\"主要框架\"]},\"304\":{\"h\":\"1. 基本概念\",\"t\":[\"State(状态)：The status of the agent with respect to the environment.\",\"State Space(状态空间): 所有状态的集合。S={si​}i=1n​。\",\"Action(动作): 对于每一个状态，都有可选择的动作。\",\"Action space of a state: 对应状态中所有可选择的动作集合。A(si​)={ai​}i=1n​\",\"State transition(状态转换): s1​→a1​s2​。定义了agent与环境的交互行为。\",\"State transition probability: p(s2​∣s1​,a1​)，即状态s1​采用动作a1​转到状态s2​的概率。\",\"Policy π: 指导agent在当前状态下选择哪个动作。\",\"Reward(奖励): 在执行一个动作后获得的一个常数(依赖于当前状态和所采取的动作)。同样可以用条件概率的形式进行描述，如p(r=1∣s1​,a1​)，即在状态s1​下采用动作a1​获得的奖励r=1的概率。\",\"Trajectory：a state-action-reward chain.(可以有限，也可以是无限长的trajectory) s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​. 个人理解，trajectory是在策略给定下，agent可能走出的全部轨迹，并非只是一个单一的轨迹。\",\"Return of a trajectory：将对应的轨迹所获得的所有reward的总和，可以粗步衡量一个策略的好坏。\",\"Discounted return(of a trajectory)：为了应对具有无限步的trajectory的return=∞的情况。 s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​…. 此时该trajectory的return=0+0+0+1+1+⋯=∞。 引入discount rate, γ∈[0,1). 此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​ 显然，如果γ接近0，即此时的discounted return越短视，注重近期的reward；γ接近1，更远视，更注重长远的reward。\",\"Episode(trial)：When interacting with the environment following a policy, the agent may stop at some terminal states. The resulting trajectory is called an episode(or a trial)/ 即表示具有终止状态terminal states的trajectory，通常是具有有限步长的trajectory. 同理，这样的任务称为episodic tasks。\",\"continuing tasks：即不具备terminal states的任务，会与环境一直交互下去。 可以通过设置将episodic tasks转换成continuing tasks，如可以在target states中限制action space，控制其一直待在target states中。 Deterministic — Stochastic\"]},\"305\":{\"h\":\"2.Markov decision process(MDP)\",\"t\":[\"关键元素：\",\"Sets： \",\"State：the set of states S\",\"Action：the set of actions A(s) is associate for state s∈S\",\"Reward：the set of rewards R(s,a).\",\"Probability distribution： \",\"State transition probability p(s′∣s,a): 表示在状态s下采取动作a，转换到状态s′的概率。\",\"Reward probability p(r∣s,a): 表示在状态s下采取动作a，获得reward r 的概率。\",\"Policy：at state s, the probability to choose action a is π(a∣s). 表示在各状态执行各动作的概率。\",\"Markov property：即无记忆的特性。 p(st+1​∣at+1​,st​,…,a1​,s0​)=p(st+1​∣at+1​,st​)r(st+1​∣at+1​,st​,…,a1​,s0​)=p(rt+1​∣at+1​,st​)\",\"Markov process：在policy是确定的情况下，MDP就变为MP。\"]},\"306\":{\"c\":[\"academic\"]},\"307\":{\"c\":[\"强化学习\"]},\"308\":{\"h\":\"RL10 - Actor-Critic 方法\",\"t\":[\"actor: 对应 policy update\",\"critic: 对应 policy evaluation 或者 value evaluation\",\"20240830184236\",\"显然，是在基于 策略梯度上升 算法的基础上，将对于 Q 值的估计通过一个网络来进行描述，这个便成为 critic, 而对应的策略梯度上升算法就是对应 actor。\",\"20240830184312\"]},\"309\":{\"h\":\"1. The simplest actor-critic (QAC)\",\"t\":[\"20240830184330\",\"20240830184424\"]},\"310\":{\"h\":\"2. Advantage actor-critic (A2C)\",\"t\":[\"核心思想：在 QAC 的基础上来引入偏置量(baseline)，从而减小方差，提升采样的效率。\"]},\"311\":{\"h\":\"2.1 baseline\",\"t\":[\"在策略梯度算法中引入一个 baseline, 不会影响所求的梯度。 即:\",\"▽θ​J(θ)​=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)]=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)−b(S)]​\",\"证明: 要证明加入baseline成立，只需要保证:\",\"ES∼η,A∼π​[▽θ​ln(A∣S,θ)b(S)]=0\",\"20240830185127\",\"作用:\",\"因此，我们需要找到一个 baseline 来保证这个梯度的方差最小即可。\"]},\"312\":{\"h\":\"2.2 最好的 baseline\",\"t\":[\"20240830185324\",\"在实际情况中，我们通常将 baseline 设置为 vπ​(s)\"]},\"313\":{\"h\":\"2.3 对应算法\",\"t\":[\"20240830185537\",\"20240830185556\",\"20240830185629\"]},\"314\":{\"h\":\"3. off-policy actor-critic\",\"t\":[\"通过 重要性采样 的方法，将处于 另一分布下 的策略所采集的数据来 运用到 策略更新 中。\"]},\"315\":{\"h\":\"3.1 重要性采样 (Importance sampling)\",\"t\":[\"20240830200056\",\"20240830200118\",\"20240830200138\"]},\"316\":{\"h\":\"3.2 off-policy\",\"t\":[\"20240830200248\",\"20240830200305\",\"20240830200320\",\"20240830200343\"]},\"317\":{\"h\":\"3.3 伪代码\",\"t\":[\"20240830200406\"]},\"318\":{\"h\":\"4. Deterministic actor-critic (DPG)\",\"t\":[\"1234\",\"20240830200608\",\"20240830200624\"]},\"319\":{\"c\":[\"academic\"]},\"320\":{\"c\":[\"强化学习\"]},\"321\":{\"h\":\"RL2 - 贝尔曼公式\"},\"322\":{\"h\":\"核心内容\",\"t\":[\"state value\",\"the Bellman equation\"]},\"323\":{\"h\":\"1.State value\"},\"324\":{\"h\":\"1.1\",\"t\":[\"引入随机变量后对应的discounted return的描述。 即一个trajectory下的discounted return。 由此可以推导出一个多步的trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的discounted return为：Gt​=Rt+1​+γRt+2​+γ2Rt+3​+…\",\"γ 为discounted rate\",\"Gt​也是一个随机变量\"]},\"325\":{\"h\":\"1.2 State value\",\"t\":[\"State value 是 Gt​ 的期望, 也称为 state value function 表示为 The expection(expected value or mean) of Gt​:\",\"vπ​(s)=E[Gt​∣St​=s]\",\"是一个有关状态s的函数.\",\"vπ​(s) 是基于一个给定策略 π , 对于不同的策略，所得到的 state value 是不同的.\",\"state value 可以用来衡量一个状态的价值.\"]},\"326\":{\"h\":\"1.3 State value 与 return 的区别\",\"t\":[\"Return 是针对一条trajectory所求的，而 State value 则是对多个 trajectory 求 return 再求平均值。 The state value is the mean of all possible returns that can be obtained starting from a state. 只有当所有东西都是确定性的(π(a∣s),p(r∣s,a),p(s′∣s,a))，state value 与 return 是一致的.\"]},\"327\":{\"h\":\"2. Bellman equation\",\"t\":[\"用来描述所有状态的state value的关系. 根据一个 random trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的 discounted return Gt​ 为:\",\"Gt​​=Rt+1​+γRt+2​+γ2Rt+3​+…=Rt+1​+γ(Rt+2​+γRt+3​+…)=Rt+1​+γGt+1​​\",\"因此，对应的 state value 为:\",\"vπ​(s)​=E[Gt​∣St​=s]=E[Rt+1​+γGt+1​∣St​=s]=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s]​\",\"需要推导E[Rt+1​∣St​=s]和E[Gt+1​∣St​=s]的计算即可。\"]},\"328\":{\"h\":\"2.1 The mean of immediate rewards:\",\"t\":[\"E[Rt+1​∣St​=s]​=a∑​π(a∣s)E[Rt+1​∣St​=s,At​=a]=a∑​π(a∣s)r∑​p(r∣s,a)r​\"]},\"329\":{\"h\":\"2.2 The mean of future rewards:\",\"t\":[\"E[Gt+1​∣St​=s]​=s′∑​E[Gt+1​∣St​=s,St+1​=s′]=s′∑​E[Gt+1​∣St+1​=s′](无记忆性)=s′∑​vπ​(s′)p(s′∣s)=s′∑​vπ​(s′)a∑​p(s′∣s,a)π(a∣s)​\",\"个人推导：\",\"E[Gt+1​∣St​=s]​=a∑​π(a∣s)E[Gt+1​∣St​=s,At​=a]=a∑​π(a∣s)s′∑​E[Gt+1​∣St​=s,At​=a,St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)E[Gt+1​∣St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​\"]},\"330\":{\"h\":\"2.3 Bellman equation\",\"t\":[\"vπ​(s)​=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s],=mean of immediate rewards a∑​π(a∣s)r∑​p(r∣s,a)r​​+mean of future rewards γa∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​​,=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)],∀s∈S.​\",\"该式子针对状态空间中的所有状态均成立.\",\"通过 Bootstrapping , 可以求解 state value.\",\"π(a∣s) 表示一个给定的策略. 求解Bellman equation 称为策略评估(Policy evaluation).\",\"p(r∣s,a),p(s′∣s,a) 是由环境决定的(dynamic model|environment model). 后续可能是未知的(model-free)，需要通过采样解决.\"]},\"331\":{\"h\":\"2.4 Bellman equation (Matrix-vector form)\",\"t\":[\" 此时,对于所有状态s，对应的 Bellman equation 为\",\"vπ​(s)=rπ​(s)+γs′∑​pπ​(s′∣s)vπ​(s′)​\",\"将所有状态的 Bellman equation 整合，重新修改为 matrix-vector form.\",\"vπ​=rπ​+γPπ​vπ​​\",\"其中,\",\"vπ​=[vπ​(s1​),…,vπ​(sn​)]T∈Rn\",\"rπ​=[rπ​(s1​),…,rπ​(sn​)]T∈Rn\",\"Pπ​∈Rn×n, where [Pπ​]ij​=pπ​(sj​∣si​), 表示状态转移矩阵.\"]},\"332\":{\"h\":\"3. Why to slove state value\",\"t\":[\"为了进行 Policy evaluation, 即对于给定策略，求出其对应状态的 state value 的过程。\",\"通过 Bellman euqation 进行求解。\",\"The closed-form solution(不常用):\",\"vπ​=(I−γpπ​)−1rπ​​\",\"An iterative solution(一种迭代策略):\",\"vk+1​=rπ​+γPπ​vk​​\",\"可以最开始均初始化为 0 , 然后进行不断迭代，可以得到一个序列v0​,v1​,v2​,…. 最终可以证明：vk​→vπ​=(I−γpπ​)−1rπ​,k→∞\"]},\"333\":{\"h\":\"4. Action value\",\"t\":[\"State value: agent从一个状态出发可以得到的平均return. the average return the agent can get starting from a state\",\"Action value: agent从一个状态出发，采取一个指定的action可以得到的平均return。 the average return the agent can get starting from a state and taking an action.\",\"通过求解 action value 我们可以分析出在该状态下采取哪个 action 收益最大. Action value 定义:\",\"qπ​(s,a)=E[Gt​∣St​=s,At​=a]​\",\"同样地，qπ​(s,a)是依赖于策略π的，并且与状态 s 和动作 a 有关.\",\"vπ​(s)E[Gt​∣St​=s]​​=a∑​qπ​(s,a)E[Gt​∣St​=s,At​=a]​​π(a∣s)\",\"因此，vπ​(s)=∑a​qπ​(s,a)π(a∣s) 由于,\",\"vπ​(s)=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)]​\",\"所以，qπ​(s,a)=∑r​p(r∣s,a)r+γ∑s′​p(s′∣s,a)vπ​(s′)\",\"实际意义是：在当前状态s下采取动作 a 所获得的均值，加上 γ 的转到下一个状态的 state value 加权均值。\",\"引入 action value 后，对于 state value 实际意义的解释：在当前状态s下，根据策略π, 所有可能动作的 action value 的加权均值。\",\"state value 和 action value 可以互相转化。\"]},\"334\":{\"h\":\"5. 总结\",\"t\":[\"State value: vπ​(s)=E[Gt​∣St​=s]\",\"Action value: qπ​(s,a)=E[Gt​∣St​=s,At​=a]\",\"State value 是 action value 的根据策略π加权平均，即vπ​(s)=∑a​π(a∣s)q(s,a)\",\"The Bellman equation (elementwise form and matrix-vector form)\",\"求解 the Bellman equation (2种方法)\"]},\"335\":{\"c\":[\"academic\"]},\"336\":{\"c\":[\"强化学习\"]},\"337\":{\"h\":\"RL3 - 贝尔曼最优公式\",\"t\":[\"Core concepts: optimal state value and optimal policy\",\"A fundamental tool: the Bellman optimality equation (BOE)\"]},\"338\":{\"h\":\"1. Optimal policy\",\"t\":[\"最优策略的定义: A policy π∗ is optimal if π∗(s)≥vπ​(s) for all s and for any other policy π. 需要确定几件事:\",\"最优策略是否存在 存在，根据 the contraction mapping Theorem.\",\"最优策略是否唯一 唯一，根据 the contraction mapping Theorem.\",\"最优策略是 stochastic 还是 deterministic deterministic 且 greedy\",\"如何得到最优策略 选取状态中最大的 action value 作为下一步的 action\"]},\"339\":{\"h\":\"2. Bellman optimality equation (BOE)\"},\"340\":{\"h\":\"2.1 基本形式\",\"t\":[\"对于贝尔曼最优公式而言，其策略π表示的是最优策略，除了需要求解 state value 外，还需要求解最优策略π.elementwise form:\",\"vπ​(s)​=πmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)),∀s∈S=πmax​a∑​π(a∣s)q(a,s),∀s∈S​\",\"matrix-vector foem:\",\"v=πmax​(rπ​+γPπ​v)​\"]},\"341\":{\"h\":\"2.2 如何求解\",\"t\":[\"对于贝尔曼最优公式而言，区别于贝尔曼公式，只是求解各状态的 state value, 我们还需要理解其所描述的最优策略π∗ 具体分两步:\"]},\"342\":{\"h\":\"2.2.1 如何处理等式右边的 (最优策略)\",\"t\":[\"vπ​(s)=maxπ​∑a​π(a∣s)q(s,a), 为了让右边取到最大值的情况，我们只需要在当前状态下，保证选取最大的 action value 即可，对应策略表示为:\",\"π(a∣s)={10​a=a∗a=a∗​\",\"其中a∗表示在该状态下计算出来的最大 action value 对应的动作，即a∗=argmaxa​q(s∣a)\"]},\"343\":{\"h\":\"2. 求解 state value\",\"t\":[\"将 BOE 转换为 v=f(v) 的形式，其中f(v):=maxπ​(rπ​+γPπ​v)f(v)对应一个向量, [f(v)]s​=maxπ​∑a​π(a∣s)q(s∣a),∀s∈S\",\"求解方法：\",\"Fix point: f(x)=x\",\"Contraction mapping(contractive function): ∣∣f(x1​)−f(x2​)∣∣≤γ∣∣x1​−x2​∣∣\",\"由此可以根据Contraction Mapping Theorem: For any equation that has the form of x=f(x), if f is a contraction mapping, then\",\"Existence: 存在不动点x∗，满足f(x∗)=x∗\",\"Uniqueness: 不动点x∗是唯一的\",\"Algorithm: Consider a sequence xk​ where xk+1​=f(xk​), then xk​→x∗ as k→∞. Moreover, the convergence rate is exponentially fast.\",\"因此，可以通过Contraction Mapping Theorem来求解贝尔曼最优公式，因为其满足该理论，即f(v)是一个contraction mapping。\"]},\"344\":{\"c\":[\"academic\"]},\"345\":{\"c\":[\"强化学习\"]},\"346\":{\"h\":\"RL4 - 值迭代和策略迭代(动态规划)\",\"t\":[\"贝尔曼最优公式:\",\"v=f(v)=πmax​(rπ​+γPπ​v)\"]},\"347\":{\"h\":\"1. Value iteration algorithm\",\"t\":[\"根据 chapter 3 中涉及的 contraction mapping theorem, 我们可以通过对应的迭代算法来求解贝尔曼最优公式\",\"vk+1​=f(vk​)=πmax​(rπ​+γPπ​vk​),k=1,2,3…\",\"这种迭代算法称为 value iteration.\"]},\"348\":{\"h\":\"1.1 具体步骤\",\"t\":[\"共分为 2 步：\",\"Policy update 这步是更新策略π，即求解右边的式子，πk+1​=argmaxπ​(rπ​+γPπ​vk​), 其中vk​是给定的。 其对应的 elementwise form:\",\"πk+1​(s)=πargmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)v(s′)),s∈S 由于 p(s′∣s,a),p(r∣s,a),v(s′) 是已知的，显然，这里的最优策略πk+1​是一个 greedy policy，我们只需要挑选在当前迭代下最大的 action value 就好了, 即:\",\"πk+1​(a∣s)={10​a=ak∗​(s)a=ak∗​(s)​ 其中ak∗​(s)=argmaxa​qk​(a,s).\",\"value update 根据 Policy update 的策略πk+1​, 求解下一步的vk+1​, 即\",\"vk+1​=rπk+1​​+γPπk+1​​vk​这里的vk​并不是 state value 由于πk+1​是 greedy 的，对应的vk+1​(s)=maxa​qk​(a,s)\"]},\"349\":{\"h\":\"1.2 伪代码\",\"t\":[\"20240810190018\"]},\"350\":{\"h\":\"2. Policy iteration algorithm\",\"t\":[\"算法迭代示意图:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\"]},\"351\":{\"h\":\"2.1 算法描述\",\"t\":[\"首先随机设计一个初始的策略π0​\",\"Step 1: policy evaluation (PE) 策略评估 该步骤是用来计算当前策略 πk​ 的 state value. 可以通过 Bellman equation 进行求解，即:\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"根据对应的 Elementwise form:\",\"vπk​(j+1)​(s)=a∑​πk​(a∣s)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​(j)​(s′)),s∈S\",\"由此进行迭代，直到设置的收敛条件为止，即j→∞ 或者 ∣∣vπk+1​(j+1)​(s)−vπk​(j)​(s)∣∣≤δ.\",\"Step 2: policy improvement (PI) 策略提升 该步骤是根据 PE 所求出的 state value, 根据 action value，来提升当前策略 πk​\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"对应的 Elementwise form:\",\"πk+1​(s)=πargmax​a∑​πk​(a∣s)qπk​​(s,a)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​​(s′))​​,s∈S\",\"这里，显然是可以通过一个 greedy 的策略来进行选择，即:\",\"πk+1​(a∣s)={10​a=ak∗​(s),a=ak∗​(s).​\",\"其中 aK∗​(s)=argmaxa​qπk​​(s,a).\"]},\"352\":{\"h\":\"2.2 伪代码\",\"t\":[\"20240811002219\"]},\"353\":{\"h\":\"2.3 一些问题\",\"t\":[\"在 PE 步骤中，如何通过 Bellman equation 得到 state value vπk​​. 根据 chapter 2 中求解 Bellman equation 的方法 一种是可以直接通过矩阵求逆进行求解，即 vπk​​=(I−γPπk​​)−1rπk​​，实际不常用. 一种是通过迭代算法来求解\",\"vπk​(j+1)​=rπk​​+γPπk​​vπk​(j)​\",\"在 PI 步骤中，如何确保策略 πk+1​ 是优于 πk​的.\",\"为什么这个迭代算法最终可以找到最优策略 每次迭代都会使得策略进行提升，那么\",\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",\"我们需要保证策略是不断提升，且最终会收敛到最优策略v∗\",\"policy iteration algorithm 与 value iteration algorithm 之间存在什么关系.\"]},\"354\":{\"h\":\"3. Truncated policy iteration algorithm\",\"t\":[\"该算法是 value iteration 以及 policy iteration 一般化的推广\"]},\"355\":{\"h\":\"3.1 value iteration 与 policy iteration 算法比较\",\"t\":[\"Policy iteration: 需要初始化策略π0​, 之后进行迭代\",\"Policy evaluation (PE): 通过 Bellman equation 求解当前策略的 state value.\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"内嵌迭代算法求解.\",\"Policy improvement (PI): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"Value iteration: 需要初始化猜测的 state value v0​\",\"Policy update (PU): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vk​)\",\"Value update (VU): 进行迭代\",\"vk+1​=rπk+1​​+γPπk+1​​vk​\",\"两个算法迭代过程十分类似: Policy iteration:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\",\"Value iteration:\",\"u0​PU​π1′​VU​u1​PU​π2′​VU​u2​PU​…\",\"Policy iteration algorithm\",\"Value iteration algorithm\",\"Comments\",\"1) Policy:\",\"π0​\",\"N/A\",\"2) Value:\",\"vπ0​​=rπ0​​+γPπ0​​vπ0​​\",\"v0​:=vπ0​​\",\"对于 policy iteration，vπ0​​是通过迭代算法来求的; 而 value iteration 我们这里强行初始化为vπ0​​，方便后续比较\",\"3) Policy:\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"在策略更新上，这两个算法是一致的。\",\"4) Value:\",\"vπ1​​=rπ1​​+γPπ1​​vπ1​​\",\"v1​=rπ1​​+γPπ1​​v0​\",\"对于 Policy iteration 而言, 这里需要通过迭代算法来精确求出 vπ1​​; 对于 Value iteration，则只是进行一次带入求解。\",\"5) Policy:\",\"π2​=argmaxπ​(rπ​+γPπ​vπ1​​)\",\"π2′​=argmaxπ​(rπ​+γPπ​v1​)\",\"⋮\",\"⋮\",\"⋮\",\"⋮\"]},\"356\":{\"h\":\"3.2 Truncated policy iteration algorithm\",\"t\":[\"20240811010933\",\"显然，在求解 Bellman equation 中，Value iteration 只是进行了一步求解，而 Policy iteration 进行了无穷多步来进行了真实的求解 state value，显然在现实运行算法中是无法做到的。 因此 Truncated policy iteration algorithm 就是进行迭代 n 步来求解。\"]},\"357\":{\"h\":\"truncated policy iteration algorithm 是否是收敛的\",\"t\":[\"20240811011334\"]},\"358\":{\"c\":[\"academic\"]},\"359\":{\"c\":[\"强化学习\"]},\"360\":{\"h\":\"RL5 - 蒙特卡洛方法 (Monte Carlo) model-free\",\"t\":[\"如何在没有模型 (即p(r∣s,a),p(s′∣s,a)等均未知) 的情况下进行估计 通过 Monte Carlo estimation. 其核心思想是： 若有一系列(i.i.d)样本采样，得到一个样本序列x1​,x2​,…,xN​ 那么对于随机变量X的估计可以为：\",\"E[x]≈xˉ=N1​j=1∑N​xj​\",\"该方法成立的数学依据是 大数定理 (Law of Large Numbers)样本必须是独立同分布(iid, independent and identically distributed)\",\"为什么考虑 mean estimation. 因为无论是 state value 还是 action value 其原始定义都是从期望出发的。\",\"vπ​(s)=E[Gt​∣St​=s];qπ​(s,a)=E[Gt​∣St​=s,At​=a]\"]},\"361\":{\"h\":\"1. MC Basic\",\"t\":[\"最简单的示例算法，用于解释 MC 的原理，但现实场景中不太经常使用，效率过低。\",\"核心思想：如何将 Policy iteration algorithm 转换为 model-free 的情况。\"]},\"362\":{\"h\":\"1.1 算法思路\",\"t\":[\"Policy iteration 算法的核心是 先根据当前策略计算出各个状态的 state value， 再将 state value 转换为 action value，更新策略的步骤就是选择此时 action value 最大的 action.\",\"{Policyevaluation:vπk​​=rπk​​+γPπk​​vπk​​Policyimprovement:πk+1​=argmaxπ​(rπ​+γPπ​vπk​​)​\",\"显然其核心关键就是在 PE 中 通过迭代算法求解 Bellman equation 的 state value后：\",\"对于 model-based 的情况, 因为 p(r∣s,a),p(s′∣s,a) 已知，我们可以很轻松的求出各个情况下的q(s,a)，从而选择每个状态下最大的 action value 即可。\",\"qπk​​(s,a)=r∑​p(r∣s,a)+γs′∑​p(s′∣s,a)vπk​​(s)\",\"对于 model-free 的情况，此时 p(r∣s,a),p(s′∣s,a) 未知，我们不能通过之前的方法来求出q(s,a)，需要从 action value 的定义出发，即：\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]\",\"从此可以发现，我们可以通过前面所引入的 mean estimation 方法，来进行求解 q(s,a).\"]},\"363\":{\"h\":\"1.2 如何估计\",\"t\":[\"从指定的 (s,a) 出发，根据策略 πk​, 我们可以生成一个 episode.\",\"这个 episode 的 return 为 g(s,a).\",\"显然，g(s,a) 就是前面 Gt​ 的一个 sample.\",\"假设我们有了一系列 从状态 s 出发, 采取动作 a 的 episodes, 即 g(j)(s,a). 那么我们可以对 qπk​​(s,a) 进行估计，即\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]≈N1​i=1∑N​g(i)(s,a).\"]},\"364\":{\"h\":\"1.3 具体算法\",\"t\":[\"与 Policy iteration algorithm 步骤类似 首先初始化一个随机的策略π0​，然后进行迭代，对于 kth 迭代，有：\",\"Step 1: Policy evaluation. 求在策略πk​下所有的 action value, q(s,a). 具体求解方法，如 1.2 节所述，只不过我们此时需要遍历所有的 action-state pair. 为什么不去求 state value，因为最终策略更新的核心仍然是 action value, 即使先估计了 state value, 我们仍需要估计 action value.\",\"Step 2: Policy improvement. 这是来求解 πk+1​(s)=argmaxπ​∑a​π(a∣s)qπk​​(s,a),foralls∈S 这个仍然与之前一致，采用 greedy policy，即对于每个状态，我们选取其 action value 最大的 action.πk+1​(ak∗​∣s)=1，其中ak∗​=argmaxa​qπk​​(s,a)\",\"20240811233346\"]},\"365\":{\"h\":\"2. MC Exploring Starts\",\"t\":[\"MC Exploring Starts 是针对 MC Basic 的一些改进，即对于数据(experience)更加高效利用。\"]},\"366\":{\"h\":\"2.1 Episode 的高效利用\",\"t\":[\"Visit: every time a state-action pair appears in the episode, it is called a visit of that state-action pair.\",\"考虑一个 episode, 跟随策略π,\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…\",\"对于 MC-Basic, 这一条 episode 仅用作估计 state-action pair (s1​,a2​) 的 action value q(s1​,a2​)，但存在一定的浪费, 对于一个 episode, 可以拆分为多个 episode, 从而进行多次利用.\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s1​a2​​s2​a3​​s5​a1​​…s2​a3​​s5​a1​​…s5​a1​​…​[originalepisode][episodestartingfrom(s2​,a4​)][episodestartingfrom(s1​,a2​)][episodestartingfrom(s2​,a3​)][episodestartingfrom(s5​,a1​)]​\",\"这样，我们不仅可以用来估计q(s1​,a2​), 还可以估计q(s2​,a4​),q(s2​,a3​)…\",\"Data-efficient methods:\",\"first-visit method 记录在 episode 中第一次出现的 state-action pair, 如果该 state-action pair 再次出现, 不记录 action value 估计中.\",\"every-visit method 对于每个 state-action pair, 都记录 action value 估计中.\"]},\"367\":{\"h\":\"2.2 高效地更新 Policy\",\"t\":[\"什么时候更新策略也是一个影响效率的因素。\",\"方法1：如 MC Based 一样，在收集到了足够多的 从给定的 state-action pair 出发的 episodes 后, 通过 mean estimation 估计了q(s,a)后, 才进行更新。 缺点，等候时间过长，只有当所有 episodes 均收集完，才能进行 策略更新。\",\"方法2：直接 uses the return of a single episode to approximate the action value. 这类算法统称为：Generalized policy iteration (GPI). 它会在 Policy-evaluation 和 policy-improvement 中不断切换，即不需要完全精确地求出 action value，就直接去更新策略。\"]},\"368\":{\"h\":\"2.3 MC Exploring Starts\",\"t\":[\"20240812004534\"]},\"369\":{\"h\":\"2.4 Exploring Statrts的解释\",\"t\":[\"Exploring 表示对于每一个 action-state pair (s,a), 都需要有多个 episodes, 这样才能去估计相应的qπ​(s,a). 如果存在一个 action value 未能访问，就不能确保所选择的 action 是最优的。\",\"Starts 表示对于对应 action-state pair (s,a) 的 episodes，每次都是从对应的状态 s 出发，选择对应的动作 a 进行的采样。 如果从其他状态出发，得到的 episode，如果经过了 (s,a)，那么这称为 visit , 但目前无法保证 visit 一定可以遍历所给定的 (s,a).\",\"据目前而言，Exploring Starts 是一个必要条件.\"]},\"370\":{\"h\":\"3. MC Eplison-Greedy\",\"t\":[\"将 Exploring Starts 条件转换掉，通过采取 Soft Policies 的方法。\"]},\"371\":{\"h\":\"3.1 Soft Policy\",\"t\":[\"A policy is called soft if the probability to take any action is positive. 显然 soft policy 是 stochastic 的，并且如果按照这样一个策略，在 episode 足够长的情况下，我们可以确保其可以遍历所有的 state-action pair.\"]},\"372\":{\"h\":\"3.2 -greedy policy\",\"t\":[\"在这里，我们采用的是 ϵ-greedy policies, 其属于 soft policies.\",\"π(a∣s)={1−∣A(s)∣ϵ​(∣A(s)∣−1),∣A(s)∣ϵ​,​forthegreedyaction,fortheother∣A(s)∣−1action,​\",\"其中 ϵ∈[0,1] 且 ∣A(s)∣ 为状态 s 的动作数量.ϵ-greedy policy 可以平衡 exploitation 和 exploration. 显然ϵ=0, policy 就是 greedy 的; 如果ϵ=1, 此时就是随机策略，其探索性就很强.\"]},\"373\":{\"h\":\"3.3 -greedy policy 引入 MC-based 算法中\",\"t\":[\"对于 MC Basic 以及 MC Exploring 中的 policy improvement 中，找的是在所有可能策略中的最优策略，因此是一个确定的贪心策略。\",\"20240812011140\"]},\"374\":{\"h\":\"3.3 算法流程\",\"t\":[\"20240812010538\"]},\"375\":{\"c\":[\"academic\"]},\"376\":{\"c\":[\"强化学习\"]},\"377\":{\"h\":\"RL6 - 随机近似理论与随机梯度下降算法\",\"t\":[\"针对 mean estimation 问题进行研究，因为在 RL 中 无论是 state value 还是 action value 其定义都是一个均值 (means)\",\"Stochastic approximation(SA): SA refers to a broad class of stochastic iterative algorithms soloving root finding or optimization problems.\"]},\"378\":{\"h\":\"1. 引言\"},\"379\":{\"h\":\"1.1 求均值的方法\",\"t\":[\"第一种：直接通过 E[x]≈xˉ:=N1​∑i=1N​xi​，进行估计，只有当样本全部收集完才能估计.\",\"第二种: 增量式的迭代算法. 假设:\",\"wk+1​=k1​i=1∑k​xi​,k=1,2,…\",\"对应的\",\"wk​=k−11​i=1∑k−1​xi​,k=2,3,…\",\"那么，wk+1​可以由wk​推导出来，即\",\"wk+1​​=k1​∑i=1k​xi​​=k1​(∑i=1k−1​xi​+xk​)=k1​((k−1)wk​+xk​)​=wk​−k1​(wk​−xk​)​\",\"因此，wk+1​=wk​−k1​(wk​−xk​)\"]},\"380\":{\"h\":\"2. Robbins-Monto(RM) algorithm\"},\"381\":{\"h\":\"2.1 问题引入\",\"t\":[\"假设我们需要求解如下方程:\",\"g(w)=0\",\"其中, w∈R 且需要被求解出来，g:R→R 为一个函数方程. 显然，如果对于 g(w) 已知的情况，我们可以通过一些特定的算法进行求解。 如果 g(w) 未知，就需要新的算法进行解决。\"]},\"382\":{\"h\":\"2.2 算法介绍\",\"t\":[\"RM 算法就可以用来求解当 g(w) 未知时的情况，即函数 g(w) 是一个黑盒，我们只能通过 输入序列: wk​, 得到含有噪音的观测值序列: g​(wk​,ηk​) 具体解决如下:\",\"wk+1​=wk​−ak​g​(wk​,ηk​),k=1,2,3,…\",\"其中:\",\"wk​ 是第 k 次方程根的估计.\",\"g​(wk​,ηk​)=g(wk​)+ηk​ 是第 k 次的观测值(含噪音).\",\"ak​ 是一个 positive coefficient.\"]},\"383\":{\"h\":\"2.3 收敛性分析\",\"t\":[\"Robbins-Monro Theorem In the Robbins-Monro algorithm, if\",\"0<c1​≤▽w​g(w)≤c2​,forallw; 要求g(w)必须是递增的，确保根是存在且唯一的。\",\"∑k=1∞​ak​=∞ 且 ∑k=1∞​ak2​<∞;∑k=1∞​ak2​=∞ 保证 ak​→0,k→0∑k=1∞​ak​=∞ 保证 ak​→0不要过快.\",\"E[ηk​∣Hk​]=0 且 E[ηk2​∣Hk​]<∞; 其中Hk​=wk​,wk−1​,…, 那么 wk​ converges with probability 1 (w.p.1) to the root w∗ satisfying g(w∗)=0.\",\"ak​=k1​是满足上面三个条件的. 但实际上我们往往是选择一个非常小的常数。\"]},\"384\":{\"h\":\"2.4 应用于 mean estimation 中\",\"t\":[\"比如我们要估计某个随机变量X的 E[X] 我们可以设计如下方程:\",\"g(w)≐w−E[X].\",\"那么只要求解 g(w)=0, 我们就可以得到 E[X] 的值。 同样，我们不能直接得到随机变量的值，而是对应的样本 x，sample of X. 即，我们得到的观测值是:\",\"g​(w,x)≐w−x\",\"我们可以修改为噪音 η 的形式，\",\"g​(w,η)​=w−x​=w−x+E[X]−E[X]=(w−E[X])+(E[X]−x)​≐g(w)+η​\",\"因此我们可以通过 RM 算法来进行求解\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​(wk​−xk​)\"]},\"385\":{\"h\":\"3. Stochastic gradient descent\"},\"386\":{\"h\":\"3.1 问题引入\",\"t\":[\"需要求解一个优化问题:\",\"wargmin​J(w)=E[f(w,X)]\",\"其中，\",\"w 是需要被优化的参数\",\"X 是一个随机变量\",\"w 和 X 可以是标量，也可以是向量. 对于函数 f(⋅) 输出为标量.\",\"对于这个问题，我们有以下几种方法:\",\"Method 1: 梯度下降法 (gradient descent, GD)\",\"wk+1​=wk​−αk​▽w​E[f(wk​,X)]=wk​−αk​E[▽w​f(wk​,X)]\",\"但由于 j(w) 是一个期望值，我们很难直接获得.\",\"Method 2: batch gradient descent (BGD) 借用 MC 的思想，我们可以将:\",\"E[▽w​f(wk​,X)]≈n1​i=1∑n​▽w​f(wk​,xi​).\",\"因此\",\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f(wk​,xi​)\",\"但需要大量的 samples 收集完毕才能进行一次迭代.\",\"Method 3: 随机梯度下降(SGD) 考虑能否仅用一次 sample 进行迭代.\",\"wk+1​=wk​−αk​▽w​f(wk​,xk​)\",\"但能否保证其精确度，以及是否可以到最后优化的成果。\"]},\"387\":{\"h\":\"3.2 SGD 分析\"},\"388\":{\"h\":\"mean estimation 问题转化\",\"t\":[\"我们可以将 均值估计 问题 转化为 一个 优化问题 进行求解：\",\"20240814014058\"]},\"389\":{\"h\":\"SGD 正确性和收敛性分析\",\"t\":[\"从 GD 到 SGD:\",\"wk+1​=wk​−αk​E[▽w​f(wk​,X)]⇓wk+1​=wk​−αk​▽w​f(wk​,x)​\",\"显然我们可以将 ▽w​f(wk​,x) 视为 E[▽w​f(wk​,x)] 的一个观测值(含噪声):\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]+η▽w​f(wk​,x)−E[▽w​f(wk​,x)]​​\",\"因为\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]\",\"因此，我们需要思考使用 SGD 时wk​→w∗ as k→∞ 是否成立。\",\"我们可以将 SGD 视为一个特殊情况下的 RM 算法 SGD的目标是 minimize\",\"J(w)=E[f(w,X)]\",\"而最小值问题，往往可以转化为导数为 0 的情况,\",\"▽w​J(w)=E[▽w​f(w,X)]=0\",\"显然，可以参考 RM 算法, 让\",\"g(w)=▽w​J(w)=E[▽w​f(w,X)]\",\"从而转换为一个 root-finding 问题. 相应的，对于观测值g​(w,η),\",\"g~​(w,η)​=∇w​f(w,x)=g(w)E[∇w​f(w,X)]​​+η∇w​f(w,x)−E[∇w​f(w,X)]​​.​\",\"因此，我们就可以通过 RM 算法进行求解g(w)=0,\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​▽w​f(wk​,xk​)\",\"对应收敛性证明\"]},\"390\":{\"h\":\"3.3 SGD 另一种问题描述方法 (deterministic formulation)\",\"t\":[\"在之前关于使用 SGD 算法的问题描述中，我们是引入了 随机变量 和 期望的情况. 我们可以将这个问题可以转化为一个随机变量的方法，从而引入 SGD 算法.\"]},\"391\":{\"h\":\"3.4 BGD MBGD SGDw\",\"t\":[\"20240814230747\"]},\"392\":{\"c\":[\"academic\"]},\"393\":{\"c\":[\"强化学习\"]},\"394\":{\"h\":\"RL7 - Temporal-Difference Learning\"},\"395\":{\"h\":\"1. 引入\",\"t\":[\"考虑一个复杂的均值估计问题: 计算\",\"ω=E[R+γv(X)],\",\"其中, R, X 均是随机变量，γ 是常数，v(⋅) 表示一个函数。 显然我们仍然可以通过 RM 算法进行求解，假设我们可以得到有关随机变量 R, X 的采样 {x},{r}\",\"g(w)g~​(w,η)​=w−E[R+γv(X)]=w−[r+γv(x)]=(w−E[R+γv(X)])+(E[R+γv(X)]−[r+γv(x)])≐g(w)+η​\",\"因此，我们可以将该问题定义为一个 root-finding 问题: g(w)=0. 相应的 RM 算法为:\",\"wk+1​=wk​−αk​g~​(wk​,ηk​)=wk​−αk​[wk​−[rk​+γv(xk​)]]\"]},\"396\":{\"h\":\"2. TD Learning of state value\",\"t\":[\"求解给定策略 π 的 state value，这样就可以与 policy improvement 结合去寻找最优策略。\"]},\"397\":{\"h\":\"2.1 算法描述\",\"t\":[\"算法所需的数据(experience): 根据给定的策略 π 所生成的数据 (s0​,r1​,s1​,…,st​,rt+1​,st+1​,…) or {(st​,rt+1​,st+1​)}\",\"相应的算法是:\",\"vt+1​(st​)vt+1​(s)​=vt​(st​)−αt​(st​)[vt​(st​)−[rt+1​+γvt​(st+1​)]]=vt​(s),∀s=st​,​\",\"其中 t=0,1,2,…, vt​(st​)是关于 vπ​(st​) 的估计。\",\"newestimatevt+1​(st​)​​=currentestimatevt​(st​)​​−αt​(st​)[vt​(st​)−TDtargetvt​ˉ​[rt+1​+γvt​(st+1​)]​​]​TDerrorδt​​\"]},\"398\":{\"h\":\"2.2 算法分析\",\"t\":[\"TD 算法是用来求解一个 给定策略 π 的 Bellman equation.\",\"根据 state value 的定义，对于策略 π 的 state value\",\"vπ​(s)=E[R+γG∣S=s],s∈S\",\"其中 G 是 discounted return。\",\"E[G∣S=s]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s)=E[vπ​(S′)∣S=s]\",\"因此，我们可以写出 Bellman equation 的新形式，称为 Bellman expection equation\",\"vπ​(s)=E[E+γvπ​(S′)∣S=s],s∈S\"]},\"399\":{\"h\":\"2.3 TD 算法 与 MC 算法的比较\"},\"400\":{\"h\":\"3. TD Learning of action value\",\"t\":[\"Sarsa (state-action-reward-state-action) Sarsa 算法其目的是用于直接估计 action value, 从而可以在 policy improvement 中直接根据 action value 进行更新即可。\",\"Sarsa 算法同样是来求解 Bellman equation:\",\"qπ​(s,a)=E[R+γqπ​(S′,A′)∣s,a],∀s,a\"]},\"401\":{\"h\":\"3.1 Sarsa\",\"t\":[\"假设我们具有 some experience {(st​,at​,rt+1​,st+1​,at+1​)} 对应的 Sarsa 算法如下来进行估计 action value:\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(sa​,at​)−αt​(st​,at​)[qt​(sa​,at​)−[rt+1​+γqt​(st+1​,at+1​)]]=qt​(s,a),∀(s,a)=(st​,at​)​\",\"其中 t=0,1,2,…, qt​(st​,at​) 是qπ​(st​,at​)的估计。\",\"收敛性情况\",\"20240817000114\",\"伪代码\",\"20240817000134\",\"20240817000230\"]},\"402\":{\"h\":\"3.2 n-step Sarsa\",\"t\":[\"20240817000500\",\"20240817000601\",\"20240817000642\"]},\"403\":{\"h\":\"3.3 Expected Sarsa\",\"t\":[\"20240817000331\",\"20240817000409\"]},\"404\":{\"h\":\"4. TD Learning of optimal action value\",\"t\":[\"Q-learning 算法是用来解决 action value 形式下的贝尔曼最优公式 (Bellman optimality equation in terms of action value)\",\"q(s,a)=E[Rt+1​+γamax​q(St+1​,a)∣St​=s,At​=a],∀s,a\"]},\"405\":{\"h\":\"4.1 Q-learning\",\"t\":[\"Q-learning 直接估计的是 optimal action value，因此不需要进行 policy improvement。\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(st​,at​)−αt​(st​,at​)[qt​(st​,at​)−[rt+1​+γa∈Amax​qt​(st+1​,a)]]=qt​(s,a),∀(s,a)=(st​,at​)​\"]},\"406\":{\"h\":\"4.2. off-policy | on-policy\",\"t\":[\"behavior policy: 是用来与环境进行交互，从而生成经验数据的策略\",\"target policy: 是我们不断进行更新的策略，最终优化的策略\"]},\"407\":{\"h\":\"on - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是一致的，即我通过这个策略与环境进行交互生成一系列经验，在通过经验来更新这个策略。\"]},\"408\":{\"h\":\"off - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是不同的，即我通过一个策略与环境进行交互生成一系列经验。再通过这些经验来不断改进更新另一个策略，这另一个策略会更新到最优的策略。\",\"Sarsa，MC 是 on-policy 的 Q-learning 是 off-policy 的\"]},\"409\":{\"h\":\"4.3 Q-learning 伪代码\",\"t\":[\"因为 Q-learning 是 off-policy 的，因此，如果我们强制让 target policy 与 behavior ppolicy 一致也是可以的，此时也可以是 on-policy 的。\"]},\"410\":{\"h\":\"off-poicy 版本\",\"t\":[\"20240818182057\",\"此时 target policy 就不需要是 ϵ−greedy 策略了，因为不需要 target policy 进行生成数据。\"]},\"411\":{\"h\":\"on-policy 版本\",\"t\":[\"20240818181917\"]},\"412\":{\"h\":\"5. TD 算法的统一形式和总结\",\"t\":[\"20240818182301\",\"20240818182231\"]},\"413\":{\"c\":[\"academic\"]},\"414\":{\"c\":[\"强化学习\"]},\"415\":{\"h\":\"RL8 - 值函数近似(Value Function Approximation)\",\"t\":[\"对于 q-value 的估计从 基于表格的 (tabular representation) 转换到 基于函数的 (function representation)\"]},\"416\":{\"h\":\"1. 引入\",\"t\":[\"通过使用一个函数来进行拟合 state values 或者 action values: v^(s,w)≈vπ​(s)， 其中w∈Rm是参数向量。\",\"可以提高存储效率\",\"提高泛化能力\"]},\"417\":{\"h\":\"2. Alogorithm of state value estimation\",\"t\":[\"目标: 寻找一个最优的参数w，使得v^(s,w)最接近真实的vπ​(s).\",\"共两步:\",\"定义目标函数\",\"优化目标函数的算法\"]},\"418\":{\"h\":\"2.1 Obejctive function\",\"t\":[\"J(w)=E[(vπ​(S)−v^(S,w))2]\",\"分析随机变量 S 的 probability distribution (即对于损失函数中的 expection 需要考虑怎样对状态进行平均):\"]},\"419\":{\"h\":\"uniform distributon\",\"t\":[\"认为所有状态都是同等重要的，即各个状态的可能性为∣S∣1​ 因此这种情况下的 objective function 可以写成:\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=∣S∣1​s∈S∑​(vπ​(s)−v^(s,w))2\",\"但实际情况可能并不是所有状态的概率都是一致的，基于给定策略下，一些状态可能很少被访问，另一些则频繁被访问，因此采用这种 objective function 就不太可行。\"]},\"420\":{\"h\":\"stationary distribution\",\"t\":[\"stationary: 表示是一种长时间的交互行为\",\"distributon: 表示是 状态 的分布\",\"通常也称为 steady-state distributon or limiting distributon.\",\"describes the long-run behavior of a Markov process. 即基于一个策略，我们不断地与环境进行交互，最终会达到一个平稳的状态，此时可以分析每一个状态在这个策略下的概率。\",\"设 {dπ​(s)}s∈S​ 表示 基于策略 π 下的 stationary distribution。其中 dπ​(s)≥0 且 ∑s∈S​dπ​(s)=1\",\"那么此时的 objective function 可以表示为：\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=s∈S∑​dπ​(s)(vπ​(s)−v^(s,w))2\",\"20240820181406\",\"20240820181718\"]},\"421\":{\"h\":\"2.2 Optimization algorithms 优化算法\",\"t\":[\"目前的优化算法只是在估计给定策略的 statevalue\",\"minisize obejctive function J(w), 采用 梯度下降 算法:\",\"wk+1​=wk​−αk​▽w​J(wk​)\",\"对应目标函数的真实梯度是：\",\"▽w​j(w)​=▽w​E[(vπ​(S)−v^(S,w))2]=E[▽w​(vπ​(S)−v^(S,w))2]=−2E[(vπ​(S)−v^(S,w))▽w​v^(S,w)]​\",\"这里包含了一个 Expection，因此可以考虑 SGD 方法进行求解：\",\"wk+1​=wk​+αk​(vπ​(st​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\",\"其中st​是随机变量S的一个样本。 但这里还有一个难点，vπ​(st​) 我们是无法估计的，这是我们所求的量，因此需要用近似算法来进行替代，从而使得算法可行。\"]},\"422\":{\"h\":\"Monte Carlo learning with function approximation\",\"t\":[\"设 gt​ 表示在一个 episode 中，从状态 st​ 出发的 discounted return。因此我们用 gt​ 来近似 vπ​(st​), 即：\",\"wk+1​=wk​+αk​(gt​−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"423\":{\"h\":\"TD Learning with function approximation\",\"t\":[\"在 TD 算法中，我们将 rt+1​+γv^(st+1​,wt​) 来近似 vπ​(st​), 因此对应算法为：\",\"wk+1​=wk​+αk​(rt+1​+γv^(st+1​,wt​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"424\":{\"h\":\"3. Sarsa with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γq^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"20240820184127\"]},\"425\":{\"h\":\"4. Q-learning with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γa∈A(st+1​)max​q^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"on-policy版本：\",\"20240820184405\"]},\"426\":{\"h\":\"5. Deep Q-learning (DQN)\",\"t\":[\"Deep Q-learning 目的是最小化目标函数(objective/loss function):\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"其中 (S,A,R,S′) 均是随机变量。\"]},\"427\":{\"h\":\"优化方法\",\"t\":[\"采用梯度下降。\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"对于 q^​(S,A,w) 求解梯度还是很好求的。 但对于 maxa∈A(S′)​q^​(S′,a,w) 其求解梯度比较难求，在 DQN 中采用一个 固定 的方法进行解决。 尝试将 y≐R+γmaxa∈A(S′)​q^​(S′,a,w) 中的 w 进行固定求解，具体如下：\",\"引入两个网络：\",\"main network q^​(s,a,w)w 会一直进行更新，根据梯度下降的公式。\",\"target network q^​(s′,a,wT​) 并不是一直进行更新，而是等 main network 更新一定次数后，将该网络的 w 复制到 wT​ 中\",\"将 objective function 修改为：\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))2]\",\"在计算 main network q^​(s,a,w) 的梯度时，将 q^​(S′,a,wT​) 中的 wT​ 固定不动，因此左侧那个类似 TD target 的就不是有关 w 的函数，不用进行求导，从而方便计算。 然后在更新了一定次数之后，在将 wT​=w 进行赋值。\",\"因此对应的损失函数的梯度可以修改为：\",\"▽w​J​=E[−2(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))▽w​q^​(S,A,w)]=E[−2(YT​−q^​(S,A,w))▽w​q^​(S,A,w)]​\",\"一些细节:\",\"w 和 wT​ 表示 the main and target networks 的参数，在初始化的时候是设为相同的。\",\"在每一次迭代时，我们需要从经验池 (the replay buffer) 中取出一定数量的样本 (a mini-batch of samples {(s,a,r,s')}) 进行训练。\",\"网络的输入包括 状态 s 和 动作 a. 在训练求解梯度时，我们先直接求解 target network 的输出，视为 yT​≐r+γmaxa∈A(s′)​q^​(s′,a,wT​)。 然后我们通过 mini-batch 样本 {(s,a,yT​)}, 通过梯度的算法来最小化对应的损失函数, 假设有 N 个样本，那么对应的损失函数求解为：\",\"J(w)=i=1∑N​yT​−q^​(s,a,w) 即可以通过梯度下降，来更新参数值\",\"wt+1​=wt​+αt​N1​i=1∑N​(yT​−q^​(si​,ai​,wt​))⋅▽w​q^​(si​,ai​,wt​)\"]},\"428\":{\"h\":\"经验回放 (replay buffer)\",\"t\":[\"20240820230827\",\"20240820230920\",\"20240820230944\"]},\"429\":{\"h\":\"伪代码\",\"t\":[\"20240820231024\",\"但在发表 DQN 的文章中，不太一样，在原文是 on-policy 且 main network 的输出是不一样的。\",\"20240820231205\"]},\"430\":{\"c\":[\"academic\"]},\"431\":{\"c\":[\"强化学习\"]},\"432\":{\"h\":\"RL9 - 策略梯度法(Policy gradient)\",\"t\":[\"之前介绍的方法都是 value-based 的方法，从这章开始时基于 policy-based 的方法。\",\"policy function approximation 是直接建立一个基于策略的目标函数来进行梯度上升的优化。\"]},\"433\":{\"h\":\"1. 基本思路\",\"t\":[\"将基于表格表示的策略 转换为 基于函数表示的策略。 即此时策略 π 可以描述为：\",\"π(a∣s,θ)\",\"其中，θ∈Rm表示参数向量，是我们需要进行优化的。\",\"当策略是以表格的形式保存时，我们定义最优的策略为 在该策略下的所有 state value 都是最大的。\",\"当策略是以函数的形式存在时，我们定义 最优的策略 为 可以最大化一个确定的常数指标(certain scalar metrics).\",\"Policy gradient 的基本步骤：\",\"确定 metrics/objective function，来定义最优的策略：J(θ)\",\"进行优化，如梯度上升算法\",\"θt+1​=θt​+α▽θ​J(θt​)\"]},\"434\":{\"h\":\"2. 目标函数定义\"},\"435\":{\"h\":\"2.1 average state value\",\"t\":[\"vˉπ​=s∈S∑​d(s)vπ​(s)=dTvπ​\",\"vˉπ​ 显然是 state value 的加权平均。\",\"d(s)≥0 是各个 state 的权重\",\"∑s∈S​d(s)=1, 我们可以认为 d(s) 是 概率分布，因此该指标可以描述为:\",\"vˉπ​=ES∼d​[vπ​(S)]\"]},\"436\":{\"h\":\"另一种表达\",\"t\":[\"J(θ)=E[t=0∑∞​γtRt+1​]\",\"20240826173749\"]},\"437\":{\"h\":\"d(s)的选择\",\"t\":[\"d 与策略 π 无关 这种情况我们将 d 表示为 d0​, vˉπ​ 表示为 vˉπ0​. 这种情况下的 d 可以根据对各个状态的重要程度进行选择： 一种是将所有状态视为同等重要，一种则是有所偏向。\",\"d 与策略 π 有关 d 表示为 dπ​(s), 即在策略 π 下的 stationary distribution。\"]},\"438\":{\"h\":\"2.2 average return value\",\"t\":[\"rˉπ​=s∈S∑​dπ​(s)rπ​(s)=ES∼d​[rπ​(s)]\",\"其中:\",\"rπ​(s)r(s,a)​≐a∈A∑​π(a∣s)r(s,a)=E[R∣s,a]=r∑​rp(r∣s,a)​\",\"rπ​(s)表示在策略π下 状态s时可以得到的平均reward。r(s,a)表示在单步情况下(在状态s采用动作a)时的平均reward。\"]},\"439\":{\"h\":\"另一种表达\",\"t\":[\"假设 agent 跟随一个 给定的策略 然后生成了一个 trajectory以及对应的 rewards (Rt+1​,Rt+2​,…)\",\"对应 average single-step reward along this trajectory is\",\"====​n→∞lim​n1​E[Rt+1​+Rt+2​+⋯+Rt+n​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​]s∑​dπ​(s)rπ​(s)rˉπ​​\"]},\"440\":{\"h\":\"3. 目标函数梯度求解\",\"t\":[\"这里在视频没有详细介绍，只给出了梯度的公式：\",\"▽θ​J(θ)​=s∈S∑​η(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"其中\",\"J(θ) 可以是 vˉπ​,rˉπ​,vˉπ0​ 任何一种。\",\"\\\"=\\\" 有表示 严格等于 近似 以及 成比例等于\",\"η 表示 state 的权重或者分布\",\"具体推导过程:\",\"▽θ​lnπ(a∣s,θ)▽θ​J(θ)​=π(a∣s,θ)▽θ​π(a∣s,θ)​=s∈S∑​d(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=s∈S∑​d(s)a∈A∑​π(a∣s,θ)▽θ​lnπ(a∣s,θ)qπ​(s,a)=ES∼d​[a∑​π(s∣S,θ)▽θ​lnπ(a∣S,θ)qπ​(S,a)]=ES∼d,A∼π​[▽θ​lnπ(A∣S,θ)qπ​(S,A)]≐E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"根据这个式子我们就可以通过 SGD 方法，从而可以进行近似求解：\",\"▽θ​J(θ)≈▽θ​lnπ(a∣s,θ)qπ​(s,a)\",\"一些特性 这里的策略是随机性 的，因为我们需要计算的是 lnπ(a∣s,θ), 因此我们需要保证对于所有的 s,a,θ\",\"π(a∣s,θ)≥0\",\"20240826180244\"]},\"441\":{\"h\":\"4. REINFORCE 梯度上升算法\",\"t\":[\"梯度上升算法的本质就是最大化目标函数 J(θ)\",\"θt+1​​=θt​+α▽θ​J(θ)=θt​+αE[▽θ​lnπ(A∣S,θt​)qπ​(S,A)]​\",\"而对应的真实梯度可以用一个估计的梯度来替代:\",\"θt+1​=θt​+α▽θ​lnπ(at​∣st​,θt​)qπ​(s,a)\",\"但还存在 qπ​(s,a) 是未知的，我们也可以进行近似：\",\"θt+1​=θt​+α▽θ​lnπ(a∣s,θt​)qt​(st​,at​)\",\"这里可以用不同的方法来近似 qπ​(s,a).\",\"Monte-Carlo based method， 我们便称为 REINFORCE\",\"也可以采用基于 TD 的算法 或者 其他的算法。\",\"一些细节\",\"20240826181340\",\"20240826181538\",\"20240826181638\"]},\"442\":{\"h\":\"REINFORCE 算法\",\"t\":[\"20240826181712\"]},\"443\":{\"c\":[\"academic\"]},\"444\":{\"c\":[\"强化学习\"]},\"445\":{\"h\":\"javaweb - Socket1\"},\"446\":{\"h\":\"Socket\",\"t\":[\"通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。\"]},\"447\":{\"h\":\"socket 连接示例\",\"t\":[\"//服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); //由于继承了Autocloseble 省略 socket.close() }catch (IOException e){ e.printStackTrace(); } } \",\"//客户端 public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ System.out.println(\\\"已连接到服务端！\\\"); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } \",\"实际上它就是一个TCP连接的建立过程：\",\"20250319235934\",\"一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } \"]},\"448\":{\"h\":\"使用Socket进行数据传输\",\"t\":[\"通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：\",\"注意：\",\"如果服务端是 Socket socket = server.accept(); 最后需要 socket.close 不然会报错\",\"如果接收端读取的是 reader.readLine(), 注意需要添加 \\\\n，writer.write(text+ \\\"\\\\n\\\");, writer不会主动加 \\\\n\",\"OutputStream 是把东西先到对应的流里 InputStream 是获取对应流的内容\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080) ){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.print(\\\"接收到客户端数据：\\\"); System.out.println(reader.readLine()); //向客户端发请求 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"receiver!\\\"); writer.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080); Scanner scanner = new Scanner(System.in); ){ System.out.println(\\\"已连接到服务端！\\\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); System.out.println(\\\"请输入要发送给服务端的内容：\\\"); String text = scanner.nextLine(); writer.write(text+ \\\"\\\\n\\\"); writer.flush(); System.out.println(\\\"数据已发送：\\\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\\\"收到服务器返回：\\\"+reader.readLine()); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"449\":{\"h\":\"杂项\",\"t\":[\"我们可以手动关闭单向的流：\",\"socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 \",\"如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间：\",\" socket.setSoTimeout(3000); \",\"当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：\",\" java.net.SocketTimeoutException: Read timed out \",\"我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接 connect 方法，调用无参构造方法不会自动连接。\",\"try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\\\"localhost\\\", 8080), 1000); //手动调用connect方法进行连接 } \",\"如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生：\",\"socket.setKeepAlive(true); \",\"当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。\",\"TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：\",\" socket.setReceiveBufferSize(25565); //TCP接收缓冲区 socket.setSendBufferSize(25565); //TCP发送缓冲区 \"]},\"450\":{\"c\":[\"code\"]},\"451\":{\"c\":[\"javaweb\"]},\"452\":{\"h\":\"javaweb - Socket2\"},\"453\":{\"h\":\"Socket2\"},\"454\":{\"h\":\"Socket 传输文件\",\"t\":[\"其实本质上都差不多，主要掌握几种流之间的操作，和 socket 的用法\",\"一般 xxxOutputStream 的操作是往对应的xxx流内写入一些东西；xxxInputStream 的操作是从对应的xxx流内获取一些东西。\",\"// Server.java public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080); FileOutputStream fileOutputStream = new FileOutputStream(\\\"net/data.txt\\\"); ){ Socket socket = server.accept(); InputStream inputstream = socket.getInputStream(); byte[] bytes = new byte[1024]; int i; while((i = inputstream.read(bytes)) != -1){ fileOutputStream.write(bytes); } fileOutputStream.flush(); socket.close(); } catch (IOException e) { throw new RuntimeException(e); } } } \",\"// Client.java public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)){ FileInputStream fileInputStream = new FileInputStream(\\\"1.txt\\\"); OutputStream stream = socket.getOutputStream(); byte[] bytes = new byte[1024]; int i; while((i = fileInputStream.read(bytes)) != -1){ stream.write(bytes, 0, i); } stream.flush(); }catch (IOException e){ System.out.println(\\\"服务端连接失败！\\\"); e.printStackTrace(); } } } \"]},\"455\":{\"h\":\"使用浏览器访问Socket服务器\",\"t\":[\"Http请求是基于TCP协议，不会保持长久连接，在收到响应的数据后会立即关闭TCP连接。\",\"尝试自己写的http相应时，要保持服务器一直在线，不能一个socket之后就done了，因为浏览器访问时会不止发一个请求，所以如果没有始终在线，浏览器会显示无法访问。\",\"查看浏览器发起的请求\",\"public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\\\"接收到客户端数据：\\\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } \",\"通过访问 http://localhost:8080 或是 http://127.0.0.1:8080, 来连接我们本地端口的服务器。\",\"我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：\",\"GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: keep-alive Cache-Control: max-age=0 sec-ch-ua: \\\"Chromium\\\";v=\\\"94\\\", \\\"Google Chrome\\\";v=\\\"94\\\", \\\";Not A Brand\\\";v=\\\"99\\\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \\\"macOS\\\" Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 \",\"实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。\",\"既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：\",\"HTTP/1.1 200 Accpeted \",\"然后就是响应内容（注意一定要换行再写），对应支持HTTP协议的响应内容：\",\"public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ // 必须加 while(true) 因为浏览器不止发一个请求 while(true){ System.out.println(\\\"正在等待客户端连接...\\\"); Socket socket = server.accept(); System.out.println(\\\"客户端已连接，IP地址为：\\\"+socket.getInetAddress().getHostAddress()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\\\"HTTP/1.1 200 Accepted\\\\r\\\\n\\\"); writer.write(\\\"\\\\r\\\\n\\\"); writer.write(\\\"Penguin!\\\"); writer.flush(); socket.close(); } }catch (Exception e){ e.printStackTrace(); } } } \"]},\"456\":{\"c\":[\"code\"]},\"457\":{\"c\":[\"javaweb\"]},\"458\":{\"h\":\"javaweb - 数据库1\"},\"459\":{\"h\":\"数据库 1\"},\"460\":{\"h\":\"简介\",\"t\":[\"数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。\",\"常见的数据库有很多种，包括但不限于：\",\"MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统\"]},\"461\":{\"h\":\"数据模型\",\"t\":[\"数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：\",\"属性不可再分\",\"一个实体的属性可以有很多个\",\"用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的\",\"属性取值可以有一定的约束，比如性别只能是男或是女\",\"实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。\",\"通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。\",\"1\"]},\"462\":{\"h\":\"数据库创建\",\"t\":[\"既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：\",\"学生表：用于存放所有学生的数据，学生（学号，姓名，性别）\",\"教师表：用于存放所有教师的数据，教师（教师号，姓名）\",\"授课表：用于存放教师与学生的授课信息，授课（学号，教师号）\",\"其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。\"]},\"463\":{\"h\":\"数据库的规范化\",\"t\":[\"要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。\",\"1NF对表中每一列进行约束，2NF对主属性和其他属性的依赖关系产生约束，3NF对依赖关系进一步加强，BCNF则是对主键的选取进行唯一确定\"]},\"464\":{\"h\":\"第一范式（1NF）\",\"t\":[\"第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：\",\"学生（姓名，电话号码）\",\"电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为：\",\"学生（姓名，座机号码，手机号码）\",\"满足第一范式是关系型数据库最基本的要求！\"]},\"465\":{\"h\":\"第二范式（2NF）\",\"t\":[\"第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：\",\"学生（学号，姓名，性别）\",\"学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。\"]},\"466\":{\"h\":\"第三范式（3NF）\",\"t\":[\"在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。\",\"学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）\",\"实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：\",\"学生借书情况（借阅编号，学生学号，书籍编号）\",\"书籍（书籍编号，书籍名称，书籍作者）\",\"这样就消除了传递依赖，从而满足第三范式。\"]},\"467\":{\"h\":\"BCNF\",\"t\":[\"BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：\",\"(仓库ID, 存储物品ID) →(管理员ID, 数量)\",\"(管理员ID, 存储物品ID) → (仓库ID, 数量)\",\"所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：\",\"(仓库ID) → (管理员ID)\",\"(管理员ID) → (仓库ID)\",\"即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。\"]},\"468\":{\"c\":[\"code\"]},\"469\":{\"c\":[\"javaweb\",\"mysql\"]},\"470\":{\"h\":\"javaweb - 数据库2\"},\"471\":{\"h\":\"数据库 2\"},\"472\":{\"h\":\"SQL 语句\",\"t\":[\"结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。\",\"SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！\",\"SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。\",\"我们要学习的就是以下四种类型的SQL语言：\",\"数据查询语言（Data Query Language, DQL） 基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。\",\"数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集， 以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。\",\"数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。\",\"DCL（Data Control Language）是数据库控制语言。 是用来设置或更改数据库用户或角色权限的语句 包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。\",\"我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）\"]},\"473\":{\"h\":\"数据库定义语言（DDL）\"},\"474\":{\"h\":\"SQL数据类型\",\"t\":[\"以下的数据类型用于字符串存储：\",\"char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。\",\"varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。\",\"以下数据类型用于存储数字：\",\"smallint用于存储小的整数，范围在 (-32768，32767)\",\"int用于存储一般的整数，范围在 (-2147483648，2147483647)\",\"bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)\",\"float用于存储单精度小数\",\"double用于存储双精度的小数\",\"以下数据类型用于存储时间：\",\"date存储日期\",\"time存储时间\",\"year存储年份\",\"datetime用于混合存储日期+时间\"]},\"475\":{\"h\":\"列级约束条件\",\"t\":[\"列级约束有六种：\",\"主键 Primary key 确保列中的每个值都是唯一的，并且不能为空。一个表只能有一个主键，主键列的值用来唯一标识每一行数据。在主键列中，不允许有重复的值和空值。\",\"id INT PRIMARY KEY 表示 id 列是主键，且不能为空且唯一。\",\"外键 foreign key 用于建立和维护两表之间的关系，确保列中的值必须存在于另一表的主键或唯一约束列中。它保证数据的参照完整性。即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值。\",\"FOREIGN KEY (department_id) REFERENCES departments(id)，表示 department_id 列是外键，参照 departments 表的 id 列。\",\"唯一 unique 确保列中的每个值都是唯一的，但允许空值。与主键类似，唯一约束保证列中所有的非空数据都是唯一的。一个表可以有多个唯一约束，不同于主键，唯一约束允许有空值。\",\"email VARCHAR(255) UNIQUE 表示 email 列的值是唯一的。\",\"检查 check （MySQL不支持） 用于定义列的值必须满足某些条件。检查约束通常用于限制某些特定的数值范围或模式。\",\"age INT CHECK (age >= 18)，表示 age 列的值必须大于或等于 18。\",\"默认 default 用于为列指定默认值。如果在插入数据时没有为该列提供值，则会使用默认值。默认值仅在插入数据时使用，如果插入时该列有明确值，则默认值不会生效。\",\"status VARCHAR(10) DEFAULT 'active'，表示 status 列在未指定值时默认值为 'active'。\",\"非空/空值 not null/ null 用于定义列是否可以为空。NOT NULL 约束要求该列的每一行必须有一个非空值，而 NULL 允许列中的某些行没有值。\",\"name VARCHAR(100) NOT NULL 表示 name 列不能为 NULL，每一行必须有值。\"]},\"476\":{\"h\":\"表级约束条件\",\"t\":[\"表级约束有四种：主键、外键、唯一、检查\",\"主键 主键约束保证表中的每一行数据都有唯一的标识符，且该列的值不能为空。一个表只能有一个主键。\",\"CONSTRAINT pk_primary_key PRIMARY KEY (id)\",\"外键 外键约束用于在两个表之间建立参照完整性关系，确保某列的值必须存在于另一表的主键或唯一约束列中。\",\"CREATE TABLE Departments ( DepartmentID INT, DepartmentName VARCHAR(50) NOT NULL, Location VARCHAR(50), ManagerID INT, Budget DECIMAL(10, 2), CONSTRAINT PK_Departments PRIMARY KEY (DepartmentID), CONSTRAINT UC_DepartmentName UNIQUE (DepartmentName), CONSTRAINT CK_BudgetPositive CHECK (Budget >= 0), CONSTRAINT FK_Manager FOREIGN KEY (ManagerID) REFERENCES Employees(EmployeeID), CONSTRAINT DF_Location DEFAULT 'Headquarters' FOR Location ); \"]},\"477\":{\"h\":\"数据库操作\",\"t\":[\"我们可以通过create database来创建一个数据库：\",\"CREATE DATABASE 数据库名 \",\"为了能够支持中文，我们在创建时可以设定编码格式：\",\"CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; \",\"如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库：\",\"DROP DATABASE 数据库名 \"]},\"478\":{\"h\":\"创建表\",\"t\":[\"在创建表之前，一定要先切换到我们要创建表的数据库内 use xxxx;，默认并不是你创建的数据库。\",\"数据库创建完成后，我们一般通过create table语句来创建一张表：\",\"create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) \"]},\"479\":{\"h\":\"修改表\",\"t\":[\"如果我们想修改表结构，我们可以通过alter table来进行修改：\",\"ALTER TABLE 表名 [ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] \",\"我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。\"]},\"480\":{\"h\":\"删除表\",\"t\":[\"我们可以通过drop table来删除一个表：\",\"DROP TABLE 表名[restrict|cascade] \",\"其中restrict和cascade上面的效果一致。\"]},\"481\":{\"h\":\"数据库操纵语言 (DML)\"},\"482\":{\"h\":\"插入数据\",\"t\":[\"通过使用insert into语句来向数据库中插入一条数据（一条记录）：\",\"INSERT INTO 表名 VALUES(值1, 值2, 值3) \",\"如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) \",\"我们也可以一次性向数据库中插入多条数据：\",\"INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) \",\"我们来试试看向我们刚刚创建的表中添加三条数据。\"]},\"483\":{\"h\":\"修改数据\",\"t\":[\"我们可以通过update语句来更新表中的数据：\",\"UPDATE 表名 SET 列名=值,... WHERE 条件 \",\"注意，SQL语句中的等于判断是=\",\"警告： 如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！\"]},\"484\":{\"h\":\"删除数据\",\"t\":[\"我们可以通过使用delete来删除表中的数据：\",\"DELETE FROM 表名 \",\"通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据：\",\"DELETE FROM 表名 WHERE 条件 \"]},\"485\":{\"c\":[\"code\"]},\"486\":{\"c\":[\"javaweb\",\"mysql\"]},\"487\":{\"h\":\"javaweb - 数据库3\"},\"488\":{\"h\":\"数据库 3\"},\"489\":{\"h\":\"数据库查询语言 (DQL)\"},\"490\":{\"h\":\"单表查询\",\"t\":[\"单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询：\",\"-- 指定查询某一列数据 SELECT 列名[,列名] FROM 表名 -- 会以别名显示此列 SELECT 列名 别名 FROM 表名 -- 查询所有的列数据 SELECT * FROM 表名 -- 只查询不重复的值 SELECT DISTINCT 列名 FROM 表名 \",\"我们也可以添加where字句来限定查询目标：\",\"SELECT * FROM 表名 WHERE 条件 \"]},\"491\":{\"h\":\"常用 查询条件\",\"t\":[\"一般的比较运算符，包括=、>、<、>=、<=、!=等。\",\"是否在集合中：in、not in\",\"字符模糊匹配：like，not like % 表示任意内容 比如 03% 表示03开头\",\"多重条件连接查询：and、or、not\"]},\"492\":{\"h\":\"排序查询\",\"t\":[\"我们可以通过order by来将查询结果进行排序：\",\"SELECT * FROM 表名 ORDER BY 列名 ASC|DESC \",\"使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。\",\"我们也可以可以同时添加多个排序：\",\"SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC \",\"这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。\"]},\"493\":{\"h\":\"聚集函数\",\"t\":[\"聚集函数一般用作统计，包括：\",\"count([distinct]*)统计所有的行数（distinct表示去重再统计，下同）\",\"count([distinct]列名)统计某列的值总和\",\"sum([distinct]列名)求一列的和（注意必须是数字类型的）\",\"avg([distinct]列名)求一列的平均值（注意必须是数字类型）\",\"max([distinct]列名)求一列的最大值\",\"min([distinct]列名)求一列的最小值\",\"一般聚集函数是这样使用的：\",\"SELECT count(distinct 列名) FROM 表名 WHERE 条件 \"]},\"494\":{\"h\":\"分组和分页查询\",\"t\":[\"通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 \",\"我们还可以添加having来限制分组条件：\",\"SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 \",\"我们可以通过limit来限制查询的数量，只取前n个结果：\",\"SELECT * FROM 表名 LIMIT 数量 \",\"我们也可以进行分页：\",\"SELECT * FROM 表名 LIMIT 起始位置,数量 \"]},\"495\":{\"h\":\"多表查询\",\"t\":[\"多表查询是同时查询的两个或两个以上的表，多表查询会通过连接转换为单表查询。\",\"SELECT * FROM 表1, 表2 \",\"直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。\",\"SELECT * FROM 表1, 表2 WHERE 条件 \",\"这样，只会从笛卡尔积的结果中得到满足条件的数据。\",\"注意： 如果两个表中都带有此属性，需要添加表名前缀来指明是哪一个表的数据。比如 select * from a1, a2 where a1.xxx;\"]},\"496\":{\"h\":\"自身连接查询\",\"t\":[\"自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：\",\"SELECT * FROM 表名 别名1, 表名 别名2 \",\"其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。\"]},\"497\":{\"h\":\"外连接查询\",\"t\":[\"可以叠着使用\",\"外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：\",\"通过使用inner join xxx on进行内连接 只会返回两个表满足条件的交集部分： select * from student inner join teach on student.sid = teach.sid;\",\"通过使用left join xxx on进行左连接 不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： select * from student left join teach on student.sid = teach.sid;\",\"右连接类似 right join xxx on\"]},\"498\":{\"h\":\"嵌套查询\",\"t\":[\"我们可以将查询的结果作为另一个查询的条件，比如：\",\"SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) \",\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。\"]},\"499\":{\"h\":\"数据库控制语言（DCL）\",\"t\":[\"庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。\"]},\"500\":{\"h\":\"创建用户\",\"t\":[\"我们可以通过create user来创建用户：\",\"CREATE USER 用户名 identified by 密码; \",\"也可以不带密码：\",\"CREATE USER 用户名; \",\"我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。\"]},\"501\":{\"h\":\"登陆用户\",\"t\":[\"首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：\",\"login -u 用户名 -p \",\"输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：\",\"show databases; \",\"我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！\"]},\"502\":{\"h\":\"用户授权\",\"t\":[\"我们可以通过使用grant来为一个数据库用户进行授权：\",\"grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] \",\"其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。\",\"我们可以使用revoke来收回一个权限：\",\"revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 \"]},\"503\":{\"c\":[\"code\"]},\"504\":{\"c\":[\"javaweb\",\"mysql\"]},\"505\":{\"h\":\"javaweb - 数据库4\"},\"506\":{\"h\":\"数据库 4\"},\"507\":{\"h\":\"视图\",\"t\":[\"视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。\",\"既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 对视图的修改就是对基本表的修改，相当于一个指针。\",\"我们可以通过create view来创建视图;\",\"CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; \",\"WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。\",\"若视图是由两个以上基本表导出的，则此视图不允许更新。\",\"若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。\",\"若视图的字段来自集函数，则此视图不允许更新。\",\"若视图定义中含有GROUP BY子句，则此视图不允许更新。\",\"若视图定义中含有DISTINCT短语，则此视图不允许更新。\",\"若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade > (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。\",\"一个不允许更新的视图上定义的视图也不允许更新\",\"通过drop来删除一个视图：\",\"drop view apptest \"]},\"508\":{\"h\":\"索引\",\"t\":[\"在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：\",\"-- 创建索引 CREATE INDEX 索引名称 ON 表名 (列名) -- 查看表中的索引 show INDEX FROM student \",\"索引类型包括：NORMAL, UNIQUE, FULLTEST, SPATIAL\",\"索引方法：BTREE, HASH\",\"我们也可以通过下面的命令删除一个索引：\",\"drop index 索引名称 on 表名 \",\"虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。\"]},\"509\":{\"h\":\"触发器\",\"t\":[\"触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。\",\"触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）\",\"比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。\",\"CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno \",\"FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！\",\"通过下面的命令来查看触发器：\",\"SHOW TRIGGERS \",\"如果不需要，我们就可以删除此触发器：\",\"DROP TRIGGER 触发器名称 \"]},\"510\":{\"h\":\"事务\",\"t\":[\"当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：\",\"SHOW ENGINES; \",\"MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。\",\"事务具有以下特性：\",\"原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\",\"一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\",\"隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\",\"持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\",\"类似 git 的操作？开启事务只有当commit后才能在真正的数据库里看到\",\"我们通过以下例子来探究以下事务：\",\"begin; #开始事务 ... rollback; #回滚事务 savepoint 回滚点; #添加回滚点 rollback to 回滚点; #回滚到指定回滚点 ... commit; #提交事务 -- 一旦提交，就无法再进行回滚了！ \",\"函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。\"]},\"511\":{\"c\":[\"code\"]},\"512\":{\"c\":[\"javaweb\",\"mysql\"]},\"513\":{\"h\":\"javaweb - JAVA与数据库1\"},\"514\":{\"h\":\"主要内容\",\"t\":[\"通过Java如何去使用数据库来帮助我们存储数据\"]},\"515\":{\"h\":\"JDBC\",\"t\":[\"JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。\",\"我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。\"]},\"516\":{\"h\":\"使用JDBC连接数据库\",\"t\":[\"//注意前两步都放在try()中，因为在最后需要释放资源！ //1. 通过DriverManager来获得数据库连接 try (Connection connection = DriverManager.getConnection( \\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement() ){ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\\\"select * from student\\\"); //4. 查看结果 while (set.next()){ System.out.println(set.getString(1)); } }catch (SQLException e){ e.printStackTrace(); } //5. 释放资源，try-with-resource语法会自动帮助我们close \",\"其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序）\",\"注意： 6.0版本以上，不用手动加载驱动，我们直接使用即可！ 即不需要使用 反射 来加载驱动类\",\"Class.forName(\\\"com.mysql.jdbc.Driver\\\") \",\"如果加载会提示\",\"Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. \"]},\"517\":{\"h\":\"DriverManager\",\"t\":[\"DriverManager是管理我们的数据库驱动的, 来分析我们设定的驱动是否可以连接，如果成功就返回对应的 connection\",\"public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\\\"registerDriver: \\\" + driver); } \",\"private static Connection getConnection( String url, java.util.Properties info, Class<?> caller) throws SQLException { /* * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) { // synchronize loading of the correct classloader. if (callerCL == null) { callerCL = Thread.currentThread().getContextClassLoader(); } } if(url == null) { throw new SQLException(\\\"The url cannot be null\\\", \\\"08001\\\"); } println(\\\"DriverManager.getConnection(\\\\\\\"\\\" + url + \\\"\\\\\\\")\\\"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) { // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) { try { println(\\\" trying \\\" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! println(\\\"getConnection returning \\\" + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { println(\\\" skipping: \\\" + aDriver.getClass().getName()); } } // if we got here nobody could connect. if (reason != null) { println(\\\"getConnection failed: \\\" + reason); throw reason; } println(\\\"getConnection: no suitable driver found for \\\"+ url); throw new SQLException(\\\"No suitable driver found for \\\"+ url, \\\"08001\\\"); } \",\"我们可以通过调用getConnection()来进行数据库的链接：\",\"@CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\\\"user\\\", user); } if (password != null) { info.put(\\\"password\\\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } \",\"我们可以手动为驱动管理器添加一个日志打印：\",\"static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } \",\"现在我们执行的数据库操作日志会在控制台实时打印。\"]},\"518\":{\"h\":\"了解Connection\",\"t\":[\"Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句：\",\"Statement createStatement() throws SQLException; \",\"我们发现除了普通的Statement，还存在PreparedStatement：\",\"PreparedStatement prepareStatement(String sql) throws SQLException; \",\"在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。\",\"它还支持事务的处理，也放到后面来详细进行讲解。\"]},\"519\":{\"h\":\"了解Statement\",\"t\":[\"我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！\",\"Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。\",\"也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。\",\"6\"]},\"520\":{\"c\":[\"code\"]},\"521\":{\"c\":[\"javaweb\",\"mysql\"]},\"522\":{\"h\":\"javaweb - JAVA与数据库2\"},\"523\":{\"h\":\"JDBC\"},\"524\":{\"h\":\"执行DML操作\",\"t\":[\"删除、更新、添加\",\"import java.io.PrintWriter; import java.sql.*; public class Main { public static void main(String[] args) { try ( Connection connection = DriverManager.getConnection(\\\"jdbc:mysql://localhost:3306/study\\\",\\\"root\\\",\\\"123456\\\"); Statement statement = connection.createStatement(); ){ int i = statement.executeUpdate(\\\"insert into student values(4,'monkey','男')\\\"); // statement.executeUpdate(\\\"delete from student where sid = 4\\\"); // int i = statement.executeUpdate(\\\"update student set name = 'dog' where sid=3\\\"); System.out.println(\\\"生效了：\\\"+i+\\\"行\\\"); } catch (SQLException e) { throw new RuntimeException(e); } } } \"]},\"525\":{\"h\":\"执行DQL操作\",\"t\":[\"执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 一开始是在第一行上面，可以理解在标题栏\",\"//首先要明确，select返回的数据类似于一个excel表格 while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行 } \",\"我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。\",\"7\"]},\"526\":{\"h\":\"执行批处理操作\",\"t\":[\"当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\\\"insert into user values ('f', 1234)\\\"); statement.addBatch(\\\"insert into user values ('e', 1234)\\\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); } } \"]},\"527\":{\"h\":\"将查询结果映射为对象\",\"t\":[\"既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类：\",\"public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\\\"我叫：\\\"+name+\\\"，学号为：\\\"+sid+\\\"，我的性别是：\\\"+sex); } } \",\"现在我们来进行一个转换：\",\"while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say(); } \",\"注意： 列的下标是从1开始的。\",\"我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射：\",\"private static <T> T convert(ResultSet set, Class<T> clazz){ try { Constructor<T> constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class<?>[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i < param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\\\"错误的类型转换：\\\"+object[i].getClass()+\\\" -> \\\"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; } } \",\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了：\",\"while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say(); } \",\"实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。\"]},\"528\":{\"c\":[\"code\"]},\"529\":{\"c\":[\"javaweb\",\"mysql\"]},\"530\":{\"h\":\"javaweb - JAVA与数据库3\"},\"531\":{\"h\":\"JDBC\"},\"532\":{\"h\":\"实现登陆与SQL注入攻击\",\"t\":[\"在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写：\",\"try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\\\"select * from user where username='\\\"+scanner.nextLine()+\\\"'and pwd='\\\"+scanner.nextLine()+\\\"';\\\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } \",\"用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢：\",\"Test 1111' or 1=1; -- # Test 登陆成功！ \",\"1=1一定是true，那么我们原本的SQL语句会变为：\",\"select * from user where username='Test' and pwd='1111' or 1=1; -- ' \",\"我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。\"]},\"533\":{\"h\":\"使用\",\"t\":[\"我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); PreparedStatement statement = connection.prepareStatement(\\\"select * from user where username= ? and pwd=?;\\\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\\\" 登陆成功！\\\"); } }catch (SQLException e){ e.printStackTrace(); } } \",\"我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么：\",\"com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- '; \",\"我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！\"]},\"534\":{\"h\":\"管理事务\",\"t\":[\"JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false)方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。\",\"con.setAutoCommit(); //关闭自动提交后相当于开启事务。 // SQL语句 // SQL语句 // SQL语句 con.commit();或 con.rollback(); \",\"一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); } } \",\"我们来接着尝试一下使用回滚操作：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"同样的，我们也可以去创建一个回滚点来实现定点回滚：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\\\"insert into user values ('b', 1234)\\\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\\\"insert into user values ('c', 1234)\\\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } \",\"通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去：\",\"public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\\\"URL\\\",\\\"用户名\\\",\\\"密码\\\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\\\"insert into user values ('a', 1234)\\\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\\\"insert into user values ('d', 1234)\\\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } } \"]},\"535\":{\"c\":[\"code\"]},\"536\":{\"c\":[\"javaweb\",\"mysql\"]},\"537\":{\"h\":\"javaweb - Lombok1\"},\"538\":{\"h\":\"Lombok1\",\"t\":[\"我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！\",\"通过使用 Lombok（小辣椒）就可以解决这样的问题！\",\"img\",\"使用原生方式和小辣椒方式编写类的区别，首先是传统方式：\",\"public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } \",\"而使用Lombok之后：\",\"@Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } \",\"我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！\"]},\"539\":{\"h\":\"配置Lombok\",\"t\":[\"首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download\",\"然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。\",\"重启IDEA\",\"Lombok 是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理(编译阶段处理)。\",\"Java的编译过程可以分成三个阶段： \",\"所有源文件会被解析成语法树。\",\"调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。\",\"最后，语法树会被分析并转化成类文件。\",\"实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。\"]},\"540\":{\"h\":\"使用Lombok\",\"t\":[\"我们通过实战来演示一下Lombok的实用注解：\",\"我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。\",\"我们还可以使用@Accessors来控制生成Getter和Setter的样式。\",\"我们通过添加@ToString来为当前类生成预设的toString方法。\",\"我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。\",\"我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。\",\"我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。\",\"使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。\",\"一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。\",\"使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。\",\"使用@SneakyThrows来自动生成try-catch代码块。\",\"使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换）\",\"使用@Builder来快速生成建造者模式。\",\"通过使用@Builder.Default来指定默认值。\",\"通过使用@Builder.ObtainVia来指定默认值的获取方式。\"]},\"541\":{\"c\":[\"code\"]},\"542\":{\"c\":[\"javaweb\",\"Lombok\"]},\"543\":{\"h\":\"javaweb - Mybatis1\"},\"544\":{\"h\":\"Mybatis1\",\"t\":[\"在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。\",\"再次强调： 学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。\",\"image-20230306163528771\",\"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。\"]},\"545\":{\"h\":\"XML语言\",\"t\":[\"在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <outer> <name>阿伟</name> <desc>怎么又在玩电动啊</desc> <inner type=\\\"1\\\"> <age>10</age> <sex>男</sex> </inner> </outer> \",\"HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。\",\"一个XML文件存在以下的格式规范：\",\"必须存在一个根节点，将所有的子标签全部包含。\",\"可以但不必须包含一个头部声明（主要是可以设定编码格式）\",\"所有的标签必须成对出现，可以嵌套但不能交叉嵌套\",\"区分大小写。\",\"标签中可以存在属性，比如上面的type=\\\"1\\\"就是inner标签的一个属性，属性的值由单引号或双引号包括。\",\"XML文件也可以使用注释：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!-- 注释内容 --> \",\"通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件）\"]},\"546\":{\"h\":\"转义字符\",\"t\":[\"image-20230306163528771\",\"如果嫌一个一个改太麻烦，也可以使用CDATA <![CDATA[ xxxxx ] 来快速创建不解析区域：\",\"<test> <name><![CDATA[我看你<><><>是一点都不懂哦>>>]]></name> </test> \"]},\"547\":{\"h\":\"解析XML文件\",\"t\":[\"如何将定义好的XML文件读取到Java程序中\",\"JDK为我们内置了一个叫做org.w3c的XML解析库：\",\"// 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\\\"file:mappers/test.xml\\\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\\\"test\\\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 // 节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i < childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \\\"：\\\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本 // （内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } \",\"当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的）\",\"不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！\"]},\"548\":{\"c\":[\"code\"]},\"549\":{\"c\":[\"javaweb\",\"mybatis\"]},\"550\":{\"h\":\"javaweb - Mybatis2\"},\"551\":{\"h\":\"Mybatis2\"},\"552\":{\"h\":\"初次使用 Mybatis\",\"t\":[\"文档网站：https://mybatis.org/mybatis-3/zh_CN/configuration.html\",\"我们需要导入Mybatis的依赖，依赖导入完成后，编写Mybatis的配置文件(通过一个XML文件去配置)\",\"按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <!-- 对应哪个数据库的JDBC驱动 com.mysql.cj.jdbc.Driver --> <property name=\\\"driver\\\" value=\\\"${驱动类（含包名）}\\\"/> <property name=\\\"url\\\" value=\\\"${数据库连接URL}\\\"/> <property name=\\\"username\\\" value=\\\"${用户名}\\\"/> <property name=\\\"password\\\" value=\\\"${密码}\\\"/> </dataSource> </environment> </environments> </configuration> \",\"我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容）\",\"通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了 （也可以不使用配置文件，自行阅读官方文档）\",\"配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象：\",\"public static void main(String[] args) throws FileNotFoundException { String resource = \\\"mybatis-config.xml\\\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try(SqlSession s = sqlSessionFactory.openSession(true)){ } } \",\"直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！\"]},\"553\":{\"h\":\"\",\"t\":[\"那么现在我们来看看，SqlSessionFactory对象是什么东西：\",\"每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话 —— SqlSession对象，\",\"每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。\",\"而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。\"]},\"554\":{\"h\":\"直接读取实体类\",\"t\":[\"我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段\",\"在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。\",\"首先编写实体类，直接使用Lombok：\",\"import lombok.Data; @Data public class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex; } \",\"在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"com.test.entity.Student\\\"> select * from student </select> </mapper> \",\"其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。\",\"我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。\",\"编写好后，我们在配置文件中添加这个Mapper映射器：\",\"<mappers> <mapper url=\\\"file:mappers/TestMapper.xml\\\"/> <!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --> </mappers> \",\"最后在程序中使用我们定义好的Mapper即可：\",\"public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \",\"我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！\"]},\"555\":{\"c\":[\"code\"]},\"556\":{\"c\":[\"javaweb\",\"mybatis\"]},\"557\":{\"h\":\"javaweb - Mybatis3\"},\"558\":{\"h\":\"Mybatis详解1\",\"t\":[\"由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些：\",\"public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\\\"mybatis-config.xml\\\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } \",\"现在我们只需要在main方法中这样写即可查询结果了：\",\"public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List<Student> student = sqlSession.selectList(\\\"selectStudent\\\"); student.forEach(System.out::println); } } \"]},\"559\":{\"h\":\"查询操作\",\"t\":[\"XML配置sql操作\",\"对应java进行调用\",\"查询操作在XML配置中使用一个select标签进行囊括\",\"假设我们现在需要编写一个根据ID查询用户的操作，首先我们需要指定select操作的id：\",\"<select id=\\\"selectUserById\\\"> </select> \",\"接着是我们需要进行查询的参数，这里我们需要根据用户ID查询，那么传入的参数就是一个int类型的参数，参数也可以是字符串类型的，类型名称：\",\"如果是基本类型，需要使用_int这样前面添加下划线。\",\"如果是JDK内置的包装类型或是其他类型，可以直接使用其名称，比如String、int（Integer的缩写）、Long\",\"如果是自己编写的类型，需要完整的包名+类名才可以。\",\"当然也可以直接不填这个属性，Mybatis会自动判断：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> </select> \",\"接下来就是编写我们的SQL语句了，由于这里我们需要通过一个参数来查询，所以需要填入一个占位符，通过使用#{xxx}或是${xxx}来填入我们给定的属性，名称随便：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\"> select * from user where id = #{id} </select> \",\"实际上Mybatis也是通过PreparedStatement首先进行一次预编译，来有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此对于常见的一些查询参数，我们一般都使用#{xxx}来进行操作保证安全性。\",\"最后我们查询到结果后，一般都是将其转换为对应的实体类对象，所以说这里我们之间填写之前建好的实体类名称，使用resultType属性来指定：\",\"<select id=\\\"selectUserById\\\" parameterType=\\\"int\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"560\":{\"h\":\"别名\",\"t\":[\"当然，如果你觉得像这样每次都要写一个完整的类名太累了，也可以为它起个别名，我们只需要在Mybatis的配置文件中进行编写即可：\",\"<typeAliases> <typeAlias type=\\\"com.test.User\\\" alias=\\\"User\\\"/> </typeAliases> \",\"也可以直接扫描整个包下的所有实体类，自动起别名，默认情况下别名就是类的名称：\",\"<typeAliases> <package name=\\\"com.test.entity\\\"/> </typeAliases> \",\"这样，SQL语句映射配置我们就编写好了，接着就是Java这边进行调用了：\",\"//这里我们填写刚刚的id，然后将我们的参数填写到后面 User user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"561\":{\"h\":\"hashmap 转换\",\"t\":[\"当然，如果你不需要转换为实体类，Mybatis也为我们提供了多种转换方案，比如转换为一个Map对象：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} </select> \",\"//使用Map类型变量进行接受，Key为String类型，Value为Object类型 Map<String, Object> user = session.selectOne(\\\"selectUserById\\\", 1); System.out.println(user); \"]},\"562\":{\"h\":\"多参数查询\",\"t\":[\"我们可以尝试接着来写一个同时查询ID和年龄的查询操作：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"hashmap\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"因为这里需要多个参数，我们可以使用一个Map (Map.of是JAVA9的特性)或是具有同样参数的实体类来传递，显然Map用起来更便捷一些，注意key的名称需要与我们编写的SQL语句中占位符一致：\",\"User user = session.selectOne(\\\"selectUserByIdAndAge\\\", Map.of(\\\"id\\\", 1, \\\"age\\\", 18)); System.out.println(user); \"]},\"563\":{\"h\":\"\",\"t\":[\"下面这种情况，实体类中定义的属性名称和我们数据库中的名称不一样\",\"这会导致Mybatis自动处理出现问题：\",\"@Data public class User { int uid; String username; int age; } \",\"运行后发现，Mybatis虽然可以查询到对应的记录，但是转换的实体类数据并没有被添加上去，这是因为数据库字段名称与类中字段名称不匹配导致的，我们可以手动配一个resultMap来解决这种问题，直接在Mapper中添加：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultMap=\\\"user\\\"> select * from user where id = #{id} and age = #{age} </select> <resultMap id=\\\"user\\\" type=\\\"com.test.User\\\"> <!-- 因为id为主键，这里也可以使用<id>标签，有助于提高性能 --> <result column=\\\"id\\\" property=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"column 对应数据库字段名\",\"property 对应实体类属性名\",\"这里我们在resultMap标签中配置了一些result标签，每一个result标签都可以配置数据库字段和类属性的对应关系，这样Mybatis就可以按照我们的配置来正确找到对应的位置并赋值了，没有手动配置的字段会按照之前默认的方式进行赋值。\",\"配置完成后，最终只需要将resultType改为resultMap并指定对应id即可，然后就能够正确查询了。\",\"这里有一个RowBounds参数，用于实现分页效果，但是其分页功能是对查询到的数据进行划分，非常鸡肋，这里不进行介绍，了解即可。\"]},\"564\":{\"h\":\"查询列表操作\",\"t\":[\"我们再来尝试编写一下查询一个列表，查询列表时，resultType无需设置为list这种类型，而是使用List内部所包含的类型\",\"所以这里还是填写com.test.User类型或是Map类型：\",\"<select id=\\\"selectUsers\\\" resultType=\\\"com.test.User\\\"> select * from user; </select> \",\"由于返回的结果是一个列表，这里我们需要使用selectList方法来执行，如果使用之前的selectOne会导致异常：\",\"List<User> user = session.selectList(\\\"selectUsers\\\"); System.out.println(user); \",\"我们同样可以进行简单的条件查询，比如我们想要查询所有年龄大于等于18岁的用户：\",\"<select id=\\\"selectUsersByAge\\\" resultType=\\\"com.test.User\\\"> select * from user where age &gt; #{age}; </select> \",\"注意由于这里是XML配置，其中一些字符被用作标签表示，无法代表其原本的意思，比如小于、大于符号，分别需要使用&lt;和&gt;来进行转义。\",\"List<User> user = session.selectList(\\\"selectUsersByAge\\\", 18); \",\"一个比较特殊的选择方法selectMap\",\"可以将查询结果以一个Map的形式表示，只不过这和我们之前说的Map不太一样，它返回的Map是使用我们想要的属性作为Key，然后得到的结果作为Value的Map，它适用于单个数据查询或是多行数据查询：\",\"//最后一个参数为我们希望作为key的属性 Map<String, User> user = session.selectMap(\\\"selectUserById\\\", 1, \\\"id\\\"); \",\"可以看到这个Map中确实使用的是id作为Key，然后查询得到的实体对象作为Value。\",\"还有一个比较特殊的选择操作是selectCursor\",\"可以得到一个Cursor对象，同样是用于列表查询的，只不过使用起来和我们之前JDBC中的ResultSet比较类似，也是通过迭代器的形式去进行数据的读取，官方解释它主要用于惰性获取数据，提高性能：\",\"public interface Cursor<T> extends Closeable, Iterable<T> { ... } \",\"可以看到它本身是实现了Iterable接口的，表明它可以获取迭代器或是直接使用foreach来遍历：\",\"Cursor<User> cursor = session.selectCursor(\\\"selectUsers\\\"); for (User user : cursor) { System.out.println(user); } \",\"只不过这种方式在大部分请情况下还是用的比较少，我们主要还是以selectOne和selectList为主。\",\"最后还有一个普通的select方法，它支持我们使用Lambda的形式进行查询结果的处理：\",\"session.select(\\\"selectUsers\\\", context -> { //使用ResultHandler来处理结果 System.out.println(context.getResultObject()); }); \",\"结果会自动进行遍历并依次执行我们传入的Lambda表达式。\"]},\"565\":{\"c\":[\"code\"]},\"566\":{\"c\":[\"javaweb\",\"mybatis\"]},\"567\":{\"h\":\"javaweb - Mybatis4\"},\"568\":{\"h\":\"Mybatis详解2\"},\"569\":{\"h\":\"指定构造方法\",\"t\":[\"(一般不咋用) 通过前面的学习，我们已经知道如何使用Mybatis进行各种查询操作。我们知道，Mybatis在执行完查询语句后，会自动将查询的结果转换为我们所需要的实体类\",\"实际上Mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象，然后通过反射进行赋值，我们可以手动编写一个带调试信息的无参构造：\",\"public User() { System.out.println(\\\"????\\\"); } \",\"alt text\",\"可以看到Mybatis确实调用了我们的无参构造方法来构建对象，属性则是通过反射进行赋值，这里截取部分Mybatis源代码进行演示：\",\"//这里的object就是刚刚构造好的实体类对象，prop是要设置的值的字段信息，value就是要设置的值 private void setBeanProperty(PropertyTokenizer prop, Object object, Object value) { try { //Invoker是Mybatis内部编写一个用于反射设置对象属性值的工具 Invoker method = metaClass.getSetInvoker(prop.getName()); Object[] params = { value }; try { method.invoke(object, params); //通过Invoker为传入的实体类对象赋值 } catch (Throwable t) { throw ExceptionUtil.unwrapThrowable(t); } } catch (Throwable t) { ... } } \",\"由于Mybatis默认情况下直接通过无参构造来创建实体类对象，如果我们的类中存在其他的构造方法覆盖掉默认的无参构造，那么Mybatis会选择可用的构造方法来进行构造。\",\"但是如果存在多个构造方法，Mybatis会出现问题：\",\"@ToString public class User { ... public User(int id) { this.id = id; } public User(String name, int age) { this.name = name; this.age = age; } } \",\"运行时出现错误：\",\"Exception in thread \\\"main\\\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.User matching [java.lang.Integer, java.lang.String, java.lang.Integer] ### The error may exist in file:mappers/TestMapper.xml \",\"此时由于类中存在多个构造方法，而Mybatis不知道该如何选择，那么就会告诉我们找不到合适的构造方法，要解决这种问题也很简单，我们不需要删除这些多余的构造方法，只需添加一个无参构造或是全参构造即可，注意全参构造必须与查询结果字段参数一一对应。\",\"但是注意，Mybatis仅仅是使用这种方式进行对象的构建，而字段的赋值无论是什么构造方法，都会使用反射进行一次赋值：\",\"public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; //这里我们让age在赋值时增加一次 } \",\"我们会发现，就算像这样进行了修改，最终的结果依然是被赋值为数据库中的结果，也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了。\",\"如果需要让Mybatis完全使用构造方法进行对象构建与赋值工作，那么我们需要在XML中手动编写配置，同样需要使用resultMap来完成：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.User\\\"> <constructor> </constructor> </resultMap> \",\"这一次我们在resultMap中添加constructor标签，表示我们的查询结果直接使用指定的构造方法来处理。接着我们需要配置一下constructor里面的内容，使其符合我们指定构造方法的定义，比如现在我们有一个这样的构造方法：\",\"public User(int id, String name) { this.id = id; this.name = name + \\\"同学\\\"; } \",\"那么对应的XML配置编写为，使用arg标签来代表每一个参数，主键可以使用idArg来表示，有助于优化性能：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> </constructor> \",\"注意参数的顺序，必须和构造方法的顺序一致，否则会导致Mybatis无法确认。\",\"指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值。\"]},\"570\":{\"h\":\"接口绑定\",\"t\":[\"之前通过创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，可以用接口来简化\",\"通过namespace来将各种操作绑定到一个接口上，然后使用方法的形式来表示，注意接口的参数和返回值必须正确对应，否则可能会出现问题：\",\"public interface TestMapper { List<Student> selectStudent(); Student selectStuById(int id); List<Student> selectStusBySex(String sex); } \",\"接着将Mapper文件的命名空间修改为我们的接口完整名称：\",\"<mapper namespace=\\\"com.test.mapper.TestMapper\\\"> <select id=\\\"selectStudent\\\" resultType=\\\"Student\\\"> select * from student </select> <select id=\\\"selectStuById\\\" resultType=\\\"Student\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectStusBySex\\\" resultType=\\\"Student\\\"> select * from student where sex = #{sex} </select> </mapper> \",\"这里建议将对应的xml配置也放到放到同包中，作为内部资源：\",\"alt text\",\"作为内部资源后，我们需要修改一下配置文件中的mapper文件目录，不使用url而是resource表示是Jar内部的文件：\",\"<mappers> <mapper resource=\\\"com/test/mapper/TestMapper.xml\\\"/> </mappers> \",\"现在我们可以直接通过SqlSession获取我们编写接口的实现类，这个实现类是由Mybatis根据我们的配置自动生成的，不需要我们做任何事情：\",\"try(SqlSession sqlSession = MybatisUtil.openSession(true)) { TestMapper mapper = sqlSession.getMapper(TestMapper.class); //直接获取实现类 //这里调用我们编写的接口方法 mapper.selectStudent().forEach(System.out::println); } \",\"那肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？\",\"我们可以通过调用getClass()方法来看看实现类是个什么：\",\"TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getClass()); \",\"我们发现，得到的类名称很奇怪class jdk.proxy2.$Proxy4，它其实是通过动态代理生成的，相当于在程序运行过程中动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。\"]},\"571\":{\"h\":\"多参数表示\",\"t\":[\"xml中参数名改为 param1, param2, ...\",\"用注解 @param(xx)\",\"我们接着来看更方便的用法，有些时候，我们的查询操作可能需要不止一个参数：\",\"<select id=\\\"selectUserByIdAndAge\\\" resultType=\\\"com.test.entity.User\\\"> select * from user where id = #{id} and age = #{age} </select> \",\"一种最简单的方式就是和之前一样，我们使用一个Map作为参数，然后将这些参数添加到Map中进行传递：\",\"User selectUserByIdAndAge(Map<String, Object> map); \",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserByIdAndAge(Map.of(\\\"id\\\", 1, \\\"age\\\", 18))); \",\"只不过，这样编写实在是太复杂了，要是由一种更简单的方式就好了，我们也可以直接将这两个参数定义到形参列表中：\",\"User selectUserByIdAndAge(int id, int age); \",\"只不过这种方式查询的话，Mybatis会并不能正确获取对应的参数：\",\"### Cause: org.apache.ibatis.binding.BindingException: Parameter 'id' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) \",\"这是因为Java代码编译后形参名称无法保留，导致Mybatis无法确定具体哪个参数交什么名字，\",\"所以默认情况下它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等，这里id实际上就是param1：\",\"select * from user where id = #{param1} and age = #{param2} \",\"当然，如果你实在需要使用对应的属性名称，我们也可以手动添加一个@Param注解来指定某个参数的名称：\",\"User selectUserByIdAndAge(@Param(\\\"id\\\") int id, @Param(\\\"age\\\") int age); \",\"这样Mybatis就可以正确识别了。\"]},\"572\":{\"c\":[\"code\"]},\"573\":{\"c\":[\"javaweb\",\"mybatis\"]},\"574\":{\"h\":\"javaweb - Mybatis5\"},\"575\":{\"h\":\"Mybatis详解3\"},\"576\":{\"h\":\"复杂查询\"},\"577\":{\"h\":\"一对一查询\",\"t\":[\"首先来看最简单的一对一查询，假设我们每个用户都有一个自己的详细信息表：\",\"alt text\",\"这里的id与用户id一致，作为用户id的逻辑外键，表示对应用户的详细信息。对应的实体类为：\",\"@Data public class UserDetail { int id; String description; Date register; String avatar; } @Data public class User { int id; String name; int age; UserDetail detail; } \",\"现在我们希望查询User时，同时将用户的详细信息包含在内，像这种一对一查询该怎么实现呢？\",\"我们现在同样需要使用resultMap来自定义映射规则\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> </resultMap> \",\"MyBatis 有两种不同的方式加载关联：\",\"嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。\",\"嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。\"]},\"578\":{\"h\":\"嵌套结果映射\",\"t\":[\"我们先来看第一种方式，需要使用关联查询将用户的详细信息一并获取，然后配置关联查询相关信息，最后由Mybatis来对查询的结果进行处理即可.\",\"首先是关联查询的SQL语句，这里我们直接使用左连接：\",\"select * from user left join user_detail on user.id = user_detail.id where user.id = #{id} \",\"alt text\",\"接着我们需要在resultMap编写好对应关系，一对一查询我们可以使用association标签来进行指定，其中property就是需要进行一对一处理的对象\",\"在此标签内部填写需要进行一对一映射的对象属性：\",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" javaType=\\\"UserDetail\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"description\\\" column=\\\"description\\\"/> <result property=\\\"register\\\" column=\\\"register\\\"/> <result property=\\\"avatar\\\" column=\\\"avatar\\\"/> </association> </resultMap> \",\"这里的column和javaType可以不填，Mybatis一般情况下可以自动完成推断，配置完成后，我们在查询时Mybatis就可以自动把额外信息也封装好了：\",\"alt text\"]},\"579\":{\"h\":\"嵌套 Select 查询\",\"t\":[\"们可以在查询user表的时候，同时查询user_detail表的对应信息，分别执行两个选择语句，最后再由Mybatis将其结果合并，效果和第一种方法是一样的：\",\"<select id=\\\"selectUserById\\\" resultMap=\\\"test\\\"> select * from user where id = #{id} </select> <select id=\\\"selectUserDetailById\\\" resultType=\\\"com.test.entity.UserDetail\\\"> select * from user_detail where id = #{id} </select> <resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id property=\\\"id\\\" column=\\\"id\\\"/> <result property=\\\"name\\\" column=\\\"name\\\"/> <result property=\\\"age\\\" column=\\\"age\\\"/> <association property=\\\"detail\\\" column=\\\"id\\\" select=\\\"selectUserDetailById\\\" javaType=\\\"com.test.entity.UserDetail\\\"/> </resultMap> \",\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息，并使用association标签的select属性来指定关联查询操作，得到结果是一样的\"]},\"580\":{\"h\":\"Mybatis日志\",\"t\":[\"我们可以开启Mybatis的日志来观察具体执行的操作，这里我们需要在Mybatis配置文件中添加：\",\"<settings> <setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\"/> </settings> \",\"这样Mybatis运行时就会打印日志到控制台了：\",\"... Opening JDBC Connection Created connection 1962329560. ==> Preparing: select * from user where id = ? ==> Parameters: 1(Integer) <== Columns: id, name, age <== Row: 1, 小明, 18 ====> Preparing: select * from user_detail where id = ? ====> Parameters: 1(Integer) <==== Columns: id, description, register, avatar <==== Row: 1, 我是一个阳光开朗大男孩, 2024-08-16 15:15:03, https://www.baidu.com <==== Total: 1 <== Total: 1 User(id=1, name=小明, age=18, detail=UserDetail(id=1, description=我是一个阳光开朗大男孩, register=Fri Aug 16 15:15:03 CST 2024, avatar=https://www.baidu.com)) Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@74f6c5d8] Returned connection 1962329560 to pool. \",\"Mybatis日志中，==>向右的箭头就是发送给MySQL服务器的SQL语句以及其参数列表，<==向左的箭头就是得到的结果，可以看到这里一共执行了两次SQL语句，分别是user表和user_detail表的查询操作\"]},\"581\":{\"h\":\"一对多查询 (查询一个 - 返回多个)\",\"t\":[\"collection - 实体属性为列表\",\"association - 实体属性为实体类\",\"我们接着来看一对多查询，现在来一个新的表，用于存放用户借阅的图书，对应实体类如下：\",\"@Data public class Book { int bid; String title; } @Data public class User { int id; String name; int age; List<Book> books; //直接得到用户所属的所有书籍信息 } \",\"其中book表设计如下，其中uid作为用户id的逻辑外键，表示这本书是谁借的：\",\"alt text\",\"对于一对多查询，我们也可以进行关联查询来让Mybatis自动解析结果并封装为对象\",\"首先还是关联查询的SQL语句，这里我们让user左连接到book表中：\",\"select * from user left join book on user.id = book.uid where user.id = #{id} \",\"此时由于出现了多行数据，我们需要配置一个collection标签来让其可以正确处理关联的集合结果，Mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中：\",\"<resultMap id=\\\"test\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <collection property=\\\"books\\\" ofType=\\\"com.test.entity.Book\\\"> <id column=\\\"bid\\\" property=\\\"bid\\\"/> <result column=\\\"title\\\" property=\\\"title\\\"/> </collection> </resultMap> \",\"我们需要在resultMap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系，当然这个关系哪怕只写一个Mybatis也可以自动推断其他的，不过建议还是写完整一点\"]},\"582\":{\"h\":\"嵌套查询\",\"t\":[\"此外也可以用 select 嵌套查询来解决，操作是同样的\",\"<select id=\\\"selectStuById\\\" resultMap=\\\"test\\\" parameterType=\\\"_int\\\"> select * from student where sid = #{sid} </select> <select id=\\\"selectBookBySid\\\" resultType=\\\"com.test.entity.Book\\\"> select * from book where uid = #{sid} </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <collection property=\\\"books\\\" select=\\\"selectBookBySid\\\" column=\\\"sid\\\" ofType=\\\"com.test.entity.Book\\\"/> </resultMap> \"]},\"583\":{\"h\":\"多对一查询 (多 - 多)\",\"t\":[\"了解了一对多，那么多对一又该如何查询\",\"比如每个用户现在都有一个小组，但是他们目前都是在同一个小组中，此时我们查询所有用户信息的时候，需要自动携带他们的小组：\",\"alt text\",\"这里我们需要修改一下user表来记录每一个用户所属的小组id，这里使用gid作为分组id的逻辑外键\",\"接着是实体类设计：\",\"@Data public class Group { int id; String name; } @Data public class User { int id; String name; int age; Group group; } \",\"接着就是编写SQL映射，实际上这里跟我们之前的一对一非常类似，我们只需要让查询出来的每一个用户都左连接分组信息即可，这样Mybatis就可以通过association来自动处理了：\",\"select *, groups.name as gname from user left join `groups` on user.gid = groups.id \",\"注意SQL语句中一些字段存在歧义，我们需要手动为其起个别名，接着就是XML编写了：\",\"<select id=\\\"selectAllUser\\\" resultMap=\\\"test2\\\"> select *, groups.name as gname from user left join `groups` on user.gid = groups.id </select> <resultMap id=\\\"test2\\\" type=\\\"com.test.entity.User\\\"> <id column=\\\"id\\\" property=\\\"id\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"age\\\" property=\\\"age\\\"/> <association property=\\\"group\\\"> <id column=\\\"gid\\\" property=\\\"id\\\"/> <result column=\\\"gname\\\" property=\\\"name\\\"/> </association> </resultMap> \",\"这样我们就可以成功实现多对一查询了，这与之前的一对一比较类似。\",\"当然，也可以嵌套select\",\"<select id=\\\"selectStudent\\\" resultMap=\\\"test\\\"> select * from student </select> <resultMap id=\\\"test\\\" type=\\\"Student\\\"> <id column=\\\"sid\\\" property=\\\"sid\\\"/> <result column=\\\"name\\\" property=\\\"name\\\"/> <result column=\\\"sex\\\" property=\\\"sex\\\"/> <association property=\\\"group\\\" select=\\\"selectGroup\\\" column=\\\"gid\\\" javaType=\\\"com.test.entity.Group\\\"/> </resultMap> <select id=\\\"selectGroup\\\" resultType=\\\"com.test.entity.Group\\\"> select * from `group` where gid = #{gid} </select> \"]},\"584\":{\"c\":[\"code\"]},\"585\":{\"c\":[\"javaweb\",\"mybatis\"]},\"586\":{\"h\":\"javaweb - Mybatis6\"},\"587\":{\"h\":\"Mybatis详解4\"},\"588\":{\"h\":\"DML 操作\",\"t\":[\"前面我们介绍了查询操作，我们接着来看修改相关操作(增、删、改)。\",\"Mybatis为我们的DML操作提供了几个预设方法：\",\"int insert(String statement); int insert(String statement, Object parameter); int update(String statement); int update(String statement, Object parameter); int delete(String statement); int delete(String statement, Object parameter); \",\"可以看到，这些方法默认情况下返回的结果都是int类型的，这与我们之前JDBC中是一样的，它代表执行SQL后受影响的行数。\"]},\"589\":{\"h\":\"插入 标签\",\"t\":[\"我们来尝试编写一个插入操作\",\"Mybatis为我们提供的插入操作非常快捷，我们可以直接让一个User对象作为参数传入\",\"即可在配置中直接解析其属性到insert语句中，这里需要用到insert标签：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里我们将parameterType类型设置为我们的实体类型，这样下面在使用#{name}时Mybatis就会自动调用类中对应的Get方法来获取结果\",\"不过，即使这里不指定具体类型，Mybatis也能完成自动推断，非常智能(参数名称要与实体类参数对应)。\",\"和之前一样，我们也可以直接将其绑定到一个接口上：\",\"public interface TestMapper { int addUser(User user); } \",\"注意返回类型必须是int或是long这类数字类型，表示生效的行数，然后这里我们传入的参数直接写成对应的类型即可。\"]},\"590\":{\"h\":\"自增主键ID\",\"t\":[\"有些时候，我们的数据插入后使用的是一个自增主键ID，那么这个自增的主键值我们该如何获取到呢？\",\"Mybatis为我们提供了一些参数用于处理这种问题：\",\"<insert id=\\\"addUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这里useGeneratedKeys设置为true表示我们希望获取数据库生成的键\",\"keyProperty设置为User类中的需要获取自增结果的属性名，keyColumn为数据库中自增的字段名称\",\"但是一般情况下不需要手动设置，但是某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，必须设置。\",\"这样我们就可以获取到自增后的值了，接着我们什么都不需要做，Mybatis会在查询完后自动为我们的User对象赋值：\"]},\"591\":{\"h\":\"修改 标签\",\"t\":[\"我们接着来看修改操作，比如要根据ID修改用户的年龄：\",\"<update id=\\\"setUserAgeById\\\"> update user set age = #{age} where id = #{id} </update> \",\"int setUserAgeById(User user); \",\"这里的参数我们依然选择使用User，和之前insert一样，Mybatis会从传入的对象中自动获取需要的参数，当然我们也可以将此方法设计为两个参数的形式：\",\"int setUserAgeById(@Param(\\\"age\\\") int age, @Param(\\\"id\\\") int id); \"]},\"592\":{\"h\":\"删除\",\"t\":[\"删除操作则更为简单，假设我们要根据用户的id进行数据的删除：\",\"<delete id=\\\"deleteUserById\\\"> delete from user where id = #{id} </delete> \",\"这些操作相比查询操作来说非常简单就可以实现，这里就不多做介绍了。\"]},\"593\":{\"h\":\"事务操作\",\"t\":[\"我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多\",\"在创建SqlSession的时候不填写参数默认使用的就是事务模式：\",\"try (SqlSession session = sqlSessionFactory.openSession(false)) { ... } \",\"我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的：\",\"try(SqlSession session = MybatisUtils.openSession(false)) { TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); //虽然日志中已经提示生效1行，但是并没有提交 } \",\"SqlSession接口中为我们提供了事务操作相关的方法，这里我们可以直接尝试进行事务的提交：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(7); session.commit(); //通过SqlSession进行事务提交 \",\"注意，如果我们在提交事务之前，没有进行任何的DML操作，也就是删除、更新、插入的其中任意一种操作，那么调用commit方法则不会进行提交，当然如果仍然需要提交的话也可以使用commit(true)来强制提交。\",\"我们接着来测试一下回滚操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); mapper.deleteUserById(1); System.out.println(mapper.selectUserById(1)); //此时由于数据被删除，无法查到 session.rollback(); //进行回滚操作 System.out.println(mapper.selectUserById(1)); //之前被删除的数据回来了 \",\"事务相关操作非常简单，这里就暂时先介绍这么多。\"]},\"594\":{\"c\":[\"code\"]},\"595\":{\"c\":[\"javaweb\",\"mybatis\"]},\"596\":{\"h\":\"javaweb - Mybatis7\"},\"597\":{\"h\":\"Mybatis详解5\"},\"598\":{\"h\":\"动态SQL\"},\"599\":{\"h\":\"批处理\",\"t\":[\"在之前JDBC讲解的时候，我们就提到过批量执行语句的问题，当我们要执行很多条语句时，可能会一个一个地提交：\",\"//现在要求把下面所有用户都插入到数据库中 List<String> users = List.of(\\\"小刚\\\", \\\"小强\\\", \\\"小王\\\", \\\"小美\\\", \\\"小黑子\\\"); //使用for循环来一个一个执行insert语句 for (String user : users) { statement.executeUpdate(\\\"insert into user (name, age) values ('\\\" + user + \\\"', 18)\\\"); } \",\"虽然这样看似非常完美，也符合逻辑，但是实际上我们每次执行SQL语句，都像是去厨房端菜到客人桌上一样，我们每次上菜的时候只从厨房端一个菜，效率非常低\",\"但是如果我们每次上菜推一个小推车装满N个菜一起上，效率就会提升很多，而数据库也是这样，我们每一次执行SQL语句，都需要一定的时间开销\",\"但是如果我把这些任务合在一起告诉数据库，效率会截然不同：\",\"alt text\",\"可见，使用循环操作执行数据库相关操作实际上非常耗费资源，不仅带来网络上的额外开销，还有数据库的额外开销\",\"更推荐使用批处理来优化这种情况，一次性提交一个批量操作给数据库。\",\"需要在Mybatis中开启批处理，我们只需要在创建SqlSession时进行一些配置即可：\",\"factory.openSession(ExecutorType.BATCH, autoCommit); \",\"在使用openSession时直接配置ExecutorType为BATCH即可，这样SqlSession会开启批处理模式，在多次处理相同SQL时会尽可能转换为一次执行，开启批处理后，无论是否处于事务模式下，我们都需要flushStatements()来一次性提交之前是所有批处理操作：\",\"TestMapper mapper = session.getMapper(TestMapper.class); for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } session.flushStatements(); \",\"此时日志中可以看到Mybatis在尽可能优化我们的SQL操作：\",\"alt text\"]},\"600\":{\"h\":\"动态SQL介绍\",\"t\":[\"除了使用批处理之外，Mybatis还为我们提供了一种更好的方式来处理这种问题，我们可以使用动态SQL来一次性生成一个批量操作的SQL语句\",\"动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\",\"简单来说，动态SQL在执行时可以进行各种条件判断以及循环拼接等操作，极大地提升了SQL语句编写的的灵活性。\"]},\"601\":{\"h\":\"条件判断 标签\",\"t\":[\"在编写SQL时，我们可以添加一些用于条件判断的标签到XML的SQL语句中\",\"比如我们希望在根据ID查询用户时，如果查询的ID大于3，那么必须同时要满足大于18岁这个条件，这看似是一个很奇怪的查询条件，此时动态SQL就能很轻松实现这个操作：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",\"如果不满足，那么就不拼接里面的内容到原本的SQL中，其中test属性就是我们需要填写的判断条件，它采用OGNL表达式进行编写，语法与Java比较相似\",\"详细了解: https://commons.apache.org/dormant/commons-ognl/\",\"当我们查询条件不同时，Mybatis会选择性拼接我们的SQL语句\"]},\"602\":{\"h\":\"选择判断\",\"t\":[\"除了if操作之外，Mybatis还针对多分支情况提供了choose操作，它类似于Java中的switch语句\",\"比如现在我们希望在查询用户时，ID等于1的必须同时要满足小于18岁，ID等于2的必须满足等于18岁，其他情况的必须满足大于18岁(这需求有点抽象)\",\"我们可以像这样进行编写：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <choose> <when test=\\\"id == 1\\\"> and age &lt;= 18 </when> <when test=\\\"id == 2\\\"> and age = 18 </when> <otherwise> and age > 18 </otherwise> </choose> </select> \",\"注意在when中不允许使用<或是>这种模糊匹配的条件(实际运行好像是可以的)。\"]},\"603\":{\"h\":\"实现批量处理\",\"t\":[\"foreach操作，它与Java中的for类似，可以实现批量操作，这非常适合处理我们前面说的批量执行SQL的问题：\"]},\"604\":{\"h\":\"批量删除\",\"t\":[\"for (int i = 1; i <= 5; i++) { mapper.deleteUserById(i); } \",\"但是实际上这种情况完全可以简写为一个SQL语句：\",\"DELETE FROM users WHERE id IN (1, 2, 3, 4, 5); \",\"使用foreach来完成它就很简单了：\",\"<delete id=\\\"deleteUsers\\\"> delete from user where id in <foreach collection=\\\"list\\\" item=\\\"item\\\" index=\\\"index\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\"> #{item} </foreach> </delete> \",\"其中:\",\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称，即我们在JAVA中所传给他的值\",\"open和close用于控制起始和结束位置添加的符号\",\"separator用于控制分隔符\",\"现在执行以下操作：\",\"session.delete(\\\"deleteUsers\\\", List.of(1, 2, 3, 4, 5)); \",\"最后实际执行的SQL为：\",\"alt text\"]},\"605\":{\"h\":\"批量插入\",\"t\":[\"我们再来看一个例子，比如现在我们想要批量插入一些用户到数据库里面，原本Java应该这样写，但是这是一种极其不推荐的做法：\",\"TestMapper mapper = session.getMapper(TestMapper.class); List<User> users = List.of(new User(\\\"小美\\\", 17), new User(\\\"小张\\\", 18), new User(\\\"小刘\\\", 19)); for (User user : users) { mapper.insertUser(user); } \",\"实际上这种操作完全可以浓缩为一个SQL语句：\",\"INSERT INTO user (name, age) VALUES ('小美', 17), ('小张', 18), ('小刘', 19); \",\"那这时又可以直接使用咱们的动态SQL来完成操作了：\",\"<insert id=\\\"insertAllUser\\\"> insert into user (name, age) values <foreach collection=\\\"list\\\" item=\\\"item\\\" separator=\\\",\\\"> (#{item.name}, #{item.age}) </foreach> </insert> \",\"alt text\",\"通过使用动态SQL语句，我们基本上可以解决大部分的SQL查询和批量处理场景了。\"]},\"606\":{\"c\":[\"code\"]},\"607\":{\"c\":[\"javaweb\",\"mybatis\"]},\"608\":{\"h\":\"javaweb - Mybatis8\"},\"609\":{\"h\":\"Mybatis详解6\"},\"610\":{\"h\":\"缓存机制\",\"t\":[\"其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高，缓存的概念在我们后续的学习中还会经常遇见，它也是现在提高数据获取效率的良好解决方案。\",\"Mybatis为了查询效率，同样内置了一个缓存机制，我们在查询时，如果Mybatis缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求，节省性能开销。\",\"alt text\",\"Mybatis的缓存机制有些复杂，存在一级缓存(本地缓存)和二级缓存\"]},\"611\":{\"h\":\"一级缓存 (作用在 )\",\"t\":[\"我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，也就是一级缓存，它仅仅对一个会话中的数据进行缓存（一级缓存强制启用，无法关闭，只能做调整）\",\"也就是每一个SqlSession都有有一个对应的缓存\",\"我们来看看下面这段代码：\",\"TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectUserById(1)); System.out.println(mapper.selectUserById(1)); //再次获取 \",\"这里我们连续获取了两次ID为1的用户，我们会在日志中惊奇地发现，这里的查询操作实际上只进行了一次：\",\"alt text\",\"我们去掉类上的@Data注解，会发现得到的两个对象实际上就是同一个：\",\"alt text\",\"也就是说我们第二次查询不仅压根就没执行SQL语句，甚至直接没有重新构造对象，而是直接获取之前创建好的。\",\"可见，Mybatis确实存在着缓存机制来进行性能优化。\",\"那么如果我修改了数据库中的内容，缓存还会生效吗：\",\"System.out.println(mapper.selectUserById(1)); mapper.updateAgeById(1, 19); System.out.println(mapper.selectUserById(1)); \",\"此时由于我们更新了数据库中的数据，那么之前缓存的内容也会跟着失效，第二次获取的时候会进行重新查询。\",\"也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。\",\"但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。\",\"因此， 一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，我们可以来试验一下：\",\"try(SqlSession s1 = MybatisUtils.openSession(true); SqlSession s2 = MybatisUtils.openSession(true)) { TestMapper m1 = s1.getMapper(TestMapper.class); TestMapper m2 = s2.getMapper(TestMapper.class); System.out.println(m1.selectUserById(1)); m2.updateAgeById(1, 19); System.out.println(m1.selectUserById(1)); } \",\"可以看到，会话1在重复查询数据时，即使会话2已经修改了数据，但是依然没有影响会话1之中的缓存。\",\"这导致尽管会话2更新了数据，但是会话1中的数据是从缓存得到的，没有更新。\",\"一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，无论哪个会话对于数据的查询缓存都可以直接被所有会话使用。\"]},\"612\":{\"h\":\"二级缓存 (作用在 )\",\"t\":[\"我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加：\",\"<cache/> \",\"二级缓存是Mapper级别的，只要是使用这个Mapper的会话，都会关联到这个二级缓存\",\"无论哪个会话失效，它之前查询的缓存依然会存在于二级缓存中，依然可以被其他会话直接使用。\",\"我们可以对cache标签进行一些配置：\",\"<cache eviction=\\\"FIFO\\\" flushInterval=\\\"60000\\\" size=\\\"512\\\" readOnly=\\\"true\\\"/> \",\"其中，size表示最大的缓存对象数量，当缓存达到上限时，会根据eviction配置的策略进行清理：\",\"LRU – 最近最少使用：移除最长时间不被使用的对象。\",\"FIFO – 先进先出：按对象进入缓存的顺序来移除它们。\",\"SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。\",\"WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\",\"flushInterval用于控制缓存刷新时间，当到达指定时间时会自动清理所有缓存，默认情况下如果不配置此项则不会进行定时清理。\",\"readOnly（只读）属性可以被设置为 true 或 false，只读的缓存会给所有调用者返回相同的缓存对象，且对象不能被修改。这就提供了可观的性能提升。\",\"而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。\",\"注意： 二级缓存是事务性的，这意味着，当 SqlSession 结束并提交时，或是结束并回滚，而且没有执行 flushCache=true 的 insert/delete/update 语句时，二级缓存才会被更新。\",\"即：\",\"try(SqlSession session = MybatisUtil.getSession(true); SqlSession session2 = MybatisUtil.getSession(true) ){ TestMapper mapper = session.getMapper(TestMapper.class); System.out.println(mapper.selectStuById(1)); session2.commit(); TestMapper mapper2 = session2.getMapper(TestMapper.class); System.out.println(mapper2.selectStuById(1)); } \",\"只有commit了，才会保存在二级缓存，这样用mapper2时，才不会重新读取，如果没有commit，就会重新读取，因为并没有保存在缓存中\",\"开启二级缓存后，再次执行我们之前的操作，就可以直接在二级缓存中命中了：\",\"alt text\"]},\"613\":{\"h\":\"查找顺序\",\"t\":[\"实际上，添加了二级缓存之后，Mybatis会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库。\"]},\"614\":{\"h\":\"单独配置取消二级缓存\",\"t\":[\"当我们开启二级缓存后，默认情况下一个Mapper中所有的操作都会使用二级缓存\",\"我们也可以单独配置其不使用二级缓存，只需要修改useCache属性即可：\",\"<select id=\\\"selectUserById\\\" useCache=\\\"false\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \"]},\"615\":{\"h\":\"操作结束，清除所有缓存\",\"t\":[\"有些操作可能比较特殊，比如我们希望某个操作执行完成后，直接清除所有缓存，无论是一级缓存还是二级缓存，那么此时就可以开启flushCache属性：\",\"<select id=\\\"selectUserById\\\" flushCache=\\\"true\\\" resultType=\\\"com.test.User\\\"> select * from user where id = #{id} </select> \",\"开启此选项后，调用此操作将直接导致一级和二级缓存被清除。\"]},\"616\":{\"h\":\"缓存一致性问题\",\"t\":[\"虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题\",\"当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题。\",\"alt text\",\"而Mybatis也会这样，我们来看看这个例子：\",\"TestMapper mapper = session.getMapper(TestMapper.class); while (true){ Thread.sleep(3000); System.out.println(mapper.selectUserById(1)); } \",\"我们现在循环地每三秒读取一次，而在这个过程中，我们使用其他软件手动修改数据库中的数据，将1号用户的ID改成100，那么理想情况下，下一次读取将直接无法获取到这行数据，因为ID已经发生变化了。\",\"但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的\",\"因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题\",\"我们只能关闭所有二级缓存，并且在Mybatis每个操作都配置flushCache为true来保证刷新。\",\"只不过这种操作实际上是治标不治本的，实现多服务器缓存共用才是最终解决方案，也就是让所有的Mybatis都使用同一个缓存进行数据存取\",\"在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。\"]},\"617\":{\"c\":[\"code\"]},\"618\":{\"c\":[\"javaweb\",\"mybatis\"]},\"619\":{\"h\":\"javaweb - Mybatis9\"},\"620\":{\"h\":\"Mybatis详解7\"},\"621\":{\"h\":\"使用注解开发\",\"t\":[\"在之前的学习中，我们已经体验到Mybatis为我们带来的便捷了\",\"我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。\",\"那么，能否实现无需XML映射器配置，而是直接使用注解在接口上进行配置呢？\",\"我们可以直接删除掉所有的Mapper.xml文件了，只保留Mapper相关的接口。\",\"现在，我们来尝试以全注解的形式重现编写咱们的SQL语句映射\"]},\"622\":{\"h\":\"调整\",\"t\":[\"还是以查询所有的用户为例，既然现在不需要配置Mapper.xml文件了，那么我们现在需要重写在Mybatis的配置文件中进行mapper的配置\",\"因为现在只需要使用接口来进行配置\",\"所以使用package标签来指定一个包，包下所有的接口都将直接作为Mapper配置接口：\",\"<mappers> <package name=\\\"com.test.mapper\\\"/> </mappers> \",\"或者还是mapper标签通过class属性来指定具体的接口：\",\"<mappers> <mapper class=\\\"com.test.mapper.TestMapper\\\"/> </mappers> \"]},\"623\":{\"h\":\"修改对应接口+注解\",\"t\":[\"现在我们还是在Mapper中添加一个对应的方法用于执行：\",\"public interface TestMapper { List<User> selectAllUser(); } \",\"之前我们需要像这样编写：\",\"<select id=\\\"selectAllUser\\\" resultType=\\\"com.test.User\\\"> select * from user </select> \"]},\"624\":{\"h\":\"举例\",\"t\":[\"现在只需要一个注解即可，Mybatis为我们提供了丰富的注解用于表示不同SQL语句类型\",\"这里的@Select代表的就是select标签，我们只需要直接在其中编写SQL语句即可，而返回类型Mybatis会自动根据方法的返回值进行判断：\",\"public interface TestMapper { @Select(\\\"select * from user\\\") List<User> selectAllUser(); } \",\"QQ_1724143033753\",\"包括一些SQL语句参数的使用也是和之前完全一样，比如插入一个用户：\",\"@Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \"]},\"625\":{\"h\":\"配置这些额外的参数\",\"t\":[\"虽然Mybatis为我们提供了之前XML配置中各种操作的对应注解，但是我们发现，这些注解并不能像之前XML那样直接修改一些属性\",\"比如我们希望配置useGeneratedKeys来得到自动生成的主键，从而修改我们对应的实体类\",\"需要配置这些额外的参数，我们可以使用@Options注解：\",\"@Options(useGeneratedKeys = true, keyColumn = \\\"id\\\", keyProperty = \\\"id\\\") @Insert(\\\"insert into user (name, age) values (#{name}, #{age})\\\") int insertUser(User user); \",\"<insert id=\\\"insertUser\\\" parameterType=\\\"com.test.entity.User\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\" keyColumn=\\\"id\\\"> insert into user (name, age) values (#{name}, #{age}) </insert> \",\"这两种写法效果是完全一样的，Mybatis在插入后，会将我们当前的实体类对象的id修改为得到的id\",\"Student student = new Student().setName(\\\"abc\\\").setSex(\\\"女\\\"); mapper.insertStudent(student); System.out.println(student); \",\"alt text\",\"所以我们通过Mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置。\"]},\"626\":{\"h\":\"实体类字段名称与数据库不同\",\"t\":[\"假如现在我们的实体类字段名称与数据库不同，此时该如何像之前一样配置resultMap呢？\",\"public class User { int uid; String username; int age; } \",\"<resultMap id=\\\"test\\\" type=\\\"User\\\"> <id property=\\\"id\\\" column=\\\"uid\\\"/> <result column=\\\"name\\\" property=\\\"username\\\"/> </resultMap> \",\"我们可以使用@Results注解来实现这种操作，它的使用方式与resultMap几乎没什么区别：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"uid\\\"), @Result(column = \\\"name\\\", property = \\\"username\\\") }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"627\":{\"h\":\"结合 配置\",\"t\":[\"当然，如果你还是觉得这种方式配置起来不如之前方便，那么你也可以单独在XML中配置一个resultMap\",\"然后直接通过注解的形式引用：\",\"@ResultMap(\\\"test\\\") @Select(\\\"select * from user\\\") List<User> selectAllUser(); \"]},\"628\":{\"h\":\"指定构造方法\",\"t\":[\"那么现在如果我们需要指定使用的构造方法怎么办呢？就像我们之前在使用constrator标签一样\",\"Mybatis为我们提供了@ConstructorArgs注解，配置方式和之前几乎一致：\",\"public class User { int id; String name; int age; public User(int id, String name, int age) { this.id = id; this.name = name; this.age = age + 20; } } \",\"@ConstructorArgs({ @Arg(id = true, column = \\\"id\\\", javaType = int.class), @Arg(column = \\\"name\\\", javaType = String.class), @Arg(column = \\\"age\\\", javaType = int.class) }) @Select(\\\"select * from user\\\") List<User> selectAllUser(); \",\"这与我们之前的XML配置完全一致：\",\"<constructor> <idArg column=\\\"id\\\" javaType=\\\"_int\\\"/> <arg column=\\\"name\\\" javaType=\\\"String\\\"/> <arg column=\\\"age\\\" javaType=\\\"_int\\\"/> </constructor> \"]},\"629\":{\"h\":\"关联查询 (注解只支持嵌套查询)\",\"t\":[\"我们再来看看之前在resultMap中配置的关联查询该如何编写，Mybatis也为我们提供了丰富的注解用于处理这类问题，我们首先来看看一对一查询：\",\"@Results({ @Result(id = true, column = \\\"id\\\", property = \\\"id\\\"), @Result(column = \\\"id\\\", property = \\\"detail\\\", one = @One(select = \\\"selectDetailById\\\")) }) @Select(\\\"select * from user where id = #{id};\\\") User selectUserById(int id); @Select(\\\"select * from user_detail where id = #{id}\\\") UserDetail selectDetailById(int id); \",\"我们在配置@Result注解时，只需要将one或是many参数进行填写即可，它们分别代表一对一关联和一对多关联\",\"使用@One和@Many注解来指定其他查询语句进行嵌套查询，就像是我们之前使用association和collection那样。\",\"不过很遗憾的是，我们无法完全通过注解来实现之前的联合查询解析（这是因为 Java 注解不允许循环引用）\",\"只能使用这种嵌套查询来完成复杂查询操作，因此，如果对这种复杂查询有着一定需求的话，建议使用之前的XML方式进行配置。\"]},\"630\":{\"h\":\"动态 配置 ( 注解)\",\"t\":[\"我们还可以使用注解进行动态SQL的配置\",\"比如现在我们想要实现之前的这个奇葩需求：\",\"<select id=\\\"selectUserById\\\" resultType=\\\"User\\\"> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </select> \",\"Mybatis针对于所有的SQL操作都提供了对应的Provider注解，用于配置动态SQL\",\"我们需要先创建一个类编写我们的动态SQL操作：\",\"public class TestSqlBuilder { public static String buildGetUserById(int id) { return new SQL(){{ //SQL类中提供了常见的SELECT、FORM、WHERE等操作 SELECT(\\\"*\\\"); FROM(\\\"user\\\"); WHERE(\\\"id = #{id}\\\"); if (id > 3) { WHERE(\\\"age > 18\\\"); } }}.toString(); } } \",\"详细的SQL语句构建器语法文档：https://mybatis.org/mybatis-3/zh_CN/statement-builders.html\",\"构建完成后，接着我们就可以使用@SelectProvider来引用这边编写好的动态SQL操作：\",\"@SelectProvider(type = TestSqlBuilder.class, method = \\\"buildGetUserById\\\") User selectUserById(int id); \",\"效果和之前我们编写XML形式的动态SQL一致\",\"当然，如果遇到了多个参数的情况，我们同样需要使用@Param来指定参数名称，包括TestSqlBuilder中编写的方法也需要添加，否则必须保证形参列表与这边接口一致。\",\"虽然这样可以实现和之前差不多的效果，但是这实在是太过复杂了，我们还需要单独编写一个类来做这种事情\",\"实际上我们也可以直接在@Select中编写一个XML配置动态SQL，Mybatis同样可以正常解析：\",\"@Select(\\\"\\\"\\\" <script> select * from user where id = #{id} <if test=\\\"id > 3\\\"> and age > 18 </if> </script> \\\"\\\"\\\") User selectUserById(int id); \",\"这里只需要包括一个script标签我们就能像之前XML那样编写动态SQL了，只不过由于IDEA不支持这种语法的识别，可能会出现一些莫名其妙的红标，但是是可以正常运行的。\"]},\"631\":{\"h\":\"二级缓存配置\",\"t\":[\"最后我们来看一下二级缓存相关的配置，使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用：\",\"@CacheNamespace(size = 512, readWrite = false) public interface TestMapper {} \",\"我们如果需要控制单个方法的缓存，同样可以使用@Option来进行配置：\",\"@Options(flushCache = Options.FlushCachePolicy.TRUE, useCache = false) @Select(\\\"select * from user where id = #{id}\\\") User selectUserById(int id); \"]},\"632\":{\"h\":\"\",\"t\":[\"这里我们不如再做的更加极致一点，咱们把配置文件也给变成代码配置，彻底抛弃XML配置\",\"实际上我们的XML配置中所有配置项都可以以Configuration对象的形式进行配置，最后在构造SqlSessionFactory时也可以通过此对象进行创建：\",\"sqlSessionFactory = new SqlSessionFactoryBuilder().build(initConfiguration()); private static Configuration initConfiguration() { Configuration configuration = new Configuration(); PooledDataSource dataSource = new PooledDataSource( \\\"com.mysql.cj.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/web_study\\\", \\\"test\\\", \\\"123456\\\"); Environment environment = new Environment(\\\"development\\\", new JdbcTransactionFactory(), dataSource); configuration.setEnvironment(environment); configuration.getTypeAliasRegistry().registerAliases(\\\"com.test.entity\\\"); configuration.setLogImpl(StdOutImpl.class); configuration.addMappers(\\\"com.test.mapper\\\"); return configuration; } \",\"有关Mybatis的基本使用，我们就暂时介绍到这里。\"]},\"633\":{\"c\":[\"code\"]},\"634\":{\"c\":[\"javaweb\",\"mybatis\"]},\"635\":{\"h\":\"javaweb - JUL日志1\"},\"636\":{\"h\":\"JUL日志系统\",\"t\":[\"JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单：\",\"public class Main { public static void main(String[] args) { // 首先获取日志打印器，名称随意 Logger logger = Logger.getLogger(\\\"test\\\"); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\\\"我是普通的日志\\\"); } } \",\"我们可以在主类中使用日志打印，得到日志的打印结果：\",\"十一月 15, 2021 12:55:37 下午 com.test.Main main 信息: 我是普通的日志 \",\"我们发现，通过日志输出的结果会更加规范，在后续的学习中，日志将时刻伴随我们左右。\"]},\"637\":{\"h\":\"JUL基本使用\",\"t\":[\"日志的打印并不是简单的输出，有些时候我们可以会打印一些比较重要的日志信息，或是一些非常紧急的日志信息，根据不同类型的信息进行划分\"]},\"638\":{\"h\":\"级别划分\",\"t\":[\"日志一般分为7个级别，详细信息我们可以在Level类中查看：\",\"public class Level implements java.io.Serializable { ... //出现严重故障的消息级别，值为1000，也是可用的日志级别中最大的 public static final Level SEVERE = new Level(\\\"SEVERE\\\",1000, defaultBundle); //存在潜在问题的消息级别，比如边充电边打电话就是个危险操作，虽然手机爆炸的概率很小，但是还是会有人警告你最好别这样做，这是日志级别中倒数第二大的 public static final Level WARNING = new Level(\\\"WARNING\\\", 900, defaultBundle); //所有常规提示日志信息都以INFO级别进行打印 public static final Level INFO = new Level(\\\"INFO\\\", 800, defaultBundle); //以下日志级别依次降低，不太常用 public static final Level CONFIG = new Level(\\\"CONFIG\\\", 700, defaultBundle); public static final Level FINE = new Level(\\\"FINE\\\", 500, defaultBundle); public static final Level FINER = new Level(\\\"FINER\\\", 400, defaultBundle); public static final Level FINEST = new Level(\\\"FINEST\\\", 300, defaultBundle); ... } \",\"之前通过info方法直接输出的结果就是使用的默认级别的日志，实际上每个级别都有一个对应的方法用于打印：\",\"public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.severe(\\\"severe\\\"); //最高日志级别 logger.warning(\\\"warning\\\"); logger.info(\\\"info\\\"); //默认日志级别 logger.config(\\\"config\\\"); logger.fine(\\\"fine\\\"); logger.finer(\\\"finer\\\"); logger.finest(\\\"finest\\\"); //最低日志级别 } \"]},\"639\":{\"h\":\"自定义级别设置\",\"t\":[\"当然，如果需要更加灵活地控制日志级别\",\"我们也可以通过log方法来主动设定该条日志的输出级别：\",\"Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \\\"严重的错误\\\", new NullPointerException(\\\"祝你明天就遇到我\\\")); logger.log(Level.WARNING, \\\"警告的内容\\\"); logger.log(Level.INFO, \\\"普通的信息\\\"); logger.log(Level.CONFIG, \\\"级别低于普通信息\\\"); \",\"Logger默认情况下只会打印INFO级别以上的日志，而INFO级别以下的日志则会直接省略，我们可以通过配置来进行调整。\"]},\"640\":{\"h\":\"修改日志的默认打印级别\",\"t\":[\"我们知道日志的默认打印级别为INFO，此时低于INFO的所有日志都是被屏蔽的，而要修改日志的默认打印级别，我们需要同时调整Handler和Logger的level属性：\",\"handler.setLevel(Level.FINEST); //注意，填写的日志打印级别是什么，高于等于此级别的所有日志都会被打印 logger.setLevel(Level.FINEST); logger.fine(\\\"Hello World\\\"); \",\"现在我们再次打印低于INFO级别的日志就可以正确得到结果了。\",\"Logger类还为我们提供了两个比较特殊的日志级别，它们专门用于配置特殊情况：\",\"//表示直接关闭所有日志信息，值为int的最大值 public static final Level OFF = new Level(\\\"OFF\\\",Integer.MAX_VALUE, defaultBundle); //表示开启所有日志信息，无论是什么级别都进行打印 public static final Level ALL = new Level(\\\"ALL\\\", Integer.MIN_VALUE, defaultBundle); \",\"因为这这里OFF的值为int的最大值，也就是说没有任何日志级别的值大于它，因此，如果将打印等级配置为OFF，那么所有类型的日志信息都不会被打印了，而ALL则相反。\"]},\"641\":{\"c\":[\"code\"]},\"642\":{\"c\":[\"javaweb\",\"JUL\"]},\"643\":{\"h\":\"javaweb - JUL日志2\"},\"644\":{\"h\":\"JUL日志系统2\"},\"645\":{\"h\":\"日志核心内容\"},\"646\":{\"h\":\"核心部分\",\"t\":[\"日志打印的核心部分：Handler，它用于处理我们的日志内容打印\",\"ConsoleHandler | FileHandler | SocketHandler\",\"JDK为我们提供了很多种类的Handler用于多种不同类型的日志打印，比较常见的就是打印到控制台，当然我们也可以打印到一个日志文件中，名字一般为xxx.log这种格式。\",\"常用的Handler实现有：\",\"ConsoleHandler: 将日志通过System. err打印到控制台，现在默认就是使用的这个。\",\"FileHandler: 将日志直接写入到指定的文件中。\",\"SocketHandler: 将日志利用Socket通过网络发送到另一个主机。\",\"当然，一个Logger中可以包含多个Handler用于同时向不同的地方打印日志，我们可以通过getHandlers方法来获取Logger对象中已经配置的Handler对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(Arrays.toString(logger.getHandlers())); \",\"此时打印的列表中不存在任何Handler对象，可见，我们创建的Logger默认是不带任何Handler对象的\",\"那么我们之前的日志是怎么打印出来的呢？这实际上是Logger的父级提供的，这里我们先暂时不介绍继承关系。\",\"我们使用setUseParentHandlers方法来屏蔽所有父级提供的日志处理器：\",\"logger.setUseParentHandlers(false); \",\"现在由于Logger没有配置任何Handler处理器，因此我们打印日志就不会有任何效果。\"]},\"647\":{\"h\":\"\",\"t\":[\"我们可以来尝试自己配置一个用于控制台打印的Handler处理器，这里直接创建一个新的ConsoleHandler对象：\",\"ConsoleHandler handler = new ConsoleHandler(); logger.addHandler(handler); logger.info(\\\"Hello World\\\"); \",\"现在我们打印日志就可以出现想要的结果了：\",\"8月 28, 2024 12:12:37 上午 com.test.Main main 信息: Hello World \"]},\"648\":{\"h\":\"\",\"t\":[\"我们接着来尝试将日志记录到我们本地的文件中，这里使用FileHandler类型：\",\"FileHandler handler = new FileHandler(\\\"test.log\\\", true); //第二个参数开启后会续写已有的日志，如果不开启会直接覆盖重写 logger.addHandler(handler); \",\"最后我们就可以得到一个日志文件了，默认是以XML格式进行写入的：\",\"alt text\",\"这种格式有助于程序的日志读取，但是对于我们人来说，非常难以阅读，那有没有什么办法将文件的日志打印变成控制台那种格式呢？\"]},\"649\":{\"h\":\"修改输出格式\",\"t\":[\"实际上每一个Handler都有一个Formatter对象，它用于控制日志的格式，默认情况下，ConsoleHandler会配置一个SimpleFormatter对象，格式为：\",\"时间 类名 方法 日志级别: 日志内容 \",\"我们刚刚在FileHandler中见到的是默认生成的XMLFormatter，它会将日志以XML的形式进行打印，现在我们也可以手动修改它为SimpleFormatter类型：\",\"Handler handler = new FileHandler(\\\"test.log\\\"); handler.setFormatter(new SimpleFormatter()); \",\"此时日志文件中写入的内容就是简单的日志格式了\\n\"]},\"650\":{\"c\":[\"code\"]},\"651\":{\"c\":[\"javaweb\",\"JUL\"]},\"652\":{\"h\":\"javaweb - JUL日志3\"},\"653\":{\"h\":\"JUL日志系统3\"},\"654\":{\"h\":\"日志继承关系\"},\"655\":{\"h\":\"\",\"t\":[\"JUL中Logger之间存在父子关系，这种父子关系类似于继承，我们可以通过Logger的getParent方法来获取其父Logger对象：\",\"Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent()); \",\"这里我们会得到一个：\",\"java.util.logging.LogManager$RootLogger@24d46ca6 \",\"这个RootLogger对象为所有日志记录器的最顶层父级对象，它包含一个默认的ConsoleHandler处理器用于进行控制台打印，而日志在打印时，子Logger会继承父Logger提供的所有Handler进行日志处理，因此我们在默认情况下才能正常使用日志打印：\",\"Logger logger = Logger.getLogger(\\\"test\\\"); Logger parent = logger.getParent(); System.out.println(Arrays.toString(parent.getHandlers())); \"]},\"656\":{\"h\":\"修改默认情况下的打印等级\",\"t\":[\"Handler是属于对应的Logger的，即继承的子Logger不能直接修改父Logger的Handler\",\"根据我们上节课学习的知识，在默认情况下如果我们需要修改日志打印等级，那么同时也需要将父级的Handler也进行日志等级配置：\",\"parent.getHandlers()[0].setLevel(Level.ALL); logger.setLevel(Level.ALL); logger.finest(\\\"test\\\"); \"]},\"657\":{\"h\":\"重复 问题\",\"t\":[\"当然，如果我们在不屏蔽父级Handler的情况下为子级配置一个Handler，那么此时两个Handler都会生效\",\"顺序：先子Logger, 再父Logger\",\"logger.addHandler(new ConsoleHandler()); logger.info(\\\"你干嘛\\\"); \",\"日志中出现了两次：\",\"8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 8月 28, 2024 12:57:39 上午 com.test.Main main 信息: 你干嘛 \",\"不过需要注意一下顺序，当父级和子级都配置时，那么子级的Handler优先进行处理，接着才是父级。\"]},\"658\":{\"h\":\"名称分级，自动构建继承关系\",\"t\":[\"除了默认的RootLogger作为父类，实际上Logger还会通过名称进行分级，自动构建一个继承关系，比如下面：\",\"Logger logger1 = Logger.getLogger(\\\"com\\\"); Logger logger2 = Logger.getLogger(\\\"com.test\\\"); Logger logger3 = Logger.getLogger(\\\"com.test.inner1\\\"); Logger logger4 = Logger.getLogger(\\\"com.test.inner2\\\"); System.out.println(logger4.getParent() == logger2); //全true System.out.println(logger3.getParent() == logger2); System.out.println(logger2.getParent() == logger1); \",\"就像包名一样，日志的名称会按照包的分级，进行自动继承，就像下面这个图一样：\",\"alt text\"]},\"659\":{\"c\":[\"code\"]},\"660\":{\"c\":[\"javaweb\",\"JUL\"]},\"661\":{\"h\":\"javaweb - JUL日志4\"},\"662\":{\"h\":\"JUL日志系统4\"},\"663\":{\"h\":\"日志默认配置\"},\"664\":{\"h\":\"格式\",\"t\":[\"Properties格式的文件是Java的一种配置文件，我们之前在学习Mybatis的时候学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？\",\"此时就可以使用Properties文件，它的格式如下：\",\"name=Test desc=Description \",\"该文件配置很简单，格式类似于我们Java中的Map键值对，中间使用等号进行连接。\",\"当然，键的名称我们也可以分为多级进行配置，每一级使用.进行划分，比如我们现在要配置数据库的连接信息，就可以编写为这种形式：\",\"jdbc.datasource.driver=com.cj.mysql.Driver jdbc.datasource.url=jdbc:mysql://localhost:3306/test jdbc.datasource.username=test jdbc.datasource.password=123456 \"]},\"665\":{\"h\":\"JAVA读取\",\"t\":[\"JDK为我们提供了一个叫做Properties的类型，它继承自Hashtable类（是HashMap的同步加锁版）\",\"使用起来和HashMap是差不多的：\",\"public class Properties extends Hashtable<Object,Object> {} \",\"相关操作：\",\"Properties properties = new Properties(); properties.load(new FileReader(\\\"test.properties\\\")); //使用load方法读取本地文件中的所有配置到Map中 System.out.println(properties); properties.get(xxx); \"]},\"666\":{\"h\":\"获取系统数据\",\"t\":[\"实际上，我们也可以通过这种方式来获取我们的一些系统属性\",\"System类中有一个getProperties方法用于存储所有系统相关的属性值，这里我们打印一下系统名称和版本：\",\"Properties properties = System.getProperties(); System.out.println(properties.get(\\\"os.name\\\")); System.out.println(properties.get(\\\"os.version\\\")); \",\"当然，程序中的Properties对象也可以快速保存为一个对应的.properties文件：\",\"Properties properties = System.getProperties(); properties.store(new FileWriter(\\\"system.properties\\\"), \\\"系统属性\\\"); \"]},\"667\":{\"h\":\"JUL设置默认配置\",\"t\":[\"实际上JUL也可以通过进行配置文件来规定日志打印器的一些默认值\",\"比如我们现在想配置默认的日志打印级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"接着我们需要在程序开始之前加载这里的配置：\",\"LogManager manager = LogManager.getLogManager(); //获取LogManager读取配置文件 manager.readConfiguration(new FileInputStream(\\\"test.properties\\\")); Logger logger = Logger.getLogger(\\\"test\\\"); logger.config(\\\"Hello World\\\"); \",\"这样就可以通过配置文件的形式修改一些功能的默认属性了，而不需要我们再使用代码进行配置。\",\"实际上在JUL的这类内部也有着对应的配置处理操作，如果发现有默认配置优先使用配置里面的，比如Handler的构造方法：\",\"Handler(Level defaultLevel, Formatter defaultFormatter, Formatter specifiedFormatter) { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); final Level level = manager.getLevelProperty(cname + \\\".level\\\", defaultLevel); final Filter filter = manager.getFilterProperty(cname + \\\".filter\\\", null); final Formatter formatter = specifiedFormatter == null ? manager.getFormatterProperty(cname + \\\".formatter\\\", defaultFormatter) : specifiedFormatter; final String encoding = manager.getStringProperty(cname + \\\".encoding\\\", null); ... } \",\"关于使用配置文件的形式修改JUL部分内容的默认值就先讲解到这里。\"]},\"668\":{\"c\":[\"code\"]},\"669\":{\"c\":[\"javaweb\",\"JUL\"]},\"670\":{\"h\":\"javaweb - JUL日志5\"},\"671\":{\"h\":\"JUL日志系统5\"},\"672\":{\"h\":\"自定义日志格式\",\"t\":[\"新建一个类，来继承Formatter，通过修改对应的format函数来实现自定义\",\"每一个Handler都可以配置一个对应的Formatter来决定日志打印的格式，除了官方为我们提供的两种默认格式外，我们也可以自定义我们想要的日志打印格式。\",\"我们只需要继承Formatter类，就可以创建一个自定义的日志格式处理逻辑了：\",\"public class MyFormatter extends Formatter { @Override public String format(LogRecord record) { return \\\"我是自定义日志格式\\\"; } } \",\"其中参数为LogRecord，它提供了当前日志记录的相关信息，比如：\",\"@Override public String format(LogRecord record) { System.out.println(\\\"所在类: \\\" + record.getSourceClassName()); System.out.println(\\\"方法名称: \\\" + record.getSourceMethodName()); System.out.println(\\\"日志级别: \\\" + record.getLevel().getLocalizedName()); return \\\"我是自定义日志格式\\\"; } \"]},\"673\":{\"h\":\"修改对应\"},\"674\":{\"h\":\"手动修改\",\"t\":[\"Logger logger = Logger.getLogger(\\\"com.test\\\"); logger.getParent().getHandlers()[0].setFormatter(new MyFormatter()); \"]},\"675\":{\"h\":\"配置文件修改\",\"t\":[\"直接把ConsoleHandler的默认Formatter配置为我们自己的类：\",\"java.util.logging.ConsoleHandler.formatter=com.test.MyFormatter \"]},\"676\":{\"h\":\"自定义例子\",\"t\":[\"因此，我们也可以利用这些属性来编写一个类似于的SimpleFormatter的日志格式，比如这里包含类名、时间等，类似于下面图中的日志格式：\",\"alt text\",\"我们来尝试编写一下：\",\"public String format(LogRecord record) { StringBuilder builder = new StringBuilder(); //日期 Date date = new Date(record.getMillis()); SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss.SSS\\\"); builder.append(dateFormat.format(date)); //级别 builder.append(\\\" \\\").append(record.getLevel()); builder.append(\\\" --- \\\"); //线程名称 builder.append('[').append(Thread.currentThread().getName()).append(']'); //类名称 builder.append(\\\" \\\").append(String.format(\\\"%-15s\\\", record.getSourceClassName())); //消息内容 builder.append(\\\" : \\\").append(record.getMessage()); return builder.toString(); } \"]},\"677\":{\"h\":\"第三方框架兼容性\",\"t\":[\"我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？\",\"前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter\"]},\"678\":{\"h\":\"日志注解\",\"t\":[\"同样的，Logger也是可以使用Lombok快速生成的。\",\"@Log public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \",\"只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。\",\"我们也可以手动指定名称：\",\"@Log(topic = \\\"打工是不可能打工的\\\") public class Main { public static void main(String[] args) { System.out.println(\\\"自动生成的Logger名称：\\\"+log.getName()); log.info(\\\"我是日志信息\\\"); } } \"]},\"679\":{\"h\":\"日志\",\"t\":[\"我们接着来看Mybatis，经过前面的学习，我们知道，Mybatis也有日志系统，它详细记录了所有的数据库操作等，要开启日志系统，我们需要进行配置：\",\"<setting name=\\\"logImpl\\\" value=\\\"STDOUT_LOGGING\\\" /> \",\"logImpl包括很多种配置项 包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\",\"而默认情况下是未配置，也就是说不打印。\",\"将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台\",\"现在我们也可以将其设置为JDK提供的日志框架：\",\"<setting name=\\\"logImpl\\\" value=\\\"JDK_LOGGING\\\" /> \",\"将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低\",\"因此我们需要设置一下logging.properties默认的日志级别：\",\"# RootLogger 的默认处理器为 handlers=java.util.logging.ConsoleHandler # RootLogger 的默认的日志级别 .level=ALL # 配置ConsoleHandler的默认level java.util.logging.ConsoleHandler.level=ALL \",\"这样，Mybatis就可以正确使用JDK的日志框架进行日志打印了，只不过格式稍微有点炸裂，可能还是得我们自己编写一个自定义的Formatter才行。\"]},\"680\":{\"c\":[\"code\"]},\"681\":{\"c\":[\"javaweb\",\"JUL\"]},\"682\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"683\":{\"h\":\"Daily\"},\"684\":{\"h\":\"Java\"},\"685\":{\"h\":\"Code\"},\"686\":{\"h\":\"Java Hint\"},\"687\":{\"h\":\"UAV\"},\"688\":{\"h\":\"Academic\"},\"689\":{\"h\":\"强化学习\"},\"690\":{\"h\":\"1 Socket\"},\"691\":{\"h\":\"Javaweb\"},\"692\":{\"h\":\"2 数据库\"},\"693\":{\"h\":\"3 Lombok\"},\"694\":{\"h\":\"4 Mybatis\"},\"695\":{\"h\":\"5 JUL\"}},\"dirtCount\":0,\"index\":[[\"经过前面的学习\",{\"1\":{\"679\":1}}],[\"经验回放\",{\"0\":{\"428\":1}}],[\"打工是不可能打工的\",{\"1\":{\"678\":1}}],[\"打印查看一下最终执行的\",{\"1\":{\"533\":1}}],[\"打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"打印当前线程名称\",{\"1\":{\"166\":1}}],[\"打印\",{\"1\":{\"142\":1,\"275\":1}}],[\"打印流其实我们从一开始就在使用了\",{\"1\":{\"127\":1}}],[\"打印流\",{\"0\":{\"127\":1}}],[\"打印集合类\",{\"1\":{\"25\":1}}],[\"消息内容\",{\"1\":{\"676\":1}}],[\"消费者可以从货架上拿走商品\",{\"1\":{\"174\":1}}],[\"消费者也在不断的消费\",{\"1\":{\"174\":1}}],[\"日期\",{\"1\":{\"676\":1}}],[\"日志\",{\"0\":{\"679\":1}}],[\"日志注解\",{\"0\":{\"678\":1}}],[\"日志默认配置\",{\"0\":{\"663\":1}}],[\"日志的名称会按照包的分级\",{\"1\":{\"658\":1}}],[\"日志的打印并不是简单的输出\",{\"1\":{\"637\":1}}],[\"日志中出现了两次\",{\"1\":{\"657\":1}}],[\"日志继承关系\",{\"0\":{\"654\":1}}],[\"日志内容\",{\"1\":{\"649\":1}}],[\"日志级别\",{\"1\":{\"649\":1,\"672\":1}}],[\"日志打印的核心部分\",{\"1\":{\"646\":1}}],[\"日志核心内容\",{\"0\":{\"645\":1}}],[\"日志一般分为7个级别\",{\"1\":{\"638\":1}}],[\"日志将时刻伴随我们左右\",{\"1\":{\"636\":1}}],[\"格式类似于我们java中的map键值对\",{\"1\":{\"664\":1}}],[\"格式\",{\"0\":{\"664\":1}}],[\"格式为\",{\"1\":{\"649\":1}}],[\"顺序\",{\"1\":{\"657\":1}}],[\"顺序就同我们的插入顺序一致\",{\"1\":{\"61\":1}}],[\"比较常见的就是打印到控制台\",{\"1\":{\"646\":1}}],[\"比如这里包含类名\",{\"1\":{\"676\":1}}],[\"比如这里就是通过空格分隔\",{\"1\":{\"244\":1}}],[\"比如handler的构造方法\",{\"1\":{\"667\":1}}],[\"比如下面\",{\"1\":{\"658\":1}}],[\"比如边充电边打电话就是个危险操作\",{\"1\":{\"638\":1}}],[\"比如插入一个用户\",{\"1\":{\"624\":1}}],[\"比如每个用户现在都有一个小组\",{\"1\":{\"583\":1}}],[\"比如每个同学的学号都是不一样的\",{\"1\":{\"461\":1}}],[\"比如小于\",{\"1\":{\"564\":1}}],[\"比如转换为一个map对象\",{\"1\":{\"561\":1}}],[\"比如类中的哪个字段对应数据库中的哪个字段\",{\"1\":{\"554\":1}}],[\"比如根节点下就囊括了所有的节点\",{\"1\":{\"547\":1}}],[\"比如要根据id修改用户的年龄\",{\"1\":{\"591\":1}}],[\"比如要依次删除很多个表的数据\",{\"1\":{\"510\":1}}],[\"比如要共享某些数据\",{\"1\":{\"138\":1}}],[\"比如在insert操作时\",{\"1\":{\"509\":1}}],[\"比如现在我们想要实现之前的这个奇葩需求\",{\"1\":{\"630\":1}}],[\"比如现在我们想要批量插入一些用户到数据库里面\",{\"1\":{\"605\":1}}],[\"比如现在我们想要让数据从大到小排列\",{\"1\":{\"14\":1}}],[\"比如现在我们希望在查询用户时\",{\"1\":{\"602\":1}}],[\"比如现在我们有一个这样的构造方法\",{\"1\":{\"569\":1}}],[\"比如现在有一个存储所有用户的表\",{\"1\":{\"497\":1}}],[\"比如性别只能是男或是女\",{\"1\":{\"461\":1}}],[\"比如一个老师可以教很多个学生\",{\"1\":{\"461\":1}}],[\"比如一个学生的特征包括姓名\",{\"1\":{\"461\":1}}],[\"比如一些集合允许重复的元素\",{\"1\":{\"21\":1}}],[\"比如是因为什么原因导致的异常\",{\"1\":{\"266\":1}}],[\"比如object类中定义的clone方法\",{\"1\":{\"264\":1}}],[\"比如数组越界异常\",{\"1\":{\"264\":1}}],[\"比如字符串的裁剪\",{\"1\":{\"244\":1}}],[\"比如之前悬念中的value变量\",{\"1\":{\"154\":1}}],[\"比如string\",{\"1\":{\"559\":1}}],[\"比如scanner获取输入的文本\",{\"1\":{\"142\":1}}],[\"比如system\",{\"1\":{\"127\":1}}],[\"比如com\",{\"1\":{\"120\":1}}],[\"比如键盘发送的信号\",{\"1\":{\"108\":1}}],[\"比如筛选\",{\"1\":{\"71\":1}}],[\"比如上面的type=\",{\"1\":{\"545\":1}}],[\"比如上面的学生信息\",{\"1\":{\"56\":1}}],[\"比如上我们定义的是类型\",{\"1\":{\"14\":1}}],[\"比如我们现在想配置默认的日志打印级别\",{\"1\":{\"667\":1}}],[\"比如我们现在要配置数据库的连接信息\",{\"1\":{\"664\":1}}],[\"比如我们现在不希望使用object类中提供的equals方法\",{\"1\":{\"216\":1}}],[\"比如我们希望配置usegeneratedkeys来得到自动生成的主键\",{\"1\":{\"625\":1}}],[\"比如我们希望某个操作执行完成后\",{\"1\":{\"615\":1}}],[\"比如我们希望在根据id查询用户时\",{\"1\":{\"601\":1}}],[\"比如我们要估计某个随机变量x的\",{\"1\":{\"384\":1}}],[\"比如我们想要查询所有年龄大于等于18岁的用户\",{\"1\":{\"564\":1}}],[\"比如我们想要打印数组\",{\"1\":{\"275\":1}}],[\"比如我们想计算某个学生的所有科目分数之后\",{\"1\":{\"65\":1}}],[\"比如我们可以判断变量的值\",{\"1\":{\"268\":1}}],[\"比如我们可以来看看下面这个问题\",{\"1\":{\"154\":1}}],[\"比如我们可以直接当做栈来进行使用\",{\"1\":{\"44\":1}}],[\"比如我们运行qq\",{\"1\":{\"138\":1}}],[\"比如我们经常访问的\",{\"1\":{\"120\":1}}],[\"比如我们之前学习的顺序表\",{\"1\":{\"23\":1}}],[\"比如\",{\"1\":{\"23\":1,\"203\":1,\"264\":1,\"465\":1,\"491\":1,\"495\":1,\"498\":1,\"571\":1,\"672\":1}}],[\"比如说\",{\"1\":{\"14\":1,\"219\":1}}],[\"填写的日志打印级别是什么\",{\"1\":{\"640\":1}}],[\"级别\",{\"1\":{\"676\":1}}],[\"级别低于普通信息\",{\"1\":{\"639\":1}}],[\"级别划分\",{\"0\":{\"638\":1}}],[\"祝你明天就遇到我\",{\"1\":{\"639\":1}}],[\"严重的错误\",{\"1\":{\"639\":1}}],[\"严格等于\",{\"1\":{\"440\":1}}],[\"十一月\",{\"1\":{\"636\":1}}],[\"十六进制哈希值\",{\"1\":{\"215\":1}}],[\"彻底抛弃xml配置\",{\"1\":{\"632\":1}}],[\"咱们把配置文件也给变成代码配置\",{\"1\":{\"632\":1}}],[\"构建完成后\",{\"1\":{\"630\":1}}],[\"构造函数也不能赋值\",{\"1\":{\"217\":1}}],[\"构造器\",{\"1\":{\"9\":1,\"191\":1}}],[\"构造方法的编写会非常麻烦\",{\"1\":{\"538\":1}}],[\"构造方法也可以被引用\",{\"1\":{\"258\":1}}],[\"构造方法得到字符串\",{\"1\":{\"91\":1}}],[\"构造方法会在new的时候自动执行\",{\"1\":{\"9\":1}}],[\"构造方法会在对象创建时执行\",{\"1\":{\"9\":1}}],[\"构造方法不需要指定返回值\",{\"1\":{\"9\":1}}],[\"构造方法不需要填写返回值\",{\"1\":{\"9\":1}}],[\"构造方法\",{\"0\":{\"9\":1},\"1\":{\"9\":1,\"25\":1}}],[\"建议使用之前的xml方式进行配置\",{\"1\":{\"629\":1}}],[\"建议在最后执行一次刷新操作\",{\"1\":{\"92\":1}}],[\"建议在finally中进行\",{\"1\":{\"90\":1}}],[\"假如现在我们的实体类字段名称与数据库不同\",{\"1\":{\"626\":1}}],[\"假设仓库管理关系表为storehousemanage\",{\"1\":{\"467\":1}}],[\"假设有\",{\"1\":{\"427\":1}}],[\"假设我们要根据用户的id进行数据的删除\",{\"1\":{\"592\":1}}],[\"假设我们每个用户都有一个自己的详细信息表\",{\"1\":{\"577\":1}}],[\"假设我们现在需要编写一个根据id查询用户的操作\",{\"1\":{\"559\":1}}],[\"假设我们具有\",{\"1\":{\"401\":1}}],[\"假设我们可以得到有关随机变量\",{\"1\":{\"395\":1}}],[\"假设我们需要求解如下方程\",{\"1\":{\"381\":1}}],[\"假设我们有了一系列\",{\"1\":{\"363\":1}}],[\"假设\",{\"1\":{\"379\":1,\"439\":1}}],[\"假设功率q=qn​\",{\"1\":{\"296\":1}}],[\"假设厨师炒出一个菜的时间为3秒\",{\"1\":{\"174\":1}}],[\"女\",{\"1\":{\"625\":1}}],[\"举例\",{\"0\":{\"624\":1}}],[\"清除所有缓存\",{\"0\":{\"615\":1}}],[\"清空缓冲区\",{\"1\":{\"113\":1}}],[\"清空整个map\",{\"1\":{\"56\":1}}],[\"清空整个集合\",{\"1\":{\"23\":1}}],[\"速度上会慢一些\",{\"1\":{\"612\":1}}],[\"弱引用\",{\"1\":{\"612\":1}}],[\"软引用\",{\"1\":{\"612\":1}}],[\"二级缓存配置\",{\"0\":{\"631\":1}}],[\"二级缓存才会被更新\",{\"1\":{\"612\":1}}],[\"二级缓存是事务性的\",{\"1\":{\"612\":1}}],[\"二级缓存是mapper级别的\",{\"1\":{\"612\":1}}],[\"二级缓存默认是关闭状态\",{\"1\":{\"612\":1}}],[\"二级缓存\",{\"0\":{\"612\":1}}],[\"二分搜索\",{\"0\":{\"77\":1}}],[\"详细信息我们可以在level类中查看\",{\"1\":{\"638\":1}}],[\"详细的sql语句构建器语法文档\",{\"1\":{\"630\":1}}],[\"详细了解\",{\"1\":{\"601\":1}}],[\"详细过程就不介绍了\",{\"1\":{\"60\":1}}],[\"极大的简化了我们之前jdbc那样的代码编写模式\",{\"1\":{\"621\":1}}],[\"极大地提升了sql语句编写的的灵活性\",{\"1\":{\"600\":1}}],[\"极大简化了之前的流程\",{\"1\":{\"553\":1}}],[\"批量插入\",{\"0\":{\"605\":1}}],[\"批量删除\",{\"0\":{\"604\":1}}],[\"批量操作\",{\"1\":{\"56\":1}}],[\"批处理\",{\"0\":{\"599\":1}}],[\"像\",{\"1\":{\"590\":1}}],[\"像这种一对一查询该怎么实现呢\",{\"1\":{\"577\":1}}],[\"像这种只有一个方法需要实现的接口\",{\"1\":{\"14\":1}}],[\"改\",{\"1\":{\"588\":1}}],[\"删\",{\"1\":{\"588\":1}}],[\"删除操作则更为简单\",{\"1\":{\"592\":1}}],[\"删除\",{\"0\":{\"592\":1},\"1\":{\"524\":1}}],[\"删除数据\",{\"0\":{\"484\":1}}],[\"删除表\",{\"0\":{\"480\":1}}],[\"删除2到4这个范围内的字符\",{\"1\":{\"245\":1}}],[\"删除就完事\",{\"1\":{\"25\":1}}],[\"删除的是另一个对象\",{\"1\":{\"25\":1}}],[\"删除的是下标为10的元素\",{\"1\":{\"25\":1}}],[\"删除所有元素\",{\"1\":{\"23\":1}}],[\"们可以在查询user表的时候\",{\"1\":{\"579\":1}}],[\"嵌套\",{\"0\":{\"579\":1},\"1\":{\"577\":1}}],[\"嵌套结果映射\",{\"0\":{\"578\":1},\"1\":{\"577\":1}}],[\"嵌套查询来解决\",{\"1\":{\"582\":1}}],[\"嵌套查询\",{\"0\":{\"498\":1,\"582\":1}}],[\"官方解释它主要用于惰性获取数据\",{\"1\":{\"564\":1}}],[\"官方解释它是java编程语言和广泛的数据库之间独立于数据库的连接标准的java\",{\"1\":{\"515\":1}}],[\"名称分级\",{\"0\":{\"658\":1}}],[\"名称随意\",{\"1\":{\"636\":1}}],[\"名称随便\",{\"1\":{\"559\":1}}],[\"名称最好和数据库字段名称保持一致\",{\"1\":{\"554\":1}}],[\"名字一般为xxx\",{\"1\":{\"646\":1}}],[\"名字\",{\"1\":{\"4\":1}}],[\"配置文件修改\",{\"0\":{\"675\":1}}],[\"配置文件完成后\",{\"1\":{\"552\":1}}],[\"配置consolehandler的默认level\",{\"1\":{\"667\":1,\"679\":1}}],[\"配置方式和之前几乎一致\",{\"1\":{\"628\":1}}],[\"配置\",{\"0\":{\"627\":1,\"630\":1}}],[\"配置这些额外的参数\",{\"0\":{\"625\":1}}],[\"配置完成后\",{\"1\":{\"563\":1,\"578\":1}}],[\"配置lombok\",{\"0\":{\"539\":1}}],[\"含包名\",{\"1\":{\"552\":1}}],[\"含噪声\",{\"1\":{\"389\":1}}],[\"含噪音\",{\"1\":{\"382\":1}}],[\"驱动类\",{\"1\":{\"552\":1}}],[\"$proxy4\",{\"1\":{\"570\":1}}],[\"$\",{\"1\":{\"552\":4}}],[\"文档类型定义\",{\"1\":{\"552\":1}}],[\"文档网站\",{\"1\":{\"552\":1}}],[\"文件其实就是我们编写的一个类\",{\"1\":{\"118\":1}}],[\"文件丢给\",{\"1\":{\"118\":1}}],[\"文件字符流\",{\"0\":{\"95\":1}}],[\"文件字节流\",{\"0\":{\"89\":1}}],[\"文件拷贝操作实现\",{\"0\":{\"94\":1}}],[\"文件读取\",{\"0\":{\"91\":1}}],[\"初次使用\",{\"0\":{\"552\":1}}],[\"初始容量为16\",{\"1\":{\"59\":1}}],[\"节省性能开销\",{\"1\":{\"610\":1}}],[\"节点可以是一个带有内容的标签\",{\"1\":{\"547\":1}}],[\"节所述\",{\"1\":{\"364\":1}}],[\"解析xml文件\",{\"0\":{\"547\":1}}],[\"解决方案\",{\"0\":{\"297\":1}}],[\"区分大小写\",{\"1\":{\"545\":1}}],[\"区别于贝尔曼公式\",{\"1\":{\"341\":1}}],[\"避免了几乎所有的\",{\"1\":{\"544\":1}}],[\"合理地使用这些技术\",{\"1\":{\"544\":1}}],[\"合格\",{\"1\":{\"280\":1}}],[\"放在项目目录下直接导入就行了\",{\"1\":{\"539\":1}}],[\"放入缓冲区再经过转换流输出到给定的输出流上\",{\"1\":{\"127\":1}}],[\"炸\",{\"1\":{\"538\":1}}],[\"爆\",{\"1\":{\"538\":1}}],[\"长\",{\"1\":{\"538\":1}}],[\"长度不固定\",{\"1\":{\"474\":1}}],[\"长度不超过\",{\"1\":{\"71\":1}}],[\"长度是在一开始创建数组的时候就确定好的\",{\"1\":{\"236\":1}}],[\"撤销前面全部操作\",{\"1\":{\"534\":2}}],[\"乍一看好像没啥问题\",{\"1\":{\"532\":1}}],[\"登陆成功\",{\"1\":{\"532\":2,\"533\":1}}],[\"登陆用户\",{\"0\":{\"501\":1}}],[\"行\",{\"1\":{\"524\":1}}],[\"行不行\",{\"1\":{\"245\":2}}],[\"了解了一对多\",{\"1\":{\"583\":1}}],[\"了解即可\",{\"1\":{\"563\":1}}],[\"了解statement\",{\"0\":{\"519\":1}}],[\"了解connection\",{\"0\":{\"518\":1}}],[\"`group`\",{\"1\":{\"583\":1}}],[\"`groups`\",{\"1\":{\"583\":2}}],[\"`com\",{\"1\":{\"516\":2}}],[\"``\",{\"1\":{\"192\":1}}],[\"连接的url如果记不住格式\",{\"1\":{\"516\":1}}],[\"连接示例\",{\"0\":{\"447\":1}}],[\"释放资源\",{\"1\":{\"516\":1}}],[\"执行批处理操作\",{\"0\":{\"526\":1}}],[\"执行dql操作会返回一个resultset对象\",{\"1\":{\"525\":1}}],[\"执行dql操作\",{\"0\":{\"525\":1}}],[\"执行dml操作\",{\"0\":{\"524\":1}}],[\"执行sql语句\",{\"1\":{\"516\":1}}],[\"执行一个延时任务\",{\"1\":{\"166\":1}}],[\"又要挨个进行修改\",{\"1\":{\"538\":1}}],[\"又兼备存储的优势\",{\"1\":{\"515\":1}}],[\"又比如每个同学都有一个学号与其唯一对应\",{\"1\":{\"461\":1}}],[\"根本上说jdbc是一种规范\",{\"1\":{\"515\":1}}],[\"根据我们上节课学习的知识\",{\"1\":{\"656\":1}}],[\"根据不同类型的信息进行划分\",{\"1\":{\"637\":1}}],[\"根据这个式子我们就可以通过\",{\"1\":{\"440\":1}}],[\"根据梯度下降的公式\",{\"1\":{\"427\":1}}],[\"根据策略\",{\"1\":{\"363\":1}}],[\"根据策略π\",{\"1\":{\"333\":1}}],[\"根据对应的\",{\"1\":{\"351\":1}}],[\"根据\",{\"1\":{\"338\":2,\"347\":1,\"348\":1,\"351\":1,\"353\":1,\"398\":1}}],[\"根据一个\",{\"1\":{\"327\":1}}],[\"根据所给定的用户划分情况\",{\"1\":{\"298\":1}}],[\"根据遗传算法找到cn​个最优个体作为簇的中心\",{\"1\":{\"298\":1}}],[\"根据n个用户\",{\"1\":{\"298\":1}}],[\"根据mos数值\",{\"1\":{\"295\":1}}],[\"根据香农定理\",{\"1\":{\"294\":1}}],[\"根据上面的推导\",{\"1\":{\"60\":1}}],[\"根据给定的策略\",{\"1\":{\"397\":1}}],[\"根据给定的键\",{\"1\":{\"56\":1}}],[\"根据给定的predicate条件进行元素移除操作\",{\"1\":{\"23\":1}}],[\"根据初始化大小\",{\"1\":{\"25\":1}}],[\"回滚到回滚点\",{\"1\":{\"534\":1}}],[\"回滚到指定回滚点\",{\"1\":{\"510\":1}}],[\"回滚之前的内容都没了\",{\"1\":{\"534\":2}}],[\"回滚\",{\"1\":{\"534\":1}}],[\"回滚点\",{\"1\":{\"510\":2}}],[\"回滚事务\",{\"1\":{\"510\":1}}],[\"回到mark时的位置\",{\"1\":{\"108\":1}}],[\"持久性\",{\"1\":{\"510\":1}}],[\"读提交\",{\"1\":{\"510\":1}}],[\"读取实体类肯定需要一个映射规则\",{\"1\":{\"554\":1}}],[\"读取后直接得到一个字符串\",{\"1\":{\"112\":1}}],[\"读取一个少一个\",{\"1\":{\"91\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"510\":1}}],[\"隔离性\",{\"1\":{\"510\":1}}],[\"隔开即可\",{\"1\":{\"219\":1}}],[\"串联性以及后续数据库可以自发性地完成预定的工作\",{\"1\":{\"510\":1}}],[\"事务相关操作非常简单\",{\"1\":{\"593\":1}}],[\"事务操作\",{\"0\":{\"593\":1}}],[\"事务等\",{\"1\":{\"515\":1}}],[\"事务处理结束后\",{\"1\":{\"510\":1}}],[\"事务隔离分为不同级别\",{\"1\":{\"510\":1}}],[\"事务在执行过程中发生错误\",{\"1\":{\"510\":1}}],[\"事务具有以下特性\",{\"1\":{\"510\":1}}],[\"事务\",{\"0\":{\"510\":1}}],[\"旧的内容会被移到old表中\",{\"1\":{\"509\":2}}],[\"旧容量不大于0只可能是还没初始化\",{\"1\":{\"60\":1}}],[\"触发器名称\",{\"1\":{\"509\":2}}],[\"触发器所依附的表称为基本表\",{\"1\":{\"509\":1}}],[\"触发器显得更加灵活\",{\"1\":{\"509\":1}}],[\"触发器通常用于检查内容的安全性\",{\"1\":{\"509\":1}}],[\"触发器就像其名字一样\",{\"1\":{\"509\":1}}],[\"触发器\",{\"0\":{\"509\":1}}],[\"能否简化一下这个流程呢\",{\"1\":{\"677\":1}}],[\"能否实现无需xml映射器配置\",{\"1\":{\"621\":1}}],[\"能够大大提高我们的查询效率\",{\"1\":{\"508\":1}}],[\"能匹配\",{\"1\":{\"246\":2}}],[\"索引为我们带来高速查询效率的同时\",{\"1\":{\"508\":1}}],[\"索引方法\",{\"1\":{\"508\":1}}],[\"索引类型包括\",{\"1\":{\"508\":1}}],[\"索引名称\",{\"1\":{\"508\":2}}],[\"索引\",{\"0\":{\"508\":1}}],[\"子logger会继承父logger提供的所有handler进行日志处理\",{\"1\":{\"655\":1}}],[\"子查询语句\",{\"1\":{\"507\":1}}],[\"子类也可以定义\",{\"1\":{\"218\":1}}],[\"子类对应必须是\",{\"1\":{\"218\":1}}],[\"子类必须要实现抽象类所有的抽象方法\",{\"1\":{\"218\":1}}],[\"子类\",{\"1\":{\"218\":1}}],[\"子类是\",{\"1\":{\"214\":1}}],[\"子类实现了父类所有非私有化的属性和方法\",{\"1\":{\"212\":1}}],[\"子类我们会在下一章介绍\",{\"1\":{\"121\":1}}],[\"子类初始化时\",{\"1\":{\"118\":1}}],[\"代表为所有的数据库和表都授权\",{\"1\":{\"502\":1}}],[\"代码和手动设置参数以及获取结果集\",{\"1\":{\"544\":1}}],[\"代码的健壮性有所欠缺\",{\"1\":{\"280\":1}}],[\"代码语句\",{\"1\":{\"257\":1}}],[\"代码块\",{\"1\":{\"155\":1}}],[\"代码块中的内容会在对象创建时仅执行一次\",{\"1\":{\"9\":1}}],[\"代码块同样会在对象构造之前进行\",{\"1\":{\"9\":1}}],[\"权限2\",{\"1\":{\"502\":2}}],[\"密码等\",{\"1\":{\"552\":1}}],[\"密码\",{\"1\":{\"500\":1,\"532\":1,\"533\":1,\"534\":4,\"552\":1}}],[\"庞大的数据库不可能由一个人来管理\",{\"1\":{\"499\":1}}],[\"起始位置\",{\"1\":{\"494\":1}}],[\"约束条件\",{\"1\":{\"494\":1}}],[\"约束要求该列的每一行必须有一个非空值\",{\"1\":{\"475\":1}}],[\"统计某列的值总和\",{\"1\":{\"493\":1}}],[\"统计所有的行数\",{\"1\":{\"493\":1}}],[\"聚集函数一般用作统计\",{\"1\":{\"493\":1}}],[\"聚集函数\",{\"0\":{\"493\":1}}],[\"聚合等\",{\"1\":{\"71\":1}}],[\"别名2\",{\"1\":{\"496\":1}}],[\"别名1\",{\"1\":{\"496\":1}}],[\"别名\",{\"0\":{\"560\":1},\"1\":{\"490\":1}}],[\"别人将某个方法设置为private一定有他的理由\",{\"1\":{\"192\":1}}],[\"别人来调用我们的实现\",{\"1\":{\"14\":1}}],[\"单独配置取消二级缓存\",{\"0\":{\"614\":1}}],[\"单表查询是最简单的一种查询\",{\"1\":{\"490\":1}}],[\"单表查询\",{\"0\":{\"490\":1}}],[\"单走\",{\"1\":{\"66\":4}}],[\"警告的内容\",{\"1\":{\"639\":1}}],[\"警告\",{\"1\":{\"483\":1}}],[\"条件判断\",{\"0\":{\"601\":1}}],[\"条件\",{\"1\":{\"483\":1,\"484\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":2,\"495\":1,\"498\":1}}],[\"条件转换掉\",{\"1\":{\"370\":1}}],[\"参照\",{\"1\":{\"475\":1}}],[\"参数也可以是字符串类型的\",{\"1\":{\"559\":1}}],[\"参数一样\",{\"1\":{\"258\":1}}],[\"参数直接写成lambda表达式\",{\"1\":{\"257\":1}}],[\"参数名称要与实体类参数对应\",{\"1\":{\"589\":1}}],[\"参数名称\",{\"1\":{\"241\":1,\"257\":1}}],[\"参数类型\",{\"1\":{\"241\":1,\"257\":1}}],[\"参数类型可能会多种多样\",{\"1\":{\"8\":1}}],[\"参数上\",{\"1\":{\"203\":1}}],[\"参数化类型中可以获取到泛型在定义过程中的参数类型\",{\"1\":{\"186\":1}}],[\"列的下标是从1开始的\",{\"1\":{\"527\":1}}],[\"列的值必须大于或等于\",{\"1\":{\"475\":1}}],[\"列的值是唯一的\",{\"1\":{\"475\":1}}],[\"列1\",{\"1\":{\"502\":2}}],[\"列名=值\",{\"1\":{\"483\":1}}],[\"列名2\",{\"1\":{\"482\":2,\"492\":1}}],[\"列名1\",{\"1\":{\"482\":2,\"492\":1}}],[\"列名\",{\"1\":{\"478\":2,\"479\":2,\"490\":4,\"492\":1,\"493\":6,\"494\":2,\"498\":2,\"507\":1,\"508\":1}}],[\"列不能为\",{\"1\":{\"475\":1}}],[\"列在未指定值时默认值为\",{\"1\":{\"475\":1}}],[\"列\",{\"1\":{\"475\":1}}],[\"列是外键\",{\"1\":{\"475\":1}}],[\"列是主键\",{\"1\":{\"475\":1}}],[\"列级约束有六种\",{\"1\":{\"475\":1}}],[\"列级约束条件\",{\"0\":{\"475\":1},\"1\":{\"478\":2,\"479\":1}}],[\"列表中允许存在相同元素\",{\"1\":{\"25\":1}}],[\"列表中允许存在重复元素\",{\"1\":{\"24\":1}}],[\"列表\",{\"0\":{\"24\":1},\"1\":{\"24\":1,\"84\":1}}],[\"范围在\",{\"1\":{\"474\":3}}],[\"负责对数据库对象运行数据访问工作的指令集\",{\"1\":{\"472\":1}}],[\"负载因子默认为0\",{\"1\":{\"60\":1}}],[\"负载因子\",{\"1\":{\"58\":1}}],[\"→\",{\"1\":{\"467\":4}}],[\"管理事务\",{\"0\":{\"534\":1}}],[\"管理员id\",{\"1\":{\"467\":6}}],[\"管理和操作我们的数据而存在的\",{\"1\":{\"21\":1}}],[\"仓库id\",{\"1\":{\"467\":6}}],[\"书籍\",{\"1\":{\"466\":1}}],[\"书籍作者\",{\"1\":{\"466\":2}}],[\"书籍名称\",{\"1\":{\"466\":2}}],[\"书籍编号\",{\"1\":{\"466\":3}}],[\"借阅编号\",{\"1\":{\"466\":2}}],[\"借用\",{\"1\":{\"386\":1}}],[\"满足第三范式\",{\"1\":{\"466\":1}}],[\"满足第一范式是关系型数据库最基本的要求\",{\"1\":{\"464\":1}}],[\"满足f\",{\"1\":{\"343\":1}}],[\"手机号码\",{\"1\":{\"464\":1}}],[\"手动修改\",{\"0\":{\"674\":1}}],[\"手动调用connect方法进行连接\",{\"1\":{\"449\":1}}],[\"手动调用wait\",{\"1\":{\"143\":1}}],[\"手动编译一个\",{\"1\":{\"199\":1}}],[\"座机号码\",{\"1\":{\"464\":1}}],[\"电话号码实际上包括了家用座机电话和移动电话\",{\"1\":{\"464\":1}}],[\"电话号码\",{\"1\":{\"464\":1}}],[\"授课\",{\"1\":{\"462\":1}}],[\"授课表\",{\"1\":{\"462\":1}}],[\"教师号\",{\"1\":{\"462\":2}}],[\"教师\",{\"1\":{\"462\":1}}],[\"教师表\",{\"1\":{\"462\":1}}],[\"姓名和性别都会因此发生改变\",{\"1\":{\"465\":1}}],[\"姓名\",{\"1\":{\"462\":2,\"464\":2,\"465\":1}}],[\"专业等\",{\"1\":{\"461\":1}}],[\"专门创建一个独属于某个线程的变量\",{\"1\":{\"162\":1}}],[\"专门用于表示一个文件或文件夹\",{\"1\":{\"98\":1}}],[\"专门用于处理文本数据\",{\"1\":{\"88\":1}}],[\"年级\",{\"1\":{\"461\":1}}],[\"年龄\",{\"1\":{\"4\":1,\"9\":1,\"461\":1}}],[\"开启此选项后\",{\"1\":{\"615\":1}}],[\"开启二级缓存后\",{\"1\":{\"612\":1}}],[\"开启批处理后\",{\"1\":{\"599\":1}}],[\"开启时把之前的事务模式下的内容给提交了\",{\"1\":{\"534\":1}}],[\"开启事务只有当commit后才能在真正的数据库里看到\",{\"1\":{\"510\":1}}],[\"开源数据库\",{\"1\":{\"460\":1}}],[\"开始事务\",{\"1\":{\"510\":1}}],[\"开始支持\",{\"1\":{\"204\":2,\"205\":1}}],[\"开始唤醒\",{\"1\":{\"161\":1}}],[\"开始等待\",{\"1\":{\"161\":1}}],[\"免费\",{\"1\":{\"460\":1}}],[\"全true\",{\"1\":{\"658\":1}}],[\"全称为超文本传输协议\",{\"1\":{\"455\":1}}],[\"全部拷贝为一个新的对象\",{\"1\":{\"220\":1}}],[\"传输文件\",{\"0\":{\"454\":1}}],[\"传入的如果是对象\",{\"1\":{\"155\":1}}],[\"传入fileinputstream\",{\"1\":{\"105\":1}}],[\"探测双方的tcp\",{\"1\":{\"449\":1}}],[\"看系统内核参数配置\",{\"1\":{\"449\":1}}],[\"看看是否还有下一个元素\",{\"1\":{\"32\":1}}],[\"超过一个时间\",{\"1\":{\"449\":1}}],[\"杂项\",{\"0\":{\"449\":1}}],[\"客户端\",{\"1\":{\"447\":1}}],[\"客户端已连接\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"省略\",{\"1\":{\"447\":1}}],[\"服务端不仅仅只可以让一个客户端进行连接\",{\"1\":{\"447\":1}}],[\"服务端和客户端之间就可以相互发送数据\",{\"1\":{\"447\":1}}],[\"服务端连接失败\",{\"1\":{\"447\":1,\"448\":1,\"454\":1}}],[\"服务端\",{\"1\":{\"447\":1}}],[\"梯度上升算法的本质就是最大化目标函数\",{\"1\":{\"441\":1}}],[\"梯度上升算法\",{\"0\":{\"441\":1}}],[\"梯度下降\",{\"1\":{\"421\":1}}],[\"梯度下降法\",{\"1\":{\"386\":1}}],[\"近似\",{\"1\":{\"440\":1}}],[\"任何一种\",{\"1\":{\"440\":1}}],[\"任何方法都可以通过方法引用作为实现\",{\"1\":{\"258\":1}}],[\"概率分布\",{\"1\":{\"435\":1}}],[\"概念上的定义\",{\"1\":{\"4\":1}}],[\"确保某列的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"476\":1}}],[\"确保列中的值必须存在于另一表的主键或唯一约束列中\",{\"1\":{\"475\":1}}],[\"确保列中的每个值都是唯一的\",{\"1\":{\"475\":2}}],[\"确保根是存在且唯一的\",{\"1\":{\"383\":1}}],[\"确定\",{\"1\":{\"433\":1}}],[\"网络的输入包括\",{\"1\":{\"427\":1}}],[\"网易云音乐等软件\",{\"1\":{\"138\":1}}],[\"复杂查询\",{\"0\":{\"576\":1}}],[\"复制一份即可\",{\"1\":{\"516\":1}}],[\"复制到\",{\"1\":{\"427\":1}}],[\"复位中断标记\",{\"1\":{\"144\":2}}],[\"尝试自己写的http相应时\",{\"1\":{\"455\":1}}],[\"尝试将\",{\"1\":{\"427\":1}}],[\"尝试获取threadlocal中存放的变量\",{\"1\":{\"162\":1}}],[\"固定不动\",{\"1\":{\"427\":1}}],[\"固定\",{\"1\":{\"427\":1}}],[\"≥0\",{\"1\":{\"420\":1,\"435\":1,\"440\":1}}],[\"≥vπ​\",{\"1\":{\"338\":1}}],[\"认为所有状态都是同等重要的\",{\"1\":{\"419\":1}}],[\"寻找一个最优的参数w\",{\"1\":{\"417\":1}}],[\"版本\",{\"0\":{\"410\":1,\"411\":1}}],[\"版本要求\",{\"1\":{\"285\":1}}],[\"形式下的贝尔曼最优公式\",{\"1\":{\"404\":1}}],[\"形式来声明\",{\"1\":{\"207\":1}}],[\"≐e\",{\"1\":{\"440\":1}}],[\"≐g\",{\"1\":{\"395\":1}}],[\"≐w−x\",{\"1\":{\"384\":1}}],[\"≐w−e\",{\"1\":{\"384\":1}}],[\"ω=e\",{\"1\":{\"395\":1}}],[\"期望的情况\",{\"1\":{\"390\":1}}],[\"另一种表达\",{\"0\":{\"436\":1,\"439\":1}}],[\"另一种问题描述方法\",{\"0\":{\"390\":1}}],[\"另一些则频繁被访问\",{\"1\":{\"419\":1}}],[\"另一分布下\",{\"1\":{\"314\":1}}],[\"∇w​f\",{\"1\":{\"389\":2}}],[\"往往可以转化为导数为\",{\"1\":{\"389\":1}}],[\"=\",{\"1\":{\"401\":1,\"405\":1}}],[\"=e\",{\"1\":{\"389\":1}}],[\"=n\",{\"1\":{\"293\":1,\"296\":1,\"298\":1}}],[\"视图名\",{\"1\":{\"509\":1}}],[\"视图名称\",{\"1\":{\"507\":1}}],[\"视图本质就是一个查询的结果\",{\"1\":{\"507\":1}}],[\"视图\",{\"0\":{\"507\":1}}],[\"视图一起删除\",{\"1\":{\"479\":1}}],[\"视为一个特殊情况下的\",{\"1\":{\"389\":1}}],[\"视为\",{\"1\":{\"389\":1,\"427\":1}}],[\"视频等二进制数据\",{\"1\":{\"88\":1}}],[\"⇓wk+1​=wk​−αk​▽w​f\",{\"1\":{\"389\":1}}],[\"到事务开始前的状态\",{\"1\":{\"510\":1}}],[\"到\",{\"1\":{\"389\":1,\"538\":1}}],[\"转义字符\",{\"0\":{\"546\":1}}],[\"转化为\",{\"1\":{\"388\":1}}],[\"转换\",{\"0\":{\"561\":1}}],[\"转换到\",{\"1\":{\"415\":1}}],[\"转换到状态s\",{\"1\":{\"305\":1}}],[\"转换为\",{\"1\":{\"343\":1,\"361\":1,\"362\":1,\"433\":1}}],[\"转换为数字666\",{\"1\":{\"228\":1}}],[\"转换流\",{\"0\":{\"126\":1}}],[\"▽w​q^​\",{\"1\":{\"427\":2}}],[\"▽w​qt​^​\",{\"1\":{\"424\":1,\"425\":1}}],[\"▽w​vt​^​\",{\"1\":{\"421\":1,\"422\":1,\"423\":1}}],[\"▽w​v^\",{\"1\":{\"421\":1}}],[\"▽w​\",{\"1\":{\"421\":1}}],[\"▽w​j​=e\",{\"1\":{\"427\":1}}],[\"▽w​j\",{\"1\":{\"389\":1,\"421\":1}}],[\"▽w​f\",{\"1\":{\"386\":2,\"389\":10}}],[\"▽θ​π\",{\"1\":{\"440\":1}}],[\"▽θ​lnπ\",{\"1\":{\"440\":6,\"441\":1}}],[\"▽θ​ln\",{\"1\":{\"311\":3}}],[\"▽θ​j\",{\"1\":{\"311\":1,\"440\":3}}],[\"⋅▽w​q^​\",{\"1\":{\"427\":1}}],[\"⋅\",{\"1\":{\"386\":1,\"395\":1}}],[\"η\",{\"1\":{\"384\":2,\"389\":2,\"395\":1,\"440\":1}}],[\"ηk2​∣hk​\",{\"1\":{\"383\":1}}],[\"ηk​∣hk​\",{\"1\":{\"383\":1}}],[\"ηk​\",{\"1\":{\"382\":3,\"384\":1,\"389\":1,\"395\":1}}],[\"应用于\",{\"0\":{\"384\":1}}],[\"应该是无人机最终停的位置即是部署的最佳位置\",{\"1\":{\"298\":1}}],[\"收钱的\",{\"1\":{\"460\":2}}],[\"收到服务器返回\",{\"1\":{\"448\":1}}],[\"收敛性情况\",{\"1\":{\"401\":1}}],[\"收敛性分析\",{\"0\":{\"383\":1}}],[\"收集完毕才能进行一次迭代\",{\"1\":{\"386\":1}}],[\"收益最大\",{\"1\":{\"333\":1}}],[\"问题\",{\"0\":{\"657\":1},\"1\":{\"388\":1,\"389\":1,\"395\":1}}],[\"问题转化\",{\"0\":{\"388\":1}}],[\"问题引入\",{\"0\":{\"381\":1,\"386\":1}}],[\"问题进行研究\",{\"1\":{\"377\":1}}],[\"针对\",{\"1\":{\"377\":1}}],[\"针对于这些特性\",{\"1\":{\"24\":1}}],[\"找的是在所有可能策略中的最优策略\",{\"1\":{\"373\":1}}],[\"找到尾部\",{\"1\":{\"59\":1}}],[\"ϵ−greedy\",{\"1\":{\"410\":1}}],[\"ϵ∈\",{\"1\":{\"372\":1}}],[\"ϵ\",{\"1\":{\"372\":2}}],[\"足够长的情况下\",{\"1\":{\"371\":1}}],[\"据目前而言\",{\"1\":{\"369\":1}}],[\"未能访问\",{\"1\":{\"369\":1}}],[\"未知时的情况\",{\"1\":{\"382\":1}}],[\"未知\",{\"1\":{\"9\":1,\"362\":1,\"381\":1}}],[\"均是随机变量\",{\"1\":{\"395\":1,\"426\":1}}],[\"均值估计\",{\"1\":{\"388\":1}}],[\"均收集完\",{\"1\":{\"367\":1}}],[\"均为非负整数\",{\"1\":{\"246\":1}}],[\"缺点\",{\"1\":{\"367\":1}}],[\"估计了q\",{\"1\":{\"367\":1}}],[\"估计中\",{\"1\":{\"366\":2}}],[\"什么时候更新策略也是一个影响效率的因素\",{\"1\":{\"367\":1}}],[\"什么都不写\",{\"1\":{\"121\":1}}],[\"记录在\",{\"1\":{\"366\":1}}],[\"记录当前数组元素数的\",{\"1\":{\"25\":1}}],[\"迭代\",{\"1\":{\"364\":1}}],[\"迭代器的使用是一次性的\",{\"1\":{\"34\":1}}],[\"迭代器\",{\"0\":{\"30\":1,\"33\":1},\"1\":{\"30\":1}}],[\"迭代器我们会在下一个部分讲解\",{\"1\":{\"24\":2}}],[\"≈▽θ​lnπ\",{\"1\":{\"440\":1}}],[\"≈vπ​\",{\"1\":{\"416\":1}}],[\"≈n1​i=1∑n​▽w​f\",{\"1\":{\"386\":1}}],[\"≈n1​i=1∑n​g\",{\"1\":{\"363\":1}}],[\"≈xˉ\",{\"1\":{\"379\":1}}],[\"≈xˉ=n1​j=1∑n​xj​\",{\"1\":{\"360\":1}}],[\"已连接到服务端\",{\"1\":{\"447\":1,\"448\":1}}],[\"已知的情况\",{\"1\":{\"381\":1}}],[\"已知\",{\"1\":{\"362\":1}}],[\"已经超过了readlimit\",{\"1\":{\"108\":1}}],[\"样本\",{\"1\":{\"427\":1}}],[\"样本必须是独立同分布\",{\"1\":{\"360\":1}}],[\"样本采样\",{\"1\":{\"360\":1}}],[\"蒙特卡洛方法\",{\"0\":{\"360\":1}}],[\"⋮\",{\"1\":{\"355\":4}}],[\"方言\",{\"1\":{\"472\":1}}],[\"方便后续比较\",{\"1\":{\"355\":1}}],[\"方法2\",{\"1\":{\"367\":1}}],[\"方法1\",{\"1\":{\"367\":1}}],[\"方法转换字符串\",{\"1\":{\"275\":1}}],[\"方法引用其实本质上就相当于将其他方法的实现\",{\"1\":{\"258\":1}}],[\"方法引用\",{\"0\":{\"258\":1},\"1\":{\"258\":2}}],[\"方法名\",{\"1\":{\"253\":1,\"258\":4}}],[\"方法名称\",{\"1\":{\"5\":2,\"672\":1}}],[\"方法名称同样可以随便起\",{\"1\":{\"5\":1}}],[\"方法参数的name\",{\"1\":{\"251\":1}}],[\"方法等\",{\"1\":{\"251\":1}}],[\"方法重写\",{\"0\":{\"216\":1}}],[\"方法上的标记是不是也可以通过这种方式获取注解\",{\"1\":{\"208\":1}}],[\"方法定义为\",{\"1\":{\"198\":1}}],[\"方法为某个对象\",{\"1\":{\"193\":1}}],[\"方法可以找到类中的非public构造方法\",{\"1\":{\"191\":1}}],[\"方法可以将当前线程进入休眠\",{\"1\":{\"143\":1}}],[\"方法用于获取可拆分迭代器\",{\"1\":{\"173\":1}}],[\"方法暂时处于等待状态\",{\"1\":{\"167\":1}}],[\"方法会暂时使得此线程进入等待状态\",{\"1\":{\"161\":1}}],[\"方法后\",{\"1\":{\"156\":1,\"161\":1}}],[\"方法是让该线程从\",{\"1\":{\"161\":1}}],[\"方法是强制终止线程\",{\"1\":{\"144\":1}}],[\"方法是语句的集合\",{\"1\":{\"5\":1}}],[\"方法强行停止\",{\"1\":{\"143\":1}}],[\"方法能够终止此线程\",{\"1\":{\"142\":1}}],[\"方法来看看实现类是个什么\",{\"1\":{\"570\":1}}],[\"方法来执行一个dml或是ddl语句\",{\"1\":{\"519\":1}}],[\"方法来执行select语句\",{\"1\":{\"519\":1}}],[\"方法来防止此类情况发生\",{\"1\":{\"449\":1}}],[\"方法来设定io超时时间\",{\"1\":{\"449\":1}}],[\"方法来获取一个类定义的指定字段\",{\"1\":{\"193\":1}}],[\"方法来获取类的权限为\",{\"1\":{\"191\":1}}],[\"方法来创建对应类型的实例\",{\"1\":{\"191\":1}}],[\"方法来使用单线程维持原本的顺序\",{\"1\":{\"173\":1}}],[\"方法来关闭它的工作线程\",{\"1\":{\"167\":1}}],[\"方法来实现线程的加入\",{\"1\":{\"148\":1}}],[\"方法来将当前资源让位给其他同优先级线程\",{\"1\":{\"147\":1}}],[\"方法来强行终止此线程\",{\"1\":{\"142\":1}}],[\"方法来让当前线程休眠一段时间\",{\"1\":{\"142\":1}}],[\"方法来运行此线程\",{\"1\":{\"140\":1}}],[\"方法得到一个字符串\",{\"1\":{\"127\":1}}],[\"方法进行求解\",{\"1\":{\"421\":1}}],[\"方法进行错误检查\",{\"1\":{\"127\":1}}],[\"方法进行判断的\",{\"1\":{\"84\":1}}],[\"方法时\",{\"1\":{\"84\":1,\"143\":1}}],[\"方法也相同\",{\"1\":{\"84\":1}}],[\"方法判断相同时\",{\"1\":{\"84\":1}}],[\"方法判断相同后\",{\"1\":{\"84\":1}}],[\"方法判断的\",{\"1\":{\"84\":1}}],[\"方法判定为\",{\"1\":{\"24\":1}}],[\"方法比较的是地址\",{\"1\":{\"84\":1}}],[\"方法内部本质上也是迭代器在处理\",{\"1\":{\"35\":1}}],[\"方法\",{\"0\":{\"59\":1,\"60\":1,\"140\":1,\"141\":1,\"142\":1,\"161\":1,\"236\":1,\"308\":1},\"1\":{\"35\":1,\"60\":1,\"66\":1,\"84\":2,\"91\":3,\"92\":1,\"127\":1,\"144\":1,\"191\":1,\"192\":2,\"198\":1,\"199\":2,\"208\":1,\"215\":1,\"362\":1,\"440\":1,\"449\":1,\"534\":1,\"540\":1,\"649\":1}}],[\"方法体\",{\"1\":{\"5\":1}}],[\"方法的名称等内容\",{\"1\":{\"192\":1}}],[\"方法的权限修饰符改为private后\",{\"1\":{\"192\":1}}],[\"方法的内容\",{\"1\":{\"138\":1}}],[\"方法的返回类型\",{\"1\":{\"8\":1}}],[\"方法的重载是为某个方法提供更多种类\",{\"1\":{\"216\":1}}],[\"方法的重载\",{\"0\":{\"8\":1}}],[\"方法的进阶使用\",{\"0\":{\"6\":1}}],[\"方法的调用\",{\"1\":{\"5\":1}}],[\"方法的定义如下\",{\"1\":{\"5\":1}}],[\"方法的创建与使用\",{\"0\":{\"5\":1}}],[\"步骤类似\",{\"1\":{\"364\":1}}],[\"步骤中\",{\"1\":{\"353\":2}}],[\"步来求解\",{\"1\":{\"356\":1}}],[\"步\",{\"1\":{\"348\":1}}],[\"动态\",{\"0\":{\"630\":1},\"1\":{\"600\":1}}],[\"动态sql在执行时可以进行各种条件判断以及循环拼接等操作\",{\"1\":{\"600\":1}}],[\"动态sql介绍\",{\"0\":{\"600\":1}}],[\"动态sql\",{\"0\":{\"598\":1}}],[\"动态规划\",{\"0\":{\"346\":1}}],[\"动作\",{\"1\":{\"304\":1,\"427\":1}}],[\"动作空间包含两个部分\",{\"1\":{\"299\":1}}],[\"动作空间\",{\"1\":{\"298\":1}}],[\"选择判断\",{\"0\":{\"602\":1}}],[\"选择对应的动作\",{\"1\":{\"369\":1}}],[\"选择移动方向和选择关联用户\",{\"1\":{\"299\":1}}],[\"选取当前状态下最大的\",{\"1\":{\"355\":2}}],[\"选取状态中最大的\",{\"1\":{\"338\":1}}],[\"唯一约束允许有空值\",{\"1\":{\"475\":1}}],[\"唯一约束保证列中所有的非空数据都是唯一的\",{\"1\":{\"475\":1}}],[\"唯一\",{\"1\":{\"338\":1,\"475\":1,\"476\":1}}],[\"贝尔曼最优公式\",{\"0\":{\"337\":1},\"1\":{\"346\":1}}],[\"贝尔曼公式\",{\"0\":{\"321\":1}}],[\"采取动作\",{\"1\":{\"363\":1}}],[\"采取一个指定的action可以得到的平均return\",{\"1\":{\"333\":1}}],[\"采用梯度下降\",{\"1\":{\"427\":1}}],[\"采用\",{\"1\":{\"364\":1,\"421\":1}}],[\"采用的是the\",{\"1\":{\"299\":1}}],[\"采用q\",{\"1\":{\"298\":1}}],[\"采用基于遗传算法的gak\",{\"1\":{\"298\":1}}],[\"采用mos作为用户qos衡量的标准\",{\"1\":{\"295\":1}}],[\"整合\",{\"1\":{\"331\":1}}],[\"整个idea程序都是由java编写的\",{\"1\":{\"516\":1}}],[\"整个内部类中都处于静态上下文\",{\"1\":{\"252\":1}}],[\"整个arraylist体系由于我们的反射操作\",{\"1\":{\"193\":1}}],[\"整个过程都是反射在代替进行操作\",{\"1\":{\"192\":1}}],[\"称为key\",{\"1\":{\"461\":1}}],[\"称为\",{\"1\":{\"398\":1}}],[\"称为策略评估\",{\"1\":{\"330\":1}}],[\"称之为\",{\"1\":{\"154\":1}}],[\"求一列的最小值\",{\"1\":{\"493\":1}}],[\"求一列的最大值\",{\"1\":{\"493\":1}}],[\"求一列的平均值\",{\"1\":{\"493\":1}}],[\"求一列的和\",{\"1\":{\"493\":1}}],[\"求一个数的算术平方根\",{\"1\":{\"274\":1}}],[\"求均值的方法\",{\"0\":{\"379\":1}}],[\"求在策略πk​下所有的\",{\"1\":{\"364\":1}}],[\"求解梯度还是很好求的\",{\"1\":{\"427\":1}}],[\"求解给定策略\",{\"1\":{\"396\":1}}],[\"求解当前策略的\",{\"1\":{\"355\":1}}],[\"求解下一步的vk+1​\",{\"1\":{\"348\":1}}],[\"求解方法\",{\"1\":{\"343\":1}}],[\"求解\",{\"0\":{\"343\":1},\"1\":{\"334\":1}}],[\"求解bellman\",{\"1\":{\"330\":1}}],[\"求出其对应状态的\",{\"1\":{\"332\":1}}],[\"求\",{\"1\":{\"326\":1}}],[\"核心部分\",{\"0\":{\"646\":1}}],[\"核心内容\",{\"0\":{\"322\":1}}],[\"核心思想\",{\"1\":{\"310\":1,\"361\":1}}],[\"伪代码\",{\"0\":{\"317\":1,\"349\":1,\"352\":1,\"409\":1,\"429\":1},\"1\":{\"401\":1}}],[\"证明\",{\"1\":{\"311\":1}}],[\"θt+1​=θt​+α▽θ​lnπ\",{\"1\":{\"441\":2}}],[\"θt+1​=θt​+α▽θ​j\",{\"1\":{\"433\":1}}],[\"θt+1​​=θt​+α▽θ​j\",{\"1\":{\"441\":1}}],[\"θt​\",{\"1\":{\"433\":1,\"441\":3}}],[\"θ∈rm表示参数向量\",{\"1\":{\"433\":1}}],[\"θ\",{\"1\":{\"311\":4,\"433\":2,\"436\":1,\"440\":20,\"441\":2}}],[\"θkn​​\",{\"1\":{\"294\":1}}],[\"策略梯度法\",{\"0\":{\"432\":1}}],[\"策略梯度上升\",{\"1\":{\"308\":1}}],[\"策略了\",{\"1\":{\"410\":1}}],[\"策略求解\",{\"1\":{\"355\":2}}],[\"策略提升\",{\"1\":{\"351\":1}}],[\"策略评估\",{\"1\":{\"351\":1}}],[\"策略更新\",{\"1\":{\"314\":1,\"367\":1}}],[\"策略为贪心策略\",{\"1\":{\"298\":1}}],[\"∣\",{\"1\":{\"372\":1}}],[\"∣−1action\",{\"1\":{\"372\":1}}],[\"∣−1\",{\"1\":{\"372\":1}}],[\"∣a\",{\"1\":{\"372\":3}}],[\"∣ϵ​\",{\"1\":{\"372\":2}}],[\"∣∣≤δ\",{\"1\":{\"351\":1}}],[\"∣∣≤γ∣∣x1​−x2​∣∣\",{\"1\":{\"343\":1}}],[\"∣∣vπk+1​\",{\"1\":{\"351\":1}}],[\"∣∣f\",{\"1\":{\"343\":1}}],[\"∣st​=s\",{\"1\":{\"404\":1}}],[\"∣s=s\",{\"1\":{\"398\":2}}],[\"∣s\",{\"1\":{\"305\":1,\"326\":1,\"329\":4,\"330\":3,\"331\":1,\"333\":2,\"340\":1,\"348\":2,\"351\":2,\"360\":1,\"362\":3,\"398\":1,\"400\":1}}],[\"∣kn​∣为第n个簇的用户总数\",{\"1\":{\"299\":1}}],[\"控制其一直待在target\",{\"1\":{\"304\":1}}],[\"控制符\",{\"0\":{\"217\":1}}],[\"γa∑​π\",{\"1\":{\"330\":1}}],[\"γ\",{\"1\":{\"324\":1,\"333\":1,\"395\":1}}],[\"γ接近1\",{\"1\":{\"304\":1}}],[\"γ∈\",{\"1\":{\"304\":1}}],[\"γkn​\",{\"1\":{\"296\":1,\"298\":1}}],[\"γkn​​\",{\"1\":{\"294\":1}}],[\"γk0​σ2μlos​pmax​​\",{\"1\":{\"294\":1}}],[\"指定构造方法后\",{\"1\":{\"569\":1}}],[\"指定构造方法\",{\"0\":{\"569\":1,\"628\":1}}],[\"指定查询某一列数据\",{\"1\":{\"490\":1}}],[\"指导agent在当前状态下选择哪个动作\",{\"1\":{\"304\":1}}],[\"指示编译器去忽略注解中声明的警告\",{\"1\":{\"204\":1}}],[\"π2\",{\"1\":{\"355\":1}}],[\"π2​=argmaxπ​\",{\"1\":{\"355\":1}}],[\"π1​=argmaxπ​\",{\"1\":{\"355\":2}}],[\"π180​θkn​​−ζ\",{\"1\":{\"294\":1}}],[\"π0​\",{\"1\":{\"355\":1}}],[\"π0​pe​vπ0​​pi​π1​pe​vπ1​​pi​π2​pe​vπ2​​pi​\",{\"1\":{\"350\":1,\"355\":1}}],[\"πk​的\",{\"1\":{\"353\":1}}],[\"πk​\",{\"1\":{\"351\":2,\"363\":1}}],[\"πk+1​=πargmax​\",{\"1\":{\"351\":1,\"355\":2}}],[\"πk+1​=argmaxπ​\",{\"1\":{\"348\":1,\"362\":1}}],[\"πk+1​\",{\"1\":{\"348\":2,\"351\":2,\"353\":1,\"364\":2}}],[\"π∗\",{\"1\":{\"338\":2}}],[\"π\",{\"1\":{\"304\":1,\"305\":1,\"325\":1,\"326\":1,\"329\":1,\"330\":1,\"333\":1,\"338\":1,\"342\":1,\"372\":1,\"396\":1,\"397\":1,\"398\":2,\"420\":1,\"433\":2,\"437\":3,\"440\":1}}],[\"训练阶段\",{\"1\":{\"299\":1}}],[\"基于垃圾回收器状态和软引用规则移除对象\",{\"1\":{\"612\":1}}],[\"基于函数表示的策略\",{\"1\":{\"433\":1}}],[\"基于函数的\",{\"1\":{\"415\":1}}],[\"基于策略\",{\"1\":{\"420\":1}}],[\"基于给定策略下\",{\"1\":{\"419\":1}}],[\"基于表格的\",{\"1\":{\"415\":1}}],[\"基于q\",{\"1\":{\"299\":1}}],[\"基本结构是由select子句\",{\"1\":{\"472\":1}}],[\"基本思路\",{\"0\":{\"433\":1}}],[\"基本形式\",{\"0\":{\"340\":1}}],[\"基本概念\",{\"0\":{\"302\":1,\"304\":1}}],[\"基本设置\",{\"0\":{\"293\":1}}],[\"基本上不会用到\",{\"1\":{\"253\":1}}],[\"基本类型是不支持的\",{\"1\":{\"281\":1}}],[\"基本类型\",{\"1\":{\"243\":1}}],[\"基本类型包装类\",{\"0\":{\"226\":1}}],[\"基本类型的比较跟之前一样\",{\"1\":{\"216\":1}}],[\"基本数据类型也有对应的class对象\",{\"1\":{\"183\":1}}],[\"基本数据类型的\",{\"0\":{\"183\":1}}],[\"基本示例\",{\"1\":{\"57\":1}}],[\"基本定义是\",{\"1\":{\"253\":1}}],[\"基本定义\",{\"0\":{\"56\":1}}],[\"右连接类似\",{\"1\":{\"497\":1}}],[\"右连接right\",{\"1\":{\"497\":1}}],[\"右\",{\"1\":{\"299\":1}}],[\"右转\",{\"1\":{\"298\":1}}],[\"需考虑用户的移动性\",{\"1\":{\"299\":1}}],[\"需要配置这些额外的参数\",{\"1\":{\"625\":1}}],[\"需要解决这个问题\",{\"1\":{\"616\":1}}],[\"需要在mybatis中开启批处理\",{\"1\":{\"599\":1}}],[\"需要在类的最上面添加package关键字来指明当前类所处的包\",{\"1\":{\"120\":1}}],[\"需要自动携带他们的小组\",{\"1\":{\"583\":1}}],[\"需要完整的包名+类名才可以\",{\"1\":{\"559\":1}}],[\"需要使用关联查询将用户的详细信息一并获取\",{\"1\":{\"578\":1}}],[\"需要使用\",{\"1\":{\"559\":1}}],[\"需要编写大量的get\",{\"1\":{\"538\":1}}],[\"需要添加表名前缀来指明是哪一个表的数据\",{\"1\":{\"495\":1}}],[\"需要考虑怎样对状态进行平均\",{\"1\":{\"418\":1}}],[\"需要求解一个优化问题\",{\"1\":{\"386\":1}}],[\"需要从\",{\"1\":{\"362\":1}}],[\"需要初始化猜测的\",{\"1\":{\"355\":1}}],[\"需要初始化策略π0​\",{\"1\":{\"355\":1}}],[\"需要确定几件事\",{\"1\":{\"338\":1}}],[\"需要通过采样解决\",{\"1\":{\"330\":1}}],[\"需要通过关键字\",{\"1\":{\"120\":2}}],[\"需要推导e\",{\"1\":{\"327\":1}}],[\"需要调整相应无人机的高度\",{\"1\":{\"294\":1}}],[\"需要合理选择无人机n的垂直高度hn​\",{\"1\":{\"294\":1}}],[\"需要由子类来完成\",{\"1\":{\"218\":1}}],[\"需要先进行导入才可以\",{\"1\":{\"120\":1}}],[\"需要进行大小限制\",{\"1\":{\"25\":1}}],[\"需要接受的参数类型并不确定时\",{\"1\":{\"14\":1}}],[\"∑s∈s​d\",{\"1\":{\"435\":1}}],[\"∑s∈s​dπ​\",{\"1\":{\"420\":1}}],[\"∑k=1∞​ak2​=∞\",{\"1\":{\"383\":1}}],[\"∑k=1∞​ak2​<∞\",{\"1\":{\"383\":1}}],[\"∑k=1∞​ak​=∞\",{\"1\":{\"383\":1}}],[\"∑kn​=1kn​​pkn​​\",{\"1\":{\"296\":1,\"298\":1}}],[\"∑i=1k−1​xi​+xk​\",{\"1\":{\"379\":1}}],[\"∑​pπ​\",{\"1\":{\"331\":1}}],[\"∑​p\",{\"1\":{\"329\":2,\"330\":2,\"333\":1,\"340\":1,\"348\":1,\"351\":2,\"362\":1,\"398\":1}}],[\"∑​vπ​\",{\"1\":{\"329\":2}}],[\"∑​e\",{\"1\":{\"329\":3}}],[\"∑n=1n​∣kn​∣是总用户数\",{\"1\":{\"299\":1}}],[\"算法是用来解决\",{\"1\":{\"404\":1}}],[\"算法是用来求解一个\",{\"1\":{\"398\":1}}],[\"算法如下来进行估计\",{\"1\":{\"401\":1}}],[\"算法同样是来求解\",{\"1\":{\"400\":1}}],[\"算法其目的是用于直接估计\",{\"1\":{\"400\":1}}],[\"算法分析\",{\"0\":{\"398\":1}}],[\"算法所需的数据\",{\"1\":{\"397\":1}}],[\"算法为\",{\"1\":{\"395\":1}}],[\"算法进行求解\",{\"1\":{\"395\":1}}],[\"算法进行求解g\",{\"1\":{\"389\":1}}],[\"算法\",{\"0\":{\"399\":1,\"442\":1},\"1\":{\"389\":2,\"390\":1,\"421\":1}}],[\"算法来进行求解\",{\"1\":{\"384\":1}}],[\"算法就可以用来求解当\",{\"1\":{\"382\":1}}],[\"算法介绍\",{\"0\":{\"382\":1}}],[\"算法流程\",{\"0\":{\"374\":1}}],[\"算法中\",{\"0\":{\"373\":1},\"1\":{\"423\":1}}],[\"算法的统一形式和总结\",{\"0\":{\"412\":1}}],[\"算法的比较\",{\"0\":{\"399\":1}}],[\"算法的问题描述中\",{\"1\":{\"390\":1}}],[\"算法的核心是\",{\"1\":{\"362\":1}}],[\"算法的基础上\",{\"1\":{\"308\":1}}],[\"算法思路\",{\"0\":{\"362\":1}}],[\"算法比较\",{\"0\":{\"355\":1}}],[\"算法描述\",{\"0\":{\"351\":1,\"397\":1}}],[\"算法迭代示意图\",{\"1\":{\"350\":1}}],[\"算法1\",{\"1\":{\"298\":1}}],[\"算术异常等\",{\"1\":{\"264\":1}}],[\"奖励\",{\"1\":{\"298\":1,\"304\":1}}],[\"静止\",{\"1\":{\"298\":1}}],[\"静态内部类编译特性\",{\"0\":{\"254\":1}}],[\"静态内部类由于是静态的\",{\"1\":{\"252\":1}}],[\"静态内部类的类名同样是之前的格式\",{\"1\":{\"252\":1}}],[\"静态内部类就像静态方法和静态变量一样\",{\"1\":{\"252\":1}}],[\"静态内部类\",{\"0\":{\"252\":1}}],[\"静态\",{\"1\":{\"249\":1}}],[\"静态初始化\",{\"1\":{\"235\":1}}],[\"静态导入test方法\",{\"1\":{\"121\":1}}],[\"静态导入\",{\"1\":{\"121\":1}}],[\"静态方法使用\",{\"1\":{\"258\":1}}],[\"静态方法甚至是类指定访问权限\",{\"1\":{\"121\":1}}],[\"静态方法同样是属于类的\",{\"1\":{\"117\":1}}],[\"静态变量\",{\"1\":{\"121\":1}}],[\"静态变量初始化\",{\"0\":{\"118\":1}}],[\"静态变量和静态方法\",{\"0\":{\"117\":1}}],[\"静态的内容\",{\"1\":{\"117\":1}}],[\"前\",{\"1\":{\"299\":1}}],[\"前进\",{\"1\":{\"298\":1}}],[\"前面我们学习了lombok\",{\"1\":{\"677\":1}}],[\"前面我们介绍了查询操作\",{\"1\":{\"588\":1}}],[\"前面我们已经了解如何使用泛型\",{\"1\":{\"16\":1}}],[\"前面说不推荐使用\",{\"1\":{\"156\":1}}],[\"左转\",{\"1\":{\"298\":1}}],[\"个样本\",{\"1\":{\"427\":1}}],[\"个人推导\",{\"1\":{\"329\":1}}],[\"个人感觉是这个\",{\"1\":{\"298\":1}}],[\"个人理解\",{\"1\":{\"298\":1,\"304\":1}}],[\"个\",{\"1\":{\"298\":1}}],[\"个类型的实参\",{\"1\":{\"241\":1}}],[\"×\",{\"1\":{\"298\":2}}],[\"智能体\",{\"1\":{\"298\":1}}],[\"目的是最小化目标函数\",{\"1\":{\"426\":1}}],[\"目标函数梯度求解\",{\"0\":{\"440\":1}}],[\"目标函数定义\",{\"0\":{\"434\":1}}],[\"目标\",{\"1\":{\"417\":1}}],[\"目标是获得无人机的最佳3d位置\",{\"1\":{\"298\":1}}],[\"目前的优化算法只是在估计给定策略的\",{\"1\":{\"421\":1}}],[\"目前各位小伙伴就暂时理解为会返回对象存放的内存地址\",{\"1\":{\"215\":1}}],[\"目前暂时不会用到\",{\"1\":{\"215\":3}}],[\"目前\",{\"1\":{\"50\":1}}],[\"划分完毕\",{\"1\":{\"298\":1}}],[\"水平位置和高度\",{\"1\":{\"296\":1}}],[\"总结\",{\"0\":{\"334\":1}}],[\"总用户的mos取决于无人机的发射功率\",{\"1\":{\"296\":1}}],[\"总分\",{\"1\":{\"65\":1}}],[\"∀\",{\"1\":{\"401\":1,\"405\":1}}],[\"∀s\",{\"1\":{\"400\":1,\"404\":1}}],[\"∀s=st​\",{\"1\":{\"397\":1}}],[\"∀s∈s​\",{\"1\":{\"340\":1}}],[\"∀s∈s=πmax​a∑​π\",{\"1\":{\"340\":1}}],[\"∀s∈s\",{\"1\":{\"330\":1,\"343\":1}}],[\"∀kn​\",{\"1\":{\"296\":3,\"298\":3}}],[\"∀t\",{\"1\":{\"296\":4,\"298\":4}}],[\"∀n\",{\"1\":{\"296\":2,\"298\":2}}],[\"发现在该位置静止是最优的\",{\"1\":{\"298\":1}}],[\"发现对于\",{\"1\":{\"218\":1}}],[\"发送端的时间\",{\"1\":{\"295\":1}}],[\"共两步\",{\"1\":{\"417\":1}}],[\"共分为\",{\"1\":{\"348\":1}}],[\"共考虑7个方向\",{\"1\":{\"298\":1}}],[\"共划分5个等级\",{\"1\":{\"295\":1}}],[\"共有三种方法\",{\"1\":{\"182\":1}}],[\"高于等于此级别的所有日志都会被打印\",{\"1\":{\"640\":1}}],[\"高效地更新\",{\"0\":{\"367\":1}}],[\"高度h=hn​\",{\"1\":{\"296\":1}}],[\"高度的上界是最大发射功率pmax​的函数\",{\"1\":{\"294\":1}}],[\"高速缓存通过保存内存中数据的副本来提供更加快速的数据访问\",{\"1\":{\"154\":1}}],[\"≤c2​\",{\"1\":{\"383\":1}}],[\"≤pmax​\",{\"1\":{\"296\":1,\"298\":1}}],[\"≤hmax​\",{\"1\":{\"296\":1,\"298\":1}}],[\"≤hn​\",{\"1\":{\"294\":1}}],[\"≤\",{\"1\":{\"294\":1}}],[\"ζ2​是系数\",{\"1\":{\"295\":1}}],[\"ζ1​\",{\"1\":{\"295\":1}}],[\"ζ+em\",{\"1\":{\"294\":1}}],[\"ζ是由环境决定的常数\",{\"1\":{\"294\":1}}],[\"信息\",{\"1\":{\"636\":1,\"647\":1,\"657\":2}}],[\"信道容量c=b∗log\",{\"1\":{\"294\":1}}],[\"信号模型\",{\"0\":{\"294\":1}}],[\"且对象不能被修改\",{\"1\":{\"612\":1}}],[\"且该列的值不能为空\",{\"1\":{\"476\":1}}],[\"且不能为空且唯一\",{\"1\":{\"475\":1}}],[\"且有一个管理员只在一个仓库工作\",{\"1\":{\"467\":1}}],[\"且其他的属性必须完全依赖于主键\",{\"1\":{\"465\":1}}],[\"且需要被求解出来\",{\"1\":{\"381\":1}}],[\"且最终会收敛到最优策略v∗\",{\"1\":{\"353\":1}}],[\"且\",{\"1\":{\"338\":1,\"372\":1,\"383\":2,\"420\":1,\"429\":1}}],[\"且ζ1​+ζ2​=1\",{\"1\":{\"295\":1}}],[\"且传输率永远都不可能超过信道容量c\",{\"1\":{\"294\":1}}],[\"且无人机向关联用户的发射功率是恒定的\",{\"1\":{\"294\":1}}],[\"且同样不能使用\",{\"1\":{\"218\":1}}],[\"μnlos​\",{\"1\":{\"294\":1}}],[\"μnlos​是表示los和nlos链路的衰减因子\",{\"1\":{\"294\":1}}],[\"μlos​−μnlos​\",{\"1\":{\"294\":1}}],[\"μlos​\",{\"1\":{\"294\":1}}],[\"α是表示路径损耗指数\",{\"1\":{\"294\":1}}],[\"​≐a∈a∑​π\",{\"1\":{\"438\":1}}],[\"​≐g\",{\"1\":{\"384\":1}}],[\"​q^​\",{\"1\":{\"427\":3}}],[\"​tderrorδt​​\",{\"1\":{\"397\":1}}],[\"​forthegreedyaction\",{\"1\":{\"372\":1}}],[\"​vu​u2​pu​\",{\"1\":{\"355\":1}}],[\"​vu​u1​pu​π2\",{\"1\":{\"355\":1}}],[\"​p\",{\"1\":{\"333\":1}}],[\"​​−αt​\",{\"1\":{\"397\":1}}],[\"​​=currentestimatevt​\",{\"1\":{\"397\":1}}],[\"​​=a∑​qπ​\",{\"1\":{\"333\":1}}],[\"​​+η∇w​f\",{\"1\":{\"389\":1}}],[\"​​π\",{\"1\":{\"333\":1}}],[\"​​\",{\"1\":{\"330\":1,\"351\":1,\"389\":2,\"397\":1}}],[\"​=π\",{\"1\":{\"440\":1}}],[\"​=πmax​a∑​π\",{\"1\":{\"340\":1}}],[\"​=▽w​e\",{\"1\":{\"421\":1}}],[\"​=qt​\",{\"1\":{\"401\":1,\"405\":1}}],[\"​=vt​\",{\"1\":{\"397\":1}}],[\"​=∇w​f\",{\"1\":{\"389\":1}}],[\"​=w−e\",{\"1\":{\"395\":1}}],[\"​=w−x​=w−x+e\",{\"1\":{\"384\":1}}],[\"​=wk​−k1​\",{\"1\":{\"379\":1}}],[\"​=argmaxπ​\",{\"1\":{\"355\":1}}],[\"​=a∑​π\",{\"1\":{\"328\":1,\"329\":1}}],[\"​=rπk​​+γpπk​​vπk​\",{\"1\":{\"353\":1}}],[\"​=s∈s∑​d\",{\"1\":{\"440\":1}}],[\"​=s∈s∑​η\",{\"1\":{\"440\":1}}],[\"​=s\",{\"1\":{\"329\":1}}],[\"​=e\",{\"1\":{\"327\":1,\"330\":1}}],[\"​=es∼η\",{\"1\":{\"311\":1}}],[\"​=ϕ\",{\"1\":{\"293\":1,\"296\":1,\"298\":1}}],[\"​ifmosnew​>mosold​ifmosnew​=mosold​ifmosnew​<mosold​​\",{\"1\":{\"298\":1}}],[\"​≥0\",{\"1\":{\"296\":1,\"298\":1}}],[\"​≥γkn​​\",{\"1\":{\"296\":1,\"298\":1}}],[\"​−μlos​−μnlos​μnlos​​​s\",{\"1\":{\"294\":1}}],[\"​\",{\"1\":{\"294\":3,\"295\":1,\"296\":1,\"298\":1,\"311\":1,\"327\":1,\"329\":2,\"330\":1,\"331\":1,\"333\":2,\"340\":1,\"348\":1,\"351\":5,\"353\":1,\"362\":1,\"366\":2,\"372\":1,\"379\":1,\"389\":2,\"397\":1,\"401\":1,\"405\":1,\"421\":1,\"427\":1,\"438\":1,\"440\":2,\"441\":1}}],[\"​hn​\",{\"1\":{\"294\":1}}],[\"−2\",{\"1\":{\"427\":2}}],[\"−q^​\",{\"1\":{\"424\":1,\"425\":1,\"426\":1,\"427\":3}}],[\"−v^\",{\"1\":{\"418\":1,\"419\":2,\"420\":2,\"421\":4,\"423\":1}}],[\"−vπk​\",{\"1\":{\"351\":1}}],[\"−tdtargetvt​ˉ​\",{\"1\":{\"397\":1}}],[\"−αt​\",{\"1\":{\"397\":1,\"401\":1,\"405\":1}}],[\"−\",{\"1\":{\"395\":1,\"397\":1,\"401\":1,\"405\":1}}],[\"−x\",{\"1\":{\"384\":1}}],[\"−xkn​​\",{\"1\":{\"293\":1}}],[\"−e\",{\"1\":{\"384\":1,\"389\":2}}],[\"−f\",{\"1\":{\"343\":1}}],[\"−b\",{\"1\":{\"311\":1}}],[\"−0\",{\"1\":{\"298\":1}}],[\"−1rπk​​\",{\"1\":{\"353\":1}}],[\"−1rπ​\",{\"1\":{\"332\":1}}],[\"−1rπ​​\",{\"1\":{\"332\":1}}],[\"−1\",{\"1\":{\"294\":1,\"295\":2,\"298\":4}}],[\"−ykn​​\",{\"1\":{\"293\":1}}],[\"∈\",{\"1\":{\"293\":1}}],[\"飞行速度恒定\",{\"1\":{\"293\":1}}],[\"考虑能否仅用一次\",{\"1\":{\"386\":1}}],[\"考虑一个复杂的均值估计问题\",{\"1\":{\"395\":1}}],[\"考虑一个\",{\"1\":{\"366\":1}}],[\"考虑\",{\"1\":{\"355\":2}}],[\"考虑用户在每个时隙移动的情况\",{\"1\":{\"299\":1}}],[\"考虑以下场景\",{\"1\":{\"298\":1}}],[\"考虑无人机辅助无线网络的下行链路传输\",{\"1\":{\"293\":1}}],[\"考虑qoe\",{\"1\":{\"289\":1}}],[\"系统属性\",{\"1\":{\"666\":1}}],[\"系统结构\",{\"0\":{\"292\":1}}],[\"系统输入流\",{\"1\":{\"128\":1}}],[\"更积极地基于垃圾收集器状态和弱引用规则移除对象\",{\"1\":{\"612\":1}}],[\"更推荐使用批处理来优化这种情况\",{\"1\":{\"599\":1}}],[\"更不用说如果我还需要进行实体类映射\",{\"1\":{\"544\":1}}],[\"更新\",{\"1\":{\"524\":1,\"593\":1}}],[\"更新与删除\",{\"1\":{\"472\":1}}],[\"更新一定次数后\",{\"1\":{\"427\":1}}],[\"更新策略的步骤就是选择此时\",{\"1\":{\"362\":1}}],[\"更加高效利用\",{\"1\":{\"365\":1}}],[\"更注重长远的reward\",{\"1\":{\"304\":1}}],[\"更远视\",{\"1\":{\"304\":1}}],[\"更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署\",{\"1\":{\"289\":1}}],[\"更简洁\",{\"1\":{\"285\":1}}],[\"较繁琐\",{\"1\":{\"285\":1}}],[\"及以上\",{\"1\":{\"285\":2}}],[\"及其子类\",{\"1\":{\"88\":2}}],[\"带初始值的初始化\",{\"1\":{\"285\":1}}],[\"率\",{\"1\":{\"280\":1}}],[\"项目中代码量非常之大\",{\"1\":{\"280\":1}}],[\"显然map用起来更便捷一些\",{\"1\":{\"562\":1}}],[\"显然是\",{\"1\":{\"435\":1}}],[\"显然是可以通过一个\",{\"1\":{\"351\":1}}],[\"显然我们仍然可以通过\",{\"1\":{\"395\":1}}],[\"显然我们可以将\",{\"1\":{\"389\":1}}],[\"显然ϵ=0\",{\"1\":{\"372\":1}}],[\"显然其核心关键就是在\",{\"1\":{\"362\":1}}],[\"显然在现实运行算法中是无法做到的\",{\"1\":{\"356\":1}}],[\"显然\",{\"1\":{\"304\":1,\"308\":1,\"348\":1,\"356\":1,\"363\":1,\"371\":1,\"381\":1,\"389\":1}}],[\"显然无法在编译期确定类型是否安全\",{\"1\":{\"280\":1}}],[\"显示声明了会抛出一个interruptedexception异常\",{\"1\":{\"143\":1}}],[\"取值范围从1−4\",{\"1\":{\"295\":1}}],[\"取值只能进行强制类型转换\",{\"1\":{\"280\":1}}],[\"取消这些不必要保存的属性\",{\"1\":{\"133\":1}}],[\"良好\",{\"1\":{\"280\":1}}],[\"课程成绩\",{\"1\":{\"280\":1}}],[\"课程号\",{\"1\":{\"280\":1}}],[\"常用的handler实现有\",{\"1\":{\"646\":1}}],[\"常用\",{\"0\":{\"491\":1}}],[\"常用工具类\",{\"0\":{\"273\":1}}],[\"常见的数据库有很多种\",{\"1\":{\"460\":1}}],[\"常数\",{\"1\":{\"294\":1}}],[\"常规优先级\",{\"1\":{\"145\":1}}],[\"便于我们去使用的类\",{\"1\":{\"272\":1}}],[\"断言表达式\",{\"0\":{\"268\":1}}],[\"永远都不会被捕获\",{\"1\":{\"267\":2}}],[\"捕获到异常\",{\"1\":{\"267\":1}}],[\"捕获异常\",{\"1\":{\"264\":1}}],[\"抛出\",{\"1\":{\"285\":1}}],[\"抛出异常\",{\"0\":{\"266\":1}}],[\"抛给上一级\",{\"1\":{\"267\":1}}],[\"明确会抛出ioexception\",{\"1\":{\"267\":1}}],[\"处理\",{\"1\":{\"267\":1}}],[\"处理单位\",{\"1\":{\"88\":3}}],[\"给定的策略\",{\"1\":{\"439\":1}}],[\"给定策略\",{\"1\":{\"398\":1}}],[\"给\",{\"1\":{\"267\":1}}],[\"交给上一级函数\",{\"1\":{\"267\":1}}],[\"函数和存储过程并没有包含在我们的教程当中\",{\"1\":{\"510\":1}}],[\"函数调用方必须要对抛出的这个异常进行对应的处理才可以\",{\"1\":{\"266\":1}}],[\"函数的\",{\"0\":{\"242\":1}}],[\"空值\",{\"1\":{\"475\":1}}],[\"空指针异常\",{\"1\":{\"264\":1}}],[\"空集合\",{\"0\":{\"79\":1}}],[\"卡布奇诺今犹在\",{\"1\":{\"258\":1}}],[\"待实现的求和方法\",{\"1\":{\"258\":1}}],[\"今天学会了\",{\"1\":{\"257\":5}}],[\"今年\",{\"1\":{\"5\":1}}],[\"匿名类只能访问其父类的属性或方法\",{\"1\":{\"255\":1}}],[\"匿名对象通常不能直接给属性赋值\",{\"1\":{\"255\":1}}],[\"匿名对象的类是在创建时匿名生成的\",{\"1\":{\"255\":1}}],[\"匿名对象本身不能定义新的属性\",{\"1\":{\"255\":1}}],[\"匿名内部类特性\",{\"0\":{\"256\":1}}],[\"匿名内部类中同样可以使用类中的属性\",{\"1\":{\"255\":1}}],[\"匿名内部类是我们使用频率非常高的一种内部类\",{\"1\":{\"255\":1}}],[\"匿名内部类\",{\"0\":{\"255\":1},\"1\":{\"256\":1}}],[\"匿名内部类在java8无法使用钻石运算符\",{\"1\":{\"25\":1}}],[\"把未实现的方法实现了\",{\"1\":{\"255\":1}}],[\"把对象的属性和方法结合成一个独立的整体\",{\"1\":{\"212\":1}}],[\"局部内部类直接使用类名就行\",{\"1\":{\"253\":1}}],[\"局部内部类名\",{\"1\":{\"253\":1}}],[\"局部内部类就像局部变量一样\",{\"1\":{\"253\":1}}],[\"局部内部类\",{\"0\":{\"253\":1}}],[\"依赖导入完成后\",{\"1\":{\"552\":1}}],[\"依赖于当前状态和所采取的动作\",{\"1\":{\"304\":1}}],[\"依然可以被其他会话直接使用\",{\"1\":{\"612\":1}}],[\"依然会被反射赋值\",{\"1\":{\"569\":1}}],[\"依然使用泛型\",{\"1\":{\"282\":1}}],[\"依然是就近原则\",{\"1\":{\"251\":1}}],[\"依附任何对象我们可以直接创建使用\",{\"1\":{\"252\":1}}],[\"依附于b创建的对象\",{\"1\":{\"251\":1}}],[\"依附于a创建的对象\",{\"1\":{\"251\":1}}],[\"依次打印\",{\"1\":{\"71\":1}}],[\"套娃了属于是\",{\"1\":{\"251\":1}}],[\"套壳实现的\",{\"1\":{\"67\":1}}],[\"外连接有三种方式\",{\"1\":{\"497\":1}}],[\"外连接就是专门用于联合查询情景的\",{\"1\":{\"497\":1}}],[\"外连接查询\",{\"0\":{\"497\":1}}],[\"外键约束用于在两个表之间建立参照完整性关系\",{\"1\":{\"476\":1}}],[\"外键\",{\"1\":{\"475\":1,\"476\":2}}],[\"外\",{\"1\":{\"340\":1}}],[\"外部类初始化\",{\"1\":{\"254\":2}}],[\"外部类父类的tostring方法\",{\"1\":{\"251\":1}}],[\"外部类的tosrting方法\",{\"1\":{\"251\":1}}],[\"外部是无法访问到这个内部类的\",{\"1\":{\"251\":1}}],[\"外层\",{\"1\":{\"251\":1}}],[\"属性可以被设置为\",{\"1\":{\"612\":1}}],[\"属性则是通过反射进行赋值\",{\"1\":{\"569\":1}}],[\"属性的值由单引号或双引号包括\",{\"1\":{\"545\":1}}],[\"属性取值可以有一定的约束\",{\"1\":{\"461\":1}}],[\"属性不可再分\",{\"1\":{\"461\":1}}],[\"属性具有以下特点\",{\"1\":{\"461\":1}}],[\"属性默认就是这个值\",{\"1\":{\"9\":1}}],[\"属于\",{\"0\":{\"251\":1,\"252\":1},\"1\":{\"249\":2}}],[\"下午\",{\"1\":{\"636\":1}}],[\"下一次读取将直接无法获取到这行数据\",{\"1\":{\"616\":1}}],[\"下次需要获取数据时\",{\"1\":{\"610\":1}}],[\"下面这种情况\",{\"1\":{\"563\":1}}],[\"下同\",{\"1\":{\"493\":1}}],[\"下的\",{\"1\":{\"420\":1,\"437\":1}}],[\"下行\",{\"1\":{\"298\":1}}],[\"下划线\",{\"1\":{\"246\":1}}],[\"下界限定就像这样\",{\"1\":{\"15\":1}}],[\"下界\",{\"1\":{\"15\":1}}],[\"非空\",{\"1\":{\"475\":1}}],[\"非空白符\",{\"1\":{\"246\":1}}],[\"非常难以阅读\",{\"1\":{\"648\":1}}],[\"非常智能\",{\"1\":{\"589\":1}}],[\"非常鸡肋\",{\"1\":{\"563\":1}}],[\"非常耗时\",{\"1\":{\"138\":1}}],[\"非常方便\",{\"1\":{\"25\":1}}],[\"^\",{\"1\":{\"246\":1}}],[\"^aeiou\",{\"1\":{\"246\":1}}],[\"^abc\",{\"1\":{\"246\":1}}],[\"请输入要发送给服务端的内容\",{\"1\":{\"448\":1}}],[\"请调用方处理好\",{\"1\":{\"266\":1}}],[\"请注意在逗号和两个数之间不能有空格\",{\"1\":{\"246\":1}}],[\"请将\",{\"1\":{\"198\":1}}],[\"至少匹配n\",{\"1\":{\"246\":1}}],[\"至于为什么默认是0\",{\"1\":{\"60\":1}}],[\"至于为什么要这样设计\",{\"1\":{\"31\":1}}],[\"次的观测值\",{\"1\":{\"382\":1}}],[\"次方程根的估计\",{\"1\":{\"382\":1}}],[\"次且最多匹配\",{\"1\":{\"246\":1}}],[\"次\",{\"1\":{\"246\":4}}],[\"例如拼接时要确保不能忘记添加必要的空格\",{\"1\":{\"600\":1}}],[\"例如将成绩在平均成绩之上的元组定义成一个视图good\",{\"1\":{\"507\":1}}],[\"例如\",{\"1\":{\"246\":8}}],[\"例如当向printstream流中写入一个字节数组后自动调用flush\",{\"1\":{\"127\":1}}],[\"匹配字母\",{\"1\":{\"246\":1}}],[\"匹配字符串\",{\"1\":{\"246\":2}}],[\"匹配所有\",{\"1\":{\"246\":1}}],[\"匹配所有大写字母\",{\"1\":{\"246\":1}}],[\"匹配除换行符\",{\"1\":{\"246\":1}}],[\"匹配除了\",{\"1\":{\"246\":1}}],[\"匹配\",{\"1\":{\"246\":1}}],[\"匹配确定的\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式零次或一次\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式零次或多次\",{\"1\":{\"246\":1}}],[\"匹配前面的子表达式一次或多次\",{\"1\":{\"246\":1}}],[\"匹配成功返回true\",{\"1\":{\"246\":1}}],[\"描述如下\",{\"1\":{\"298\":1}}],[\"描述\",{\"1\":{\"246\":2}}],[\"描述了一种字符串匹配的模式\",{\"1\":{\"246\":1}}],[\"限定符表如下\",{\"1\":{\"246\":1}}],[\"汉堡\",{\"1\":{\"245\":2}}],[\"汉堡做滴彳亍不彳亍\",{\"1\":{\"113\":1}}],[\"弥补了字符串不能修改的不足\",{\"1\":{\"245\":1}}],[\"裁剪等操作\",{\"1\":{\"245\":1}}],[\"哥们在这跟你说唱\",{\"1\":{\"241\":1}}],[\"哥们这瓜多少钱一斤\",{\"1\":{\"199\":2}}],[\"答案是可以的\",{\"1\":{\"240\":1}}],[\"允许便捷式访问底层数据库\",{\"1\":{\"515\":1}}],[\"允许列中的某些行没有值\",{\"1\":{\"475\":1}}],[\"允许包含\",{\"1\":{\"285\":1}}],[\"允许\",{\"1\":{\"239\":1}}],[\"允许在任何地方被访问\",{\"1\":{\"121\":1}}],[\"肯定是继承自object的\",{\"1\":{\"235\":1}}],[\"肯定的啊\",{\"1\":{\"15\":1}}],[\"面向对象高级篇\",{\"0\":{\"233\":1,\"262\":1,\"272\":1}}],[\"面向对象高级篇1\",{\"0\":{\"225\":1}}],[\"精确到小数点后100位\",{\"1\":{\"229\":1}}],[\"浮点类型精度有限\",{\"1\":{\"229\":1}}],[\"乘法\",{\"1\":{\"229\":1}}],[\"轻轻松松\",{\"1\":{\"229\":1}}],[\"轻松地就实现了\",{\"1\":{\"67\":1}}],[\"特性\",{\"0\":{\"238\":1},\"1\":{\"285\":1}}],[\"特殊包装类\",{\"0\":{\"229\":1}}],[\"特别注意一下\",{\"1\":{\"25\":1}}],[\"内层查询中涉及的表也是sc\",{\"1\":{\"507\":1}}],[\"内嵌迭代算法求解\",{\"1\":{\"355\":1}}],[\"内存占用已经超出限制\",{\"1\":{\"264\":1}}],[\"内存也会消耗更多\",{\"1\":{\"227\":1}}],[\"内容\",{\"1\":{\"253\":1}}],[\"内部的内容都是子节点\",{\"1\":{\"547\":1}}],[\"内部的数据结构\",{\"1\":{\"67\":1}}],[\"内部有实现\",{\"1\":{\"517\":1}}],[\"内部类静态方法\",{\"1\":{\"254\":2}}],[\"内部类初始化\",{\"1\":{\"254\":2}}],[\"内部类父类的tostring方法\",{\"1\":{\"251\":1}}],[\"内部类自己的tostring方法\",{\"1\":{\"251\":1}}],[\"内部类名称\",{\"1\":{\"251\":1}}],[\"内部类也是类\",{\"1\":{\"251\":1}}],[\"内部类顾名思义\",{\"1\":{\"250\":1}}],[\"内部类\",{\"0\":{\"249\":1,\"250\":1}}],[\"内部什么都没有\",{\"1\":{\"245\":1}}],[\"内部使用结点\",{\"1\":{\"58\":1}}],[\"内部使用的结点类\",{\"1\":{\"25\":1}}],[\"覆盖原有构造方法\",{\"1\":{\"221\":1}}],[\"覆盖之后\",{\"1\":{\"59\":1}}],[\"枚举的成员变量\",{\"1\":{\"221\":1}}],[\"枚举类型是普通的类\",{\"1\":{\"221\":1}}],[\"枚举类型使用起来就非常方便了\",{\"1\":{\"221\":1}}],[\"枚举类的语法稍微有一些不一样\",{\"1\":{\"221\":1}}],[\"枚举类\",{\"0\":{\"221\":1}}],[\"睡觉\",{\"1\":{\"221\":2}}],[\"睡觉这三个之中的其中一种\",{\"1\":{\"221\":1}}],[\"学号为\",{\"1\":{\"527\":1}}],[\"学号发生改变就代表学生发生改变\",{\"1\":{\"465\":1}}],[\"学号是每个学生的唯一标识\",{\"1\":{\"465\":1}}],[\"学号\",{\"1\":{\"461\":1,\"462\":2,\"465\":1}}],[\"学习和使用xml只是为了更好地去认识mybatis的工作原理\",{\"1\":{\"547\":1}}],[\"学习厉害的框架或是厉害的技术\",{\"1\":{\"544\":1}}],[\"学习\",{\"1\":{\"221\":2}}],[\"学生学号\",{\"1\":{\"466\":2}}],[\"学生借书情况\",{\"1\":{\"466\":2}}],[\"学生表\",{\"1\":{\"462\":1}}],[\"学生\",{\"1\":{\"219\":1,\"220\":1,\"462\":1,\"464\":2,\"465\":1}}],[\"学生和老师来说\",{\"1\":{\"219\":1}}],[\"深拷贝会将引用类型的所有内容\",{\"1\":{\"220\":1}}],[\"深拷贝\",{\"1\":{\"220\":1}}],[\"拷贝个基莫\",{\"1\":{\"220\":1}}],[\"浅拷贝\",{\"1\":{\"220\":1}}],[\"克隆实现\",{\"1\":{\"220\":1}}],[\"克隆操作可以完全复制一个对象的所有属性\",{\"1\":{\"220\":1}}],[\"克隆出来的与原来的对象不是一个对象\",{\"1\":{\"220\":1}}],[\"克隆方法\",{\"0\":{\"220\":1}}],[\"克隆当前对象\",{\"1\":{\"215\":1}}],[\"顶多说是多继承的一种替代方案\",{\"1\":{\"219\":1}}],[\"逗号\",{\"1\":{\"219\":1}}],[\"甚至直接没有重新构造对象\",{\"1\":{\"611\":1}}],[\"甚至当字段变得很多时\",{\"1\":{\"538\":1}}],[\"甚至连名字都没有\",{\"1\":{\"255\":1}}],[\"甚至还可以继续套娃一个成员内部类\",{\"1\":{\"251\":1}}],[\"甚至还能获取到泛型\",{\"1\":{\"179\":1}}],[\"甚至都不是一个类了\",{\"1\":{\"219\":1}}],[\"甚至都不是一个类\",{\"1\":{\"219\":1}}],[\"他只代表某个确切的功能\",{\"1\":{\"219\":1}}],[\"他们可以添加到类或是字段上\",{\"1\":{\"540\":1}}],[\"他们可能会做不同的事情\",{\"1\":{\"120\":1}}],[\"他们都继承自\",{\"1\":{\"264\":1}}],[\"他们都具有学习这个能力\",{\"1\":{\"219\":1}}],[\"他们其实都是异常类型\",{\"1\":{\"264\":1}}],[\"他们其实是需要配合synchronized来使用的\",{\"1\":{\"161\":1}}],[\"他们存储了方法的信息\",{\"1\":{\"192\":1}}],[\"抽象成接口来进行使用\",{\"1\":{\"219\":1}}],[\"抽象方法的访问权限不能为\",{\"1\":{\"218\":1}}],[\"抽象方法是指\",{\"1\":{\"218\":1}}],[\"抽象方法\",{\"1\":{\"218\":2}}],[\"抽象类中可以具有抽象方法\",{\"1\":{\"218\":1}}],[\"抽象类的子类也可以是一个抽象类\",{\"1\":{\"218\":1}}],[\"抽象类的实现\",{\"1\":{\"186\":1}}],[\"抽象类一般只用作继承使用\",{\"1\":{\"218\":1}}],[\"抽象类具有\",{\"1\":{\"218\":1}}],[\"抽象类\",{\"0\":{\"218\":1},\"1\":{\"218\":1,\"282\":1}}],[\"加权均值\",{\"1\":{\"333\":1}}],[\"加上它们在参数列表中的位置来命名\",{\"1\":{\"571\":1}}],[\"加上\",{\"1\":{\"333\":1}}],[\"加\",{\"1\":{\"217\":1}}],[\"做滴\",{\"1\":{\"245\":2}}],[\"做题我并不擅长\",{\"1\":{\"216\":1,\"218\":1}}],[\"做传输媒介\",{\"1\":{\"94\":1}}],[\"重启idea\",{\"1\":{\"539\":1}}],[\"重新开启自动提交\",{\"1\":{\"534\":1}}],[\"重新修改为\",{\"1\":{\"331\":1}}],[\"重要性采样\",{\"0\":{\"315\":1},\"1\":{\"314\":1}}],[\"重复\",{\"0\":{\"657\":1}}],[\"重复步骤\",{\"1\":{\"298\":1}}],[\"重复字符串\",{\"1\":{\"71\":1}}],[\"重写方法可以添加\",{\"1\":{\"216\":1}}],[\"重写方法要求与父类的定义完全一致\",{\"1\":{\"216\":2}}],[\"垃圾\",{\"1\":{\"215\":1}}],[\"完整类名\",{\"1\":{\"215\":1}}],[\"完成自我介绍需要执行的所有代码就在这个花括号中编写\",{\"1\":{\"5\":1}}],[\"父类型在前\",{\"1\":{\"267\":1}}],[\"父类是\",{\"1\":{\"214\":1}}],[\"父加载器\",{\"1\":{\"198\":1}}],[\"正在等待客户端连接\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"正确性和收敛性分析\",{\"0\":{\"389\":1}}],[\"正好可以匹配\",{\"1\":{\"246\":1}}],[\"正则表达式并不是只有java才支持\",{\"1\":{\"246\":1}}],[\"正则表达式\",{\"0\":{\"232\":1,\"246\":1},\"1\":{\"246\":2}}],[\"正是这三大特性\",{\"1\":{\"212\":1}}],[\"正常实例化方法是无法创造抽象类的实例\",{\"1\":{\"218\":1}}],[\"正常情况下是不会出错的\",{\"1\":{\"264\":1}}],[\"正常情况下\",{\"1\":{\"186\":1,\"255\":1}}],[\"正常插入键值对返回值为null\",{\"1\":{\"59\":1}}],[\"叫子类\",{\"1\":{\"212\":1}}],[\"隐藏实现细节\",{\"1\":{\"212\":1}}],[\"隐式加载\",{\"1\":{\"118\":1}}],[\"封装成一个类\",{\"1\":{\"227\":1}}],[\"封装\",{\"0\":{\"212\":1,\"213\":1},\"1\":{\"212\":2}}],[\"现阶段作为初学者\",{\"1\":{\"208\":1}}],[\"现在由于logger没有配置任何handler处理器\",{\"1\":{\"646\":1}}],[\"现在默认就是使用的这个\",{\"1\":{\"646\":1}}],[\"现在只需要一个注解即可\",{\"1\":{\"624\":1}}],[\"现在只会进行追加写入\",{\"1\":{\"93\":1}}],[\"现在执行以下操作\",{\"1\":{\"604\":1}}],[\"现在要求把下面所有用户都插入到数据库中\",{\"1\":{\"599\":1}}],[\"现在来一个新的表\",{\"1\":{\"581\":1}}],[\"现在将变为我们手动提交\",{\"1\":{\"534\":4}}],[\"现在的问题就是\",{\"1\":{\"280\":1}}],[\"现在我们也可以将其设置为jdk提供的日志框架\",{\"1\":{\"679\":1}}],[\"现在我们也可以手动修改它为simpleformatter类型\",{\"1\":{\"649\":1}}],[\"现在我们打印日志就可以出现想要的结果了\",{\"1\":{\"647\":1}}],[\"现在我们再次打印低于info级别的日志就可以正确得到结果了\",{\"1\":{\"640\":1}}],[\"现在我们还是在mapper中添加一个对应的方法用于执行\",{\"1\":{\"623\":1}}],[\"现在我们希望查询user时\",{\"1\":{\"577\":1}}],[\"现在我们希望能够自己处理出现的问题\",{\"1\":{\"267\":1}}],[\"现在我们可以直接通过sqlsession获取我们编写接口的实现类\",{\"1\":{\"570\":1}}],[\"现在我们只需要在main方法中这样写即可查询结果了\",{\"1\":{\"558\":1}}],[\"现在我们只需要通过一个对象就能完成数据库交互了\",{\"1\":{\"553\":1}}],[\"现在我们就可以通过我们的方法来将查询结果转换为一个对象了\",{\"1\":{\"527\":1}}],[\"现在我们就可以对此类进行操作了\",{\"1\":{\"199\":1}}],[\"现在我们来进行一个转换\",{\"1\":{\"527\":1}}],[\"现在我们执行的数据库操作日志会在控制台实时打印\",{\"1\":{\"517\":1}}],[\"现在\",{\"1\":{\"199\":1,\"621\":1}}],[\"现在线程才是程序执行流的最小单元\",{\"1\":{\"138\":1}}],[\"现在是按字符进行读取\",{\"1\":{\"96\":1}}],[\"现在跳过的是一个字符\",{\"1\":{\"96\":1}}],[\"现在没有\",{\"1\":{\"15\":1}}],[\"现在有一个新的需求\",{\"1\":{\"15\":1}}],[\"丝毫get不到这玩意的用处\",{\"1\":{\"208\":1}}],[\"多\",{\"0\":{\"583\":2}}],[\"多对一查询\",{\"0\":{\"583\":1}}],[\"多参数表示\",{\"0\":{\"571\":1}}],[\"多参数查询\",{\"0\":{\"562\":1}}],[\"多表查询会通过连接转换为单表查询\",{\"1\":{\"495\":1}}],[\"多表查询是同时查询的两个或两个以上的表\",{\"1\":{\"495\":1}}],[\"多表查询\",{\"0\":{\"495\":1}}],[\"多重条件连接查询\",{\"1\":{\"491\":1}}],[\"多维数组\",{\"0\":{\"240\":1},\"1\":{\"275\":1}}],[\"多个会话之间不相通\",{\"1\":{\"611\":1}}],[\"多个类型变量使用逗号隔开\",{\"1\":{\"281\":1}}],[\"多个异常使用逗号隔开\",{\"1\":{\"266\":1}}],[\"多个不同的对象对同一消息作出响应\",{\"1\":{\"212\":1}}],[\"多个值时就使用花括号括起来\",{\"1\":{\"207\":1}}],[\"多态\",{\"1\":{\"212\":1}}],[\"多线程4\",{\"0\":{\"171\":1}}],[\"多线程3\",{\"0\":{\"160\":1}}],[\"多线程下java内存管理\",{\"0\":{\"154\":1}}],[\"多线程2\",{\"0\":{\"152\":1}}],[\"多线程与反射4\",{\"0\":{\"170\":1}}],[\"多线程与反射3\",{\"0\":{\"159\":1}}],[\"多线程与反射2\",{\"0\":{\"151\":1}}],[\"多线程与反射1\",{\"0\":{\"136\":1}}],[\"多线程\",{\"0\":{\"137\":1}}],[\"该算法中\",{\"1\":{\"407\":1,\"408\":1}}],[\"该算法是\",{\"1\":{\"354\":1}}],[\"该方法成立的数学依据是\",{\"1\":{\"360\":1}}],[\"该方法是否是重写方法\",{\"1\":{\"204\":1}}],[\"该步骤是根据\",{\"1\":{\"351\":1}}],[\"该步骤是用来计算当前策略\",{\"1\":{\"351\":1}}],[\"该式子针对状态空间中的所有状态均成立\",{\"1\":{\"330\":1}}],[\"该论文中在精度和模型复杂型上作出平衡\",{\"1\":{\"298\":1}}],[\"该问题依然是np\",{\"1\":{\"298\":1}}],[\"该优化问题是一个non\",{\"1\":{\"296\":1}}],[\"该文件配置很简单\",{\"1\":{\"664\":1}}],[\"该文中不同集群所利用的频谱是不同的\",{\"1\":{\"294\":1}}],[\"该文中表示为\",{\"1\":{\"294\":1}}],[\"该文提出的算法具较快的收敛性\",{\"1\":{\"290\":1}}],[\"该文基于q\",{\"1\":{\"290\":1}}],[\"该文设计的是3d部署\",{\"1\":{\"289\":1}}],[\"该框架将无人机部署在三维空间内\",{\"1\":{\"290\":1}}],[\"该咋写咋写\",{\"1\":{\"257\":1}}],[\"该怎么处理\",{\"1\":{\"229\":1}}],[\"该注解由\",{\"1\":{\"206\":1}}],[\"元注解是作用于注解上的注解\",{\"1\":{\"205\":1}}],[\"元注解\",{\"0\":{\"205\":1}}],[\"元素中的\",{\"1\":{\"84\":1}}],[\"元素流在管道中经过\",{\"1\":{\"71\":1}}],[\"忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告\",{\"1\":{\"204\":1}}],[\"标签\",{\"0\":{\"589\":1,\"591\":1,\"601\":1}}],[\"标签中可以存在属性\",{\"1\":{\"545\":1}}],[\"标注下划线的属性\",{\"1\":{\"462\":1}}],[\"标准格式为\",{\"1\":{\"257\":1}}],[\"标识某注解可以在同一个声明上使用多次\",{\"1\":{\"205\":1}}],[\"标识这个注解怎么保存\",{\"1\":{\"205\":1}}],[\"标识一个匿名函数或函数式接口\",{\"1\":{\"204\":1}}],[\"标记这个注解是继承于哪个注解类\",{\"1\":{\"205\":1}}],[\"标记这个注解应该是哪种\",{\"1\":{\"205\":1}}],[\"标记这些注解是否包含在用户文档中\",{\"1\":{\"205\":1}}],[\"标记过时方法\",{\"1\":{\"204\":1}}],[\"标记为native的方法是本地方法\",{\"1\":{\"215\":1}}],[\"标记为公共的内容\",{\"1\":{\"121\":1}}],[\"标记为受保护的内容可以能被类本身和同包中的其他类访问\",{\"1\":{\"121\":1}}],[\"标记为私有的内容无法被除当前类以外的任何位置访问\",{\"1\":{\"121\":1}}],[\"标记位置\",{\"1\":{\"108\":1}}],[\"检查约束通常用于限制某些特定的数值范围或模式\",{\"1\":{\"475\":1}}],[\"检查\",{\"1\":{\"204\":1,\"475\":1,\"476\":1}}],[\"作用在\",{\"0\":{\"611\":1,\"612\":1}}],[\"作用\",{\"1\":{\"311\":1}}],[\"作用于代码\",{\"1\":{\"204\":1}}],[\"作为用户id的逻辑外键\",{\"1\":{\"577\":1}}],[\"作为内部资源后\",{\"1\":{\"570\":1}}],[\"作为内部资源\",{\"1\":{\"570\":1}}],[\"作为占位符\",{\"1\":{\"533\":1}}],[\"作为key\",{\"1\":{\"462\":1}}],[\"作为下一步的\",{\"1\":{\"338\":1}}],[\"作为附加功能存在\",{\"1\":{\"219\":1}}],[\"作为结果\",{\"1\":{\"57\":1}}],[\"作为返回值\",{\"1\":{\"14\":1}}],[\"作为参数\",{\"1\":{\"14\":1}}],[\"预设注解\",{\"0\":{\"204\":1}}],[\"注释内容\",{\"1\":{\"545\":1}}],[\"注重近期的reward\",{\"1\":{\"304\":1}}],[\"注解不允许循环引用\",{\"1\":{\"629\":1}}],[\"注解只支持嵌套查询\",{\"0\":{\"629\":1}}],[\"注解只有成员变量\",{\"1\":{\"207\":1}}],[\"注解的成员变量在注解的定义中以\",{\"1\":{\"207\":1}}],[\"注解的属性也叫做成员变量\",{\"1\":{\"207\":1}}],[\"注解的使用\",{\"0\":{\"207\":1}}],[\"注解并没有继承于任何子类\",{\"1\":{\"205\":1}}],[\"注解本质上也是一个类\",{\"1\":{\"203\":1}}],[\"注解也可以选择是否保留到运行时\",{\"1\":{\"203\":1}}],[\"注解可以通过反射在运行时获取\",{\"1\":{\"203\":1}}],[\"注解可以被标注在任意地方\",{\"1\":{\"203\":1}}],[\"注解定义上等\",{\"1\":{\"203\":1}}],[\"注解\",{\"0\":{\"202\":1,\"203\":1,\"630\":1},\"1\":{\"216\":1}}],[\"注意在when中不允许使用<或是>这种模糊匹配的条件\",{\"1\":{\"602\":1}}],[\"注意返回类型必须是int或是long这类数字类型\",{\"1\":{\"589\":1}}],[\"注意返回值是class<\",{\"1\":{\"182\":1}}],[\"注意sql语句中一些字段存在歧义\",{\"1\":{\"583\":1}}],[\"注意接口的参数和返回值必须正确对应\",{\"1\":{\"570\":1}}],[\"注意参数的顺序\",{\"1\":{\"569\":1}}],[\"注意全参构造必须与查询结果字段参数一一对应\",{\"1\":{\"569\":1}}],[\"注意由于这里是xml配置\",{\"1\":{\"564\":1}}],[\"注意key的名称需要与我们编写的sql语句中占位符一致\",{\"1\":{\"562\":1}}],[\"注意静态字段不会生成\",{\"1\":{\"540\":1}}],[\"注意前两步都放在try\",{\"1\":{\"516\":1}}],[\"注意必须是数字类型\",{\"1\":{\"493\":1}}],[\"注意必须是数字类型的\",{\"1\":{\"493\":1}}],[\"注意一定要换行再写\",{\"1\":{\"455\":1}}],[\"注意需要添加\",{\"1\":{\"448\":1}}],[\"注意只是相当于外部来说\",{\"1\":{\"252\":1}}],[\"注意传参\",{\"1\":{\"192\":1}}],[\"注意它会抛出instantiationexception和illegalaccessexception异常\",{\"1\":{\"191\":1}}],[\"注意此class对象只会存在一个\",{\"1\":{\"180\":1}}],[\"注意这是一个泛型类\",{\"1\":{\"162\":1}}],[\"注意这个是一个抽象类\",{\"1\":{\"166\":1}}],[\"注意这个填充是对集合中已有的元素进行覆盖\",{\"1\":{\"78\":1}}],[\"注意这个接口是集合接口的父接口\",{\"1\":{\"36\":1}}],[\"注意\",{\"1\":{\"9\":1,\"25\":2,\"34\":1,\"71\":1,\"77\":1,\"90\":1,\"91\":2,\"92\":1,\"120\":1,\"129\":1,\"130\":1,\"148\":1,\"161\":1,\"183\":1,\"199\":1,\"241\":1,\"243\":1,\"251\":1,\"266\":1,\"267\":2,\"448\":1,\"483\":1,\"495\":1,\"516\":1,\"527\":1,\"534\":2,\"593\":1,\"612\":1,\"640\":1}}],[\"想破解你代码有的是方法\",{\"1\":{\"199\":1}}],[\"想要了解优先级队列的具体是原理\",{\"1\":{\"46\":1}}],[\"华强\",{\"1\":{\"199\":1}}],[\"成比例等于\",{\"1\":{\"440\":1}}],[\"成绩可能是string类型\",{\"1\":{\"280\":1}}],[\"成功加载外部class文件\",{\"1\":{\"199\":1}}],[\"成员变量一样\",{\"1\":{\"251\":1}}],[\"成员变量的初始化\",{\"1\":{\"9\":1}}],[\"成员内部类的name\",{\"1\":{\"251\":2}}],[\"成员内部类的类型名称就是\",{\"1\":{\"251\":1}}],[\"成员内部类可以访问到外部的成员变量\",{\"1\":{\"251\":1}}],[\"成员内部类也可以使用访问权限控制\",{\"1\":{\"251\":1}}],[\"成员内部类和成员方法\",{\"1\":{\"251\":1}}],[\"成员内部类其实在某些情况下使用起来比较麻烦\",{\"1\":{\"251\":1}}],[\"成员内部类\",{\"0\":{\"251\":1}}],[\"成员\",{\"1\":{\"205\":1,\"249\":1}}],[\"成员属性上\",{\"1\":{\"203\":1}}],[\"成员方法因为需要具体对象使用\",{\"1\":{\"258\":1}}],[\"成员方法只能通过\",{\"1\":{\"258\":1}}],[\"成员方法中不能用\",{\"1\":{\"216\":1}}],[\"成员方法\",{\"1\":{\"121\":1}}],[\"爷爷加载器\",{\"1\":{\"198\":1}}],[\"错误的类型转换\",{\"1\":{\"527\":1}}],[\"错误\",{\"1\":{\"198\":1,\"264\":1,\"268\":1}}],[\"既然现在不需要配置mapper\",{\"1\":{\"622\":1}}],[\"既然我们现在可以从数据库中获取数据了\",{\"1\":{\"527\":1}}],[\"既然我们的注解可以保留到运行时\",{\"1\":{\"208\":1}}],[\"既然视图本质就是一个查询的结果\",{\"1\":{\"507\":1}}],[\"既然了解了属性和联系\",{\"1\":{\"462\":1}}],[\"既然了解了元注解的使用和注解的定义方式\",{\"1\":{\"206\":1}}],[\"既然使用的是http连接\",{\"1\":{\"455\":1}}],[\"既然是在方法中声明的类\",{\"1\":{\"253\":1}}],[\"既然数组可以是任何类型的\",{\"1\":{\"240\":1}}],[\"既然数组操作都这么方便了\",{\"1\":{\"75\":1}}],[\"既然能装箱\",{\"1\":{\"227\":1}}],[\"既然都有\",{\"1\":{\"219\":1}}],[\"既然通过classloader就可以加载类\",{\"1\":{\"199\":1}}],[\"既然说class对象和加载的类唯一对应\",{\"1\":{\"198\":1}}],[\"思考\",{\"1\":{\"198\":1}}],[\"淦\",{\"1\":{\"193\":1,\"281\":1}}],[\"瞎移除都不带报错的\",{\"1\":{\"193\":1}}],[\"大于符号\",{\"1\":{\"564\":1}}],[\"大于0表示大于\",{\"1\":{\"14\":1}}],[\"大大提高工作效率\",{\"1\":{\"510\":1}}],[\"大大提升开发效\",{\"1\":{\"280\":1}}],[\"大型数据库系统\",{\"1\":{\"460\":1}}],[\"大数定理\",{\"1\":{\"360\":1}}],[\"大体内容其实普通类差不多\",{\"1\":{\"218\":1}}],[\"大小直接变成11\",{\"1\":{\"193\":1}}],[\"几乎能够无视一切阻拦\",{\"1\":{\"193\":1}}],[\"几乎都在操作内部维护的一个hashmap\",{\"1\":{\"67\":1}}],[\"强化学习\",{\"0\":{\"689\":1},\"2\":{\"307\":1,\"320\":1,\"336\":1,\"345\":1,\"359\":1,\"376\":1,\"393\":1,\"414\":1,\"431\":1,\"444\":1}}],[\"强化学习框架图\",{\"0\":{\"303\":1}}],[\"强行设置值\",{\"1\":{\"193\":1}}],[\"强制类型转换\",{\"1\":{\"184\":1,\"219\":1}}],[\"强制写入\",{\"1\":{\"92\":1}}],[\"~modifier\",{\"1\":{\"193\":1}}],[\"尤其是仅比较子类属性\",{\"1\":{\"540\":1}}],[\"尤其是在类进行类内部成员字段封装时\",{\"1\":{\"538\":1}}],[\"尤其是在网络i\",{\"1\":{\"91\":1}}],[\"尤其是我们提到的越权访问\",{\"1\":{\"192\":1}}],[\"q=0\",{\"1\":{\"455\":6}}],[\"q^​\",{\"1\":{\"427\":5}}],[\"qt​\",{\"1\":{\"401\":2,\"405\":1,\"441\":1}}],[\"qt+1​\",{\"1\":{\"401\":2,\"405\":2}}],[\"qπk​​\",{\"1\":{\"351\":1,\"362\":2,\"363\":2,\"364\":1}}],[\"qπ​\",{\"1\":{\"311\":2,\"333\":3,\"334\":1,\"360\":1,\"400\":1,\"440\":8,\"441\":4}}],[\"qac\",{\"0\":{\"309\":1},\"1\":{\"310\":1}}],[\"q\",{\"0\":{\"405\":1,\"409\":1,\"425\":1,\"426\":1},\"1\":{\"290\":2,\"296\":1,\"298\":2,\"299\":1,\"308\":1,\"334\":1,\"340\":1,\"342\":1,\"343\":1,\"362\":1,\"364\":1,\"366\":2,\"404\":2,\"405\":1,\"408\":1,\"409\":1,\"415\":1,\"426\":1}}],[\"qoe\",{\"1\":{\"289\":1}}],[\"quality\",{\"0\":{\"295\":1},\"1\":{\"289\":1}}],[\"querying\",{\"1\":{\"569\":1}}],[\"query\",{\"1\":{\"472\":2}}],[\"queue\",{\"1\":{\"43\":5,\"45\":1,\"46\":14,\"167\":11,\"174\":8}}],[\"queue<object>\",{\"1\":{\"174\":1}}],[\"queue<integer>\",{\"1\":{\"46\":2}}],[\"queue<string>\",{\"1\":{\"43\":1,\"45\":1}}],[\"queue<e>\",{\"1\":{\"43\":1,\"44\":1}}],[\"quene\",{\"0\":{\"42\":1,\"43\":1}}],[\"qq\",{\"1\":{\"192\":1,\"624\":1}}],[\"组合\",{\"1\":{\"192\":1}}],[\"过去研究主要考虑的是2d部署\",{\"1\":{\"289\":1}}],[\"过去研究大多没有基于用户的移动\",{\"1\":{\"289\":1}}],[\"过多的使用反射\",{\"1\":{\"192\":1}}],[\"过滤换行符之类的内容\",{\"1\":{\"547\":1}}],[\"过滤\",{\"1\":{\"71\":2}}],[\"萨日朗\",{\"1\":{\"191\":1}}],[\"仍然是获取不到具体的\",{\"1\":{\"186\":1}}],[\"哪些变量等等\",{\"1\":{\"180\":1}}],[\"与主键类似\",{\"1\":{\"475\":1}}],[\"与策略\",{\"1\":{\"437\":2}}],[\"与\",{\"0\":{\"326\":1,\"355\":1,\"399\":1},\"1\":{\"326\":1,\"353\":1,\"364\":1,\"409\":1}}],[\"与基于q\",{\"1\":{\"299\":1}}],[\"与k\",{\"1\":{\"290\":1}}],[\"与加载的类唯一对应\",{\"1\":{\"180\":1}}],[\"与迭代器作用相同\",{\"1\":{\"23\":1}}],[\"堆内存\",{\"1\":{\"180\":1}}],[\"慎重使用\",{\"1\":{\"179\":1}}],[\"继续编写throws往上一级抛\",{\"1\":{\"267\":1}}],[\"继续读取会导致mark失效\",{\"1\":{\"108\":1}}],[\"继承也是同样的\",{\"1\":{\"282\":1}}],[\"继承自\",{\"1\":{\"264\":1}}],[\"继承自number类\",{\"1\":{\"227\":1}}],[\"继承自哪个类\",{\"1\":{\"179\":1}}],[\"继承\",{\"0\":{\"214\":1},\"1\":{\"212\":1,\"264\":1}}],[\"继承和多态是面向对象编程的三大特性\",{\"1\":{\"212\":1}}],[\"继承和多态\",{\"0\":{\"212\":1}}],[\"反映客观事物间的本质联系\",{\"1\":{\"460\":1}}],[\"反正只要是符合接口中方法的定义的\",{\"1\":{\"258\":1}}],[\"反正作为新手\",{\"1\":{\"60\":1}}],[\"反射获取注解\",{\"0\":{\"208\":1}}],[\"反射3\",{\"0\":{\"196\":1,\"197\":1}}],[\"反射非常暴力\",{\"1\":{\"193\":1}}],[\"反射非常强大\",{\"1\":{\"192\":1}}],[\"反射可以无视权限修饰符访问类的内容\",{\"1\":{\"191\":1}}],[\"反射2\",{\"0\":{\"189\":1,\"190\":1}}],[\"反射操作可能需要用到\",{\"1\":{\"183\":1}}],[\"反射就是把java类中的各个成分映射成一个个的java对象\",{\"1\":{\"179\":1}}],[\"反射\",{\"0\":{\"179\":1},\"1\":{\"516\":1}}],[\"反射1\",{\"0\":{\"177\":1,\"178\":1}}],[\"顾客3\",{\"1\":{\"174\":1}}],[\"顾客2\",{\"1\":{\"174\":1}}],[\"顾客1\",{\"1\":{\"174\":1}}],[\"顾客吃掉菜品的时间为4秒\",{\"1\":{\"174\":1}}],[\"厨师2\",{\"1\":{\"174\":1}}],[\"厨师1\",{\"1\":{\"174\":1}}],[\"通常也称为\",{\"1\":{\"420\":1}}],[\"通常是具有有限步长的trajectory\",{\"1\":{\"304\":1}}],[\"通常为\",{\"1\":{\"285\":2}}],[\"通配符\",{\"1\":{\"281\":1}}],[\"通俗的讲\",{\"1\":{\"174\":1}}],[\"通过修改对应的format函数来实现自定义\",{\"1\":{\"672\":1}}],[\"通过日志输出的结果会更加规范\",{\"1\":{\"636\":1}}],[\"通过序列化\",{\"1\":{\"612\":1}}],[\"通过执行另外一个\",{\"1\":{\"577\":1}}],[\"通过namespace来将各种操作绑定到一个接口上\",{\"1\":{\"570\":1}}],[\"通过前面的学习\",{\"1\":{\"569\":1}}],[\"通过进行配置\",{\"1\":{\"552\":1}}],[\"通过一个xml文件去配置\",{\"1\":{\"552\":1}}],[\"通过invoker为传入的实体类对象赋值\",{\"1\":{\"569\":1}}],[\"通过idea我们可以使用ctrl+\",{\"1\":{\"545\":1}}],[\"通过isinterrupted\",{\"1\":{\"144\":1}}],[\"通过开启事务\",{\"1\":{\"534\":1}}],[\"通过直接将我们的内容进行替换的方式来填写数据\",{\"1\":{\"533\":1}}],[\"通过drivermanager来获得数据库连接\",{\"1\":{\"516\":1}}],[\"通过drop来删除一个视图\",{\"1\":{\"507\":1}}],[\"通过drop来删除一个列\",{\"1\":{\"479\":1}}],[\"通过java如何去使用数据库来帮助我们存储数据\",{\"1\":{\"514\":1}}],[\"通过javac命令\",{\"1\":{\"199\":1}}],[\"通过学习它们能够让你的数据库管理能力更上一层楼\",{\"1\":{\"510\":1}}],[\"通过下面的命令来查看触发器\",{\"1\":{\"509\":1}}],[\"通过构建一个er图\",{\"1\":{\"461\":1}}],[\"通过访问\",{\"1\":{\"455\":1}}],[\"通过sqlsession进行事务提交\",{\"1\":{\"593\":1}}],[\"通过socket对象\",{\"1\":{\"448\":1}}],[\"通过socket技术\",{\"1\":{\"446\":1}}],[\"通过string\",{\"1\":{\"91\":1}}],[\"通过梯度的算法来最小化对应的损失函数\",{\"1\":{\"427\":1}}],[\"通过采取\",{\"1\":{\"370\":1}}],[\"通过迭代算法求解\",{\"1\":{\"362\":1}}],[\"通过求解\",{\"1\":{\"333\":1}}],[\"通过k\",{\"1\":{\"298\":1}}],[\"通过gak\",{\"1\":{\"290\":1}}],[\"通过getfield\",{\"1\":{\"193\":1}}],[\"通过get方法返回得到的值\",{\"1\":{\"71\":1}}],[\"通过优化无人机的部署和动态移动来解决总用户mos最大化问题\",{\"1\":{\"290\":1}}],[\"通过自动装箱转换的integer对象\",{\"1\":{\"227\":1}}],[\"通过添加abstract关键字\",{\"1\":{\"218\":1}}],[\"通过这种方式\",{\"1\":{\"199\":1,\"484\":1}}],[\"通过反射机制\",{\"1\":{\"208\":1}}],[\"通过反射可以直接将final修饰符直接去除\",{\"1\":{\"193\":1}}],[\"通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值\",{\"1\":{\"193\":1}}],[\"通过method对象的invoke方法来调用方法\",{\"1\":{\"192\":2}}],[\"通过方法名和形参类型获取类中的方法\",{\"1\":{\"192\":2}}],[\"通过调用getmethod\",{\"1\":{\"192\":1}}],[\"通过调用sleep\",{\"1\":{\"143\":1}}],[\"通过调用start\",{\"1\":{\"140\":1}}],[\"通过获取类的构造方法\",{\"1\":{\"191\":1}}],[\"通过实例对象获取\",{\"1\":{\"182\":1}}],[\"通过包名\",{\"1\":{\"182\":1}}],[\"通过类名获取\",{\"1\":{\"182\":1}}],[\"通过classloader将类加载\",{\"1\":{\"180\":1}}],[\"通过多线程编程\",{\"1\":{\"174\":1}}],[\"通过灵活的使用synchronized就能很好地解决我们之前提到的问题了\",{\"1\":{\"155\":1}}],[\"通过使用这些工具\",{\"1\":{\"616\":1}}],[\"通过使用动态sql语句\",{\"1\":{\"605\":1}}],[\"通过使用left\",{\"1\":{\"497\":1}}],[\"通过使用inner\",{\"1\":{\"497\":1}}],[\"通过使用insert\",{\"1\":{\"482\":1}}],[\"通过使用group\",{\"1\":{\"494\":1}}],[\"通过使用select语句来进行单表查询\",{\"1\":{\"490\":1}}],[\"通过使用setpriority方法来设定优先级\",{\"1\":{\"145\":1}}],[\"通过使用drop\",{\"1\":{\"477\":1}}],[\"通过使用\",{\"1\":{\"472\":1,\"538\":1,\"540\":2,\"559\":1}}],[\"通过使用关系型数据库\",{\"1\":{\"461\":1}}],[\"通过使用一个函数来进行拟合\",{\"1\":{\"416\":1}}],[\"通过使用newinstance\",{\"1\":{\"191\":1}}],[\"通过使用yield\",{\"1\":{\"147\":1}}],[\"通过使用迭代器\",{\"1\":{\"31\":1}}],[\"通过创建索引\",{\"1\":{\"508\":1}}],[\"通过创建thread对象来创建一个新的线程\",{\"1\":{\"139\":1}}],[\"通过创建泛型接口的匿名内部类\",{\"1\":{\"14\":1}}],[\"通过file对象\",{\"1\":{\"98\":2}}],[\"通过while循环来一次性读完内容\",{\"1\":{\"91\":1}}],[\"通过\",{\"1\":{\"84\":1,\"314\":1,\"330\":1,\"332\":1,\"355\":1,\"360\":1,\"367\":1,\"455\":1}}],[\"通过观察\",{\"1\":{\"67\":1}}],[\"通过resize方法初始化底层哈希表\",{\"1\":{\"59\":1}}],[\"通过给定的键\",{\"1\":{\"56\":1}}],[\"通过给设定泛型上限\",{\"1\":{\"15\":1}}],[\"生效了\",{\"1\":{\"524\":1}}],[\"生产者此时等待货架出现空位\",{\"1\":{\"174\":1}}],[\"生产者要生产产品\",{\"1\":{\"174\":1}}],[\"生产者与消费者\",{\"0\":{\"174\":1}}],[\"生成流\",{\"1\":{\"71\":1}}],[\"生成\",{\"1\":{\"71\":1}}],[\"生成反向迭代器\",{\"1\":{\"44\":1}}],[\"生成一个匿名的iterator对象\",{\"1\":{\"36\":1}}],[\"生成当前集合的迭代器\",{\"1\":{\"36\":1}}],[\"生成当前集合的并行流\",{\"1\":{\"23\":1}}],[\"生成当前集合的流\",{\"1\":{\"23\":1}}],[\"效率会更高\",{\"1\":{\"610\":1}}],[\"效率会截然不同\",{\"1\":{\"599\":1}}],[\"效率就会提升很多\",{\"1\":{\"599\":1}}],[\"效率非常低\",{\"1\":{\"599\":1}}],[\"效率过低\",{\"1\":{\"361\":1}}],[\"效率更高\",{\"1\":{\"173\":1}}],[\"效果和之前我们编写xml形式的动态sql一致\",{\"1\":{\"630\":1}}],[\"效果和第一种方法是一样的\",{\"1\":{\"579\":1}}],[\"效果是完全一样的\",{\"1\":{\"34\":1}}],[\"效果跟上面是一样的\",{\"1\":{\"14\":1}}],[\"翻译过来就是\",{\"1\":{\"173\":1}}],[\"程序中的properties对象也可以快速保存为一个对应的\",{\"1\":{\"666\":1}}],[\"程序继续正常运行\",{\"1\":{\"267\":1}}],[\"程序正常运行中\",{\"1\":{\"172\":2}}],[\"程序编译之后的样子是什么样的\",{\"1\":{\"16\":1}}],[\"守护进程在后台运行运行\",{\"1\":{\"172\":1}}],[\"守护线程自动结束\",{\"1\":{\"172\":2}}],[\"守护线程\",{\"0\":{\"172\":1}}],[\"结合\",{\"0\":{\"627\":1}}],[\"结合去寻找最优策略\",{\"1\":{\"396\":1}}],[\"结构化查询语言\",{\"1\":{\"472\":1}}],[\"结果会自动进行遍历并依次执行我们传入的lambda表达式\",{\"1\":{\"564\":1}}],[\"结果是\",{\"1\":{\"254\":1}}],[\"结果依然是删除成功\",{\"1\":{\"25\":1}}],[\"结束并提交时\",{\"1\":{\"612\":1}}],[\"结束\",{\"1\":{\"167\":1}}],[\"循环间隔\",{\"1\":{\"166\":1}}],[\"循环定时任务等\",{\"1\":{\"166\":1}}],[\"延迟\",{\"1\":{\"166\":1}}],[\"定时器\",{\"0\":{\"164\":1}}],[\"定义目标函数\",{\"1\":{\"417\":1}}],[\"定义了agent与环境的交互行为\",{\"1\":{\"304\":1}}],[\"定义为ξ=\",{\"1\":{\"298\":1}}],[\"定义接口\",{\"1\":{\"219\":1}}],[\"定义\",{\"0\":{\"206\":1,\"235\":1},\"1\":{\"219\":1,\"333\":1}}],[\"定义一个自己的classloader\",{\"1\":{\"199\":1}}],[\"定义可以先放在try外部\",{\"1\":{\"90\":1}}],[\"定义中提到\",{\"1\":{\"84\":1}}],[\"定义的全部功能\",{\"1\":{\"67\":1}}],[\"设\",{\"1\":{\"420\":1,\"422\":1}}],[\"设无人机总数为n\",{\"1\":{\"299\":1}}],[\"设计一种基于\",{\"1\":{\"290\":2}}],[\"设置为\",{\"1\":{\"312\":1}}],[\"设置为守护线程\",{\"1\":{\"172\":2}}],[\"设置初始值\",{\"1\":{\"163\":1}}],[\"设定此属性的值\",{\"1\":{\"193\":1}}],[\"设定上界为number\",{\"1\":{\"16\":1}}],[\"设定类型参数上界\",{\"1\":{\"15\":1}}],[\"间隔1秒\",{\"1\":{\"162\":1}}],[\"间隔2秒\",{\"1\":{\"162\":1}}],[\"唤醒所有等待当前对象锁的线程\",{\"1\":{\"215\":1}}],[\"唤醒一个等待当前对象锁的线程\",{\"1\":{\"215\":1}}],[\"唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\",{\"1\":{\"161\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"161\":1}}],[\"态\",{\"1\":{\"161\":1}}],[\"平常环境下是无法使用的\",{\"1\":{\"161\":1}}],[\"分组和分页查询\",{\"0\":{\"494\":1}}],[\"分析随机变量\",{\"1\":{\"418\":1}}],[\"分析\",{\"0\":{\"387\":1}}],[\"分别是user表和user\",{\"1\":{\"580\":1}}],[\"分别是wait\",{\"1\":{\"161\":1}}],[\"分别执行两个选择语句\",{\"1\":{\"579\":1}}],[\"分别需要使用\",{\"1\":{\"564\":1}}],[\"分别代表插入\",{\"1\":{\"472\":1}}],[\"分别设为1\",{\"1\":{\"295\":1}}],[\"分割字符串\",{\"1\":{\"244\":1}}],[\"分割字符串并生成新的流\",{\"1\":{\"71\":1}}],[\"分割操作\",{\"1\":{\"244\":1}}],[\"然后直接通过注解的形式引用\",{\"1\":{\"627\":1}}],[\"然后这里我们传入的参数直接写成对应的类型即可\",{\"1\":{\"589\":1}}],[\"然后配置关联查询相关信息\",{\"1\":{\"578\":1}}],[\"然后将这些参数添加到map中进行传递\",{\"1\":{\"571\":1}}],[\"然后将我们的参数填写到后面\",{\"1\":{\"560\":1}}],[\"然后使用方法的形式来表示\",{\"1\":{\"570\":1}}],[\"然后通过反射进行赋值\",{\"1\":{\"569\":1}}],[\"然后查询得到的实体对象作为value\",{\"1\":{\"564\":1}}],[\"然后得到的结果作为value的map\",{\"1\":{\"564\":1}}],[\"然后就能够正确查询了\",{\"1\":{\"563\":1}}],[\"然后就在标签中写入我们的查询语句即可\",{\"1\":{\"554\":1}}],[\"然后就是响应内容\",{\"1\":{\"455\":1}}],[\"然后在javac进行编译的时候\",{\"1\":{\"539\":1}}],[\"然后在更新了一定次数之后\",{\"1\":{\"427\":1}}],[\"然后我们可以通过使用\",{\"1\":{\"631\":1}}],[\"然后我们要安装一下lombok插件\",{\"1\":{\"539\":1}}],[\"然后我们通过cmd去登陆mysql\",{\"1\":{\"501\":1}}],[\"然后我们通过\",{\"1\":{\"427\":1}}],[\"然后生成了一个\",{\"1\":{\"439\":1}}],[\"然后进行迭代\",{\"1\":{\"364\":1}}],[\"然后进行不断迭代\",{\"1\":{\"332\":1}}],[\"然后创建子类对象\",{\"1\":{\"255\":1}}],[\"然后编写一个我们自己的classloader\",{\"1\":{\"199\":1}}],[\"然后\",{\"1\":{\"156\":1}}],[\"然后继续做我们的事情\",{\"1\":{\"144\":1}}],[\"首次调用会移动到第一行\",{\"1\":{\"525\":1}}],[\"首先获取日志打印器\",{\"1\":{\"636\":1}}],[\"首先还是关联查询的sql语句\",{\"1\":{\"581\":1}}],[\"首先来看最简单的一对一查询\",{\"1\":{\"577\":1}}],[\"首先编写实体类\",{\"1\":{\"554\":1}}],[\"首先我们需要指定select操作的id\",{\"1\":{\"559\":1}}],[\"首先我们需要导入lombok的jar依赖\",{\"1\":{\"539\":1}}],[\"首先我们要明确\",{\"1\":{\"462\":1}}],[\"首先是关联查询的sql语句\",{\"1\":{\"578\":1}}],[\"首先是传统方式\",{\"1\":{\"538\":1}}],[\"首先是响应头\",{\"1\":{\"455\":1}}],[\"首先要通过connection对象调用setautocommit\",{\"1\":{\"534\":1}}],[\"首先要明确\",{\"1\":{\"525\":1}}],[\"首先定义我们的实体类\",{\"1\":{\"527\":1}}],[\"首先需要添加一个环境变量\",{\"1\":{\"501\":1}}],[\"首先初始化一个随机的策略π0​\",{\"1\":{\"364\":1}}],[\"首先随机设计一个初始的策略π0​\",{\"1\":{\"351\":1}}],[\"首先实现cloneable接口\",{\"1\":{\"220\":1}}],[\"首先利用jps找到我们的java进程号\",{\"1\":{\"156\":1}}],[\"首字母不是大写字母\",{\"1\":{\"71\":1}}],[\"导出视图good\",{\"1\":{\"507\":1}}],[\"导出其他的视图\",{\"1\":{\"507\":1}}],[\"导致mybatis无法确定具体哪个参数交什么名字\",{\"1\":{\"571\":1}}],[\"导致一方还持有连接\",{\"1\":{\"449\":1}}],[\"导致被破坏\",{\"1\":{\"193\":1}}],[\"导致程序卡住\",{\"1\":{\"156\":1}}],[\"导入我们需要使用的类\",{\"1\":{\"120\":1}}],[\"死锁是指两个线程相互持有对方需要的锁\",{\"1\":{\"156\":1}}],[\"死锁\",{\"0\":{\"156\":1}}],[\"引言\",{\"0\":{\"378\":1}}],[\"引入两个网络\",{\"1\":{\"427\":1}}],[\"引入随机变量后对应的discounted\",{\"1\":{\"324\":1}}],[\"引入discount\",{\"1\":{\"304\":1}}],[\"引入\",{\"0\":{\"373\":1,\"395\":1,\"416\":1},\"1\":{\"155\":1,\"333\":1}}],[\"引用尾结点\",{\"1\":{\"25\":1}}],[\"引用首结点\",{\"1\":{\"25\":1}}],[\"保证\",{\"1\":{\"383\":2}}],[\"保证选取最大的\",{\"1\":{\"342\":1}}],[\"保证在传输过程中的安全性\",{\"1\":{\"199\":1}}],[\"保证两个线程执行完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"保证数据的安全性\",{\"1\":{\"154\":1}}],[\"保证当两个对象通过\",{\"1\":{\"84\":1}}],[\"难道取1000还可能吐2000出来吗\",{\"1\":{\"154\":1}}],[\"好比说一个银行\",{\"1\":{\"154\":1}}],[\"缓存还会生效吗\",{\"1\":{\"611\":1}}],[\"缓存的概念在我们后续的学习中还会经常遇见\",{\"1\":{\"610\":1}}],[\"缓存机制\",{\"0\":{\"610\":1}}],[\"缓存一致性问题\",{\"0\":{\"616\":1}}],[\"缓存一致性\",{\"1\":{\"154\":1}}],[\"缓冲字符输出流\",{\"0\":{\"113\":1}}],[\"缓冲字符读取流\",{\"0\":{\"112\":1}}],[\"缓冲字符流\",{\"0\":{\"111\":1}}],[\"缓冲字节输出流\",{\"0\":{\"110\":1}}],[\"缓冲字节读取流\",{\"0\":{\"105\":1}}],[\"缓冲字节流\",{\"0\":{\"104\":1}}],[\"缓冲机制\",{\"0\":{\"108\":1}}],[\"缓冲区\",{\"1\":{\"103\":1}}],[\"缓冲流可以叠加\",{\"0\":{\"109\":1}}],[\"缓冲流特性\",{\"0\":{\"106\":1}}],[\"缓冲流\",{\"0\":{\"103\":1}}],[\"写共享变量的副本\",{\"1\":{\"154\":1}}],[\"写入的是二进制数据\",{\"1\":{\"129\":1}}],[\"写入对应长度的数据到输出流\",{\"1\":{\"94\":1}}],[\"本文目的是优化无人机在每个时隙的位置\",{\"1\":{\"296\":1}}],[\"本地缓存\",{\"1\":{\"610\":1}}],[\"本地方法不是我们se中需要学习的内容\",{\"1\":{\"215\":1}}],[\"本地内存\",{\"1\":{\"154\":1}}],[\"本来应该进行2次自增操作\",{\"1\":{\"154\":1}}],[\"本质就是调用的构造方法\",{\"1\":{\"221\":1}}],[\"本质上还是类的实例进行调用\",{\"1\":{\"192\":1}}],[\"本质上是一个intstream\",{\"1\":{\"71\":1}}],[\"本质和普通进程类似\",{\"1\":{\"172\":1}}],[\"本质也是reader和writer\",{\"1\":{\"126\":1}}],[\"再父logger\",{\"1\":{\"657\":1}}],[\"再通过sqlsession来执行对应的方法\",{\"1\":{\"570\":1}}],[\"再通过这些经验来不断改进更新另一个策略\",{\"1\":{\"408\":1}}],[\"再次执行我们之前的操作\",{\"1\":{\"612\":1}}],[\"再次获取\",{\"1\":{\"611\":1}}],[\"再次出现\",{\"1\":{\"366\":1}}],[\"再次强调\",{\"1\":{\"193\":1,\"544\":1}}],[\"再将\",{\"1\":{\"362\":1}}],[\"再将用户划分给距离最近的无人机\",{\"1\":{\"298\":1}}],[\"再求平均值\",{\"1\":{\"326\":1}}],[\"再根据欧几里得距离重新划分\",{\"1\":{\"298\":1}}],[\"再找到新的簇的各中心\",{\"1\":{\"298\":1}}],[\"再来调用此方法\",{\"1\":{\"199\":1}}],[\"再来看\",{\"1\":{\"67\":1}}],[\"再写回主内存后\",{\"1\":{\"154\":1}}],[\"再继续执行的线程2内容\",{\"1\":{\"148\":1}}],[\"尽可能减少\",{\"1\":{\"463\":1}}],[\"尽可能多的在执行线程2的内容\",{\"1\":{\"147\":1}}],[\"尽可能的扬长避短\",{\"1\":{\"25\":1}}],[\"观察结果\",{\"1\":{\"147\":1}}],[\"yyyy\",{\"1\":{\"676\":1}}],[\"year存储年份\",{\"1\":{\"474\":1}}],[\"yt​\",{\"1\":{\"427\":1}}],[\"yt​≐r+γmaxa∈a\",{\"1\":{\"427\":1}}],[\"yt​−q^​\",{\"1\":{\"427\":2}}],[\"y≐r+γmaxa∈a\",{\"1\":{\"427\":1}}],[\"yuser​\",{\"1\":{\"299\":2}}],[\"yuav​\",{\"1\":{\"298\":2,\"299\":2}}],[\"yd​+1\",{\"1\":{\"298\":1}}],[\"yd​\",{\"1\":{\"298\":1}}],[\"yn​\",{\"1\":{\"293\":2}}],[\"ykn​​\",{\"1\":{\"293\":1}}],[\"yield\",{\"1\":{\"147\":1}}],[\"yoni\",{\"1\":{\"65\":3}}],[\"获得reward\",{\"1\":{\"305\":1}}],[\"获得并行流\",{\"1\":{\"173\":1}}],[\"获得cpu资源的概率会越大\",{\"1\":{\"145\":1}}],[\"获取logmanager读取配置文件\",{\"1\":{\"667\":1}}],[\"获取系统数据\",{\"0\":{\"666\":1}}],[\"获取一个新的会话\",{\"1\":{\"558\":1}}],[\"获取首个\",{\"1\":{\"547\":1}}],[\"获取参数列表\",{\"1\":{\"527\":1}}],[\"获取成绩需要进行强制类型转换\",{\"1\":{\"280\":1}}],[\"获取成员变量\",{\"1\":{\"199\":1}}],[\"获取异常的错误信息\",{\"1\":{\"267\":1}}],[\"获取长度\",{\"1\":{\"244\":1}}],[\"获取封装的成员变量\",{\"1\":{\"221\":1}}],[\"获取对象的哈希值\",{\"1\":{\"215\":1}}],[\"获取对应下标位置上的元素\",{\"1\":{\"24\":1}}],[\"获取我们在注解中写入的内容\",{\"1\":{\"208\":2}}],[\"获取我们定义的test\",{\"1\":{\"199\":2}}],[\"获取类型\",{\"1\":{\"208\":2}}],[\"获取类名称\",{\"1\":{\"184\":1}}],[\"获取返回值类型\",{\"1\":{\"192\":1}}],[\"获取方法名称\",{\"1\":{\"192\":1}}],[\"获取非public方法并调用\",{\"1\":{\"192\":1}}],[\"获取父类的原始类型的type\",{\"1\":{\"186\":1}}],[\"获取它的类加载器\",{\"1\":{\"184\":1}}],[\"获取相应类的class对象\",{\"0\":{\"182\":1}}],[\"获取到类的一些属性\",{\"1\":{\"179\":1}}],[\"获取到的是不同的锁\",{\"1\":{\"155\":1}}],[\"获取线程名称\",{\"1\":{\"140\":1}}],[\"获取文件的绝对路径\",{\"1\":{\"98\":1}}],[\"获取文件的大小\",{\"1\":{\"98\":1}}],[\"获取平均值\",{\"1\":{\"71\":1}}],[\"获取数量\",{\"1\":{\"71\":1}}],[\"获取语法统计实例\",{\"1\":{\"71\":1}}],[\"获取键值对的值\",{\"1\":{\"56\":1}}],[\"获取键值对的键\",{\"1\":{\"56\":1}}],[\"获取当前的类型class对象\",{\"1\":{\"215\":1}}],[\"获取当前线程对象\",{\"1\":{\"140\":1,\"142\":1}}],[\"获取当前存储的键值对数量\",{\"1\":{\"56\":1}}],[\"获取当前集合中的元素数量\",{\"1\":{\"23\":1}}],[\"获取队尾元素\",{\"1\":{\"44\":1}}],[\"获取队首元素\",{\"1\":{\"44\":1}}],[\"休眠后再运行\",{\"1\":{\"165\":2}}],[\"休眠3秒\",{\"1\":{\"144\":1}}],[\"休眠时间\",{\"1\":{\"142\":1}}],[\"响应中断\",{\"1\":{\"144\":1}}],[\"由驱动程序转交给应用程序负责\",{\"1\":{\"534\":1}}],[\"由无人机的位置和它们在最后时隙采取的动作决定\",{\"1\":{\"299\":1}}],[\"由用户的初始位置和运动模型决定\",{\"1\":{\"299\":1}}],[\"由此进行迭代\",{\"1\":{\"351\":1}}],[\"由此可以根据contraction\",{\"1\":{\"343\":1}}],[\"由此可以推导出一个多步的trajectory\",{\"1\":{\"324\":1}}],[\"由此\",{\"1\":{\"294\":1}}],[\"由线程来响应此中断并进行相应的处理\",{\"1\":{\"144\":1}}],[\"由于mybatis默认情况下直接通过无参构造来创建实体类对象\",{\"1\":{\"569\":1}}],[\"由于返回的结果是一个列表\",{\"1\":{\"564\":1}}],[\"由于这里我们需要通过一个参数来查询\",{\"1\":{\"559\":1}}],[\"由于sqlsessionfactory一般只需要创建一次\",{\"1\":{\"558\":1}}],[\"由于string的构造方法在创建对象时也会得到一个string类型的结果\",{\"1\":{\"258\":1}}],[\"由于idea默认都安装了lombok的插件\",{\"1\":{\"539\":1}}],[\"由于存在如下决定关系\",{\"1\":{\"467\":1}}],[\"由于继承了autocloseble\",{\"1\":{\"447\":1}}],[\"由于πk+1​是\",{\"1\":{\"348\":1}}],[\"由于\",{\"1\":{\"333\":1,\"348\":1}}],[\"由于用户在每个时隙都处于漫游状态\",{\"1\":{\"299\":1}}],[\"由于gak\",{\"1\":{\"298\":1}}],[\"由于特定用户的mos与该用户与无人机之间的距离有关\",{\"1\":{\"298\":1}}],[\"由于不同用户对于传输速率的需求是不同的\",{\"1\":{\"295\":1}}],[\"由于不同集群的频谱不同\",{\"1\":{\"294\":1}}],[\"由于是\",{\"1\":{\"280\":1}}],[\"由于基本数据类型和引用类型不同\",{\"1\":{\"238\":1}}],[\"由于类本身都是继承\",{\"1\":{\"219\":1}}],[\"由于类型擦除机制\",{\"1\":{\"186\":1}}],[\"由于泛型中未定义\",{\"1\":{\"186\":1}}],[\"由于泛型机制上的一些漏洞\",{\"1\":{\"80\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"156\":1}}],[\"由于每个进程都有一个自己的内存空间\",{\"1\":{\"138\":1}}],[\"由于默认导入了系统自带的string类\",{\"1\":{\"120\":1}}],[\"由于外部i\",{\"1\":{\"103\":1}}],[\"由于底层采用哈希表实现\",{\"1\":{\"48\":1}}],[\"被除数不能为0\",{\"1\":{\"266\":2}}],[\"被挂起的线程才能继续\",{\"1\":{\"156\":1}}],[\"被\",{\"1\":{\"143\":1}}],[\"阻塞态\",{\"1\":{\"161\":1}}],[\"阻塞\",{\"1\":{\"143\":1}}],[\"状态s时可以得到的平均reward\",{\"1\":{\"438\":1}}],[\"状态转换\",{\"1\":{\"304\":1}}],[\"状态转换模型\",{\"1\":{\"298\":1}}],[\"状态除了要考虑无人机的3d位置外\",{\"1\":{\"299\":1}}],[\"状态空间\",{\"1\":{\"298\":1,\"304\":1}}],[\"状态\",{\"1\":{\"143\":1,\"221\":1,\"298\":1,\"304\":1,\"420\":1,\"427\":1}}],[\"或其它类似的框架\",{\"1\":{\"600\":1}}],[\"或注解来配置和映射原生信息\",{\"1\":{\"544\":1}}],[\"或\",{\"1\":{\"534\":1,\"612\":1}}],[\"或是一些非常紧急的日志信息\",{\"1\":{\"637\":1}}],[\"或是结束并回滚\",{\"1\":{\"612\":1}}],[\"或是具有同样参数的实体类来传递\",{\"1\":{\"562\":1}}],[\"或是$\",{\"1\":{\"559\":1}}],[\"或是getupdatecount\",{\"1\":{\"519\":1}}],[\"或是\",{\"1\":{\"455\":1,\"472\":1}}],[\"或是继续使用此泛型让具体创建的对象来确定类型\",{\"1\":{\"282\":1}}],[\"或是调用sleep\",{\"1\":{\"142\":1}}],[\"或者还是mapper标签通过class属性来指定具体的接口\",{\"1\":{\"622\":1}}],[\"或者\",{\"1\":{\"237\":1,\"256\":1,\"308\":1,\"351\":1,\"416\":1,\"441\":1}}],[\"或者是继续摆烂\",{\"1\":{\"282\":1}}],[\"或者是false\",{\"1\":{\"235\":1}}],[\"或者是在运行时可以通过反射访问\",{\"1\":{\"205\":1}}],[\"或者是引用的接口中并没有该方法时\",{\"1\":{\"204\":1}}],[\"或者为静态变量赋值\",{\"1\":{\"118\":1}}],[\"始终都是依次进行的\",{\"1\":{\"138\":1}}],[\"运用到\",{\"1\":{\"314\":1}}],[\"运用了封装的思想\",{\"1\":{\"227\":1}}],[\"运行时出现错误\",{\"1\":{\"569\":1}}],[\"运行时异常只需要继承\",{\"1\":{\"265\":1}}],[\"运行时异常\",{\"1\":{\"264\":1}}],[\"运行后发现\",{\"1\":{\"563\":1}}],[\"运行函数\",{\"1\":{\"166\":1}}],[\"运行态\",{\"1\":{\"161\":1}}],[\"运行main\",{\"1\":{\"138\":1}}],[\"运算符\",{\"1\":{\"5\":1}}],[\"线程名称\",{\"1\":{\"676\":1}}],[\"线程会阻塞\",{\"1\":{\"447\":1,\"448\":1}}],[\"线程a和线程b都需要对方的锁\",{\"1\":{\"156\":1}}],[\"线程锁\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"线程锁和线程同步\",{\"0\":{\"153\":1}}],[\"线程之间的共享变量\",{\"1\":{\"154\":1}}],[\"线程之间是同时运行的\",{\"1\":{\"139\":1}}],[\"线程2变量值已设定\",{\"1\":{\"162\":1}}],[\"线程2\",{\"1\":{\"156\":1}}],[\"线程2完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"线程2等待线程1待执行的内容全部执行完成之后\",{\"1\":{\"148\":1}}],[\"线程2开始运行\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程1读取变量值\",{\"1\":{\"162\":1}}],[\"线程1变量值已设定\",{\"1\":{\"162\":1}}],[\"线程1\",{\"1\":{\"156\":1}}],[\"线程1完成\",{\"1\":{\"154\":1,\"155\":2}}],[\"线程1加入后\",{\"1\":{\"148\":1}}],[\"线程1加入到此线程\",{\"1\":{\"148\":1}}],[\"线程1结束\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程1开始运行\",{\"1\":{\"147\":1,\"148\":1}}],[\"线程优先级\",{\"0\":{\"145\":1}}],[\"线程被中断了\",{\"1\":{\"144\":1}}],[\"线程开始运行\",{\"1\":{\"144\":1,\"145\":1}}],[\"线程的加入只是等待另一个线程的完成\",{\"1\":{\"148\":1}}],[\"线程的礼让和加入\",{\"0\":{\"146\":1}}],[\"线程的优先级一般分为以下三种\",{\"1\":{\"145\":1}}],[\"线程的下一个状态会出现以下情况\",{\"1\":{\"143\":1}}],[\"线程的休眠和中断\",{\"0\":{\"143\":1}}],[\"线程的创建和启动\",{\"0\":{\"139\":1}}],[\"线程和进程差不多\",{\"1\":{\"142\":1}}],[\"线程是程序执行中一个单一的顺序控制流程\",{\"1\":{\"138\":1}}],[\"线程横空出世\",{\"1\":{\"138\":1}}],[\"线性表支持随机访问\",{\"1\":{\"24\":1}}],[\"线性表\",{\"1\":{\"24\":1}}],[\"浏览器也是可以直接打开xml文件的\",{\"1\":{\"545\":1}}],[\"浏览器会显示无法访问\",{\"1\":{\"455\":1}}],[\"浏览器\",{\"1\":{\"138\":1}}],[\"进而补货\",{\"1\":{\"174\":1}}],[\"进入等待状态并释放锁\",{\"1\":{\"161\":1}}],[\"进程之间的通信就变得非常麻烦\",{\"1\":{\"138\":1}}],[\"进程是拥有资源和独立运行的最小单位\",{\"1\":{\"138\":1}}],[\"进程是程序执行的实体\",{\"1\":{\"138\":1}}],[\"进程与线程概念\",{\"0\":{\"138\":1}}],[\"进行划分\",{\"1\":{\"664\":1}}],[\"进行自动继承\",{\"1\":{\"658\":1}}],[\"进行回滚操作\",{\"1\":{\"593\":1}}],[\"进行处理\",{\"1\":{\"539\":1}}],[\"进行结尾\",{\"1\":{\"472\":1}}],[\"进行优化\",{\"1\":{\"433\":1}}],[\"进行训练\",{\"1\":{\"427\":1}}],[\"进行赋值\",{\"1\":{\"427\":1}}],[\"进行固定求解\",{\"1\":{\"427\":1}}],[\"进行生成数据\",{\"1\":{\"410\":1}}],[\"进行更新即可\",{\"1\":{\"400\":1}}],[\"进行的采样\",{\"1\":{\"369\":1}}],[\"进行估计\",{\"1\":{\"363\":1,\"379\":1}}],[\"进行了无穷多步来进行了真实的求解\",{\"1\":{\"356\":1}}],[\"进行迭代\",{\"1\":{\"355\":1,\"386\":1}}],[\"进行求解\",{\"1\":{\"332\":1,\"351\":1,\"388\":1}}],[\"进行类型比较又会导致额外的开销和增加代码量\",{\"1\":{\"280\":1}}],[\"进行异常捕获\",{\"1\":{\"267\":1}}],[\"进行捕获\",{\"1\":{\"267\":1}}],[\"进行拼接操作\",{\"1\":{\"245\":1}}],[\"进行加密\",{\"1\":{\"199\":1}}],[\"进行数据转换就会很麻烦\",{\"1\":{\"126\":1}}],[\"进行判断\",{\"1\":{\"84\":1}}],[\"进行判断来删除元素\",{\"1\":{\"84\":1}}],[\"进行判断的\",{\"1\":{\"84\":1}}],[\"进行分割\",{\"1\":{\"71\":1}}],[\"进行倒序排列\",{\"1\":{\"71\":1}}],[\"使其符合我们指定构造方法的定义\",{\"1\":{\"569\":1}}],[\"使得用户能够随意登陆别人的账号\",{\"1\":{\"532\":1}}],[\"使得v^\",{\"1\":{\"417\":1}}],[\"使得java能够更好的体现面向对象的思想\",{\"1\":{\"226\":1}}],[\"使得持有当前对象锁的线程进入等待状态\",{\"1\":{\"215\":1}}],[\"使得整个过程被模糊了\",{\"1\":{\"192\":1}}],[\"使得线程处于等待状态一段时间\",{\"1\":{\"143\":1}}],[\"使得某些属性不参与序列化\",{\"1\":{\"133\":1}}],[\"使用load方法读取本地文件中的所有配置到map中\",{\"1\":{\"665\":1}}],[\"使用lombok\",{\"0\":{\"540\":1}}],[\"使用lombok之后\",{\"1\":{\"538\":1}}],[\"使用起来和hashmap是差不多的\",{\"1\":{\"665\":1}}],[\"使用起来非常简单\",{\"1\":{\"636\":1}}],[\"使用注解开发\",{\"0\":{\"621\":1}}],[\"使用注解的时候可以不用传入属性值\",{\"1\":{\"207\":1}}],[\"使用foreach来完成它就很简单了\",{\"1\":{\"604\":1}}],[\"使用for循环来一个一个执行insert语句\",{\"1\":{\"599\":1}}],[\"使用循环操作执行数据库相关操作实际上非常耗费资源\",{\"1\":{\"599\":1}}],[\"使用嵌套的结果映射来处理连接结果的重复子集\",{\"1\":{\"577\":1}}],[\"使用map类型变量进行接受\",{\"1\":{\"561\":1}}],[\"使用哪个账号进行登陆了\",{\"1\":{\"552\":1}}],[\"使用原生方式和小辣椒方式编写类的区别\",{\"1\":{\"538\":1}}],[\"使用原始类型接收一个integer类型的arraylist\",{\"1\":{\"80\":1}}],[\"使用这种方式\",{\"1\":{\"533\":1}}],[\"使用反射的好处是\",{\"1\":{\"527\":1}}],[\"使用java读取xml内容不要求掌握\",{\"1\":{\"547\":1}}],[\"使用jdbc连接数据库\",{\"0\":{\"516\":1}}],[\"使用jconsole也可以进行监测\",{\"1\":{\"156\":1}}],[\"使用浏览器访问socket服务器\",{\"0\":{\"455\":1}}],[\"使用钻石运算符可以省略其中的类型\",{\"1\":{\"281\":1}}],[\"使用object类型作为引用\",{\"1\":{\"280\":1}}],[\"使用泛型的原因\",{\"0\":{\"280\":1}}],[\"使用运行时异常同样可以捕获到\",{\"1\":{\"267\":1}}],[\"使用throws关键字告知调用方此方法会抛出哪些异常\",{\"1\":{\"266\":1}}],[\"使用throw关键字来抛出异常\",{\"1\":{\"266\":1}}],[\"使用new表示\",{\"1\":{\"258\":1}}],[\"使用newline进行换行\",{\"1\":{\"113\":1}}],[\"使用双冒号来进行方法引用\",{\"1\":{\"258\":1}}],[\"使用外部静态变量\",{\"1\":{\"254\":1}}],[\"使用频率很低\",{\"1\":{\"253\":1}}],[\"使用频率极高\",{\"1\":{\"21\":1}}],[\"使用socket进行数据传输\",{\"0\":{\"448\":1}}],[\"使用split方法进行字符串分割\",{\"1\":{\"244\":1}}],[\"使用synchronized关键字创建同步代码块\",{\"1\":{\"155\":1}}],[\"使用就像对象的参数一样\",{\"1\":{\"221\":1}}],[\"使用枚举类也非常方便\",{\"1\":{\"221\":1}}],[\"使用desc表示降序排序\",{\"1\":{\"492\":1}}],[\"使用default关键字为接口中的方法添加默认实现\",{\"1\":{\"219\":1}}],[\"使用datainputstream可以读取\",{\"1\":{\"129\":1}}],[\"使用implements关键字来实现接口\",{\"1\":{\"219\":1}}],[\"使用import关键字导入其他包中的类\",{\"1\":{\"120\":1}}],[\"使用interface表示这是一个接口\",{\"1\":{\"219\":1}}],[\"使用value则无需填入\",{\"1\":{\"207\":1}}],[\"使用getdeclaredconstructor\",{\"1\":{\"191\":1}}],[\"使用get方法根据键获取对应的值\",{\"1\":{\"57\":1}}],[\"使用class类静态方法forname\",{\"1\":{\"182\":1}}],[\"使用class关键字\",{\"1\":{\"182\":1}}],[\"使用copyof快速将内容拷贝到扩容后的新数组中并设定为新的elementdata底层数组\",{\"1\":{\"25\":1}}],[\"使用多线程进行并行排序\",{\"1\":{\"173\":1}}],[\"使用\",{\"0\":{\"533\":1},\"1\":{\"155\":1,\"267\":1,\"540\":5,\"629\":1,\"631\":1}}],[\"使用的是系统提供的输入流\",{\"1\":{\"128\":1}}],[\"使用长度为10的byte\",{\"1\":{\"94\":1}}],[\"使用方法同输入流一样\",{\"1\":{\"92\":1}}],[\"使用arg标签来代表每一个参数\",{\"1\":{\"569\":1}}],[\"使用asc表示升序排序\",{\"1\":{\"492\":1}}],[\"使用available方法能查看当前可读的剩余字节数量\",{\"1\":{\"91\":1}}],[\"使用add添加元素\",{\"1\":{\"25\":1}}],[\"使用resulthandler来处理结果\",{\"1\":{\"564\":1}}],[\"使用resulttype属性来指定\",{\"1\":{\"559\":1}}],[\"使用read可以直接读取一个字节的数据\",{\"1\":{\"91\":1}}],[\"使用reduce方法\",{\"1\":{\"71\":1}}],[\"使用equals判断\",{\"1\":{\"71\":1}}],[\"使用一种类似用\",{\"1\":{\"71\":1}}],[\"使用put方法添加键值对\",{\"1\":{\"57\":1}}],[\"使用即可\",{\"1\":{\"50\":1}}],[\"使用示例\",{\"0\":{\"34\":1}}],[\"使用匿名内部类\",{\"1\":{\"25\":1}}],[\"使用接口的引用来操作具体的集合类实现\",{\"1\":{\"25\":1}}],[\"使用时\",{\"1\":{\"15\":1}}],[\"秘制小汉堡\",{\"1\":{\"128\":1}}],[\"❌\",{\"1\":{\"121\":6,\"285\":3}}],[\"✅\",{\"1\":{\"121\":10,\"285\":4}}],[\"公共\",{\"1\":{\"121\":1}}],[\"受保护\",{\"1\":{\"121\":1}}],[\"受限制的始终是底层哈希表的长度\",{\"1\":{\"60\":1}}],[\"私有\",{\"1\":{\"121\":1}}],[\"之间存在什么关系\",{\"1\":{\"353\":1}}],[\"之外的任何单个字符\",{\"1\":{\"246\":1}}],[\"之外\",{\"1\":{\"236\":1}}],[\"之前通过info方法直接输出的结果就是使用的默认级别的日志\",{\"1\":{\"638\":1}}],[\"之前通过创建一个映射器来将结果快速转换为实体类\",{\"1\":{\"570\":1}}],[\"之前我们需要像这样编写\",{\"1\":{\"623\":1}}],[\"之前被删除的数据回来了\",{\"1\":{\"593\":1}}],[\"之前的操作也就不会生效\",{\"1\":{\"534\":1}}],[\"之前介绍的方法都是\",{\"1\":{\"432\":1}}],[\"之前执行\",{\"1\":{\"156\":1}}],[\"之前使用的scanner\",{\"1\":{\"128\":1}}],[\"之前就是直接使用的\",{\"1\":{\"120\":1}}],[\"之后进行迭代\",{\"1\":{\"355\":1}}],[\"之后\",{\"1\":{\"50\":1,\"108\":2}}],[\"随着无人机与用户之间距离和发射功率的变化\",{\"1\":{\"294\":1}}],[\"随着我们的程序不断变大\",{\"1\":{\"120\":1}}],[\"随机变量\",{\"1\":{\"390\":1}}],[\"随机梯度下降\",{\"1\":{\"386\":1}}],[\"随机近似理论与随机梯度下降算法\",{\"0\":{\"377\":1}}],[\"随机数生成\",{\"1\":{\"274\":1}}],[\"随机int型数字\",{\"1\":{\"71\":1}}],[\"随时都认为有其他线程在对数据进行修改\",{\"1\":{\"155\":1}}],[\"包下所有的接口都将直接作为mapper配置接口\",{\"1\":{\"622\":1}}],[\"包含会抛出\",{\"1\":{\"285\":1}}],[\"包装类支持字符串直接转换\",{\"1\":{\"228\":1}}],[\"包装类的方法\",{\"0\":{\"228\":1}}],[\"包装类实际上就是将我们的基本数据类型\",{\"1\":{\"227\":1}}],[\"包装类型支持自动装箱\",{\"1\":{\"227\":1}}],[\"包装类型的自动装箱和拆箱机制\",{\"1\":{\"227\":1}}],[\"包装类型都有一个type\",{\"1\":{\"183\":1}}],[\"包延时任务\",{\"1\":{\"166\":1}}],[\"包其实就是用来区分类位置的东西\",{\"1\":{\"120\":1}}],[\"包的命名规则同样是英文和数字的组合\",{\"1\":{\"120\":1}}],[\"包的声明和导入\",{\"0\":{\"120\":1}}],[\"包的访问与控制\",{\"0\":{\"119\":1}}],[\"包括testsqlbuilder中编写的方法也需要添加\",{\"1\":{\"630\":1}}],[\"包括一些sql语句参数的使用也是和之前完全一样\",{\"1\":{\"624\":1}}],[\"包括url\",{\"1\":{\"552\":1}}],[\"包括后面的spring等众多框架都会用到xml来作为框架的配置文件\",{\"1\":{\"547\":1}}],[\"包括读未提交\",{\"1\":{\"510\":1}}],[\"包括=\",{\"1\":{\"491\":1}}],[\"包括但不限于\",{\"1\":{\"460\":1}}],[\"包括接口\",{\"1\":{\"282\":1}}],[\"包括课程名称\",{\"1\":{\"280\":1}}],[\"包括返回值\",{\"1\":{\"257\":1}}],[\"包括对方法的调用和super关键字的使用\",{\"1\":{\"251\":1}}],[\"包括对象内部的所有成员变量\",{\"1\":{\"220\":1}}],[\"包括对象的各个属性\",{\"1\":{\"215\":1}}],[\"包括换行\",{\"1\":{\"246\":1}}],[\"包括引用类型和基本类型\",{\"1\":{\"234\":1}}],[\"包括三种策略\",{\"1\":{\"206\":1}}],[\"包括方法上\",{\"1\":{\"203\":1}}],[\"包括方法的形式参数列表\",{\"1\":{\"192\":1}}],[\"包括void\",{\"1\":{\"183\":1}}],[\"包括类里面有哪些方法\",{\"1\":{\"180\":1}}],[\"包括类里面有哪些字段\",{\"1\":{\"179\":1}}],[\"包括文本\",{\"1\":{\"88\":1}}],[\"包括\",{\"1\":{\"66\":1,\"472\":1,\"493\":1,\"679\":1}}],[\"包括列表\",{\"1\":{\"21\":1}}],[\"包括数组复制方法\",{\"1\":{\"14\":1}}],[\"优秀\",{\"1\":{\"280\":1,\"281\":2}}],[\"优化方法\",{\"0\":{\"427\":1}}],[\"优化算法\",{\"0\":{\"421\":1}}],[\"优化目标函数的算法\",{\"1\":{\"417\":1}}],[\"优化问题\",{\"1\":{\"388\":1}}],[\"优化问题建立\",{\"0\":{\"296\":1}}],[\"优化\",{\"1\":{\"118\":1}}],[\"优先使用cpu资源\",{\"1\":{\"145\":1}}],[\"优先使用作用域最接近的\",{\"1\":{\"7\":1}}],[\"优先级越高的线程\",{\"1\":{\"145\":2}}],[\"优先级队列只能保证出队顺序是按照优先级进行的\",{\"1\":{\"46\":1}}],[\"优先级队列并不是队列中所有的元素都是按照优先级排放的\",{\"1\":{\"46\":1}}],[\"优先级队列可以根据每一个元素的优先级\",{\"1\":{\"46\":1}}],[\"优先级队列\",{\"0\":{\"46\":1},\"1\":{\"45\":1}}],[\"关于使用配置文件的形式修改jul部分内容的默认值就先讲解到这里\",{\"1\":{\"667\":1}}],[\"关于对象类型的变量\",{\"1\":{\"4\":1}}],[\"关联查询\",{\"0\":{\"629\":1}}],[\"关闭自动提交\",{\"1\":{\"534\":4}}],[\"关闭自动提交后相当于开启事务\",{\"1\":{\"534\":1}}],[\"关闭输入方向的流\",{\"1\":{\"449\":1}}],[\"关闭输出方向的流\",{\"1\":{\"449\":1}}],[\"关键元素\",{\"1\":{\"305\":1}}],[\"关键字推荐使用大写\",{\"1\":{\"472\":1}}],[\"关键字\",{\"0\":{\"133\":1},\"1\":{\"216\":1,\"235\":1}}],[\"关键字来声明一个变量或一个方法为静态的\",{\"1\":{\"117\":1}}],[\"则会变成事务操作\",{\"1\":{\"558\":1}}],[\"则会使用默认值\",{\"1\":{\"475\":1}}],[\"则不允许对此视图执行insert和update操作\",{\"1\":{\"507\":1}}],[\"则此视图不允许更新\",{\"1\":{\"507\":5}}],[\"则默认值不会生效\",{\"1\":{\"475\":1}}],[\"则用空格填充\",{\"1\":{\"474\":1}}],[\"则用户的关联动作数为2n∑n=1n​∣kn​∣\",{\"1\":{\"299\":1}}],[\"则只是进行一次带入求解\",{\"1\":{\"355\":1}}],[\"则是对多个\",{\"1\":{\"326\":1}}],[\"则是让处于\",{\"1\":{\"161\":1}}],[\"则总动作空间的大小为7+2n∑n=1n​∣kn​∣会导致动作空间过大\",{\"1\":{\"299\":1}}],[\"则无人机将获得正奖励\",{\"1\":{\"298\":1}}],[\"则无需再去请求外部设备\",{\"1\":{\"103\":1}}],[\"则等价于\",{\"1\":{\"246\":1}}],[\"则表示只能赋一次值\",{\"1\":{\"217\":1}}],[\"则表示永久等待\",{\"1\":{\"161\":1}}],[\"则主动唤醒自己\",{\"1\":{\"161\":1}}],[\"则可以先让出一部分资源\",{\"1\":{\"145\":1}}],[\"则必须实现serializable接口才能被序列化\",{\"1\":{\"131\":1}}],[\"则之后的内容不会被保留\",{\"1\":{\"108\":1}}],[\"主键可以使用idarg来表示\",{\"1\":{\"569\":1}}],[\"主键约束保证表中的每一行数据都有唯一的标识符\",{\"1\":{\"476\":1}}],[\"主键列的值用来唯一标识每一行数据\",{\"1\":{\"475\":1}}],[\"主键\",{\"1\":{\"475\":1,\"476\":2}}],[\"主线程停止1秒\",{\"1\":{\"154\":1,\"155\":2}}],[\"主动让出cpu资源\",{\"0\":{\"147\":1}}],[\"主方法的string参数是java\",{\"1\":{\"120\":1}}],[\"主机接收了就没了\",{\"1\":{\"108\":1}}],[\"主要是可以设定编码格式\",{\"1\":{\"545\":1}}],[\"主要掌握几种流之间的操作\",{\"1\":{\"454\":1}}],[\"主要框架\",{\"1\":{\"303\":1}}],[\"主要内容\",{\"0\":{\"291\":1,\"514\":1}}],[\"主要贡献\",{\"0\":{\"290\":1}}],[\"主要动机\",{\"0\":{\"289\":1}}],[\"主要区别\",{\"1\":{\"88\":1}}],[\"主要类\",{\"1\":{\"88\":2}}],[\"主要方法\",{\"1\":{\"32\":1}}],[\"暂时不需要了解\",{\"1\":{\"107\":1}}],[\"暂时不做讲解\",{\"1\":{\"36\":1}}],[\"装饰着模式\",{\"0\":{\"107\":1}}],[\"提高性能\",{\"1\":{\"564\":1}}],[\"提高泛化能力\",{\"1\":{\"416\":1}}],[\"提交事务\",{\"1\":{\"510\":1,\"534\":2}}],[\"提升采样的效率\",{\"1\":{\"310\":1}}],[\"提升clone方法的访问权限\",{\"1\":{\"220\":1}}],[\"提出解决总用户mos最大化问题的三步骤\",{\"1\":{\"290\":1}}],[\"提出了一个理想的由qoe驱动的多无人机协助通信框架\",{\"1\":{\"290\":1}}],[\"提前将部分内容存入内存\",{\"1\":{\"103\":1}}],[\"提供了一种特殊的语法\",{\"1\":{\"255\":1}}],[\"提供了一个支持\",{\"1\":{\"35\":1}}],[\"提供的方法进行计算\",{\"1\":{\"229\":1}}],[\"提供的迭代器生成方法\",{\"1\":{\"36\":1}}],[\"很容易出现以下的情况\",{\"1\":{\"280\":1}}],[\"很遗憾\",{\"1\":{\"236\":1}}],[\"很有可能造成程序反应迟钝\",{\"1\":{\"103\":1}}],[\"很简单\",{\"1\":{\"25\":1}}],[\"虽然手机爆炸的概率很小\",{\"1\":{\"638\":1}}],[\"虽然mybatis为我们提供了之前xml配置中各种操作的对应注解\",{\"1\":{\"625\":1}}],[\"虽然缓存机制给我们提供了很大的性能提升\",{\"1\":{\"616\":1}}],[\"虽然这样可以实现和之前差不多的效果\",{\"1\":{\"630\":1}}],[\"虽然这样看似非常完美\",{\"1\":{\"599\":1}}],[\"虽然这两种列表的实现不同\",{\"1\":{\"33\":1}}],[\"虽然日志中已经提示生效1行\",{\"1\":{\"593\":1}}],[\"虽然没有干什么事情\",{\"1\":{\"552\":1}}],[\"虽然我们能够通过jdbc来连接和操作数据库\",{\"1\":{\"544\":1}}],[\"虽然我们目前还没有学习数组\",{\"1\":{\"227\":1}}],[\"虽然添加索引后会使得查询效率更高\",{\"1\":{\"508\":1}}],[\"虽然此用户能够成功登录\",{\"1\":{\"501\":1}}],[\"虽然并不是一开始的类型\",{\"1\":{\"280\":1}}],[\"虽然是继承于\",{\"1\":{\"236\":1}}],[\"虽然a和b的值相同\",{\"1\":{\"227\":1}}],[\"虽然java语言是一个面向对象的语言\",{\"1\":{\"226\":1}}],[\"虽然拥有了创世主的能力\",{\"1\":{\"193\":1}}],[\"虽然任务执行完成了\",{\"1\":{\"167\":1}}],[\"虽然stop\",{\"1\":{\"142\":1}}],[\"虽然能得到对象\",{\"1\":{\"133\":1}}],[\"虽然给定的是fileinputstream\",{\"1\":{\"126\":1}}],[\"虽然给定的是fileoutputstream\",{\"1\":{\"126\":1}}],[\"虽然普通的文件流读取文件数据非常便捷\",{\"1\":{\"103\":1}}],[\"刷新\",{\"1\":{\"97\":1}}],[\"牛\",{\"1\":{\"97\":2}}],[\"支持c语言样式\",{\"1\":{\"235\":1}}],[\"支持载入外部class文件\",{\"1\":{\"199\":1}}],[\"支持参数\",{\"1\":{\"161\":1}}],[\"支持\",{\"1\":{\"108\":1,\"285\":1}}],[\"支持获取编码\",{\"1\":{\"97\":1}}],[\"支持泛型的数组转换\",{\"1\":{\"23\":1}}],[\"追加操作\",{\"0\":{\"93\":1}}],[\"操作结束\",{\"0\":{\"615\":1}}],[\"操作是同样的\",{\"1\":{\"582\":1}}],[\"操作出现在suspend\",{\"1\":{\"156\":1}}],[\"操作的都是同一个目标\",{\"1\":{\"117\":1}}],[\"操作和原来的流是一样的\",{\"1\":{\"105\":1}}],[\"操作\",{\"0\":{\"588\":1},\"1\":{\"92\":1,\"108\":1,\"112\":1}}],[\"操作而是write\",{\"1\":{\"92\":1}}],[\"操作就是相同的\",{\"1\":{\"84\":1}}],[\"输入密码后即可登陆此用户\",{\"1\":{\"501\":1}}],[\"输入序列\",{\"1\":{\"382\":1}}],[\"输入流会以某种方式保留之后读取的readlimit\",{\"1\":{\"108\":1}}],[\"输入流\",{\"0\":{\"90\":1,\"128\":1}}],[\"输出节点名称\",{\"1\":{\"547\":1}}],[\"输出为标量\",{\"1\":{\"386\":1}}],[\"输出为\",{\"1\":{\"254\":1}}],[\"输出流没有read\",{\"1\":{\"92\":1}}],[\"输出流也需要在最后调用close\",{\"1\":{\"92\":1}}],[\"输出流\",{\"0\":{\"92\":1}}],[\"跳过了一个字节\",{\"1\":{\"91\":1}}],[\"第三方框架兼容性\",{\"0\":{\"677\":1}}],[\"第三范式\",{\"0\":{\"466\":1}}],[\"第三个参数是读取流中的字节数\",{\"1\":{\"91\":1}}],[\"第一范式是指数据库的每一列都是不可分割的基本数据项\",{\"1\":{\"464\":1}}],[\"第一范式\",{\"0\":{\"464\":1}}],[\"第一种\",{\"1\":{\"379\":1}}],[\"第二个参数开启后会续写已有的日志\",{\"1\":{\"648\":1}}],[\"第二个参数是从给定数组的哪个位置开始放入内容\",{\"1\":{\"91\":1}}],[\"第二次获取的时候会进行重新查询\",{\"1\":{\"611\":1}}],[\"第二范式要求表中必须存在主键\",{\"1\":{\"465\":1}}],[\"第二范式\",{\"0\":{\"465\":1}}],[\"第二种\",{\"1\":{\"379\":1}}],[\"无关\",{\"1\":{\"437\":1}}],[\"无记忆性\",{\"1\":{\"329\":1}}],[\"无人机需要进行移动\",{\"1\":{\"299\":1}}],[\"无人机的动态移动设计\",{\"0\":{\"299\":1}}],[\"无人机的位置初始化也是随机部署的\",{\"1\":{\"298\":1}}],[\"无人机的3d部署\",{\"0\":{\"298\":1}}],[\"无人机3d部署算法\",{\"1\":{\"298\":1}}],[\"无人机\",{\"1\":{\"298\":1}}],[\"无人机n以可变高度悬停在用户上方\",{\"1\":{\"298\":1}}],[\"无人机n的高度需满足\",{\"1\":{\"294\":1}}],[\"无人机n与用户kn​在时间t的距离表示为\",{\"1\":{\"293\":1}}],[\"无人机往往有更高的los链接概率\",{\"1\":{\"294\":1}}],[\"无参构造方法被覆盖\",{\"1\":{\"221\":1}}],[\"无形参的方法\",{\"1\":{\"207\":1}}],[\"无限循环等待客户端连接\",{\"1\":{\"447\":1}}],[\"无限循环执行\",{\"1\":{\"165\":1}}],[\"无限循环\",{\"1\":{\"144\":1}}],[\"无论什么类型都可以通过我们的方法来进行实体类型映射\",{\"1\":{\"527\":1}}],[\"无论哪个会话失效\",{\"1\":{\"612\":1}}],[\"无论哪个会话对于数据的查询缓存都可以直接被所有会话使用\",{\"1\":{\"611\":1}}],[\"无论哪行进行指定操作都会执行触发器\",{\"1\":{\"509\":1}}],[\"无论哪种方法所获取到的\",{\"1\":{\"182\":1}}],[\"无论是什么级别都进行打印\",{\"1\":{\"640\":1}}],[\"无论是一级缓存还是二级缓存\",{\"1\":{\"615\":1}}],[\"无论是否处于事务模式下\",{\"1\":{\"599\":1}}],[\"无论是否出现异常\",{\"1\":{\"267\":1}}],[\"无论是\",{\"1\":{\"377\":1}}],[\"无论是基本类型还是引用类型\",{\"1\":{\"220\":1}}],[\"无论是方法\",{\"1\":{\"208\":1}}],[\"无论是静态方法还是成员方法\",{\"1\":{\"14\":1}}],[\"无论你是调用方法\",{\"1\":{\"138\":1}}],[\"无法关闭\",{\"1\":{\"611\":1}}],[\"无法查到\",{\"1\":{\"593\":1}}],[\"无法代表其原本的意思\",{\"1\":{\"564\":1}}],[\"无法继续申请内存了\",{\"1\":{\"264\":1}}],[\"无法显式定义构造函数或初始化块\",{\"1\":{\"255\":1}}],[\"无法直接定义新的属性\",{\"1\":{\"255\":1}}],[\"无法进行修改\",{\"1\":{\"243\":1}}],[\"无法表示一个非常大的数\",{\"1\":{\"229\":1}}],[\"无法使用lambda表达式简化\",{\"1\":{\"166\":1}}],[\"无法使用this关键字\",{\"1\":{\"117\":1}}],[\"无法获取成员变量的值\",{\"1\":{\"117\":1}}],[\"无法reset\",{\"1\":{\"108\":1}}],[\"无需再编写finally语句块\",{\"1\":{\"90\":1}}],[\"路径\",{\"1\":{\"90\":2}}],[\"减少了字节到字符的转换时间\",{\"1\":{\"88\":1}}],[\"性质\",{\"0\":{\"239\":1}}],[\"性能\",{\"1\":{\"88\":1}}],[\"性别呢\",{\"1\":{\"9\":1}}],[\"性别\",{\"1\":{\"4\":1,\"462\":1,\"465\":1}}],[\"字母的所有字母\",{\"1\":{\"246\":1}}],[\"字母\",{\"1\":{\"246\":1}}],[\"字符模糊匹配\",{\"1\":{\"491\":1}}],[\"字符\",{\"1\":{\"246\":2}}],[\"字符数组转字符串\",{\"1\":{\"244\":1}}],[\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组\",{\"1\":{\"244\":1}}],[\"字符串支持使用\",{\"1\":{\"245\":1}}],[\"字符串类中提供了很多方便我们操作的方法\",{\"1\":{\"244\":1}}],[\"字符串类是一个比较特殊的类\",{\"1\":{\"243\":1}}],[\"字符串的内容比较\",{\"1\":{\"244\":1}}],[\"字符串中的字符一旦确定\",{\"1\":{\"243\":1}}],[\"字符串\",{\"0\":{\"232\":1,\"243\":1}}],[\"字符串转integer有多个方法\",{\"1\":{\"228\":1}}],[\"字符串内容的比较\",{\"1\":{\"216\":1}}],[\"字符流只支持char\",{\"1\":{\"96\":1}}],[\"字符流是以一个具体的字符进行读取\",{\"1\":{\"96\":1}}],[\"字符流不同于字节\",{\"1\":{\"96\":1}}],[\"字符流在处理文本数据时通常更高效\",{\"1\":{\"88\":1}}],[\"字符流自动处理字符编码转换\",{\"1\":{\"88\":1}}],[\"字符流仅适用于文本数据\",{\"1\":{\"88\":1}}],[\"字符流以字符为单位\",{\"1\":{\"88\":1}}],[\"字符流\",{\"1\":{\"88\":1}}],[\"字节流不处理字符编码\",{\"1\":{\"88\":1}}],[\"字节流适用于所有类型的数据\",{\"1\":{\"88\":1}}],[\"字节流以字节为单位\",{\"1\":{\"88\":1}}],[\"字节流\",{\"1\":{\"88\":1}}],[\"编写好后\",{\"1\":{\"554\":1}}],[\"编写mybatis的配置文件\",{\"1\":{\"552\":1}}],[\"编写适用于自己数据库的实现类\",{\"1\":{\"515\":1}}],[\"编译阶段处理\",{\"1\":{\"539\":1}}],[\"编译时异常的子类有很多很多\",{\"1\":{\"265\":1}}],[\"编译时异常只需要继承\",{\"1\":{\"265\":1}}],[\"编译时异常明确指出可能会出现的异常\",{\"1\":{\"264\":1}}],[\"编译时异常\",{\"1\":{\"264\":1}}],[\"编译器是很聪明的\",{\"1\":{\"245\":1}}],[\"编译器不知道到底我们想用的是哪一个string类\",{\"1\":{\"120\":1}}],[\"编译后\",{\"1\":{\"199\":1}}],[\"编译出来就自带\",{\"1\":{\"9\":1}}],[\"编码处理\",{\"1\":{\"88\":3}}],[\"音频\",{\"1\":{\"88\":1}}],[\"图片\",{\"1\":{\"88\":1}}],[\"适用于windows\",{\"1\":{\"460\":1}}],[\"适用于中小型\",{\"1\":{\"460\":1}}],[\"适用于处理文本文件\",{\"1\":{\"88\":1}}],[\"适用于处理所有类型的数据\",{\"1\":{\"88\":1}}],[\"适用范围\",{\"1\":{\"88\":1}}],[\"适用场景\",{\"1\":{\"88\":2}}],[\"为一个函数方程\",{\"1\":{\"381\":1}}],[\"为状态\",{\"1\":{\"372\":1}}],[\"为什么不去求\",{\"1\":{\"364\":1}}],[\"为什么考虑\",{\"1\":{\"360\":1}}],[\"为什么这个迭代算法最终可以找到最优策略\",{\"1\":{\"353\":1}}],[\"为什么会找不到此方法呢\",{\"1\":{\"198\":1}}],[\"为discounted\",{\"1\":{\"324\":1}}],[\"为t时刻的mos评分\",{\"1\":{\"295\":1}}],[\"为\",{\"1\":{\"294\":1,\"327\":2,\"331\":1,\"363\":1,\"433\":1}}],[\"为指标\",{\"1\":{\"290\":1}}],[\"为子线程的\",{\"1\":{\"163\":1}}],[\"为单位进行读写操作\",{\"1\":{\"88\":2}}],[\"为了能够支持中文\",{\"1\":{\"477\":1}}],[\"为了让右边取到最大值的情况\",{\"1\":{\"342\":1}}],[\"为了进行\",{\"1\":{\"332\":1}}],[\"为了应对具有无限步的trajectory的return=∞的情况\",{\"1\":{\"304\":1}}],[\"为了保证所有用户都能连接到网络\",{\"1\":{\"294\":1}}],[\"为了满足不同用户传输速率要求\",{\"1\":{\"294\":1}}],[\"为了在los信道概率和路径损耗之间取得平衡\",{\"1\":{\"294\":1}}],[\"为了在创建匿名对象时进行属性初始化\",{\"1\":{\"255\":1}}],[\"为了解决以上问题\",{\"1\":{\"280\":1}}],[\"为了统计学生成绩\",{\"1\":{\"280\":1}}],[\"为了优化效率\",{\"1\":{\"244\":1}}],[\"为了避免上面的这个现象\",{\"1\":{\"155\":1}}],[\"为了使得线程资源分配更加合理\",{\"1\":{\"145\":1}}],[\"为了防止意外将之前的键值对覆盖掉\",{\"1\":{\"57\":1}}],[\"为了简便\",{\"1\":{\"34\":1}}],[\"为了兼容之前的java版本\",{\"1\":{\"16\":1}}],[\"为了支持小数加法\",{\"1\":{\"8\":1}}],[\"位于java\",{\"1\":{\"636\":1}}],[\"位\",{\"1\":{\"88\":2}}],[\"值为int的最大值\",{\"1\":{\"640\":1}}],[\"值为1000\",{\"1\":{\"638\":1}}],[\"值为0\",{\"1\":{\"58\":1}}],[\"值3\",{\"1\":{\"482\":1}}],[\"值2\",{\"1\":{\"482\":5}}],[\"值1\",{\"1\":{\"482\":5}}],[\"值函数近似\",{\"0\":{\"415\":1}}],[\"值迭代和策略迭代\",{\"0\":{\"346\":1}}],[\"值的估计通过一个网络来进行描述\",{\"1\":{\"308\":1}}],[\"值\",{\"1\":{\"298\":1}}],[\"值还是可以修改\",{\"1\":{\"239\":1}}],[\"值也相同\",{\"1\":{\"84\":1}}],[\"两个算法迭代过程十分类似\",{\"1\":{\"355\":1}}],[\"两个方法同时在运行或者是两个计算同时在进行\",{\"1\":{\"138\":1}}],[\"两个对象只有\",{\"1\":{\"84\":1}}],[\"两个需要比较的数会在这里给出\",{\"1\":{\"14\":1}}],[\"以灵活地应对需要解决的问题\",{\"1\":{\"544\":1}}],[\"以下日志级别依次降低\",{\"1\":{\"638\":1}}],[\"以下数据类型用于存储时间\",{\"1\":{\"474\":1}}],[\"以下数据类型用于存储数字\",{\"1\":{\"474\":1}}],[\"以下的数据类型用于字符串存储\",{\"1\":{\"474\":1}}],[\"以insert\",{\"1\":{\"472\":1}}],[\"以向用户提供可靠的服务\",{\"1\":{\"294\":1}}],[\"以\",{\"1\":{\"290\":1}}],[\"以上的方法虽然很好地解决了多种类型存储问题\",{\"1\":{\"280\":1}}],[\"以毫秒为单位\",{\"1\":{\"142\":1}}],[\"以某种格式保存对象\",{\"1\":{\"130\":1}}],[\"以操作writer的样子写入outputstream\",{\"1\":{\"126\":1}}],[\"以字符\",{\"1\":{\"88\":1}}],[\"以字节\",{\"1\":{\"88\":1}}],[\"以及如何使用xml来作为mybatis的配置文件\",{\"1\":{\"547\":1}}],[\"以及标签内部的文本\",{\"1\":{\"547\":1}}],[\"以及是否可以到最后优化的成果\",{\"1\":{\"386\":1}}],[\"以及object的方法\",{\"1\":{\"219\":1}}],[\"以及notifyall\",{\"1\":{\"161\":1}}],[\"以及\",{\"1\":{\"84\":1,\"246\":2,\"354\":1,\"373\":1,\"440\":1}}],[\"以set形式返回\",{\"1\":{\"56\":1}}],[\"判断当前对象和给定对象是否相等\",{\"1\":{\"215\":1}}],[\"判断是否为子类或是接口\",{\"1\":{\"186\":1}}],[\"判断是否存在中断标志\",{\"1\":{\"144\":1}}],[\"判断相同\",{\"1\":{\"84\":1}}],[\"判断修改成根据\",{\"1\":{\"84\":1}}],[\"判断两个元素是否相同\",{\"1\":{\"84\":1}}],[\"判断两个键值对是否相等\",{\"1\":{\"56\":1}}],[\"判断两个集合是否相等\",{\"1\":{\"23\":1}}],[\"等\",{\"1\":{\"571\":1}}],[\"等候时间过长\",{\"1\":{\"367\":1}}],[\"等均未知\",{\"1\":{\"360\":1}}],[\"等操作\",{\"1\":{\"285\":1}}],[\"等待结束\",{\"1\":{\"161\":1}}],[\"等待态的线程变为\",{\"1\":{\"161\":1}}],[\"等待\",{\"1\":{\"161\":1}}],[\"等待下一次获得cpu资源\",{\"1\":{\"143\":1}}],[\"等待通知\",{\"1\":{\"142\":1}}],[\"等方法\",{\"1\":{\"84\":1}}],[\"等价于\",{\"1\":{\"59\":1,\"246\":6}}],[\"快速取最小值\",{\"1\":{\"274\":1}}],[\"快速取最大值\",{\"1\":{\"274\":1}}],[\"快速获取文件夹下的文件名称列表\",{\"1\":{\"98\":1}}],[\"快速获取最大值\",{\"1\":{\"71\":1}}],[\"快速填充\",{\"0\":{\"78\":1}}],[\"汇成新的list\",{\"1\":{\"71\":1}}],[\"变参数实际上就是一个数组\",{\"1\":{\"192\":1}}],[\"变成独立的6个元素\",{\"1\":{\"71\":1}}],[\"变量名称\",{\"1\":{\"235\":4}}],[\"变量的值就是当前对象的存放值\",{\"1\":{\"5\":1}}],[\"变量的类型就是对应的类名\",{\"1\":{\"4\":1}}],[\"变量使用之前需要先赋值\",{\"1\":{\"4\":1}}],[\"没啥意义\",{\"1\":{\"229\":1}}],[\"没错\",{\"1\":{\"80\":1,\"258\":1}}],[\"没想到吧\",{\"1\":{\"71\":1}}],[\"没有更新\",{\"1\":{\"611\":1}}],[\"没有进行任何的dml操作\",{\"1\":{\"593\":1}}],[\"没有手动配置的字段会按照之前默认的方式进行赋值\",{\"1\":{\"563\":1}}],[\"没有任何关联\",{\"1\":{\"553\":1}}],[\"没有任何一处需要引用到对象的实际类型\",{\"1\":{\"192\":1}}],[\"没有commit也成功了\",{\"1\":{\"534\":1}}],[\"没有方法体\",{\"1\":{\"218\":1}}],[\"没有方法\",{\"1\":{\"207\":1}}],[\"没有的话就暂时处于休眠状态\",{\"1\":{\"167\":1}}],[\"没有使用哈希表\",{\"1\":{\"62\":1}}],[\"没有返回值\",{\"1\":{\"5\":1}}],[\"接着才是父级\",{\"1\":{\"657\":1}}],[\"接着就是xml编写了\",{\"1\":{\"583\":1}}],[\"接着就是编写sql映射\",{\"1\":{\"583\":1}}],[\"接着就是java这边进行调用了\",{\"1\":{\"560\":1}}],[\"接着是实体类设计\",{\"1\":{\"583\":1}}],[\"接着是我们需要进行查询的参数\",{\"1\":{\"559\":1}}],[\"接着将mapper文件的命名空间修改为我们的接口完整名称\",{\"1\":{\"570\":1}}],[\"接着我们就可以使用\",{\"1\":{\"630\":1}}],[\"接着我们什么都不需要做\",{\"1\":{\"590\":1}}],[\"接着我们需要在程序开始之前加载这里的配置\",{\"1\":{\"667\":1}}],[\"接着我们需要在resultmap编写好对应关系\",{\"1\":{\"578\":1}}],[\"接着我们需要配置一下constructor里面的内容\",{\"1\":{\"569\":1}}],[\"接着我们对三个属性挨个进行比较\",{\"1\":{\"216\":1}}],[\"接收到客户端数据\",{\"1\":{\"448\":1,\"455\":1}}],[\"接收端\",{\"1\":{\"295\":1}}],[\"接下来就是编写我们的sql语句了\",{\"1\":{\"559\":1}}],[\"接下来\",{\"1\":{\"71\":1}}],[\"接口绑定\",{\"0\":{\"570\":1}}],[\"接口内部必须有且仅有一个抽象方法\",{\"1\":{\"257\":1}}],[\"接口也可以通过这种匿名内部类的形式\",{\"1\":{\"255\":1}}],[\"接口同样支持向下转型\",{\"1\":{\"219\":1}}],[\"接口跟抽象类一样\",{\"1\":{\"219\":1}}],[\"接口定义\",{\"1\":{\"219\":1}}],[\"接口支持多继承\",{\"1\":{\"219\":1}}],[\"接口是可以继承\",{\"1\":{\"219\":1}}],[\"接口不同于类\",{\"1\":{\"219\":1}}],[\"接口的默认方法是保底的\",{\"1\":{\"219\":1}}],[\"接口的继承相当于是对接口功能的融合罢了\",{\"1\":{\"219\":1}}],[\"接口的使用和继承的概念有一定的出入\",{\"1\":{\"219\":1}}],[\"接口的类\",{\"1\":{\"77\":1}}],[\"接口可以实现很多个\",{\"1\":{\"219\":1}}],[\"接口里只能定义对应的抽象方法\",{\"1\":{\"219\":1}}],[\"接口包含了一些列方法的定义\",{\"1\":{\"219\":1}}],[\"接口一般只代表某些功能的抽象\",{\"1\":{\"219\":1}}],[\"接口甚至比抽象类还抽象\",{\"1\":{\"219\":1}}],[\"接口中可以存在让抽象方法的默认实现\",{\"1\":{\"219\":1}}],[\"接口中只能定义访问权限为public抽象方法\",{\"1\":{\"219\":1}}],[\"接口中如果定义了与\",{\"1\":{\"219\":1}}],[\"接口中不允许存在成员变量和成员方法\",{\"1\":{\"219\":1}}],[\"接口中的方法可以存在默认实现\",{\"1\":{\"219\":1}}],[\"接口中并没有定义支持指定下标位置访问的添加和删除操作\",{\"1\":{\"48\":1}}],[\"接口中定义的静态方法也只能是public的\",{\"1\":{\"219\":1}}],[\"接口中定义的静态变量只能是public\",{\"1\":{\"219\":1}}],[\"接口中定义的操作\",{\"1\":{\"56\":1}}],[\"接口中定义的\",{\"1\":{\"35\":1}}],[\"接口中定义的方法都是\",{\"1\":{\"47\":1}}],[\"接口中定义的方法\",{\"1\":{\"24\":1}}],[\"接口\",{\"0\":{\"219\":1},\"1\":{\"24\":1,\"219\":1,\"255\":1}}],[\"工人\",{\"1\":{\"218\":1}}],[\"工作内存中存储了该线程以读\",{\"1\":{\"154\":1}}],[\"工具类一般都会内置大量的静态方法\",{\"1\":{\"272\":1}}],[\"工具类就是专门为一些特定场景编写的\",{\"1\":{\"272\":1}}],[\"工具类\",{\"0\":{\"74\":1,\"75\":1,\"271\":1}}],[\"工具类中\",{\"1\":{\"25\":1}}],[\"工厂的机器才会按照预定的流程启动\",{\"1\":{\"71\":1}}],[\"zh\",{\"1\":{\"455\":2,\"552\":1,\"630\":1}}],[\"z0\",{\"1\":{\"246\":1}}],[\"za\",{\"1\":{\"246\":1}}],[\"zo+\",{\"1\":{\"246\":1}}],[\"zoo\",{\"1\":{\"246\":2}}],[\"zo\",{\"1\":{\"246\":2}}],[\"z\",{\"1\":{\"71\":1,\"246\":5}}],[\"去挂起线程的原因\",{\"1\":{\"156\":1}}],[\"去执行的\",{\"1\":{\"118\":1}}],[\"去重\",{\"1\":{\"71\":2}}],[\"去除final标记\",{\"1\":{\"193\":1}}],[\"去除\",{\"1\":{\"71\":1}}],[\"里面条件为\",{\"1\":{\"71\":1}}],[\"xml文件了\",{\"1\":{\"621\":1,\"622\":1}}],[\"xml文件也可以使用注释\",{\"1\":{\"545\":1}}],[\"xml中参数名改为\",{\"1\":{\"571\":1}}],[\"xml配置sql操作\",{\"1\":{\"559\":1}}],[\"xml的文件作为我们的映射器\",{\"1\":{\"554\":1}}],[\"xml的文件\",{\"1\":{\"552\":1}}],[\"xml语言发明最初是用于数据的存储和传输\",{\"1\":{\"545\":1}}],[\"xml语言\",{\"0\":{\"545\":1}}],[\"xml\",{\"1\":{\"455\":1,\"544\":1,\"545\":2,\"547\":1,\"552\":2,\"554\":3,\"558\":1,\"569\":1,\"570\":1}}],[\"xhtml+xml\",{\"1\":{\"455\":1}}],[\"xi​\",{\"1\":{\"386\":2}}],[\"xk+1​=f\",{\"1\":{\"343\":1}}],[\"xk​→x∗\",{\"1\":{\"343\":1}}],[\"xk​\",{\"1\":{\"343\":2,\"386\":1,\"389\":1,\"395\":1}}],[\"xkn​​\",{\"1\":{\"293\":1}}],[\"x∗\",{\"1\":{\"343\":1}}],[\"x=f\",{\"1\":{\"343\":1}}],[\"x2​\",{\"1\":{\"343\":1,\"360\":1}}],[\"x1​\",{\"1\":{\"343\":1}}],[\"x\",{\"1\":{\"343\":2,\"360\":1,\"379\":1,\"384\":10,\"386\":6,\"389\":17,\"395\":9,\"455\":1}}],[\"xuser​\",{\"1\":{\"299\":2}}],[\"xuav​\",{\"1\":{\"298\":1,\"299\":2}}],[\"xt​=⎩⎨⎧​1\",{\"1\":{\"298\":1}}],[\"xd​+1\",{\"1\":{\"298\":1}}],[\"xd​\",{\"1\":{\"298\":1}}],[\"xn​\",{\"1\":{\"293\":2,\"360\":1}}],[\"x之内的随机数\",{\"1\":{\"274\":1}}],[\"xss\",{\"1\":{\"71\":1}}],[\"xxx\",{\"1\":{\"495\":1,\"497\":3,\"559\":4,\"665\":1}}],[\"xxxx\",{\"1\":{\"478\":1}}],[\"xxxxx\",{\"1\":{\"242\":1,\"546\":1}}],[\"xxxinputstream\",{\"1\":{\"454\":1}}],[\"xxxoutputstream\",{\"1\":{\"454\":1}}],[\"xxxexception\",{\"1\":{\"267\":2}}],[\"xx\",{\"1\":{\"71\":1,\"571\":1}}],[\"得到日志的打印结果\",{\"1\":{\"636\":1}}],[\"得到含有噪音的观测值序列\",{\"1\":{\"382\":1}}],[\"得到\",{\"1\":{\"353\":1}}],[\"得到一个样本序列x1​\",{\"1\":{\"360\":1}}],[\"得到一个字符串数组\",{\"1\":{\"244\":1}}],[\"得到一个克隆的对象\",{\"1\":{\"220\":1}}],[\"得到一个class文件\",{\"1\":{\"199\":1}}],[\"得到一个method对象\",{\"1\":{\"192\":1}}],[\"得到的类名称很奇怪class\",{\"1\":{\"570\":1}}],[\"得到的会是同一个对象\",{\"1\":{\"227\":1}}],[\"得到的是包名+类名的完整名称\",{\"1\":{\"184\":1}}],[\"得到的\",{\"1\":{\"84\":1,\"369\":1}}],[\"得到结果是一样的\",{\"1\":{\"579\":1}}],[\"得到结果\",{\"1\":{\"71\":1,\"496\":1}}],[\"得到前面处理的结果\",{\"1\":{\"71\":1}}],[\"得益于泛型的类型擦除机制\",{\"1\":{\"80\":1}}],[\"得益于\",{\"1\":{\"36\":1}}],[\"最低日志级别\",{\"1\":{\"638\":1}}],[\"最低优先级\",{\"1\":{\"145\":1}}],[\"最高日志级别\",{\"1\":{\"638\":1}}],[\"最高优先级\",{\"1\":{\"145\":1}}],[\"最近最少使用\",{\"1\":{\"612\":1}}],[\"最近的是参数\",{\"1\":{\"251\":1}}],[\"最优的策略\",{\"1\":{\"433\":1}}],[\"最优策略\",{\"0\":{\"342\":1}}],[\"最优策略是\",{\"1\":{\"338\":1}}],[\"最优策略是否唯一\",{\"1\":{\"338\":1}}],[\"最优策略是否存在\",{\"1\":{\"338\":1}}],[\"最优策略的定义\",{\"1\":{\"338\":1}}],[\"最接近真实的vπ​\",{\"1\":{\"417\":1}}],[\"最简单的示例算法\",{\"1\":{\"361\":1}}],[\"最好的\",{\"0\":{\"312\":1}}],[\"最好是一个域名的格式\",{\"1\":{\"120\":1}}],[\"最终的结果依然是被赋值为数据库中的结果\",{\"1\":{\"569\":1}}],[\"最终只需要将resulttype改为resultmap并指定对应id即可\",{\"1\":{\"563\":1}}],[\"最终会达到一个平稳的状态\",{\"1\":{\"420\":1}}],[\"最终优化的策略\",{\"1\":{\"406\":1}}],[\"最终可以证明\",{\"1\":{\"332\":1}}],[\"最终输出结果\",{\"1\":{\"298\":1}}],[\"最终输出的结果\",{\"1\":{\"298\":1}}],[\"最终到\",{\"1\":{\"267\":1}}],[\"最终操作\",{\"1\":{\"71\":1}}],[\"最少匹配\",{\"1\":{\"246\":1}}],[\"最方便的是\",{\"1\":{\"127\":1}}],[\"最小\",{\"0\":{\"76\":1}}],[\"最大的\",{\"1\":{\"362\":1,\"364\":1}}],[\"最大的q\",{\"1\":{\"298\":1}}],[\"最大的不同是它支持基本数据类型的直接读取\",{\"1\":{\"129\":1}}],[\"最大\",{\"0\":{\"76\":1}}],[\"最后在构造sqlsessionfactory时也可以通过此对象进行创建\",{\"1\":{\"632\":1}}],[\"最后在程序中使用我们定义好的mapper即可\",{\"1\":{\"554\":1}}],[\"最后我们就可以得到一个日志文件了\",{\"1\":{\"648\":1}}],[\"最后我们来看一下二级缓存相关的配置\",{\"1\":{\"631\":1}}],[\"最后我们查询到结果后\",{\"1\":{\"559\":1}}],[\"最后实际执行的sql为\",{\"1\":{\"604\":1}}],[\"最后实际上只有一个成功插入了\",{\"1\":{\"48\":1}}],[\"最后再由mybatis将其结果合并\",{\"1\":{\"579\":1}}],[\"最后再提一下\",{\"1\":{\"266\":1}}],[\"最后还有一个普通的select方法\",{\"1\":{\"564\":1}}],[\"最后一个参数为我们希望作为key的属性\",{\"1\":{\"564\":1}}],[\"最后\",{\"1\":{\"539\":1}}],[\"最后需要\",{\"1\":{\"448\":1}}],[\"最后面分号可以不打\",{\"1\":{\"221\":1}}],[\"最后也得不到我们想要的结果\",{\"1\":{\"155\":1}}],[\"最后由mybatis来对查询的结果进行处理即可\",{\"1\":{\"578\":1}}],[\"最后由\",{\"1\":{\"71\":1}}],[\"最后哈希表就长这样了\",{\"1\":{\"58\":1}}],[\"最后得到的结果并不是我们插入顺序\",{\"1\":{\"50\":1}}],[\"排序查询\",{\"0\":{\"492\":1}}],[\"排序\",{\"1\":{\"71\":1}}],[\"流的内容是有限的\",{\"1\":{\"91\":1}}],[\"流在管道中传输\",{\"1\":{\"71\":1}}],[\"流stream\",{\"1\":{\"71\":1}}],[\"简单来说\",{\"1\":{\"600\":1}}],[\"简单说它就是java与数据库的连接的桥梁或者插件\",{\"1\":{\"515\":1}}],[\"简单理解为\",{\"1\":{\"180\":1}}],[\"简称sql\",{\"1\":{\"472\":1}}],[\"简而言之\",{\"1\":{\"179\":1,\"460\":1,\"463\":1}}],[\"简洁的代码\",{\"1\":{\"71\":1}}],[\"简介\",{\"0\":{\"31\":1,\"460\":1}}],[\"干净\",{\"1\":{\"71\":1}}],[\"语句时\",{\"1\":{\"612\":1}}],[\"语句有多痛苦\",{\"1\":{\"600\":1}}],[\"语句\",{\"0\":{\"472\":1},\"1\":{\"472\":1}}],[\"语句块进行异常的捕获\",{\"1\":{\"267\":1}}],[\"语句块来处理\",{\"1\":{\"267\":1}}],[\"语句从数据库查询数据的直观方式来提供一种对\",{\"1\":{\"71\":1}}],[\"语法与java比较相似\",{\"1\":{\"601\":1}}],[\"语法树会被分析并转化成类文件\",{\"1\":{\"539\":1}}],[\"语法\",{\"1\":{\"30\":1,\"36\":1}}],[\"利用动态\",{\"1\":{\"600\":1}}],[\"利用反射之后\",{\"1\":{\"192\":1}}],[\"利用了\",{\"1\":{\"67\":1}}],[\"利用这种特性\",{\"1\":{\"44\":1}}],[\"才不会重新读取\",{\"1\":{\"612\":1}}],[\"才进行更新\",{\"1\":{\"367\":1}}],[\"才进行替换\",{\"1\":{\"66\":1}}],[\"才能进行\",{\"1\":{\"367\":1}}],[\"才能进行比较\",{\"1\":{\"216\":1}}],[\"才能去\",{\"1\":{\"251\":1}}],[\"才能用这三个方法\",{\"1\":{\"161\":1}}],[\"才会请求数据库\",{\"1\":{\"613\":1}}],[\"才会从一级缓存中获取\",{\"1\":{\"613\":1}}],[\"才会保存在二级缓存\",{\"1\":{\"612\":1}}],[\"才会初始化外部类\",{\"1\":{\"254\":1}}],[\"才会让appclassloader来加载\",{\"1\":{\"198\":1}}],[\"才会转换\",{\"1\":{\"161\":1}}],[\"才会依次进行\",{\"1\":{\"71\":1}}],[\"才正确\",{\"1\":{\"155\":1}}],[\"才认为这两个元素是相同的\",{\"1\":{\"84\":1}}],[\"才是灵魂\",{\"1\":{\"67\":1}}],[\"你干嘛\",{\"1\":{\"657\":3}}],[\"你应该能理解根据不同条件拼接\",{\"1\":{\"600\":1}}],[\"你也可以认为这就是之前jdbc中的statement对象\",{\"1\":{\"553\":1}}],[\"你看\",{\"1\":{\"245\":2}}],[\"你会发现它更像一个sql语句\",{\"1\":{\"71\":1}}],[\"你会发现所有的方法全是替身攻击\",{\"1\":{\"67\":1}}],[\"你只需要坐着等别人写好然后你自己拿去交差就行了\",{\"1\":{\"67\":1}}],[\"你没看错\",{\"1\":{\"67\":1}}],[\"玛卡\",{\"1\":{\"66\":1}}],[\"巴卡\",{\"1\":{\"66\":1}}],[\"计算\",{\"1\":{\"395\":1}}],[\"计算机网络\",{\"1\":{\"281\":2}}],[\"计算10\",{\"1\":{\"229\":1}}],[\"计算的话也只能通过\",{\"1\":{\"229\":1}}],[\"计算规则为\",{\"1\":{\"71\":1}}],[\"计算并将键值对放入map中\",{\"1\":{\"64\":1}}],[\"计算当前整个集合对象的哈希值\",{\"1\":{\"23\":1}}],[\"存在潜在问题的消息级别\",{\"1\":{\"638\":1}}],[\"存在一级缓存\",{\"1\":{\"610\":1}}],[\"存在不动点x∗\",{\"1\":{\"343\":1}}],[\"存在\",{\"1\":{\"338\":1}}],[\"存在lemma1\",{\"1\":{\"294\":1}}],[\"存在时存在则计算并赋予新的值\",{\"1\":{\"64\":1}}],[\"存放参数\",{\"1\":{\"527\":1}}],[\"存放在元空间中\",{\"1\":{\"180\":1}}],[\"存放数据的底层数组\",{\"1\":{\"25\":1}}],[\"存储过程以及高级映射\",{\"1\":{\"544\":1}}],[\"存储过程\",{\"1\":{\"515\":1}}],[\"存储物品id\",{\"1\":{\"467\":5}}],[\"存储类型为我们要存放的变量类型\",{\"1\":{\"162\":1}}],[\"存储在主内存\",{\"1\":{\"154\":1}}],[\"存储本地读取字节数\",{\"1\":{\"94\":1}}],[\"若此字段被填入了构造方法作为参数\",{\"1\":{\"569\":1}}],[\"若此文件不存在\",{\"1\":{\"92\":1}}],[\"若视图定义中有嵌套查询\",{\"1\":{\"507\":1}}],[\"若视图定义中含有distinct短语\",{\"1\":{\"507\":1}}],[\"若视图定义中含有group\",{\"1\":{\"507\":1}}],[\"若视图的字段来自集函数\",{\"1\":{\"507\":1}}],[\"若视图的字段来自字段表达式或常数\",{\"1\":{\"507\":1}}],[\"若视图是由两个以上基本表导出的\",{\"1\":{\"507\":1}}],[\"若有一系列\",{\"1\":{\"360\":1}}],[\"若不存在则计算并插入新的值\",{\"1\":{\"64\":1}}],[\"若key不存在\",{\"1\":{\"64\":1}}],[\"若\",{\"1\":{\"64\":1}}],[\"具有\",{\"1\":{\"61\":1}}],[\"具体推导过程\",{\"1\":{\"440\":1}}],[\"具体解决如下\",{\"1\":{\"382\":1}}],[\"具体求解方法\",{\"1\":{\"364\":1}}],[\"具体算法\",{\"0\":{\"364\":1}}],[\"具体步骤\",{\"0\":{\"348\":1}}],[\"具体分两步\",{\"1\":{\"341\":1}}],[\"具体代码\",{\"1\":{\"298\":1}}],[\"具体表述如下\",{\"1\":{\"296\":1}}],[\"具体如下\",{\"1\":{\"295\":1,\"427\":1}}],[\"具体类型不同的泛型类变量\",{\"1\":{\"281\":1}}],[\"具体类型只能是我们指定的上界类型或是上界类型的子类\",{\"1\":{\"15\":1}}],[\"具体使用\",{\"1\":{\"281\":1}}],[\"具体实现克隆\",{\"1\":{\"220\":1}}],[\"具体的实现由\",{\"1\":{\"218\":1}}],[\"具体而言\",{\"1\":{\"5\":1}}],[\"原本java应该这样写\",{\"1\":{\"605\":1}}],[\"原本就有的\",{\"1\":{\"37\":3}}],[\"原子性\",{\"1\":{\"510\":1}}],[\"原因很多\",{\"1\":{\"60\":1}}],[\"阈值为负载因子乘以默认容量\",{\"1\":{\"60\":1}}],[\"出现严重故障的消息级别\",{\"1\":{\"638\":1}}],[\"出现重名时\",{\"1\":{\"7\":1}}],[\"出发的\",{\"1\":{\"367\":1,\"422\":1}}],[\"出发\",{\"1\":{\"363\":2,\"369\":1}}],[\"出来的时候\",{\"1\":{\"60\":1}}],[\"新建一个类\",{\"1\":{\"672\":1}}],[\"新建名为testmapper\",{\"1\":{\"554\":1}}],[\"新文件也要进行编译\",{\"1\":{\"539\":1}}],[\"新数据类型\",{\"1\":{\"479\":1}}],[\"新列名\",{\"1\":{\"479\":1}}],[\"新的内容会出现在new表中\",{\"1\":{\"509\":1}}],[\"新的内容会被插入到new表中\",{\"1\":{\"509\":1}}],[\"新的容量直接等于默认容量16\",{\"1\":{\"60\":1}}],[\"新的容量等于旧容量的2倍\",{\"1\":{\"60\":1}}],[\"新的阈值也提升到原来的两倍\",{\"1\":{\"60\":1}}],[\"新增操作\",{\"1\":{\"57\":1}}],[\"先子logger\",{\"1\":{\"657\":1}}],[\"先进先出\",{\"1\":{\"612\":1}}],[\"先根据当前策略计算出各个状态的\",{\"1\":{\"362\":1}}],[\"先实现未实现的方法\",{\"1\":{\"255\":1}}],[\"先转换为当前类型\",{\"1\":{\"216\":1}}],[\"先写好我们定义的类\",{\"1\":{\"199\":1}}],[\"先加载\",{\"1\":{\"180\":1}}],[\"先完成线程1的内容\",{\"1\":{\"148\":1}}],[\"先把下面这几个旧的东西保存一下\",{\"1\":{\"60\":1}}],[\"先初始化\",{\"1\":{\"59\":1}}],[\"此方法返回给我们一个resultset对象\",{\"1\":{\"519\":1}}],[\"此方法会直接终止此线程\",{\"1\":{\"142\":1}}],[\"此缓冲区大小为\",{\"1\":{\"449\":1}}],[\"此注解在编译时会被自动丢弃\",{\"1\":{\"203\":1}}],[\"此外也可以用\",{\"1\":{\"582\":1}}],[\"此外\",{\"1\":{\"186\":1}}],[\"此外在每次扩容时会调用\",{\"1\":{\"60\":1}}],[\"此文件是否存在\",{\"1\":{\"98\":1}}],[\"此时就可以使用properties文件\",{\"1\":{\"664\":1}}],[\"此时就是随机策略\",{\"1\":{\"372\":1}}],[\"此时日志文件中写入的内容就是简单的日志格式了\",{\"1\":{\"649\":1}}],[\"此时日志中可以看到mybatis在尽可能优化我们的sql操作\",{\"1\":{\"599\":1}}],[\"此时打印的列表中不存在任何handler对象\",{\"1\":{\"646\":1}}],[\"此时低于info的所有日志都是被屏蔽的\",{\"1\":{\"640\":1}}],[\"此时该如何像之前一样配置resultmap呢\",{\"1\":{\"626\":1}}],[\"此时该trajectory的return=0+0+0+1+1+⋯=∞\",{\"1\":{\"304\":1}}],[\"此时动态sql就能很轻松实现这个操作\",{\"1\":{\"601\":1}}],[\"此时我们查询所有用户信息的时候\",{\"1\":{\"583\":1}}],[\"此时我们怎么去明确要使用的是哪一个\",{\"1\":{\"251\":1}}],[\"此时由于我们更新了数据库中的数据\",{\"1\":{\"611\":1}}],[\"此时由于数据被删除\",{\"1\":{\"593\":1}}],[\"此时由于出现了多行数据\",{\"1\":{\"581\":1}}],[\"此时由于类中存在多个构造方法\",{\"1\":{\"569\":1}}],[\"此时由于三个属性完全一致\",{\"1\":{\"216\":1}}],[\"此时可以分析每一个状态在这个策略下的概率\",{\"1\":{\"420\":1}}],[\"此时也可以是\",{\"1\":{\"409\":1}}],[\"此时\",{\"1\":{\"331\":1,\"362\":1,\"410\":1}}],[\"此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​\",{\"1\":{\"304\":1}}],[\"此时的mos模型定义如下\",{\"1\":{\"295\":1}}],[\"此时发生异常再往上抛出的话\",{\"1\":{\"267\":1}}],[\"此时这里创建出来的student对象\",{\"1\":{\"255\":1}}],[\"此时消费者在等待生产者往货架上生产产品\",{\"1\":{\"174\":1}}],[\"此时获取键为3的值\",{\"1\":{\"57\":1}}],[\"此时再调用next将不能再得到下一个元素\",{\"1\":{\"31\":1}}],[\"此时元素成功被移除\",{\"1\":{\"25\":1}}],[\"此时虽然使用的是通配符\",{\"1\":{\"15\":1}}],[\"此时this\",{\"1\":{\"9\":1}}],[\"此时变量没有引用任何对象\",{\"1\":{\"4\":1}}],[\"键的名称我们也可以分为多级进行配置\",{\"1\":{\"664\":1}}],[\"键值对size计数自增\",{\"1\":{\"59\":1}}],[\"键也相同\",{\"1\":{\"59\":1}}],[\"达到了阈值\",{\"1\":{\"59\":1}}],[\"普通的信息\",{\"1\":{\"639\":1}}],[\"普通的\",{\"1\":{\"544\":1}}],[\"普通的类也可以\",{\"1\":{\"255\":1}}],[\"普通的list只需要一个方法就可以直接转换到方便好用的intstream了\",{\"1\":{\"71\":1}}],[\"普通链表就直接在链表尾部插入\",{\"1\":{\"59\":1}}],[\"普通队列中从队尾入队\",{\"1\":{\"44\":1}}],[\"说明这种情况下\",{\"1\":{\"254\":1}}],[\"说明这个链表已经升级为红黑树了\",{\"1\":{\"59\":1}}],[\"说明外部希望当前线程立即停止\",{\"1\":{\"144\":1}}],[\"说明已经存放了相同键的键值对了\",{\"1\":{\"59\":1}}],[\"后续可能是未知的\",{\"1\":{\"330\":1}}],[\"后续会根据情况扩容\",{\"1\":{\"59\":1}}],[\"后四个方向\",{\"1\":{\"299\":1}}],[\"后退\",{\"1\":{\"298\":1}}],[\"后\",{\"1\":{\"186\":1,\"333\":1,\"367\":2}}],[\"后处于等待的线程\",{\"1\":{\"161\":1}}],[\"后面加上花括号\",{\"1\":{\"255\":1}}],[\"后面在juc中我们还会讲到乐观锁\",{\"1\":{\"155\":1}}],[\"后面的表达式判断结果为\",{\"1\":{\"268\":1}}],[\"后面的\",{\"1\":{\"120\":1}}],[\"后面的元素就被挤到后面去了\",{\"1\":{\"24\":1}}],[\"后保存的读取内容是取readlimit和bufferedinputstream类的缓冲区大小两者中的最大值\",{\"1\":{\"108\":1}}],[\"哈希表的大小并不是一直不变的\",{\"1\":{\"58\":1}}],[\"哈希表可能会出现哈希冲突\",{\"1\":{\"58\":1}}],[\"哈希表\",{\"1\":{\"58\":1}}],[\"备胎\",{\"1\":{\"57\":1}}],[\"khtml\",{\"1\":{\"455\":1}}],[\"keep\",{\"1\":{\"455\":1}}],[\"keycolumn\",{\"1\":{\"625\":1}}],[\"keycolumn为数据库中自增的字段名称\",{\"1\":{\"590\":1}}],[\"keycolumn=\",{\"1\":{\"590\":1,\"625\":1}}],[\"keyproperty\",{\"1\":{\"625\":1}}],[\"keyproperty设置为user类中的需要获取自增结果的属性名\",{\"1\":{\"590\":1}}],[\"keyproperty=\",{\"1\":{\"590\":1,\"625\":1}}],[\"key为string类型\",{\"1\":{\"561\":1}}],[\"keyset\",{\"1\":{\"56\":1,\"67\":1}}],[\"key\",{\"1\":{\"56\":4,\"58\":1,\"59\":15,\"61\":2,\"64\":3,\"65\":1,\"67\":2,\"475\":4,\"476\":4}}],[\"k→0∑k=1∞​ak​=∞\",{\"1\":{\"383\":1}}],[\"k→∞\",{\"1\":{\"332\":1,\"343\":1,\"389\":1}}],[\"k−1\",{\"1\":{\"379\":1}}],[\"k=2\",{\"1\":{\"379\":1}}],[\"k=1∑n​rt+k​\",{\"1\":{\"439\":1}}],[\"k=1∑n​rt+k​∣st​=s0​\",{\"1\":{\"439\":1}}],[\"k=1\",{\"1\":{\"347\":1,\"379\":1,\"382\":1}}],[\"kth\",{\"1\":{\"364\":1}}],[\"kn​∩kn\",{\"1\":{\"293\":1,\"296\":1,\"298\":1}}],[\"kn​\",{\"1\":{\"293\":1,\"294\":2}}],[\"killed\",{\"1\":{\"167\":1}}],[\"k\",{\"1\":{\"56\":3,\"58\":1,\"59\":8,\"61\":1,\"64\":3,\"65\":2,\"382\":2}}],[\"体系下的接口\",{\"1\":{\"55\":1}}],[\"映射语句来加载期望的复杂类型\",{\"1\":{\"577\":1}}],[\"映射成数据库中的记录\",{\"1\":{\"544\":1}}],[\"映射指两个元素的之间相互\",{\"1\":{\"55\":1}}],[\"映射等数据结构\",{\"1\":{\"21\":1}}],[\"底层c++写的\",{\"1\":{\"235\":1}}],[\"底层是由c++实现的\",{\"1\":{\"215\":1}}],[\"底层是直接用\",{\"1\":{\"67\":1}}],[\"底层直接用\",{\"1\":{\"67\":1}}],[\"底层哈希表的长度永远是2的n次方\",{\"1\":{\"59\":1}}],[\"底层实现\",{\"0\":{\"58\":1,\"67\":1}}],[\"底层采用哈希表实现\",{\"1\":{\"57\":2}}],[\"底层维护的不再是一个\",{\"1\":{\"49\":1}}],[\"底层就是采用数组实现的\",{\"1\":{\"25\":1}}],[\"篇视频教程中学习大顶堆和小顶堆\",{\"1\":{\"46\":1}}],[\"按对象进入缓存的顺序来移除它们\",{\"1\":{\"612\":1}}],[\"按照官方文档给定的提示\",{\"1\":{\"552\":1}}],[\"按照所给定策略j来执行一个动作at​∈a从而获得奖励rt​以及下一个状态st+1​\",{\"1\":{\"298\":1}}],[\"按照从大到小顺序出队\",{\"1\":{\"46\":1}}],[\"按行读取\",{\"1\":{\"112\":1}}],[\"按顺序从前往后存放\",{\"1\":{\"24\":1}}],[\"栈相关操作已经帮助我们定义好了\",{\"1\":{\"44\":1}}],[\"队首出队\",{\"1\":{\"44\":1}}],[\"队列中继承下来的方法操作是一样的\",{\"1\":{\"44\":1}}],[\"队列的添加操作\",{\"1\":{\"43\":1}}],[\"队列\",{\"0\":{\"43\":1,\"45\":1},\"1\":{\"21\":1}}],[\"双端队列既可以当做普通队列使用\",{\"1\":{\"44\":1}}],[\"双端队列\",{\"0\":{\"44\":1}}],[\"仅用作估计\",{\"1\":{\"366\":1}}],[\"仅需要考虑无人机的7个移动方向即可\",{\"1\":{\"299\":1}}],[\"仅支持接口\",{\"1\":{\"257\":1}}],[\"仅仅是se中就有700多个\",{\"1\":{\"265\":1}}],[\"仅仅是检查\",{\"1\":{\"204\":1}}],[\"仅仅编译器阶段\",{\"1\":{\"204\":1}}],[\"仅使用默认类加载器\",{\"1\":{\"180\":1}}],[\"仅获取队首元素\",{\"1\":{\"43\":1}}],[\"仅适用于通配符\",{\"1\":{\"15\":1}}],[\"除非抛出的异常是一个运行时异常\",{\"1\":{\"267\":1}}],[\"除非我们手动重载一个无参构造\",{\"1\":{\"9\":1}}],[\"除了官方为我们提供的两种默认格式外\",{\"1\":{\"672\":1}}],[\"除了默认的rootlogger作为父类\",{\"1\":{\"658\":1}}],[\"除了if操作之外\",{\"1\":{\"602\":1}}],[\"除了使用批处理之外\",{\"1\":{\"600\":1}}],[\"除了需要求解\",{\"1\":{\"340\":1}}],[\"除了clone\",{\"1\":{\"236\":1}}],[\"除了linkedlist实现了队列接口之外\",{\"1\":{\"45\":1}}],[\"除了可以直接当做列表使用之外\",{\"1\":{\"42\":1}}],[\"和二级缓存\",{\"1\":{\"610\":1}}],[\"和jdbc其实都差不多\",{\"1\":{\"593\":1}}],[\"和jdbc依赖是一样的\",{\"1\":{\"539\":1}}],[\"和之前insert一样\",{\"1\":{\"591\":1}}],[\"和之前一样\",{\"1\":{\"589\":1}}],[\"和串行化\",{\"1\":{\"510\":1}}],[\"和动作\",{\"1\":{\"333\":1}}],[\"和e\",{\"1\":{\"327\":1}}],[\"和匿名内部类不同\",{\"1\":{\"257\":1}}],[\"和iterator一样\",{\"1\":{\"173\":1}}],[\"和reset\",{\"1\":{\"112\":1}}],[\"和\",{\"0\":{\"42\":1,\"161\":1},\"1\":{\"84\":2,\"88\":4,\"108\":1,\"126\":1,\"229\":1,\"245\":1,\"246\":1,\"285\":1,\"333\":1,\"367\":1,\"372\":1,\"386\":1,\"390\":1,\"407\":1,\"408\":1,\"427\":2,\"454\":1,\"467\":1,\"564\":1}}],[\"插入的其中任意一种操作\",{\"1\":{\"593\":1}}],[\"插入\",{\"0\":{\"589\":1}}],[\"插入数据\",{\"0\":{\"482\":1}}],[\"插入新的元素到当前待遍历元素之前\",{\"1\":{\"37\":1}}],[\"插入元素默认是插入到尾部\",{\"1\":{\"24\":1}}],[\"增\",{\"1\":{\"588\":1}}],[\"增量式的迭代算法\",{\"1\":{\"379\":1}}],[\"增加了更多方便的操作\",{\"1\":{\"37\":1}}],[\"增强\",{\"1\":{\"30\":1}}],[\"测试阶段\",{\"1\":{\"299\":1}}],[\"测试\",{\"1\":{\"36\":1,\"193\":1}}],[\"让mybatis对配置文件进行读取并得到一个sqlsessionfactory对象\",{\"1\":{\"552\":1}}],[\"让\",{\"1\":{\"389\":1}}],[\"让子类继续为一个泛型类\",{\"1\":{\"282\":1}}],[\"让程序继续运行下去\",{\"1\":{\"267\":1}}],[\"让程序员写出高效率\",{\"1\":{\"71\":1}}],[\"让类来使用这个接口\",{\"1\":{\"219\":1}}],[\"让我们的java程序更加生动形象\",{\"1\":{\"212\":1}}],[\"让我看看\",{\"1\":{\"117\":1}}],[\"让线程1加入\",{\"1\":{\"148\":1}}],[\"让线程自行处理后续\",{\"1\":{\"144\":1}}],[\"让位\",{\"1\":{\"147\":1}}],[\"让p等于e一会覆盖就行了\",{\"1\":{\"59\":1}}],[\"让其实现iterable接口\",{\"1\":{\"36\":1}}],[\"让当前对象的name变量值等于参数传入的值\",{\"1\":{\"7\":1}}],[\"介绍\",{\"0\":{\"36\":1,\"37\":1}}],[\"调整\",{\"0\":{\"622\":1}}],[\"调整为限制的大小\",{\"1\":{\"25\":1}}],[\"调用info来输出一个普通的信息\",{\"1\":{\"636\":1}}],[\"调用此操作将直接导致一级和二级缓存被清除\",{\"1\":{\"615\":1}}],[\"调用此方法时也会获取锁\",{\"1\":{\"155\":1}}],[\"调用此方法后\",{\"1\":{\"144\":1}}],[\"调用此方法来开始执行此线程\",{\"1\":{\"140\":1}}],[\"调用注解处理器\",{\"1\":{\"539\":1}}],[\"调用无参构造不会自动连接\",{\"1\":{\"449\":1}}],[\"调用无参构造方法不会自动连接\",{\"1\":{\"449\":1}}],[\"调用\",{\"1\":{\"258\":1}}],[\"调用clone方法\",{\"1\":{\"220\":1}}],[\"调用consumer的accept来对每一个元素进行消费\",{\"1\":{\"35\":1}}],[\"调用父类的实现\",{\"1\":{\"216\":1}}],[\"调用protected方法\",{\"1\":{\"199\":1}}],[\"调用类方法\",{\"0\":{\"192\":1}}],[\"调用类的静态方法\",{\"1\":{\"118\":1}}],[\"调用方法\",{\"1\":{\"191\":1}}],[\"调用t的interrupt方法\",{\"1\":{\"144\":1}}],[\"调用时的位置\",{\"1\":{\"108\":1}}],[\"调用resize进行扩容\",{\"1\":{\"59\":1}}],[\"调用的另一个方法进行映射关系存放\",{\"1\":{\"59\":1}}],[\"自增主键id\",{\"0\":{\"590\":1}}],[\"自行阅读官方文档\",{\"1\":{\"552\":1}}],[\"自身连接\",{\"1\":{\"496\":1}}],[\"自身连接查询\",{\"0\":{\"496\":1}}],[\"自身存在一个\",{\"1\":{\"35\":1}}],[\"自动生成的logger名称\",{\"1\":{\"678\":2}}],[\"自动构建一个继承关系\",{\"1\":{\"658\":1}}],[\"自动构建继承关系\",{\"0\":{\"658\":1}}],[\"自动起别名\",{\"1\":{\"560\":1}}],[\"自动装箱|拆箱机制\",{\"1\":{\"229\":1}}],[\"自动处理字符编码转换\",{\"1\":{\"88\":1}}],[\"自其他接口的\",{\"1\":{\"219\":1}}],[\"自定义例子\",{\"0\":{\"676\":1}}],[\"自定义日志格式\",{\"0\":{\"672\":1}}],[\"自定义级别设置\",{\"0\":{\"639\":1}}],[\"自定义运行时异常\",{\"1\":{\"265\":1}}],[\"自定义编译时异常\",{\"1\":{\"265\":1}}],[\"自定义异常\",{\"0\":{\"265\":1}}],[\"自定义的注解需要定义1个\",{\"1\":{\"206\":1}}],[\"自定义线程名称\",{\"1\":{\"140\":1}}],[\"自己编译的类加载到\",{\"0\":{\"199\":1}}],[\"自己定义的定时器\",{\"0\":{\"165\":1}}],[\"自己定义的类要序列化保存\",{\"1\":{\"131\":1}}],[\"自我介绍需要用到当前对象的名字和年龄\",{\"1\":{\"5\":1}}],[\"自我介绍只需要完成就行\",{\"1\":{\"5\":1}}],[\"表明它可以获取迭代器或是直接使用foreach来遍历\",{\"1\":{\"564\":1}}],[\"表\",{\"1\":{\"502\":2}}],[\"表2\",{\"1\":{\"495\":2}}],[\"表1\",{\"1\":{\"495\":2}}],[\"表名\",{\"1\":{\"478\":1,\"479\":1,\"480\":1,\"482\":3,\"483\":1,\"484\":2,\"490\":5,\"492\":2,\"493\":1,\"494\":4,\"496\":2,\"498\":2,\"508\":2,\"509\":1}}],[\"表级约束有四种\",{\"1\":{\"476\":1}}],[\"表级约束条件\",{\"0\":{\"476\":1},\"1\":{\"478\":1}}],[\"表的\",{\"1\":{\"475\":1}}],[\"表中的唯一非关键字段为数量\",{\"1\":{\"467\":1}}],[\"表示开启所有日志信息\",{\"1\":{\"640\":1}}],[\"表示直接关闭所有日志信息\",{\"1\":{\"640\":1}}],[\"表示生效的行数\",{\"1\":{\"589\":1}}],[\"表示这本书是谁借的\",{\"1\":{\"581\":1}}],[\"表示这个类具有克隆的功能\",{\"1\":{\"220\":1}}],[\"表示这个类是一个抽象类\",{\"1\":{\"218\":1}}],[\"表示这个类不能再被继承了\",{\"1\":{\"217\":1}}],[\"表示对应用户的详细信息\",{\"1\":{\"577\":1}}],[\"表示对于对应\",{\"1\":{\"369\":1}}],[\"表示对于每一个\",{\"1\":{\"369\":1}}],[\"表示我们的查询结果直接使用指定的构造方法来处理\",{\"1\":{\"569\":1}}],[\"表示我们无权去调用默认构造方法\",{\"1\":{\"191\":1}}],[\"表示将数据库结果映射为student类\",{\"1\":{\"554\":1}}],[\"表示添加一个select操作\",{\"1\":{\"554\":1}}],[\"表示执行后受影响的行数\",{\"1\":{\"519\":1}}],[\"表示针对每一行都会生效\",{\"1\":{\"509\":1}}],[\"表示匹配所有的ip地址\",{\"1\":{\"500\":1}}],[\"表示03开头\",{\"1\":{\"491\":1}}],[\"表示任意内容\",{\"1\":{\"491\":1}}],[\"表示如果此列作为其他表的约束或视图引用到此列时\",{\"1\":{\"479\":1}}],[\"表示是\",{\"1\":{\"420\":1}}],[\"表示是一种长时间的交互行为\",{\"1\":{\"420\":1}}],[\"表示是最佳部署位置\",{\"1\":{\"298\":1}}],[\"表示状态转移矩阵\",{\"1\":{\"331\":1}}],[\"表示为\",{\"1\":{\"325\":1,\"437\":3}}],[\"表示为rkn​​\",{\"1\":{\"294\":1}}],[\"表示在单步情况下\",{\"1\":{\"438\":1}}],[\"表示在策略π下\",{\"1\":{\"438\":1}}],[\"表示在一个\",{\"1\":{\"422\":1}}],[\"表示在各状态执行各动作的概率\",{\"1\":{\"305\":1}}],[\"表示在状态s下采取动作a\",{\"1\":{\"305\":2}}],[\"表示\",{\"1\":{\"295\":1,\"420\":1,\"427\":1,\"440\":1,\"475\":6}}],[\"表示round\",{\"1\":{\"295\":1}}],[\"表示无人机与用户之间的仰角\",{\"1\":{\"294\":1}}],[\"表示所有小写字母\",{\"1\":{\"246\":1}}],[\"表示一个函数\",{\"1\":{\"395\":1}}],[\"表示一个给定的策略\",{\"1\":{\"330\":1}}],[\"表示一个区间\",{\"1\":{\"246\":1}}],[\"表示一个键值对\",{\"1\":{\"56\":1}}],[\"表示abc这几个字符可以出现\",{\"1\":{\"246\":1}}],[\"表示当前数组长度\",{\"1\":{\"236\":1}}],[\"表示long的最大值\",{\"1\":{\"229\":1}}],[\"表示类支持接口代表的功能\",{\"1\":{\"219\":1}}],[\"表示类具有的属性\",{\"1\":{\"4\":1}}],[\"表示导入这个包中全部的类\",{\"1\":{\"120\":1}}],[\"表示integer这个类型\",{\"1\":{\"80\":1}}],[\"表达式的\",{\"1\":{\"35\":1}}],[\"用注解\",{\"1\":{\"571\":1}}],[\"用java代码就能操作数据库的增删改查\",{\"1\":{\"515\":1}}],[\"用的最多的\",{\"1\":{\"460\":1}}],[\"用的就是\",{\"1\":{\"67\":1}}],[\"用来描述所有状态的state\",{\"1\":{\"327\":1}}],[\"用户可以通过自己输入用户名和密码来登陆\",{\"1\":{\"532\":1}}],[\"用户\",{\"1\":{\"502\":2}}],[\"用户授权\",{\"0\":{\"502\":1}}],[\"用户名\",{\"1\":{\"500\":2,\"501\":1,\"532\":1,\"533\":1,\"534\":4,\"552\":2}}],[\"用户的速度设为\",{\"1\":{\"299\":1}}],[\"用户漫游模型\",{\"1\":{\"299\":1}}],[\"用户区域划分算法\",{\"1\":{\"298\":1}}],[\"用户关联策略\",{\"1\":{\"298\":1}}],[\"用户是保持静态的\",{\"1\":{\"298\":1}}],[\"用户rkn​​在一段时间ts​内的mos总和为\",{\"1\":{\"295\":1}}],[\"用|隔开每种类型即可\",{\"1\":{\"267\":1}}],[\"用于配置动态sql\",{\"1\":{\"630\":1}}],[\"用于实现分页效果\",{\"1\":{\"563\":1}}],[\"用于定义列是否可以为空\",{\"1\":{\"475\":1}}],[\"用于定义列的值必须满足某些条件\",{\"1\":{\"475\":1}}],[\"用于为列指定默认值\",{\"1\":{\"475\":1}}],[\"用于建立和维护两表之间的关系\",{\"1\":{\"475\":1}}],[\"用于区别于其他实体数据的唯一标记\",{\"1\":{\"462\":1}}],[\"用于存放用户借阅的图书\",{\"1\":{\"581\":1}}],[\"用于存放教师与学生的授课信息\",{\"1\":{\"462\":1}}],[\"用于存放所有教师的数据\",{\"1\":{\"462\":1}}],[\"用于存放所有学生的数据\",{\"1\":{\"462\":1}}],[\"用于唯一区分不同实体的的属性\",{\"1\":{\"461\":1}}],[\"用于解释\",{\"1\":{\"361\":1}}],[\"用于便捷操作数组\",{\"1\":{\"275\":1}}],[\"用于规定给定组件必须要出现多少次才能满足匹配的\",{\"1\":{\"246\":1}}],[\"用于计算超大数字\",{\"1\":{\"229\":1}}],[\"用于表示此枚举的作用域\",{\"1\":{\"206\":1}}],[\"用于我们编写自定义的注解\",{\"1\":{\"205\":1}}],[\"用于写入基本数据类型\",{\"1\":{\"129\":1}}],[\"用于指定当前类所处的包的\",{\"1\":{\"120\":1}}],[\"用于简化这样的写法\",{\"1\":{\"90\":1}}],[\"用于记录数组的长\",{\"1\":{\"25\":1}}],[\"用了之后就不能用了\",{\"1\":{\"34\":1}}],[\"遍历打印数组中每一个元素\",{\"1\":{\"241\":1}}],[\"遍历方式也不同\",{\"1\":{\"33\":1}}],[\"遍历当前元素\",{\"1\":{\"32\":1}}],[\"向客户端发请求\",{\"1\":{\"448\":1}}],[\"向map中添加新的映射关系\",{\"1\":{\"56\":1}}],[\"向后继续寻找结点\",{\"1\":{\"33\":1}}],[\"向集合中添加元素\",{\"1\":{\"23\":1}}],[\"移动指针\",{\"1\":{\"33\":1}}],[\"移除最长时间不被使用的对象\",{\"1\":{\"612\":1}}],[\"移除\",{\"1\":{\"84\":1}}],[\"移除其映射关系\",{\"1\":{\"56\":1}}],[\"移除队首元素\",{\"1\":{\"43\":1}}],[\"移除上一个被遍历的元素\",{\"1\":{\"32\":1}}],[\"移除指定位置上的元素\",{\"1\":{\"24\":1}}],[\"移除给定集合中出现的所有元素\",{\"1\":{\"23\":1}}],[\"移除成功返回true\",{\"1\":{\"23\":3}}],[\"实体类字段名称与数据库不同\",{\"0\":{\"626\":1}}],[\"实体类中定义的属性名称和我们数据库中的名称不一样\",{\"1\":{\"563\":1}}],[\"实体属性为实体类\",{\"1\":{\"581\":1}}],[\"实体属性为列表\",{\"1\":{\"581\":1}}],[\"实体或是属性之间可以具有一定的联系\",{\"1\":{\"461\":1}}],[\"实现多服务器缓存共用才是最终解决方案\",{\"1\":{\"616\":1}}],[\"实现批量处理\",{\"0\":{\"603\":1}}],[\"实现登陆与sql注入攻击\",{\"0\":{\"532\":1}}],[\"实现接口时\",{\"1\":{\"219\":1}}],[\"实现接口\",{\"1\":{\"219\":1}}],[\"实现的\",{\"1\":{\"58\":1}}],[\"实现用例\",{\"0\":{\"33\":1}}],[\"实际运行好像是可以的\",{\"1\":{\"602\":1}}],[\"实际不常用\",{\"1\":{\"353\":1}}],[\"实际意义的解释\",{\"1\":{\"333\":1}}],[\"实际意义是\",{\"1\":{\"333\":1}}],[\"实际返回的\",{\"1\":{\"285\":1}}],[\"实际上jul也可以通过进行配置文件来规定日志打印器的一些默认值\",{\"1\":{\"667\":1}}],[\"实际上logger还会通过名称进行分级\",{\"1\":{\"658\":1}}],[\"实际上每一个handler都有一个formatter对象\",{\"1\":{\"649\":1}}],[\"实际上每个级别都有一个对应的方法用于打印\",{\"1\":{\"638\":1}}],[\"实际上我们的xml配置中所有配置项都可以以configuration对象的形式进行配置\",{\"1\":{\"632\":1}}],[\"实际上我们的集合类都是支持使用foreach语法\",{\"1\":{\"30\":1}}],[\"实际上我们也可以直接在\",{\"1\":{\"630\":1}}],[\"实际上mybatis一开始会通过我们实体类默认的无参构造得到一个最初的对象\",{\"1\":{\"569\":1}}],[\"实际上mybatis也是通过preparedstatement首先进行一次预编译\",{\"1\":{\"559\":1}}],[\"实际上main就是一个函数\",{\"1\":{\"5\":1}}],[\"实际上idea就是一个java程序\",{\"1\":{\"516\":1}}],[\"实际上书籍编号依赖于借阅编号\",{\"1\":{\"466\":1}}],[\"实际上会有一个缓冲区用于数据的发送和接收\",{\"1\":{\"449\":1}}],[\"实际上会直接使用默认的类型\",{\"1\":{\"16\":1}}],[\"实际上它就是一个tcp连接的建立过程\",{\"1\":{\"447\":1}}],[\"实际上正则表达式内容非常多\",{\"1\":{\"246\":1}}],[\"实际上实现接口更像是一个类的功能列表\",{\"1\":{\"219\":1}}],[\"实际上接口的目标就是将类所具有某些的行为抽象出来\",{\"1\":{\"219\":1}}],[\"实际上类最开始是由bootstarpclassloader进行加载\",{\"1\":{\"198\":1}}],[\"实际上类锁也是对象锁\",{\"1\":{\"155\":1}}],[\"实际上锁就是依附于对象存在的\",{\"1\":{\"161\":1}}],[\"实际上synchronized是一种悲观锁\",{\"1\":{\"155\":1}}],[\"实际上只执行了一次\",{\"1\":{\"154\":1}}],[\"实际上只要是实现了迭代器接口的类\",{\"1\":{\"36\":1}}],[\"实际上一个java程序启动后\",{\"1\":{\"138\":1}}],[\"实际上这种操作完全可以浓缩为一个sql语句\",{\"1\":{\"605\":1}}],[\"实际上这种模式是父类filterinputstream提供的规范\",{\"1\":{\"107\":1}}],[\"实际上这里跟我们之前的一对一非常类似\",{\"1\":{\"583\":1}}],[\"实际上这里面就是方法体\",{\"1\":{\"257\":1}}],[\"实际上这些内容都是http协议规定的请求头内容\",{\"1\":{\"455\":1}}],[\"实际上这是classloader的双亲委派机制在保护java程序的正常运行\",{\"1\":{\"198\":1}}],[\"实际上这个表就是一个存放头结点的数组+若干结点\",{\"1\":{\"58\":1}}],[\"实际上进行i\",{\"1\":{\"107\":1}}],[\"实际上在jul的这类内部也有着对应的配置处理操作\",{\"1\":{\"667\":1}}],[\"实际上在java中并不是真的有泛型类型\",{\"1\":{\"16\":1}}],[\"实际上在上述的第二阶段\",{\"1\":{\"539\":1}}],[\"实际上在我们的开发中\",{\"1\":{\"80\":1}}],[\"实际上对应类型的集合类有可能会存放其他类型的值\",{\"1\":{\"80\":1}}],[\"实际上最后只要是object的实现类都可以保存到集合类中\",{\"1\":{\"80\":1}}],[\"实际上\",{\"1\":{\"71\":1,\"142\":1,\"154\":2,\"193\":1,\"461\":1,\"527\":1,\"613\":1,\"666\":1}}],[\"实际上用的就是我们的\",{\"1\":{\"67\":1}}],[\"实际上底层大致结构跟我们之前学习的差不多\",{\"1\":{\"58\":1}}],[\"实际上就是存放的映射关系\",{\"1\":{\"58\":1}}],[\"实际上就像这样\",{\"1\":{\"15\":1}}],[\"实际上编译之后会修改为\",{\"1\":{\"30\":1}}],[\"实际上泛型方法在很多工具类中也有\",{\"1\":{\"14\":1}}],[\"实际传入的参数是一个字符串类型的值\",{\"1\":{\"14\":1}}],[\"某些集合不支持这种操作\",{\"1\":{\"32\":1}}],[\"||\",{\"1\":{\"59\":4,\"84\":2}}],[\"|\",{\"0\":{\"76\":1,\"232\":2,\"406\":1},\"1\":{\"32\":2,\"111\":1,\"131\":1,\"133\":1,\"155\":1,\"161\":1,\"186\":1,\"267\":2,\"275\":3,\"527\":1,\"646\":2,\"679\":6}}],[\"源码定义\",{\"0\":{\"32\":1}}],[\"可见\",{\"1\":{\"599\":1,\"611\":1,\"646\":1}}],[\"可见性\",{\"1\":{\"121\":1}}],[\"可重复读\",{\"1\":{\"510\":1}}],[\"可知\",{\"1\":{\"294\":1}}],[\"可变\",{\"1\":{\"285\":1}}],[\"可变长参数\",{\"0\":{\"241\":1}}],[\"可是消费者消费的产品是生产者生产的\",{\"1\":{\"174\":1}}],[\"可拆分迭代器\",{\"1\":{\"173\":1}}],[\"可运行\",{\"1\":{\"143\":1}}],[\"可写可不写\",{\"1\":{\"120\":1}}],[\"可能还是得我们自己编写一个自定义的formatter才行\",{\"1\":{\"679\":1}}],[\"可能有很多个名字为test的标签\",{\"1\":{\"547\":1}}],[\"可能高等数学这门课是以数字成绩进行结算\",{\"1\":{\"280\":1}}],[\"可能会一个一个地提交\",{\"1\":{\"599\":1}}],[\"可能会同时拿到同样的值\",{\"1\":{\"154\":1}}],[\"可能会创建各种各样的类\",{\"1\":{\"120\":1}}],[\"可能会出现一些莫名其妙的红标\",{\"1\":{\"630\":1}}],[\"可能会出现各自的缓存内容不同步的问题\",{\"1\":{\"616\":1}}],[\"可能会出现无法预知的错误\",{\"1\":{\"192\":1}}],[\"可能会出现\",{\"1\":{\"90\":1}}],[\"可能会是乱序的\",{\"1\":{\"57\":1}}],[\"可能是链式存储\",{\"1\":{\"31\":1}}],[\"可以实现批量操作\",{\"1\":{\"603\":1}}],[\"可以彻底摆脱这种痛苦\",{\"1\":{\"600\":1}}],[\"可以将查询结果以一个map的形式表示\",{\"1\":{\"564\":1}}],[\"可以将复制一个完全一样的对象出来\",{\"1\":{\"215\":1}}],[\"可以嵌套但不能交叉嵌套\",{\"1\":{\"545\":1}}],[\"可以但不必须包含一个头部声明\",{\"1\":{\"545\":1}}],[\"可以自由更换\",{\"1\":{\"540\":1}}],[\"可以不用一次一次地提交\",{\"1\":{\"526\":1}}],[\"可以理解在标题栏\",{\"1\":{\"525\":1}}],[\"可以理解为\",{\"1\":{\"219\":1}}],[\"可以用接口来简化\",{\"1\":{\"570\":1}}],[\"可以用java来写不同类型的可执行文件\",{\"1\":{\"515\":1}}],[\"可以用来衡量一个状态的价值\",{\"1\":{\"325\":1}}],[\"可以用来检查一个串是否含有某种子串\",{\"1\":{\"246\":1}}],[\"可以叠着使用\",{\"1\":{\"497\":1}}],[\"可以存储任意字符串\",{\"1\":{\"474\":1}}],[\"可以根据对各个状态的重要程度进行选择\",{\"1\":{\"437\":1}}],[\"可以最大化一个确定的常数指标\",{\"1\":{\"433\":1}}],[\"可以最开始均初始化为\",{\"1\":{\"332\":1}}],[\"可以描述为\",{\"1\":{\"433\":1}}],[\"可以写成\",{\"1\":{\"419\":1}}],[\"可以写入多个\",{\"1\":{\"94\":1}}],[\"可以提高存储效率\",{\"1\":{\"416\":1}}],[\"可以参考\",{\"1\":{\"389\":1}}],[\"可以平衡\",{\"1\":{\"372\":1}}],[\"可以拆分为多个\",{\"1\":{\"366\":1}}],[\"可以互相转化\",{\"1\":{\"333\":1}}],[\"可以得到一个cursor对象\",{\"1\":{\"564\":1}}],[\"可以得到一个序列v0​\",{\"1\":{\"332\":1}}],[\"可以得到一个非常规范的结果\",{\"1\":{\"25\":1}}],[\"可以求解\",{\"1\":{\"330\":1}}],[\"可以粗步衡量一个策略的好坏\",{\"1\":{\"304\":1}}],[\"可以忽略\",{\"1\":{\"295\":1}}],[\"可以表示为\",{\"1\":{\"294\":1,\"420\":1}}],[\"可以表示同样的一组元素\",{\"1\":{\"22\":1}}],[\"可以减轻无人机对用户接收到的干扰\",{\"1\":{\"294\":1}}],[\"可以使用简单的\",{\"1\":{\"544\":1}}],[\"可以使用\",{\"1\":{\"285\":1}}],[\"可以使用方括号\",{\"1\":{\"246\":1}}],[\"可以对\",{\"1\":{\"275\":1}}],[\"可以对列表中每个元素都进行处理\",{\"1\":{\"24\":1}}],[\"可以简写为\",{\"1\":{\"267\":1}}],[\"可以只跟\",{\"1\":{\"267\":1}}],[\"可以交给\",{\"1\":{\"267\":1}}],[\"可以有限\",{\"1\":{\"304\":1}}],[\"可以有多个方法\",{\"1\":{\"257\":1}}],[\"可以有其他方式判断类型\",{\"1\":{\"186\":1}}],[\"可以通过它来判断dml语句是否执行成功\",{\"1\":{\"519\":1}}],[\"可以通过连接对象来创建一个statement用于执行sql语句\",{\"1\":{\"518\":1}}],[\"可以通过\",{\"1\":{\"351\":1}}],[\"可以通过contraction\",{\"1\":{\"343\":1}}],[\"可以通过class对象来创建对象\",{\"1\":{\"191\":1}}],[\"可以通过设置将episodic\",{\"1\":{\"304\":1}}],[\"可以通过这个成员内部类又创建出更多对象\",{\"1\":{\"251\":1}}],[\"可以到\",{\"1\":{\"246\":1}}],[\"可以匹配\",{\"1\":{\"246\":1}}],[\"可以保存一个2字节的unicode字符\",{\"1\":{\"243\":1}}],[\"可以传入\",{\"1\":{\"241\":1}}],[\"可以是\",{\"1\":{\"440\":1}}],[\"可以是标量\",{\"1\":{\"386\":1}}],[\"可以是跑步\",{\"1\":{\"221\":1}}],[\"可以是相对路径\",{\"1\":{\"98\":1}}],[\"可以获取到父类的class对象\",{\"1\":{\"186\":1}}],[\"可以给他传一个时间参数进去的\",{\"1\":{\"161\":1}}],[\"可以判断线程是否存在中断标志\",{\"1\":{\"144\":1}}],[\"可以节省数据空间占用以及减少序列化时间\",{\"1\":{\"133\":1}}],[\"可以返回之前标记过的位置\",{\"1\":{\"108\":1}}],[\"可以返回一个备选的返回值\",{\"1\":{\"57\":1}}],[\"可以更好地管理和操作硬盘上的文件\",{\"1\":{\"98\":1}}],[\"可以直接通过\",{\"1\":{\"275\":1}}],[\"可以直接使用其名称\",{\"1\":{\"559\":1}}],[\"可以直接使用\",{\"1\":{\"285\":1}}],[\"可以直接使用一个\",{\"1\":{\"280\":1}}],[\"可以直接使用一个while循环来完成\",{\"1\":{\"91\":1}}],[\"可以直接使用lambda表达式\",{\"1\":{\"258\":1}}],[\"可以直接省去花括号和return关键字\",{\"1\":{\"257\":1}}],[\"可以直接写入一个字符串\",{\"1\":{\"113\":1}}],[\"可以直接写入内容\",{\"1\":{\"92\":1}}],[\"可以直接将file作为参数传入字节流或是字符流\",{\"1\":{\"98\":1}}],[\"可以跳过指定数量的字节\",{\"1\":{\"91\":1}}],[\"可以一次直接读取全部数据\",{\"1\":{\"91\":1}}],[\"可以极大提高java程序员的生产力\",{\"1\":{\"71\":1}}],[\"可以让你以一种声明的方式处理数据\",{\"1\":{\"71\":1}}],[\"可以在这里进行下载\",{\"1\":{\"539\":1}}],[\"可以在方法中定义\",{\"1\":{\"253\":1}}],[\"可以在\",{\"1\":{\"46\":1}}],[\"可以看到这里一共执行了两次sql语句\",{\"1\":{\"580\":1}}],[\"可以看到这个map中确实使用的是id作为key\",{\"1\":{\"564\":1}}],[\"可以看到mybatis确实调用了我们的无参构造方法来构建对象\",{\"1\":{\"569\":1}}],[\"可以看到它本身是实现了iterable接口的\",{\"1\":{\"564\":1}}],[\"可以看到它不仅仅实现了list接口\",{\"1\":{\"42\":1}}],[\"可以看到system\",{\"1\":{\"127\":1}}],[\"可以看到跟我们之前的写法是一样的\",{\"1\":{\"58\":1}}],[\"可以看到\",{\"1\":{\"15\":1,\"24\":1,\"25\":2,\"46\":1,\"48\":1,\"58\":1,\"242\":1,\"588\":1,\"611\":1}}],[\"可以相同\",{\"1\":{\"8\":1}}],[\"直到客户端主动关闭连接\",{\"1\":{\"447\":1}}],[\"直到有客户端连接为止\",{\"1\":{\"447\":1,\"448\":1}}],[\"直到设置的收敛条件为止\",{\"1\":{\"351\":1}}],[\"直到各个簇的成员没有太大变化\",{\"1\":{\"298\":1}}],[\"直到对应的线程执行resume\",{\"1\":{\"156\":1}}],[\"直到读取完成为止\",{\"1\":{\"94\":1}}],[\"直到完成每一个元素的遍历\",{\"1\":{\"31\":1}}],[\"直接把consolehandler的默认formatter配置为我们自己的类\",{\"1\":{\"675\":1}}],[\"直接填写字符串即可\",{\"1\":{\"636\":1}}],[\"直接清除所有缓存\",{\"1\":{\"615\":1}}],[\"直接得到用户所属的所有书籍信息\",{\"1\":{\"581\":1}}],[\"直接获取实现类\",{\"1\":{\"570\":1}}],[\"直接读取实体类\",{\"0\":{\"554\":1}}],[\"直接读取到char\",{\"1\":{\"96\":1}}],[\"直接运行会产生报错\",{\"1\":{\"552\":1}}],[\"直接运行即可\",{\"1\":{\"552\":1}}],[\"直接这样查询会得到两张表的笛卡尔积\",{\"1\":{\"495\":1}}],[\"直接估计的是\",{\"1\":{\"405\":1}}],[\"直接通过\",{\"1\":{\"379\":1}}],[\"直接\",{\"1\":{\"367\":1}}],[\"直接作为接口中抽象方法的实现\",{\"1\":{\"258\":2}}],[\"直接指定值和大小\",{\"1\":{\"235\":1}}],[\"直接写每个状态的名字即可\",{\"1\":{\"221\":1}}],[\"直接判断引用的对象是不是teacher类型\",{\"1\":{\"219\":1}}],[\"直接判断是否为test\",{\"1\":{\"208\":2}}],[\"直接判断是否为这个类型\",{\"1\":{\"186\":1}}],[\"直接int\",{\"1\":{\"219\":1}}],[\"直接==\",{\"1\":{\"216\":1}}],[\"直接编写逻辑\",{\"1\":{\"140\":1}}],[\"直接使用lombok\",{\"1\":{\"554\":1}}],[\"直接使用integer为我们通过好的求和方法\",{\"1\":{\"258\":1}}],[\"直接使用就可以\",{\"1\":{\"121\":1}}],[\"直接使用即可\",{\"1\":{\"120\":1}}],[\"直接做参数\",{\"1\":{\"98\":1}}],[\"直接在mapper中添加\",{\"1\":{\"563\":1}}],[\"直接在方法中创建局部内部类\",{\"1\":{\"253\":1}}],[\"直接在try\",{\"1\":{\"90\":1}}],[\"直接在类中定义变量\",{\"1\":{\"4\":1}}],[\"直接处理原始字节数据\",{\"1\":{\"88\":1}}],[\"直接构造一个默认大小为16负载因子0\",{\"1\":{\"67\":1}}],[\"直接替换为新的\",{\"1\":{\"66\":1}}],[\"直接给予一个比较规则即可\",{\"1\":{\"62\":1}}],[\"直接将字符串的666\",{\"1\":{\"228\":1}}],[\"直接将数据读取为任意基本数据类型\",{\"1\":{\"129\":1}}],[\"直接将新的容量变成旧的阈值\",{\"1\":{\"60\":1}}],[\"直接将对应位置上的元素替换为给定元素\",{\"1\":{\"24\":1}}],[\"直接结束\",{\"1\":{\"59\":2}}],[\"直接创建一个匿名的接口实现类\",{\"1\":{\"255\":1}}],[\"直接创建文件对象\",{\"1\":{\"98\":1}}],[\"直接创建新的结点连在后面\",{\"1\":{\"59\":1}}],[\"直接创建就行了\",{\"1\":{\"25\":1}}],[\"直接继承过来的方法\",{\"1\":{\"47\":1}}],[\"直接继承自前面介绍的\",{\"1\":{\"24\":1}}],[\"直接返回true\",{\"1\":{\"36\":1}}],[\"直接返回指针所指元素\",{\"1\":{\"33\":1}}],[\"直接认为就是要删除的对象\",{\"1\":{\"25\":1}}],[\"直接安排了\",{\"1\":{\"14\":1}}],[\"直接赋值\",{\"1\":{\"9\":1}}],[\"各个线程之间共享程序的内存空间\",{\"1\":{\"138\":1}}],[\"各项操作的结果也是一样的\",{\"1\":{\"25\":1}}],[\"各种属性都是默认值\",{\"1\":{\"9\":1}}],[\"还要注意去掉列表最后一个列名的逗号\",{\"1\":{\"600\":1}}],[\"还支持很多种类型的文件\",{\"1\":{\"545\":1}}],[\"还存在preparedstatement\",{\"1\":{\"518\":1}}],[\"还能在视图的基础上\",{\"1\":{\"507\":1}}],[\"还需要求解最优策略π\",{\"1\":{\"340\":1}}],[\"还需要考虑所有用户的2d位置\",{\"1\":{\"299\":1}}],[\"还需要判断\",{\"1\":{\"84\":1}}],[\"还与los的概率有关\",{\"1\":{\"298\":1}}],[\"还没学异常\",{\"1\":{\"220\":1}}],[\"还体会不到注解带来的快乐\",{\"1\":{\"208\":1}}],[\"还是以查询所有的用户为例\",{\"1\":{\"622\":1}}],[\"还是同一张q\",{\"1\":{\"298\":1}}],[\"还是\",{\"1\":{\"280\":1,\"338\":1,\"360\":1,\"377\":1}}],[\"还是字段\",{\"1\":{\"208\":1}}],[\"还是编入class文件中\",{\"1\":{\"205\":1}}],[\"还是进行计算\",{\"1\":{\"138\":1}}],[\"还是很方便的\",{\"1\":{\"43\":1}}],[\"还有数据库的额外开销\",{\"1\":{\"599\":1}}],[\"还有几个同名的\",{\"1\":{\"208\":1}}],[\"还有一个比较特殊的选择操作是selectcursor\",{\"1\":{\"564\":1}}],[\"还有一个append方法\",{\"1\":{\"97\":1}}],[\"还有一张用户详细信息的表\",{\"1\":{\"497\":1}}],[\"还有一种就是\",{\"1\":{\"280\":1}}],[\"还有一种set叫做treeset\",{\"1\":{\"50\":1}}],[\"还有其他的实现类\",{\"1\":{\"45\":1}}],[\"还可以通过alter来修改此列的属性\",{\"1\":{\"479\":1}}],[\"还可以估计q\",{\"1\":{\"366\":1}}],[\"还可以获取文件夹内部的文件列表等内容\",{\"1\":{\"98\":1}}],[\"还可以当做其他的数据结构使用\",{\"1\":{\"42\":1}}],[\"还可以定义一些方法来描述同一类的行为\",{\"1\":{\"5\":1}}],[\"还保存指向上一个结点的引用\",{\"1\":{\"25\":1}}],[\"异常错误信息\",{\"1\":{\"267\":1}}],[\"异常处理\",{\"1\":{\"267\":1}}],[\"异常的处理\",{\"0\":{\"267\":1}}],[\"异常的抛出同样需要创建一个异常对象出来\",{\"1\":{\"266\":1}}],[\"异常对象携带了我们抛出异常时的一些信息\",{\"1\":{\"266\":1}}],[\"异常其实就两大类\",{\"1\":{\"265\":1}}],[\"异常就是不同寻常\",{\"1\":{\"264\":1}}],[\"异常类型\",{\"0\":{\"264\":1}}],[\"异常机制\",{\"0\":{\"263\":1}}],[\"异常\",{\"0\":{\"261\":1},\"1\":{\"25\":1}}],[\"哟唉嘛干你\",{\"1\":{\"25\":2}}],[\"那有没有什么办法将文件的日志打印变成控制台那种格式呢\",{\"1\":{\"648\":1}}],[\"那这时又可以直接使用咱们的动态sql来完成操作了\",{\"1\":{\"605\":1}}],[\"那这接口怎么就出现了一个实现类呢\",{\"1\":{\"570\":1}}],[\"那如果我输入的是以下内容呢\",{\"1\":{\"532\":1}}],[\"那如果我们手动创建一个与jdk包名一样\",{\"1\":{\"198\":1}}],[\"那作用范围也就只能在方法中了\",{\"1\":{\"253\":1}}],[\"那肯定有人好奇\",{\"1\":{\"570\":1}}],[\"那肯定不相等\",{\"1\":{\"216\":1}}],[\"那肯定是没有的\",{\"1\":{\"57\":1}}],[\"那必须的\",{\"1\":{\"75\":1}}],[\"那就是参数了\",{\"1\":{\"251\":1}}],[\"那就执行覆盖操作\",{\"1\":{\"59\":1}}],[\"那就直接放一个新的结点\",{\"1\":{\"59\":1}}],[\"那要是我们就是想要使用维持顺序的set集合呢\",{\"1\":{\"49\":1}}],[\"那要是此时我们删除对象呢\",{\"1\":{\"25\":1}}],[\"那要是这样写呢\",{\"1\":{\"25\":1}}],[\"那么能否有一种简单一点的配置文件呢\",{\"1\":{\"664\":1}}],[\"那么能否实现在对象创建时就为其指定名字\",{\"1\":{\"9\":1}}],[\"那么子级的handler优先进行处理\",{\"1\":{\"657\":1}}],[\"那么同时也需要将父级的handler也进行日志等级配置\",{\"1\":{\"656\":1}}],[\"那么同样可以使用\",{\"1\":{\"216\":1}}],[\"那么你也可以单独在xml中配置一个resultmap\",{\"1\":{\"627\":1}}],[\"那么理想情况下\",{\"1\":{\"616\":1}}],[\"那么之前的缓存就全部失效了\",{\"1\":{\"611\":1}}],[\"那么之前缓存的内容也会跟着失效\",{\"1\":{\"611\":1}}],[\"那么如果我修改了数据库中的内容\",{\"1\":{\"611\":1}}],[\"那么如果内部类中也定义了同名的变量\",{\"1\":{\"251\":1}}],[\"那么必须同时要满足大于18岁这个条件\",{\"1\":{\"601\":1}}],[\"那么必须告知函数的调用方我们会抛出某个异常\",{\"1\":{\"266\":1}}],[\"那么调用commit方法则不会进行提交\",{\"1\":{\"593\":1}}],[\"那么多对一又该如何查询\",{\"1\":{\"583\":1}}],[\"那么mybatis会选择可用的构造方法来进行构造\",{\"1\":{\"569\":1}}],[\"那么传入的参数就是一个int类型的参数\",{\"1\":{\"559\":1}}],[\"那么所有类型的日志信息都不会被打印了\",{\"1\":{\"640\":1}}],[\"那么所有的操作都会丢失\",{\"1\":{\"534\":1}}],[\"那么所有在方法中可能会抛出的异常都需要注明\",{\"1\":{\"266\":1}}],[\"那么现在如果我们需要指定使用的构造方法怎么办呢\",{\"1\":{\"628\":1}}],[\"那么现在我们来看看\",{\"1\":{\"553\":1}}],[\"那么现在执行所有的操作如果在最后不进行commit\",{\"1\":{\"534\":1}}],[\"那么现在就可以将这些数据转换为一个类来进行操作\",{\"1\":{\"527\":1}}],[\"那么现在该如何去设计这样的一个\",{\"1\":{\"280\":1}}],[\"那么它本身就是一个虚表\",{\"1\":{\"507\":1}}],[\"那么它们的\",{\"1\":{\"84\":1}}],[\"那么被授权的用户还能将已获得的授权继续授权给其他用户\",{\"1\":{\"502\":1}}],[\"那么是否可以等到我们想要的时候再去连接\",{\"1\":{\"449\":1}}],[\"那么是不相等的\",{\"1\":{\"227\":1}}],[\"那么此时两个handler都会生效\",{\"1\":{\"657\":1}}],[\"那么此时就可以开启flushcache属性\",{\"1\":{\"615\":1}}],[\"那么此时就出现了歧义\",{\"1\":{\"120\":1}}],[\"那么此时的\",{\"1\":{\"420\":1}}],[\"那么只要求解\",{\"1\":{\"384\":1}}],[\"那么这个自增的主键值我们该如何获取到呢\",{\"1\":{\"590\":1}}],[\"那么这称为\",{\"1\":{\"369\":1}}],[\"那么这些类如果都放在一起的话\",{\"1\":{\"120\":1}}],[\"那么\",{\"1\":{\"353\":1,\"379\":1,\"383\":1,\"621\":1}}],[\"那么在使用时\",{\"1\":{\"281\":1}}],[\"那么由于类型不确定\",{\"1\":{\"281\":1}}],[\"那么泛型就变成对应的类型了\",{\"1\":{\"281\":1}}],[\"那么泛型到底是如何实现的呢\",{\"1\":{\"16\":1}}],[\"那么当发生这个异常时\",{\"1\":{\"267\":1}}],[\"那么使用时候\",{\"1\":{\"258\":1}}],[\"那么需要在前面添加外部类型名称\",{\"1\":{\"251\":1}}],[\"那么需要在前面添加外部类型名称test\",{\"1\":{\"251\":1}}],[\"那么需要重新生成一个迭代器对象\",{\"1\":{\"34\":1}}],[\"那么中间就需要产生4个字符串对象出来\",{\"1\":{\"245\":1}}],[\"那么始终都是同一个对象\",{\"1\":{\"244\":1}}],[\"那么始终都会得到同一个对象\",{\"1\":{\"227\":1}}],[\"那么可以省略列名\",{\"1\":{\"482\":1}}],[\"那么可以省去小括号\",{\"1\":{\"257\":1}}],[\"那么可以不用明确\",{\"1\":{\"282\":1}}],[\"那么可以直接明确对应类型\",{\"1\":{\"282\":1}}],[\"那么可以使用\",{\"1\":{\"281\":1}}],[\"那么可以使用this关键字\",{\"1\":{\"7\":1}}],[\"那么可变长参数只能放在最后\",{\"1\":{\"241\":1}}],[\"那么自动装箱的呢\",{\"1\":{\"227\":1}}],[\"那么实现类中不强制要求进行实现\",{\"1\":{\"219\":1}}],[\"那么实际上只是传递了对象的引用\",{\"1\":{\"4\":1}}],[\"那么还有什么意义呢\",{\"1\":{\"218\":1}}],[\"那么还需要将旧的数组中所有元素全部搬到新的里面去\",{\"1\":{\"60\":1}}],[\"那么无法重写\",{\"1\":{\"216\":1}}],[\"那么对应的xml配置编写为\",{\"1\":{\"569\":1}}],[\"那么对应的损失函数求解为\",{\"1\":{\"427\":1}}],[\"那么对应返回的就是确定的类型\",{\"1\":{\"186\":1}}],[\"那么对于随机变量x的估计可以为\",{\"1\":{\"360\":1}}],[\"那么对象构造好之后\",{\"1\":{\"9\":1}}],[\"那么对象的属性都会存在初始值\",{\"1\":{\"4\":1}}],[\"那么有可能两个线程同一时间都执行同一个方法\",{\"1\":{\"173\":1}}],[\"那么有没有下界呢\",{\"1\":{\"15\":1}}],[\"那么线程将一直处于挂起状态\",{\"1\":{\"156\":1}}],[\"那么我们之前的日志是怎么打印出来的呢\",{\"1\":{\"646\":1}}],[\"那么我们现在需要重写在mybatis的配置文件中进行mapper的配置\",{\"1\":{\"622\":1}}],[\"那么我们需要在xml中手动编写配置\",{\"1\":{\"569\":1}}],[\"那么我们原有的sql语句结构就遭到了破坏\",{\"1\":{\"532\":1}}],[\"那么我们原本的sql语句会变为\",{\"1\":{\"532\":1}}],[\"那么我们就可以直接从缓存中获取\",{\"1\":{\"610\":1}}],[\"那么我们就可以将学习这个能力\",{\"1\":{\"219\":1}}],[\"那么我们就可以将其重写了\",{\"1\":{\"216\":1}}],[\"那么我们就来尝试创建一个数据库\",{\"1\":{\"462\":1}}],[\"那么我们这边会发送一个ack探测包发到对方\",{\"1\":{\"449\":1}}],[\"那么我们能否创建数组类型的数组呢\",{\"1\":{\"240\":1}}],[\"那么我们也可以给枚举类型添加独有的成员方法\",{\"1\":{\"221\":1}}],[\"那么我们来看看\",{\"1\":{\"208\":2}}],[\"那么我们如何去检测死锁呢\",{\"1\":{\"156\":1}}],[\"那么我们可以对\",{\"1\":{\"363\":1}}],[\"那么我们可以继续踢皮球\",{\"1\":{\"267\":1}}],[\"那么我们可以将匿名内部类简写为lambda表达式\",{\"1\":{\"257\":1}}],[\"那么我们可以自己手动将class文件加载到jvm中吗\",{\"1\":{\"199\":1}}],[\"那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用\",{\"1\":{\"121\":1}}],[\"那么我们可以使用emptyxxx来快速生成一个只读的空集合\",{\"1\":{\"79\":1}}],[\"那么其他的对象读取的就是被改变的值\",{\"1\":{\"117\":1}}],[\"那么通过这个类创建的所有对象\",{\"1\":{\"117\":1}}],[\"那么fill操作不会生效\",{\"1\":{\"78\":1}}],[\"那么直接给到\",{\"1\":{\"60\":1}}],[\"那么直接扩容到最小的大小\",{\"1\":{\"25\":1}}],[\"那么就不拼接里面的内容到原本的sql中\",{\"1\":{\"601\":1}}],[\"那么就不能修改了\",{\"1\":{\"281\":1}}],[\"那么就会告诉我们找不到合适的构造方法\",{\"1\":{\"569\":1}}],[\"那么就会出现这种情况\",{\"1\":{\"80\":1}}],[\"那么就必须逐一进行修改\",{\"1\":{\"467\":1}}],[\"那么就需要在每个类都去编写获取logger的代码\",{\"1\":{\"677\":1}}],[\"那么就需要按照http协议的规则\",{\"1\":{\"455\":1}}],[\"那么就需要创造一个对象\",{\"1\":{\"251\":1}}],[\"那么就相当于到顶层了\",{\"1\":{\"267\":1}}],[\"那么就是b的\",{\"1\":{\"251\":1}}],[\"那么就是a的\",{\"1\":{\"251\":1}}],[\"那么就是不同的对象了\",{\"1\":{\"244\":1}}],[\"那么就像我们把成员变量访问权限变成私有一样\",{\"1\":{\"251\":1}}],[\"那么就可以像这样\",{\"1\":{\"65\":1}}],[\"那么就可以直接使用迭代器来完成\",{\"1\":{\"33\":1}}],[\"那么就进行扩容\",{\"1\":{\"60\":1}}],[\"那么就开始扩容\",{\"1\":{\"60\":1}}],[\"那么就转换为红黑树来存放\",{\"1\":{\"59\":1}}],[\"那么键就是integer类型的\",{\"1\":{\"56\":1}}],[\"那么会直接返回已经提前创建好的对象\",{\"1\":{\"227\":1}}],[\"那么会直接抛出类型转换异常\",{\"1\":{\"80\":1}}],[\"那么会覆盖掉之前的\",{\"1\":{\"57\":1}}],[\"那么会失败\",{\"1\":{\"47\":1}}],[\"那么会抛出异常\",{\"1\":{\"43\":2}}],[\"那么会从默认类型变成上界定义的类型\",{\"1\":{\"16\":1}}],[\"那么集合中就是相同的两个对象\",{\"1\":{\"25\":1}}],[\"那么忽略这个元素\",{\"1\":{\"23\":1}}],[\"那么编译之后\",{\"1\":{\"16\":1}}],[\"那么限定了上界后\",{\"1\":{\"15\":1}}],[\"那么既然泛型有上界\",{\"1\":{\"15\":1}}],[\"那么肯定应该排在前面\",{\"1\":{\"14\":1}}],[\"那么t就会自动变成\",{\"1\":{\"14\":1}}],[\"那么默认会认为这个变量是一个\",{\"1\":{\"281\":1}}],[\"那么默认情况下可以不使用this关键字来明确表示当前对象\",{\"1\":{\"7\":1}}],[\"那么默认是null\",{\"1\":{\"4\":1}}],[\"那么默认是统一为0\",{\"1\":{\"4\":1}}],[\"那么创建对象之后能否直接访问呢\",{\"1\":{\"4\":1}}],[\"时间等\",{\"1\":{\"676\":1}}],[\"时间\",{\"1\":{\"649\":1}}],[\"时mybatis就会自动调用类中对应的get方法来获取结果\",{\"1\":{\"589\":1}}],[\"时的平均reward\",{\"1\":{\"438\":1}}],[\"时wk​→w∗\",{\"1\":{\"389\":1}}],[\"时\",{\"1\":{\"25\":1,\"61\":1,\"215\":1,\"533\":1}}],[\"上午\",{\"1\":{\"647\":1,\"657\":2}}],[\"上行\",{\"1\":{\"298\":1}}],[\"上\",{\"1\":{\"217\":1}}],[\"上下文切换速度也高于进程\",{\"1\":{\"138\":1}}],[\"上头啊\",{\"1\":{\"25\":1}}],[\"上界number\",{\"1\":{\"16\":1}}],[\"上界\",{\"1\":{\"15\":1}}],[\"科技与狠活\",{\"1\":{\"25\":1}}],[\"<script>\",{\"1\":{\"630\":1}}],[\"<setting\",{\"1\":{\"580\":1,\"679\":2}}],[\"<settings>\",{\"1\":{\"580\":1}}],[\"<select\",{\"1\":{\"554\":1,\"559\":4,\"561\":1,\"562\":1,\"563\":1,\"564\":2,\"569\":1,\"570\":3,\"571\":1,\"577\":1,\"579\":2,\"582\":2,\"583\":3,\"601\":1,\"602\":1,\"614\":1,\"615\":1,\"623\":1,\"630\":1}}],[\"<sex>男<\",{\"1\":{\"545\":1}}],[\"<foreach\",{\"1\":{\"604\":1,\"605\":1}}],[\"<otherwise>\",{\"1\":{\"602\":1}}],[\"<outer>\",{\"1\":{\"545\":1}}],[\"<when\",{\"1\":{\"602\":2}}],[\"<cache\",{\"1\":{\"612\":2}}],[\"<choose>\",{\"1\":{\"602\":1}}],[\"<collection\",{\"1\":{\"581\":1,\"582\":1}}],[\"<constructor>\",{\"1\":{\"569\":2,\"628\":1}}],[\"<configuration>\",{\"1\":{\"552\":1}}],[\"<code>run<\",{\"1\":{\"139\":2}}],[\"<code>runnable<\",{\"1\":{\"139\":1}}],[\"<update\",{\"1\":{\"591\":1}}],[\"<association\",{\"1\":{\"578\":1,\"579\":1,\"583\":2}}],[\"<arg\",{\"1\":{\"569\":1,\"628\":2}}],[\"<age>10<\",{\"1\":{\"545\":1}}],[\"<if\",{\"1\":{\"601\":1,\"630\":2}}],[\"<insert\",{\"1\":{\"589\":1,\"590\":1,\"605\":1,\"625\":1}}],[\"<inner\",{\"1\":{\"545\":1}}],[\"<id\",{\"1\":{\"578\":2,\"579\":1,\"581\":2,\"582\":1,\"583\":3,\"626\":1}}],[\"<idarg\",{\"1\":{\"569\":1,\"628\":1}}],[\"<result\",{\"1\":{\"563\":2,\"578\":5,\"579\":2,\"581\":3,\"582\":2,\"583\":5,\"626\":1}}],[\"<resultmap\",{\"1\":{\"563\":1,\"569\":1,\"577\":1,\"578\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":2,\"626\":1}}],[\"<mappers>\",{\"1\":{\"554\":1,\"570\":1,\"622\":2}}],[\"<mapper\",{\"1\":{\"554\":2,\"570\":2,\"622\":1}}],[\"<package\",{\"1\":{\"560\":1,\"622\":1}}],[\"<property\",{\"1\":{\"552\":4}}],[\"<p>\",{\"1\":{\"139\":1}}],[\"<delete\",{\"1\":{\"592\":1,\"604\":1}}],[\"<desc>怎么又在玩电动啊<\",{\"1\":{\"545\":1}}],[\"<datasource\",{\"1\":{\"552\":1}}],[\"<environment\",{\"1\":{\"552\":1}}],[\"<environments\",{\"1\":{\"552\":1}}],[\"<name><\",{\"1\":{\"546\":1}}],[\"<name>阿伟<\",{\"1\":{\"545\":1}}],[\"<∞\",{\"1\":{\"383\":1}}],[\"<==向左的箭头就是得到的结果\",{\"1\":{\"580\":1}}],[\"<====\",{\"1\":{\"580\":3}}],[\"<==\",{\"1\":{\"580\":3}}],[\"<=\",{\"1\":{\"71\":1,\"227\":1,\"246\":1,\"491\":1,\"599\":1,\"604\":1}}],[\"<<\",{\"1\":{\"60\":2}}],[\"<\",{\"1\":{\"25\":2,\"60\":1,\"71\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"161\":1,\"172\":2,\"186\":3,\"237\":1,\"274\":1,\"491\":1,\"527\":1,\"545\":5,\"546\":2,\"547\":1,\"552\":7,\"554\":6,\"559\":4,\"560\":2,\"561\":1,\"562\":1,\"563\":3,\"564\":2,\"569\":4,\"570\":5,\"571\":1,\"577\":2,\"578\":2,\"579\":3,\"580\":1,\"581\":2,\"582\":3,\"583\":6,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"601\":2,\"602\":5,\"604\":2,\"605\":2,\"614\":1,\"615\":1,\"622\":2,\"623\":1,\"625\":1,\"626\":1,\"628\":1,\"630\":4}}],[\"<typealias\",{\"1\":{\"560\":1}}],[\"<typealiases>\",{\"1\":{\"560\":2}}],[\"<transactionmanager\",{\"1\":{\"552\":1}}],[\"<test>\",{\"1\":{\"546\":1}}],[\"<t\",{\"1\":{\"16\":1}}],[\"<t>\",{\"1\":{\"14\":2,\"16\":1,\"23\":1,\"47\":1,\"186\":1,\"527\":1}}],[\"扩容规则跟我们之前的是一样的\",{\"1\":{\"25\":1}}],[\"扩展了collection接口中一些额外的操作\",{\"1\":{\"24\":1}}],[\"扩展了大量列表支持的操作\",{\"1\":{\"24\":1}}],[\"mm\",{\"1\":{\"676\":2}}],[\"m2\",{\"1\":{\"611\":2}}],[\"m1\",{\"1\":{\"611\":3}}],[\"myformatter\",{\"1\":{\"672\":1,\"674\":1,\"675\":1}}],[\"mybatis就可以正确使用jdk的日志框架进行日志打印了\",{\"1\":{\"679\":1}}],[\"mybatis就会自动将对应的结果填入到对象的对应字段上\",{\"1\":{\"554\":1}}],[\"mybatis同样可以正常解析\",{\"1\":{\"630\":1}}],[\"mybatis针对于所有的sql操作都提供了对应的provider注解\",{\"1\":{\"630\":1}}],[\"mybatis在插入后\",{\"1\":{\"625\":1}}],[\"mybatis在执行完查询语句后\",{\"1\":{\"569\":1}}],[\"mybatis9\",{\"0\":{\"619\":1}}],[\"mybatis不知道我们修改了数据\",{\"1\":{\"616\":1}}],[\"mybatis确实存在着缓存机制来进行性能优化\",{\"1\":{\"611\":1}}],[\"mybatis的缓存机制有些复杂\",{\"1\":{\"610\":1}}],[\"mybatis为了查询效率\",{\"1\":{\"610\":1}}],[\"mybatis为我们提供了\",{\"1\":{\"628\":1}}],[\"mybatis为我们提供了丰富的注解用于表示不同sql语句类型\",{\"1\":{\"624\":1}}],[\"mybatis为我们提供了一些参数用于处理这种问题\",{\"1\":{\"590\":1}}],[\"mybatis为我们提供的插入操作非常快捷\",{\"1\":{\"589\":1}}],[\"mybatis为我们的dml操作提供了几个预设方法\",{\"1\":{\"588\":1}}],[\"mybatis8\",{\"0\":{\"608\":1}}],[\"mybatis还针对多分支情况提供了choose操作\",{\"1\":{\"602\":1}}],[\"mybatis还为我们提供了一种更好的方式来处理这种问题\",{\"1\":{\"600\":1}}],[\"mybatis7\",{\"0\":{\"596\":1}}],[\"mybatis6\",{\"0\":{\"586\":1}}],[\"mybatis日志中\",{\"1\":{\"580\":1}}],[\"mybatis日志\",{\"0\":{\"580\":1}}],[\"mybatis一般情况下可以自动完成推断\",{\"1\":{\"578\":1}}],[\"mybatis5\",{\"0\":{\"574\":1}}],[\"mybatis也有日志系统\",{\"1\":{\"679\":1}}],[\"mybatis也为我们提供了丰富的注解用于处理这类问题\",{\"1\":{\"629\":1}}],[\"mybatis也为我们提供了多种转换方案\",{\"1\":{\"561\":1}}],[\"mybatis也能完成自动推断\",{\"1\":{\"589\":1}}],[\"mybatis也不可能提前帮我们写了实现类啊\",{\"1\":{\"570\":1}}],[\"mybatis仅仅是使用这种方式进行对象的构建\",{\"1\":{\"569\":1}}],[\"mybatis会先从二级缓存中查找数据\",{\"1\":{\"613\":1}}],[\"mybatis会选择性拼接我们的sql语句\",{\"1\":{\"601\":1}}],[\"mybatis会从传入的对象中自动获取需要的参数\",{\"1\":{\"591\":1}}],[\"mybatis会在查询完后自动为我们的user对象赋值\",{\"1\":{\"590\":1}}],[\"mybatis会根据我们配置的属性自动将关联数据变为一个集合并存放在对象中\",{\"1\":{\"581\":1}}],[\"mybatis会并不能正确获取对应的参数\",{\"1\":{\"571\":1}}],[\"mybatis会出现问题\",{\"1\":{\"569\":1}}],[\"mybatis会自动判断\",{\"1\":{\"559\":1}}],[\"mybatis详解7\",{\"0\":{\"620\":1}}],[\"mybatis详解6\",{\"0\":{\"609\":1}}],[\"mybatis详解5\",{\"0\":{\"597\":1}}],[\"mybatis详解4\",{\"0\":{\"587\":1}}],[\"mybatis详解3\",{\"0\":{\"575\":1}}],[\"mybatis详解2\",{\"0\":{\"568\":1}}],[\"mybatis详解1\",{\"0\":{\"558\":1}}],[\"mybatis4\",{\"0\":{\"567\":1}}],[\"mybatis虽然可以查询到对应的记录\",{\"1\":{\"563\":1}}],[\"mybatisutils\",{\"1\":{\"593\":1,\"611\":2}}],[\"mybatisutil\",{\"1\":{\"558\":2,\"570\":1,\"612\":2}}],[\"mybatis3\",{\"0\":{\"557\":1}}],[\"mybatis非常智能\",{\"1\":{\"554\":1}}],[\"mybatis2\",{\"0\":{\"550\":1,\"551\":1}}],[\"mybatis\",{\"0\":{\"552\":1,\"694\":1},\"1\":{\"544\":3,\"552\":6,\"553\":1,\"554\":4,\"558\":1,\"577\":1,\"600\":1,\"630\":2},\"2\":{\"549\":1,\"556\":1,\"566\":1,\"573\":1,\"585\":1,\"595\":1,\"607\":1,\"618\":1,\"634\":1}}],[\"mybatis1\",{\"0\":{\"543\":1,\"544\":1}}],[\"mysql实现的驱动会被加载\",{\"1\":{\"517\":1}}],[\"mysql默认采用的是innodb引擎\",{\"1\":{\"510\":1}}],[\"mysql不支持\",{\"1\":{\"475\":1}}],[\"mysql就是一种关系型数据库\",{\"1\":{\"461\":1}}],[\"mysql\",{\"1\":{\"460\":1,\"516\":4,\"524\":1,\"533\":1,\"552\":1,\"580\":1,\"632\":2,\"664\":2},\"2\":{\"469\":1,\"486\":1,\"504\":1,\"512\":1,\"521\":1,\"529\":1,\"536\":1}}],[\"myclassloader\",{\"1\":{\"199\":3}}],[\"mbgd\",{\"0\":{\"391\":1}}],[\"mc\",{\"0\":{\"361\":1,\"365\":1,\"368\":1,\"370\":1,\"373\":1,\"399\":1},\"1\":{\"361\":1,\"365\":2,\"366\":1,\"367\":1,\"373\":2,\"386\":1,\"408\":1}}],[\"mdp就变为mp\",{\"1\":{\"305\":1}}],[\"mdp\",{\"0\":{\"305\":1}}],[\"mssrkn​​rtt​+1\",{\"1\":{\"295\":1}}],[\"mss\",{\"1\":{\"295\":1}}],[\"mozilla\",{\"1\":{\"455\":1}}],[\"mobile\",{\"1\":{\"455\":1}}],[\"mobility\",{\"1\":{\"299\":1}}],[\"monkey\",{\"1\":{\"524\":1}}],[\"monro\",{\"1\":{\"383\":2}}],[\"monto\",{\"0\":{\"380\":1}}],[\"monte\",{\"0\":{\"360\":1,\"422\":1},\"1\":{\"360\":1,\"441\":1}}],[\"moreover\",{\"1\":{\"343\":1}}],[\"mode\",{\"1\":{\"455\":1}}],[\"model|environment\",{\"1\":{\"330\":1}}],[\"model\",{\"0\":{\"295\":1,\"360\":1},\"1\":{\"299\":3,\"330\":2,\"361\":1,\"362\":2}}],[\"modles可选择\",{\"1\":{\"299\":1}}],[\"modifiers\",{\"1\":{\"193\":1}}],[\"modifiersfield\",{\"1\":{\"193\":3}}],[\"mos主要是有关传输速率rkn​​的函数\",{\"1\":{\"298\":1}}],[\"mosrkn​​​=t=0∑ts​​moskn​​\",{\"1\":{\"295\":1}}],[\"moskn​​\",{\"1\":{\"295\":3}}],[\"mos\",{\"1\":{\"290\":1}}],[\"movement\",{\"0\":{\"288\":1},\"1\":{\"289\":2}}],[\"multiple\",{\"0\":{\"288\":1},\"1\":{\"289\":1}}],[\"multiply\",{\"1\":{\"229\":1}}],[\"mutable\",{\"1\":{\"285\":1}}],[\"microsoft\",{\"1\":{\"460\":1}}],[\"millis\",{\"1\":{\"143\":1}}],[\"mini\",{\"1\":{\"427\":2}}],[\"minisize\",{\"1\":{\"421\":1}}],[\"minimize\",{\"1\":{\"389\":1}}],[\"min\",{\"1\":{\"76\":1,\"145\":2,\"274\":1,\"493\":1,\"640\":1}}],[\"mincapacity\",{\"1\":{\"25\":4}}],[\"memcache等缓存框架\",{\"1\":{\"616\":1}}],[\"memory\",{\"1\":{\"154\":1}}],[\"metaclass\",{\"1\":{\"569\":1}}],[\"metrics\",{\"1\":{\"433\":2}}],[\"methods\",{\"1\":{\"366\":1}}],[\"method和constructor都和class一样\",{\"1\":{\"192\":1}}],[\"method\",{\"1\":{\"139\":2,\"192\":15,\"199\":6,\"206\":2,\"207\":4,\"208\":1,\"366\":2,\"386\":3,\"441\":1,\"569\":2,\"630\":1}}],[\"means\",{\"1\":{\"377\":1}}],[\"means来划分各个无人机所管理的用户簇\",{\"1\":{\"298\":1}}],[\"means的优化目标是最小化无人机与对应集群用户的欧氏距离\",{\"1\":{\"298\":1}}],[\"means可以视为获得无人机部署的低复杂度方案\",{\"1\":{\"298\":1}}],[\"means算法\",{\"1\":{\"298\":1}}],[\"means和igk算法比具有较低的复杂度\",{\"1\":{\"290\":1}}],[\"mean算法获得初始单元划分\",{\"1\":{\"290\":1}}],[\"mean\",{\"0\":{\"328\":1,\"329\":1,\"384\":1,\"388\":1},\"1\":{\"290\":1,\"325\":1,\"326\":1,\"360\":1,\"362\":1,\"367\":1,\"377\":1}}],[\"message\",{\"1\":{\"265\":4}}],[\"menu\",{\"1\":{\"174\":1}}],[\"me\",{\"1\":{\"142\":2}}],[\"merge\",{\"1\":{\"65\":1}}],[\"merge方法可以对重复键的值进行特殊操作\",{\"1\":{\"65\":1}}],[\"merge方法用于处理数据\",{\"1\":{\"65\":1}}],[\"m\",{\"1\":{\"56\":1,\"64\":3,\"246\":4,\"294\":1,\"461\":1}}],[\"make\",{\"1\":{\"517\":1}}],[\"many注解来指定其他查询语句进行嵌套查询\",{\"1\":{\"629\":1}}],[\"manual\",{\"1\":{\"516\":1}}],[\"manager\",{\"1\":{\"476\":1,\"667\":7}}],[\"managerid\",{\"1\":{\"476\":2}}],[\"managementfactory\",{\"1\":{\"138\":1}}],[\"manipulation\",{\"1\":{\"472\":1}}],[\"mac\",{\"1\":{\"455\":1}}],[\"macintosh\",{\"1\":{\"455\":1}}],[\"macos\",{\"1\":{\"455\":1}}],[\"machine\",{\"1\":{\"183\":1}}],[\"matrix\",{\"0\":{\"331\":1},\"1\":{\"331\":1,\"334\":1,\"340\":1}}],[\"matching\",{\"1\":{\"569\":1}}],[\"matches\",{\"1\":{\"246\":2}}],[\"matches方法用于对给定正则表达式进行匹配\",{\"1\":{\"246\":1}}],[\"match\",{\"1\":{\"246\":1}}],[\"math也是java\",{\"1\":{\"274\":1}}],[\"math类\",{\"1\":{\"274\":1}}],[\"math\",{\"1\":{\"65\":3,\"229\":3,\"274\":5}}],[\"male\",{\"1\":{\"219\":1}}],[\"may\",{\"1\":{\"139\":1,\"304\":1,\"569\":1}}],[\"markov\",{\"0\":{\"305\":1},\"1\":{\"305\":2,\"420\":1}}],[\"markovian\",{\"1\":{\"299\":1}}],[\"mark已经失效\",{\"1\":{\"108\":1}}],[\"mark\",{\"1\":{\"108\":6}}],[\"mapper2\",{\"1\":{\"612\":2}}],[\"mapper>\",{\"1\":{\"554\":1,\"570\":1}}],[\"mapper\",{\"1\":{\"554\":3,\"570\":4,\"571\":2,\"593\":8,\"599\":2,\"604\":1,\"605\":2,\"611\":6,\"612\":2,\"616\":2,\"622\":2,\"625\":1,\"632\":1}}],[\"mappers>\",{\"1\":{\"554\":1,\"570\":1,\"622\":2}}],[\"mappers\",{\"1\":{\"547\":1,\"554\":1,\"569\":1}}],[\"mapping\",{\"1\":{\"338\":2,\"343\":5,\"347\":1}}],[\"maptoint\",{\"1\":{\"71\":1}}],[\"map中只有键为1的映射\",{\"1\":{\"57\":1}}],[\"map<test\",{\"1\":{\"84\":1}}],[\"map<string\",{\"1\":{\"65\":1,\"561\":1,\"564\":1,\"571\":1}}],[\"map<integer\",{\"1\":{\"57\":4,\"64\":1,\"66\":3}}],[\"map<\",{\"1\":{\"56\":1}}],[\"map<k\",{\"1\":{\"56\":1,\"58\":1}}],[\"map并不是collection体系下的接口\",{\"1\":{\"56\":1}}],[\"map目前只需要记住\",{\"1\":{\"50\":1}}],[\"map\",{\"0\":{\"55\":1,\"56\":1,\"63\":1},\"1\":{\"50\":1,\"55\":2,\"56\":2,\"57\":16,\"58\":1,\"64\":10,\"66\":12,\"67\":6,\"71\":1,\"84\":5,\"562\":2,\"571\":2}}],[\"maxa∈a\",{\"1\":{\"427\":1}}],[\"max​q^​\",{\"1\":{\"425\":1,\"426\":1,\"427\":3}}],[\"maximum\",{\"1\":{\"60\":2}}],[\"max\",{\"1\":{\"25\":4,\"60\":2,\"76\":1,\"145\":1,\"229\":1,\"274\":1,\"455\":1,\"493\":1,\"640\":1}}],[\"mainloop\",{\"1\":{\"167\":2}}],[\"main\",{\"1\":{\"4\":3,\"5\":1,\"14\":10,\"15\":3,\"16\":1,\"23\":2,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":4,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":1,\"120\":4,\"121\":2,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":2,\"155\":17,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":2,\"172\":2,\"173\":2,\"174\":7,\"182\":1,\"183\":1,\"184\":1,\"186\":10,\"191\":2,\"192\":5,\"193\":3,\"198\":9,\"199\":2,\"206\":2,\"207\":5,\"208\":3,\"219\":3,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":2,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":1,\"254\":2,\"255\":5,\"256\":1,\"257\":3,\"258\":9,\"267\":5,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":4,\"427\":4,\"429\":1,\"447\":3,\"448\":2,\"454\":2,\"455\":2,\"524\":2,\"526\":1,\"533\":1,\"534\":4,\"552\":1,\"554\":1,\"558\":1,\"569\":1,\"636\":4,\"638\":2,\"639\":1,\"646\":1,\"647\":2,\"655\":1,\"657\":4,\"678\":4}}],[\"gname\",{\"1\":{\"583\":3}}],[\"got\",{\"1\":{\"517\":1}}],[\"good\",{\"1\":{\"295\":1,\"507\":1}}],[\"google\",{\"1\":{\"246\":2,\"455\":1}}],[\"gid\",{\"1\":{\"583\":6}}],[\"git\",{\"1\":{\"510\":1}}],[\"given\",{\"1\":{\"139\":1}}],[\"gzip\",{\"1\":{\"455\":1}}],[\"g∣s=s\",{\"1\":{\"398\":1}}],[\"g~​\",{\"1\":{\"389\":1,\"395\":1}}],[\"gd\",{\"1\":{\"386\":1,\"389\":1}}],[\"g​\",{\"1\":{\"382\":2,\"384\":2}}],[\"gpi\",{\"1\":{\"367\":1}}],[\"g\",{\"1\":{\"363\":3,\"381\":4,\"382\":2,\"383\":1,\"384\":2,\"389\":1,\"395\":2,\"398\":1}}],[\"groups\",{\"1\":{\"583\":4}}],[\"group\",{\"1\":{\"494\":2,\"583\":7}}],[\"grow\",{\"1\":{\"25\":1}}],[\"grade\",{\"1\":{\"507\":3}}],[\"gradient\",{\"0\":{\"385\":1,\"432\":1},\"1\":{\"386\":2,\"433\":1}}],[\"grant\",{\"1\":{\"472\":1,\"502\":3}}],[\"greedy\",{\"0\":{\"370\":1,\"372\":1,\"373\":1},\"1\":{\"338\":1,\"348\":2,\"351\":1,\"355\":2,\"364\":1,\"372\":3}}],[\"gt\",{\"1\":{\"564\":2}}],[\"gt+1​∣st+1​=s\",{\"1\":{\"329\":2}}],[\"gt+1​∣st​=s\",{\"1\":{\"327\":2,\"329\":5,\"330\":1}}],[\"gt​−v^\",{\"1\":{\"422\":1}}],[\"gt​​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"327\":1}}],[\"gt​∣st​=s\",{\"1\":{\"325\":1,\"327\":1,\"333\":3,\"334\":2,\"360\":2,\"362\":1,\"363\":1}}],[\"gt​\",{\"1\":{\"325\":2,\"327\":1,\"363\":1,\"422\":2}}],[\"gt​也是一个随机变量\",{\"1\":{\"324\":1}}],[\"gt​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"324\":1}}],[\"gt​=e\",{\"1\":{\"298\":1}}],[\"gkn​​\",{\"1\":{\"294\":1}}],[\"gain\",{\"1\":{\"294\":1}}],[\"gecko\",{\"1\":{\"455\":1}}],[\"generics\",{\"1\":{\"186\":1}}],[\"genericinterface\",{\"1\":{\"186\":2}}],[\"generally\",{\"1\":{\"516\":1}}],[\"generalized\",{\"1\":{\"367\":1}}],[\"general\",{\"1\":{\"139\":1,\"477\":1}}],[\"getformatterproperty\",{\"1\":{\"667\":1}}],[\"getfilterproperty\",{\"1\":{\"667\":1}}],[\"getfield\",{\"1\":{\"199\":1}}],[\"getfirstchild\",{\"1\":{\"547\":1}}],[\"getfirst\",{\"1\":{\"44\":1}}],[\"gethandlers\",{\"1\":{\"646\":1,\"655\":1,\"656\":1,\"674\":1}}],[\"gethostaddress\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"getresultobject\",{\"1\":{\"564\":1}}],[\"getresourceasstream\",{\"1\":{\"552\":1}}],[\"getreturntype\",{\"1\":{\"192\":1}}],[\"getnodevalue\",{\"1\":{\"547\":1}}],[\"getnodename\",{\"1\":{\"547\":1}}],[\"getnodetype\",{\"1\":{\"547\":1}}],[\"getname\",{\"1\":{\"7\":1,\"65\":2,\"140\":1,\"166\":1,\"167\":1,\"173\":1,\"174\":2,\"184\":1,\"186\":1,\"192\":1,\"199\":1,\"215\":1,\"221\":2,\"517\":3,\"538\":1,\"569\":1,\"638\":1,\"639\":1,\"646\":1,\"655\":1,\"667\":1,\"676\":1,\"678\":2}}],[\"getlocalizedname\",{\"1\":{\"672\":1}}],[\"getlogmanager\",{\"1\":{\"667\":2}}],[\"getlogger\",{\"1\":{\"636\":1,\"638\":1,\"639\":1,\"646\":1,\"655\":2,\"658\":4,\"667\":1,\"674\":1}}],[\"getlevel\",{\"1\":{\"672\":1,\"676\":1}}],[\"getlevelproperty\",{\"1\":{\"667\":1}}],[\"getlength\",{\"1\":{\"547\":1}}],[\"getlast\",{\"1\":{\"44\":1}}],[\"getelementsbytagname\",{\"1\":{\"547\":1}}],[\"getencoding\",{\"1\":{\"97\":1}}],[\"getobject\",{\"1\":{\"527\":1}}],[\"getoutputstream\",{\"1\":{\"448\":2,\"454\":1,\"455\":1}}],[\"getordefault\",{\"1\":{\"57\":2}}],[\"getint\",{\"1\":{\"527\":1}}],[\"getinterfaces\",{\"1\":{\"186\":1}}],[\"getinputstream\",{\"1\":{\"448\":2,\"454\":1,\"455\":1}}],[\"getinetaddress\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"getproperties\",{\"1\":{\"666\":2}}],[\"getprimitiveclass获取的是原始类型\",{\"1\":{\"183\":1}}],[\"getprimitiveclass\",{\"1\":{\"183\":2}}],[\"getparametertypes\",{\"1\":{\"527\":2}}],[\"getparameters\",{\"1\":{\"192\":1}}],[\"getparent\",{\"1\":{\"198\":3,\"655\":2,\"658\":3,\"674\":1}}],[\"getdeclaredfield\",{\"1\":{\"193\":4}}],[\"getdeclaredmethod\",{\"1\":{\"192\":3}}],[\"getdeclaredconstructor\",{\"1\":{\"191\":1}}],[\"getmillis\",{\"1\":{\"676\":1}}],[\"getmapper\",{\"1\":{\"570\":2,\"571\":1,\"593\":3,\"599\":1,\"605\":1,\"611\":3,\"612\":2,\"616\":1}}],[\"getmax\",{\"1\":{\"71\":1}}],[\"getmessage\",{\"1\":{\"267\":1,\"676\":1}}],[\"getmethod\",{\"1\":{\"192\":2,\"199\":2,\"208\":1}}],[\"getmodifiers\",{\"1\":{\"193\":1}}],[\"getgenericinterfaces\",{\"1\":{\"186\":1}}],[\"getgenericsuperclass\",{\"1\":{\"186\":5}}],[\"getsourcemethodname\",{\"1\":{\"672\":1}}],[\"getsourceclassname\",{\"1\":{\"672\":1,\"676\":1}}],[\"getsetinvoker\",{\"1\":{\"569\":1}}],[\"getsession\",{\"1\":{\"558\":2,\"612\":2}}],[\"getsex\",{\"1\":{\"538\":1}}],[\"getsid\",{\"1\":{\"538\":1}}],[\"getsimplename\",{\"1\":{\"184\":1}}],[\"gets\",{\"1\":{\"517\":1}}],[\"getstringproperty\",{\"1\":{\"667\":1}}],[\"getstring\",{\"1\":{\"516\":1,\"527\":2,\"532\":1,\"533\":1}}],[\"getstatus\",{\"1\":{\"221\":2}}],[\"getsuperclass\",{\"1\":{\"186\":2}}],[\"getscore\",{\"1\":{\"65\":2}}],[\"getter和setter\",{\"1\":{\"677\":1}}],[\"getter和\",{\"1\":{\"540\":1}}],[\"getter\",{\"1\":{\"538\":1,\"540\":1}}],[\"getthreadname\",{\"1\":{\"138\":1}}],[\"getthreadinfo\",{\"1\":{\"138\":1}}],[\"getthreadmxbean\",{\"1\":{\"138\":1}}],[\"gettypealiasregistry\",{\"1\":{\"632\":1}}],[\"gettypename\",{\"1\":{\"184\":1,\"186\":1}}],[\"gettype\",{\"1\":{\"65\":1}}],[\"getannotations\",{\"1\":{\"208\":2}}],[\"getactualtypearguments\",{\"1\":{\"186\":4}}],[\"getallthreadids\",{\"1\":{\"138\":1}}],[\"getabsolutepath\",{\"1\":{\"98\":1}}],[\"getaverage\",{\"1\":{\"71\":1}}],[\"getbytes\",{\"1\":{\"92\":2,\"93\":1,\"110\":1}}],[\"getchildnodes\",{\"1\":{\"547\":1}}],[\"getcallerclass\",{\"1\":{\"517\":1}}],[\"getcontextclassloader\",{\"1\":{\"517\":1}}],[\"getconnection\",{\"1\":{\"516\":1,\"517\":7,\"524\":1,\"526\":1,\"532\":1,\"533\":1,\"534\":4}}],[\"getconstructors\",{\"1\":{\"527\":1}}],[\"getconstructor\",{\"1\":{\"191\":2,\"192\":1,\"527\":1}}],[\"getcount\",{\"1\":{\"71\":1}}],[\"getclassloader\",{\"1\":{\"184\":1,\"198\":4,\"517\":1}}],[\"getclass\",{\"1\":{\"84\":4,\"182\":1,\"186\":10,\"215\":2,\"517\":3,\"527\":2,\"570\":1,\"667\":1}}],[\"getkey\",{\"1\":{\"56\":1}}],[\"get\",{\"1\":{\"24\":1,\"25\":1,\"56\":1,\"57\":3,\"71\":1,\"84\":1,\"110\":1,\"162\":1,\"163\":1,\"193\":1,\"333\":2,\"455\":1,\"665\":1,\"666\":2}}],[\"getvalue\",{\"1\":{\"15\":3,\"56\":1}}],[\"度\",{\"1\":{\"25\":1}}],[\"jul设置默认配置\",{\"0\":{\"667\":1}}],[\"jul中logger之间存在父子关系\",{\"1\":{\"655\":1}}],[\"jul\",{\"0\":{\"695\":1},\"2\":{\"642\":1,\"651\":1,\"660\":1,\"669\":1,\"681\":1}}],[\"jul基本使用\",{\"0\":{\"637\":1}}],[\"jul日志5\",{\"0\":{\"670\":1}}],[\"jul日志4\",{\"0\":{\"661\":1}}],[\"jul日志3\",{\"0\":{\"652\":1}}],[\"jul日志2\",{\"0\":{\"643\":1}}],[\"jul日志系统5\",{\"0\":{\"671\":1}}],[\"jul日志系统4\",{\"0\":{\"662\":1}}],[\"jul日志系统3\",{\"0\":{\"653\":1}}],[\"jul日志系统2\",{\"0\":{\"644\":1}}],[\"jul日志系统\",{\"0\":{\"636\":1}}],[\"jul日志1\",{\"0\":{\"635\":1}}],[\"jar\",{\"1\":{\"517\":1}}],[\"java读取\",{\"0\":{\"665\":1}}],[\"javatype\",{\"1\":{\"628\":3}}],[\"javatype=\",{\"1\":{\"569\":2,\"578\":1,\"579\":1,\"583\":1,\"628\":3}}],[\"java对象\",{\"1\":{\"544\":1}}],[\"java的编译过程可以分成三个阶段\",{\"1\":{\"539\":1}}],[\"java的内存模型也是这样类似设计的\",{\"1\":{\"154\":1}}],[\"java与数据库3\",{\"0\":{\"530\":1}}],[\"java与数据库2\",{\"0\":{\"522\":1}}],[\"java与数据库1\",{\"0\":{\"513\":1}}],[\"java应用程序\",{\"1\":{\"515\":1}}],[\"java数据库连接\",{\"1\":{\"515\":1}}],[\"javaweb\",{\"0\":{\"445\":1,\"452\":1,\"458\":1,\"470\":1,\"487\":1,\"505\":1,\"513\":1,\"522\":1,\"530\":1,\"537\":1,\"543\":1,\"550\":1,\"557\":1,\"567\":1,\"574\":1,\"586\":1,\"596\":1,\"608\":1,\"619\":1,\"635\":1,\"643\":1,\"652\":1,\"661\":1,\"670\":1,\"691\":1},\"2\":{\"451\":1,\"457\":1,\"469\":1,\"486\":1,\"504\":1,\"512\":1,\"521\":1,\"529\":1,\"536\":1,\"542\":1,\"549\":1,\"556\":1,\"566\":1,\"573\":1,\"585\":1,\"595\":1,\"607\":1,\"618\":1,\"634\":1,\"642\":1,\"651\":1,\"660\":1,\"669\":1,\"681\":1}}],[\"java提供的基本类型包装类\",{\"1\":{\"226\":1}}],[\"java并不是纯面向对象的语言\",{\"1\":{\"226\":1}}],[\"javac\",{\"1\":{\"199\":1}}],[\"java高版本不行\",{\"1\":{\"193\":1}}],[\"java中没有字符串这种基本类型\",{\"1\":{\"243\":1}}],[\"java中的基本类型\",{\"1\":{\"226\":1}}],[\"java中也有些使用并行来进行操作的\",{\"1\":{\"173\":1}}],[\"java中所有的线程都执行完毕后\",{\"1\":{\"172\":1}}],[\"java中引入了访问权限控制\",{\"1\":{\"121\":1}}],[\"java采用的是抢占式调度方式\",{\"1\":{\"145\":1}}],[\"java程序中的每个线程并不是平均分配cpu时间的\",{\"1\":{\"145\":1}}],[\"java会默认导入java\",{\"1\":{\"120\":1}}],[\"java8开始\",{\"1\":{\"219\":1}}],[\"java8新增操作\",{\"1\":{\"57\":1}}],[\"java8新增方法\",{\"1\":{\"23\":1,\"36\":1}}],[\"java8\",{\"1\":{\"35\":1,\"57\":1}}],[\"java\",{\"0\":{\"3\":1,\"12\":1,\"19\":1,\"28\":1,\"40\":1,\"53\":1,\"70\":1,\"74\":1,\"83\":1,\"87\":1,\"101\":1,\"116\":1,\"124\":1,\"136\":1,\"151\":1,\"159\":1,\"170\":1,\"177\":1,\"180\":1,\"189\":1,\"196\":1,\"202\":1,\"211\":1,\"224\":1,\"232\":1,\"249\":1,\"261\":1,\"271\":1,\"278\":1,\"684\":1,\"686\":1},\"1\":{\"23\":2,\"24\":1,\"25\":2,\"42\":1,\"67\":1,\"71\":2,\"95\":2,\"118\":1,\"120\":1,\"139\":1,\"173\":1,\"182\":1,\"186\":3,\"192\":4,\"198\":2,\"199\":2,\"204\":2,\"205\":2,\"208\":6,\"220\":1,\"221\":3,\"229\":3,\"242\":1,\"255\":2,\"274\":2,\"275\":1,\"285\":5,\"448\":2,\"449\":1,\"454\":2,\"515\":3,\"517\":4,\"524\":2,\"544\":2,\"569\":3,\"571\":1,\"629\":1,\"638\":1,\"655\":1,\"667\":1,\"675\":1,\"679\":1},\"2\":{\"11\":1,\"18\":1,\"27\":1,\"39\":1,\"52\":1,\"69\":1,\"73\":1,\"82\":1,\"86\":1,\"100\":1,\"115\":1,\"123\":1,\"135\":1,\"150\":1,\"158\":1,\"169\":1,\"176\":1,\"188\":1,\"195\":1,\"201\":1,\"210\":1,\"223\":1,\"231\":1,\"248\":1,\"260\":1,\"270\":1,\"277\":1,\"284\":1,\"287\":1}}],[\"jsp等\",{\"1\":{\"515\":1}}],[\"jstack自动帮助我们找到了一个死锁\",{\"1\":{\"156\":1}}],[\"jstack\",{\"1\":{\"156\":1}}],[\"jdbctransactionfactory\",{\"1\":{\"632\":1}}],[\"jdbc很方便\",{\"1\":{\"544\":1}}],[\"jdbc默认的事务处理行为是自动提交\",{\"1\":{\"534\":1}}],[\"jdbc英文名为\",{\"1\":{\"515\":1}}],[\"jdbc\",{\"0\":{\"515\":1,\"523\":1,\"531\":1},\"1\":{\"516\":4,\"517\":1,\"524\":1,\"533\":1,\"544\":1,\"552\":2,\"580\":3,\"600\":1,\"632\":2,\"664\":4}}],[\"jdk为我们提供了一个叫做properties的类型\",{\"1\":{\"665\":1}}],[\"jdk为我们提供了一个自带的日志框架\",{\"1\":{\"636\":1}}],[\"jdk为我们提供了很多种类的handler用于多种不同类型的日志打印\",{\"1\":{\"646\":1}}],[\"jdk为我们内置了一个叫做org\",{\"1\":{\"547\":1}}],[\"jdk为我们准备的\",{\"1\":{\"75\":1}}],[\"jdk自带了一个java\",{\"1\":{\"515\":1}}],[\"jdk\",{\"1\":{\"280\":1,\"570\":1,\"679\":2}}],[\"jdk预设了以下注解\",{\"1\":{\"204\":1}}],[\"jdk提供的string类也是\",{\"1\":{\"198\":1}}],[\"jdk1\",{\"1\":{\"180\":1,\"183\":1}}],[\"j+1\",{\"1\":{\"351\":2,\"353\":1}}],[\"j++\",{\"1\":{\"155\":6}}],[\"j\",{\"1\":{\"155\":12,\"351\":2,\"353\":1,\"363\":1,\"386\":1,\"389\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"426\":1,\"427\":3,\"433\":1,\"436\":1,\"440\":1,\"441\":1}}],[\"join同理\",{\"1\":{\"497\":1}}],[\"join\",{\"1\":{\"148\":1,\"497\":5,\"578\":1,\"581\":1,\"583\":2}}],[\"jvm发现任何异常都会立即终止程序运行\",{\"1\":{\"267\":1}}],[\"jvm会加载这个类吗\",{\"1\":{\"198\":1}}],[\"jvm会将一部分类\",{\"1\":{\"180\":1}}],[\"jvm\",{\"0\":{\"199\":1},\"1\":{\"118\":2,\"267\":2}}],[\"jvm都c++实现中\",{\"1\":{\"25\":1}}],[\"创建documentbuilder对象\",{\"1\":{\"547\":1}}],[\"创建documentbuilderfactory对象\",{\"1\":{\"547\":1}}],[\"创建回滚点\",{\"1\":{\"534\":1}}],[\"创建一个用于执行sql的statement对象\",{\"1\":{\"516\":1}}],[\"创建一个变量指代我们刚刚创建好的对象\",{\"1\":{\"4\":1}}],[\"创建索引\",{\"1\":{\"508\":1}}],[\"创建后\",{\"1\":{\"507\":1}}],[\"创建用户\",{\"0\":{\"500\":1}}],[\"创建表\",{\"0\":{\"478\":1}}],[\"创建random对象\",{\"1\":{\"274\":1}}],[\"创建出来的数组每个位置上都有默认值\",{\"1\":{\"235\":1}}],[\"创建出学生对象\",{\"1\":{\"192\":2}}],[\"创建对象越多\",{\"1\":{\"227\":1}}],[\"创建枚举需要添加参数\",{\"1\":{\"221\":1}}],[\"创建类对象\",{\"0\":{\"191\":1}}],[\"创建类的实例\",{\"1\":{\"118\":1}}],[\"创建定时器对象\",{\"1\":{\"166\":1}}],[\"创建并启动此定时任务\",{\"1\":{\"165\":2}}],[\"创建好后\",{\"1\":{\"140\":1}}],[\"创建当前列表\",{\"1\":{\"25\":1}}],[\"中间使用等号进行连接\",{\"1\":{\"664\":1}}],[\"中间操作\",{\"1\":{\"71\":1}}],[\"中取出一定数量的样本\",{\"1\":{\"427\":1}}],[\"中采用一个\",{\"1\":{\"427\":1}}],[\"中直接根据\",{\"1\":{\"400\":1}}],[\"中直接继承的\",{\"1\":{\"47\":1}}],[\"中不断切换\",{\"1\":{\"367\":1}}],[\"中不存在时\",{\"1\":{\"57\":1}}],[\"中第一次出现的\",{\"1\":{\"366\":1}}],[\"中求解\",{\"1\":{\"353\":1}}],[\"中涉及的\",{\"1\":{\"347\":1}}],[\"中方法\",{\"1\":{\"255\":1}}],[\"中除了\",{\"1\":{\"246\":1}}],[\"中字符的所有字符\",{\"1\":{\"246\":1}}],[\"中所有的\",{\"1\":{\"246\":1}}],[\"中的前三个\",{\"1\":{\"246\":1}}],[\"中的所有操作\",{\"1\":{\"510\":1}}],[\"中的所有字符\",{\"1\":{\"246\":1}}],[\"中的所有\",{\"1\":{\"246\":1}}],[\"中的两个\",{\"1\":{\"246\":1}}],[\"中的\",{\"1\":{\"246\":3,\"373\":1,\"427\":2}}],[\"中的某个对象\",{\"1\":{\"48\":1}}],[\"中找不到\",{\"1\":{\"198\":1}}],[\"中途是不允许转换的\",{\"1\":{\"172\":2}}],[\"中断\",{\"0\":{\"144\":1}}],[\"中使用一个类之前\",{\"1\":{\"118\":1}}],[\"中定义的\",{\"1\":{\"218\":1}}],[\"中定义的差不多\",{\"1\":{\"47\":1}}],[\"中定义要在完成之后释放的资源\",{\"1\":{\"90\":1}}],[\"中无法添加相同的键\",{\"1\":{\"57\":1}}],[\"中存取元素\",{\"1\":{\"48\":1}}],[\"中\",{\"0\":{\"199\":1,\"384\":1},\"1\":{\"25\":1,\"56\":1,\"96\":1,\"154\":1,\"229\":1,\"242\":1,\"255\":1,\"256\":1,\"274\":1,\"275\":1,\"314\":1,\"356\":1,\"362\":1,\"373\":1,\"377\":1,\"422\":1,\"427\":1,\"516\":1,\"590\":1}}],[\"中已经帮我们将常用的集合类型都实现好了\",{\"1\":{\"23\":1}}],[\"lru\",{\"1\":{\"612\":1}}],[\"lt\",{\"1\":{\"564\":1,\"602\":1}}],[\"lnπ\",{\"1\":{\"440\":1}}],[\"l2​=log2​\",{\"1\":{\"295\":1}}],[\"l2​\",{\"1\":{\"295\":1}}],[\"l1​=log2​\",{\"1\":{\"295\":1}}],[\"l1​\",{\"1\":{\"295\":1}}],[\"l=min\",{\"1\":{\"295\":1}}],[\"level=all\",{\"1\":{\"667\":2,\"679\":2}}],[\"level\",{\"1\":{\"638\":15,\"639\":4,\"640\":6,\"656\":2,\"667\":4}}],[\"left\",{\"1\":{\"497\":1,\"578\":1,\"581\":1,\"583\":2}}],[\"learning是优化长期目标\",{\"1\":{\"298\":1}}],[\"learning的部署算法不同的是\",{\"1\":{\"299\":1}}],[\"learning的移动算法\",{\"1\":{\"299\":1}}],[\"learning的优化目标是最大化长期收益\",{\"1\":{\"298\":1}}],[\"learning的方案来解决无人机的np\",{\"1\":{\"290\":1}}],[\"learning算法\",{\"1\":{\"298\":1}}],[\"learning\",{\"0\":{\"288\":1,\"394\":1,\"396\":1,\"400\":1,\"404\":1,\"405\":1,\"409\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1},\"1\":{\"290\":2,\"404\":1,\"405\":1,\"408\":1,\"409\":1,\"426\":1}}],[\"length方法可以求字符串长度\",{\"1\":{\"244\":1}}],[\"length属性是int类型的值\",{\"1\":{\"236\":1}}],[\"length\",{\"1\":{\"25\":1,\"59\":2,\"60\":1,\"71\":1,\"98\":1,\"199\":1,\"236\":2,\"237\":1,\"244\":2,\"527\":2}}],[\"length字段\",{\"1\":{\"25\":2}}],[\"log4j2\",{\"1\":{\"679\":1}}],[\"log4j\",{\"1\":{\"679\":1}}],[\"log注解即可\",{\"1\":{\"678\":1}}],[\"logrecord\",{\"1\":{\"672\":2,\"676\":1}}],[\"logmanager\",{\"1\":{\"667\":4}}],[\"logmanager$rootlogger\",{\"1\":{\"655\":1}}],[\"log这种格式\",{\"1\":{\"646\":1}}],[\"log\",{\"1\":{\"639\":4,\"648\":1,\"649\":1,\"678\":4}}],[\"logger也是可以使用lombok快速生成的\",{\"1\":{\"678\":1}}],[\"logger4\",{\"1\":{\"658\":2}}],[\"logger3\",{\"1\":{\"658\":2}}],[\"logger2\",{\"1\":{\"658\":4}}],[\"logger1\",{\"1\":{\"658\":2}}],[\"logger类还为我们提供了两个比较特殊的日志级别\",{\"1\":{\"640\":1}}],[\"logger默认情况下只会打印info级别以上的日志\",{\"1\":{\"639\":1}}],[\"logger\",{\"1\":{\"636\":4,\"638\":10,\"639\":7,\"640\":2,\"646\":5,\"647\":2,\"648\":1,\"655\":9,\"656\":2,\"657\":2,\"658\":8,\"667\":4,\"674\":4}}],[\"logging表示使用jul进行日志打印\",{\"1\":{\"679\":1}}],[\"logging表示直接使用标准输出将日志信息打印到控制台\",{\"1\":{\"679\":1}}],[\"logging包下\",{\"1\":{\"636\":1}}],[\"logging\",{\"1\":{\"580\":1,\"655\":1,\"667\":2,\"675\":1,\"679\":8}}],[\"logimpl包括很多种配置项\",{\"1\":{\"679\":1}}],[\"logimpl\",{\"1\":{\"580\":1,\"679\":2}}],[\"login\",{\"1\":{\"501\":1}}],[\"lombok\",{\"0\":{\"693\":1},\"1\":{\"538\":1,\"539\":2,\"554\":1},\"2\":{\"542\":1}}],[\"lombok1\",{\"0\":{\"537\":1,\"538\":1}}],[\"location\",{\"1\":{\"476\":3}}],[\"localhost\",{\"1\":{\"447\":1,\"448\":1,\"449\":1,\"454\":1,\"455\":1,\"516\":1,\"524\":1,\"632\":1,\"664\":1}}],[\"local\",{\"1\":{\"162\":4,\"163\":4}}],[\"loss\",{\"1\":{\"426\":1}}],[\"low\",{\"1\":{\"227\":2}}],[\"loop\",{\"1\":{\"167\":1}}],[\"looptime\",{\"1\":{\"165\":5}}],[\"lol\",{\"1\":{\"138\":1}}],[\"long\",{\"1\":{\"132\":1,\"133\":1,\"138\":1,\"143\":1,\"165\":4,\"215\":2,\"227\":3,\"229\":1,\"420\":1,\"559\":1}}],[\"loaded\",{\"1\":{\"517\":2}}],[\"loading\",{\"1\":{\"516\":2,\"517\":1}}],[\"load\",{\"1\":{\"58\":1,\"60\":1,\"517\":1,\"665\":1}}],[\"loadfactor\",{\"1\":{\"58\":2}}],[\"lbw\",{\"1\":{\"133\":1}}],[\"lbwnb\",{\"1\":{\"92\":2,\"126\":1,\"163\":1,\"242\":1,\"258\":2,\"281\":1}}],[\"lb\",{\"1\":{\"93\":1}}],[\"large\",{\"1\":{\"360\":1}}],[\"law\",{\"1\":{\"360\":1}}],[\"language\",{\"1\":{\"455\":1,\"472\":5}}],[\"lang包下的类\",{\"1\":{\"274\":1}}],[\"lang包下的\",{\"1\":{\"120\":1}}],[\"lang\",{\"1\":{\"120\":1,\"139\":1,\"182\":1,\"198\":2,\"208\":4,\"220\":1,\"221\":2,\"569\":3}}],[\"lang这个包下的所有类\",{\"1\":{\"120\":1}}],[\"lambda表达式的具体规范\",{\"1\":{\"257\":1}}],[\"lambda表达式\",{\"0\":{\"257\":1}}],[\"lambda\",{\"1\":{\"35\":1,\"256\":1,\"257\":1}}],[\"lastreturned\",{\"1\":{\"33\":1}}],[\"lastret\",{\"1\":{\"33\":1}}],[\"last\",{\"1\":{\"25\":1}}],[\"lastindexof\",{\"1\":{\"24\":1}}],[\"like\",{\"1\":{\"455\":1,\"491\":2}}],[\"link\",{\"1\":{\"293\":1}}],[\"linkedmap\",{\"1\":{\"67\":1}}],[\"linkedset\",{\"1\":{\"67\":1}}],[\"linkedhashmap中的结点实现\",{\"1\":{\"61\":1}}],[\"linkedhashmap\",{\"0\":{\"61\":1},\"1\":{\"49\":1,\"57\":1,\"61\":2}}],[\"linkedhashset<>\",{\"1\":{\"49\":1}}],[\"linkedhashset\",{\"0\":{\"49\":1},\"1\":{\"49\":2}}],[\"linkedlist<e>\",{\"1\":{\"25\":1,\"42\":1}}],[\"linkedlist<>\",{\"1\":{\"25\":2,\"43\":1,\"44\":1,\"174\":1}}],[\"linkedlist\",{\"1\":{\"25\":3,\"33\":1,\"42\":1,\"43\":1}}],[\"lines\",{\"1\":{\"112\":1}}],[\"limiting\",{\"1\":{\"420\":1}}],[\"limit\",{\"1\":{\"71\":3,\"112\":1,\"494\":2}}],[\"li\",{\"1\":{\"24\":4}}],[\"listn\",{\"1\":{\"285\":1}}],[\"list1\",{\"1\":{\"285\":1}}],[\"list初始化\",{\"0\":{\"285\":1}}],[\"listfiles\",{\"1\":{\"98\":1}}],[\"list<book>\",{\"1\":{\"581\":1}}],[\"list<user>\",{\"1\":{\"564\":2,\"605\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":1,\"628\":1}}],[\"list<test>\",{\"1\":{\"84\":1}}],[\"list<student>\",{\"1\":{\"65\":1,\"285\":1,\"554\":1,\"558\":1,\"570\":2}}],[\"list<string>\",{\"1\":{\"25\":6,\"30\":2,\"34\":2,\"35\":1,\"71\":2,\"186\":1,\"193\":1,\"285\":2,\"599\":1}}],[\"list<list<string>>\",{\"1\":{\"25\":1}}],[\"list<integer>\",{\"1\":{\"25\":2,\"71\":3,\"76\":1,\"77\":1,\"78\":1,\"79\":3,\"80\":1,\"173\":1}}],[\"list<e>\",{\"1\":{\"24\":2,\"25\":2,\"42\":1}}],[\"listiterator\",{\"1\":{\"24\":4}}],[\"listiterator<e>\",{\"1\":{\"24\":4,\"37\":1}}],[\"list中可插入重复元素\",{\"1\":{\"24\":1}}],[\"list是一个有序的集合类\",{\"1\":{\"24\":1}}],[\"list\",{\"0\":{\"24\":1},\"1\":{\"23\":2,\"24\":3,\"25\":30,\"30\":4,\"34\":4,\"35\":2,\"71\":31,\"76\":3,\"77\":2,\"78\":3,\"79\":4,\"80\":12,\"84\":4,\"98\":1,\"173\":2,\"186\":2,\"285\":7,\"517\":1,\"599\":1,\"604\":2,\"605\":2}}],[\"right\",{\"1\":{\"497\":1}}],[\"rˉπ​\",{\"1\":{\"440\":1}}],[\"rˉπ​​\",{\"1\":{\"439\":1}}],[\"rˉπ​=s∈s∑​dπ​\",{\"1\":{\"438\":1}}],[\"r1​\",{\"1\":{\"397\":1}}],[\"rk​+γv\",{\"1\":{\"395\":1}}],[\"rkn​​mss​\",{\"1\":{\"295\":1}}],[\"rkn​​\",{\"1\":{\"295\":3}}],[\"r→r\",{\"1\":{\"381\":1}}],[\"rm\",{\"0\":{\"380\":1},\"1\":{\"382\":1,\"384\":1,\"389\":3,\"395\":2}}],[\"rollback\",{\"1\":{\"510\":3,\"534\":3,\"593\":1}}],[\"row\",{\"1\":{\"509\":2,\"580\":2}}],[\"robbins\",{\"0\":{\"380\":1},\"1\":{\"383\":2}}],[\"rootlogger\",{\"1\":{\"667\":2,\"679\":2}}],[\"rootnode\",{\"1\":{\"547\":2}}],[\"root\",{\"1\":{\"377\":1,\"383\":1,\"389\":1,\"395\":1,\"516\":1,\"524\":1}}],[\"roundingmode是舍入模式\",{\"1\":{\"229\":1}}],[\"roundingmode\",{\"1\":{\"229\":1}}],[\"r+s\",{\"1\":{\"351\":2}}],[\"r+γa∈a\",{\"1\":{\"426\":1,\"427\":3}}],[\"r+γqπ​\",{\"1\":{\"400\":1}}],[\"r+γg∣s=s\",{\"1\":{\"398\":1}}],[\"r+γv\",{\"1\":{\"395\":6}}],[\"r+γ∑s\",{\"1\":{\"333\":1}}],[\"r+γs\",{\"1\":{\"330\":1,\"333\":1,\"340\":1,\"348\":1}}],[\"rπ​+γpπ​v1​\",{\"1\":{\"355\":1}}],[\"rπ​+γpπ​vπ1​​\",{\"1\":{\"355\":1}}],[\"rπ​+γpπ​vπ0​​\",{\"1\":{\"355\":2}}],[\"rπ​+γpπ​vπk​​\",{\"1\":{\"351\":1,\"355\":1,\"362\":1}}],[\"rπ​+γpπ​vk​\",{\"1\":{\"347\":1,\"348\":1,\"355\":1}}],[\"rπ​+γpπ​v\",{\"1\":{\"340\":1,\"343\":1,\"346\":1}}],[\"rπ​\",{\"1\":{\"331\":2,\"438\":4,\"439\":1}}],[\"rπ​=\",{\"1\":{\"331\":1}}],[\"r​​+mean\",{\"1\":{\"330\":1}}],[\"r​\",{\"1\":{\"328\":1}}],[\"r∑​p\",{\"1\":{\"328\":1,\"330\":2,\"333\":1,\"340\":1,\"348\":1,\"351\":2}}],[\"rl9\",{\"0\":{\"432\":1}}],[\"rl8\",{\"0\":{\"415\":1}}],[\"rl7\",{\"0\":{\"394\":1}}],[\"rl\",{\"1\":{\"377\":1}}],[\"rl6\",{\"0\":{\"377\":1}}],[\"rl5\",{\"0\":{\"360\":1}}],[\"rl4\",{\"0\":{\"346\":1}}],[\"rl3\",{\"0\":{\"337\":1}}],[\"rl2\",{\"0\":{\"321\":1}}],[\"rl10\",{\"0\":{\"308\":1}}],[\"rl1\",{\"0\":{\"302\":1}}],[\"r∣s\",{\"1\":{\"305\":1,\"326\":1,\"328\":1,\"330\":3,\"333\":2,\"340\":1,\"348\":2,\"351\":2,\"360\":1,\"362\":3,\"438\":2}}],[\"r=1∣s1​\",{\"1\":{\"304\":1}}],[\"rt\",{\"1\":{\"517\":1}}],[\"rt+2​\",{\"1\":{\"439\":1}}],[\"rt+2​+γrt+3​+\",{\"1\":{\"327\":1}}],[\"rt+1​+rt+2​+⋯+rt+n​∣st​=s0​\",{\"1\":{\"439\":1}}],[\"rt+1​+γq^​\",{\"1\":{\"424\":1}}],[\"rt+1​+γqt​\",{\"1\":{\"401\":1}}],[\"rt+1​+γv^\",{\"1\":{\"423\":2}}],[\"rt+1​+γvt​\",{\"1\":{\"397\":2}}],[\"rt+1​+γa∈a\",{\"1\":{\"425\":1}}],[\"rt+1​+γa∈amax​qt​\",{\"1\":{\"405\":1}}],[\"rt+1​+γamax​q\",{\"1\":{\"404\":1}}],[\"rt+1​+γgt+1​∣st​=s\",{\"1\":{\"327\":1}}],[\"rt+1​\",{\"1\":{\"397\":2,\"401\":1,\"439\":1}}],[\"rt+1​∣st​=s\",{\"1\":{\"327\":2,\"328\":2,\"330\":1}}],[\"rt+1​∣at+1​\",{\"1\":{\"305\":1}}],[\"rt​∣st​\",{\"1\":{\"298\":1}}],[\"rtt\",{\"1\":{\"295\":1}}],[\"r\",{\"1\":{\"246\":2,\"305\":3,\"395\":3,\"426\":1,\"427\":1,\"438\":3,\"455\":2}}],[\"runoob\",{\"1\":{\"246\":3}}],[\"running\",{\"1\":{\"221\":5}}],[\"runnable\",{\"1\":{\"139\":3,\"165\":8}}],[\"runtime\",{\"1\":{\"206\":1,\"207\":4,\"208\":1}}],[\"runtimeexceptionruntimeexception\",{\"1\":{\"264\":1}}],[\"runtimeexception\",{\"1\":{\"110\":1,\"174\":1,\"264\":1,\"265\":3,\"266\":2,\"267\":2,\"448\":1,\"454\":1,\"524\":1}}],[\"run方法\",{\"1\":{\"141\":1}}],[\"run\",{\"1\":{\"139\":2,\"165\":2,\"166\":1,\"167\":2,\"420\":1}}],[\"raised\",{\"1\":{\"517\":1}}],[\"rate\",{\"1\":{\"304\":1,\"324\":1,\"343\":1}}],[\"random是一个随机数工具类\",{\"1\":{\"71\":1}}],[\"random支持直接生成随机数的流\",{\"1\":{\"71\":1}}],[\"random\",{\"1\":{\"71\":8,\"274\":6,\"299\":2,\"327\":1}}],[\"randomaccess\",{\"1\":{\"25\":1}}],[\"rawtypes\",{\"1\":{\"24\":1,\"60\":1}}],[\"record\",{\"1\":{\"672\":5,\"676\":5}}],[\"receiver\",{\"1\":{\"448\":1}}],[\"reason\",{\"1\":{\"517\":6}}],[\"readconfiguration\",{\"1\":{\"667\":1}}],[\"readwrite\",{\"1\":{\"631\":1}}],[\"readonly\",{\"1\":{\"612\":1}}],[\"readonly=\",{\"1\":{\"612\":1}}],[\"readobject\",{\"1\":{\"131\":1,\"133\":1}}],[\"readboolean\",{\"1\":{\"129\":1}}],[\"readline\",{\"1\":{\"112\":1,\"448\":3}}],[\"readlimit\",{\"1\":{\"108\":2}}],[\"read\",{\"1\":{\"91\":5,\"94\":1,\"96\":2,\"105\":1,\"108\":8,\"112\":1,\"126\":1,\"199\":1,\"449\":1,\"454\":2,\"455\":1,\"510\":3}}],[\"reader\",{\"1\":{\"88\":1,\"96\":5,\"112\":6,\"113\":4,\"126\":2,\"448\":4}}],[\"reraise\",{\"1\":{\"517\":1}}],[\"remember\",{\"1\":{\"517\":1}}],[\"removing\",{\"1\":{\"167\":1}}],[\"removelastoccurrence\",{\"1\":{\"44\":1}}],[\"removelast\",{\"1\":{\"44\":1}}],[\"removefirstoccurrence\",{\"1\":{\"44\":1}}],[\"removefirst\",{\"1\":{\"44\":1}}],[\"removed\",{\"1\":{\"23\":3}}],[\"removeif\",{\"1\":{\"23\":1}}],[\"removeall\",{\"1\":{\"23\":1,\"47\":1}}],[\"remove\",{\"1\":{\"23\":2,\"24\":1,\"25\":4,\"32\":3,\"37\":1,\"43\":1,\"47\":1,\"48\":1,\"56\":1,\"66\":2,\"84\":2,\"193\":1,\"285\":2}}],[\"revoke\",{\"1\":{\"502\":1}}],[\"revoke等\",{\"1\":{\"472\":1}}],[\"requiredargsconstructor\",{\"1\":{\"540\":1}}],[\"requiredargsconstructor来快速生成参数只包含final或被标记为\",{\"1\":{\"540\":1}}],[\"requirenonnull\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1}}],[\"requests\",{\"1\":{\"455\":1}}],[\"reinforce\",{\"0\":{\"441\":1,\"442\":1},\"1\":{\"441\":1}}],[\"reinforcement\",{\"0\":{\"288\":1}}],[\"rewards\",{\"0\":{\"328\":1,\"329\":1},\"1\":{\"305\":1,\"330\":2,\"439\":1}}],[\"reward\",{\"1\":{\"298\":1,\"304\":2,\"305\":2,\"400\":1,\"439\":1}}],[\"registeraliases\",{\"1\":{\"632\":1}}],[\"register=fri\",{\"1\":{\"580\":1}}],[\"register\",{\"1\":{\"517\":1,\"577\":1,\"578\":2,\"580\":1}}],[\"registerdriver\",{\"1\":{\"517\":2}}],[\"registereddrivers\",{\"1\":{\"517\":3}}],[\"registered\",{\"1\":{\"516\":1}}],[\"registernatives\",{\"1\":{\"215\":2}}],[\"regexp\",{\"1\":{\"246\":2}}],[\"regular\",{\"1\":{\"246\":1}}],[\"refers\",{\"1\":{\"377\":1}}],[\"references\",{\"1\":{\"167\":1,\"475\":1,\"476\":1}}],[\"reflection\",{\"1\":{\"517\":1}}],[\"reflectiveoperationexception\",{\"1\":{\"192\":2,\"193\":2,\"527\":1}}],[\"reflectiveobjects\",{\"1\":{\"186\":1}}],[\"reflect\",{\"1\":{\"186\":1}}],[\"replay\",{\"0\":{\"428\":1},\"1\":{\"427\":1}}],[\"replace\",{\"1\":{\"66\":2}}],[\"replace方法可以快速替换某个映射的值\",{\"1\":{\"66\":1}}],[\"replaceall\",{\"1\":{\"24\":1}}],[\"representation\",{\"1\":{\"415\":2}}],[\"representing\",{\"1\":{\"183\":1}}],[\"repeatable\",{\"1\":{\"205\":1,\"510\":1}}],[\"re\",{\"1\":{\"167\":1}}],[\"res\",{\"1\":{\"532\":3,\"533\":3}}],[\"restrict|cascade\",{\"1\":{\"479\":1,\"480\":1}}],[\"respect\",{\"1\":{\"304\":1}}],[\"result注解时\",{\"1\":{\"629\":1}}],[\"results\",{\"1\":{\"626\":1,\"629\":1}}],[\"results注解来实现这种操作\",{\"1\":{\"626\":1}}],[\"resultset\",{\"1\":{\"516\":1,\"527\":1,\"532\":1,\"533\":1}}],[\"resultmap\",{\"1\":{\"627\":1}}],[\"resultmap>\",{\"1\":{\"563\":1,\"569\":1,\"577\":1,\"578\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":2,\"626\":1}}],[\"resultmap=\",{\"1\":{\"563\":1,\"569\":1,\"577\":1,\"579\":1,\"582\":1,\"583\":2}}],[\"resulttype无需设置为list这种类型\",{\"1\":{\"564\":1}}],[\"resulttype指定为我们刚刚定义的实体类\",{\"1\":{\"554\":1}}],[\"resulttype=\",{\"1\":{\"554\":1,\"559\":1,\"561\":1,\"562\":1,\"564\":2,\"570\":3,\"571\":1,\"579\":1,\"582\":1,\"583\":1,\"601\":1,\"602\":1,\"614\":1,\"615\":1,\"623\":1,\"630\":1}}],[\"resulting\",{\"1\":{\"304\":1}}],[\"result\",{\"1\":{\"245\":2,\"626\":2,\"629\":2}}],[\"reset\",{\"1\":{\"108\":5}}],[\"resource=\",{\"1\":{\"570\":1}}],[\"resources\",{\"1\":{\"552\":1}}],[\"resource\",{\"1\":{\"92\":1,\"552\":2}}],[\"resource语法会自动帮助我们close\",{\"1\":{\"516\":1}}],[\"resource语法\",{\"1\":{\"90\":1}}],[\"resize\",{\"0\":{\"60\":1},\"1\":{\"59\":2,\"60\":2}}],[\"reduce\",{\"1\":{\"71\":1}}],[\"retrieve\",{\"1\":{\"472\":1}}],[\"retry\",{\"1\":{\"107\":1}}],[\"retention和1\",{\"1\":{\"206\":1}}],[\"retention表示此注解的保留策略\",{\"1\":{\"206\":1}}],[\"retentionpolicy\",{\"1\":{\"206\":2,\"207\":4,\"208\":2}}],[\"retention\",{\"1\":{\"205\":1,\"206\":2,\"207\":4,\"208\":2}}],[\"retainall\",{\"1\":{\"23\":1,\"47\":1}}],[\"returned\",{\"1\":{\"580\":1}}],[\"returning\",{\"1\":{\"517\":1}}],[\"returns\",{\"1\":{\"326\":1}}],[\"return为\",{\"1\":{\"324\":1}}],[\"return的描述\",{\"1\":{\"324\":1}}],[\"return越短视\",{\"1\":{\"304\":1}}],[\"return\",{\"0\":{\"326\":1,\"438\":1},\"1\":{\"7\":1,\"8\":2,\"14\":3,\"15\":1,\"23\":4,\"25\":3,\"33\":2,\"36\":4,\"47\":1,\"59\":3,\"60\":1,\"64\":3,\"65\":3,\"67\":3,\"84\":7,\"107\":1,\"173\":1,\"183\":1,\"199\":1,\"215\":2,\"216\":3,\"220\":1,\"221\":2,\"227\":2,\"257\":2,\"258\":1,\"266\":2,\"282\":2,\"304\":2,\"324\":1,\"326\":3,\"327\":1,\"333\":2,\"363\":1,\"367\":1,\"398\":1,\"422\":1,\"517\":2,\"527\":2,\"538\":3,\"558\":2,\"630\":1,\"632\":1,\"672\":2,\"676\":1}}],[\"uid\",{\"1\":{\"563\":2,\"581\":1,\"582\":1,\"626\":3}}],[\"url=jdbc\",{\"1\":{\"664\":1}}],[\"url=\",{\"1\":{\"554\":1}}],[\"url\",{\"1\":{\"517\":9,\"532\":1,\"533\":1,\"534\":4,\"552\":1}}],[\"utf\",{\"1\":{\"545\":2,\"552\":1,\"554\":1}}],[\"utf8\",{\"1\":{\"477\":2}}],[\"util包下定义的\",{\"1\":{\"23\":1}}],[\"util\",{\"1\":{\"23\":1,\"274\":2,\"275\":1,\"517\":3,\"636\":1,\"655\":1,\"667\":2,\"675\":1,\"679\":2}}],[\"uc\",{\"1\":{\"476\":1}}],[\"ua\",{\"1\":{\"455\":3}}],[\"uavn\",{\"1\":{\"298\":1}}],[\"uavs\",{\"1\":{\"289\":1,\"290\":1}}],[\"uav\",{\"0\":{\"288\":1,\"687\":1},\"1\":{\"289\":1},\"2\":{\"301\":1}}],[\"u0​pu​π1\",{\"1\":{\"355\":1}}],[\"usecache\",{\"1\":{\"631\":1}}],[\"usecache=\",{\"1\":{\"614\":1}}],[\"usegeneratedkeys\",{\"1\":{\"625\":1}}],[\"usegeneratedkeys=\",{\"1\":{\"590\":1,\"625\":1}}],[\"use\",{\"1\":{\"478\":1}}],[\"userdetail\",{\"1\":{\"577\":2,\"578\":1,\"579\":2,\"629\":1}}],[\"user>\",{\"1\":{\"564\":1}}],[\"user类型或是map类型\",{\"1\":{\"564\":1}}],[\"username+\",{\"1\":{\"532\":1,\"533\":1}}],[\"username\",{\"1\":{\"532\":1,\"533\":1,\"552\":1,\"563\":2,\"626\":3}}],[\"username=test\",{\"1\":{\"664\":1}}],[\"username=\",{\"1\":{\"532\":2,\"533\":2}}],[\"user来创建用户\",{\"1\":{\"500\":1}}],[\"user\",{\"1\":{\"455\":2,\"500\":2,\"517\":4,\"526\":2,\"532\":2,\"533\":2,\"534\":11,\"559\":3,\"560\":5,\"561\":3,\"562\":4,\"563\":5,\"564\":11,\"569\":9,\"571\":6,\"577\":2,\"578\":6,\"579\":3,\"580\":3,\"581\":5,\"583\":6,\"589\":4,\"590\":2,\"591\":3,\"592\":1,\"599\":3,\"601\":2,\"602\":2,\"604\":1,\"605\":8,\"614\":2,\"615\":2,\"623\":2,\"624\":4,\"625\":5,\"626\":3,\"627\":1,\"628\":3,\"629\":3,\"630\":6,\"631\":2}}],[\"users\",{\"1\":{\"289\":2,\"599\":2,\"604\":1,\"605\":2}}],[\"uses\",{\"1\":{\"367\":1}}],[\"used\",{\"1\":{\"139\":1}}],[\"u\",{\"1\":{\"246\":2,\"501\":1}}],[\"upgrade\",{\"1\":{\"455\":1}}],[\"updateagebyid\",{\"1\":{\"611\":2}}],[\"update>\",{\"1\":{\"591\":1}}],[\"update\",{\"1\":{\"308\":1,\"348\":3,\"355\":2,\"472\":2,\"483\":1,\"509\":2,\"524\":1,\"588\":2,\"591\":1,\"612\":1}}],[\"up\",{\"1\":{\"191\":1,\"192\":1}}],[\"unwrapthrowable\",{\"1\":{\"569\":1}}],[\"unnecessary\",{\"1\":{\"516\":1}}],[\"uncommitted\",{\"1\":{\"510\":1}}],[\"unchecked\",{\"1\":{\"24\":1,\"60\":1,\"183\":1}}],[\"und\",{\"1\":{\"455\":1}}],[\"unique\",{\"1\":{\"475\":2,\"476\":1,\"508\":1}}],[\"uniqueness\",{\"1\":{\"343\":1}}],[\"uniform\",{\"0\":{\"419\":1}}],[\"unmanned\",{\"1\":{\"289\":1}}],[\"unmodifiablelist\",{\"1\":{\"79\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"25\":1,\"32\":1,\"285\":2}}],[\"unaryoperator<e>\",{\"1\":{\"24\":1}}],[\"跟jdbc是一样的\",{\"1\":{\"558\":1}}],[\"跟随一个\",{\"1\":{\"439\":1}}],[\"跟随策略π\",{\"1\":{\"366\":1}}],[\"跟对象成员变量的默认值是一样的\",{\"1\":{\"235\":1}}],[\"跟普通的类一样\",{\"1\":{\"219\":1}}],[\"跟普通方法是一样的\",{\"1\":{\"9\":1}}],[\"跟之前的\",{\"1\":{\"62\":1}}],[\"跟next相反\",{\"1\":{\"37\":1}}],[\"跟我们之前不一样\",{\"1\":{\"58\":1}}],[\"跟我们之前的顺序表思路差不多\",{\"1\":{\"25\":1}}],[\"跟我们之前顺序表的插入是一样的\",{\"1\":{\"24\":1}}],[\"将日志利用socket通过网络发送到另一个主机\",{\"1\":{\"646\":1}}],[\"将日志直接写入到指定的文件中\",{\"1\":{\"646\":1}}],[\"将日志通过system\",{\"1\":{\"646\":1}}],[\"将1号用户的id改成100\",{\"1\":{\"616\":1}}],[\"将不会通过反射给字段单独赋值\",{\"1\":{\"569\":1}}],[\"将不会执行commit\",{\"1\":{\"534\":1}}],[\"将所有的子标签全部包含\",{\"1\":{\"545\":1}}],[\"将所有状态的\",{\"1\":{\"331\":1}}],[\"将接口和\",{\"1\":{\"544\":1}}],[\"将数据转换为我们可以直接操作的实体类型\",{\"1\":{\"544\":1}}],[\"将sql语句的提交\",{\"1\":{\"534\":1}}],[\"将查询结果映射为对象\",{\"0\":{\"527\":1}}],[\"将删除表中全部数据\",{\"1\":{\"484\":1}}],[\"将使得整个表中此列的所有数据都被修改\",{\"1\":{\"483\":1}}],[\"将服务端创建在端口8080上\",{\"1\":{\"447\":2,\"455\":1}}],[\"将基于表格表示的策略\",{\"1\":{\"433\":1}}],[\"将该网络的\",{\"1\":{\"427\":1}}],[\"将\",{\"1\":{\"343\":1,\"370\":1,\"427\":2}}],[\"将处于\",{\"1\":{\"314\":1}}],[\"将对于\",{\"1\":{\"308\":1}}],[\"将对应的轨迹所获得的所有reward的总和\",{\"1\":{\"304\":1}}],[\"将无法删除\",{\"1\":{\"479\":1}}],[\"将无法通过编译\",{\"1\":{\"264\":1,\"281\":1}}],[\"将无人机部署在每个中心内\",{\"1\":{\"298\":1}}],[\"将上述优化问题简化\",{\"1\":{\"298\":1}}],[\"将上一个已遍历元素修改为新的元素\",{\"1\":{\"37\":1}}],[\"将其配置为jdk\",{\"1\":{\"679\":1}}],[\"将其设定为stdout\",{\"1\":{\"679\":1}}],[\"将其平均分配给其∣kn​∣个关联用户\",{\"1\":{\"294\":1}}],[\"将其中的抽象方法实现\",{\"1\":{\"255\":1}}],[\"将抛出\",{\"1\":{\"268\":1}}],[\"将匹配\",{\"1\":{\"246\":1}}],[\"将匹配的子串替换或者从某个串中取出符合某个条件的子串等\",{\"1\":{\"246\":1}}],[\"将这些值提前做成包装类放在数组中存放\",{\"1\":{\"227\":1}}],[\"将int类型值作为包装类型使用\",{\"1\":{\"227\":1}}],[\"将当前对象转换为string的形式\",{\"1\":{\"215\":1}}],[\"将test\",{\"1\":{\"192\":1}}],[\"将变量的值给予threadlocal\",{\"1\":{\"162\":2}}],[\"将cpu资源让位给其他线程\",{\"1\":{\"147\":1}}],[\"将文件内容作为输入流进行扫描\",{\"1\":{\"128\":1}}],[\"将它们以字符串的形式写入到输出流\",{\"1\":{\"127\":1}}],[\"将main类放到com\",{\"1\":{\"120\":1}}],[\"将缓冲区大小设置为1\",{\"1\":{\"108\":1}}],[\"将每一个元素映射为integer类型\",{\"1\":{\"71\":1}}],[\"将会无限进行下去\",{\"1\":{\"71\":1}}],[\"将底层数组变成新的扩容之后的数组\",{\"1\":{\"60\":1}}],[\"将另一个map中的所有键值对添加到当前map中\",{\"1\":{\"56\":1}}],[\"将元素从栈顶出栈\",{\"1\":{\"44\":1}}],[\"将元素推向栈顶\",{\"1\":{\"44\":1}}],[\"将给定集合中所有元素插入到当前结合的给定位置上\",{\"1\":{\"24\":1}}],[\"将集合转换为数组的形式\",{\"1\":{\"23\":1}}],[\"功能还会更多一些\",{\"1\":{\"24\":1}}],[\"相关操作\",{\"1\":{\"665\":1}}],[\"相应的算法是\",{\"1\":{\"397\":1}}],[\"相应的\",{\"1\":{\"389\":1,\"395\":1}}],[\"相等于\",{\"1\":{\"246\":1}}],[\"相当于在程序运行过程中动态生成了一个实现类\",{\"1\":{\"570\":1}}],[\"相当于没有启动事务\",{\"1\":{\"534\":1}}],[\"相当于没有头结点的链表\",{\"1\":{\"58\":1}}],[\"相当于一个指针\",{\"1\":{\"507\":1}}],[\"相当于\",{\"1\":{\"219\":1}}],[\"相信各位就能感受到注解带来的魅力了\",{\"1\":{\"208\":1}}],[\"相比直接添加约束\",{\"1\":{\"509\":1}}],[\"相比reader更方便的是\",{\"1\":{\"112\":1}}],[\"相比之前的collection接口定义\",{\"1\":{\"24\":1}}],[\"相同之处\",{\"1\":{\"22\":1}}],[\"其求解梯度比较难求\",{\"1\":{\"427\":1}}],[\"其定义都是一个均值\",{\"1\":{\"377\":1}}],[\"其探索性就很强\",{\"1\":{\"372\":1}}],[\"其属于\",{\"1\":{\"372\":1}}],[\"其原始定义都是从期望出发的\",{\"1\":{\"360\":1}}],[\"其核心思想是\",{\"1\":{\"360\":1}}],[\"其策略π表示的是最优策略\",{\"1\":{\"340\":1}}],[\"其目标也应该不一样\",{\"1\":{\"298\":1}}],[\"其状态为其3d坐标\",{\"1\":{\"298\":1}}],[\"其高度的下界是距离dkn​​\",{\"1\":{\"294\":1}}],[\"其每个用户带宽表示为\",{\"1\":{\"294\":1}}],[\"其可用带宽为bn​\",{\"1\":{\"294\":1}}],[\"其水平坐标表示为qn​\",{\"1\":{\"293\":1}}],[\"其垂直高度表示为hn​\",{\"1\":{\"293\":1}}],[\"其坐标表示为wkn​​=\",{\"1\":{\"293\":1}}],[\"其子类的对应的方法的访问权限需要高于抽象类中的方法\",{\"1\":{\"218\":1}}],[\"其返回值定义了该成员变量的类型\",{\"1\":{\"207\":1}}],[\"其方法名定义了该成员变量的名字\",{\"1\":{\"207\":1}}],[\"其对应的\",{\"1\":{\"186\":1,\"348\":1}}],[\"其实缓存机制我们在之前学习io流的时候已经提及过了\",{\"1\":{\"610\":1}}],[\"其实idea本质也是使用的jdbc\",{\"1\":{\"516\":1}}],[\"其实自身连接查询和前面的是一样的\",{\"1\":{\"496\":1}}],[\"其实本质上都差不多\",{\"1\":{\"454\":1}}],[\"其实本质上是定义在对应的包装类中的\",{\"1\":{\"183\":1}}],[\"其实枚举类型的本质就是一个普通的类\",{\"1\":{\"221\":1}}],[\"其实不是\",{\"1\":{\"208\":1}}],[\"其实也就是基本类型的class\",{\"1\":{\"183\":1}}],[\"其实就是一个多线程执行的流\",{\"1\":{\"173\":1}}],[\"其实就是编写要在另一个线程执行的内容逻辑\",{\"1\":{\"139\":1}}],[\"其实我们可以看到\",{\"1\":{\"133\":1}}],[\"其实system\",{\"1\":{\"127\":1}}],[\"其实和bufferedinputstream原理差不多\",{\"1\":{\"110\":1}}],[\"其实mark\",{\"1\":{\"108\":1}}],[\"其实功能和write一样\",{\"1\":{\"97\":1}}],[\"其他情况的必须满足大于18岁\",{\"1\":{\"602\":1}}],[\"其他情况e都是null\",{\"1\":{\"59\":1}}],[\"其他的算法\",{\"1\":{\"441\":1}}],[\"其他的情况会在讲到反射时介绍\",{\"1\":{\"118\":1}}],[\"其他很多语言比如javascript\",{\"1\":{\"246\":1}}],[\"其他定义方法\",{\"1\":{\"235\":1}}],[\"其他地方不能修改\",{\"1\":{\"217\":1}}],[\"其他线程都无法访问被它占用的锁\",{\"1\":{\"156\":1}}],[\"其他视图操作\",{\"1\":{\"56\":1}}],[\"其他集合类实现\",{\"0\":{\"45\":1}}],[\"其他遍历\",{\"0\":{\"35\":1}}],[\"其他元素一律移除\",{\"1\":{\"23\":1}}],[\"其中参数为logrecord\",{\"1\":{\"672\":1}}],[\"其中test属性就是我们需要填写的判断条件\",{\"1\":{\"601\":1}}],[\"其中uid作为用户id的逻辑外键\",{\"1\":{\"581\":1}}],[\"其中book表设计如下\",{\"1\":{\"581\":1}}],[\"其中property就是需要进行一对一处理的对象\",{\"1\":{\"578\":1}}],[\"其中public和abstract关键字可以省略\",{\"1\":{\"219\":1}}],[\"其中一些字符被用作标签表示\",{\"1\":{\"564\":1}}],[\"其中namespace就是命名空间\",{\"1\":{\"554\":1}}],[\"其中restrict和cascade上面的效果一致\",{\"1\":{\"480\":1}}],[\"其中st​是随机变量s的一个样本\",{\"1\":{\"421\":1}}],[\"其中w∈rm是参数向量\",{\"1\":{\"416\":1}}],[\"其中hk​=wk​\",{\"1\":{\"383\":1}}],[\"其中all代表授予所有权限\",{\"1\":{\"502\":1}}],[\"其中ak∗​=argmaxa​qπk​​\",{\"1\":{\"364\":1}}],[\"其中ak∗​\",{\"1\":{\"348\":1}}],[\"其中a∗表示在该状态下计算出来的最大\",{\"1\":{\"342\":1}}],[\"其中vk​是给定的\",{\"1\":{\"348\":1}}],[\"其中f\",{\"1\":{\"343\":1}}],[\"其中cmax​表示用户的最大速度\",{\"1\":{\"299\":1}}],[\"其中σ2=bkn​​n0​\",{\"1\":{\"294\":1}}],[\"其中θkn​​\",{\"1\":{\"294\":1}}],[\"其中k0​=\",{\"1\":{\"294\":1}}],[\"其中kn​表示划分到集群n的用户\",{\"1\":{\"293\":1}}],[\"其中k就是键的类型\",{\"1\":{\"56\":1}}],[\"其中用户表示为k=k1​\",{\"1\":{\"293\":1}}],[\"其中存放的每一个数据称为数组的一个元素\",{\"1\":{\"234\":1}}],[\"其中能够表示数字的基本类型包装类\",{\"1\":{\"227\":1}}],[\"其中的\",{\"1\":{\"120\":1}}],[\"其中\",{\"1\":{\"42\":1,\"246\":1,\"294\":1,\"295\":2,\"331\":1,\"351\":1,\"372\":1,\"381\":1,\"382\":1,\"386\":1,\"395\":1,\"397\":1,\"398\":1,\"401\":1,\"420\":1,\"426\":1,\"433\":1,\"438\":1,\"440\":1,\"462\":1,\"516\":1,\"604\":1,\"612\":1}}],[\"其中最突出的就是直接根据下标位置进行的增删改查操作\",{\"1\":{\"24\":1}}],[\"其中很多地方重新定义了一次\",{\"1\":{\"24\":1}}],[\"其变量名存储的是对象的引用\",{\"1\":{\"4\":1}}],[\"hh\",{\"1\":{\"676\":1}}],[\"here\",{\"1\":{\"517\":2}}],[\"headquarters\",{\"1\":{\"476\":1}}],[\"hello\",{\"1\":{\"5\":2,\"14\":2,\"110\":1,\"244\":6,\"253\":1,\"640\":1,\"647\":2,\"667\":1}}],[\"host\",{\"1\":{\"455\":1}}],[\"hybrid\",{\"1\":{\"299\":1}}],[\"huav​\",{\"1\":{\"298\":2,\"299\":2}}],[\"hugecapacity\",{\"1\":{\"25\":1}}],[\"hmax​−hmin​+1\",{\"1\":{\"298\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​moskn​​\",{\"1\":{\"298\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​∑t=0ts​​moskn​​\",{\"1\":{\"296\":1}}],[\"hmax​\",{\"1\":{\"293\":1,\"298\":1}}],[\"hmin​≤hn​\",{\"1\":{\"296\":1,\"298\":1}}],[\"hmin​\",{\"1\":{\"293\":1,\"298\":1}}],[\"handlers=java\",{\"1\":{\"667\":1,\"679\":1}}],[\"handler是属于对应的logger的\",{\"1\":{\"656\":1}}],[\"handler\",{\"1\":{\"640\":1,\"646\":1,\"647\":2,\"648\":2,\"649\":3,\"667\":1}}],[\"have\",{\"1\":{\"517\":1}}],[\"having\",{\"1\":{\"494\":1}}],[\"hard问题\",{\"1\":{\"298\":1}}],[\"hard\",{\"1\":{\"290\":1}}],[\"has\",{\"1\":{\"343\":1,\"517\":1}}],[\"hashtable<object\",{\"1\":{\"665\":1}}],[\"hash\",{\"1\":{\"58\":1,\"59\":13,\"61\":2,\"84\":1,\"508\":1}}],[\"hashmap的一个链表长度过大时\",{\"1\":{\"60\":1}}],[\"hashmap并不是只使用简单的链地址法\",{\"1\":{\"58\":1}}],[\"hashmap支持自动扩容\",{\"1\":{\"58\":1}}],[\"hashmap<e\",{\"1\":{\"67\":1}}],[\"hashmap<k\",{\"1\":{\"58\":1}}],[\"hashmap<>\",{\"1\":{\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"67\":1,\"84\":1}}],[\"hashmap\",{\"0\":{\"57\":1,\"58\":1,\"561\":1},\"1\":{\"48\":1,\"49\":1,\"57\":1,\"58\":2,\"61\":3,\"67\":3,\"561\":1,\"562\":1}}],[\"hashset<e>\",{\"1\":{\"67\":1}}],[\"hashset<>\",{\"1\":{\"48\":3}}],[\"hashset\",{\"0\":{\"48\":1,\"67\":1},\"1\":{\"48\":1,\"67\":5}}],[\"hashcode\",{\"1\":{\"23\":1,\"47\":1,\"56\":1,\"84\":7,\"215\":3}}],[\"hasprevious\",{\"1\":{\"37\":1}}],[\"hasnext\",{\"1\":{\"23\":1,\"24\":1,\"30\":1,\"32\":3,\"34\":1,\"36\":1,\"37\":1}}],[\"hint\",{\"0\":{\"285\":1,\"686\":1},\"2\":{\"287\":1}}],[\"high\",{\"1\":{\"227\":1}}],[\"http是一种应用层协议\",{\"1\":{\"455\":1}}],[\"http\",{\"1\":{\"455\":5,\"552\":1,\"554\":1}}],[\"http请求是基于tcp协议\",{\"1\":{\"455\":1}}],[\"https\",{\"1\":{\"246\":1,\"539\":1,\"552\":1,\"580\":1,\"601\":1,\"630\":1}}],[\"html主要用于通过编排来展示数据\",{\"1\":{\"545\":1}}],[\"html\",{\"1\":{\"246\":1,\"455\":1,\"552\":1,\"630\":1}}],[\"h\",{\"1\":{\"229\":2}}],[\"wrapexception\",{\"1\":{\"571\":1}}],[\"writeobject\",{\"1\":{\"131\":1,\"133\":1}}],[\"writeboolean\",{\"1\":{\"129\":1}}],[\"write\",{\"1\":{\"92\":3,\"93\":1,\"94\":1,\"97\":1,\"110\":1,\"113\":1,\"126\":1,\"448\":3,\"454\":2,\"455\":3}}],[\"writer不会主动加\",{\"1\":{\"448\":1}}],[\"writer除了write方法外\",{\"1\":{\"97\":1}}],[\"writer\",{\"1\":{\"88\":1,\"97\":5,\"126\":2,\"448\":7,\"455\":5}}],[\"w3c的xml解析库\",{\"1\":{\"547\":1}}],[\"web\",{\"1\":{\"632\":1}}],[\"webp\",{\"1\":{\"455\":1}}],[\"weak\",{\"1\":{\"612\":1}}],[\"we\",{\"1\":{\"517\":3}}],[\"wt+1​=wt​+αt​n1​i=1∑n​\",{\"1\":{\"427\":1}}],[\"wt​=w\",{\"1\":{\"427\":1}}],[\"wt​\",{\"1\":{\"421\":2,\"422\":2,\"423\":4,\"424\":3,\"425\":3,\"427\":10}}],[\"w−e\",{\"1\":{\"384\":1,\"395\":1}}],[\"w∗\",{\"1\":{\"383\":2}}],[\"w∈r\",{\"1\":{\"381\":1}}],[\"wk−1​\",{\"1\":{\"383\":1}}],[\"wk​−\",{\"1\":{\"395\":1}}],[\"wk​−xk​\",{\"1\":{\"379\":2,\"384\":1}}],[\"wk​\",{\"1\":{\"382\":6,\"383\":1,\"384\":1,\"386\":6,\"389\":12,\"395\":1,\"421\":1}}],[\"wk​+xk​\",{\"1\":{\"379\":1}}],[\"wk​=k−11​i=1∑k−1​xi​\",{\"1\":{\"379\":1}}],[\"wk+1​=wk​+αk​\",{\"1\":{\"421\":1,\"422\":1,\"423\":1,\"424\":1,\"425\":1}}],[\"wk+1​=wk​−αk​g~​\",{\"1\":{\"395\":1}}],[\"wk+1​=wk​−αk​g​\",{\"1\":{\"384\":1,\"389\":1}}],[\"wk+1​=wk​−αk​e\",{\"1\":{\"389\":1}}],[\"wk+1​=wk​−αk​▽w​j\",{\"1\":{\"421\":1}}],[\"wk+1​=wk​−αk​▽w​f\",{\"1\":{\"386\":1}}],[\"wk+1​=wk​−αk​▽w​e\",{\"1\":{\"386\":1}}],[\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f\",{\"1\":{\"386\":1}}],[\"wk+1​=wk​−ak​g​\",{\"1\":{\"382\":1}}],[\"wk+1​=wk​−k1​\",{\"1\":{\"379\":1}}],[\"wk+1​=k1​i=1∑k​xi​\",{\"1\":{\"379\":1}}],[\"wk+1​​=k1​∑i=1k​xi​​=k1​\",{\"1\":{\"379\":1}}],[\"wk+1​可以由wk​推导出来\",{\"1\":{\"379\":1}}],[\"wireless\",{\"1\":{\"289\":1}}],[\"with\",{\"0\":{\"422\":1,\"423\":1,\"424\":1,\"425\":1},\"1\":{\"90\":1,\"92\":1,\"167\":1,\"295\":1,\"304\":2,\"383\":1,\"502\":1,\"507\":2,\"516\":1,\"517\":1}}],[\"w\",{\"1\":{\"246\":1,\"381\":3,\"382\":2,\"383\":3,\"384\":5,\"386\":5,\"389\":15,\"395\":4,\"416\":1,\"417\":1,\"418\":2,\"419\":3,\"420\":3,\"421\":6,\"426\":3,\"427\":21}}],[\"worker\",{\"1\":{\"218\":2}}],[\"world\",{\"1\":{\"14\":1,\"244\":6,\"640\":1,\"647\":2,\"667\":1}}],[\"which\",{\"1\":{\"517\":1}}],[\"while\",{\"1\":{\"23\":1,\"24\":1,\"30\":1,\"32\":1,\"34\":1,\"91\":1,\"94\":1,\"107\":1,\"144\":1,\"165\":1,\"167\":1,\"172\":2,\"174\":3,\"447\":1,\"454\":2,\"455\":3,\"516\":1,\"525\":1,\"527\":2,\"532\":1,\"533\":1,\"616\":1}}],[\"why\",{\"0\":{\"332\":1}}],[\"where等操作\",{\"1\":{\"630\":1}}],[\"where子句组成的查询块\",{\"1\":{\"472\":1}}],[\"where\",{\"1\":{\"331\":1,\"343\":1,\"483\":1,\"484\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":2,\"495\":2,\"498\":2,\"507\":1,\"509\":1,\"524\":2,\"532\":2,\"533\":2,\"559\":2,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"569\":1,\"570\":2,\"571\":2,\"578\":1,\"579\":2,\"580\":2,\"581\":1,\"582\":2,\"583\":1,\"591\":1,\"592\":1,\"601\":1,\"602\":1,\"604\":2,\"614\":1,\"615\":1,\"629\":2,\"630\":4,\"631\":1}}],[\"when>\",{\"1\":{\"602\":2}}],[\"when\",{\"1\":{\"139\":1,\"167\":1,\"304\":1,\"517\":1}}],[\"what\",{\"1\":{\"191\":1,\"192\":1}}],[\"whatsoever\",{\"1\":{\"139\":1}}],[\"www\",{\"1\":{\"120\":1,\"246\":1,\"580\":2}}],[\"warning\",{\"1\":{\"638\":4,\"639\":1}}],[\"wargmin​j\",{\"1\":{\"386\":1}}],[\"walk\",{\"1\":{\"299\":2,\"517\":1}}],[\"waiting\",{\"1\":{\"161\":1}}],[\"wait需要捕获\",{\"1\":{\"161\":1}}],[\"wait\",{\"1\":{\"161\":6,\"167\":2,\"174\":1,\"215\":3}}],[\"was\",{\"1\":{\"107\":1}}],[\"wang\",{\"1\":{\"65\":3}}],[\"fk\",{\"1\":{\"476\":1}}],[\"fetch\",{\"1\":{\"455\":4}}],[\"fulltest\",{\"1\":{\"508\":1}}],[\"fundamental\",{\"1\":{\"337\":1}}],[\"function\",{\"0\":{\"415\":1,\"418\":1,\"422\":1,\"423\":1,\"424\":1,\"425\":1},\"1\":{\"241\":1,\"325\":1,\"343\":1,\"415\":1,\"419\":2,\"420\":1,\"421\":1,\"426\":1,\"427\":1,\"432\":1,\"433\":1}}],[\"functionalinterface\",{\"1\":{\"139\":1,\"204\":1}}],[\"future\",{\"0\":{\"329\":1},\"1\":{\"330\":1}}],[\"fs\",{\"1\":{\"295\":1}}],[\"fs​+l\",{\"1\":{\"295\":1}}],[\"fc​是载波频率\",{\"1\":{\"294\":1}}],[\"free\",{\"0\":{\"360\":1},\"1\":{\"330\":1,\"361\":1,\"362\":1}}],[\"framework\",{\"1\":{\"289\":1}}],[\"from子句\",{\"1\":{\"472\":1}}],[\"from\",{\"1\":{\"167\":1,\"221\":1,\"326\":1,\"333\":2,\"484\":2,\"490\":5,\"492\":2,\"493\":1,\"494\":4,\"495\":3,\"496\":1,\"497\":2,\"498\":2,\"502\":1,\"507\":2,\"508\":1,\"509\":1,\"516\":1,\"517\":1,\"524\":1,\"532\":2,\"533\":2,\"554\":1,\"559\":2,\"561\":1,\"562\":1,\"563\":1,\"564\":2,\"569\":1,\"570\":3,\"571\":2,\"578\":1,\"579\":2,\"580\":2,\"581\":1,\"582\":2,\"583\":4,\"592\":1,\"601\":1,\"602\":1,\"604\":2,\"614\":1,\"615\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":1,\"628\":1,\"629\":2,\"630\":3,\"631\":1}}],[\"fromindex\",{\"1\":{\"24\":1}}],[\"found\",{\"1\":{\"517\":2,\"569\":1,\"571\":1,\"682\":1}}],[\"foem\",{\"1\":{\"340\":1}}],[\"following\",{\"1\":{\"304\":1}}],[\"fooooood\",{\"1\":{\"246\":1}}],[\"foooood\",{\"1\":{\"246\":1}}],[\"food\",{\"1\":{\"246\":1}}],[\"foreign\",{\"1\":{\"475\":2,\"476\":1}}],[\"foreach>\",{\"1\":{\"604\":1,\"605\":1}}],[\"foreach操作\",{\"1\":{\"603\":1}}],[\"foreach操作的顺序\",{\"1\":{\"173\":1}}],[\"foreach语法遍历每一个元素\",{\"1\":{\"35\":1}}],[\"foreach\",{\"1\":{\"35\":5,\"36\":2,\"65\":2,\"71\":1,\"112\":1,\"173\":1,\"237\":1,\"554\":1,\"558\":1,\"570\":1}}],[\"foreachremaining\",{\"1\":{\"32\":1}}],[\"forallw\",{\"1\":{\"383\":1}}],[\"foralls∈s\",{\"1\":{\"364\":1}}],[\"fortheother∣a\",{\"1\":{\"372\":1}}],[\"format\",{\"1\":{\"672\":2,\"676\":3}}],[\"formatter=com\",{\"1\":{\"675\":1}}],[\"formatter\",{\"1\":{\"667\":5,\"672\":1}}],[\"formulation\",{\"0\":{\"390\":1}}],[\"form\",{\"0\":{\"331\":1},\"1\":{\"331\":1,\"332\":1,\"334\":2,\"340\":1,\"343\":1,\"348\":1,\"351\":2,\"630\":1}}],[\"forname\",{\"1\":{\"182\":1,\"192\":3,\"516\":1}}],[\"for\",{\"1\":{\"24\":1,\"25\":1,\"30\":2,\"34\":1,\"35\":1,\"36\":1,\"59\":1,\"98\":1,\"138\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"161\":1,\"167\":1,\"172\":2,\"183\":1,\"186\":5,\"192\":1,\"208\":2,\"237\":3,\"241\":1,\"242\":1,\"244\":1,\"274\":1,\"289\":2,\"305\":1,\"338\":2,\"343\":1,\"476\":1,\"509\":2,\"517\":4,\"527\":1,\"547\":1,\"564\":1,\"599\":2,\"604\":1,\"605\":1}}],[\"flushcachepolicy\",{\"1\":{\"631\":1}}],[\"flushcache\",{\"1\":{\"631\":1}}],[\"flushcache=\",{\"1\":{\"615\":1}}],[\"flushcache=true\",{\"1\":{\"612\":1}}],[\"flushinterval用于控制缓存刷新时间\",{\"1\":{\"612\":1}}],[\"flushinterval=\",{\"1\":{\"612\":1}}],[\"flushstatements\",{\"1\":{\"599\":1}}],[\"flush\",{\"1\":{\"92\":1,\"93\":1,\"97\":1,\"113\":1,\"131\":1,\"133\":1,\"448\":2,\"454\":2,\"455\":1}}],[\"flatmap\",{\"1\":{\"71\":1}}],[\"float用于存储单精度小数\",{\"1\":{\"474\":1}}],[\"float\",{\"1\":{\"58\":1,\"227\":2}}],[\"f\",{\"1\":{\"71\":1,\"98\":2,\"343\":4,\"386\":3,\"389\":1,\"526\":1}}],[\"failed\",{\"1\":{\"517\":1}}],[\"fair\",{\"1\":{\"295\":1}}],[\"fast\",{\"1\":{\"343\":1}}],[\"fastremove\",{\"1\":{\"25\":1}}],[\"factory\",{\"1\":{\"547\":2,\"599\":1}}],[\"factor\",{\"1\":{\"58\":1,\"60\":1}}],[\"false\",{\"1\":{\"23\":2,\"25\":1,\"59\":1,\"84\":2,\"129\":1,\"139\":1,\"167\":1,\"216\":2,\"268\":1,\"534\":5,\"593\":2,\"612\":2,\"614\":1,\"631\":2,\"646\":1}}],[\"fifo\",{\"1\":{\"612\":2}}],[\"finest\",{\"1\":{\"638\":4,\"640\":2,\"656\":1}}],[\"finer\",{\"1\":{\"638\":4}}],[\"fine\",{\"1\":{\"638\":4,\"640\":1}}],[\"finding\",{\"1\":{\"377\":1,\"389\":1,\"395\":1}}],[\"final字段无法生成set方法\",{\"1\":{\"540\":1}}],[\"final类型\",{\"1\":{\"236\":1}}],[\"final的status类型成员变量\",{\"1\":{\"221\":1}}],[\"final的\",{\"1\":{\"219\":1}}],[\"finalize\",{\"1\":{\"215\":1}}],[\"finally\",{\"1\":{\"90\":1,\"167\":1,\"267\":1}}],[\"final\",{\"1\":{\"15\":3,\"23\":1,\"24\":1,\"25\":2,\"58\":3,\"59\":1,\"60\":1,\"65\":3,\"67\":1,\"127\":1,\"132\":1,\"133\":1,\"167\":2,\"174\":1,\"183\":1,\"193\":1,\"215\":6,\"217\":2,\"221\":5,\"239\":1,\"251\":2,\"252\":1,\"253\":1,\"256\":3,\"638\":7,\"640\":2,\"667\":4}}],[\"fix\",{\"1\":{\"343\":1}}],[\"field\",{\"1\":{\"193\":13,\"199\":3}}],[\"filehandler\",{\"1\":{\"646\":2,\"648\":2,\"649\":1}}],[\"files\",{\"1\":{\"110\":1}}],[\"file\",{\"1\":{\"98\":19,\"547\":1,\"554\":1,\"569\":1}}],[\"filenotfoundexception\",{\"1\":{\"90\":1,\"128\":1,\"266\":2,\"552\":1,\"554\":1,\"558\":1}}],[\"filewriter\",{\"1\":{\"88\":1,\"95\":1,\"97\":2,\"113\":1,\"666\":1}}],[\"filereader\",{\"1\":{\"88\":1,\"95\":1,\"96\":4,\"112\":3,\"665\":1}}],[\"fileoutputstream\",{\"1\":{\"88\":1,\"92\":4,\"93\":2,\"94\":2,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"454\":5}}],[\"fileinputstream\",{\"1\":{\"88\":1,\"90\":4,\"91\":6,\"94\":2,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"126\":1,\"128\":1,\"129\":1,\"131\":1,\"133\":1,\"199\":2,\"454\":4,\"554\":1,\"558\":1,\"667\":1}}],[\"fill\",{\"1\":{\"78\":1,\"107\":1,\"275\":1}}],[\"filter\",{\"1\":{\"23\":3,\"71\":4,\"667\":3}}],[\"first\",{\"1\":{\"25\":1,\"366\":1,\"517\":1}}],[\"添加后\",{\"1\":{\"678\":1}}],[\"添加了二级缓存之后\",{\"1\":{\"613\":1}}],[\"添加每一条批处理语句\",{\"1\":{\"526\":1}}],[\"添加\",{\"1\":{\"524\":1}}],[\"添加回滚点\",{\"1\":{\"510\":1}}],[\"添加点内容的话\",{\"1\":{\"242\":1}}],[\"添加元素只有在当前set集合中不存在此元素时才会成功\",{\"1\":{\"47\":1}}],[\"添加的是一个对象\",{\"1\":{\"25\":1}}],[\"添加integer的值10\",{\"1\":{\"25\":1}}],[\"添加成功返回true\",{\"1\":{\"23\":1}}],[\"添加给定集合中所有的元素\",{\"1\":{\"23\":1}}],[\"从这章开始时基于\",{\"1\":{\"432\":1}}],[\"从\",{\"1\":{\"389\":1}}],[\"从给定的\",{\"1\":{\"367\":1}}],[\"从状态\",{\"1\":{\"363\":1,\"422\":1}}],[\"从状态st​到st+1​\",{\"1\":{\"298\":1}}],[\"从指定的\",{\"1\":{\"363\":1}}],[\"从此可以发现\",{\"1\":{\"362\":1}}],[\"从而修改我们对应的实体类\",{\"1\":{\"625\":1}}],[\"从而满足第三范式\",{\"1\":{\"466\":1}}],[\"从而可以进行近似求解\",{\"1\":{\"440\":1}}],[\"从而可以在\",{\"1\":{\"400\":1}}],[\"从而方便计算\",{\"1\":{\"427\":1}}],[\"从而使得算法可行\",{\"1\":{\"421\":1}}],[\"从而生成经验数据的策略\",{\"1\":{\"406\":1}}],[\"从而引入\",{\"1\":{\"390\":1}}],[\"从而转换为一个\",{\"1\":{\"389\":1}}],[\"从而进行多次利用\",{\"1\":{\"366\":1}}],[\"从而选择每个状态下最大的\",{\"1\":{\"362\":1}}],[\"从而减小方差\",{\"1\":{\"310\":1}}],[\"从而最大化所有用户的总mos值\",{\"1\":{\"296\":1}}],[\"从而其它被阻塞在这个锁的线程才可以继续执行\",{\"1\":{\"156\":1}}],[\"从无人机n到用户kn​的信道功率增益\",{\"1\":{\"294\":1}}],[\"从java8开始\",{\"1\":{\"219\":1}}],[\"从已知的一个类中派生出一个新的类\",{\"1\":{\"212\":1}}],[\"从队列中删除最后一个出现的指定元素\",{\"1\":{\"44\":1}}],[\"从队列中删除第一个出现的指定元素\",{\"1\":{\"44\":1}}],[\"从数学角度来说\",{\"1\":{\"23\":4}}],[\"从集合中移除某个元素\",{\"1\":{\"23\":1}}],[\"同学\",{\"1\":{\"569\":1}}],[\"同名的方法\",{\"1\":{\"219\":1}}],[\"同一无人机通过fdma同时为同一集群中的多个用户提供服务\",{\"1\":{\"293\":1}}],[\"同一消息根据不同的对象而采用各种不同的方法\",{\"1\":{\"212\":1}}],[\"同一个包下的类\",{\"1\":{\"121\":1}}],[\"同构造方法一样\",{\"1\":{\"192\":1}}],[\"同步代码块内部\",{\"1\":{\"161\":1}}],[\"同理\",{\"1\":{\"96\":1,\"103\":1,\"304\":1}}],[\"同read一样\",{\"1\":{\"92\":1}}],[\"同时查询user\",{\"1\":{\"579\":1}}],[\"同时将用户的详细信息包含在内\",{\"1\":{\"577\":1}}],[\"同时id作为操作的名称\",{\"1\":{\"554\":1}}],[\"同时如果字段名称发生改变\",{\"1\":{\"538\":1}}],[\"同时数据库能够为我们提供高效的访问性能\",{\"1\":{\"460\":1}}],[\"同时告知上一级方法执行出现了问题\",{\"1\":{\"266\":1}}],[\"同时也会占用磁盘资源\",{\"1\":{\"508\":1}}],[\"同时也会生成一个class对象存放在内存\",{\"1\":{\"180\":1}}],[\"同时也使得基本类型能够支持对象操作\",{\"1\":{\"226\":1}}],[\"同时具体实现还需要由主体来实现\",{\"1\":{\"219\":1}}],[\"同时还能获取到注解中填入的值\",{\"1\":{\"208\":1}}],[\"同时此注解可以作用于方法或是类上\",{\"1\":{\"206\":1}}],[\"同时类名也保持一致\",{\"1\":{\"198\":1}}],[\"同时我们需要向其中填入参数\",{\"1\":{\"191\":1}}],[\"同时每次打印也是不同的线程在执行\",{\"1\":{\"173\":1}}],[\"同时会释放当前代码块持有的锁\",{\"1\":{\"161\":1}}],[\"同时一直占用锁\",{\"1\":{\"156\":1}}],[\"同时runnable只有一个未实现方法\",{\"1\":{\"139\":1}}],[\"同时保存了插入顺序\",{\"1\":{\"61\":1}}],[\"同时得益于每一个节点都是一个双向链表\",{\"1\":{\"61\":1}}],[\"同样内置了一个缓存机制\",{\"1\":{\"610\":1}}],[\"同样地\",{\"1\":{\"333\":1}}],[\"同样\",{\"1\":{\"294\":1,\"384\":1}}],[\"同样可以使用\",{\"1\":{\"631\":1}}],[\"同样可以用条件概率的形式进行描述\",{\"1\":{\"304\":1}}],[\"同样可以捕获到\",{\"1\":{\"267\":1}}],[\"同样可以按照上面的操作进行越权访问\",{\"1\":{\"193\":1}}],[\"同样需要使用resultmap来完成\",{\"1\":{\"569\":1}}],[\"同样需要使用\",{\"1\":{\"235\":1}}],[\"同样需要将接口中所有的抽象方法全部实现\",{\"1\":{\"219\":1}}],[\"同样需要给一个\",{\"1\":{\"46\":1}}],[\"同样采用装饰者模式\",{\"1\":{\"129\":1}}],[\"同样不能超过最大值\",{\"1\":{\"60\":1}}],[\"同样是用于列表查询的\",{\"1\":{\"564\":1}}],[\"同样是一个comparator\",{\"1\":{\"50\":1}}],[\"同样是只能插入那些不重复的元素\",{\"1\":{\"47\":1}}],[\"同样是仅获取队首元素\",{\"1\":{\"43\":1}}],[\"同样是移除队首元素\",{\"1\":{\"43\":1}}],[\"同样是添加操作\",{\"1\":{\"43\":1}}],[\"同样是list的实现类\",{\"1\":{\"25\":1}}],[\"同样的键只能存在一个\",{\"1\":{\"57\":1}}],[\"同样的\",{\"1\":{\"15\":1,\"23\":1,\"59\":1,\"77\":1,\"117\":2,\"126\":1,\"156\":1,\"227\":1,\"255\":1,\"534\":1,\"678\":1}}],[\"同样的类型\",{\"1\":{\"14\":1}}],[\"同上输入流\",{\"1\":{\"92\":1}}],[\"同上\",{\"1\":{\"23\":1,\"215\":4,\"235\":1}}],[\"查找顺序\",{\"0\":{\"613\":1}}],[\"查找位置\",{\"0\":{\"80\":1}}],[\"查看结果\",{\"1\":{\"516\":1}}],[\"查看表中的索引\",{\"1\":{\"508\":1}}],[\"查看浏览器发起的请求\",{\"1\":{\"455\":1}}],[\"查看当前类的类加载器\",{\"1\":{\"198\":1}}],[\"查看当前集合是否为空\",{\"1\":{\"23\":1}}],[\"查看map中是否包含指定的值\",{\"1\":{\"56\":1}}],[\"查看map中是否包含指定的键\",{\"1\":{\"56\":1}}],[\"查看前面是否有已经遍历的元素\",{\"1\":{\"37\":1}}],[\"查询一个\",{\"0\":{\"581\":1}}],[\"查询\",{\"0\":{\"579\":1},\"1\":{\"577\":1}}],[\"查询列表时\",{\"1\":{\"564\":1}}],[\"查询列表操作\",{\"0\":{\"564\":1}}],[\"查询操作在xml配置中使用一个select标签进行囊括\",{\"1\":{\"559\":1}}],[\"查询操作\",{\"0\":{\"559\":1}}],[\"查询得到的数据\",{\"1\":{\"519\":1}}],[\"查询条件\",{\"0\":{\"491\":1}}],[\"查询所有的列数据\",{\"1\":{\"490\":1}}],[\"查询相关操作\",{\"1\":{\"56\":1}}],[\"查询某个元素在当前列表中的最后一次出现的下标位置\",{\"1\":{\"24\":1}}],[\"查询某个元素在当前列表中的第一次出现的下标位置\",{\"1\":{\"24\":1}}],[\"查询当前集合是否包含给定集合中所有的元素\",{\"1\":{\"23\":1}}],[\"查询当前集合中是否包含某个元素\",{\"1\":{\"23\":1}}],[\"树脂666\",{\"1\":{\"23\":1}}],[\"所在类\",{\"1\":{\"672\":1}}],[\"所生成的数据\",{\"1\":{\"397\":1}}],[\"所求出的\",{\"1\":{\"351\":1}}],[\"所获得的均值\",{\"1\":{\"333\":1}}],[\"所得到的\",{\"1\":{\"325\":1}}],[\"所谓的生产者消费者模型\",{\"1\":{\"174\":1}}],[\"所处的包和对应的目录是一一对应的\",{\"1\":{\"120\":1}}],[\"所有常规提示日志信息都以info级别进行打印\",{\"1\":{\"638\":1}}],[\"所有源文件会被解析成语法树\",{\"1\":{\"539\":1}}],[\"所有此表满足第二范式\",{\"1\":{\"465\":1}}],[\"所有可能动作的\",{\"1\":{\"333\":1}}],[\"所有状态的集合\",{\"1\":{\"304\":1}}],[\"所有包装类如下\",{\"0\":{\"227\":1}}],[\"所有其他类都是继承它的\",{\"1\":{\"215\":1}}],[\"所有代码执行结束时\",{\"1\":{\"143\":1}}],[\"所有被标记为静态的内容\",{\"1\":{\"118\":1}}],[\"所有子文件的file对象\",{\"1\":{\"98\":1}}],[\"所有直接覆盖就行\",{\"1\":{\"59\":1}}],[\"所有的标签必须成对出现\",{\"1\":{\"545\":1}}],[\"所有的操作才会被保存\",{\"1\":{\"534\":1}}],[\"所有的操作都有分别对应队首和队尾的\",{\"1\":{\"44\":1}}],[\"所有的属性都不传递依赖于主键\",{\"1\":{\"466\":1}}],[\"所有的运行时异常都继承自\",{\"1\":{\"264\":1}}],[\"所有的集合类最终都是实现自集合根接口的\",{\"1\":{\"23\":1}}],[\"所以我们通过mybatis为我们设计的这一系列注解就可以很轻松地取代掉之前的配置\",{\"1\":{\"625\":1}}],[\"所以使用package标签来指定一个包\",{\"1\":{\"622\":1}}],[\"所以依然在使用缓存中的数据\",{\"1\":{\"616\":1}}],[\"所以之前缓存的内容可能就不是当前数据库里面最新的内容了\",{\"1\":{\"611\":1}}],[\"所以默认情况下它们将会以\",{\"1\":{\"571\":1}}],[\"所以这里还是填写com\",{\"1\":{\"564\":1}}],[\"所以这个8就是存了数组\",{\"1\":{\"25\":1}}],[\"所以需要填入一个占位符\",{\"1\":{\"559\":1}}],[\"所以要获取内部的节点\",{\"1\":{\"547\":1}}],[\"所以jdbc需要进行事务管理时\",{\"1\":{\"534\":1}}],[\"所以前面我们执行一个sql语句就会被直接提交\",{\"1\":{\"534\":1}}],[\"所以视图good\",{\"1\":{\"507\":1}}],[\"所以其不符合bcnf范式\",{\"1\":{\"467\":1}}],[\"所以如果没有始终在线\",{\"1\":{\"455\":1}}],[\"所以状态其实共有\",{\"1\":{\"298\":1}}],[\"所以在无人机辅助通信网络中我们需要考虑qoe模型\",{\"1\":{\"295\":1}}],[\"所以只初始化了内部类\",{\"1\":{\"254\":1}}],[\"所以只要\",{\"1\":{\"84\":1}}],[\"所以相对外部来说\",{\"1\":{\"252\":1}}],[\"所以可能不满足真实需求\",{\"1\":{\"236\":1}}],[\"所以是\",{\"1\":{\"186\":1}}],[\"所以类锁本质上就是对应的类的\",{\"1\":{\"182\":1}}],[\"所以仍然需要等在运行的线程结束才会转为运行态\",{\"1\":{\"161\":1}}],[\"所以\",{\"1\":{\"156\":1,\"235\":1,\"333\":1,\"467\":1}}],[\"所以自己定义的类要自己重写\",{\"1\":{\"84\":1}}],[\"所以不维护顺序\",{\"1\":{\"57\":1}}],[\"所以它支持两种方向的遍历操作\",{\"1\":{\"37\":1}}],[\"所以添加成功返回true\",{\"1\":{\"23\":1}}],[\"所以说是可以的\",{\"1\":{\"281\":1}}],[\"所以说具体类型同样会变成\",{\"1\":{\"281\":1}}],[\"所以说静态方法中是不能用对象定义的泛型的\",{\"1\":{\"281\":1}}],[\"所以说静态内容一定会在第一个对象初始化之前完成加载\",{\"1\":{\"118\":1}}],[\"所以说并不能直接判断存储的类型到底是\",{\"1\":{\"280\":1}}],[\"所以说默认就可以直接使用\",{\"1\":{\"274\":1}}],[\"所以说只能使用\",{\"1\":{\"258\":1}}],[\"所以说里面也可以有成员变量\",{\"1\":{\"251\":1}}],[\"所以说int类型的数组时不能被object类型的数组变量接收的\",{\"1\":{\"238\":1}}],[\"所以说可以直接向上转型\",{\"1\":{\"235\":1}}],[\"所以说可以反复使用\",{\"1\":{\"37\":1}}],[\"所以说==判断为假\",{\"1\":{\"227\":1}}],[\"所以说两个不同的对象\",{\"1\":{\"227\":1}}],[\"所以说照着写就行了\",{\"1\":{\"220\":1}}],[\"所以说有些人说接口其实就是java中的多继承\",{\"1\":{\"219\":1}}],[\"所以说不能为私有\",{\"1\":{\"218\":1}}],[\"所以说判断结果为真\",{\"1\":{\"216\":1}}],[\"所以说呢\",{\"1\":{\"208\":1}}],[\"所以说就这样设计了\",{\"1\":{\"161\":1}}],[\"所以说没有包这个概念\",{\"1\":{\"120\":1}}],[\"所以说没必要直接用实现类\",{\"1\":{\"25\":1}}],[\"所以说我们需要明确指定\",{\"1\":{\"120\":1}}],[\"所以说我们在静态方法中\",{\"1\":{\"117\":1}}],[\"所以说我们可以添加两个一模一样的\",{\"1\":{\"25\":1}}],[\"所以说这里我们之间填写之前建好的实体类名称\",{\"1\":{\"559\":1}}],[\"所以说这里就明确了类型\",{\"1\":{\"14\":1}}],[\"所以说这种解决办法虽然可行\",{\"1\":{\"280\":1}}],[\"所以说这个对象当做每一个键值对的共享\",{\"1\":{\"67\":2}}],[\"所以说直接采用红黑树会更好\",{\"1\":{\"62\":1}}],[\"所以说直接就使用了\",{\"1\":{\"7\":1}}],[\"所以说返回null\",{\"1\":{\"57\":1}}],[\"所以说返回正数表示大于\",{\"1\":{\"14\":1}}],[\"所以说值是学生对象类型的\",{\"1\":{\"56\":1}}],[\"所以说最重要的还是\",{\"1\":{\"50\":1}}],[\"所以说无法维持插入元素的顺序\",{\"1\":{\"48\":1}}],[\"所以说\",{\"1\":{\"33\":1,\"67\":1,\"117\":1,\"258\":1}}],[\"所以说一定要注意\",{\"1\":{\"25\":1}}],[\"所以说哪怕是我们不去指定类型也可以直接使用\",{\"1\":{\"16\":1}}],[\"所以说依然是跟之前一样\",{\"1\":{\"15\":1}}],[\"所以说使用void\",{\"1\":{\"5\":1}}],[\"数量\",{\"1\":{\"467\":3,\"494\":2}}],[\"数量和位置\",{\"1\":{\"296\":1}}],[\"数量的内容\",{\"1\":{\"108\":1}}],[\"数学工具类\",{\"0\":{\"274\":1}}],[\"数字\",{\"1\":{\"246\":1}}],[\"数据实际上还是存放在原来的表中\",{\"1\":{\"507\":1}}],[\"数据类型\",{\"1\":{\"478\":2,\"479\":1}}],[\"数据操纵语言\",{\"1\":{\"472\":1}}],[\"数据查询语言\",{\"1\":{\"472\":1}}],[\"数据模型与现实世界中的模型一样\",{\"1\":{\"461\":1}}],[\"数据模型\",{\"0\":{\"461\":1}}],[\"数据表之间相互关联\",{\"1\":{\"460\":1}}],[\"数据库连接url\",{\"1\":{\"552\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"510\":1}}],[\"数据库的完整性没有被破坏\",{\"1\":{\"510\":1}}],[\"数据库的规范化\",{\"0\":{\"463\":1}}],[\"数据库4\",{\"0\":{\"505\":1}}],[\"数据库控制语言\",{\"0\":{\"499\":1}}],[\"数据库查询语言\",{\"0\":{\"489\":1}}],[\"数据库3\",{\"0\":{\"487\":1}}],[\"数据库操纵语言\",{\"0\":{\"481\":1}}],[\"数据库操作\",{\"0\":{\"477\":1}}],[\"数据库名\",{\"1\":{\"477\":3}}],[\"数据库定义语言\",{\"0\":{\"473\":1}}],[\"数据库定义语言ddl\",{\"1\":{\"472\":1}}],[\"数据库2\",{\"0\":{\"470\":1}}],[\"数据库创建完成后\",{\"1\":{\"478\":1}}],[\"数据库创建\",{\"0\":{\"462\":1}}],[\"数据库能有效地帮助一个组织或企业科学地管理各类信息资源\",{\"1\":{\"460\":1}}],[\"数据库是数据管理的有效技术\",{\"1\":{\"460\":1}}],[\"数据库\",{\"0\":{\"459\":1,\"471\":1,\"488\":1,\"506\":1,\"692\":1},\"1\":{\"502\":2}}],[\"数据库1\",{\"0\":{\"458\":1}}],[\"数据已发送\",{\"1\":{\"448\":1}}],[\"数据包从发送端\",{\"1\":{\"295\":1}}],[\"数据流datainputstream也是filterinputstream的子类\",{\"1\":{\"129\":1}}],[\"数据流\",{\"0\":{\"129\":1}}],[\"数据结构与算法基础\",{\"1\":{\"15\":2,\"280\":1}}],[\"数据结构与算法\",{\"1\":{\"15\":1,\"46\":1}}],[\"数组工具类\",{\"0\":{\"275\":1}}],[\"数组同样支持向上转型\",{\"1\":{\"238\":1}}],[\"数组大小\",{\"1\":{\"235\":2}}],[\"数组类型比较特殊\",{\"1\":{\"235\":1}}],[\"数组类型也是一种类型\",{\"1\":{\"184\":1}}],[\"数组可以代表任何相同类型的一组内容\",{\"1\":{\"234\":1}}],[\"数组可以存放基本数据类型\",{\"1\":{\"22\":1}}],[\"数组是相同类型数据的有序集合\",{\"1\":{\"234\":1}}],[\"数组\",{\"0\":{\"232\":1,\"234\":1}}],[\"数组的\",{\"0\":{\"184\":1},\"1\":{\"236\":1}}],[\"数组的大小是固定的\",{\"1\":{\"22\":1}}],[\"数组实现的栈和队列\",{\"1\":{\"45\":1}}],[\"数组存放的类型只能是一种\",{\"1\":{\"22\":1}}],[\"都像是去厨房端菜到客人桌上一样\",{\"1\":{\"599\":1}}],[\"都需要一定的时间开销\",{\"1\":{\"599\":1}}],[\"都需要编写大量的代码\",{\"1\":{\"544\":1}}],[\"都需要有多个\",{\"1\":{\"369\":1}}],[\"都记录\",{\"1\":{\"366\":1}}],[\"都会关联到这个二级缓存\",{\"1\":{\"612\":1}}],[\"都会使用反射进行一次赋值\",{\"1\":{\"569\":1}}],[\"都会抛出\",{\"1\":{\"285\":1}}],[\"都会在最后执行任务\",{\"1\":{\"267\":1}}],[\"都会将指针后移一位\",{\"1\":{\"31\":1}}],[\"都可以通过实现此接口\",{\"1\":{\"515\":1}}],[\"都可以直接进行方法引用\",{\"1\":{\"258\":1}}],[\"都可以使用getannotations\",{\"1\":{\"208\":1}}],[\"都可以使用\",{\"1\":{\"36\":1}}],[\"都在\",{\"1\":{\"229\":1}}],[\"都能调用它的任意一个方法和属性\",{\"1\":{\"179\":1}}],[\"都能够知道这个类所有的属性和方法\",{\"1\":{\"179\":1}}],[\"都能够容纳一组元素\",{\"1\":{\"22\":1}}],[\"都只能获取到当前线程所属的变量\",{\"1\":{\"162\":1}}],[\"都有可选择的动作\",{\"1\":{\"304\":1}}],[\"都有学习的能力\",{\"1\":{\"219\":1}}],[\"都有一个获取原始类型class方法\",{\"1\":{\"183\":1}}],[\"都有一个interrupt\",{\"1\":{\"144\":1}}],[\"都有自己的内存空间\",{\"1\":{\"138\":1}}],[\"都是storehousemanage的候选关键字\",{\"1\":{\"467\":1}}],[\"都是string类型的一个实例对象\",{\"1\":{\"244\":1}}],[\"都是最大的\",{\"1\":{\"433\":1}}],[\"都是可以支持泛型的\",{\"1\":{\"282\":1}}],[\"都是始终是那一个对象\",{\"1\":{\"180\":1}}],[\"都是根据\",{\"1\":{\"84\":1}}],[\"都是直接使用new关键字就能直接搞定了\",{\"1\":{\"9\":1}}],[\"它详细记录了所有的数据库操作等\",{\"1\":{\"679\":1}}],[\"它继承自hashtable类\",{\"1\":{\"665\":1}}],[\"它包含一个默认的consolehandler处理器用于进行控制台打印\",{\"1\":{\"655\":1}}],[\"它用于控制日志的格式\",{\"1\":{\"649\":1}}],[\"它用于处理我们的日志内容打印\",{\"1\":{\"646\":1}}],[\"它用于保存字符串\",{\"1\":{\"243\":1}}],[\"它之前查询的缓存依然会存在于二级缓存中\",{\"1\":{\"612\":1}}],[\"它仅仅对一个会话中的数据进行缓存\",{\"1\":{\"611\":1}}],[\"它也是现在提高数据获取效率的良好解决方案\",{\"1\":{\"610\":1}}],[\"它与java中的for类似\",{\"1\":{\"603\":1}}],[\"它类似于java中的switch语句\",{\"1\":{\"602\":1}}],[\"它采用ognl表达式进行编写\",{\"1\":{\"601\":1}}],[\"它代表执行sql后受影响的行数\",{\"1\":{\"588\":1}}],[\"它代表当前类的版本\",{\"1\":{\"132\":1}}],[\"它其实是通过动态代理生成的\",{\"1\":{\"570\":1}}],[\"它适用于单个数据查询或是多行数据查询\",{\"1\":{\"564\":1}}],[\"它返回的map是使用我们想要的属性作为key\",{\"1\":{\"564\":1}}],[\"它提供了当前日志记录的相关信息\",{\"1\":{\"672\":1}}],[\"它提供的接口\",{\"1\":{\"515\":1}}],[\"它提前帮助我们规定了一些标签\",{\"1\":{\"552\":1}}],[\"它内部就还有子节点\",{\"1\":{\"547\":1}}],[\"它更像是一个配置文件\",{\"1\":{\"545\":1}}],[\"它所做的工作就是我们上面所说的\",{\"1\":{\"539\":1}}],[\"它对jdbc进行了深层次的封装\",{\"1\":{\"527\":1}}],[\"它还可以用来绑定一个接口\",{\"1\":{\"554\":1}}],[\"它还支持事务的处理\",{\"1\":{\"518\":1}}],[\"它还能把每一行内容依次转换为集合类提到的stream流\",{\"1\":{\"112\":1}}],[\"它需要结合聚合函数一起使用\",{\"1\":{\"494\":1}}],[\"它保证数据的参照完整性\",{\"1\":{\"475\":1}}],[\"它专门用于数据库的操作\",{\"1\":{\"472\":1}}],[\"它至少要包含一个响应码\",{\"1\":{\"455\":1}}],[\"它本质也是基于tcp协议进行数据传输\",{\"1\":{\"455\":1}}],[\"它本身也是类\",{\"1\":{\"235\":1}}],[\"它支持我们使用lambda的形式进行查询结果的处理\",{\"1\":{\"564\":1}}],[\"它支持定制化\",{\"1\":{\"544\":1}}],[\"它支持多行\",{\"1\":{\"472\":1}}],[\"它支持tcp和udp\",{\"1\":{\"446\":1}}],[\"它支持按行读取\",{\"1\":{\"112\":1}}],[\"它是符合第三范式的\",{\"1\":{\"467\":1}}],[\"它是计算机之间进行通信的一种约定或一种方式\",{\"1\":{\"446\":1}}],[\"它是运行时异常的子类\",{\"1\":{\"267\":1}}],[\"它是局部内部类的简化版\",{\"1\":{\"255\":1}}],[\"它是一个用于操作数组的工具类\",{\"1\":{\"75\":1}}],[\"它就像一个字符串编辑器\",{\"1\":{\"245\":1}}],[\"它相当于我们对某样东西的一个标记\",{\"1\":{\"203\":1}}],[\"它可以长这样\",{\"1\":{\"545\":1}}],[\"它可以判断一个对象是否为此接口或是类的实现或是子类\",{\"1\":{\"186\":1}}],[\"它可以提高你的多线程任务的速度\",{\"1\":{\"173\":1}}],[\"它通过默认的forkjoinpool实现\",{\"1\":{\"173\":1}}],[\"它将我们的变量值存储在内部只能存储一个变量\",{\"1\":{\"162\":1}}],[\"它不是继承自filterinputstream的\",{\"1\":{\"130\":1}}],[\"它会将日志以xml的形式进行打印\",{\"1\":{\"649\":1}}],[\"它会预编译一个sql语句\",{\"1\":{\"533\":1}}],[\"它会返回一个boolean来表示执行结果是一个resultset还是一个int\",{\"1\":{\"519\":1}}],[\"它会返回一个int类型\",{\"1\":{\"519\":1}}],[\"它会在\",{\"1\":{\"367\":1}}],[\"它会在元素插入时进行排序\",{\"1\":{\"50\":1}}],[\"它会直接打印基本数据类型或是调用对象的tostring\",{\"1\":{\"127\":1}}],[\"它同样也支持mark\",{\"1\":{\"112\":1}}],[\"它能够有效地预防sql注入式攻击\",{\"1\":{\"518\":1}}],[\"它能够快速地定位元素存放的位置\",{\"1\":{\"508\":1}}],[\"它能够在编译阶段就检查类型安全\",{\"1\":{\"280\":1}}],[\"它能够在插入数据时利用链表自动维护顺序\",{\"1\":{\"49\":1}}],[\"它能够格式化任意的类型\",{\"1\":{\"127\":1}}],[\"它能够提供一个缓冲\",{\"1\":{\"103\":1}}],[\"它们专门用于配置特殊情况\",{\"1\":{\"640\":1}}],[\"它们分别代表一对一关联和一对多关联\",{\"1\":{\"629\":1}}],[\"它们能够捆绑一组sql语句运行\",{\"1\":{\"510\":1}}],[\"它们通过\",{\"1\":{\"84\":1}}],[\"它们都是容器\",{\"1\":{\"22\":1}}],[\"它给我们提供了大量的工具方法\",{\"1\":{\"75\":1}}],[\"它扩展了大量队列相关操作\",{\"1\":{\"43\":1}}],[\"它的格式如下\",{\"1\":{\"664\":1}}],[\"它的使用方式与resultmap几乎没什么区别\",{\"1\":{\"626\":1}}],[\"它的权限非常高\",{\"1\":{\"179\":1}}],[\"它的底层很简单\",{\"1\":{\"67\":1}}],[\"它的底层就是采用哈希表实现的\",{\"1\":{\"48\":1}}],[\"它的内部直接维护了一个红黑树\",{\"1\":{\"62\":1}}],[\"它的内部对插入顺序进行了维护\",{\"1\":{\"57\":1}}],[\"它的运作机制大概是\",{\"1\":{\"31\":1}}],[\"它的主要特性有\",{\"1\":{\"24\":1}}],[\"它的祖先就是collection接口\",{\"1\":{\"23\":1}}],[\"它的属性没有进行赋值\",{\"1\":{\"4\":1}}],[\"每调用一次next\",{\"1\":{\"525\":1}}],[\"每组列名1相同的数据再按照列名2排序\",{\"1\":{\"492\":1}}],[\"每架无人机的带宽和发射功率都均匀分配给每个用户\",{\"1\":{\"298\":1}}],[\"每次都是从对应的状态\",{\"1\":{\"369\":1}}],[\"每次迭代都会使得策略进行提升\",{\"1\":{\"353\":1}}],[\"每次无人机会根据当前状态st​∈s\",{\"1\":{\"298\":1}}],[\"每次运算都会生成一个新的对象\",{\"1\":{\"245\":1}}],[\"每次就直接返回一个字符串吧\",{\"1\":{\"36\":1}}],[\"每次循环一定要判断是否还有元素剩余\",{\"1\":{\"34\":1}}],[\"每一级使用\",{\"1\":{\"664\":1}}],[\"每一行必须有值\",{\"1\":{\"475\":1}}],[\"每一种数据库都支持sql\",{\"1\":{\"472\":1}}],[\"每一张表都代表一种实体的数据\",{\"1\":{\"462\":1}}],[\"每一轮循环\",{\"1\":{\"237\":1}}],[\"每一个handler都可以配置一个对应的formatter来决定日志打印的格式\",{\"1\":{\"672\":1}}],[\"每一个result标签都可以配置数据库字段和类属性的对应关系\",{\"1\":{\"563\":1}}],[\"每一个标签都作为一个节点\",{\"1\":{\"547\":1}}],[\"每一个学生也可以有多个教师\",{\"1\":{\"461\":1}}],[\"每一个老师不仅可以教多个学生\",{\"1\":{\"461\":1}}],[\"每一个thread对象中\",{\"1\":{\"144\":1}}],[\"每一个进程都是一个应用程序\",{\"1\":{\"138\":1}}],[\"每一个对象我们都可以称其为元素\",{\"1\":{\"21\":1}}],[\"每一次next操作\",{\"1\":{\"31\":1}}],[\"每个mapper都是唯一的\",{\"1\":{\"554\":1}}],[\"每个会话就相当于我不同的地方登陆一个账号去访问数据库\",{\"1\":{\"553\":1}}],[\"每个基于\",{\"1\":{\"553\":1}}],[\"每个学生都有着不同的学号\",{\"1\":{\"465\":1}}],[\"每个集群中无人机的最优位置也会发生变化\",{\"1\":{\"299\":1}}],[\"每个用户的移动方向均匀分布在左\",{\"1\":{\"299\":1}}],[\"每个用户都需要判断是否与每个无人机关联\",{\"1\":{\"299\":1}}],[\"每个用户只能属于一个集群\",{\"1\":{\"293\":1}}],[\"每个用双引号括起来的字符串\",{\"1\":{\"244\":1}}],[\"每个对象中都有一个单独的类定义\",{\"1\":{\"251\":1}}],[\"每个对象都有这样的一个类定义\",{\"1\":{\"251\":1}}],[\"每个对象都有一个自己的空间\",{\"1\":{\"4\":1}}],[\"每个对象都应该有针对于锁的一些操作\",{\"1\":{\"161\":1}}],[\"每个类可以创建一个对象\",{\"1\":{\"251\":1}}],[\"每个类都有且只有一个唯一的class对象存放在jvm中\",{\"1\":{\"180\":1}}],[\"每个包装类中\",{\"1\":{\"183\":1}}],[\"每个线程都有一个私有的工作内存\",{\"1\":{\"154\":1}}],[\"每个元素都要执行+1操作\",{\"1\":{\"71\":1}}],[\"每个元素都有一个自己的下标位置\",{\"1\":{\"24\":2}}],[\"集合操作能不能也安排点高级的玩法呢\",{\"1\":{\"75\":1}}],[\"集合运算和表达的高阶抽象\",{\"1\":{\"71\":1}}],[\"集合只是粗略的进行了讲解\",{\"1\":{\"50\":1}}],[\"集合中基本都是从\",{\"1\":{\"47\":1}}],[\"集合中的每一个元素就是一个集合\",{\"1\":{\"25\":1}}],[\"集合的具体类型\",{\"1\":{\"77\":1}}],[\"集合的各种功能我们都可以来测试一下\",{\"1\":{\"25\":1}}],[\"集合的\",{\"1\":{\"24\":1}}],[\"集合的大小是可变的\",{\"1\":{\"22\":1}}],[\"集合根接口\",{\"0\":{\"23\":1}}],[\"集合跟数组一样\",{\"1\":{\"22\":1}}],[\"集合\",{\"0\":{\"47\":1},\"1\":{\"21\":1}}],[\"集合表示一组对象\",{\"1\":{\"21\":1}}],[\"集合其实与我们数学中的集合是差不多的概念\",{\"1\":{\"21\":1}}],[\"集合类中有一个东西是java8新增的spliterator接口\",{\"1\":{\"173\":1}}],[\"集合类中并不是通过\",{\"1\":{\"84\":1}}],[\"集合类中继承的方法这里也不多种介绍了\",{\"1\":{\"44\":1}}],[\"集合类对象相等判定\",{\"0\":{\"83\":1,\"84\":1}}],[\"集合类同样支持这种语法\",{\"1\":{\"30\":1}}],[\"集合类是支持嵌套使用的\",{\"1\":{\"25\":1}}],[\"集合类是java中非常重要的存在\",{\"1\":{\"21\":1}}],[\"集合类基本都是在java\",{\"1\":{\"23\":1}}],[\"集合类与数组区别\",{\"0\":{\"22\":1}}],[\"集合类其实就是为了更好地组织\",{\"1\":{\"21\":1}}],[\"集合类\",{\"0\":{\"19\":1,\"20\":1,\"21\":1,\"28\":1,\"29\":1,\"35\":1,\"40\":1,\"41\":1,\"53\":1,\"54\":1,\"173\":1},\"1\":{\"35\":1,\"173\":1}}],[\"err打印到控制台\",{\"1\":{\"646\":1}}],[\"error\",{\"1\":{\"569\":2}}],[\"error错误比异常更严重\",{\"1\":{\"264\":1}}],[\"ehcache\",{\"1\":{\"616\":1}}],[\"employeeid\",{\"1\":{\"476\":1}}],[\"employees\",{\"1\":{\"476\":1}}],[\"emptylist\",{\"1\":{\"79\":1}}],[\"empty\",{\"1\":{\"25\":1,\"167\":1}}],[\"email\",{\"1\":{\"475\":2}}],[\"e+γvπ​\",{\"1\":{\"398\":1}}],[\"e+1\",{\"1\":{\"71\":1}}],[\"efficient\",{\"1\":{\"366\":1}}],[\"euqation\",{\"1\":{\"332\":1}}],[\"euqals\",{\"1\":{\"215\":1}}],[\"equation\",{\"0\":{\"327\":1,\"330\":1,\"331\":1,\"339\":1},\"1\":{\"322\":1,\"330\":1,\"331\":2,\"334\":2,\"337\":1,\"343\":1,\"351\":1,\"353\":2,\"355\":1,\"356\":1,\"362\":1,\"398\":3,\"400\":1,\"404\":1}}],[\"equal\",{\"1\":{\"24\":1}}],[\"equalsandhashcode全部注解\",{\"1\":{\"540\":1}}],[\"equalsandhashcode来快速生成比较和哈希值方法\",{\"1\":{\"540\":1}}],[\"equals\",{\"1\":{\"23\":1,\"25\":1,\"47\":1,\"56\":1,\"59\":2,\"84\":16,\"215\":1,\"216\":4,\"244\":1}}],[\"every\",{\"1\":{\"366\":2}}],[\"evaluation\",{\"1\":{\"308\":2,\"330\":1,\"332\":1,\"351\":1,\"355\":1,\"364\":1,\"367\":1}}],[\"eviction=\",{\"1\":{\"612\":1}}],[\"evict\",{\"1\":{\"59\":2}}],[\"eplison\",{\"0\":{\"370\":1}}],[\"episodestartingfrom\",{\"1\":{\"366\":4}}],[\"episodes\",{\"1\":{\"363\":1,\"367\":2,\"369\":2}}],[\"episode\",{\"0\":{\"366\":1},\"1\":{\"304\":2,\"363\":2,\"366\":6,\"367\":1,\"369\":1,\"371\":1,\"422\":1}}],[\"ep074512\",{\"1\":{\"15\":3,\"280\":1,\"281\":2}}],[\"estimation\",{\"0\":{\"384\":1,\"388\":1,\"417\":1},\"1\":{\"360\":2,\"362\":1,\"367\":1,\"377\":1}}],[\"es∼η\",{\"1\":{\"311\":1}}],[\"es\",{\"1\":{\"246\":1}}],[\"eat\",{\"1\":{\"174\":1}}],[\"each\",{\"1\":{\"23\":4,\"509\":2}}],[\"ex\",{\"1\":{\"517\":2}}],[\"executortype\",{\"1\":{\"599\":1}}],[\"executorexception\",{\"1\":{\"569\":1}}],[\"executor\",{\"1\":{\"569\":1}}],[\"executebatch\",{\"1\":{\"526\":1}}],[\"executeupdate\",{\"1\":{\"524\":3,\"534\":11,\"599\":1}}],[\"executequery\",{\"1\":{\"516\":1,\"532\":1,\"533\":1}}],[\"executing\",{\"1\":{\"139\":1,\"167\":1}}],[\"exchange\",{\"1\":{\"455\":1}}],[\"excellent\",{\"1\":{\"295\":1}}],[\"exceptionfactory\",{\"1\":{\"571\":2}}],[\"exceptions\",{\"1\":{\"569\":1,\"571\":1}}],[\"exceptionutil\",{\"1\":{\"569\":1}}],[\"exception\",{\"1\":{\"199\":2,\"264\":4,\"265\":3,\"266\":3,\"455\":2,\"517\":1,\"547\":1,\"569\":1}}],[\"exist\",{\"1\":{\"569\":1}}],[\"existence\",{\"1\":{\"343\":1}}],[\"exists\",{\"1\":{\"98\":1,\"477\":1}}],[\"exploration\",{\"1\":{\"372\":1}}],[\"exploring\",{\"0\":{\"365\":1,\"368\":1,\"369\":1},\"1\":{\"365\":1,\"369\":2,\"370\":1,\"373\":1}}],[\"exploitation\",{\"1\":{\"372\":1}}],[\"exponentially\",{\"1\":{\"343\":1}}],[\"expected\",{\"0\":{\"403\":1},\"1\":{\"325\":1}}],[\"expection\",{\"1\":{\"325\":1,\"398\":1,\"418\":1,\"421\":1}}],[\"experience\",{\"0\":{\"295\":1},\"1\":{\"289\":1,\"365\":1,\"397\":1,\"401\":1}}],[\"expression\",{\"1\":{\"246\":1}}],[\"exam\",{\"1\":{\"216\":2,\"218\":2}}],[\"extends\",{\"1\":{\"15\":3,\"16\":1,\"23\":2,\"24\":2,\"25\":2,\"37\":1,\"42\":1,\"43\":1,\"44\":1,\"47\":2,\"56\":2,\"58\":1,\"61\":1,\"67\":1,\"186\":1,\"191\":1,\"192\":1,\"199\":1,\"218\":1,\"219\":2,\"220\":1,\"221\":1,\"265\":2,\"282\":1,\"564\":1,\"665\":1,\"672\":1}}],[\"extend\",{\"1\":{\"15\":1}}],[\"engines\",{\"1\":{\"510\":1}}],[\"english\",{\"1\":{\"65\":3}}],[\"en\",{\"1\":{\"455\":1,\"552\":1,\"554\":1}}],[\"encoding=\",{\"1\":{\"545\":2,\"552\":1,\"554\":1}}],[\"encoding\",{\"1\":{\"455\":1,\"667\":2}}],[\"environments>\",{\"1\":{\"552\":1}}],[\"environment>\",{\"1\":{\"552\":1}}],[\"environment\",{\"1\":{\"304\":2,\"632\":4}}],[\"enum<com\",{\"1\":{\"221\":1}}],[\"enum表示这是一个枚举类\",{\"1\":{\"221\":1}}],[\"enum\",{\"1\":{\"221\":2}}],[\"entity\",{\"1\":{\"120\":5,\"121\":1,\"254\":3,\"255\":2,\"554\":1,\"560\":1,\"571\":1,\"577\":1,\"579\":3,\"581\":2,\"582\":2,\"583\":3,\"589\":1,\"590\":1,\"625\":1,\"632\":1}}],[\"entry\",{\"1\":{\"61\":1}}],[\"entryset\",{\"1\":{\"56\":1}}],[\"entry<k\",{\"1\":{\"56\":2,\"58\":1,\"61\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"25\":1}}],[\"eliminate\",{\"1\":{\"167\":1}}],[\"else\",{\"1\":{\"25\":3,\"59\":3,\"60\":3,\"107\":1,\"266\":1,\"517\":2}}],[\"elementwise\",{\"1\":{\"334\":1,\"340\":1,\"348\":1,\"351\":2}}],[\"elementtype是一个枚举类型\",{\"1\":{\"206\":1}}],[\"elementtype\",{\"1\":{\"206\":2,\"207\":8,\"208\":3}}],[\"elementdata\",{\"1\":{\"25\":9,\"33\":1}}],[\"element\",{\"1\":{\"24\":2,\"25\":2,\"43\":1,\"547\":1}}],[\"e>\",{\"1\":{\"23\":2,\"24\":2,\"32\":1,\"47\":1}}],[\"e\",{\"1\":{\"23\":2,\"24\":8,\"25\":5,\"32\":1,\"33\":3,\"37\":6,\"43\":8,\"44\":19,\"47\":2,\"59\":11,\"71\":4,\"90\":6,\"91\":6,\"92\":4,\"93\":2,\"94\":2,\"96\":4,\"97\":2,\"98\":2,\"105\":2,\"108\":4,\"110\":2,\"112\":6,\"113\":2,\"126\":4,\"127\":2,\"129\":4,\"131\":2,\"133\":2,\"144\":2,\"148\":2,\"156\":4,\"161\":2,\"162\":2,\"165\":4,\"172\":4,\"174\":4,\"186\":2,\"199\":4,\"246\":2,\"267\":8,\"328\":2,\"329\":4,\"333\":2,\"360\":1,\"379\":1,\"383\":2,\"384\":3,\"386\":1,\"389\":2,\"395\":1,\"398\":1,\"447\":6,\"448\":4,\"454\":4,\"455\":4,\"516\":2,\"524\":2,\"526\":3,\"527\":2,\"532\":2,\"533\":2,\"534\":8,\"547\":2,\"558\":2}}],[\"否则必须保证形参列表与这边接口一致\",{\"1\":{\"630\":1}}],[\"否则可能会出现问题\",{\"1\":{\"570\":1}}],[\"否则报错\",{\"1\":{\"267\":1}}],[\"否则我们必须要使用\",{\"1\":{\"267\":1}}],[\"否则会导致mybatis无法确认\",{\"1\":{\"569\":1}}],[\"否则会无法通过编译\",{\"1\":{\"218\":1}}],[\"否则会抛出异常\",{\"1\":{\"161\":1}}],[\"否则\",{\"1\":{\"207\":1,\"298\":1}}],[\"否则资源会被一直占用\",{\"1\":{\"90\":1}}],[\"否则给你当成\",{\"1\":{\"84\":1}}],[\"否则太过死板\",{\"1\":{\"58\":1}}],[\"否则抛出\",{\"1\":{\"25\":1}}],[\"否则false\",{\"1\":{\"23\":3}}],[\"否则返回false\",{\"1\":{\"23\":2,\"246\":1}}],[\"否则一律报错\",{\"1\":{\"15\":1}}],[\"否则要创建这个类的对象\",{\"1\":{\"9\":1}}],[\"不太常用\",{\"1\":{\"638\":1}}],[\"不太一样\",{\"1\":{\"429\":1}}],[\"不使用url而是resource表示是jar内部的文件\",{\"1\":{\"570\":1}}],[\"不满足将无法插入\",{\"1\":{\"507\":1}}],[\"不好\",{\"1\":{\"463\":1}}],[\"不然可能会映射失败导致查询结果丢失\",{\"1\":{\"554\":1}}],[\"不然会报错\",{\"1\":{\"448\":1}}],[\"不然就无法通过编译\",{\"1\":{\"267\":1}}],[\"不用手动加载驱动\",{\"1\":{\"516\":1}}],[\"不用进行求导\",{\"1\":{\"427\":1}}],[\"不用多说了吧\",{\"1\":{\"44\":3}}],[\"不记录\",{\"1\":{\"366\":1}}],[\"不动点x∗是唯一的\",{\"1\":{\"343\":1}}],[\"不常用\",{\"1\":{\"332\":1}}],[\"不可变\",{\"1\":{\"285\":1}}],[\"不可修改\",{\"1\":{\"285\":1}}],[\"不只是类\",{\"1\":{\"282\":1}}],[\"不见当年倒茶人\",{\"1\":{\"258\":1}}],[\"不会重置其他会话的缓存\",{\"1\":{\"611\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"510\":1}}],[\"不会用空格填充\",{\"1\":{\"474\":1}}],[\"不会保持长久连接\",{\"1\":{\"455\":1}}],[\"不会影响所求的梯度\",{\"1\":{\"311\":1}}],[\"不会调用外部类的\",{\"1\":{\"254\":1}}],[\"不会终止\",{\"0\":{\"167\":1}}],[\"不包括换行\",{\"1\":{\"246\":1}}],[\"不是静态方法\",{\"1\":{\"258\":1}}],[\"不是基本类型\",{\"1\":{\"227\":1}}],[\"不是接口\",{\"1\":{\"166\":1}}],[\"不需要我们做任何事情\",{\"1\":{\"570\":1}}],[\"不需要声明访问权限\",{\"1\":{\"253\":1}}],[\"不需要依附任何对象\",{\"1\":{\"252\":1}}],[\"不需要\",{\"1\":{\"227\":1,\"252\":1}}],[\"不需要和用户交互\",{\"1\":{\"172\":1}}],[\"不保留到运行时\",{\"1\":{\"204\":2}}],[\"不再推荐使用newinstance\",{\"1\":{\"191\":1}}],[\"不要使用\",{\"1\":{\"244\":1}}],[\"不要出现这种死锁的情况\",{\"1\":{\"156\":1}}],[\"不要跟之前的迭代器接口搞混了\",{\"1\":{\"36\":1}}],[\"不过需要注意一下顺序\",{\"1\":{\"657\":1}}],[\"不过很遗憾的是\",{\"1\":{\"629\":1}}],[\"不过\",{\"1\":{\"589\":1}}],[\"不过建议还是写完整一点\",{\"1\":{\"581\":1}}],[\"不过我们每次都可以通过打开视图来按照我们想要的样子查看数据\",{\"1\":{\"507\":1}}],[\"不过我们可以添加restrict或cascade\",{\"1\":{\"479\":1}}],[\"不过没必要\",{\"1\":{\"244\":1}}],[\"不过可以省略\",{\"1\":{\"219\":1}}],[\"不过如果子类也是抽象类\",{\"1\":{\"218\":1}}],[\"不过默认是向控制台打印\",{\"1\":{\"127\":1}}],[\"不过上面写法比较繁琐\",{\"1\":{\"90\":1}}],[\"不涉及字符编码转换\",{\"1\":{\"88\":1}}],[\"不支持抽象类\",{\"1\":{\"257\":1}}],[\"不支持\",{\"1\":{\"79\":2}}],[\"不支持随机访问\",{\"1\":{\"47\":1}}],[\"不存在key时\",{\"1\":{\"64\":1}}],[\"不存在\",{\"1\":{\"64\":1}}],[\"不允许有重复的值和空值\",{\"1\":{\"475\":1}}],[\"不允许\",{\"1\":{\"239\":1,\"285\":1}}],[\"不允许进行修改\",{\"1\":{\"236\":1}}],[\"不允许通过下标访问\",{\"1\":{\"47\":1}}],[\"不允许出现重复元素\",{\"1\":{\"47\":1}}],[\"不进行出队操作\",{\"1\":{\"43\":1}}],[\"不仅带来网络上的额外开销\",{\"1\":{\"599\":1}}],[\"不仅仅是mybatis\",{\"1\":{\"547\":1}}],[\"不仅仅适用于xml\",{\"1\":{\"545\":1}}],[\"不仅仅只运行一个主线程\",{\"1\":{\"138\":1}}],[\"不仅会返回两个表满足条件的交集部分\",{\"1\":{\"497\":1}}],[\"不仅可以一定程度上防止源代码被反编译\",{\"1\":{\"199\":1}}],[\"不仅能从前向后\",{\"1\":{\"37\":1}}],[\"不仅保存指向下一个结点的引用\",{\"1\":{\"25\":1}}],[\"不能一个socket之后就done了\",{\"1\":{\"455\":1}}],[\"不能用同一个q\",{\"1\":{\"298\":1}}],[\"不能通过这个不确定的类型变量就去直接创建对象和对应的数组\",{\"1\":{\"281\":1}}],[\"不能匹配\",{\"1\":{\"246\":2}}],[\"不能随便进行修改\",{\"1\":{\"236\":1}}],[\"不能\",{\"1\":{\"229\":1}}],[\"不能直接通过\",{\"1\":{\"255\":1}}],[\"不能直接创建对象\",{\"1\":{\"219\":1}}],[\"不能直接用10\",{\"1\":{\"25\":1}}],[\"不能使用不同的变量进行接收\",{\"1\":{\"281\":1}}],[\"不能使用默认\",{\"1\":{\"219\":1}}],[\"不能使用==\",{\"1\":{\"216\":1}}],[\"不能是\",{\"1\":{\"218\":1}}],[\"不能认为每一步是直接依次执行的\",{\"1\":{\"71\":1}}],[\"不能进行修改操作\",{\"1\":{\"25\":1}}],[\"不充足需要扩容\",{\"1\":{\"25\":1}}],[\"不同类型的数据库\",{\"1\":{\"515\":1}}],[\"不同类的重名问题\",{\"1\":{\"120\":1}}],[\"不同于主键\",{\"1\":{\"475\":1}}],[\"不同线程向threadlocal存放数据\",{\"1\":{\"162\":1}}],[\"不同包下的类\",{\"1\":{\"121\":1}}],[\"不同包下的子类\",{\"1\":{\"121\":1}}],[\"不同集合类\",{\"0\":{\"33\":1}}],[\"不同的可执行文件都能通过jdbc访问数据库\",{\"1\":{\"515\":1}}],[\"不同的无人机agent的q\",{\"1\":{\"298\":1}}],[\"不同的线程访问到threadlocal对象时\",{\"1\":{\"162\":1}}],[\"不同的对象代表不同的对象锁\",{\"1\":{\"155\":1}}],[\"不同的访问权限\",{\"1\":{\"121\":1}}],[\"不同的文本文件可能会有不同的编码类型\",{\"1\":{\"97\":1}}],[\"不同的实现有着不同的遍历方式\",{\"1\":{\"31\":1}}],[\"不同的集合类具体实现可能会对插入的元素有要求\",{\"1\":{\"23\":1}}],[\"不同的集合有着不同的性质\",{\"1\":{\"21\":1}}],[\"不同之处\",{\"1\":{\"22\":1}}],[\"不同对象的属性是分开独立存放的\",{\"1\":{\"4\":1}}],[\"不指定具体类型也是可以的\",{\"1\":{\"16\":1}}],[\"不得是其他类型\",{\"1\":{\"15\":1}}],[\"vˉπ0​\",{\"1\":{\"437\":1,\"440\":1}}],[\"vˉπ​=es∼d​\",{\"1\":{\"435\":1}}],[\"vˉπ​=s∈s∑​d\",{\"1\":{\"435\":1}}],[\"vˉπ​\",{\"1\":{\"435\":1,\"437\":1,\"440\":1}}],[\"v^\",{\"1\":{\"416\":1}}],[\"vt​\",{\"1\":{\"397\":3}}],[\"vt+1​\",{\"1\":{\"397\":2}}],[\"vu\",{\"1\":{\"355\":1}}],[\"v0​\",{\"1\":{\"355\":2}}],[\"vπ1​​\",{\"1\":{\"355\":1}}],[\"vπ1​​=rπ1​​+γpπ1​​vπ1​​\",{\"1\":{\"355\":1}}],[\"vπ0​​是通过迭代算法来求的\",{\"1\":{\"355\":1}}],[\"vπ0​​=rπ0​​+γpπ0​​vπ0​​\",{\"1\":{\"355\":1}}],[\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",{\"1\":{\"353\":1}}],[\"vπk​​=\",{\"1\":{\"353\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​policyimprovement\",{\"1\":{\"362\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​\",{\"1\":{\"351\":1,\"355\":1}}],[\"vπk​​\",{\"1\":{\"351\":1,\"353\":1,\"362\":1}}],[\"vπk​\",{\"1\":{\"351\":2,\"353\":1}}],[\"vπ​=\",{\"1\":{\"331\":1,\"332\":1}}],[\"vπ​=rπ​+γpπ​vπ​​\",{\"1\":{\"331\":1}}],[\"vπ​\",{\"1\":{\"312\":1,\"325\":2,\"327\":1,\"329\":1,\"330\":3,\"331\":4,\"333\":5,\"334\":1,\"340\":2,\"342\":1,\"360\":1,\"397\":1,\"398\":4,\"418\":1,\"419\":2,\"420\":2,\"421\":5,\"422\":1,\"423\":1,\"435\":2}}],[\"v=b3\",{\"1\":{\"455\":1}}],[\"v=\",{\"1\":{\"455\":3}}],[\"v=f\",{\"1\":{\"343\":1,\"346\":1}}],[\"v=πmax​\",{\"1\":{\"340\":1}}],[\"vk​\",{\"1\":{\"347\":1}}],[\"vk​→vπ​=\",{\"1\":{\"332\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​\",{\"1\":{\"355\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​这里的vk​并不是\",{\"1\":{\"348\":1}}],[\"vk+1​=rπ​+γpπ​vk​​\",{\"1\":{\"332\":1}}],[\"vk+1​=f\",{\"1\":{\"347\":1}}],[\"v2​\",{\"1\":{\"332\":1}}],[\"v1​=rπ1​​+γpπ1​​v0​\",{\"1\":{\"355\":1}}],[\"v1​\",{\"1\":{\"332\":1}}],[\"version\",{\"1\":{\"666\":1}}],[\"version=\",{\"1\":{\"545\":2,\"552\":1,\"554\":1}}],[\"very\",{\"1\":{\"295\":1}}],[\"vector\",{\"0\":{\"331\":1},\"1\":{\"331\":1,\"334\":1,\"340\":1}}],[\"vehicles\",{\"1\":{\"289\":1}}],[\"vehicular\",{\"1\":{\"288\":1},\"2\":{\"301\":1}}],[\"view\",{\"1\":{\"507\":3}}],[\"view来创建视图\",{\"1\":{\"507\":1}}],[\"visit\",{\"1\":{\"366\":4,\"369\":2}}],[\"virtual\",{\"1\":{\"183\":1}}],[\"via\",{\"1\":{\"167\":1,\"516\":1}}],[\"v+\",{\"1\":{\"64\":2}}],[\"v会返回null\",{\"1\":{\"64\":1}}],[\"v\",{\"1\":{\"56\":7,\"58\":1,\"59\":5,\"61\":1,\"64\":3,\"65\":2,\"229\":1,\"343\":5,\"346\":1,\"348\":2,\"395\":1}}],[\"v>>\",{\"1\":{\"56\":1}}],[\"v>\",{\"1\":{\"56\":3,\"58\":7,\"59\":4,\"60\":4,\"61\":4}}],[\"v就是值的类型\",{\"1\":{\"56\":1}}],[\"varchar\",{\"1\":{\"474\":1,\"475\":3,\"476\":2}}],[\"various\",{\"1\":{\"167\":1}}],[\"var2\",{\"1\":{\"30\":3}}],[\"value就是要设置的值\",{\"1\":{\"569\":1}}],[\"value为object类型\",{\"1\":{\"561\":1}}],[\"value=\",{\"1\":{\"552\":4,\"580\":1,\"679\":2}}],[\"value与\",{\"1\":{\"540\":1}}],[\"value后\",{\"1\":{\"362\":1}}],[\"value的关系\",{\"1\":{\"327\":1}}],[\"valueof\",{\"1\":{\"221\":1,\"227\":1,\"228\":1,\"229\":4}}],[\"value2\",{\"1\":{\"207\":1}}],[\"value1\",{\"1\":{\"207\":1}}],[\"value++\",{\"1\":{\"154\":2,\"155\":3}}],[\"values\",{\"1\":{\"56\":1,\"221\":1,\"416\":2,\"482\":3,\"524\":1,\"526\":2,\"534\":11,\"589\":1,\"590\":1,\"599\":1,\"605\":2,\"624\":1,\"625\":2}}],[\"value\",{\"0\":{\"323\":1,\"325\":1,\"326\":1,\"332\":1,\"333\":1,\"343\":1,\"347\":1,\"355\":1,\"396\":1,\"400\":1,\"404\":1,\"415\":1,\"417\":1,\"435\":1,\"438\":1},\"1\":{\"15\":5,\"25\":2,\"56\":3,\"58\":1,\"59\":9,\"60\":2,\"61\":2,\"65\":1,\"67\":2,\"154\":2,\"155\":4,\"193\":6,\"207\":3,\"208\":3,\"229\":1,\"280\":3,\"281\":8,\"308\":1,\"322\":1,\"325\":5,\"326\":3,\"327\":1,\"330\":1,\"332\":1,\"333\":10,\"334\":4,\"337\":1,\"338\":1,\"340\":1,\"341\":1,\"342\":2,\"347\":1,\"348\":3,\"351\":3,\"353\":2,\"354\":1,\"355\":12,\"356\":2,\"360\":2,\"362\":6,\"364\":6,\"366\":3,\"367\":2,\"369\":1,\"377\":2,\"396\":1,\"398\":2,\"400\":2,\"401\":1,\"404\":2,\"405\":1,\"415\":1,\"432\":1,\"433\":1,\"435\":1,\"569\":2,\"640\":2}}],[\"void类\",{\"1\":{\"229\":1}}],[\"void\",{\"1\":{\"4\":3,\"5\":2,\"7\":2,\"14\":6,\"15\":3,\"16\":1,\"23\":2,\"24\":3,\"25\":10,\"30\":2,\"32\":2,\"34\":2,\"35\":2,\"36\":1,\"37\":3,\"43\":1,\"44\":4,\"45\":1,\"46\":2,\"47\":1,\"48\":3,\"49\":1,\"50\":2,\"56\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":2,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":2,\"120\":2,\"121\":2,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"139\":1,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":7,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":4,\"166\":2,\"167\":4,\"172\":2,\"173\":2,\"174\":3,\"182\":1,\"183\":1,\"184\":1,\"186\":9,\"191\":4,\"192\":5,\"193\":3,\"198\":3,\"199\":2,\"206\":1,\"207\":3,\"208\":2,\"215\":7,\"216\":1,\"218\":2,\"219\":7,\"220\":2,\"221\":2,\"227\":4,\"228\":1,\"229\":3,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":4,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":6,\"252\":2,\"253\":2,\"254\":3,\"255\":8,\"256\":2,\"257\":4,\"258\":5,\"266\":2,\"267\":6,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":2,\"447\":3,\"448\":2,\"454\":2,\"455\":2,\"517\":1,\"524\":1,\"526\":1,\"527\":1,\"533\":1,\"534\":4,\"538\":3,\"552\":1,\"554\":1,\"558\":1,\"569\":1,\"636\":1,\"638\":1,\"678\":2}}],[\"ibatis\",{\"1\":{\"569\":2,\"571\":2}}],[\"ip连接是否有效\",{\"1\":{\"449\":1}}],[\"ip地址为\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"iid\",{\"1\":{\"360\":1}}],[\"i−γpπk​​\",{\"1\":{\"353\":1}}],[\"i−γpπ​\",{\"1\":{\"332\":2}}],[\"ij​=pπ​\",{\"1\":{\"331\":1}}],[\"i=1n​\",{\"1\":{\"304\":2}}],[\"ieee\",{\"1\":{\"288\":1},\"2\":{\"301\":1}}],[\"img\",{\"1\":{\"538\":1}}],[\"image\",{\"1\":{\"455\":3,\"544\":1,\"546\":1}}],[\"immediate\",{\"0\":{\"328\":1},\"1\":{\"330\":1}}],[\"immutablecollections\",{\"1\":{\"285\":1}}],[\"immutable\",{\"1\":{\"285\":1}}],[\"improvement\",{\"1\":{\"351\":1,\"355\":1,\"364\":1,\"367\":1,\"373\":1,\"396\":1,\"400\":1,\"405\":1}}],[\"implementing\",{\"1\":{\"139\":1}}],[\"implements\",{\"1\":{\"25\":2,\"36\":1,\"42\":1,\"58\":2,\"67\":1,\"131\":1,\"132\":1,\"133\":1,\"219\":2,\"220\":1,\"282\":2,\"638\":1}}],[\"importance\",{\"0\":{\"315\":1}}],[\"import\",{\"1\":{\"23\":1,\"120\":3,\"121\":1,\"208\":4,\"229\":2,\"254\":1,\"274\":1,\"524\":2,\"554\":1}}],[\"i都会更新成数组中下一个元素\",{\"1\":{\"237\":1}}],[\"i+1\",{\"1\":{\"527\":1}}],[\"i+\",{\"1\":{\"237\":1}}],[\"i++\",{\"1\":{\"142\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":8,\"161\":1,\"172\":2,\"237\":1,\"274\":1,\"527\":1,\"547\":1,\"599\":1,\"604\":1}}],[\"i就是每一个数组中的元素\",{\"1\":{\"237\":1}}],[\"its\",{\"1\":{\"167\":1}}],[\"it\",{\"1\":{\"139\":1,\"172\":2,\"289\":1,\"366\":1,\"517\":3}}],[\"item和index分别代表我们在foreach标签中使用每一个元素和下标的变量名称\",{\"1\":{\"604\":1}}],[\"item=\",{\"1\":{\"604\":1,\"605\":1}}],[\"item\",{\"1\":{\"25\":2,\"33\":1,\"547\":2,\"604\":2,\"605\":3}}],[\"iteration\",{\"0\":{\"347\":1,\"350\":1,\"354\":1,\"355\":2,\"356\":1,\"357\":1},\"1\":{\"347\":1,\"353\":2,\"354\":2,\"355\":10,\"356\":3,\"361\":1,\"362\":1,\"364\":1,\"367\":1}}],[\"iterative\",{\"1\":{\"332\":1,\"377\":1}}],[\"iterator<t>\",{\"1\":{\"36\":1}}],[\"iterator<string>\",{\"1\":{\"34\":1,\"36\":2}}],[\"iterator<e>\",{\"1\":{\"23\":2,\"32\":1,\"37\":1,\"44\":1,\"47\":1,\"67\":1}}],[\"iterator\",{\"1\":{\"23\":2,\"30\":3,\"34\":4,\"36\":3,\"47\":1,\"67\":2,\"173\":1}}],[\"iterable<string>\",{\"1\":{\"36\":1}}],[\"iterable<t>\",{\"1\":{\"36\":1,\"564\":1}}],[\"iterable<e>\",{\"1\":{\"23\":1}}],[\"iterable\",{\"1\":{\"35\":1,\"36\":1}}],[\"isdriverallowed\",{\"1\":{\"517\":1}}],[\"isdirectory\",{\"1\":{\"98\":1}}],[\"isinterrupted\",{\"1\":{\"144\":1}}],[\"is\",{\"1\":{\"139\":3,\"167\":1,\"289\":3,\"304\":1,\"305\":2,\"326\":1,\"338\":1,\"343\":2,\"366\":1,\"371\":2,\"439\":1,\"516\":4,\"517\":3}}],[\"isempty\",{\"1\":{\"23\":1,\"25\":1,\"47\":1,\"56\":1,\"67\":2,\"167\":2,\"174\":1}}],[\"illegalaccessexception\",{\"1\":{\"191\":2,\"192\":1,\"193\":1}}],[\"illegalargumentexception\",{\"1\":{\"25\":1}}],[\"illegal\",{\"1\":{\"25\":1}}],[\"io3\",{\"0\":{\"124\":1}}],[\"io流3\",{\"0\":{\"125\":1}}],[\"io流2\",{\"0\":{\"102\":1}}],[\"io流1\",{\"0\":{\"88\":1}}],[\"io2\",{\"0\":{\"101\":1}}],[\"ioexception\",{\"1\":{\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"199\":1,\"267\":6,\"447\":3,\"448\":2,\"454\":2}}],[\"io中\",{\"1\":{\"88\":1}}],[\"io1\",{\"0\":{\"87\":1}}],[\"io\",{\"1\":{\"25\":2,\"42\":1,\"67\":1,\"95\":2,\"524\":1,\"638\":1}}],[\"i\",{\"1\":{\"24\":3,\"33\":2,\"59\":3,\"71\":4,\"108\":1,\"142\":3,\"147\":5,\"148\":5,\"154\":4,\"155\":12,\"161\":3,\"172\":4,\"173\":1,\"186\":9,\"192\":1,\"193\":12,\"227\":9,\"228\":4,\"229\":6,\"237\":4,\"274\":2,\"282\":2,\"360\":2,\"363\":1,\"454\":5,\"455\":3,\"524\":2,\"527\":7,\"547\":3,\"599\":3,\"604\":3}}],[\"if>\",{\"1\":{\"601\":1,\"630\":2}}],[\"if\",{\"1\":{\"23\":1,\"25\":6,\"59\":10,\"60\":5,\"84\":4,\"90\":1,\"107\":2,\"142\":1,\"144\":1,\"147\":1,\"148\":1,\"167\":2,\"216\":2,\"219\":1,\"227\":1,\"266\":2,\"338\":1,\"343\":1,\"371\":1,\"383\":1,\"455\":1,\"477\":1,\"517\":12,\"527\":2,\"547\":1,\"630\":1}}],[\"id等于2的必须满足等于18岁\",{\"1\":{\"602\":1}}],[\"id等于1的必须同时要满足小于18岁\",{\"1\":{\"602\":1}}],[\"id=1\",{\"1\":{\"580\":2}}],[\"id=\",{\"1\":{\"552\":1,\"554\":1,\"559\":4,\"561\":1,\"562\":1,\"563\":2,\"564\":2,\"569\":2,\"570\":3,\"571\":1,\"577\":2,\"578\":1,\"579\":3,\"581\":1,\"582\":3,\"583\":5,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"601\":1,\"602\":1,\"604\":1,\"605\":1,\"614\":1,\"615\":1,\"623\":1,\"625\":1,\"626\":1,\"630\":1}}],[\"identified\",{\"1\":{\"500\":1}}],[\"identically\",{\"1\":{\"360\":1}}],[\"idle\",{\"1\":{\"295\":1}}],[\"ids\",{\"1\":{\"138\":2}}],[\"id一般是int\",{\"1\":{\"56\":1}}],[\"id\",{\"1\":{\"15\":4,\"280\":4,\"281\":4,\"475\":6,\"476\":1,\"559\":4,\"561\":2,\"562\":3,\"563\":3,\"564\":1,\"569\":12,\"570\":1,\"571\":8,\"577\":2,\"578\":9,\"579\":7,\"580\":4,\"581\":6,\"583\":7,\"590\":2,\"591\":4,\"592\":2,\"601\":3,\"602\":4,\"604\":2,\"614\":2,\"615\":2,\"625\":4,\"626\":3,\"628\":7,\"629\":10,\"630\":12,\"631\":3}}],[\"indirectly\",{\"1\":{\"517\":1}}],[\"independent\",{\"1\":{\"360\":1}}],[\"index=\",{\"1\":{\"604\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"267\":2}}],[\"indexofsublist\",{\"1\":{\"80\":1}}],[\"indexof\",{\"1\":{\"24\":1}}],[\"index++\",{\"1\":{\"25\":1}}],[\"index\",{\"1\":{\"24\":6,\"25\":4,\"508\":3,\"604\":1}}],[\"insertstudent\",{\"1\":{\"625\":1}}],[\"insertalluser\",{\"1\":{\"605\":1}}],[\"insertuser\",{\"1\":{\"605\":1,\"624\":1,\"625\":2}}],[\"insert>\",{\"1\":{\"589\":1,\"590\":1,\"605\":1,\"625\":1}}],[\"insert|update|delete\",{\"1\":{\"509\":1}}],[\"insert\",{\"1\":{\"482\":3,\"524\":1,\"526\":2,\"534\":11,\"588\":2,\"589\":1,\"590\":1,\"599\":1,\"605\":2,\"612\":1,\"624\":2,\"625\":3}}],[\"insecure\",{\"1\":{\"455\":1}}],[\"instantiationexception\",{\"1\":{\"191\":2,\"192\":1,\"193\":1}}],[\"instanceof\",{\"1\":{\"59\":1,\"186\":2,\"208\":2,\"216\":1,\"219\":1}}],[\"instance\",{\"1\":{\"4\":1,\"183\":1,\"192\":4}}],[\"inetsocketaddress\",{\"1\":{\"449\":1}}],[\"inner>\",{\"1\":{\"545\":1}}],[\"inner2\",{\"1\":{\"251\":2,\"658\":1}}],[\"inner1\",{\"1\":{\"251\":2,\"658\":1}}],[\"inner\",{\"1\":{\"251\":12,\"252\":5,\"253\":5,\"254\":3,\"497\":1}}],[\"invoking\",{\"1\":{\"517\":1}}],[\"invoker\",{\"1\":{\"569\":1}}],[\"invoker是mybatis内部编写一个用于反射设置对象属性值的工具\",{\"1\":{\"569\":1}}],[\"invoked\",{\"1\":{\"289\":1}}],[\"invoke不需要对象参数\",{\"1\":{\"192\":1}}],[\"invoke\",{\"1\":{\"192\":3,\"199\":2,\"569\":1}}],[\"invocationtargetexception\",{\"1\":{\"191\":1,\"192\":1,\"193\":1}}],[\"inherited\",{\"1\":{\"205\":1}}],[\"inheritablethreadlocal<>\",{\"1\":{\"163\":1}}],[\"inherits\",{\"1\":{\"139\":1}}],[\"initconfiguration\",{\"1\":{\"632\":2}}],[\"init\",{\"1\":{\"139\":1}}],[\"initial\",{\"1\":{\"60\":3}}],[\"initialcapacity\",{\"1\":{\"25\":5}}],[\"infos\",{\"1\":{\"138\":2}}],[\"info\",{\"1\":{\"117\":3,\"138\":2,\"517\":6,\"636\":1,\"638\":4,\"639\":1,\"647\":1,\"657\":1,\"678\":2}}],[\"in\",{\"0\":{\"288\":1},\"1\":{\"107\":4,\"128\":1,\"139\":1,\"289\":1,\"366\":1,\"383\":1,\"404\":1,\"448\":1,\"449\":1,\"455\":2,\"491\":2,\"532\":1,\"533\":1,\"569\":3,\"604\":2}}],[\"input\",{\"1\":{\"107\":3}}],[\"inputstreamreader\",{\"1\":{\"126\":3,\"448\":2}}],[\"inputstream\",{\"1\":{\"88\":1,\"90\":5,\"91\":9,\"94\":2,\"98\":2,\"107\":1,\"131\":2,\"133\":2,\"448\":1,\"454\":3,\"455\":1,\"552\":3}}],[\"int这样前面添加下划线\",{\"1\":{\"559\":1}}],[\"into\",{\"1\":{\"482\":3,\"524\":1,\"526\":2,\"534\":11,\"589\":1,\"590\":1,\"599\":1,\"605\":2,\"624\":1,\"625\":2}}],[\"into语句来向数据库中插入一条数据\",{\"1\":{\"482\":1}}],[\"int用于存储一般的整数\",{\"1\":{\"474\":1}}],[\"intsummarystatistics\",{\"1\":{\"71\":1}}],[\"ints\",{\"1\":{\"71\":2}}],[\"intel\",{\"1\":{\"455\":1}}],[\"interacting\",{\"1\":{\"304\":1}}],[\"interrupted\",{\"1\":{\"144\":1}}],[\"interruptedexception终止异常\",{\"1\":{\"161\":1}}],[\"interruptedexception\",{\"1\":{\"142\":1,\"143\":1,\"144\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":3,\"161\":2,\"162\":2,\"165\":2,\"172\":4,\"174\":2,\"215\":3}}],[\"interrupt\",{\"1\":{\"144\":1}}],[\"interrupt用法\",{\"1\":{\"144\":1}}],[\"intermediate\",{\"1\":{\"71\":1}}],[\"interface\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"36\":1,\"37\":1,\"43\":1,\"44\":1,\"47\":1,\"56\":2,\"139\":2,\"206\":2,\"207\":4,\"208\":1,\"219\":3,\"220\":1,\"255\":1,\"258\":2,\"282\":1,\"564\":1,\"570\":1,\"589\":1,\"623\":1,\"624\":1,\"631\":1}}],[\"integer的缩写\",{\"1\":{\"559\":1}}],[\"integercache会默认缓存\",{\"1\":{\"227\":1}}],[\"integercache\",{\"1\":{\"227\":4}}],[\"integer>\",{\"1\":{\"15\":1,\"65\":1,\"84\":1}}],[\"integer\",{\"1\":{\"14\":7,\"25\":5,\"60\":2,\"65\":1,\"80\":1,\"183\":2,\"184\":1,\"186\":4,\"193\":4,\"215\":1,\"227\":13,\"228\":7,\"238\":1,\"258\":2,\"280\":3,\"281\":1,\"282\":2,\"527\":2,\"538\":5,\"569\":2,\"580\":2,\"640\":2}}],[\"int\",{\"1\":{\"4\":2,\"5\":1,\"8\":3,\"9\":7,\"14\":2,\"23\":2,\"24\":10,\"25\":9,\"37\":2,\"47\":2,\"56\":2,\"58\":1,\"59\":3,\"60\":4,\"61\":1,\"65\":3,\"67\":1,\"71\":1,\"84\":1,\"91\":1,\"94\":1,\"117\":1,\"121\":1,\"142\":1,\"147\":2,\"148\":2,\"154\":3,\"155\":14,\"161\":1,\"172\":2,\"173\":2,\"183\":2,\"186\":1,\"191\":1,\"192\":3,\"215\":2,\"218\":3,\"219\":1,\"220\":1,\"227\":3,\"235\":2,\"236\":2,\"237\":5,\"238\":4,\"239\":1,\"240\":1,\"241\":3,\"256\":1,\"258\":3,\"266\":4,\"267\":4,\"268\":1,\"274\":1,\"275\":2,\"454\":2,\"455\":1,\"475\":2,\"476\":2,\"524\":2,\"527\":1,\"547\":1,\"554\":1,\"559\":4,\"563\":2,\"569\":6,\"570\":2,\"571\":4,\"577\":3,\"581\":3,\"582\":1,\"583\":3,\"588\":6,\"589\":1,\"591\":4,\"599\":1,\"604\":1,\"624\":1,\"625\":1,\"626\":2,\"628\":8,\"629\":2,\"630\":3,\"631\":1}}],[\"必须设置\",{\"1\":{\"590\":1}}],[\"必须和构造方法的顺序一致\",{\"1\":{\"569\":1}}],[\"必须存在一个根节点\",{\"1\":{\"545\":1}}],[\"必须加\",{\"1\":{\"455\":1}}],[\"必须留一个抽象方法出来\",{\"1\":{\"257\":1}}],[\"必须要进行异常的捕获\",{\"1\":{\"267\":1}}],[\"必须要考虑到出现异常的情况\",{\"1\":{\"264\":1}}],[\"必须要实现抽象类中所有抽象方法\",{\"1\":{\"218\":1}}],[\"必须要有\",{\"1\":{\"161\":1}}],[\"必须使用equals方法\",{\"1\":{\"216\":1}}],[\"必须注意是否安全\",{\"1\":{\"193\":1}}],[\"必须在开始之前\",{\"1\":{\"172\":2}}],[\"必须实现serializable接口才能被序列化\",{\"1\":{\"131\":1}}],[\"必须关闭这个流来完成对资源的释放\",{\"1\":{\"90\":1}}],[\"必须是递增的\",{\"1\":{\"383\":1}}],[\"必须是在持有锁\",{\"1\":{\"161\":1}}],[\"必须是一个对象或是一个类\",{\"1\":{\"155\":1}}],[\"必须是实现\",{\"1\":{\"77\":1}}],[\"必须是number或是number的子类\",{\"1\":{\"15\":1}}],[\"必须调用我们自己定义的构造方法\",{\"1\":{\"9\":1}}],[\"返回缓存对象的拷贝\",{\"1\":{\"612\":1}}],[\"返回多个\",{\"0\":{\"581\":1}}],[\"返回一个规范的响应文本\",{\"1\":{\"455\":1}}],[\"返回泛型t\",{\"1\":{\"191\":1}}],[\"返回的仍然是\",{\"1\":{\"186\":1}}],[\"返回的类型就是什么\",{\"1\":{\"14\":1}}],[\"返回备选方案\",{\"1\":{\"57\":1}}],[\"返回值一样\",{\"1\":{\"258\":1}}],[\"返回值为null\",{\"1\":{\"192\":1}}],[\"返回值就是方法的返回值\",{\"1\":{\"192\":1}}],[\"返回值是当前是否有中断标记\",{\"1\":{\"144\":1}}],[\"返回值是读取的字节数\",{\"1\":{\"91\":1}}],[\"返回值\",{\"1\":{\"60\":1,\"192\":1}}],[\"返回值我们会在后面讨论\",{\"1\":{\"57\":1}}],[\"返回值类型\",{\"1\":{\"5\":1}}],[\"返回当前键值对的哈希值\",{\"1\":{\"56\":1}}],[\"返回当前集合在指定范围内的子集\",{\"1\":{\"24\":1}}],[\"返回当前集合的迭代器\",{\"1\":{\"23\":1}}],[\"返回所有的键值对\",{\"1\":{\"56\":1}}],[\"返回map中存放的所有值\",{\"1\":{\"56\":1}}],[\"返回map中存放的所有键\",{\"1\":{\"56\":1}}],[\"返回其映射的值\",{\"1\":{\"56\":1}}],[\"返回上一个已遍历元素的下标\",{\"1\":{\"37\":1}}],[\"返回下一个待遍历元素的下标\",{\"1\":{\"37\":1}}],[\"返回结点内部存放的元素\",{\"1\":{\"33\":1}}],[\"瞬间变一行\",{\"1\":{\"14\":1}}],[\"><\",{\"1\":{\"546\":1}}],[\">=\",{\"1\":{\"59\":1,\"60\":2,\"71\":1,\"227\":1,\"475\":1,\"476\":1,\"491\":1}}],[\">>>\",{\"1\":{\"66\":1}}],[\">>\",{\"1\":{\"25\":1}}],[\">\",{\"1\":{\"14\":1,\"23\":3,\"25\":2,\"46\":1,\"47\":3,\"50\":1,\"59\":1,\"60\":2,\"64\":3,\"65\":2,\"71\":9,\"140\":2,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"156\":2,\"161\":3,\"162\":2,\"163\":2,\"165\":4,\"172\":3,\"173\":2,\"182\":3,\"183\":1,\"184\":1,\"186\":4,\"192\":4,\"199\":3,\"215\":1,\"227\":8,\"257\":7,\"258\":2,\"268\":1,\"281\":1,\"491\":1,\"507\":1,\"517\":1,\"527\":2,\"545\":4,\"552\":11,\"554\":6,\"559\":4,\"560\":2,\"561\":1,\"562\":1,\"563\":5,\"564\":3,\"569\":4,\"570\":5,\"571\":1,\"577\":2,\"578\":9,\"579\":7,\"580\":1,\"581\":7,\"582\":7,\"583\":15,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"601\":4,\"602\":4,\"604\":2,\"605\":2,\"612\":2,\"614\":1,\"615\":1,\"622\":2,\"623\":1,\"625\":1,\"626\":3,\"628\":3,\"630\":9,\"679\":2}}],[\"这实际上是logger的父级提供的\",{\"1\":{\"646\":1}}],[\"这也证明了mybatis的缓存在生效\",{\"1\":{\"616\":1}}],[\"这导致尽管会话2更新了数据\",{\"1\":{\"611\":1}}],[\"这非常适合处理我们前面说的批量执行sql的问题\",{\"1\":{\"603\":1}}],[\"这需求有点抽象\",{\"1\":{\"602\":1}}],[\"这看似是一个很奇怪的查询条件\",{\"1\":{\"601\":1}}],[\"这与我们之前的xml配置完全一致\",{\"1\":{\"628\":1}}],[\"这与我们之前jdbc中是一样的\",{\"1\":{\"588\":1}}],[\"这与之前的一对一比较类似\",{\"1\":{\"583\":1}}],[\"这一次我们在resultmap中添加constructor标签\",{\"1\":{\"569\":1}}],[\"这一条\",{\"1\":{\"366\":1}}],[\"这会导致mybatis自动处理出现问题\",{\"1\":{\"563\":1}}],[\"这不仅使得我们类定义中充满了get和set方法\",{\"1\":{\"538\":1}}],[\"这并不是解决问题的最好办法\",{\"1\":{\"532\":1}}],[\"这包含资料的精确度\",{\"1\":{\"510\":1}}],[\"这表示写入的资料必须完全符合所有的预设规则\",{\"1\":{\"510\":1}}],[\"这另一个策略会更新到最优的策略\",{\"1\":{\"408\":1}}],[\"这类算法统称为\",{\"1\":{\"367\":1}}],[\"这两种写法效果是完全一样的\",{\"1\":{\"625\":1}}],[\"这两种分数类型都有可能出现\",{\"1\":{\"280\":1}}],[\"这两个算法是一致的\",{\"1\":{\"355\":1}}],[\"这步是更新策略π\",{\"1\":{\"348\":1}}],[\"这\",{\"1\":{\"245\":2}}],[\"这同样不是se中需要学习的内容\",{\"1\":{\"215\":1}}],[\"这玩意学来有啥用\",{\"1\":{\"208\":1}}],[\"这玩意居然能存字符串进去\",{\"1\":{\"80\":1}}],[\"这意味着\",{\"1\":{\"191\":1,\"612\":1}}],[\"这时我们就可以手动抛出一个异常来终止程序继续运行下去\",{\"1\":{\"266\":1}}],[\"这时我们不希望用户将泛型指定为除数字类型外的其他类型\",{\"1\":{\"15\":1}}],[\"这时并没有立即释放锁\",{\"1\":{\"161\":1}}],[\"这时其他线程可以获取到此对象的锁\",{\"1\":{\"161\":1}}],[\"这就提供了可观的性能提升\",{\"1\":{\"612\":1}}],[\"这就是一种多对多的联系\",{\"1\":{\"461\":1}}],[\"这就是引入高速缓存引发的新问题\",{\"1\":{\"154\":1}}],[\"这就必然存在一个中间容器\",{\"1\":{\"174\":1}}],[\"这就产生了死锁\",{\"1\":{\"156\":1}}],[\"这样显然是很冗余的\",{\"1\":{\"677\":1}}],[\"这样用mapper2时\",{\"1\":{\"612\":1}}],[\"这样sqlsession会开启批处理模式\",{\"1\":{\"599\":1}}],[\"这样下面在使用\",{\"1\":{\"589\":1}}],[\"这样mybatis运行时就会打印日志到控制台了\",{\"1\":{\"580\":1}}],[\"这样mybatis就可以通过association来自动处理了\",{\"1\":{\"583\":1}}],[\"这样mybatis就可以正确识别了\",{\"1\":{\"571\":1}}],[\"这样mybatis就可以按照我们的配置来正确找到对应的位置并赋值了\",{\"1\":{\"563\":1}}],[\"这样mybatis就知道该链接哪个数据库\",{\"1\":{\"552\":1}}],[\"这样编写实在是太复杂了\",{\"1\":{\"571\":1}}],[\"这样会更加方便一些\",{\"1\":{\"558\":1}}],[\"这样会节省很多的时间\",{\"1\":{\"526\":1}}],[\"这样会先按照列名1进行排序\",{\"1\":{\"492\":1}}],[\"这样会把\",{\"1\":{\"84\":1}}],[\"这样才能去估计相应的qπ​\",{\"1\":{\"369\":1}}],[\"这样我们就可以获取到自增后的值了\",{\"1\":{\"590\":1}}],[\"这样我们就可以成功实现多对一查询了\",{\"1\":{\"583\":1}}],[\"这样我们就可以根据不同的类型进行选择了\",{\"1\":{\"281\":1}}],[\"这样我们在遍历\",{\"1\":{\"61\":1}}],[\"这样参数名称所表示的就是一个数组\",{\"1\":{\"241\":1}}],[\"这样是不能赋值的\",{\"1\":{\"238\":1}}],[\"这样就可以通过配置文件的形式修改一些功能的默认属性了\",{\"1\":{\"667\":1}}],[\"这样就可以与\",{\"1\":{\"396\":1}}],[\"这样就消除了传递依赖\",{\"1\":{\"466\":1}}],[\"这样就会占用资源\",{\"1\":{\"449\":1}}],[\"这样就是一个实现\",{\"1\":{\"255\":1}}],[\"这样就不同\",{\"1\":{\"244\":1}}],[\"这样就不会得到同一个对象了\",{\"1\":{\"227\":1}}],[\"这样就无需再将代码写在本地\",{\"1\":{\"199\":1}}],[\"这样\",{\"1\":{\"206\":1,\"366\":1,\"495\":1,\"560\":1,\"679\":1}}],[\"这样不断的循环\",{\"1\":{\"174\":1}}],[\"这样不仅代码量大幅度减少\",{\"1\":{\"71\":1}}],[\"这样的话相当于直接从内存中获取而不是再去向数据库索要数据\",{\"1\":{\"610\":1}}],[\"这样的任务称为episodic\",{\"1\":{\"304\":1}}],[\"这样的数字分数\",{\"1\":{\"280\":1}}],[\"这样的异常称为运行时异常\",{\"1\":{\"264\":1}}],[\"这样的\",{\"1\":{\"238\":1}}],[\"这样的做法虽然简单粗暴\",{\"1\":{\"144\":1}}],[\"这样的写法称为装饰者模式\",{\"1\":{\"107\":1}}],[\"这样保存的元素数量就会存在限制\",{\"1\":{\"58\":1}}],[\"这样做是为了更加明确方法的具体功能\",{\"1\":{\"24\":1}}],[\"这些注解并不能像之前xml那样直接修改一些属性\",{\"1\":{\"625\":1}}],[\"这些操作相比查询操作来说非常简单就可以实现\",{\"1\":{\"592\":1}}],[\"这些方法默认情况下返回的结果都是int类型的\",{\"1\":{\"588\":1}}],[\"这些方法并没有被重写\",{\"1\":{\"236\":1}}],[\"这些数据库操作语句就可以构成一个事务\",{\"1\":{\"510\":1}}],[\"这些数据被存放在结构化的数据表里\",{\"1\":{\"460\":1}}],[\"这些特征也称为实体的一种属性\",{\"1\":{\"461\":1}}],[\"这些可以省\",{\"1\":{\"219\":1}}],[\"这些都是大佬写出来的\",{\"1\":{\"60\":1}}],[\"这些映射关系被存储为键值对\",{\"1\":{\"56\":1}}],[\"这些是新的容量和扩容阈值\",{\"1\":{\"60\":1}}],[\"这些是list的特殊转换\",{\"1\":{\"24\":1}}],[\"这些是list的专用迭代器\",{\"1\":{\"24\":1}}],[\"这些是list中独特的搜索操作\",{\"1\":{\"24\":1}}],[\"这些是list中独特的位置直接访问操作\",{\"1\":{\"24\":1}}],[\"这些是比较以及哈希计算相关的操作\",{\"1\":{\"23\":1}}],[\"这些是批量执行的操作\",{\"1\":{\"23\":1}}],[\"这些是修改相关的操作\",{\"1\":{\"23\":1}}],[\"这些是查询相关的操作\",{\"1\":{\"23\":1}}],[\"这种父子关系类似于继承\",{\"1\":{\"655\":1}}],[\"这种格式有助于程序的日志读取\",{\"1\":{\"648\":1}}],[\"这种迭代算法称为\",{\"1\":{\"347\":1}}],[\"这种迭代器因为能够双向遍历\",{\"1\":{\"37\":1}}],[\"这种方式创建的列表\",{\"1\":{\"285\":1}}],[\"这种形式也可以\",{\"1\":{\"281\":1}}],[\"这种局部内部类的形式\",{\"1\":{\"253\":1}}],[\"这种即可\",{\"1\":{\"219\":1}}],[\"这种动态获取信息及动态调用对象方法的功能叫java的反射机制\",{\"1\":{\"179\":1}}],[\"这种语法只支持实现了autocloseable接口的类\",{\"1\":{\"90\":2}}],[\"这种风格将要处理的元素集合看作一种流\",{\"1\":{\"71\":1}}],[\"这种情况我们将\",{\"1\":{\"437\":1}}],[\"这种情况是可以简化的\",{\"1\":{\"257\":1}}],[\"这种情况实际上会被优化为下面的写法\",{\"1\":{\"245\":1}}],[\"这种情况不用扩了\",{\"1\":{\"60\":1}}],[\"这种情况就是哈希冲突了\",{\"1\":{\"59\":1}}],[\"这种情况下的\",{\"1\":{\"437\":1}}],[\"这种情况下就很容易出问题\",{\"1\":{\"173\":1}}],[\"这种情况下\",{\"1\":{\"25\":1}}],[\"这种集合类型比较特殊\",{\"1\":{\"47\":1}}],[\"这将会导致无限循环\",{\"1\":{\"36\":1}}],[\"这是日志级别中倒数第二大的\",{\"1\":{\"638\":1}}],[\"这是在开始之前必须要掌握的内容\",{\"1\":{\"547\":1}}],[\"这是一种特殊的语言\",{\"1\":{\"472\":1}}],[\"这是一个无限制的流\",{\"1\":{\"71\":1}}],[\"这是我们所求的量\",{\"1\":{\"421\":1}}],[\"这是来求解\",{\"1\":{\"364\":1}}],[\"这是为了提升效率\",{\"1\":{\"227\":1}}],[\"这是浅拷贝\",{\"1\":{\"220\":1}}],[\"这是强制要求的\",{\"1\":{\"218\":1}}],[\"这是因为java代码编译后形参名称无法保留\",{\"1\":{\"571\":1}}],[\"这是因为数据库字段名称与类中字段名称不匹配导致的\",{\"1\":{\"563\":1}}],[\"这是因为此用户还没有权限\",{\"1\":{\"501\":1}}],[\"这是因为\",{\"1\":{\"227\":1,\"629\":1}}],[\"这是因为timer内存维护了一个任务队列和一个工作线程\",{\"1\":{\"167\":1}}],[\"这是因为集合类在删除元素时\",{\"1\":{\"25\":1}}],[\"这是arraylist的其中一个构造方法\",{\"1\":{\"25\":1}}],[\"这个rootlogger对象为所有日志记录器的最顶层父级对象\",{\"1\":{\"655\":1}}],[\"这个实现类是由mybatis根据我们的配置自动生成的\",{\"1\":{\"570\":1}}],[\"这个数据库表中存在如下决定关系\",{\"1\":{\"467\":1}}],[\"这个仍然与之前一致\",{\"1\":{\"364\":1}}],[\"这个\",{\"1\":{\"363\":1}}],[\"这个便成为\",{\"1\":{\"308\":1}}],[\"这个参数就是异常的原因\",{\"1\":{\"265\":1}}],[\"这个抽象类直接就定义好了\",{\"1\":{\"255\":1}}],[\"这个长度是字符的数量\",{\"1\":{\"244\":1}}],[\"这个接口中什么都没定义\",{\"1\":{\"220\":1}}],[\"这个默认方法没有任何作用\",{\"1\":{\"219\":1}}],[\"这个注解默认情况下可以省略\",{\"1\":{\"216\":1}}],[\"这个我们会在最后一章的反射中进行讲解\",{\"1\":{\"215\":1}}],[\"这个类在初始化时会对类中其他本地方法进行注册\",{\"1\":{\"215\":1}}],[\"这个工具类也经常被使用到\",{\"1\":{\"80\":1}}],[\"这个时候如果阈值大于0\",{\"1\":{\"60\":1}}],[\"这个东西决定了hashmap的扩容效果\",{\"1\":{\"58\":1}}],[\"这个就是哈希表本体了\",{\"1\":{\"58\":1}}],[\"这个是内部接口entry\",{\"1\":{\"56\":1}}],[\"这个需要我们学习了map之后再来讨论\",{\"1\":{\"48\":1}}],[\"这个同样是删除指定元素\",{\"1\":{\"47\":1}}],[\"这个迭代器也是单向的\",{\"1\":{\"44\":1}}],[\"这个迭代器是针对于list的强化版本\",{\"1\":{\"37\":1}}],[\"这个效果跟上面的写法是完全一样的\",{\"1\":{\"35\":1}}],[\"这个方法我们会在jvm篇视频教程中详细介绍\",{\"1\":{\"215\":1}}],[\"这个方法我们同样会放到多线程中进行介绍\",{\"1\":{\"47\":1}}],[\"这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量\",{\"1\":{\"91\":1}}],[\"这个方法会在多线程部分中进行介绍\",{\"1\":{\"36\":1}}],[\"这个方法会在执行排序时被调用\",{\"1\":{\"14\":1}}],[\"这个方法是在\",{\"1\":{\"35\":1}}],[\"这个方法接受一个consumer\",{\"1\":{\"35\":1}}],[\"这个生成的list是只读的\",{\"1\":{\"25\":1}}],[\"这个套娃是可以一直套下去的\",{\"1\":{\"25\":1}}],[\"这个只做了解就行\",{\"1\":{\"25\":1}}],[\"这个操作并不是一定会添加成功\",{\"1\":{\"23\":1}}],[\"这里只需要包括一个script标签我们就能像之前xml那样编写动态sql了\",{\"1\":{\"630\":1}}],[\"这里只是对两个对象进行equals判断\",{\"1\":{\"25\":1}}],[\"这里就暂时先介绍这么多\",{\"1\":{\"593\":1}}],[\"这里就不多做介绍了\",{\"1\":{\"592\":1}}],[\"这里就不再介绍了\",{\"1\":{\"497\":1}}],[\"这里就不解释了\",{\"1\":{\"60\":1}}],[\"这里就不列出了\",{\"1\":{\"44\":1}}],[\"这里usegeneratedkeys设置为true表示我们希望获取数据库生成的键\",{\"1\":{\"590\":1}}],[\"这里id实际上就是param1\",{\"1\":{\"571\":1}}],[\"这里调用我们编写的接口方法\",{\"1\":{\"570\":1}}],[\"这里建议将对应的xml配置也放到放到同包中\",{\"1\":{\"570\":1}}],[\"这里截取部分mybatis源代码进行演示\",{\"1\":{\"569\":1}}],[\"这里不进行介绍\",{\"1\":{\"563\":1}}],[\"这里不讲解原理\",{\"1\":{\"173\":1}}],[\"这里有一个rowbounds参数\",{\"1\":{\"563\":1}}],[\"这里有多种mobility\",{\"1\":{\"299\":1}}],[\"这里也可以使用<id>标签\",{\"1\":{\"563\":1}}],[\"这里可以用不同的方法来近似\",{\"1\":{\"441\":1}}],[\"这里在视频没有详细介绍\",{\"1\":{\"440\":1}}],[\"这里包含了一个\",{\"1\":{\"421\":1}}],[\"这里\",{\"1\":{\"351\":1}}],[\"这里采用离散化空间坐标\",{\"1\":{\"298\":1}}],[\"这里t可以是任何类型\",{\"1\":{\"281\":1}}],[\"这里发生的是数组越界异常\",{\"1\":{\"267\":1}}],[\"这里仅仅是对正则表达式的简单使用\",{\"1\":{\"246\":1}}],[\"这里字符串是oooo\",{\"1\":{\"246\":1}}],[\"这里进行4次加法运算\",{\"1\":{\"245\":1}}],[\"这里ceiling表示向上取整\",{\"1\":{\"229\":1}}],[\"这里会有一个integercache\",{\"1\":{\"227\":1}}],[\"这里会判断容量是否充足\",{\"1\":{\"25\":1}}],[\"这里本质上就是被自动包装成了一个integer类型的对象\",{\"1\":{\"227\":1}}],[\"这里使用filehandler类型\",{\"1\":{\"648\":1}}],[\"这里使用gid作为分组id的逻辑外键\",{\"1\":{\"583\":1}}],[\"这里使用javap命令对class文件进行反编译得到\",{\"1\":{\"221\":1}}],[\"这里使用的是list的迭代器在进行遍历操作\",{\"1\":{\"30\":1}}],[\"这里向上抛出一下异常\",{\"1\":{\"220\":1}}],[\"这里要获取field类的modifiers字段进行修改\",{\"1\":{\"193\":1}}],[\"这里变成ioexception是因为调用close\",{\"1\":{\"90\":1}}],[\"这里因为本来就是integer\",{\"1\":{\"71\":1}}],[\"这里返回m\",{\"1\":{\"64\":1}}],[\"这里返回原来的value+m\",{\"1\":{\"64\":2}}],[\"这里多了一个指向前一个结点和后一个结点的引用\",{\"1\":{\"61\":1}}],[\"这里直接创建一个新的consolehandler对象\",{\"1\":{\"647\":1}}],[\"这里直接设定为控制台输出\",{\"1\":{\"517\":1}}],[\"这里直接将待插入结点等于原本冲突的结点\",{\"1\":{\"59\":1}}],[\"这里直接o2\",{\"1\":{\"14\":1}}],[\"这里计算完键的哈希值之后\",{\"1\":{\"59\":1}}],[\"这里用的是url\",{\"1\":{\"554\":1}}],[\"这里用的是内部类entry在表示\",{\"1\":{\"56\":1}}],[\"这里用到了迭代器\",{\"1\":{\"23\":1}}],[\"这里需要用到insert标签\",{\"1\":{\"589\":1}}],[\"这里需要通过迭代算法来精确求出\",{\"1\":{\"355\":1}}],[\"这里需要特别说一下\",{\"1\":{\"238\":1}}],[\"这里需要特别注意\",{\"1\":{\"9\":1}}],[\"这里需要填写两个泛型参数\",{\"1\":{\"56\":1}}],[\"这里需要介绍一下优先级队列\",{\"1\":{\"46\":1}}],[\"这里做了解就行了\",{\"1\":{\"45\":1}}],[\"这里随便写的\",{\"1\":{\"36\":1}}],[\"这里我们打印一下系统名称和版本\",{\"1\":{\"666\":1}}],[\"这里我们会得到一个\",{\"1\":{\"655\":1}}],[\"这里我们先暂时不介绍继承关系\",{\"1\":{\"646\":1}}],[\"这里我们不如再做的更加极致一点\",{\"1\":{\"632\":1}}],[\"这里我们连续获取了两次id为1的用户\",{\"1\":{\"611\":1}}],[\"这里我们连续插入两个同样的字符串\",{\"1\":{\"48\":1}}],[\"这里我们使用if标签表示里面的内容会在判断条件满足时拼接到后面\",{\"1\":{\"601\":1}}],[\"这里我们可以直接尝试进行事务的提交\",{\"1\":{\"593\":1}}],[\"这里我们可以自由传入任意数量的字符串\",{\"1\":{\"241\":1}}],[\"这里我们将parametertype类型设置为我们的实体类型\",{\"1\":{\"589\":1}}],[\"这里我们让user左连接到book表中\",{\"1\":{\"581\":1}}],[\"这里我们让age在赋值时增加一次\",{\"1\":{\"569\":1}}],[\"这里我们分别配置了两个select标签用于分别查询用户基本信息和详细信息\",{\"1\":{\"579\":1}}],[\"这里我们直接使用左连接\",{\"1\":{\"578\":1}}],[\"这里我们在resultmap标签中配置了一些result标签\",{\"1\":{\"563\":1}}],[\"这里我们填写刚刚的id\",{\"1\":{\"560\":1}}],[\"这里我们需要修改一下user表来记录每一个用户所属的小组id\",{\"1\":{\"583\":1}}],[\"这里我们需要在mybatis配置文件中添加\",{\"1\":{\"580\":1}}],[\"这里我们需要使用selectlist方法来执行\",{\"1\":{\"564\":1}}],[\"这里我们需要根据用户id查询\",{\"1\":{\"559\":1}}],[\"这里我们需要特别注意一下\",{\"1\":{\"251\":1}}],[\"这里我们选择使用父类的带参构造\",{\"1\":{\"265\":1}}],[\"这里我们定义一个test注解\",{\"1\":{\"206\":1}}],[\"这里我们定义一个info静态变量\",{\"1\":{\"117\":1}}],[\"这里我们随便写一个类\",{\"1\":{\"36\":1}}],[\"这里我们接着介绍另一个列表实现类\",{\"1\":{\"25\":1}}],[\"这里同样是进行取余操作\",{\"1\":{\"59\":1}}],[\"这里同样只需要一个comparator就行了\",{\"1\":{\"24\":1}}],[\"这里同样用到了迭代器\",{\"1\":{\"24\":1}}],[\"这里传入的类型是什么\",{\"1\":{\"14\":1}}],[\"这里是每个无人机都有一张自己的q\",{\"1\":{\"298\":1}}],[\"这里是求和\",{\"1\":{\"71\":1}}],[\"这里是倒着往回遍历\",{\"1\":{\"37\":1}}],[\"这里是\",{\"1\":{\"9\":1}}],[\"这里没有使用this\",{\"1\":{\"7\":1}}],[\"这里实际上是将方法参数的局部变量name赋值为本身\",{\"1\":{\"7\":1}}],[\"这里编写代码跟我们之前在main中是一样的\",{\"1\":{\"5\":1}}],[\"这里的查询操作实际上只进行了一次\",{\"1\":{\"611\":1}}],[\"这里的参数我们依然选择使用user\",{\"1\":{\"591\":1}}],[\"这里的column和javatype可以不填\",{\"1\":{\"578\":1}}],[\"这里的id与用户id一致\",{\"1\":{\"577\":1}}],[\"这里的i就是最终得到的下标位置了\",{\"1\":{\"59\":1}}],[\"这里的object就是刚刚构造好的实体类对象\",{\"1\":{\"569\":1}}],[\"这里的策略是随机性\",{\"1\":{\"440\":1}}],[\"这里的最优策略πk+1​是一个\",{\"1\":{\"348\":1}}],[\"这里的name是其所依附对象的\",{\"1\":{\"251\":1}}],[\"这里的话只能使用接口中的方法\",{\"1\":{\"219\":1}}],[\"这里的\",{\"1\":{\"80\":1,\"624\":1}}],[\"这里的transient关键字我们会在后面i\",{\"1\":{\"25\":1}}],[\"这里的p1存放的是对象的引用\",{\"1\":{\"4\":1}}],[\"这里的a存放的是具体的某个值\",{\"1\":{\"4\":1}}],[\"这里定义的人类具有三个属性\",{\"1\":{\"4\":1}}],[\"ognl\",{\"1\":{\"601\":1}}],[\"our\",{\"1\":{\"517\":1}}],[\"outer>\",{\"1\":{\"545\":1}}],[\"outside\",{\"1\":{\"517\":1}}],[\"outofmemoryerror\",{\"1\":{\"264\":1}}],[\"out也是printstream\",{\"1\":{\"127\":1}}],[\"out就是一个printstream\",{\"1\":{\"127\":2}}],[\"output\",{\"1\":{\"92\":2,\"93\":1,\"94\":1,\"97\":1,\"113\":1,\"129\":1,\"131\":2,\"133\":2}}],[\"outputstreamwriter\",{\"1\":{\"126\":3,\"448\":4,\"455\":2}}],[\"outputstream\",{\"1\":{\"88\":1,\"92\":6,\"93\":3,\"94\":2,\"131\":3,\"133\":3,\"448\":2,\"454\":1}}],[\"out\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"237\":2,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":2,\"275\":1,\"281\":1,\"447\":6,\"448\":9,\"449\":1,\"454\":1,\"455\":6,\"516\":1,\"517\":1,\"524\":1,\"527\":1,\"532\":1,\"533\":2,\"547\":1,\"554\":1,\"558\":1,\"560\":1,\"561\":1,\"562\":1,\"564\":3,\"569\":1,\"570\":2,\"571\":1,\"593\":2,\"611\":6,\"612\":2,\"616\":1,\"625\":1,\"646\":1,\"655\":2,\"658\":3,\"665\":1,\"666\":2,\"672\":3,\"678\":2}}],[\"owner或db\",{\"1\":{\"472\":1}}],[\"os\",{\"1\":{\"455\":1,\"666\":2}}],[\"o流进行网络数据传输\",{\"1\":{\"448\":1}}],[\"otherwise>\",{\"1\":{\"602\":1}}],[\"other\",{\"1\":{\"338\":1}}],[\"ordinary\",{\"1\":{\"544\":1}}],[\"order\",{\"1\":{\"492\":2}}],[\"org\",{\"1\":{\"539\":1,\"552\":3,\"554\":2,\"569\":2,\"571\":2,\"601\":1,\"630\":1}}],[\"original\",{\"1\":{\"517\":1}}],[\"originalepisode\",{\"1\":{\"366\":1}}],[\"oracle\",{\"1\":{\"460\":1}}],[\"or\",{\"1\":{\"304\":1,\"325\":1,\"377\":1,\"397\":1,\"420\":1,\"491\":1,\"532\":2,\"533\":1}}],[\"open和close用于控制起始和结束位置添加的符号\",{\"1\":{\"604\":1}}],[\"open=\",{\"1\":{\"604\":1}}],[\"opening\",{\"1\":{\"580\":1}}],[\"opensession\",{\"1\":{\"552\":1,\"554\":1,\"558\":1,\"570\":1,\"593\":2,\"599\":1,\"611\":2}}],[\"operation\",{\"1\":{\"71\":2}}],[\"operator\",{\"1\":{\"24\":3}}],[\"option来进行配置\",{\"1\":{\"631\":1}}],[\"options来控制单个操作的缓存启用\",{\"1\":{\"631\":1}}],[\"options\",{\"1\":{\"625\":1,\"631\":2}}],[\"options注解\",{\"1\":{\"625\":1}}],[\"option是指当创建后\",{\"1\":{\"507\":1}}],[\"option\",{\"1\":{\"502\":2,\"507\":1}}],[\"optimization\",{\"0\":{\"421\":1},\"1\":{\"377\":1}}],[\"optimality\",{\"0\":{\"339\":1},\"1\":{\"337\":1,\"404\":1}}],[\"optimal\",{\"0\":{\"338\":1,\"404\":1},\"1\":{\"337\":2,\"338\":1,\"405\":1}}],[\"opinion\",{\"1\":{\"290\":1}}],[\"one和\",{\"1\":{\"629\":1}}],[\"one\",{\"1\":{\"629\":2}}],[\"on进行左连接\",{\"1\":{\"497\":1}}],[\"on进行内连接\",{\"1\":{\"497\":1}}],[\"on\",{\"0\":{\"406\":1,\"407\":1,\"411\":1},\"1\":{\"288\":1,\"408\":1,\"409\":1,\"425\":1,\"429\":1,\"497\":3,\"502\":2,\"508\":2,\"509\":1,\"578\":1,\"581\":1,\"583\":2},\"2\":{\"301\":1}}],[\"onlyifabsent\",{\"1\":{\"59\":2}}],[\"o+\",{\"1\":{\"246\":2}}],[\"oooo\",{\"1\":{\"246\":1}}],[\"obtainvia来指定默认值的获取方式\",{\"1\":{\"540\":1}}],[\"obtained\",{\"1\":{\"326\":1}}],[\"obejctive\",{\"0\":{\"418\":1},\"1\":{\"421\":1}}],[\"obj\",{\"1\":{\"199\":5,\"215\":2,\"216\":4,\"235\":1}}],[\"objective\",{\"1\":{\"419\":2,\"420\":1,\"426\":1,\"427\":1,\"433\":1}}],[\"objectinputstream\",{\"1\":{\"131\":2,\"133\":2}}],[\"object类中的\",{\"0\":{\"220\":1}}],[\"objectoutputstream\",{\"1\":{\"131\":2,\"133\":2}}],[\"objectoutputstream不仅支持基本数据类型\",{\"1\":{\"130\":1}}],[\"object>\",{\"1\":{\"67\":1,\"561\":1,\"571\":1,\"665\":1}}],[\"objects\",{\"1\":{\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1,\"84\":3}}],[\"object\",{\"0\":{\"215\":1},\"1\":{\"15\":2,\"16\":2,\"23\":4,\"24\":4,\"25\":3,\"44\":2,\"47\":4,\"56\":5,\"67\":2,\"84\":4,\"139\":2,\"156\":4,\"161\":3,\"174\":1,\"183\":1,\"192\":3,\"199\":2,\"215\":4,\"216\":3,\"219\":2,\"220\":1,\"235\":1,\"236\":1,\"238\":5,\"264\":1,\"266\":2,\"267\":3,\"280\":4,\"281\":5,\"527\":6,\"544\":1,\"569\":5,\"588\":3}}],[\"obsolete\",{\"1\":{\"167\":2}}],[\"oftype=\",{\"1\":{\"581\":1,\"582\":1}}],[\"of是java9的特性\",{\"1\":{\"562\":1}}],[\"off\",{\"0\":{\"314\":1,\"316\":1,\"406\":1,\"408\":1,\"410\":1},\"1\":{\"408\":1,\"409\":1,\"640\":2}}],[\"offerlast\",{\"1\":{\"44\":1}}],[\"offerfirst\",{\"1\":{\"44\":1}}],[\"offer\",{\"1\":{\"43\":3,\"46\":6,\"174\":1}}],[\"of\",{\"0\":{\"295\":1,\"328\":1,\"329\":1,\"396\":1,\"400\":1,\"404\":1,\"417\":1},\"1\":{\"139\":1,\"285\":6,\"289\":3,\"295\":1,\"304\":4,\"305\":3,\"325\":1,\"326\":1,\"330\":2,\"343\":1,\"360\":1,\"366\":1,\"367\":1,\"377\":1,\"384\":1,\"404\":1,\"420\":1,\"427\":1,\"516\":1,\"517\":1,\"562\":1,\"571\":1,\"599\":1,\"604\":1,\"605\":1}}],[\"o操作一般不能重复读取内容\",{\"1\":{\"108\":1}}],[\"o操作的并不是bufferedinputstream\",{\"1\":{\"107\":1}}],[\"o操作时\",{\"1\":{\"91\":1}}],[\"o设备的速度一般都达不到内存的读取速度\",{\"1\":{\"103\":1}}],[\"o设备去获取数据\",{\"1\":{\"103\":1}}],[\"oject类中的\",{\"1\":{\"84\":1}}],[\"oldthr\",{\"1\":{\"60\":4}}],[\"oldtab\",{\"1\":{\"60\":5}}],[\"oldcap\",{\"1\":{\"60\":5}}],[\"oldcapacity\",{\"1\":{\"25\":3}}],[\"oldvalue\",{\"1\":{\"59\":3}}],[\"o中介绍用途\",{\"1\":{\"25\":1}}],[\"o\",{\"1\":{\"15\":2,\"23\":3,\"24\":2,\"25\":3,\"44\":2,\"47\":3,\"56\":1,\"84\":10,\"246\":15,\"281\":1}}],[\"o2\",{\"1\":{\"14\":5,\"156\":3}}],[\"o1就行\",{\"1\":{\"14\":1}}],[\"o1\",{\"1\":{\"14\":5,\"156\":3,\"161\":5}}],[\"override表示重写父类方法\",{\"1\":{\"203\":1}}],[\"override\",{\"1\":{\"14\":2,\"23\":1,\"36\":3,\"47\":1,\"84\":3,\"166\":1,\"167\":1,\"204\":1,\"206\":1,\"216\":3,\"218\":1,\"219\":1,\"220\":2,\"255\":2,\"256\":1,\"266\":1,\"282\":2,\"672\":2}}],[\"8月\",{\"1\":{\"647\":1,\"657\":2}}],[\"854\",{\"1\":{\"474\":2}}],[\"81\",{\"1\":{\"455\":1}}],[\"8192\",{\"1\":{\"449\":1}}],[\"8之前存放在永久代\",{\"1\":{\"180\":1}}],[\"8已经为集合框架中包含的所有数据结构提供了一个默认的spliterator实现\",{\"1\":{\"173\":1}}],[\"89\",{\"1\":{\"65\":1}}],[\"88\",{\"1\":{\"65\":1}}],[\"800\",{\"1\":{\"638\":1}}],[\"807\",{\"1\":{\"474\":1}}],[\"808\",{\"1\":{\"474\":1}}],[\"8080\",{\"1\":{\"447\":3,\"448\":2,\"449\":1,\"454\":2,\"455\":5}}],[\"80\",{\"1\":{\"65\":1}}],[\"8新增方法\",{\"1\":{\"24\":1}}],[\"8\",{\"1\":{\"14\":3,\"25\":2,\"71\":1,\"77\":2,\"88\":1,\"204\":1,\"205\":1,\"239\":1,\"275\":1,\"285\":2,\"455\":2,\"545\":2,\"552\":1,\"554\":1}}],[\"900\",{\"1\":{\"638\":1}}],[\"99\",{\"1\":{\"455\":1}}],[\"94\",{\"1\":{\"455\":3}}],[\"9+\",{\"1\":{\"285\":1}}],[\"92\",{\"1\":{\"65\":1,\"280\":1}}],[\"95\",{\"1\":{\"65\":1}}],[\"98\",{\"1\":{\"65\":1}}],[\"9\",{\"1\":{\"14\":3,\"77\":1,\"173\":2,\"246\":1,\"274\":1,\"275\":1,\"285\":1,\"455\":3,\"474\":2}}],[\"700\",{\"1\":{\"638\":1}}],[\"74f6c5d8\",{\"1\":{\"580\":1}}],[\"775\",{\"1\":{\"474\":2}}],[\"7新增了try\",{\"1\":{\"90\":1}}],[\"72\",{\"1\":{\"65\":1}}],[\"75的hashmap\",{\"1\":{\"67\":1}}],[\"75\",{\"1\":{\"58\":1,\"60\":2,\"280\":1}}],[\"7\",{\"1\":{\"14\":3,\"204\":1,\"239\":1,\"275\":1,\"455\":2,\"525\":1,\"593\":1}}],[\"39\",{\"1\":{\"657\":2}}],[\"37\",{\"1\":{\"636\":1,\"647\":1}}],[\"372\",{\"1\":{\"474\":2}}],[\"3306\",{\"1\":{\"516\":1,\"524\":1,\"632\":1,\"664\":1}}],[\"32767\",{\"1\":{\"474\":1}}],[\"32768\",{\"1\":{\"474\":1}}],[\"3nf\",{\"0\":{\"466\":1}}],[\"3nf对依赖关系进一步加强\",{\"1\":{\"463\":1}}],[\"36\",{\"1\":{\"455\":2}}],[\"3d部署和移动问题\",{\"1\":{\"290\":1}}],[\"3d位置进行优化处理\",{\"1\":{\"290\":1}}],[\"300\",{\"1\":{\"638\":1}}],[\"3000\",{\"1\":{\"144\":1,\"165\":2,\"174\":1,\"449\":1,\"616\":1}}],[\"30\",{\"1\":{\"274\":1,\"571\":1}}],[\"3的结果\",{\"1\":{\"229\":1}}],[\"3\",{\"0\":{\"40\":1,\"41\":1,\"109\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":2,\"326\":1,\"330\":1,\"332\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"364\":1,\"368\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":2,\"383\":1,\"385\":1,\"386\":1,\"387\":1,\"390\":2,\"391\":1,\"399\":1,\"400\":1,\"401\":1,\"402\":1,\"403\":2,\"409\":1,\"424\":1,\"440\":1,\"488\":1,\"693\":1},\"1\":{\"14\":4,\"50\":2,\"57\":2,\"71\":6,\"77\":1,\"78\":1,\"79\":1,\"80\":3,\"173\":2,\"229\":1,\"239\":1,\"240\":1,\"244\":1,\"246\":1,\"274\":1,\"275\":1,\"285\":1,\"347\":2,\"355\":1,\"379\":1,\"382\":1,\"386\":1,\"516\":1,\"527\":1,\"552\":3,\"554\":2,\"601\":1,\"604\":2,\"630\":4}}],[\"6746\",{\"1\":{\"295\":1}}],[\"666\",{\"1\":{\"228\":1}}],[\"60000\",{\"1\":{\"612\":1}}],[\"60\",{\"1\":{\"15\":1,\"280\":1}}],[\"6\",{\"0\":{\"272\":1},\"1\":{\"14\":3,\"78\":1,\"173\":2,\"240\":1,\"275\":1,\"516\":1,\"519\":1}}],[\"57\",{\"1\":{\"657\":2}}],[\"55\",{\"1\":{\"636\":1}}],[\"5555\",{\"1\":{\"228\":1}}],[\"512\",{\"1\":{\"612\":1,\"631\":1}}],[\"537\",{\"1\":{\"455\":2}}],[\"5新增了泛型\",{\"1\":{\"280\":1}}],[\"5个变量连续加\",{\"1\":{\"245\":1}}],[\"500\",{\"1\":{\"166\":1,\"638\":1}}],[\"50\",{\"1\":{\"65\":1,\"142\":1,\"147\":2,\"148\":2,\"161\":1,\"476\":2}}],[\"5倍\",{\"1\":{\"25\":1}}],[\"5\",{\"0\":{\"334\":1,\"412\":1,\"426\":1,\"695\":1},\"1\":{\"14\":3,\"46\":5,\"78\":1,\"79\":1,\"80\":4,\"147\":1,\"172\":2,\"173\":2,\"240\":1,\"241\":1,\"274\":1,\"275\":1,\"280\":2,\"295\":3,\"355\":1,\"455\":1,\"516\":1,\"599\":1,\"604\":3}}],[\"404\",{\"1\":{\"682\":1}}],[\"400\",{\"1\":{\"638\":1}}],[\"4000\",{\"1\":{\"174\":1}}],[\"4606\",{\"1\":{\"455\":1}}],[\"41\",{\"1\":{\"65\":1}}],[\"4\",{\"0\":{\"53\":1,\"54\":1,\"262\":1,\"318\":1,\"331\":1,\"333\":1,\"369\":1,\"384\":1,\"391\":1,\"404\":1,\"405\":1,\"406\":1,\"409\":1,\"425\":1,\"441\":1,\"506\":1,\"694\":1},\"1\":{\"14\":3,\"46\":5,\"71\":1,\"78\":1,\"79\":1,\"80\":4,\"173\":2,\"239\":3,\"240\":1,\"245\":1,\"274\":1,\"275\":1,\"295\":1,\"355\":1,\"516\":1,\"524\":2,\"604\":2}}],[\"的默认的日志级别\",{\"1\":{\"667\":1,\"679\":1}}],[\"的默认处理器为\",{\"1\":{\"667\":1,\"679\":1}}],[\"的强大特性之一\",{\"1\":{\"600\":1}}],[\"的实例为核心的\",{\"1\":{\"553\":1}}],[\"的实现\",{\"1\":{\"46\":1}}],[\"的应用都是以一个\",{\"1\":{\"553\":1}}],[\"的东西\",{\"1\":{\"552\":1}}],[\"的操作\",{\"1\":{\"510\":1}}],[\"的操作是从对应的xxx流内获取一些东西\",{\"1\":{\"454\":1}}],[\"的操作是往对应的xxx流内写入一些东西\",{\"1\":{\"454\":1}}],[\"的用法\",{\"1\":{\"454\":1}}],[\"的算法\",{\"1\":{\"441\":1}}],[\"的选择\",{\"0\":{\"437\":1}}],[\"的权重或者分布\",{\"1\":{\"440\":1}}],[\"的权重\",{\"1\":{\"435\":1}}],[\"的加权平均\",{\"1\":{\"435\":1}}],[\"的加权均值\",{\"1\":{\"333\":1}}],[\"的基本步骤\",{\"1\":{\"433\":1}}],[\"的基础上来引入偏置量\",{\"1\":{\"310\":1}}],[\"的文章中\",{\"1\":{\"429\":1}}],[\"的输出是不一样的\",{\"1\":{\"429\":1}}],[\"的输出\",{\"1\":{\"427\":1}}],[\"的参数\",{\"1\":{\"427\":1}}],[\"的就不是有关\",{\"1\":{\"427\":1}}],[\"的梯度时\",{\"1\":{\"427\":1}}],[\"的分布\",{\"1\":{\"420\":1}}],[\"的新形式\",{\"1\":{\"398\":1}}],[\"的定义\",{\"1\":{\"398\":1}}],[\"的定义出发\",{\"1\":{\"362\":1}}],[\"的估计从\",{\"1\":{\"415\":1}}],[\"的估计\",{\"1\":{\"397\":1,\"401\":1}}],[\"的采样\",{\"1\":{\"395\":1}}],[\"的思想\",{\"1\":{\"386\":1}}],[\"的值\",{\"1\":{\"384\":1}}],[\"的值进行重新计算\",{\"1\":{\"64\":1}}],[\"的动作数量\",{\"1\":{\"372\":1}}],[\"的高效利用\",{\"0\":{\"366\":1}}],[\"的一些改进\",{\"1\":{\"365\":1}}],[\"的一些方法\",{\"0\":{\"63\":1}}],[\"的一个观测值\",{\"1\":{\"389\":1}}],[\"的一个\",{\"1\":{\"363\":1}}],[\"的情况\",{\"1\":{\"361\":1,\"362\":2,\"389\":1}}],[\"的情况下进行估计\",{\"1\":{\"360\":1}}],[\"的情况下使用\",{\"1\":{\"161\":1}}],[\"的原理\",{\"1\":{\"361\":1}}],[\"的策略来进行选择\",{\"1\":{\"351\":1}}],[\"的策略πk+1​\",{\"1\":{\"348\":1}}],[\"的策略所采集的数据来\",{\"1\":{\"314\":1}}],[\"的根据策略π加权平均\",{\"1\":{\"334\":1}}],[\"的转到下一个状态的\",{\"1\":{\"333\":1}}],[\"的过程\",{\"1\":{\"332\":1}}],[\"的计算即可\",{\"1\":{\"327\":1}}],[\"的期望\",{\"1\":{\"325\":1}}],[\"的概率\",{\"1\":{\"305\":2}}],[\"的概念\",{\"1\":{\"155\":1}}],[\"的s是有范围的\",{\"1\":{\"298\":1}}],[\"的函数\",{\"1\":{\"294\":1,\"427\":1}}],[\"的功率谱密度\",{\"1\":{\"294\":1}}],[\"的无人机3d动态运动设计算法\",{\"1\":{\"290\":1}}],[\"的部署方法\",{\"1\":{\"290\":1}}],[\"的变量\",{\"1\":{\"256\":1}}],[\"的匿名类\",{\"1\":{\"255\":1}}],[\"的构造方法中我们可以写入原因\",{\"1\":{\"266\":1}}],[\"的构造方法\",{\"1\":{\"191\":1}}],[\"的区别\",{\"0\":{\"326\":1},\"1\":{\"84\":1}}],[\"的会保留\",{\"1\":{\"71\":1}}],[\"的处理\",{\"1\":{\"71\":1}}],[\"的源码发现\",{\"1\":{\"67\":1}}],[\"的全部性质\",{\"1\":{\"61\":1}}],[\"的容量\",{\"1\":{\"60\":1}}],[\"的关系存在\",{\"1\":{\"463\":1}}],[\"的关系\",{\"1\":{\"55\":1}}],[\"的性质\",{\"1\":{\"50\":1}}],[\"的底层实现是由\",{\"1\":{\"58\":1}}],[\"的底层实现\",{\"1\":{\"50\":1}}],[\"的方法进行解决\",{\"1\":{\"427\":1}}],[\"的方法\",{\"1\":{\"35\":1,\"314\":1,\"353\":1,\"370\":1,\"432\":2}}],[\"的方式去创建一个抽象类或是接口对象\",{\"1\":{\"255\":1}}],[\"的方式使用静态内容\",{\"1\":{\"219\":1}}],[\"的方式\",{\"0\":{\"35\":1}}],[\"的形式\",{\"1\":{\"30\":1,\"258\":2,\"343\":1,\"384\":1}}],[\"的\",{\"1\":{\"30\":1,\"84\":1,\"186\":1,\"219\":1,\"236\":1,\"348\":1,\"351\":1,\"362\":1,\"363\":2,\"366\":1,\"369\":1,\"371\":1,\"372\":1,\"396\":1,\"398\":2,\"408\":2,\"409\":2,\"418\":1,\"440\":1,\"544\":1,\"612\":1}}],[\"的排序方法\",{\"1\":{\"14\":1}}],[\"的使用几乎相同\",{\"1\":{\"25\":1}}],[\"的使用和\",{\"1\":{\"25\":1}}],[\"的使用\",{\"0\":{\"7\":1}}],[\"因此默认值是\",{\"1\":{\"612\":1}}],[\"因此需要用一个命名空间来区分\",{\"1\":{\"554\":1}}],[\"因此需要用近似算法来进行替代\",{\"1\":{\"421\":1}}],[\"因此直接导入依赖后就可以使用了\",{\"1\":{\"539\":1}}],[\"因此要先起一个别名\",{\"1\":{\"496\":1}}],[\"因此不同的数据库都存在自己的\",{\"1\":{\"472\":1}}],[\"因此不需要进行\",{\"1\":{\"405\":1}}],[\"因此存在传递依赖的情况\",{\"1\":{\"466\":1}}],[\"因此此表中存在一个主键\",{\"1\":{\"465\":1}}],[\"因此学号和学生之间也有一种联系\",{\"1\":{\"461\":1}}],[\"因此该指标可以描述为\",{\"1\":{\"435\":1}}],[\"因此左侧那个类似\",{\"1\":{\"427\":1}}],[\"因此对于常见的一些查询参数\",{\"1\":{\"559\":1}}],[\"因此对于用户kn​的在时刻t的传输速率rkn​​\",{\"1\":{\"294\":1}}],[\"因此对应的损失函数的梯度可以修改为\",{\"1\":{\"427\":1}}],[\"因此对应算法为\",{\"1\":{\"423\":1}}],[\"因此可以考虑\",{\"1\":{\"421\":1}}],[\"因此可以直接调用\",{\"1\":{\"274\":1,\"275\":1}}],[\"因此可以直接使用lambda表达式\",{\"1\":{\"139\":1}}],[\"因此可以直接放入\",{\"1\":{\"126\":1}}],[\"因此可以直接读取到中文字符\",{\"1\":{\"96\":1}}],[\"因此采用这种\",{\"1\":{\"419\":1}}],[\"因此这种情况下的\",{\"1\":{\"419\":1}}],[\"因此这样就能够保证我们插入顺序和最后的迭代顺序一致了\",{\"1\":{\"49\":1}}],[\"因此是一个确定的贪心策略\",{\"1\":{\"373\":1}}],[\"因此是2n\",{\"1\":{\"299\":1}}],[\"因此随着用户位置的变化\",{\"1\":{\"299\":1}}],[\"因此mos不仅与欧氏距离有关\",{\"1\":{\"298\":1}}],[\"因此moskn​​delay\",{\"1\":{\"295\":1}}],[\"因此gak\",{\"1\":{\"298\":1}}],[\"因此既可以存放integer也能存放string\",{\"1\":{\"280\":1}}],[\"因此只能使用类来进行定义\",{\"1\":{\"243\":1}}],[\"因此会读取命令行中的指令参数进行存储到\",{\"1\":{\"242\":1}}],[\"因此它能够有效地防止sql注入攻击\",{\"1\":{\"533\":1}}],[\"因此它可以被拆分为\",{\"1\":{\"464\":1}}],[\"因此它已经无法正常工作了\",{\"1\":{\"193\":1}}],[\"因此它只适合读纯文本的文件\",{\"1\":{\"96\":1}}],[\"因此守护线程不适合进行io操作\",{\"1\":{\"172\":1}}],[\"因此各个线程直接存放的内容互不干扰\",{\"1\":{\"162\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"156\":1}}],[\"因此并不能保证自增操作的原子性\",{\"1\":{\"155\":1}}],[\"因此有对象锁和类锁区别\",{\"1\":{\"155\":1}}],[\"因此为null\",{\"1\":{\"133\":1}}],[\"因此我们在默认情况下才能正常使用日志打印\",{\"1\":{\"655\":1}}],[\"因此我们打印日志就不会有任何效果\",{\"1\":{\"646\":1}}],[\"因此我们可能需要限制用户的输入来防止用户输入一些sql语句关键字\",{\"1\":{\"532\":1}}],[\"因此我们可以创建一个工具类来集中创建sqlsession\",{\"1\":{\"558\":1}}],[\"因此我们可以使用setkeepalive\",{\"1\":{\"449\":1}}],[\"因此我们可以通过\",{\"1\":{\"384\":1}}],[\"因此我们可以直接使用数组的class对象表示\",{\"1\":{\"192\":1}}],[\"因此我们的服务端能够读取http请求\",{\"1\":{\"455\":1}}],[\"因此我们需要设置一下logging\",{\"1\":{\"679\":1}}],[\"因此我们需要保证对于所有的\",{\"1\":{\"440\":1}}],[\"因此我们需要一种方法来区分类的不同版本\",{\"1\":{\"132\":1}}],[\"因此我们用\",{\"1\":{\"422\":1}}],[\"因此我们将优化问题简化为区域分割问题\",{\"1\":{\"298\":1}}],[\"因此我们编写一个自定义的来让它支持\",{\"1\":{\"199\":1}}],[\"因此我们自己编写的同名包同名类不会被加载\",{\"1\":{\"198\":1}}],[\"因此我们不需要手动指定\",{\"1\":{\"120\":1}}],[\"因此依然是装饰我们传入的输出流\",{\"1\":{\"127\":1}}],[\"因此性能还不够高\",{\"1\":{\"103\":1}}],[\"因此与read结合\",{\"1\":{\"91\":1}}],[\"因此所有的集合类都有这个方法\",{\"1\":{\"36\":1}}],[\"因此\",{\"1\":{\"14\":1,\"16\":1,\"47\":1,\"84\":1,\"156\":1,\"244\":1,\"255\":2,\"294\":2,\"295\":1,\"311\":1,\"327\":1,\"333\":1,\"343\":1,\"356\":1,\"379\":1,\"386\":1,\"389\":2,\"395\":1,\"398\":1,\"409\":1,\"507\":1,\"553\":1,\"611\":1,\"616\":1,\"629\":1,\"640\":1,\"676\":1}}],[\"因此返回值也是\",{\"1\":{\"14\":1}}],[\"因为mybatis的日志级别都比较低\",{\"1\":{\"679\":1}}],[\"因为这这里off的值为int的最大值\",{\"1\":{\"640\":1}}],[\"因为这里需要多个参数\",{\"1\":{\"562\":1}}],[\"因为这里是void\",{\"1\":{\"192\":1}}],[\"因为并没有保存在缓存中\",{\"1\":{\"612\":1}}],[\"因为并没有使用到外部类的任何静态变量\",{\"1\":{\"254\":1}}],[\"因为id已经发生变化了\",{\"1\":{\"616\":1}}],[\"因为id为主键\",{\"1\":{\"563\":1}}],[\"因为integer类中默认提供了求两个int值之和的静态方法\",{\"1\":{\"258\":1}}],[\"因为只有这样mybatis才能正确识别我们配置的内容\",{\"1\":{\"552\":1}}],[\"因为equal方法可能不符合预期结果\",{\"1\":{\"540\":1}}],[\"因为浏览器不止发一个请求\",{\"1\":{\"455\":1}}],[\"因为浏览器访问时会不止发一个请求\",{\"1\":{\"455\":1}}],[\"因为我们是从外部进行修改\",{\"1\":{\"616\":1}}],[\"因为我们需要计算的是\",{\"1\":{\"440\":1}}],[\"因为我们前面学习了lambda表达式\",{\"1\":{\"14\":1}}],[\"因为不需要\",{\"1\":{\"410\":1}}],[\"因为不这样就无法编译了\",{\"1\":{\"266\":1}}],[\"因为最终策略更新的核心仍然是\",{\"1\":{\"364\":1}}],[\"因为无论是\",{\"1\":{\"360\":1}}],[\"因为无论具体类型是什么\",{\"1\":{\"281\":1}}],[\"因为其满足该理论\",{\"1\":{\"343\":1}}],[\"因为其他类就算继承这个接口\",{\"1\":{\"219\":1}}],[\"因为q\",{\"1\":{\"298\":1}}],[\"因为目标函数对于无人机的3d坐标是非凸的\",{\"1\":{\"296\":1}}],[\"因为数组本身是引用类型\",{\"1\":{\"281\":1}}],[\"因为此时并不明确具体是什么类型\",{\"1\":{\"281\":1}}],[\"因为现在有了类型变量\",{\"1\":{\"281\":1}}],[\"因为现在只需要使用接口来进行配置\",{\"1\":{\"622\":1}}],[\"因为现在只需要一个string类型的返回值\",{\"1\":{\"258\":1}}],[\"因为现在只可能出现number的子类\",{\"1\":{\"16\":1}}],[\"因为object是所有类型的父类\",{\"1\":{\"280\":1}}],[\"因为匿名对象没有类名\",{\"1\":{\"255\":1}}],[\"因为匿名内部类就是接口的实现类\",{\"1\":{\"14\":1}}],[\"因为在最后需要释放资源\",{\"1\":{\"516\":1}}],[\"因为在最后自动帮我们调用了close\",{\"1\":{\"90\":1}}],[\"因为在\",{\"1\":{\"377\":1}}],[\"因为在不考虑用户自由穿梭集群的情况\",{\"1\":{\"299\":1}}],[\"因为在编译的时候\",{\"1\":{\"254\":1}}],[\"因为成员内部类本身就是某个对象所有的\",{\"1\":{\"251\":1}}],[\"因为父类都是\",{\"1\":{\"238\":1}}],[\"因为同样是类\",{\"1\":{\"235\":1}}],[\"因为超出了缓存的范围\",{\"1\":{\"227\":1}}],[\"因为小的数使用频率非常高\",{\"1\":{\"227\":1}}],[\"因为包装类是一个类\",{\"1\":{\"227\":1}}],[\"因为底层是c++实现\",{\"1\":{\"220\":1}}],[\"因为底层实质上是借用的一个\",{\"1\":{\"48\":1}}],[\"因为抽象方法一定要由子类实现\",{\"1\":{\"218\":1}}],[\"因为普通的classloader无法加载二进制文件\",{\"1\":{\"199\":1}}],[\"因为是具体使用对象时才会明确具体类型\",{\"1\":{\"281\":1}}],[\"因为是属于类的\",{\"1\":{\"192\":1}}],[\"因为是在顶层接口中定义的\",{\"1\":{\"36\":1}}],[\"因为newinstance\",{\"1\":{\"191\":1}}],[\"因为都直接在一个缺省的包中\",{\"1\":{\"120\":1}}],[\"因为this关键字代表的是当前的对象本身\",{\"1\":{\"117\":1}}],[\"因为静态方法属于类的\",{\"1\":{\"117\":1}}],[\"因为关闭流是任何情况都必须要执行的\",{\"1\":{\"90\":1}}],[\"因为它们都被认为是一个文本节点\",{\"1\":{\"547\":1}}],[\"因为它们直接操作字符\",{\"1\":{\"88\":1}}],[\"因为它本质上就相当于是对应类型的子类\",{\"1\":{\"255\":1}}],[\"因为它作用范围就只是方法内\",{\"1\":{\"253\":1}}],[\"因为它是我们直接加载的\",{\"1\":{\"199\":1}}],[\"因为它会将我们插入的结点按照规则进行排序\",{\"1\":{\"62\":1}}],[\"因为重写了\",{\"1\":{\"84\":1}}],[\"因为传入的哈希值可能会很大\",{\"1\":{\"59\":1}}],[\"因为操作特殊\",{\"1\":{\"55\":1,\"56\":1}}],[\"因为list是有序集合\",{\"1\":{\"37\":1}}],[\"因为\",{\"1\":{\"35\":1,\"57\":1,\"67\":2,\"84\":1,\"362\":1,\"389\":1,\"409\":1}}],[\"因为所有的对象都是属于一个普通的类型\",{\"1\":{\"16\":1}}],[\"因为还是有可能是\",{\"1\":{\"15\":1}}],[\"因而也被称为实例\",{\"1\":{\"4\":1}}],[\"title\",{\"1\":{\"581\":3}}],[\"time存储时间\",{\"1\":{\"474\":1}}],[\"timed\",{\"1\":{\"449\":1}}],[\"timeout\",{\"1\":{\"215\":2}}],[\"timerthread继承自thread\",{\"1\":{\"167\":1}}],[\"timerthread\",{\"1\":{\"167\":2}}],[\"timertask\",{\"1\":{\"165\":3,\"166\":1,\"167\":2}}],[\"timer\",{\"1\":{\"166\":4,\"167\":15}}],[\"timerlooptask\",{\"1\":{\"165\":3}}],[\"time\",{\"1\":{\"165\":5,\"295\":1,\"366\":1}}],[\"tcp发送缓冲区\",{\"1\":{\"449\":1}}],[\"tcp接收缓冲区\",{\"1\":{\"449\":1}}],[\"tcp在传输过程中\",{\"1\":{\"449\":1}}],[\"t=0∑∞​γtrt+1​\",{\"1\":{\"436\":1}}],[\"t=0\",{\"1\":{\"397\":1,\"401\":1}}],[\"td\",{\"0\":{\"396\":1,\"399\":1,\"400\":1,\"404\":1,\"412\":1,\"423\":1},\"1\":{\"398\":1,\"423\":1,\"427\":1,\"441\":1}}],[\"t∈rn\",{\"1\":{\"331\":2}}],[\"t∈r2×1\",{\"1\":{\"293\":2}}],[\"t会根据使用时提供的类型自动变成对应类型\",{\"1\":{\"281\":1}}],[\"tmp\",{\"1\":{\"91\":3,\"94\":3}}],[\"txt\",{\"1\":{\"91\":6,\"92\":2,\"93\":1,\"94\":2,\"96\":2,\"97\":1,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"128\":1,\"129\":2,\"131\":2,\"133\":2,\"454\":2}}],[\"t2\",{\"1\":{\"84\":4,\"147\":2,\"148\":2,\"154\":2,\"155\":4,\"156\":2,\"161\":2,\"162\":2}}],[\"t1\",{\"1\":{\"84\":5,\"147\":2,\"148\":3,\"154\":2,\"155\":4,\"156\":2,\"161\":2,\"162\":2}}],[\"teach\",{\"1\":{\"497\":4}}],[\"teacher\",{\"1\":{\"219\":7}}],[\"terms\",{\"1\":{\"404\":1}}],[\"terminal\",{\"1\":{\"71\":1,\"304\":1}}],[\"temporal\",{\"0\":{\"394\":1}}],[\"technology\",{\"1\":{\"288\":1},\"2\":{\"301\":1}}],[\"ten\",{\"1\":{\"229\":1}}],[\"text+\",{\"1\":{\"199\":1,\"448\":2}}],[\"text\",{\"1\":{\"199\":3,\"448\":1,\"455\":1,\"569\":1,\"570\":1,\"577\":1,\"578\":2,\"581\":1,\"583\":1,\"599\":2,\"604\":1,\"605\":1,\"610\":1,\"611\":2,\"612\":1,\"616\":1,\"625\":1,\"648\":1,\"658\":1,\"676\":1}}],[\"testsqlbuilder\",{\"1\":{\"630\":2}}],[\"test=\",{\"1\":{\"601\":1,\"602\":2,\"630\":2}}],[\"test2\",{\"1\":{\"583\":2}}],[\"testmapper明明是一个我们自己定义接口啊\",{\"1\":{\"570\":1}}],[\"testmapper\",{\"1\":{\"554\":2,\"569\":1,\"570\":9,\"571\":2,\"589\":1,\"593\":6,\"599\":2,\"605\":2,\"611\":6,\"612\":4,\"616\":2,\"622\":1,\"623\":1,\"624\":1,\"631\":1}}],[\"test>\",{\"1\":{\"546\":1}}],[\"test<>\",{\"1\":{\"281\":1}}],[\"test<string\",{\"1\":{\"281\":1}}],[\"test<string>\",{\"1\":{\"186\":1,\"191\":1,\"192\":1,\"281\":1}}],[\"test<a\",{\"1\":{\"281\":1}}],[\"test<integer>\",{\"1\":{\"281\":1}}],[\"test<\",{\"1\":{\"281\":1}}],[\"testexception\",{\"1\":{\"265\":4}}],[\"test这个包中\",{\"1\":{\"120\":1}}],[\"test\",{\"1\":{\"14\":2,\"16\":7,\"23\":1,\"36\":1,\"84\":21,\"91\":6,\"94\":1,\"96\":2,\"98\":2,\"105\":1,\"108\":2,\"109\":1,\"112\":3,\"117\":1,\"120\":7,\"121\":4,\"126\":2,\"127\":1,\"129\":1,\"186\":2,\"191\":5,\"192\":10,\"199\":10,\"206\":3,\"207\":9,\"208\":13,\"219\":2,\"221\":7,\"238\":1,\"241\":3,\"242\":1,\"251\":25,\"252\":6,\"253\":4,\"254\":11,\"255\":7,\"256\":1,\"257\":2,\"266\":3,\"267\":4,\"281\":7,\"282\":5,\"532\":3,\"533\":1,\"547\":2,\"554\":1,\"559\":1,\"560\":2,\"563\":1,\"564\":3,\"569\":4,\"570\":2,\"571\":1,\"577\":3,\"578\":1,\"579\":5,\"581\":3,\"582\":4,\"583\":5,\"589\":1,\"590\":1,\"614\":1,\"615\":1,\"622\":2,\"623\":1,\"625\":1,\"626\":1,\"627\":1,\"632\":3,\"636\":2,\"647\":1,\"648\":1,\"649\":1,\"655\":1,\"656\":1,\"657\":2,\"658\":3,\"664\":1,\"665\":1,\"667\":2,\"674\":1,\"675\":1}}],[\"typealiases>\",{\"1\":{\"560\":2}}],[\"type=\",{\"1\":{\"545\":1,\"552\":2,\"560\":1,\"563\":1,\"569\":1,\"577\":1,\"578\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":2,\"626\":1}}],[\"type1\",{\"1\":{\"186\":9}}],[\"types\",{\"1\":{\"186\":6}}],[\"typevariableimpl\",{\"1\":{\"186\":3}}],[\"type\",{\"1\":{\"65\":5,\"183\":4,\"186\":20,\"207\":4,\"208\":1,\"630\":1}}],[\"taking\",{\"1\":{\"333\":1}}],[\"take\",{\"1\":{\"139\":1,\"174\":4,\"371\":1}}],[\"taobao\",{\"1\":{\"246\":2}}],[\"taohai\",{\"1\":{\"65\":3}}],[\"taskfired\",{\"1\":{\"167\":1}}],[\"taskqueue\",{\"1\":{\"167\":2}}],[\"tasks转换成continuing\",{\"1\":{\"304\":1}}],[\"tasks\",{\"1\":{\"167\":2,\"304\":3}}],[\"task\",{\"1\":{\"165\":6,\"167\":2}}],[\"target限定为只能作用于方法上\",{\"1\":{\"206\":1}}],[\"target\",{\"1\":{\"139\":2,\"205\":1,\"206\":3,\"207\":4,\"208\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"410\":2,\"427\":4}}],[\"tabular\",{\"1\":{\"415\":1}}],[\"tab\",{\"1\":{\"59\":8}}],[\"table来删除一个表\",{\"1\":{\"480\":1}}],[\"table来进行修改\",{\"1\":{\"479\":1}}],[\"table来找出对应q\",{\"1\":{\"298\":1}}],[\"table语句来创建一张表\",{\"1\":{\"478\":1}}],[\"table过大\",{\"1\":{\"299\":1}}],[\"table管理\",{\"1\":{\"298\":1}}],[\"table\",{\"1\":{\"58\":1,\"59\":1,\"60\":2,\"298\":2,\"476\":1,\"478\":1,\"479\":1,\"480\":1}}],[\"t>\",{\"1\":{\"35\":1,\"36\":1}}],[\"then\",{\"1\":{\"343\":2,\"517\":1}}],[\"theorem来求解贝尔曼最优公式\",{\"1\":{\"343\":1}}],[\"theorem\",{\"1\":{\"338\":2,\"343\":1,\"347\":1,\"383\":1}}],[\"they\",{\"1\":{\"167\":1}}],[\"them\",{\"1\":{\"167\":1}}],[\"the\",{\"0\":{\"309\":1,\"328\":1,\"329\":1},\"1\":{\"139\":5,\"167\":7,\"183\":4,\"289\":1,\"294\":1,\"295\":1,\"304\":6,\"305\":4,\"322\":1,\"325\":1,\"326\":2,\"332\":1,\"333\":4,\"334\":2,\"337\":1,\"338\":2,\"343\":2,\"366\":1,\"367\":2,\"371\":1,\"383\":2,\"420\":1,\"427\":2,\"516\":4,\"517\":10,\"569\":1}}],[\"that\",{\"1\":{\"139\":3,\"326\":1,\"343\":1,\"366\":1,\"517\":2}}],[\"through\",{\"1\":{\"517\":1}}],[\"throughput\",{\"1\":{\"289\":1}}],[\"throwable\",{\"1\":{\"215\":1,\"569\":2}}],[\"throws\",{\"1\":{\"107\":1,\"128\":1,\"142\":1,\"143\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"172\":2,\"182\":1,\"191\":2,\"192\":3,\"193\":3,\"199\":1,\"208\":1,\"215\":5,\"220\":2,\"264\":1,\"266\":3,\"267\":4,\"517\":3,\"518\":2,\"526\":1,\"533\":1,\"534\":4,\"552\":1,\"554\":1}}],[\"throw\",{\"1\":{\"25\":1,\"32\":1,\"110\":1,\"174\":1,\"266\":6,\"267\":3,\"448\":1,\"454\":1,\"517\":4,\"524\":1,\"527\":1,\"569\":1}}],[\"threadlocal<>\",{\"1\":{\"162\":1}}],[\"threadlocal<string>\",{\"1\":{\"162\":1,\"163\":1}}],[\"threadlocal定义在主线程中\",{\"1\":{\"162\":1}}],[\"thread\",{\"1\":{\"139\":7,\"140\":6,\"142\":5,\"144\":5,\"145\":3,\"147\":5,\"148\":4,\"154\":5,\"155\":18,\"156\":6,\"161\":5,\"162\":6,\"163\":3,\"165\":4,\"166\":1,\"167\":8,\"172\":10,\"173\":1,\"174\":9,\"517\":1,\"569\":1,\"616\":1,\"676\":1}}],[\"thread构造方法中需要传入一个runnable接口的实现\",{\"1\":{\"139\":1}}],[\"threadinfo\",{\"1\":{\"138\":2}}],[\"threadmxbean\",{\"1\":{\"138\":1}}],[\"threshold\",{\"1\":{\"59\":2,\"60\":3}}],[\"this\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"9\":12,\"15\":3,\"23\":1,\"24\":3,\"25\":5,\"35\":1,\"36\":1,\"47\":1,\"58\":1,\"59\":1,\"65\":3,\"84\":4,\"107\":1,\"131\":1,\"132\":1,\"133\":1,\"139\":1,\"165\":4,\"167\":2,\"191\":2,\"192\":2,\"214\":1,\"215\":1,\"216\":3,\"218\":4,\"221\":2,\"251\":6,\"252\":1,\"253\":1,\"280\":3,\"281\":3,\"439\":1,\"516\":1,\"517\":2,\"527\":3,\"538\":6,\"569\":8,\"628\":3}}],[\"truncated\",{\"0\":{\"354\":1,\"356\":1,\"357\":1},\"1\":{\"356\":1}}],[\"true表示开启追加模式\",{\"1\":{\"93\":1}}],[\"true\",{\"1\":{\"23\":2,\"24\":1,\"25\":2,\"36\":1,\"59\":1,\"71\":1,\"84\":2,\"93\":1,\"144\":1,\"165\":1,\"172\":5,\"173\":1,\"174\":2,\"191\":1,\"192\":1,\"193\":4,\"447\":1,\"449\":2,\"455\":3,\"534\":1,\"552\":1,\"554\":1,\"558\":1,\"570\":1,\"590\":1,\"593\":1,\"611\":2,\"612\":4,\"615\":1,\"616\":1,\"625\":2,\"626\":1,\"628\":1,\"629\":1,\"631\":1,\"648\":1}}],[\"triggers\",{\"1\":{\"509\":1}}],[\"trigger\",{\"1\":{\"509\":2}}],[\"trial\",{\"1\":{\"304\":2}}],[\"trip\",{\"1\":{\"295\":1}}],[\"trajectory以及对应的\",{\"1\":{\"439\":1}}],[\"trajectory是在策略给定下\",{\"1\":{\"304\":1}}],[\"trajectory\",{\"1\":{\"304\":4,\"326\":1,\"327\":1,\"439\":1}}],[\"transaction\",{\"1\":{\"510\":1}}],[\"transactions\",{\"1\":{\"288\":1},\"2\":{\"301\":1}}],[\"transition\",{\"1\":{\"304\":2,\"305\":1}}],[\"transient\",{\"1\":{\"25\":4,\"58\":1,\"67\":1,\"133\":1}}],[\"transmission\",{\"1\":{\"293\":1}}],[\"trying\",{\"1\":{\"517\":1}}],[\"try\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"167\":2,\"172\":2,\"174\":2,\"199\":2,\"267\":9,\"447\":3,\"448\":2,\"449\":1,\"454\":2,\"455\":2,\"516\":2,\"517\":1,\"524\":1,\"526\":1,\"527\":1,\"532\":1,\"533\":1,\"534\":4,\"547\":1,\"552\":1,\"554\":1,\"558\":2,\"569\":2,\"570\":1,\"593\":2,\"611\":1,\"612\":1}}],[\"treemap\",{\"0\":{\"62\":1},\"1\":{\"67\":1}}],[\"treeifybin\",{\"1\":{\"59\":1}}],[\"treeify\",{\"1\":{\"59\":1}}],[\"treenode<k\",{\"1\":{\"59\":1}}],[\"treenode\",{\"1\":{\"59\":1}}],[\"treeset<>\",{\"1\":{\"50\":2}}],[\"treeset<integer>\",{\"1\":{\"50\":2}}],[\"treeset\",{\"0\":{\"50\":1},\"1\":{\"62\":1,\"67\":1}}],[\"topic\",{\"1\":{\"678\":1}}],[\"total\",{\"1\":{\"580\":2}}],[\"tool\",{\"1\":{\"337\":1}}],[\"tochararray\",{\"1\":{\"244\":1}}],[\"tohexstring\",{\"1\":{\"215\":1,\"228\":1}}],[\"to\",{\"0\":{\"332\":1},\"1\":{\"139\":2,\"167\":1,\"289\":1,\"304\":1,\"305\":1,\"367\":1,\"371\":1,\"377\":1,\"383\":1,\"502\":1,\"510\":1,\"517\":3,\"580\":1}}],[\"tolist\",{\"1\":{\"71\":3,\"285\":2}}],[\"toindex\",{\"1\":{\"24\":1}}],[\"toarray\",{\"1\":{\"23\":2,\"24\":1,\"47\":2}}],[\"tostring来为当前类生成预设的tostring方法\",{\"1\":{\"540\":1}}],[\"tostring\",{\"1\":{\"14\":4,\"98\":1,\"173\":1,\"215\":2,\"245\":2,\"251\":4,\"267\":1,\"275\":3,\"540\":1,\"569\":1,\"630\":1,\"646\":1,\"655\":1,\"676\":1}}],[\"t\",{\"1\":{\"14\":10,\"15\":3,\"16\":8,\"23\":2,\"35\":3,\"36\":3,\"47\":2,\"140\":3,\"142\":2,\"144\":3,\"145\":3,\"163\":2,\"172\":7,\"281\":2,\"282\":2,\"293\":11,\"294\":20,\"295\":12,\"296\":8,\"298\":6,\"527\":1,\"569\":3}}],[\"当父级和子级都配置时\",{\"1\":{\"657\":1}}],[\"当多个cpu在操作自己的缓存时\",{\"1\":{\"616\":1}}],[\"当一级缓存中都还没有数据时\",{\"1\":{\"613\":1}}],[\"当一个线程进入到同步代码块时\",{\"1\":{\"155\":1}}],[\"当二级缓存中没有时\",{\"1\":{\"613\":1}}],[\"当到达指定时间时会自动清理所有缓存\",{\"1\":{\"612\":1}}],[\"当缓存达到上限时\",{\"1\":{\"612\":1}}],[\"当主键列不是表中的第一列的时候\",{\"1\":{\"590\":1}}],[\"当触发器表上发生select\",{\"1\":{\"509\":1}}],[\"当数据库和表为\",{\"1\":{\"502\":1}}],[\"当对方没有发送任何数据过来\",{\"1\":{\"449\":1}}],[\"当对象被判定为已经不再使用的\",{\"1\":{\"215\":1}}],[\"当对象不同时\",{\"1\":{\"155\":1}}],[\"当客户端连接后\",{\"1\":{\"449\":1}}],[\"当超过设定时间都依然没有收到客户端或是服务端的数据时\",{\"1\":{\"449\":1}}],[\"当没有客户端连接时\",{\"1\":{\"447\":1,\"448\":1}}],[\"当策略是以函数的形式存在时\",{\"1\":{\"433\":1}}],[\"当策略是以表格的形式保存时\",{\"1\":{\"433\":1}}],[\"当a为静止时\",{\"1\":{\"298\":1}}],[\"当执行动作at​时\",{\"1\":{\"298\":1}}],[\"当子类实现此接口时\",{\"1\":{\"282\":1}}],[\"当代码可能出现多种类型的异常时\",{\"1\":{\"267\":1}}],[\"当程序没有按照我们理想的样子运行而出现异常时\",{\"1\":{\"267\":1}}],[\"当程序在运行时\",{\"1\":{\"16\":1}}],[\"当别人调用我们的方法时\",{\"1\":{\"266\":1}}],[\"当你使用内部类静态方法\",{\"1\":{\"254\":1}}],[\"当前数组长度为\",{\"1\":{\"236\":1}}],[\"当前类\",{\"1\":{\"121\":1}}],[\"当属性为数组\",{\"1\":{\"207\":1}}],[\"当属性为数组时呢\",{\"1\":{\"207\":1}}],[\"当属性存在默认值时\",{\"1\":{\"207\":1}}],[\"当访问private字段时\",{\"1\":{\"193\":1}}],[\"当访问权限不是public的时候\",{\"1\":{\"191\":1}}],[\"当方法是静态方法时\",{\"1\":{\"192\":1}}],[\"当方法的参数为可变参数时\",{\"1\":{\"192\":1}}],[\"当出现非public方法时\",{\"1\":{\"192\":1}}],[\"当出现多个进程需要同时运行时\",{\"1\":{\"138\":1}}],[\"当默认无参构造的权限不是public时\",{\"1\":{\"191\":1}}],[\"当类默认的构造方法被带参构造覆盖时\",{\"1\":{\"191\":1}}],[\"当integer不是number的子类时\",{\"1\":{\"186\":1}}],[\"当货架空的时候\",{\"1\":{\"174\":1}}],[\"当其他所有的非守护线程结束之后\",{\"1\":{\"172\":1}}],[\"当其他线程调用对象的notify\",{\"1\":{\"161\":1}}],[\"当被唤醒后都没有任务时\",{\"1\":{\"167\":1}}],[\"当有新的任务时\",{\"1\":{\"167\":1}}],[\"当队列为空同时没有被关闭时\",{\"1\":{\"167\":1}}],[\"当两个线程同时读取value的时候\",{\"1\":{\"154\":1}}],[\"当线程出现异常或错误\",{\"1\":{\"143\":1}}],[\"当线程进入休眠\",{\"1\":{\"143\":1}}],[\"当等待状态结束后会回到就绪状态\",{\"1\":{\"143\":1}}],[\"当cpu给予的运行时间结束时\",{\"1\":{\"143\":1}}],[\"当需要等待外部io操作\",{\"1\":{\"142\":1}}],[\"当读取的内容数量超过\",{\"1\":{\"108\":1}}],[\"当调用\",{\"1\":{\"108\":2}}],[\"当向外部设备写入数据时\",{\"1\":{\"103\":1}}],[\"当整个链式调用完成后\",{\"1\":{\"71\":1}}],[\"当遇到大量的复杂操作时\",{\"1\":{\"71\":1}}],[\"当key存在时存在则计算并赋予新的值\",{\"1\":{\"64\":1}}],[\"当链表长度到达一定限制时\",{\"1\":{\"58\":1}}],[\"当我们开启二级缓存后\",{\"1\":{\"614\":1}}],[\"当我们查询条件不同时\",{\"1\":{\"601\":1}}],[\"当我们要执行很多条语句时\",{\"1\":{\"526\":1,\"599\":1}}],[\"当我们要进行的操作非常多时\",{\"1\":{\"510\":1}}],[\"当我们字符串编辑完成之后\",{\"1\":{\"245\":1}}],[\"当我们同时去操作一个共享变量时\",{\"1\":{\"154\":1}}],[\"当我们希望一个线程等待另一个线程执行完成后再继续进行\",{\"1\":{\"148\":1}}],[\"当我们使用同一个包中的类时\",{\"1\":{\"120\":1}}],[\"当我们创建对象时\",{\"1\":{\"58\":1}}],[\"当我们在使用变量时\",{\"1\":{\"15\":1}}],[\"当不存在对应的键值对时\",{\"1\":{\"57\":1}}],[\"当\",{\"1\":{\"57\":1,\"64\":1,\"612\":1}}],[\"当做流水线处理\",{\"1\":{\"71\":1}}],[\"当做队列使用\",{\"1\":{\"43\":1}}],[\"当做一个队列来使用\",{\"1\":{\"43\":1}}],[\"当某个方法\",{\"1\":{\"14\":1}}],[\"当然我们也可以打印到一个日志文件中\",{\"1\":{\"646\":1}}],[\"当然我们也可以将此方法设计为两个参数的形式\",{\"1\":{\"591\":1}}],[\"当然如果仍然需要提交的话也可以使用commit\",{\"1\":{\"593\":1}}],[\"当然这个关系哪怕只写一个mybatis也可以自动推断其他的\",{\"1\":{\"581\":1}}],[\"当然也可以直接不填这个属性\",{\"1\":{\"559\":1}}],[\"当然前提是方法定义\",{\"1\":{\"258\":1}}],[\"当然不加效果也是一样的\",{\"1\":{\"203\":1}}],[\"当然在磁盘io下\",{\"1\":{\"91\":1}}],[\"当然计算哈希还是使用键\",{\"1\":{\"58\":1}}],[\"当然\",{\"1\":{\"7\":1,\"9\":3,\"14\":1,\"16\":1,\"25\":1,\"45\":1,\"50\":1,\"61\":1,\"112\":1,\"120\":2,\"218\":1,\"246\":1,\"255\":1,\"267\":1,\"281\":1,\"447\":1,\"545\":1,\"547\":1,\"560\":1,\"561\":1,\"571\":1,\"583\":1,\"627\":1,\"630\":1,\"639\":1,\"646\":1,\"657\":1,\"664\":1,\"666\":1}}],[\"24d46ca6\",{\"1\":{\"655\":1}}],[\"28\",{\"1\":{\"647\":1,\"657\":2}}],[\"255\",{\"1\":{\"475\":1}}],[\"25565\",{\"1\":{\"449\":2}}],[\"2nf\",{\"0\":{\"465\":1}}],[\"2nf对主属性和其他属性的依赖关系产生约束\",{\"1\":{\"463\":1}}],[\"2种方法\",{\"1\":{\"334\":1}}],[\"2l−1\",{\"1\":{\"295\":1}}],[\"2mssfs​+1\",{\"1\":{\"295\":1}}],[\"2mss\",{\"1\":{\"295\":1}}],[\"2~3\",{\"1\":{\"295\":1}}],[\"2​\",{\"1\":{\"293\":1}}],[\"2+\",{\"1\":{\"293\":1}}],[\"223\",{\"1\":{\"474\":2}}],[\"22\",{\"1\":{\"285\":1}}],[\"2147483647\",{\"1\":{\"474\":1}}],[\"2147483648\",{\"1\":{\"474\":1}}],[\"21\",{\"1\":{\"285\":1}}],[\"27\",{\"1\":{\"219\":1}}],[\"2打印\",{\"1\":{\"147\":1,\"148\":1}}],[\"200\",{\"1\":{\"455\":2}}],[\"2000\",{\"1\":{\"162\":1}}],[\"2019\",{\"1\":{\"288\":1}}],[\"20\",{\"1\":{\"142\":1,\"193\":1,\"256\":1,\"258\":2,\"274\":1,\"285\":1,\"569\":1,\"628\":1}}],[\"2021\",{\"1\":{\"636\":1}}],[\"20230306163528771\",{\"1\":{\"544\":1,\"546\":1}}],[\"20250319235934\",{\"1\":{\"447\":1}}],[\"20250312005934\",{\"1\":{\"198\":1}}],[\"20250312002044\",{\"1\":{\"192\":1}}],[\"20250310170551\",{\"1\":{\"186\":1}}],[\"20250310170039\",{\"1\":{\"186\":1}}],[\"20250310165216\",{\"1\":{\"186\":1}}],[\"20250310160214\",{\"1\":{\"180\":1}}],[\"20250309155822\",{\"1\":{\"162\":1}}],[\"20250226231025\",{\"1\":{\"156\":1}}],[\"20250226223324\",{\"1\":{\"154\":1}}],[\"20250226175843\",{\"1\":{\"140\":1,\"143\":1}}],[\"20250226173747\",{\"1\":{\"138\":1}}],[\"20250225192918\",{\"1\":{\"127\":1}}],[\"20250225181159\",{\"1\":{\"103\":1}}],[\"2024\",{\"1\":{\"580\":2,\"647\":1,\"657\":2}}],[\"20240826181712\",{\"1\":{\"442\":1}}],[\"20240826181638\",{\"1\":{\"441\":1}}],[\"20240826181538\",{\"1\":{\"441\":1}}],[\"20240826181340\",{\"1\":{\"441\":1}}],[\"20240826180244\",{\"1\":{\"440\":1}}],[\"20240826173749\",{\"1\":{\"436\":1}}],[\"20240820231205\",{\"1\":{\"429\":1}}],[\"20240820231024\",{\"1\":{\"429\":1}}],[\"20240820230944\",{\"1\":{\"428\":1}}],[\"20240820230920\",{\"1\":{\"428\":1}}],[\"20240820230827\",{\"1\":{\"428\":1}}],[\"20240820184405\",{\"1\":{\"425\":1}}],[\"20240820184127\",{\"1\":{\"424\":1}}],[\"20240820181718\",{\"1\":{\"420\":1}}],[\"20240820181406\",{\"1\":{\"420\":1}}],[\"20240818182231\",{\"1\":{\"412\":1}}],[\"20240818182301\",{\"1\":{\"412\":1}}],[\"20240818182057\",{\"1\":{\"410\":1}}],[\"20240818181917\",{\"1\":{\"411\":1}}],[\"20240817000409\",{\"1\":{\"403\":1}}],[\"20240817000331\",{\"1\":{\"403\":1}}],[\"20240817000642\",{\"1\":{\"402\":1}}],[\"20240817000601\",{\"1\":{\"402\":1}}],[\"20240817000500\",{\"1\":{\"402\":1}}],[\"20240817000230\",{\"1\":{\"401\":1}}],[\"20240817000134\",{\"1\":{\"401\":1}}],[\"20240817000114\",{\"1\":{\"401\":1}}],[\"20240814230747\",{\"1\":{\"391\":1}}],[\"20240814014058\",{\"1\":{\"388\":1}}],[\"20240812010538\",{\"1\":{\"374\":1}}],[\"20240812011140\",{\"1\":{\"373\":1}}],[\"20240812004534\",{\"1\":{\"368\":1}}],[\"20240811233346\",{\"1\":{\"364\":1}}],[\"20240811011334\",{\"1\":{\"357\":1}}],[\"20240811010933\",{\"1\":{\"356\":1}}],[\"20240811002219\",{\"1\":{\"352\":1}}],[\"20240810190018\",{\"1\":{\"349\":1}}],[\"20240815234719\",{\"1\":{\"120\":1}}],[\"20240830200624\",{\"1\":{\"318\":1}}],[\"20240830200608\",{\"1\":{\"318\":1}}],[\"20240830200406\",{\"1\":{\"317\":1}}],[\"20240830200343\",{\"1\":{\"316\":1}}],[\"20240830200320\",{\"1\":{\"316\":1}}],[\"20240830200305\",{\"1\":{\"316\":1}}],[\"20240830200248\",{\"1\":{\"316\":1}}],[\"20240830200138\",{\"1\":{\"315\":1}}],[\"20240830200118\",{\"1\":{\"315\":1}}],[\"20240830200056\",{\"1\":{\"315\":1}}],[\"20240830185629\",{\"1\":{\"313\":1}}],[\"20240830185556\",{\"1\":{\"313\":1}}],[\"20240830185537\",{\"1\":{\"313\":1}}],[\"20240830185324\",{\"1\":{\"312\":1}}],[\"20240830185127\",{\"1\":{\"311\":1}}],[\"20240830184424\",{\"1\":{\"309\":1}}],[\"20240830184330\",{\"1\":{\"309\":1}}],[\"20240830184312\",{\"1\":{\"308\":1}}],[\"20240830184236\",{\"1\":{\"308\":1}}],[\"20241029001425\",{\"1\":{\"264\":1}}],[\"20241027015718\",{\"1\":{\"254\":1}}],[\"20241027015244\",{\"1\":{\"254\":1}}],[\"20241027012950\",{\"1\":{\"251\":1}}],[\"20241017002218\",{\"1\":{\"227\":1}}],[\"20241130012855\",{\"1\":{\"84\":1}}],[\"20241130005736\",{\"1\":{\"80\":1}}],[\"20241130004116\",{\"1\":{\"71\":1}}],[\"20241130001811\",{\"1\":{\"60\":1}}],[\"20241130000528\",{\"1\":{\"58\":1}}],[\"20241127001435\",{\"1\":{\"43\":1}}],[\"20241126232128\",{\"1\":{\"31\":1}}],[\"20241126232114\",{\"1\":{\"31\":1}}],[\"20241120130452\",{\"1\":{\"23\":1,\"36\":1}}],[\"20241106133211\",{\"1\":{\"15\":1}}],[\"20241106133159\",{\"1\":{\"15\":1}}],[\"20241106133117\",{\"1\":{\"15\":1}}],[\"2\",{\"0\":{\"12\":1,\"13\":1,\"28\":1,\"29\":1,\"108\":1,\"233\":1,\"305\":1,\"310\":1,\"311\":1,\"312\":2,\"313\":1,\"316\":1,\"325\":1,\"327\":1,\"328\":1,\"329\":2,\"330\":1,\"331\":1,\"339\":1,\"340\":1,\"341\":2,\"342\":2,\"343\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":2,\"353\":1,\"356\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":2,\"368\":1,\"369\":1,\"372\":1,\"380\":1,\"381\":1,\"382\":2,\"383\":1,\"384\":1,\"387\":1,\"396\":1,\"397\":1,\"398\":2,\"399\":1,\"402\":1,\"406\":1,\"417\":1,\"418\":1,\"421\":2,\"434\":1,\"435\":1,\"438\":2,\"471\":1,\"692\":1},\"1\":{\"14\":3,\"50\":2,\"57\":2,\"64\":2,\"71\":4,\"77\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":1,\"91\":1,\"112\":1,\"173\":2,\"239\":2,\"240\":2,\"245\":1,\"246\":2,\"274\":1,\"275\":1,\"285\":1,\"293\":1,\"294\":1,\"298\":1,\"299\":1,\"347\":1,\"348\":1,\"351\":1,\"353\":1,\"355\":1,\"364\":2,\"379\":1,\"382\":1,\"386\":1,\"397\":1,\"401\":1,\"418\":1,\"419\":2,\"420\":2,\"421\":2,\"426\":1,\"427\":2,\"476\":1,\"516\":1,\"527\":1,\"533\":1,\"602\":1,\"604\":2}}],[\"泛型和多态\",{\"0\":{\"282\":1}}],[\"泛型只能确定为一个引用类型\",{\"1\":{\"281\":1}}],[\"泛型变量不止可以只有一个\",{\"1\":{\"281\":1}}],[\"泛型将数据类型的确定控制在了编译阶段\",{\"1\":{\"281\":1}}],[\"泛型在定义时并不明确是什么类型\",{\"1\":{\"281\":1}}],[\"泛型其实就一个待定类型\",{\"1\":{\"281\":1}}],[\"泛型其实仅仅是在编译阶段进行类型检查\",{\"1\":{\"16\":1}}],[\"泛型类需要使用<>\",{\"1\":{\"281\":1}}],[\"泛型类\",{\"0\":{\"281\":1}}],[\"泛型的参数获取\",{\"1\":{\"186\":1}}],[\"泛型的类型检查只存在于编译阶段\",{\"1\":{\"80\":1}}],[\"泛型通配符也支持泛型的界限\",{\"1\":{\"15\":1}}],[\"泛型界限\",{\"0\":{\"15\":1}}],[\"泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计\",{\"1\":{\"14\":1}}],[\"泛型方法会在使用时自动确定泛型类型\",{\"1\":{\"14\":1}}],[\"泛型方法\",{\"0\":{\"14\":1}}],[\"泛型\",{\"0\":{\"12\":1,\"13\":1,\"278\":1,\"279\":1}}],[\"cst\",{\"1\":{\"580\":1}}],[\"cdata\",{\"1\":{\"546\":2}}],[\"cj\",{\"1\":{\"516\":1,\"533\":1,\"552\":1,\"580\":1,\"632\":1,\"664\":1}}],[\"ci\",{\"1\":{\"477\":1}}],[\"ck\",{\"1\":{\"476\":1}}],[\"cname\",{\"1\":{\"667\":5}}],[\"cno\",{\"1\":{\"507\":1}}],[\"cn\",{\"1\":{\"455\":1,\"552\":1,\"630\":1}}],[\"certain\",{\"1\":{\"433\":1}}],[\"ceiling\",{\"1\":{\"229\":1}}],[\"critic\",{\"0\":{\"308\":1,\"309\":1,\"310\":1,\"314\":1,\"318\":1},\"1\":{\"308\":2}}],[\"created\",{\"1\":{\"580\":1}}],[\"create\",{\"1\":{\"139\":1,\"472\":1,\"476\":1,\"477\":2,\"478\":1,\"500\":2,\"507\":2,\"508\":1,\"509\":1}}],[\"createstatement\",{\"1\":{\"516\":1,\"518\":1,\"524\":1,\"526\":1,\"532\":1,\"534\":4}}],[\"creates\",{\"1\":{\"139\":1}}],[\"cmax​\",{\"1\":{\"299\":1}}],[\"cycles\",{\"1\":{\"295\":1}}],[\"c1​和c2​是通过分析web浏览应用程序的实验结果确定的常数\",{\"1\":{\"295\":1}}],[\"c是光速\",{\"1\":{\"294\":1}}],[\"c4πfc​​\",{\"1\":{\"294\":1}}],[\"c>\",{\"1\":{\"281\":1}}],[\"c++实现\",{\"1\":{\"183\":1}}],[\"cpdd\",{\"1\":{\"182\":1}}],[\"cpu一般通过时间片轮转调度算法\",{\"1\":{\"138\":1}}],[\"cpu一个核心同时只能处理一件事情\",{\"1\":{\"138\":1}}],[\"currentthread\",{\"1\":{\"140\":2,\"142\":1,\"144\":1,\"166\":1,\"167\":1,\"173\":1,\"174\":2,\"517\":1,\"676\":1}}],[\"cursor<user>\",{\"1\":{\"564\":1}}],[\"cursor<t>\",{\"1\":{\"564\":1}}],[\"cursor\",{\"1\":{\"33\":1,\"564\":2}}],[\"cause\",{\"1\":{\"569\":1,\"571\":1}}],[\"causes\",{\"1\":{\"139\":1}}],[\"carlo\",{\"0\":{\"360\":1,\"422\":1},\"1\":{\"360\":1,\"441\":1}}],[\"cachenamespace\",{\"1\":{\"631\":1}}],[\"cachenamespace注解直接定义在接口上即可\",{\"1\":{\"631\":1}}],[\"cache\",{\"1\":{\"227\":1,\"455\":1}}],[\"callersensitive\",{\"1\":{\"517\":1}}],[\"callercl\",{\"1\":{\"517\":5}}],[\"caller\",{\"1\":{\"517\":4}}],[\"called\",{\"1\":{\"139\":1,\"304\":1,\"366\":1,\"371\":1}}],[\"calls\",{\"1\":{\"167\":1}}],[\"cast\",{\"1\":{\"184\":1}}],[\"cased\",{\"1\":{\"107\":1}}],[\"case\",{\"1\":{\"107\":1}}],[\"cas无锁算法\",{\"1\":{\"107\":1}}],[\"cannot\",{\"1\":{\"517\":1}}],[\"can\",{\"1\":{\"326\":1,\"333\":2,\"517\":2}}],[\"cancel\",{\"1\":{\"167\":1}}],[\"cancelled\",{\"1\":{\"167\":1}}],[\"canexecute\",{\"1\":{\"98\":1}}],[\"canwrite\",{\"1\":{\"98\":1}}],[\"canread\",{\"1\":{\"98\":1}}],[\"catch代码块\",{\"1\":{\"540\":1}}],[\"catch\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"110\":1,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"172\":2,\"174\":2,\"199\":2,\"267\":10,\"447\":3,\"448\":2,\"454\":2,\"455\":2,\"516\":1,\"517\":1,\"524\":1,\"526\":1,\"527\":1,\"532\":1,\"533\":1,\"534\":4,\"547\":1,\"558\":1,\"569\":2}}],[\"capacity\",{\"1\":{\"25\":2,\"60\":5}}],[\"child\",{\"1\":{\"547\":3}}],[\"childnodes\",{\"1\":{\"547\":3}}],[\"chiness\",{\"1\":{\"65\":3}}],[\"check\",{\"1\":{\"475\":2,\"476\":1,\"507\":2,\"517\":1}}],[\"checkedxxx可以将给定集合类进行包装\",{\"1\":{\"80\":1}}],[\"checkedlist\",{\"1\":{\"80\":1}}],[\"chrome\",{\"1\":{\"455\":2}}],[\"chromium\",{\"1\":{\"455\":1}}],[\"ch\",{\"1\":{\"455\":3}}],[\"choose>\",{\"1\":{\"602\":1}}],[\"choose\",{\"1\":{\"305\":1}}],[\"chapter\",{\"1\":{\"347\":1,\"353\":1}}],[\"chain\",{\"1\":{\"304\":1}}],[\"channel\",{\"1\":{\"294\":1}}],[\"charlie\",{\"1\":{\"285\":1}}],[\"charset\",{\"1\":{\"477\":1}}],[\"chars\",{\"1\":{\"244\":2}}],[\"character>\",{\"1\":{\"281\":1}}],[\"character\",{\"1\":{\"227\":1}}],[\"charat\",{\"1\":{\"71\":2}}],[\"char\",{\"1\":{\"91\":2,\"96\":3,\"105\":1,\"108\":8,\"112\":1,\"126\":1,\"227\":1,\"243\":1,\"244\":1,\"455\":1,\"474\":1}}],[\"cleanup作用与局部变量\",{\"1\":{\"540\":1}}],[\"clear\",{\"1\":{\"23\":1,\"47\":1,\"56\":1,\"167\":1}}],[\"clientpreparedstatement\",{\"1\":{\"533\":1}}],[\"client\",{\"1\":{\"448\":2,\"454\":2}}],[\"clazz3\",{\"1\":{\"182\":1}}],[\"clazz2\",{\"1\":{\"182\":1}}],[\"clazz\",{\"1\":{\"182\":1,\"184\":6,\"191\":6,\"192\":10,\"199\":7,\"208\":4,\"527\":3}}],[\"class=\",{\"1\":{\"622\":1}}],[\"classloader\",{\"1\":{\"199\":3,\"517\":3}}],[\"class<t>\",{\"1\":{\"527\":1}}],[\"class<student>\",{\"1\":{\"191\":3,\"208\":2}}],[\"class<string\",{\"1\":{\"184\":1}}],[\"class<string>\",{\"1\":{\"182\":1}}],[\"class<integer>\",{\"1\":{\"183\":2}}],[\"class<\",{\"1\":{\"182\":2,\"183\":1,\"186\":1,\"192\":3,\"199\":2,\"215\":1,\"517\":1,\"527\":1}}],[\"class对象中包含我们类的一些信息\",{\"1\":{\"180\":1}}],[\"class文件\",{\"1\":{\"180\":1,\"199\":1}}],[\"classnotfoundexception\",{\"1\":{\"131\":1,\"133\":1,\"182\":1,\"192\":1,\"193\":1,\"266\":2,\"526\":1,\"533\":1,\"534\":4}}],[\"class关键字我们会在后面反射中介绍\",{\"1\":{\"80\":1}}],[\"class\",{\"0\":{\"181\":1,\"183\":1,\"184\":1,\"185\":1},\"1\":{\"4\":1,\"5\":1,\"9\":4,\"14\":1,\"15\":1,\"16\":4,\"23\":1,\"25\":3,\"36\":1,\"42\":1,\"58\":2,\"61\":1,\"65\":1,\"67\":1,\"80\":1,\"84\":4,\"117\":1,\"118\":2,\"120\":3,\"121\":2,\"131\":1,\"132\":1,\"133\":1,\"155\":6,\"165\":2,\"167\":2,\"174\":1,\"182\":4,\"183\":4,\"184\":1,\"186\":13,\"191\":7,\"192\":11,\"193\":4,\"198\":6,\"199\":5,\"206\":1,\"207\":2,\"208\":2,\"215\":1,\"216\":1,\"218\":2,\"219\":2,\"220\":1,\"221\":2,\"241\":1,\"251\":7,\"252\":2,\"253\":3,\"254\":7,\"255\":4,\"265\":2,\"280\":1,\"281\":2,\"282\":6,\"377\":1,\"448\":2,\"454\":2,\"455\":1,\"516\":4,\"517\":3,\"524\":1,\"527\":2,\"538\":2,\"554\":1,\"558\":1,\"563\":1,\"569\":1,\"570\":2,\"571\":1,\"577\":2,\"581\":2,\"583\":2,\"593\":3,\"599\":1,\"605\":1,\"611\":3,\"612\":2,\"616\":1,\"626\":1,\"628\":4,\"630\":2,\"632\":1,\"636\":1,\"638\":2,\"639\":1,\"646\":1,\"655\":1,\"665\":1,\"672\":1,\"678\":2}}],[\"closing\",{\"1\":{\"580\":1}}],[\"close=\",{\"1\":{\"604\":1}}],[\"closeable\",{\"1\":{\"564\":1}}],[\"closed\",{\"1\":{\"332\":1}}],[\"close\",{\"1\":{\"90\":1,\"107\":2,\"447\":1,\"448\":2,\"454\":1,\"455\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"215\":1,\"220\":2,\"264\":1}}],[\"clone\",{\"1\":{\"215\":2,\"220\":6,\"264\":1,\"266\":1}}],[\"cloneable\",{\"1\":{\"25\":2,\"42\":1,\"58\":1,\"67\":1,\"220\":2}}],[\"c\",{\"1\":{\"23\":4,\"24\":3,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"47\":4,\"71\":1,\"92\":1,\"281\":3,\"285\":1,\"296\":1,\"298\":1,\"534\":3}}],[\"ccc\",{\"1\":{\"14\":1,\"285\":1}}],[\"could\",{\"1\":{\"517\":1}}],[\"count\",{\"1\":{\"493\":3}}],[\"correct\",{\"1\":{\"517\":1}}],[\"core\",{\"1\":{\"337\":1,\"539\":1}}],[\"columns\",{\"1\":{\"580\":2}}],[\"column=\",{\"1\":{\"563\":2,\"569\":2,\"578\":8,\"579\":4,\"581\":5,\"582\":4,\"583\":9,\"626\":2,\"628\":3}}],[\"column\",{\"1\":{\"479\":2,\"563\":1,\"626\":2,\"628\":3,\"629\":2}}],[\"collate\",{\"1\":{\"477\":1}}],[\"collocations\",{\"1\":{\"75\":1}}],[\"collectors\",{\"1\":{\"71\":3,\"285\":2}}],[\"collect\",{\"1\":{\"71\":3,\"285\":2}}],[\"collection就是我们需要遍历的集合或是数组等任意可迭代对象\",{\"1\":{\"604\":1}}],[\"collection=\",{\"1\":{\"604\":1,\"605\":1}}],[\"collection>\",{\"1\":{\"581\":1}}],[\"collections\",{\"0\":{\"74\":1,\"75\":1},\"1\":{\"76\":2,\"77\":1,\"78\":1,\"79\":3,\"80\":2}}],[\"collection\",{\"1\":{\"24\":2,\"47\":3,\"55\":1,\"581\":1}}],[\"collection<v>\",{\"1\":{\"56\":1}}],[\"collection<\",{\"1\":{\"23\":4,\"24\":1,\"47\":4}}],[\"collection<e>\",{\"1\":{\"23\":1,\"24\":1,\"43\":1,\"47\":1}}],[\"coefficient\",{\"1\":{\"382\":1}}],[\"commons\",{\"1\":{\"601\":2,\"679\":1}}],[\"commit\",{\"1\":{\"510\":1,\"534\":5,\"593\":1,\"612\":1}}],[\"committed\",{\"1\":{\"510\":1}}],[\"comments\",{\"1\":{\"355\":1}}],[\"comment\",{\"1\":{\"167\":1}}],[\"com\",{\"1\":{\"120\":8,\"121\":1,\"192\":4,\"199\":3,\"221\":6,\"242\":1,\"246\":1,\"254\":4,\"255\":2,\"516\":1,\"533\":1,\"552\":1,\"554\":1,\"559\":1,\"560\":2,\"563\":1,\"564\":2,\"569\":2,\"570\":2,\"571\":1,\"577\":1,\"579\":3,\"580\":3,\"581\":2,\"582\":2,\"583\":3,\"589\":1,\"590\":1,\"614\":1,\"615\":1,\"622\":2,\"623\":1,\"625\":1,\"632\":3,\"636\":1,\"647\":1,\"657\":2,\"658\":4,\"674\":1}}],[\"compatibility\",{\"1\":{\"517\":1}}],[\"comparable\",{\"1\":{\"77\":1}}],[\"comparator\",{\"1\":{\"24\":1,\"46\":1}}],[\"comparator<\",{\"1\":{\"24\":1}}],[\"comparator<integer>\",{\"1\":{\"14\":2}}],[\"compareandset\",{\"1\":{\"107\":1}}],[\"compare方法要求返回一个int来表示两个数的大小关系\",{\"1\":{\"14\":1}}],[\"compare\",{\"1\":{\"14\":2}}],[\"compiled\",{\"1\":{\"221\":1}}],[\"computeifabsent\",{\"1\":{\"64\":2}}],[\"computeifpresent\",{\"1\":{\"64\":2}}],[\"compute\",{\"1\":{\"64\":3}}],[\"config\",{\"1\":{\"552\":4,\"554\":1,\"558\":1,\"638\":4,\"639\":1,\"667\":1}}],[\"configuration>\",{\"1\":{\"552\":1}}],[\"configuration\",{\"1\":{\"552\":2,\"632\":9}}],[\"con\",{\"1\":{\"517\":3,\"534\":3}}],[\"connectivity\",{\"1\":{\"515\":1}}],[\"connectionimpl\",{\"1\":{\"580\":1}}],[\"connection是数据库的连接对象\",{\"1\":{\"518\":1}}],[\"connection\",{\"1\":{\"455\":1,\"516\":3,\"517\":5,\"524\":3,\"526\":3,\"532\":3,\"533\":3,\"534\":23,\"580\":4}}],[\"connect\",{\"1\":{\"449\":2,\"517\":2}}],[\"convert\",{\"1\":{\"527\":2}}],[\"converges\",{\"1\":{\"383\":1}}],[\"convergence\",{\"1\":{\"343\":1}}],[\"convex问题\",{\"1\":{\"296\":1}}],[\"concepts\",{\"1\":{\"337\":1}}],[\"context\",{\"1\":{\"564\":2}}],[\"control\",{\"1\":{\"455\":1,\"472\":1}}],[\"contractive\",{\"1\":{\"343\":1}}],[\"contraction\",{\"1\":{\"338\":2,\"343\":2,\"347\":1}}],[\"contract\",{\"1\":{\"139\":1}}],[\"continuing\",{\"1\":{\"304\":1}}],[\"containsvalue\",{\"1\":{\"56\":1}}],[\"containskey\",{\"1\":{\"56\":1}}],[\"containsall\",{\"1\":{\"23\":1,\"47\":1}}],[\"contains\",{\"1\":{\"23\":1,\"47\":1}}],[\"consolehandler会配置一个simpleformatter对象\",{\"1\":{\"649\":1}}],[\"consolehandler\",{\"1\":{\"646\":2,\"647\":2,\"657\":1,\"667\":2,\"675\":1,\"679\":2}}],[\"constraint\",{\"1\":{\"476\":6}}],[\"constructorargs\",{\"1\":{\"628\":1}}],[\"constructorargs注解\",{\"1\":{\"628\":1}}],[\"constructor>\",{\"1\":{\"569\":2,\"628\":1}}],[\"constructor<t>\",{\"1\":{\"527\":1}}],[\"constructor<\",{\"1\":{\"192\":1}}],[\"constructor<student>\",{\"1\":{\"191\":2}}],[\"constructor\",{\"1\":{\"139\":1,\"191\":5,\"192\":2,\"527\":3,\"569\":1}}],[\"consider\",{\"1\":{\"343\":1}}],[\"considered\",{\"1\":{\"289\":1}}],[\"consumes\",{\"1\":{\"167\":1}}],[\"consumer<\",{\"1\":{\"32\":1,\"35\":1,\"36\":1}}],[\"copyofarrays\",{\"1\":{\"275\":1}}],[\"copyof\",{\"1\":{\"14\":1,\"25\":1}}],[\"code>\",{\"1\":{\"139\":3}}],[\"code\",{\"0\":{\"685\":1},\"1\":{\"183\":2},\"2\":{\"10\":1,\"17\":1,\"26\":1,\"38\":1,\"51\":1,\"68\":1,\"72\":1,\"81\":1,\"85\":1,\"99\":1,\"114\":1,\"122\":1,\"134\":1,\"149\":1,\"157\":1,\"168\":1,\"175\":1,\"187\":1,\"194\":1,\"200\":1,\"209\":1,\"222\":1,\"230\":1,\"247\":1,\"259\":1,\"269\":1,\"276\":1,\"283\":1,\"286\":1,\"450\":1,\"456\":1,\"468\":1,\"485\":1,\"503\":1,\"511\":1,\"520\":1,\"528\":1,\"535\":1,\"541\":1,\"548\":1,\"555\":1,\"565\":1,\"572\":1,\"584\":1,\"594\":1,\"606\":1,\"617\":1,\"633\":1,\"641\":1,\"650\":1,\"659\":1,\"668\":1,\"680\":1}}],[\"08\",{\"1\":{\"580\":1}}],[\"08001\",{\"1\":{\"517\":2}}],[\"0版本以上\",{\"1\":{\"516\":1}}],[\"03\",{\"1\":{\"491\":1,\"580\":2}}],[\"036\",{\"1\":{\"474\":2}}],[\"0<c1​≤▽w​g\",{\"1\":{\"383\":1}}],[\"0≤t≤ts​\",{\"1\":{\"293\":2,\"296\":2}}],[\"0xa6\",{\"1\":{\"228\":1}}],[\"0\",{\"1\":{\"9\":1,\"14\":5,\"23\":1,\"25\":7,\"36\":1,\"48\":1,\"49\":1,\"59\":2,\"60\":4,\"64\":1,\"66\":6,\"71\":4,\"92\":1,\"94\":1,\"139\":1,\"142\":1,\"147\":3,\"148\":2,\"154\":3,\"155\":14,\"161\":2,\"172\":2,\"173\":2,\"199\":1,\"237\":1,\"239\":1,\"241\":1,\"244\":1,\"246\":5,\"266\":1,\"274\":1,\"275\":1,\"280\":1,\"298\":17,\"299\":1,\"304\":1,\"332\":1,\"372\":1,\"389\":1,\"454\":1,\"455\":7,\"476\":1,\"527\":2,\"545\":2,\"547\":2,\"552\":2,\"554\":2,\"656\":1,\"674\":1}}],[\"但允许执行delete操作\",{\"1\":{\"507\":1}}],[\"但允许空值\",{\"1\":{\"475\":1}}],[\"但在发表\",{\"1\":{\"429\":1}}],[\"但对于\",{\"1\":{\"427\":1}}],[\"但对象中的属性都是同一个地址\",{\"1\":{\"220\":1}}],[\"但这里还有一个难点\",{\"1\":{\"421\":1}}],[\"但实际情况可能并不是所有状态的概率都是一致的\",{\"1\":{\"419\":1}}],[\"但实际上我们往往是选择一个非常小的常数\",{\"1\":{\"383\":1}}],[\"但实际上还是在调用本身的方法\",{\"1\":{\"216\":1}}],[\"但能否保证其精确度\",{\"1\":{\"386\":1}}],[\"但能匹配\",{\"1\":{\"246\":1}}],[\"但需要大量的\",{\"1\":{\"386\":1}}],[\"但由于\",{\"1\":{\"386\":1}}],[\"但目前无法保证\",{\"1\":{\"369\":1}}],[\"但存在一定的浪费\",{\"1\":{\"366\":1}}],[\"但现实场景中不太经常使用\",{\"1\":{\"361\":1}}],[\"但若考虑集群情况\",{\"1\":{\"299\":1}}],[\"但每个无人机所管理的用户不同\",{\"1\":{\"298\":1}}],[\"但即使仅考虑用户聚类\",{\"1\":{\"298\":1}}],[\"但功能灵活\",{\"1\":{\"285\":1}}],[\"但如果是\",{\"1\":{\"285\":1}}],[\"但并不是最好的方案\",{\"1\":{\"280\":1}}],[\"但并不是这个文件本身\",{\"1\":{\"98\":1}}],[\"但它继承自一个现有的类或实现了一个接口\",{\"1\":{\"255\":1}}],[\"但它是为了并行执行而设计的\",{\"1\":{\"173\":1}}],[\"但类名必须与接口一致\",{\"1\":{\"255\":1}}],[\"但我们可以在方法中使用匿名内部类\",{\"1\":{\"255\":1}}],[\"但还存在\",{\"1\":{\"441\":1}}],[\"但还是先初始化内部类\",{\"1\":{\"254\":1}}],[\"但还未复制\",{\"1\":{\"9\":1}}],[\"但不能超过n\",{\"1\":{\"474\":1}}],[\"但不能匹配\",{\"1\":{\"246\":1}}],[\"但不一定会导致致命的问题\",{\"1\":{\"264\":1}}],[\"但不推荐\",{\"1\":{\"235\":1}}],[\"但不支持\",{\"1\":{\"229\":1}}],[\"但包装类的class和基本类的class显然是不同的\",{\"1\":{\"183\":1}}],[\"但效果是一致的\",{\"1\":{\"97\":1}}],[\"但集合可以有不同种类的元素\",{\"1\":{\"22\":1}}],[\"但集合只能存放对象\",{\"1\":{\"22\":1}}],[\"但是对于我们人来说\",{\"1\":{\"648\":1}}],[\"但是还是会有人警告你最好别这样做\",{\"1\":{\"638\":1}}],[\"但是还不够方便\",{\"1\":{\"544\":1}}],[\"但是结果却是依然能够读取\",{\"1\":{\"616\":1}}],[\"但是缓存存在一个问题\",{\"1\":{\"616\":1}}],[\"但是更安全\",{\"1\":{\"612\":1}}],[\"但是会话1中的数据是从缓存得到的\",{\"1\":{\"611\":1}}],[\"但是依然没有影响会话1之中的缓存\",{\"1\":{\"611\":1}}],[\"但是依然能够正常读取\",{\"1\":{\"108\":1}}],[\"但是实际上这种情况完全可以简写为一个sql语句\",{\"1\":{\"604\":1}}],[\"但是实际上我们每次执行sql语句\",{\"1\":{\"599\":1}}],[\"但是并没有提交\",{\"1\":{\"593\":1}}],[\"但是并不会生成setter并且成员属性都是final的\",{\"1\":{\"540\":1}}],[\"但是并不能查看完整的数据库列表\",{\"1\":{\"501\":1}}],[\"但是并不是同一个对象\",{\"1\":{\"227\":1}}],[\"但是并不是所推荐的做法\",{\"1\":{\"142\":1}}],[\"但是并不是很常用\",{\"1\":{\"45\":1}}],[\"但是某些数据库\",{\"1\":{\"590\":1}}],[\"但是一定注意\",{\"1\":{\"611\":1}}],[\"但是一般情况下不需要手动设置\",{\"1\":{\"590\":1}}],[\"但是一旦确定\",{\"1\":{\"281\":1}}],[\"但是其分页功能是对查询到的数据进行划分\",{\"1\":{\"563\":1}}],[\"但是转换的实体类数据并没有被添加上去\",{\"1\":{\"563\":1}}],[\"但是不会出现错误\",{\"1\":{\"552\":1}}],[\"但是不再是object类型\",{\"1\":{\"15\":1}}],[\"但是需要知道mybatis就是通过这种方式来读取配置文件的\",{\"1\":{\"547\":1}}],[\"但是需要的形式参数不一样\",{\"1\":{\"8\":1}}],[\"但是哪怕只是完成一个sql语句的执行\",{\"1\":{\"544\":1}}],[\"但是关键字非常多\",{\"1\":{\"532\":1}}],[\"但是这实在是太过复杂了\",{\"1\":{\"630\":1}}],[\"但是这是一种极其不推荐的做法\",{\"1\":{\"605\":1}}],[\"但是这样很明显是不正确的\",{\"1\":{\"616\":1}}],[\"但是这样可能还是不够方便\",{\"1\":{\"570\":1}}],[\"但是这样始终治标不治本\",{\"1\":{\"60\":1}}],[\"但是这并不代表它们就不重要\",{\"1\":{\"510\":1}}],[\"但是由于表名相同\",{\"1\":{\"496\":1}}],[\"但是由于仅仅是语法糖\",{\"1\":{\"30\":1}}],[\"但是他们目前都是在同一个小组中\",{\"1\":{\"583\":1}}],[\"但是他们之间会存在一些细微的差异\",{\"1\":{\"472\":1}}],[\"但是他们的相同和不同之处在于\",{\"1\":{\"22\":1}}],[\"但是提供技术支持\",{\"1\":{\"460\":1}}],[\"但是http协议并不会保持长连接\",{\"1\":{\"455\":1}}],[\"但是注意\",{\"1\":{\"281\":1,\"569\":1}}],[\"但是注意两个线程必须使用同一把锁\",{\"1\":{\"155\":1}}],[\"但是编译不会报错\",{\"1\":{\"280\":1}}],[\"但是编程不可见\",{\"1\":{\"235\":1}}],[\"但是object类型在编译阶段并不具有良好的类型判断能力\",{\"1\":{\"280\":1}}],[\"但是outputstream又只支持byte类型\",{\"1\":{\"126\":1}}],[\"但是成绩分为两种\",{\"1\":{\"280\":1}}],[\"但是成绩依然可能是整数\",{\"1\":{\"15\":1}}],[\"但是要注意一下顺序\",{\"1\":{\"267\":1}}],[\"但是必须保证其他方法有默认实现\",{\"1\":{\"257\":1}}],[\"但是可以直接new了\",{\"1\":{\"252\":1}}],[\"但是可以存在静态变量和静态方法\",{\"1\":{\"219\":1}}],[\"但是能匹配\",{\"1\":{\"246\":1}}],[\"但是拼接字符串实际上底层需要进行很多操作\",{\"1\":{\"245\":1}}],[\"但是只能在定义时赋值\",{\"1\":{\"235\":1}}],[\"但是biginteger没有这些限制\",{\"1\":{\"229\":1}}],[\"但是各位小伙伴只需要知道\",{\"1\":{\"227\":1}}],[\"但是java中的基本数据类型却不是面向对象的\",{\"1\":{\"226\":1}}],[\"但是它的作用范围实在是有限\",{\"1\":{\"611\":1}}],[\"但是它继承自enum类\",{\"1\":{\"221\":1}}],[\"但是它存在自动刷新机制\",{\"1\":{\"127\":1}}],[\"但是推荐打上\",{\"1\":{\"221\":1}}],[\"但是像这样的拷贝操作其实也分为浅拷贝和深拷贝\",{\"1\":{\"220\":1}}],[\"但是类加载器并不是只有一个\",{\"1\":{\"198\":1}}],[\"但是请一定谨慎使用\",{\"1\":{\"192\":1}}],[\"但是在使用之前\",{\"1\":{\"191\":1}}],[\"但是获取到的type的实现并不一定是class\",{\"1\":{\"186\":1}}],[\"但是前者是唤醒所有调用wait\",{\"1\":{\"161\":1}}],[\"但是又被对方牢牢把握\",{\"1\":{\"156\":1}}],[\"但是又迟迟不释放\",{\"1\":{\"156\":1}}],[\"但是class类实例同样的类无论怎么获取都是同一个\",{\"1\":{\"155\":1}}],[\"但是如果我把这些任务合在一起告诉数据库\",{\"1\":{\"599\":1}}],[\"但是如果我们每次上菜推一个小推车装满n个菜一起上\",{\"1\":{\"599\":1}}],[\"但是如果我们使用构造方法主动创建两个新的对象\",{\"1\":{\"244\":1}}],[\"但是如果我们在运行时\",{\"1\":{\"242\":1}}],[\"但是如果存在多个构造方法\",{\"1\":{\"569\":1}}],[\"但是如果使用$\",{\"1\":{\"559\":1}}],[\"但是如果希望向指定列上插入数据\",{\"1\":{\"482\":1}}],[\"但是如果是引用类型的话\",{\"1\":{\"238\":1}}],[\"但是如果超出这个缓存范围的话\",{\"1\":{\"227\":1}}],[\"但是如果同时写入内容\",{\"1\":{\"154\":1}}],[\"但是如果多个处理器的运算任务都涉及同一块内存区域\",{\"1\":{\"154\":1}}],[\"但是如果队列为空\",{\"1\":{\"43\":2}}],[\"但是如果队列已经为空\",{\"1\":{\"43\":2}}],[\"但是很有可能导致资源不能完全释放\",{\"1\":{\"144\":1}}],[\"但是run是直接在当前线程执行\",{\"1\":{\"141\":1}}],[\"但是\",{\"1\":{\"138\":1,\"156\":1,\"236\":1,\"467\":1}}],[\"但是name属性并没有保存\",{\"1\":{\"133\":1}}],[\"但是我个人认为这种说法是错的\",{\"1\":{\"219\":1}}],[\"但是我只能往一个outputstream里输出\",{\"1\":{\"126\":1}}],[\"但是我们希望缓存能够扩展到所有会话都能使用\",{\"1\":{\"611\":1}}],[\"但是我们希望能够按字符的方式读取\",{\"1\":{\"126\":1}}],[\"但是我们不能过度使用索引\",{\"1\":{\"508\":1}}],[\"但是我们不能滥用\",{\"1\":{\"193\":1}}],[\"但是我们服务端却收到了不少的信息\",{\"1\":{\"455\":1}}],[\"但是我们也可以将接口实现类的对象以接口的形式去使用\",{\"1\":{\"219\":1}}],[\"但是我们明明在自己写的string类中定义了main方法\",{\"1\":{\"198\":1}}],[\"但是我们的程序并没有停止\",{\"1\":{\"167\":1}}],[\"但是我们限定下界的话\",{\"1\":{\"15\":1}}],[\"但是我们发现xml配置文件读取实在是太麻烦\",{\"1\":{\"664\":1}}],[\"但是我们发现\",{\"1\":{\"9\":1,\"625\":1}}],[\"但是我们前面说了\",{\"1\":{\"4\":1}}],[\"但是同样需要有访问权限的情况下才可以\",{\"1\":{\"121\":1}}],[\"但是现在支持以reader的方式进行读取\",{\"1\":{\"126\":1}}],[\"但是现在支持以writer的方式进行写入\",{\"1\":{\"126\":1}}],[\"但是现在\",{\"1\":{\"120\":1}}],[\"但是静态方法是可以访问到静态变量的\",{\"1\":{\"117\":1}}],[\"但是进行了一些额外的处理然后再调用fileinputstream的同名方法\",{\"1\":{\"107\":1}}],[\"但是每次都需要从外部i\",{\"1\":{\"103\":1}}],[\"但是学习\",{\"1\":{\"50\":1}}],[\"但是出队顺序是按照优先级来的\",{\"1\":{\"46\":1}}],[\"但是是可以正常运行的\",{\"1\":{\"630\":1}}],[\"但是是固定长度为n\",{\"1\":{\"474\":1}}],[\"但是是next方法是从后往前进行遍历的\",{\"1\":{\"44\":1}}],[\"但是是并行执行的\",{\"1\":{\"23\":1}}],[\"但是插入失败不会抛出异常\",{\"1\":{\"43\":1}}],[\"但是都是按照迭代器的标准进行了实现\",{\"1\":{\"33\":1}}],[\"但是之后的版本可以\",{\"1\":{\"25\":1}}],[\"但是仅返回类型不同\",{\"1\":{\"8\":1}}],[\"但是当前作用域下只有对象属性的name变量\",{\"1\":{\"7\":1}}],[\"但是规则跟变量的命名差不多\",{\"1\":{\"5\":1}}],[\"而默认情况下是未配置\",{\"1\":{\"679\":1}}],[\"而日志在打印时\",{\"1\":{\"655\":1}}],[\"而all则相反\",{\"1\":{\"640\":1}}],[\"而要修改日志的默认打印级别\",{\"1\":{\"640\":1}}],[\"而info级别以下的日志则会直接省略\",{\"1\":{\"639\":1}}],[\"而返回类型mybatis会自动根据方法的返回值进行判断\",{\"1\":{\"624\":1}}],[\"而在这个过程中\",{\"1\":{\"616\":1}}],[\"而在右表中缺失的数据会使用null来代替\",{\"1\":{\"497\":1}}],[\"而mybatis也会这样\",{\"1\":{\"616\":1}}],[\"而mybatis不知道该如何选择\",{\"1\":{\"569\":1}}],[\"而可读写的缓存会\",{\"1\":{\"612\":1}}],[\"而数据库也是这样\",{\"1\":{\"599\":1}}],[\"而构造方法中没有传入的字段\",{\"1\":{\"569\":1}}],[\"而字段的赋值无论是什么构造方法\",{\"1\":{\"569\":1}}],[\"而字符串则是一系列字符的序列\",{\"1\":{\"243\":1}}],[\"而通过sqlsession就可以完成几乎所有的数据库操作\",{\"1\":{\"553\":1}}],[\"而xml主要是存放数据\",{\"1\":{\"545\":1}}],[\"而使用lombok之后\",{\"1\":{\"538\":1}}],[\"而最外层有一个真正的\",{\"1\":{\"533\":1}}],[\"而最小值问题\",{\"1\":{\"389\":1}}],[\"而它就是自动生成的logger\",{\"1\":{\"678\":1}}],[\"而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换\",{\"1\":{\"527\":1}}],[\"而它的run方法会循环地读取队列中是否还有任务\",{\"1\":{\"167\":1}}],[\"而cascade会强制连带引用此列的约束\",{\"1\":{\"479\":1}}],[\"而书籍名称和书籍作者依赖于书籍编号\",{\"1\":{\"466\":1}}],[\"而下面这样的就存在可分割的情况\",{\"1\":{\"464\":1}}],[\"而学号唯一对应\",{\"1\":{\"461\":1}}],[\"而学生相对于老师就是被教授的关系\",{\"1\":{\"461\":1}}],[\"而像一个老师教多个学生的联系就是一种一对多的联系\",{\"1\":{\"461\":1}}],[\"而java就对socket底层支持进行了一套完整的封装\",{\"1\":{\"446\":1}}],[\"而对应的真实梯度可以用一个估计的梯度来替代\",{\"1\":{\"441\":1}}],[\"而对应的策略梯度上升算法就是对应\",{\"1\":{\"308\":1}}],[\"而\",{\"1\":{\"326\":1,\"355\":1,\"356\":1,\"475\":1}}],[\"而计算机网络实验这门课是以等级进行结算\",{\"1\":{\"280\":1}}],[\"而错误是致命问题\",{\"1\":{\"264\":1}}],[\"而bigdecimal可以实现小数的精确计算\",{\"1\":{\"229\":1}}],[\"而bufferedinputstream虽然有着同样的方法\",{\"1\":{\"107\":1}}],[\"而实际上指向的还是原来的那个对象\",{\"1\":{\"220\":1}}],[\"而实际要去启动的是真正的string类\",{\"1\":{\"198\":1}}],[\"而具体的实现\",{\"1\":{\"218\":1}}],[\"而方法的重写是覆盖原有的方法实现\",{\"1\":{\"216\":1}}],[\"而与注释不同的是\",{\"1\":{\"203\":1}}],[\"而我们自己编写的类实际上是appclassloader加载的\",{\"1\":{\"198\":1}}],[\"而我们可以通过连地址法解决这种问题\",{\"1\":{\"58\":1}}],[\"而反射机制其实就是利用这些存放的类信息\",{\"1\":{\"181\":1}}],[\"而当货架有货物的时候\",{\"1\":{\"174\":1}}],[\"而当我们需要使用其他包中的类时\",{\"1\":{\"120\":1}}],[\"而守护线程就不一样了\",{\"1\":{\"172\":1}}],[\"而后者是看运气随机选择一个\",{\"1\":{\"161\":1}}],[\"而如果抽象类定义的是\",{\"1\":{\"218\":1}}],[\"而如果是普通成员方法\",{\"1\":{\"155\":1}}],[\"而如果我们希望同时执行多个任务\",{\"1\":{\"138\":1}}],[\"而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容\",{\"1\":{\"155\":1}}],[\"而其他则是无序的\",{\"1\":{\"21\":1}}],[\"而这种问题\",{\"1\":{\"533\":1}}],[\"而这里面就定义了大量的接口\",{\"1\":{\"515\":1}}],[\"而这里定义为只在代码中\",{\"1\":{\"206\":1}}],[\"而这里的结点既存放键也存放值\",{\"1\":{\"58\":1}}],[\"而这时如果其他使用同样的锁的同步代码块也想执行内容\",{\"1\":{\"155\":1}}],[\"而进行自增操作之后\",{\"1\":{\"154\":1}}],[\"而类似这样的发送通知来告知线程需要中断\",{\"1\":{\"144\":1}}],[\"而原来保存的数据只适用于之前版本的这个类\",{\"1\":{\"132\":1}}],[\"而每一个\",{\"1\":{\"118\":1}}],[\"而并非完全由readlimit确定\",{\"1\":{\"108\":1}}],[\"而缓冲流提供了缓冲机制\",{\"1\":{\"108\":1}}],[\"而缓冲流正如其名称一样\",{\"1\":{\"103\":1}}],[\"而filenotfoundexception是继承自ioexception的\",{\"1\":{\"90\":1}}],[\"而言\",{\"1\":{\"84\":1,\"355\":1}}],[\"而且没有执行\",{\"1\":{\"612\":1}}],[\"而且还要知道对应的返回类型\",{\"1\":{\"570\":1}}],[\"而且是\",{\"1\":{\"236\":1}}],[\"而且如果是子类\",{\"1\":{\"218\":1}}],[\"而且在更多情况下\",{\"1\":{\"199\":1}}],[\"而且我们不仅可以通过class关键字获取\",{\"1\":{\"183\":1}}],[\"而且执行不同进程会产生上下文切换\",{\"1\":{\"138\":1}}],[\"而且通过对对象的序列化操作\",{\"1\":{\"130\":1}}],[\"而且逻辑也更加清晰明了\",{\"1\":{\"71\":1}}],[\"而且接口中本身就已经定义了主要的方法\",{\"1\":{\"25\":1}}],[\"而内部维护的\",{\"1\":{\"67\":1}}],[\"而冲突时会得到一个被覆盖的值\",{\"1\":{\"60\":1}}],[\"而hashmap也是这样的\",{\"1\":{\"58\":1}}],[\"而值就是学生信息\",{\"1\":{\"56\":1}}],[\"而双端队列允许在队列的两端进行入队和出队操作\",{\"1\":{\"44\":1}}],[\"而不需要我们再使用代码进行配置\",{\"1\":{\"667\":1}}],[\"而不需要关心集合类是如何实现\",{\"1\":{\"33\":1}}],[\"而不同的数据库厂商实现的这套标准\",{\"1\":{\"515\":1}}],[\"而不会直接存放到主内存中\",{\"1\":{\"162\":1}}],[\"而不太重要的任务\",{\"1\":{\"145\":1}}],[\"而不是传统的直接打印\",{\"1\":{\"677\":1}}],[\"而不是再去向数据库进行请求\",{\"1\":{\"610\":1}}],[\"而不是预先定义好的\",{\"1\":{\"570\":1}}],[\"而不是仅考虑吞吐量\",{\"1\":{\"289\":1}}],[\"而不是类所有的\",{\"1\":{\"251\":1}}],[\"而不是创建一个数组\",{\"1\":{\"207\":1}}],[\"而不是在对象创建的时候分配\",{\"1\":{\"118\":1}}],[\"而不是具体的某个对象\",{\"1\":{\"117\":1}}],[\"而不是字节\",{\"1\":{\"96\":1}}],[\"而不是直接向外部设备写入\",{\"1\":{\"103\":1}}],[\"而不是直接替换原文件内容\",{\"1\":{\"93\":1}}],[\"而不是直接开始执行内容\",{\"1\":{\"71\":1}}],[\"而不是进行等号判断\",{\"1\":{\"25\":1}}],[\"而不是对象本身的复制\",{\"1\":{\"4\":1}}],[\"而不是本体\",{\"1\":{\"4\":1}}],[\"而迭代器则可以将多种多样不同的集合类遍历方式进行统一\",{\"1\":{\"31\":1}}],[\"而另一些则不允许\",{\"1\":{\"21\":1}}],[\"而是直接使用注解在接口上进行配置呢\",{\"1\":{\"621\":1}}],[\"而是直接获取之前创建好的\",{\"1\":{\"611\":1}}],[\"而是直接传值\",{\"1\":{\"559\":1}}],[\"而是使用list内部所包含的类型\",{\"1\":{\"564\":1}}],[\"而是使用内部检查机制checkerror\",{\"1\":{\"127\":1}}],[\"而是它们能够使得我们在不同的开发场景下\",{\"1\":{\"544\":1}}],[\"而是一口气全部交给数据库处理\",{\"1\":{\"526\":1}}],[\"而是一个参数化类型\",{\"1\":{\"186\":1}}],[\"而是等\",{\"1\":{\"427\":1}}],[\"而是对应的样本\",{\"1\":{\"384\":1}}],[\"而是对应的上界\",{\"1\":{\"15\":1}}],[\"而是需要到使用时才会确定对应的泛型类型\",{\"1\":{\"281\":1}}],[\"而是动态进行传递\",{\"1\":{\"199\":1}}],[\"而是通过获取构造器\",{\"1\":{\"191\":1}}],[\"而是通过这个类去使用\",{\"1\":{\"117\":1}}],[\"而是通知程序做其他事情\",{\"1\":{\"144\":1}}],[\"而是在需要时才会去加载\",{\"1\":{\"118\":1}}],[\"而是在这之前就已经完成了\",{\"1\":{\"9\":1}}],[\"而是我们传入的fileinputstream\",{\"1\":{\"107\":1}}],[\"而是单独的一个体系\",{\"1\":{\"55\":1,\"56\":1}}],[\"而是按照数字的大小进行排列\",{\"1\":{\"50\":1}}],[\"而是\",{\"1\":{\"49\":1}}],[\"而非\",{\"1\":{\"9\":1}}],[\"要开启日志系统\",{\"1\":{\"679\":1}}],[\"要开启二级缓存\",{\"1\":{\"612\":1}}],[\"要解决这种问题也很简单\",{\"1\":{\"569\":1}}],[\"要解决这种问题很简单\",{\"1\":{\"80\":1}}],[\"要去设计存放一个实体的表\",{\"1\":{\"463\":1}}],[\"要保持服务器一直在线\",{\"1\":{\"455\":1}}],[\"要求g\",{\"1\":{\"383\":1}}],[\"要求设计一个score对象\",{\"1\":{\"280\":1}}],[\"要证明加入baseline成立\",{\"1\":{\"311\":1}}],[\"要么全部不完成\",{\"1\":{\"510\":1}}],[\"要么全部完成\",{\"1\":{\"510\":1}}],[\"要么在当前函数通过\",{\"1\":{\"267\":1}}],[\"要么一直\",{\"1\":{\"267\":1}}],[\"要么就往上一级函数上\",{\"1\":{\"266\":1}}],[\"要么自己处理好\",{\"1\":{\"266\":1}}],[\"要创建一个抽象类的实例对象\",{\"1\":{\"255\":1}}],[\"要创建一个缓冲字节流\",{\"1\":{\"105\":1}}],[\"要使用抽象类\",{\"1\":{\"218\":1}}],[\"要是由一种更简单的方式就好了\",{\"1\":{\"571\":1}}],[\"要是都不是这个类型还比什么\",{\"1\":{\"216\":1}}],[\"要是扩容之后比最大的大小还大\",{\"1\":{\"25\":1}}],[\"要是扩容之后的大小还没最小的大小大\",{\"1\":{\"25\":1}}],[\"要生成正常使用的\",{\"1\":{\"25\":1}}],[\"要注意传参问题\",{\"1\":{\"25\":1}}],[\"要给成员变量设定初始值\",{\"1\":{\"9\":1}}],[\"要在对象创建时进行处理\",{\"1\":{\"9\":1}}],[\"会根据eviction配置的策略进行清理\",{\"1\":{\"612\":1}}],[\"会话1在重复查询数据时\",{\"1\":{\"611\":1}}],[\"会话之间相互隔离\",{\"1\":{\"553\":1}}],[\"会发现得到的两个对象实际上就是同一个\",{\"1\":{\"611\":1}}],[\"会执行\",{\"1\":{\"539\":1}}],[\"会存在严重的sql注入攻击漏洞\",{\"1\":{\"533\":1}}],[\"会自动将查询的结果转换为我们所需要的实体类\",{\"1\":{\"569\":1}}],[\"会自动生成两个临时的表\",{\"1\":{\"509\":1}}],[\"会自动执行我们预先设定的内容\",{\"1\":{\"509\":1}}],[\"会自动转换为红黑树\",{\"1\":{\"60\":1}}],[\"会产生庞大的数据\",{\"1\":{\"495\":1}}],[\"会产生异常\",{\"1\":{\"186\":1}}],[\"会以别名显示此列\",{\"1\":{\"490\":1}}],[\"会抛出异常\",{\"1\":{\"449\":1}}],[\"会一直进行更新\",{\"1\":{\"427\":1}}],[\"会与环境一直交互下去\",{\"1\":{\"304\":1}}],[\"会隐式修改为\",{\"1\":{\"256\":1}}],[\"会限制其子类不允许其重写所对应的成员变量\",{\"1\":{\"217\":1}}],[\"会由jvm来调用一次此方法进行资源释放之类的操作\",{\"1\":{\"215\":1}}],[\"会报编译警告\",{\"1\":{\"204\":1}}],[\"会报编译错误\",{\"1\":{\"204\":1}}],[\"会报错\",{\"1\":{\"184\":1,\"238\":1}}],[\"会极大地降低后期维护性\",{\"1\":{\"192\":1}}],[\"会无法找到此构造方法\",{\"1\":{\"191\":1}}],[\"会更加合理\",{\"1\":{\"191\":1}}],[\"会更加合理一些\",{\"1\":{\"144\":1}}],[\"会出现以下报错\",{\"1\":{\"198\":1}}],[\"会出现illegalaccessexception异常\",{\"1\":{\"191\":1}}],[\"会出现instantiationexception异常\",{\"1\":{\"191\":1}}],[\"会出现异常\",{\"1\":{\"4\":1}}],[\"会提取一个类的信息生成class对象存放在内存中\",{\"1\":{\"181\":1}}],[\"会将我们当前的实体类对象的id修改为得到的id\",{\"1\":{\"625\":1}}],[\"会将其划分为n个簇\",{\"1\":{\"293\":1}}],[\"会将子类的也捕获\",{\"1\":{\"267\":1}}],[\"会将类的信息提取出来\",{\"1\":{\"180\":1}}],[\"会将指定key的值进行重新计算\",{\"1\":{\"64\":1}}],[\"会将指定\",{\"1\":{\"64\":1}}],[\"会调用wait\",{\"1\":{\"167\":1}}],[\"会唤醒刚才变成等待状态的线程\",{\"1\":{\"161\":1}}],[\"会获取到当前的锁\",{\"1\":{\"155\":1}}],[\"会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作\",{\"1\":{\"144\":1}}],[\"会从运行状态回到就绪\",{\"1\":{\"143\":1}}],[\"会创建很多线程\",{\"1\":{\"138\":1}}],[\"会被变为转义形式\",{\"1\":{\"533\":1}}],[\"会被回滚\",{\"1\":{\"510\":1}}],[\"会被唤醒\",{\"1\":{\"167\":1}}],[\"会被自动添加这个属性\",{\"1\":{\"132\":1}}],[\"会被排到最后一位\",{\"1\":{\"61\":1}}],[\"会在类刚加载的时候就分配\",{\"1\":{\"118\":1}}],[\"会使得线程的运行终止\",{\"1\":{\"143\":1}}],[\"会使得线程处于等待状态\",{\"1\":{\"143\":1}}],[\"会使得当前的读取位置回到\",{\"1\":{\"108\":1}}],[\"会使用默认的负载因子\",{\"1\":{\"58\":1}}],[\"会直接复制值给拷贝对象\",{\"1\":{\"220\":1}}],[\"会直接创建这个文件\",{\"1\":{\"92\":1}}],[\"会直接抛出异常\",{\"1\":{\"43\":1,\"79\":2}}],[\"会生成一个只有一个元素的list\",{\"1\":{\"79\":1}}],[\"会先记录每一步操作\",{\"1\":{\"71\":1}}],[\"会得到\",{\"1\":{\"60\":1}}],[\"会对底层哈希表数组进行扩容\",{\"1\":{\"59\":1}}],[\"会返回\",{\"1\":{\"64\":1}}],[\"会返回原本的被覆盖值\",{\"1\":{\"59\":1}}],[\"会返回null\",{\"1\":{\"43\":2}}],[\"会转变为效率更高的红黑树结构\",{\"1\":{\"58\":1}}],[\"会变成什么类型呢\",{\"1\":{\"15\":1}}],[\"会覆盖掉默认的那一个无参构造方法\",{\"1\":{\"9\":1}}],[\"在默认情况下如果我们需要修改日志打印等级\",{\"1\":{\"656\":1}}],[\"在默认状态下\",{\"1\":{\"472\":1}}],[\"在后续的学习中\",{\"1\":{\"636\":1}}],[\"在后面\",{\"1\":{\"616\":1}}],[\"在后面我们会学习mybatis框架\",{\"1\":{\"527\":1}}],[\"在后面我们会详细介绍preparedstatement的使用\",{\"1\":{\"518\":1}}],[\"在多次处理相同sql时会尽可能转换为一次执行\",{\"1\":{\"599\":1}}],[\"在之前的学习中\",{\"1\":{\"621\":1}}],[\"在之前jdbc讲解的时候\",{\"1\":{\"599\":1}}],[\"在之前关于使用\",{\"1\":{\"390\":1}}],[\"在关闭自动提交后\",{\"1\":{\"593\":1}}],[\"在此标签内部填写需要进行一对一映射的对象属性\",{\"1\":{\"578\":1}}],[\"在此情况下\",{\"1\":{\"299\":1}}],[\"在根目录下重新创建一个mapper文件夹\",{\"1\":{\"554\":1}}],[\"在查询语句返回结果后\",{\"1\":{\"554\":1}}],[\"在最上方还引入了一个叫做dtd\",{\"1\":{\"552\":1}}],[\"在最后自动调用其close\",{\"1\":{\"540\":1}}],[\"在项目根目录下新建名为mybatis\",{\"1\":{\"552\":1}}],[\"在开始介绍mybatis之前\",{\"1\":{\"545\":1}}],[\"在前面jdbc的学习中\",{\"1\":{\"544\":1}}],[\"在以往编写项目时\",{\"1\":{\"538\":1}}],[\"在刚启动时\",{\"1\":{\"517\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"510\":1}}],[\"在update操作时\",{\"1\":{\"509\":1}}],[\"在delete操作时\",{\"1\":{\"509\":1}}],[\"在select\",{\"1\":{\"509\":1}}],[\"在sleep代码中可以发现\",{\"1\":{\"143\":1}}],[\"在某种条件下会自动触发\",{\"1\":{\"509\":1}}],[\"在数据量变得非常庞大时\",{\"1\":{\"508\":1}}],[\"在数组的对象头中有一个\",{\"1\":{\"25\":1}}],[\"在创建sqlsession的时候不填写参数默认使用的就是事务模式\",{\"1\":{\"593\":1}}],[\"在创建表之前\",{\"1\":{\"478\":1}}],[\"在创建了对象之后\",{\"1\":{\"4\":1}}],[\"在主键列中\",{\"1\":{\"475\":1}}],[\"在满足第二范式的情况下\",{\"1\":{\"466\":1}}],[\"在得到我们响应的数据后会立即关闭tcp连接\",{\"1\":{\"455\":1}}],[\"在得到field之后\",{\"1\":{\"193\":1}}],[\"在收到响应的数据后会立即关闭tcp连接\",{\"1\":{\"455\":1}}],[\"在收集到了足够多的\",{\"1\":{\"367\":1}}],[\"在状态s采用动作a\",{\"1\":{\"438\":1}}],[\"在该策略下的所有\",{\"1\":{\"433\":1}}],[\"在该文中考虑的是网页浏览应用传输情况\",{\"1\":{\"295\":1}}],[\"在该文中\",{\"1\":{\"295\":1}}],[\"在原文是\",{\"1\":{\"429\":1}}],[\"在训练求解梯度时\",{\"1\":{\"427\":1}}],[\"在每一次迭代时\",{\"1\":{\"427\":1}}],[\"在将\",{\"1\":{\"427\":1}}],[\"在计算\",{\"1\":{\"427\":1}}],[\"在通过经验来更新这个策略\",{\"1\":{\"407\":1}}],[\"在这里\",{\"1\":{\"372\":1}}],[\"在这种情况下\",{\"1\":{\"186\":1}}],[\"在求解\",{\"1\":{\"356\":1}}],[\"在策略更新上\",{\"1\":{\"355\":1}}],[\"在策略梯度算法中引入一个\",{\"1\":{\"311\":1}}],[\"在当前状态s下\",{\"1\":{\"333\":1}}],[\"在当前状态s下采取动作\",{\"1\":{\"333\":1}}],[\"在当前包以外的其他包中无法访问\",{\"1\":{\"121\":1}}],[\"在policy是确定的情况下\",{\"1\":{\"305\":1}}],[\"在执行一个动作后获得的一个常数\",{\"1\":{\"304\":1}}],[\"在执行完毕后会自动释放这把锁\",{\"1\":{\"155\":1}}],[\"在本文中\",{\"1\":{\"299\":1}}],[\"在本文中不考虑用户移动到其他集群的情况\",{\"1\":{\"299\":1}}],[\"在设计无人机的移动之前\",{\"1\":{\"299\":1}}],[\"在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为\",{\"1\":{\"294\":1}}],[\"在时间t\",{\"1\":{\"294\":1}}],[\"在任意时刻t\",{\"1\":{\"293\":1}}],[\"在初始化的时候是设为相同的\",{\"1\":{\"427\":1}}],[\"在初始化时会调用一次\",{\"1\":{\"60\":1}}],[\"在初始时间假设用户处于静止下不断调整\",{\"1\":{\"290\":1}}],[\"在编写sql时\",{\"1\":{\"601\":1}}],[\"在编写代码的时候就能明确泛型的类型\",{\"1\":{\"281\":1}}],[\"在编译阶段就需要进行处理\",{\"1\":{\"264\":1}}],[\"在编译阶段无法感知代码是否会出现问题\",{\"1\":{\"264\":1}}],[\"在new的时候\",{\"1\":{\"255\":1}}],[\"在内部类中使用this关键字\",{\"1\":{\"251\":1}}],[\"在成员内部类中\",{\"1\":{\"251\":1}}],[\"在成员变量初始化之后执行\",{\"1\":{\"9\":1}}],[\"在c中就是一个字符数组\",{\"1\":{\"243\":1}}],[\"在collection接口中重复定义了一次\",{\"1\":{\"36\":1}}],[\"在运行时动态创建\",{\"1\":{\"235\":1}}],[\"在运行时同样会进行类型检查\",{\"1\":{\"80\":1}}],[\"在修改后\",{\"1\":{\"216\":1}}],[\"在修改访问权限之后\",{\"1\":{\"191\":1}}],[\"在回收之前\",{\"1\":{\"215\":1}}],[\"在接触到spring和springboot等大型框架后\",{\"1\":{\"208\":1}}],[\"在上述中有写到\",{\"1\":{\"206\":1}}],[\"在类加载时就进行创建\",{\"1\":{\"558\":1}}],[\"在类加载过程的同时\",{\"1\":{\"181\":1}}],[\"在类\",{\"1\":{\"198\":1}}],[\"在进行反射操作时\",{\"1\":{\"193\":1}}],[\"在没有了解别人代码的整个过程就强行越权访问\",{\"1\":{\"192\":1}}],[\"在一个对象从构造到方法调用\",{\"1\":{\"192\":1}}],[\"在一些jdk内部的源码中\",{\"1\":{\"133\":1}}],[\"在加载过程中\",{\"1\":{\"180\":1}}],[\"在arrays数组工具类中\",{\"1\":{\"173\":1}}],[\"在集合跟接口collection中提供了一个spliterator\",{\"1\":{\"173\":1}}],[\"在守护线程中产生的新线程也是守护的\",{\"1\":{\"172\":1}}],[\"在构造时自动启动\",{\"1\":{\"167\":1}}],[\"在指定时间内\",{\"1\":{\"161\":1}}],[\"在指定位置上插入元素\",{\"1\":{\"24\":1}}],[\"在使用opensession时直接配置executortype为batch即可\",{\"1\":{\"599\":1}}],[\"在使用之前\",{\"1\":{\"532\":1}}],[\"在使用时同样需要跟上<>并在其中填写明确要使用的类型\",{\"1\":{\"281\":1}}],[\"在使用完成一个流之后\",{\"1\":{\"90\":1}}],[\"在使线程暂停的同时\",{\"1\":{\"156\":1}}],[\"在写回主内存时就会发生冲突\",{\"1\":{\"154\":1}}],[\"在继续当前内容\",{\"1\":{\"148\":1}}],[\"在i==10时\",{\"1\":{\"148\":1}}],[\"在让位之后\",{\"1\":{\"147\":1}}],[\"在jdk9之后\",{\"1\":{\"191\":1}}],[\"在jdk1\",{\"1\":{\"90\":1}}],[\"在java程序启动时\",{\"1\":{\"180\":1}}],[\"在java中\",{\"1\":{\"138\":1}}],[\"在早期的计算机中\",{\"1\":{\"138\":1}}],[\"在序列化时\",{\"1\":{\"132\":1}}],[\"在我们后续的操作中\",{\"1\":{\"132\":1}}],[\"在我们自己定义一个构造方法之后\",{\"1\":{\"9\":1}}],[\"在不同包下的类\",{\"1\":{\"120\":1}}],[\"在放入包中\",{\"1\":{\"120\":1}}],[\"在静态方法中\",{\"1\":{\"117\":1}}],[\"在下次读取时\",{\"1\":{\"103\":1}}],[\"在重写\",{\"1\":{\"84\":1}}],[\"在实际情况中\",{\"1\":{\"312\":1}}],[\"在实际应用中\",{\"1\":{\"294\":1}}],[\"在实际运行时\",{\"1\":{\"80\":1}}],[\"在实现接口或是继承父类时\",{\"1\":{\"282\":1}}],[\"在实现\",{\"1\":{\"48\":1}}],[\"在外面花钱请别人帮你写公司的业务\",{\"1\":{\"67\":1}}],[\"在插入键值对时\",{\"1\":{\"61\":1}}],[\"在红黑树中插入新的结点\",{\"1\":{\"59\":1}}],[\"在队尾进行移除操作\",{\"1\":{\"44\":1}}],[\"在队尾进行插入操作\",{\"1\":{\"44\":1}}],[\"在队首进行移除操作\",{\"1\":{\"44\":1}}],[\"在队首进行插入操作\",{\"1\":{\"44\":1}}],[\"在双端队列中\",{\"1\":{\"44\":1}}],[\"在遍历过程中\",{\"1\":{\"37\":1}}],[\"在什么使用使用arraylist和linkedlist\",{\"1\":{\"25\":1}}],[\"在\",{\"1\":{\"25\":2,\"35\":1,\"48\":1,\"56\":1,\"217\":1,\"255\":1,\"266\":1,\"310\":1,\"353\":2,\"371\":1,\"423\":1,\"427\":1}}],[\"在list接口中\",{\"1\":{\"24\":1}}],[\"在返回值类型前添加<>并填写泛型变量表示这个是一个泛型方法\",{\"1\":{\"14\":1}}],[\"在赋值之前看看是否有初始值\",{\"1\":{\"9\":1}}],[\"男\",{\"1\":{\"9\":2,\"216\":4,\"219\":1,\"220\":1,\"221\":1,\"524\":1}}],[\"只读的缓存会给所有调用者返回相同的缓存对象\",{\"1\":{\"612\":1}}],[\"只读\",{\"1\":{\"612\":1}}],[\"只读集合\",{\"1\":{\"79\":1}}],[\"只启用了本地的会话缓存\",{\"1\":{\"611\":1}}],[\"只需添加一个无参构造或是全参构造即可\",{\"1\":{\"569\":1}}],[\"只需要添加一个\",{\"1\":{\"678\":1}}],[\"只需要添加几个注解\",{\"1\":{\"538\":1}}],[\"只需要将one或是many参数进行填写即可\",{\"1\":{\"629\":1}}],[\"只需要将原本的流作为构造参数传入bufferedinputstream即可\",{\"1\":{\"105\":1}}],[\"只需要修改usecache属性即可\",{\"1\":{\"614\":1}}],[\"只需要保证\",{\"1\":{\"311\":1}}],[\"只需要用\",{\"1\":{\"219\":1}}],[\"只需要把类文件传递即可\",{\"1\":{\"199\":1}}],[\"只需要在类名前面添加包名就行了\",{\"1\":{\"120\":1}}],[\"只需要在泛型变量的后面添加extends关键字即可指定上界\",{\"1\":{\"15\":1}}],[\"只需要存储\",{\"1\":{\"67\":2}}],[\"只需要各个集合类根据自己的情况进行对应实现就行了\",{\"1\":{\"31\":1}}],[\"只需要\",{\"1\":{\"5\":1}}],[\"只取前n个结果\",{\"1\":{\"494\":1}}],[\"只查询不重复的值\",{\"1\":{\"490\":1}}],[\"只删除指定的数据\",{\"1\":{\"484\":1}}],[\"只给出了梯度的公式\",{\"1\":{\"440\":1}}],[\"只添加一个元素\",{\"1\":{\"193\":1}}],[\"只适用于默认无参构造\",{\"1\":{\"191\":1}}],[\"只适合打打杂\",{\"1\":{\"172\":1}}],[\"只能做调整\",{\"1\":{\"611\":1}}],[\"只能由触发器使用\",{\"1\":{\"509\":1}}],[\"只能对其进行继承\",{\"1\":{\"255\":1}}],[\"只能表示内部类对象\",{\"1\":{\"251\":1}}],[\"只能重新创建\",{\"1\":{\"236\":1,\"243\":1}}],[\"只能\",{\"1\":{\"229\":1}}],[\"只能内部使用\",{\"1\":{\"221\":1}}],[\"只能作为一个附属功能加在主体上\",{\"1\":{\"219\":1}}],[\"只能在构造函数进行赋值\",{\"1\":{\"217\":1}}],[\"只能得到\",{\"1\":{\"216\":1,\"218\":1}}],[\"只能使用这种嵌套查询来完成复杂查询操作\",{\"1\":{\"629\":1}}],[\"只能使用\",{\"1\":{\"256\":1}}],[\"只能使用匿名内部类\",{\"1\":{\"166\":1}}],[\"只能使用获取内容相关的方法\",{\"1\":{\"25\":1}}],[\"只能被类本身和同包中的其他类访问\",{\"1\":{\"121\":1}}],[\"只保留mapper相关的接口\",{\"1\":{\"621\":1}}],[\"只保留方法的定义\",{\"1\":{\"218\":1}}],[\"只保留之后的1个字符\",{\"1\":{\"108\":2}}],[\"只保留小于0的数字\",{\"1\":{\"71\":1}}],[\"只保留当前集合中在给定集合中出现的元素\",{\"1\":{\"23\":1}}],[\"只获取前10个数字\",{\"1\":{\"71\":1}}],[\"只放行前两个元素\",{\"1\":{\"71\":1}}],[\"只是反过来而已\",{\"1\":{\"497\":1}}],[\"只是反向操作\",{\"1\":{\"110\":1}}],[\"只是连接对象变成自己和自己了\",{\"1\":{\"496\":1}}],[\"只是进行了一步求解\",{\"1\":{\"356\":1}}],[\"只是求解各状态的\",{\"1\":{\"341\":1}}],[\"只是初始化了内部类的\",{\"1\":{\"254\":1}}],[\"只是数组的地址不准修改\",{\"1\":{\"239\":1}}],[\"只是语法上为了简单\",{\"1\":{\"227\":1}}],[\"只是一定程度上\",{\"1\":{\"199\":1}}],[\"只是一个表壳\",{\"1\":{\"67\":1}}],[\"只是利用反射机制实现了方法的调用\",{\"1\":{\"192\":1}}],[\"只是编程不可见\",{\"1\":{\"184\":1}}],[\"只是可以使用包装类来表示\",{\"1\":{\"183\":1}}],[\"只是不用我们去写\",{\"1\":{\"9\":1}}],[\"只有commit了\",{\"1\":{\"612\":1}}],[\"只有提交之后\",{\"1\":{\"534\":1}}],[\"只有innodb引擎支持事务\",{\"1\":{\"510\":1}}],[\"只有sysadmin\",{\"1\":{\"472\":1}}],[\"只有当样本全部收集完才能估计\",{\"1\":{\"379\":1}}],[\"只有当所有\",{\"1\":{\"367\":1}}],[\"只有当所有东西都是确定性的\",{\"1\":{\"326\":1}}],[\"只有当对象作为锁时\",{\"1\":{\"161\":1}}],[\"只有抽象类中的抽象方法\",{\"1\":{\"219\":1}}],[\"只有是当前类型的对象\",{\"1\":{\"216\":1}}],[\"只有bootstarpclassloader都没有加载的类\",{\"1\":{\"198\":1}}],[\"只有在运行的时候才知道会不会出错\",{\"1\":{\"264\":1}}],[\"只有在你使用到外部类的静态变量或方法后\",{\"1\":{\"254\":1}}],[\"只有在类不在同一个包下时才需要进行导入\",{\"1\":{\"120\":1}}],[\"只有在不存在相同键的键值对时才会存放\",{\"1\":{\"57\":1}}],[\"只有同时匹配时才移除\",{\"1\":{\"66\":1}}],[\"只有键和值都匹配时\",{\"1\":{\"66\":1}}],[\"只有可能是前面出现了相同键的情况\",{\"1\":{\"59\":1}}],[\"只会返回两个表满足条件的交集部分\",{\"1\":{\"497\":1}}],[\"只会从笛卡尔积的结果中得到满足条件的数据\",{\"1\":{\"495\":1}}],[\"只会复制对象的地址\",{\"1\":{\"220\":1}}],[\"只会存放在线程自己的工作空间中\",{\"1\":{\"162\":1}}],[\"只会删除排在前面的第一个元素\",{\"1\":{\"25\":1}}],[\"只会调用equals方法进行判断是否为指定元素\",{\"1\":{\"25\":1}}],[\"只要是使用这个mapper的会话\",{\"1\":{\"612\":1}}],[\"只要是实现这个接口的类\",{\"1\":{\"219\":1}}],[\"只要重写的内容中不会抛出对应的异常我们可以直接省去\",{\"1\":{\"266\":1}}],[\"只要一个类的父类或者自身有对应方法\",{\"1\":{\"219\":1}}],[\"只要我们绕过这个阶段\",{\"1\":{\"80\":1}}],[\"只要判断成功\",{\"1\":{\"25\":1}}],[\"只要\",{\"1\":{\"24\":1}}],[\"只不过格式稍微有点炸裂\",{\"1\":{\"679\":1}}],[\"只不过由于idea不支持这种语法的识别\",{\"1\":{\"630\":1}}],[\"只不过使用起来和我们之前jdbc中的resultset比较类似\",{\"1\":{\"564\":1}}],[\"只不过这种操作实际上是治标不治本的\",{\"1\":{\"616\":1}}],[\"只不过这种方式查询的话\",{\"1\":{\"571\":1}}],[\"只不过这种方式在大部分请情况下还是用的比较少\",{\"1\":{\"564\":1}}],[\"只不过这和我们之前说的map不太一样\",{\"1\":{\"564\":1}}],[\"只不过这个锁不用你去给\",{\"1\":{\"155\":1}}],[\"只不过我们此时需要遍历所有的\",{\"1\":{\"364\":1}}],[\"只不过根据区域划分\",{\"1\":{\"298\":1}}],[\"只不过默认情况下没有开启断言\",{\"1\":{\"268\":1}}],[\"只不过还能更简单\",{\"1\":{\"258\":1}}],[\"只不过意义不大\",{\"1\":{\"255\":1}}],[\"只不过它比较特殊\",{\"1\":{\"244\":1}}],[\"只不过它的用法比较特殊\",{\"1\":{\"203\":1}}],[\"只不过它只是代表这个文件\",{\"1\":{\"98\":1}}],[\"只不过它是一个双向链表\",{\"1\":{\"25\":1}}],[\"只不过它是采用的链式实现\",{\"1\":{\"25\":1}}],[\"只不过现在的方向变为我们向文件里写入内容\",{\"1\":{\"92\":1}}],[\"只不过多了一些特殊的东西\",{\"1\":{\"58\":1}}],[\"只不过hashmap中没有设计头结点\",{\"1\":{\"58\":1}}],[\"只不过对这些方法有更加特殊的定义\",{\"1\":{\"47\":1}}],[\"只不过\",{\"1\":{\"47\":1,\"571\":1}}],[\"只不过需要注意的是\",{\"1\":{\"46\":1}}],[\"只不过list也是一样的\",{\"1\":{\"43\":1}}],[\"只不过linkedlist不仅可以当做list来使用\",{\"1\":{\"25\":1}}],[\"只不过此时编译器会给出警告\",{\"1\":{\"16\":1}}],[\"只不过下界仅适用于通配符\",{\"1\":{\"15\":1}}],[\"默认日志级别\",{\"1\":{\"638\":1}}],[\"默认获取第一个构造方法\",{\"1\":{\"527\":1}}],[\"默认使用的就是任意ip地址\",{\"1\":{\"500\":1}}],[\"默认为升序\",{\"1\":{\"492\":1}}],[\"默认是以xml格式进行写入的\",{\"1\":{\"648\":1}}],[\"默认是restrict\",{\"1\":{\"479\":1}}],[\"默认是接收控制台输入\",{\"1\":{\"128\":1}}],[\"默认并不是你创建的数据库\",{\"1\":{\"478\":1}}],[\"默认值仅在插入数据时使用\",{\"1\":{\"475\":1}}],[\"默认值为false\",{\"1\":{\"4\":1}}],[\"默认会让整个程序终止并打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"默认会交给\",{\"1\":{\"267\":1}}],[\"默认会返回\",{\"1\":{\"57\":1}}],[\"默认继承自\",{\"1\":{\"264\":1}}],[\"默认private\",{\"1\":{\"221\":1}}],[\"默认实现是直接用等号判断\",{\"1\":{\"215\":1}}],[\"默认只有一个属性时\",{\"1\":{\"207\":1}}],[\"默认\",{\"1\":{\"121\":2,\"205\":1,\"475\":1}}],[\"默认从小到大排序\",{\"1\":{\"71\":1}}],[\"默认情况按照自然顺序\",{\"1\":{\"46\":1}}],[\"默认情况下一个mapper中所有的操作都会使用二级缓存\",{\"1\":{\"614\":1}}],[\"默认情况下如果不配置此项则不会进行定时清理\",{\"1\":{\"612\":1}}],[\"默认情况下别名就是类的名称\",{\"1\":{\"560\":1}}],[\"默认情况下直接运行什么都没有\",{\"1\":{\"242\":1}}],[\"默认情况下格式为\",{\"1\":{\"215\":1}}],[\"默认情况下\",{\"1\":{\"121\":1,\"180\":1,\"611\":1,\"649\":1}}],[\"默认情况下包名是可以省略的\",{\"1\":{\"120\":1}}],[\"默认情况下阈值也是0\",{\"1\":{\"60\":1}}],[\"默认情况下会认为传入的是int类型值\",{\"1\":{\"25\":1}}],[\"默认情况下每个类都会自带一个没有任何参数的无参构造方法\",{\"1\":{\"9\":1}}],[\"默认都是尾插\",{\"1\":{\"43\":1}}],[\"默认有一个指向集合中第一个元素的指针\",{\"1\":{\"31\":1}}],[\"默认的情况下\",{\"1\":{\"121\":1}}],[\"默认的列表最大长度为integer\",{\"1\":{\"25\":1}}],[\"默认的数组容量\",{\"1\":{\"25\":1}}],[\"默认就是原始类型\",{\"1\":{\"16\":1}}],[\"默认就是object\",{\"1\":{\"16\":1}}],[\"并使用association标签的select属性来指定关联查询操作\",{\"1\":{\"579\":1}}],[\"并填写以下内容\",{\"1\":{\"552\":1,\"554\":1}}],[\"并得到结果集\",{\"1\":{\"516\":1}}],[\"并在数据库中添加用于存放数据的表\",{\"1\":{\"462\":1}}],[\"并在控制台打印栈追踪信息\",{\"1\":{\"267\":1}}],[\"并获得奖励rt​的这一过程可以用条件转移概率p\",{\"1\":{\"298\":1}}],[\"并与传统的基于遗传的学习算法进行对比\",{\"1\":{\"290\":1}}],[\"并直接创建实例对象\",{\"1\":{\"255\":1}}],[\"并没有初始化内部类\",{\"1\":{\"254\":1}}],[\"并没有考虑到多线程运行的情况\",{\"1\":{\"173\":1}}],[\"并返回一个新的子串对象\",{\"1\":{\"244\":1}}],[\"并根据实际需求扩展出新的行为\",{\"1\":{\"212\":1}}],[\"并提供对外访问的接口\",{\"1\":{\"212\":1}}],[\"并非只是一个单一的轨迹\",{\"1\":{\"304\":1}}],[\"并非java定义\",{\"1\":{\"183\":1}}],[\"并非是所对应的对象本身\",{\"1\":{\"4\":1}}],[\"并行流\",{\"1\":{\"173\":2}}],[\"并打印出了相关线程的栈追踪信息\",{\"1\":{\"156\":1}}],[\"并发会用到\",{\"1\":{\"107\":1}}],[\"并且在mybatis每个操作都配置flushcache为true来保证刷新\",{\"1\":{\"616\":1}}],[\"并且都开启了缓存\",{\"1\":{\"616\":1}}],[\"并且sid并没有发生改变\",{\"1\":{\"616\":1}}],[\"并且使用\",{\"1\":{\"533\":1}}],[\"并且可以反复使用\",{\"1\":{\"510\":1}}],[\"并且可以在管道的节点上进行处理\",{\"1\":{\"71\":1}}],[\"并且内层查询的from子句中涉及的表也是导出该视图的基本表\",{\"1\":{\"507\":1}}],[\"并且不能为空\",{\"1\":{\"475\":1}}],[\"并且需要使用\",{\"1\":{\"472\":1}}],[\"并且每个学生的所有属性都依赖于学号\",{\"1\":{\"465\":1}}],[\"并且如果按照这样一个策略\",{\"1\":{\"371\":1}}],[\"并且与状态\",{\"1\":{\"333\":1}}],[\"并且接口没有继承数量限制\",{\"1\":{\"219\":1}}],[\"并且默认在类中实现的权限是\",{\"1\":{\"219\":1}}],[\"并且也导入了我们自己定义的string类\",{\"1\":{\"120\":1}}],[\"并且同样支持try\",{\"1\":{\"92\":1}}],[\"并且方法名称与类名相同\",{\"1\":{\"9\":2}}],[\"并将其绑定到一个接口上\",{\"1\":{\"621\":1}}],[\"并将其保留到运行时\",{\"1\":{\"206\":1}}],[\"并将字符串转换为字符\",{\"1\":{\"127\":1}}],[\"并将下一个元素作为待遍历元素\",{\"1\":{\"32\":1}}],[\"并将元素替换为处理之后的结果\",{\"1\":{\"24\":1}}],[\"并不编写方法的主体\",{\"1\":{\"218\":1}}],[\"并不一定真实的数据量就是这么多\",{\"1\":{\"91\":1}}],[\"并不会去释放任何锁资源\",{\"1\":{\"156\":1}}],[\"并不会在一开始就去加载它\",{\"1\":{\"118\":1}}],[\"并不会真的进行类型检查\",{\"1\":{\"80\":1}}],[\"并不会真的去检查对应类型\",{\"1\":{\"16\":1}}],[\"并不会维持插入的顺序\",{\"1\":{\"61\":1}}],[\"并不是为了一定要去使用它\",{\"1\":{\"544\":1}}],[\"并不是真实存在的\",{\"1\":{\"507\":1}}],[\"并不是一直进行更新\",{\"1\":{\"427\":1}}],[\"并不是说只有抽象类和接口才可以像这样创建匿名内部类\",{\"1\":{\"255\":1}}],[\"并不是说一定优先级越高的线程越先执行\",{\"1\":{\"145\":1}}],[\"并不是基本数据类型\",{\"1\":{\"235\":1}}],[\"并不是包装类型\",{\"1\":{\"183\":1}}],[\"并不是所有的类都会在一开始加载\",{\"1\":{\"180\":1}}],[\"并不是我们实际list中的顺序\",{\"1\":{\"173\":1}}],[\"并不是将另一个线程和当前线程合并\",{\"1\":{\"148\":1}}],[\"并不是创建一个线程执行\",{\"1\":{\"141\":1}}],[\"并不是写入的字符串\",{\"1\":{\"129\":1}}],[\"并不是\",{\"1\":{\"55\":1}}],[\"并不是在构造方法之后\",{\"1\":{\"9\":1}}],[\"来继承formatter\",{\"1\":{\"672\":1}}],[\"来一次性提交之前是所有批处理操作\",{\"1\":{\"599\":1}}],[\"来强制提交\",{\"1\":{\"593\":1}}],[\"来有效地防止sql注入问题\",{\"1\":{\"559\":1}}],[\"来填入我们给定的属性\",{\"1\":{\"559\":1}}],[\"来手动回滚之前的全部操作\",{\"1\":{\"534\":1}}],[\"来提交事务的话\",{\"1\":{\"534\":1}}],[\"来提升当前策略\",{\"1\":{\"351\":1}}],[\"来将我们输入的内容进行包裹\",{\"1\":{\"533\":1}}],[\"来获取每一列的数据\",{\"1\":{\"525\":1}}],[\"来获取\",{\"1\":{\"519\":1}}],[\"来获取类的信息和操作类\",{\"1\":{\"181\":1}}],[\"来执行任意的sql语句\",{\"1\":{\"519\":1}}],[\"来分析我们设定的驱动是否可以连接\",{\"1\":{\"517\":1}}],[\"来加载驱动类\",{\"1\":{\"516\":1}}],[\"来限制用户登录的登录ip地址\",{\"1\":{\"500\":1}}],[\"来编写注释内容\",{\"1\":{\"472\":1}}],[\"来连接我们本地端口的服务器\",{\"1\":{\"455\":1}}],[\"来定义最优的策略\",{\"1\":{\"433\":1}}],[\"来更新参数值\",{\"1\":{\"427\":1}}],[\"来近似\",{\"1\":{\"422\":1,\"423\":1}}],[\"来进行转义\",{\"1\":{\"564\":1}}],[\"来进行操作保证安全性\",{\"1\":{\"559\":1}}],[\"来进行数据库的链接\",{\"1\":{\"517\":1}}],[\"来进行多行注释\",{\"1\":{\"472\":1}}],[\"来进行求解\",{\"1\":{\"362\":1}}],[\"来进行迭代\",{\"1\":{\"298\":1}}],[\"来保证这个梯度的方差最小即可\",{\"1\":{\"311\":1}}],[\"来保证数据正确写入到硬盘文件中\",{\"1\":{\"92\":1}}],[\"来表示\",{\"1\":{\"298\":1}}],[\"来最大化mos总和\",{\"1\":{\"298\":1}}],[\"来考虑无人机的机动性\",{\"1\":{\"289\":1}}],[\"来作为结果\",{\"1\":{\"280\":1}}],[\"来处理\",{\"1\":{\"267\":1}}],[\"来快速创建不解析区域\",{\"1\":{\"546\":1}}],[\"来快速添加注释文本\",{\"1\":{\"545\":1}}],[\"来快速获取我们标记的注解\",{\"1\":{\"208\":1}}],[\"来快速编写代码\",{\"1\":{\"71\":1}}],[\"来调用已经获取到的方法\",{\"1\":{\"192\":1}}],[\"来创建对象实例\",{\"1\":{\"191\":1}}],[\"来创建工作内存中的变量\",{\"1\":{\"162\":1}}],[\"来实例化对象\",{\"1\":{\"191\":1}}],[\"来实现\",{\"1\":{\"218\":1}}],[\"来实现多个进程的同时运行\",{\"1\":{\"138\":1}}],[\"来实现更加方便的操作\",{\"1\":{\"126\":1}}],[\"来模拟一个餐厅的2个厨师和3个顾客\",{\"1\":{\"174\":1}}],[\"来支持对象类型的io\",{\"1\":{\"130\":1}}],[\"来做事\",{\"1\":{\"67\":1}}],[\"来自定义排序规则\",{\"1\":{\"14\":1}}],[\"来完成\",{\"1\":{\"9\":1}}],[\"来明确表示当前类的示例对象本身\",{\"1\":{\"7\":1}}],[\"btree\",{\"1\":{\"508\":1}}],[\"by子句\",{\"1\":{\"507\":1}}],[\"by来对查询结果进行分组\",{\"1\":{\"494\":1}}],[\"by来将查询结果进行排序\",{\"1\":{\"492\":1}}],[\"by\",{\"1\":{\"492\":2,\"494\":2,\"500\":1}}],[\"byte类型的包装类也有类似的机制\",{\"1\":{\"227\":1}}],[\"bytes\",{\"1\":{\"91\":4,\"94\":3,\"199\":3,\"454\":6}}],[\"byte\",{\"1\":{\"91\":3,\"94\":2,\"107\":1,\"199\":3,\"227\":2,\"454\":4}}],[\"bcnf作为第三范式的补充\",{\"1\":{\"467\":1}}],[\"bcnf\",{\"0\":{\"467\":1}}],[\"bcnf则是对主键的选取进行唯一确定\",{\"1\":{\"463\":1}}],[\"bgd\",{\"0\":{\"391\":1},\"1\":{\"386\":1}}],[\"br\",{\"1\":{\"455\":1}}],[\"brand\",{\"1\":{\"455\":1}}],[\"broad\",{\"1\":{\"377\":1}}],[\"break\",{\"1\":{\"59\":2,\"144\":1,\"167\":1,\"455\":1}}],[\"batch\",{\"1\":{\"386\":1,\"427\":2,\"599\":1}}],[\"base\",{\"1\":{\"515\":1}}],[\"based\",{\"0\":{\"373\":1},\"1\":{\"362\":1,\"367\":1,\"432\":2,\"441\":1}}],[\"baseline\",{\"0\":{\"311\":1,\"312\":1},\"1\":{\"310\":1,\"311\":2,\"312\":1}}],[\"basic\",{\"0\":{\"361\":1},\"1\":{\"365\":1,\"366\":1,\"373\":1}}],[\"baidu\",{\"1\":{\"120\":3,\"580\":2}}],[\"bkn​​=bn​\",{\"1\":{\"294\":1}}],[\"b2​\",{\"1\":{\"294\":1}}],[\"b2​pnlos​=1−plos​\",{\"1\":{\"294\":1}}],[\"b1​\",{\"1\":{\"294\":2}}],[\"boe\",{\"0\":{\"339\":1},\"1\":{\"337\":1,\"343\":1}}],[\"bob\",{\"1\":{\"246\":2,\"285\":1}}],[\"books\",{\"1\":{\"581\":2,\"582\":1}}],[\"book\",{\"1\":{\"581\":4,\"582\":3}}],[\"bootstrapping\",{\"1\":{\"330\":1}}],[\"bootstarpclassloader用于加载jdk提供的类\",{\"1\":{\"198\":1}}],[\"boolean\",{\"1\":{\"23\":11,\"24\":1,\"25\":2,\"32\":1,\"36\":1,\"37\":2,\"43\":2,\"44\":4,\"47\":9,\"56\":4,\"59\":2,\"67\":1,\"84\":2,\"167\":1,\"215\":1,\"216\":1,\"227\":2,\"558\":1}}],[\"buildgetuserbyid\",{\"1\":{\"630\":2}}],[\"build\",{\"1\":{\"552\":1,\"554\":1,\"558\":1,\"632\":1}}],[\"builders\",{\"1\":{\"630\":1}}],[\"builder来快速生成建造者模式\",{\"1\":{\"540\":1}}],[\"builder\",{\"1\":{\"245\":8,\"540\":2,\"547\":2,\"676\":8}}],[\"budgetpositive\",{\"1\":{\"476\":1}}],[\"budget\",{\"1\":{\"476\":2}}],[\"bufupdater\",{\"1\":{\"107\":1}}],[\"buf\",{\"1\":{\"107\":2}}],[\"bufferedwriter\",{\"1\":{\"111\":1,\"113\":2}}],[\"bufferedreader\",{\"1\":{\"111\":1,\"112\":6,\"126\":1,\"448\":4}}],[\"bufferedoutputstream\",{\"1\":{\"110\":2}}],[\"bufferedinputstream\",{\"1\":{\"105\":4,\"108\":18,\"109\":3}}],[\"buffer\",{\"0\":{\"428\":1},\"1\":{\"107\":3,\"427\":1}}],[\"bid\",{\"1\":{\"581\":3}}],[\"bit\",{\"1\":{\"295\":2}}],[\"bigint用于存储大型整数\",{\"1\":{\"474\":1}}],[\"biginteger\",{\"1\":{\"229\":10}}],[\"bigdecimal\",{\"1\":{\"229\":6}}],[\"bindingexception\",{\"1\":{\"571\":1}}],[\"binding\",{\"1\":{\"571\":1}}],[\"binarysearch\",{\"1\":{\"77\":1}}],[\"bincount\",{\"1\":{\"59\":2}}],[\"been\",{\"1\":{\"517\":1}}],[\"begin\",{\"1\":{\"510\":1}}],[\"behavior\",{\"1\":{\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"420\":1}}],[\"behave\",{\"1\":{\"167\":1}}],[\"bellman\",{\"0\":{\"327\":1,\"330\":1,\"331\":1,\"339\":1},\"1\":{\"322\":1,\"331\":2,\"332\":1,\"334\":2,\"337\":1,\"351\":1,\"353\":2,\"355\":1,\"356\":1,\"362\":1,\"398\":3,\"400\":1,\"404\":1}}],[\"become\",{\"1\":{\"167\":1}}],[\"be\",{\"1\":{\"139\":1,\"289\":1,\"326\":1,\"517\":2}}],[\"bean\",{\"1\":{\"138\":3}}],[\"before|after\",{\"1\":{\"509\":1}}],[\"before\",{\"1\":{\"61\":1}}],[\"b是当前要计算的参数\",{\"1\":{\"71\":1}}],[\"bbb\",{\"1\":{\"14\":1,\"43\":1,\"44\":1,\"245\":1,\"285\":1}}],[\"b\",{\"1\":{\"8\":4,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"46\":2,\"50\":2,\"64\":2,\"71\":5,\"199\":3,\"227\":6,\"241\":1,\"251\":2,\"258\":5,\"266\":3,\"281\":4,\"282\":1,\"285\":1,\"311\":1,\"534\":3}}],[\"也符合逻辑\",{\"1\":{\"599\":1}}],[\"也放到后面来详细进行讲解\",{\"1\":{\"518\":1}}],[\"也称为\",{\"1\":{\"325\":1}}],[\"也支持向下转型\",{\"1\":{\"238\":1}}],[\"也支持键值同时匹配\",{\"1\":{\"66\":1}}],[\"也只能表示64bit的数据\",{\"1\":{\"229\":1}}],[\"也只有这一个静态的变量或方法\",{\"1\":{\"117\":1}}],[\"也会在数据更新时产生额外建立索引的开销\",{\"1\":{\"508\":1}}],[\"也会返回左边表中的全部数据\",{\"1\":{\"497\":1}}],[\"也会进行拷贝\",{\"1\":{\"220\":1}}],[\"也会等待获取cpu资源\",{\"1\":{\"142\":1}}],[\"也就自然找不到main方法了\",{\"1\":{\"198\":1}}],[\"也就是让所有的mybatis都使用同一个缓存进行数据存取\",{\"1\":{\"616\":1}}],[\"也就是每一个sqlsession都有有一个对应的缓存\",{\"1\":{\"611\":1}}],[\"也就是每一项数据和另一张表的每一项数据都结合一次\",{\"1\":{\"495\":1}}],[\"也就是一级缓存\",{\"1\":{\"611\":1}}],[\"也就是删除\",{\"1\":{\"593\":1}}],[\"也就是标签名称\",{\"1\":{\"547\":1}}],[\"也就是只包含方法的定义\",{\"1\":{\"219\":1}}],[\"也就是直接判断是否为同一个对象\",{\"1\":{\"215\":1}}],[\"也就是构造方法需要的类型\",{\"1\":{\"191\":1}}],[\"也就是结束工作线程\",{\"1\":{\"167\":1}}],[\"也就是异步的\",{\"1\":{\"138\":1}}],[\"也就是同步的\",{\"1\":{\"138\":1}}],[\"也就是同时保存两个方向\",{\"1\":{\"25\":1}}],[\"也就是所在进程的内存空间\",{\"1\":{\"138\":1}}],[\"也就是我们刚刚无参\",{\"1\":{\"60\":1}}],[\"也就是我们之前讲解的链表\",{\"1\":{\"25\":1}}],[\"也就是移除对应的键值对\",{\"1\":{\"56\":1}}],[\"也就是新的键值对\",{\"1\":{\"56\":1}}],[\"也就是说不打印\",{\"1\":{\"679\":1}}],[\"也就是说没有任何日志级别的值大于它\",{\"1\":{\"640\":1}}],[\"也就是说mybatis知道我们对数据库里面的数据进行了修改\",{\"1\":{\"611\":1}}],[\"也就是说我们第二次查询不仅压根就没执行sql语句\",{\"1\":{\"611\":1}}],[\"也就是说构造方法在默认情况下仅仅只是用于构造一个单纯的对象罢了\",{\"1\":{\"569\":1}}],[\"也就是说依然是采用的object中的默认实现\",{\"1\":{\"236\":1}}],[\"也就是说数组的长度一旦确定\",{\"1\":{\"236\":1}}],[\"也就是说这个方法只有定义\",{\"1\":{\"218\":1}}],[\"也就是说只能同时执行一个任务\",{\"1\":{\"138\":1}}],[\"也就是说只要整个哈希表用了75\",{\"1\":{\"60\":1}}],[\"也就是说需要的时候\",{\"1\":{\"71\":1}}],[\"也就是说对于刚访问过的元素\",{\"1\":{\"61\":1}}],[\"也就是说\",{\"1\":{\"55\":1,\"67\":1,\"117\":1,\"172\":1}}],[\"也就是对遍历的每一个元素进行的操作\",{\"1\":{\"35\":1}}],[\"也包含大量的并行方法\",{\"1\":{\"173\":1}}],[\"也有可能是给当前线程发送一个其他的信号\",{\"1\":{\"144\":1}}],[\"也有可能是数组存储\",{\"1\":{\"31\":1}}],[\"也能执行线程里面定义的内容\",{\"1\":{\"141\":1}}],[\"也存在大量的transient关键字\",{\"1\":{\"133\":1}}],[\"也需要考虑重写\",{\"1\":{\"84\":1}}],[\"也需要相同\",{\"1\":{\"84\":1}}],[\"也可能是integer类型\",{\"1\":{\"280\":1}}],[\"也可能是小数\",{\"1\":{\"15\":1}}],[\"也可以嵌套select\",{\"1\":{\"583\":1}}],[\"也可以为它起个别名\",{\"1\":{\"560\":1}}],[\"也可以通过excute\",{\"1\":{\"519\":1}}],[\"也可以不使用配置文件\",{\"1\":{\"552\":1}}],[\"也可以不带密码\",{\"1\":{\"500\":1}}],[\"也可以不同\",{\"1\":{\"8\":1}}],[\"也可以存储任意数量字符串\",{\"1\":{\"474\":1}}],[\"也可以使用其他类型\",{\"1\":{\"554\":1}}],[\"也可以使用cdata\",{\"1\":{\"546\":1}}],[\"也可以使用rollback\",{\"1\":{\"534\":1}}],[\"也可以使用\",{\"1\":{\"472\":1}}],[\"也可以使用访问顺序\",{\"1\":{\"61\":1}}],[\"也可以采用基于\",{\"1\":{\"441\":1}}],[\"也可以是一段文本内容\",{\"1\":{\"547\":1}}],[\"也可以是向量\",{\"1\":{\"386\":1}}],[\"也可以是无限长的trajectory\",{\"1\":{\"304\":1}}],[\"也可以是绝对路径\",{\"1\":{\"98\":1}}],[\"也可以象征性\",{\"1\":{\"244\":1}}],[\"也可以被子类访问\",{\"1\":{\"121\":1}}],[\"也可以用来将我们的类进行分类\",{\"1\":{\"120\":1}}],[\"也可以理解为是所有对象共享的内容\",{\"1\":{\"117\":1}}],[\"也可以直接扫描整个包下的所有实体类\",{\"1\":{\"560\":1}}],[\"也可以直接写入byte\",{\"1\":{\"92\":1}}],[\"也可以直接在定义时赋值\",{\"1\":{\"9\":1}}],[\"也可以控制读取的数量\",{\"1\":{\"91\":1}}],[\"也可以精准匹配\",{\"1\":{\"66\":1}}],[\"也可以当做栈来使用\",{\"1\":{\"44\":1}}],[\"也可以当做双端队列使用\",{\"1\":{\"25\":1}}],[\"也可以从后向前\",{\"1\":{\"37\":1}}],[\"也可以利用静态代码块\",{\"1\":{\"25\":1}}],[\"也是可用的日志级别中最大的\",{\"1\":{\"638\":1}}],[\"也是通过迭代器的形式去进行数据的读取\",{\"1\":{\"564\":1}}],[\"也是一样的\",{\"1\":{\"251\":1}}],[\"也是以对象的形式存在的\",{\"1\":{\"235\":1}}],[\"也是支持拆箱的\",{\"1\":{\"227\":1}}],[\"也是用于唤醒\",{\"1\":{\"161\":1}}],[\"也是用到了泛型\",{\"1\":{\"14\":1}}],[\"也是同样的值\",{\"1\":{\"154\":1}}],[\"也是更加推荐的做法\",{\"1\":{\"144\":1}}],[\"也是程序执行的最小单位\",{\"1\":{\"138\":1}}],[\"也是不同的两个类\",{\"1\":{\"120\":1}}],[\"也是由缓冲区处理\",{\"1\":{\"103\":1}}],[\"也是根据\",{\"1\":{\"84\":1}}],[\"也是头结点数组\",{\"1\":{\"58\":1}}],[\"也是1\",{\"1\":{\"25\":1}}],[\"也是尽量使用小写字母开头的单词\",{\"1\":{\"5\":1}}],[\"一级缓存给我们提供了很高速的访问效率\",{\"1\":{\"611\":1}}],[\"一级缓存只针对于单个会话\",{\"1\":{\"611\":1}}],[\"一级缓存强制启用\",{\"1\":{\"611\":1}}],[\"一级缓存\",{\"0\":{\"611\":1}}],[\"一次性提交一个批量操作给数据库\",{\"1\":{\"599\":1}}],[\"一次性读取全部内容\",{\"1\":{\"91\":1}}],[\"一对多查询\",{\"0\":{\"581\":1}}],[\"一对一查询我们可以使用association标签来进行指定\",{\"1\":{\"578\":1}}],[\"一对一查询\",{\"0\":{\"577\":1}}],[\"一起执行\",{\"1\":{\"526\":1}}],[\"一开始是在第一行上面\",{\"1\":{\"525\":1}}],[\"一开始创建时\",{\"1\":{\"245\":1}}],[\"一套完整的\",{\"1\":{\"515\":1}}],[\"一条记录\",{\"1\":{\"482\":1}}],[\"一样\",{\"1\":{\"367\":1}}],[\"一样才行\",{\"1\":{\"258\":1}}],[\"一种最简单的方式就是和之前一样\",{\"1\":{\"571\":1}}],[\"一种则是有所偏向\",{\"1\":{\"437\":1}}],[\"一种是将所有状态视为同等重要\",{\"1\":{\"437\":1}}],[\"一种是通过迭代算法来求解\",{\"1\":{\"353\":1}}],[\"一种是可以直接通过矩阵求逆进行求解\",{\"1\":{\"353\":1}}],[\"一种是以优秀\",{\"1\":{\"280\":1}}],[\"一种迭代策略\",{\"1\":{\"332\":1}}],[\"一些特性\",{\"1\":{\"440\":1}}],[\"一些细节\",{\"1\":{\"427\":1,\"441\":1}}],[\"一些状态可能很少被访问\",{\"1\":{\"419\":1}}],[\"一些问题\",{\"0\":{\"353\":1}}],[\"一些方法\",{\"1\":{\"275\":1}}],[\"一些集合是有序的\",{\"1\":{\"21\":1}}],[\"一定可以遍历所给定的\",{\"1\":{\"369\":1}}],[\"一定是\",{\"1\":{\"281\":1}}],[\"一定要先切换到我们要创建表的数据库内\",{\"1\":{\"478\":1}}],[\"一定要用equals\",{\"1\":{\"244\":1}}],[\"一定要注意\",{\"1\":{\"156\":1}}],[\"一定比线程t先醒来\",{\"1\":{\"144\":1}}],[\"一旦使用\",{\"1\":{\"540\":1}}],[\"一旦关闭自动提交\",{\"1\":{\"534\":1}}],[\"一旦提交\",{\"1\":{\"510\":1}}],[\"一旦tcp连接建立\",{\"1\":{\"447\":1}}],[\"一旦类型明确\",{\"1\":{\"281\":1}}],[\"一旦获取到\",{\"1\":{\"142\":1}}],[\"一旦被声明为静态\",{\"1\":{\"117\":1}}],[\"一直以来编写的都是单线程应用程序\",{\"1\":{\"138\":1}}],[\"一部分内容可以被暂时保存bufferedinputstream\",{\"1\":{\"108\":1}}],[\"一致性\",{\"1\":{\"510\":1}}],[\"一致也是可以的\",{\"1\":{\"409\":1}}],[\"一致\",{\"1\":{\"84\":1}}],[\"一会直接覆盖\",{\"1\":{\"59\":1}}],[\"一般不咋用\",{\"1\":{\"569\":1}}],[\"一般都是将其转换为对应的实体类对象\",{\"1\":{\"559\":1}}],[\"一般聚集函数是这样使用的\",{\"1\":{\"493\":1}}],[\"一般\",{\"1\":{\"454\":1}}],[\"一般化的推广\",{\"1\":{\"354\":1}}],[\"一般出现错误可能jvm就无法继续正常运行了\",{\"1\":{\"264\":1}}],[\"一般他们是配合一起使用的\",{\"1\":{\"129\":1}}],[\"一般遇到以下情况时才会会加载类\",{\"1\":{\"118\":1}}],[\"一般情况\",{\"1\":{\"229\":1}}],[\"一般情况下只是为了进行一些额外的初始化工作而已\",{\"1\":{\"255\":1}}],[\"一般情况下\",{\"1\":{\"117\":1,\"206\":1}}],[\"一般情况都是真实的数据量\",{\"1\":{\"91\":1}}],[\"一般在java\",{\"1\":{\"88\":1}}],[\"一般的比较运算符\",{\"1\":{\"491\":1}}],[\"一般的\",{\"1\":{\"25\":1}}],[\"一般使用驼峰命名法最规范\",{\"1\":{\"5\":1}}],[\"一个logger中可以包含多个handler用于同时向不同的地方打印日志\",{\"1\":{\"646\":1}}],[\"一个会话dml操作只会重置当前会话的缓存\",{\"1\":{\"611\":1}}],[\"一个比较特殊的选择方法selectmap\",{\"1\":{\"564\":1}}],[\"一个节点下可能会有很多个节点\",{\"1\":{\"547\":1}}],[\"一个xml文件存在以下的格式规范\",{\"1\":{\"545\":1}}],[\"一个事务\",{\"1\":{\"510\":1}}],[\"一个不允许更新的视图上定义的视图也不允许更新\",{\"1\":{\"507\":1}}],[\"一个表可以有多个唯一约束\",{\"1\":{\"475\":1}}],[\"一个表只能有一个主键\",{\"1\":{\"475\":1,\"476\":1}}],[\"一个仓库可以存储多种物品\",{\"1\":{\"467\":1}}],[\"一个实体的属性可以有很多个\",{\"1\":{\"461\":1}}],[\"一个\",{\"1\":{\"388\":1}}],[\"一个是运行时异常\",{\"1\":{\"265\":1}}],[\"一个是编译时异常\",{\"1\":{\"265\":1}}],[\"一个成员内部类\",{\"1\":{\"251\":1}}],[\"一个三行两列的数组\",{\"1\":{\"240\":1}}],[\"一个类可以附加很多个功能\",{\"1\":{\"219\":1}}],[\"一个类中可以包含多个同名的方法\",{\"1\":{\"8\":1}}],[\"一个最简单的注解就被我们创建了\",{\"1\":{\"206\":1}}],[\"一个注解可以有很多个作用域\",{\"1\":{\"206\":1}}],[\"一个线程处于运行状态下\",{\"1\":{\"143\":1}}],[\"一个进程可以有多个线程\",{\"1\":{\"138\":1}}],[\"一个对象改变了静态变量的值\",{\"1\":{\"117\":1}}],[\"一个新的迭代器就像上面这样\",{\"1\":{\"31\":1}}],[\"一个集合中可以存放多个集合\",{\"1\":{\"25\":1}}],[\"一个泛型类型编译之后\",{\"1\":{\"16\":1}}],[\"有些操作可能比较特殊\",{\"1\":{\"615\":1}}],[\"有些时候我们可以会打印一些比较重要的日志信息\",{\"1\":{\"637\":1}}],[\"有些时候我们可能需要生成一个空的集合类返回\",{\"1\":{\"79\":1}}],[\"有些时候并不需要创建那么多对象\",{\"1\":{\"227\":1}}],[\"有些时候\",{\"1\":{\"8\":1,\"571\":1,\"590\":1}}],[\"有两种不同的方式加载关联\",{\"1\":{\"577\":1}}],[\"有助于优化性能\",{\"1\":{\"569\":1}}],[\"有助于提高性能\",{\"1\":{\"563\":1}}],[\"有表示\",{\"1\":{\"440\":1}}],[\"有\",{\"1\":{\"364\":1}}],[\"有关mybatis的基本使用\",{\"1\":{\"632\":1}}],[\"有关mybatis这一部分的原理\",{\"1\":{\"570\":1}}],[\"有关\",{\"1\":{\"333\":1,\"437\":1}}],[\"有关注解我们会在最后一章进行介绍\",{\"1\":{\"216\":1}}],[\"有关锁的内容\",{\"1\":{\"215\":1}}],[\"有关线程中断相关问题\",{\"1\":{\"142\":1}}],[\"有了\",{\"1\":{\"186\":1}}],[\"有哪些方法\",{\"1\":{\"179\":1}}],[\"有可能会使得这个类的一些结构发生变化\",{\"1\":{\"132\":1}}],[\"有时会遇到这样一个很麻烦的问题\",{\"1\":{\"126\":1}}],[\"有时候我们的方法中可能会出现一些与成员变量重名的变量\",{\"1\":{\"7\":1}}],[\"有着不同程度的访问限制\",{\"1\":{\"121\":1}}],[\"有点混乱\",{\"1\":{\"120\":1}}],[\"1724143033753\",{\"1\":{\"624\":1}}],[\"17\",{\"1\":{\"605\":2}}],[\"1=1一定是true\",{\"1\":{\"532\":1}}],[\"1=1\",{\"1\":{\"532\":2,\"533\":1}}],[\"1111\",{\"1\":{\"532\":2}}],[\"1nf\",{\"0\":{\"464\":1}}],[\"1nf对表中每一列进行约束\",{\"1\":{\"463\":1}}],[\"15s\",{\"1\":{\"676\":1}}],[\"15\",{\"1\":{\"455\":1,\"580\":4,\"636\":1}}],[\"1−∣a\",{\"1\":{\"372\":1}}],[\"1~2\",{\"1\":{\"295\":1}}],[\"1+σ2pkn​​gkn​​\",{\"1\":{\"294\":1}}],[\"1+ns​\",{\"1\":{\"294\":1}}],[\"1962329560\",{\"1\":{\"580\":2}}],[\"19\",{\"1\":{\"274\":1,\"605\":2,\"611\":2}}],[\"12\",{\"1\":{\"636\":1,\"647\":2,\"657\":2}}],[\"127\",{\"1\":{\"455\":2}}],[\"120和4\",{\"1\":{\"295\":1}}],[\"128~127之间的值自动装箱为integer类型的对象\",{\"1\":{\"227\":1}}],[\"128~127之间的所有值\",{\"1\":{\"227\":1}}],[\"128\",{\"1\":{\"227\":4}}],[\"1234\",{\"1\":{\"318\":1,\"526\":2,\"534\":11}}],[\"1234567\",{\"1\":{\"133\":1}}],[\"123456\",{\"1\":{\"132\":1,\"516\":1,\"524\":1,\"533\":1,\"632\":1}}],[\"123\",{\"1\":{\"192\":1}}],[\"1打印\",{\"1\":{\"147\":1,\"148\":1}}],[\"1static\",{\"1\":{\"219\":1}}],[\"1s\",{\"1\":{\"142\":1}}],[\"166\",{\"1\":{\"228\":1}}],[\"16\",{\"1\":{\"88\":1,\"580\":2}}],[\"13\",{\"1\":{\"77\":1}}],[\"1\",{\"0\":{\"19\":1,\"20\":1,\"107\":1,\"278\":1,\"279\":1,\"304\":1,\"309\":1,\"311\":1,\"315\":1,\"323\":1,\"324\":2,\"325\":1,\"326\":1,\"328\":1,\"338\":1,\"340\":1,\"342\":1,\"347\":1,\"348\":2,\"349\":1,\"351\":1,\"355\":1,\"361\":1,\"362\":2,\"363\":1,\"364\":1,\"366\":1,\"371\":1,\"378\":1,\"379\":2,\"381\":1,\"386\":1,\"395\":1,\"397\":1,\"401\":1,\"405\":1,\"416\":1,\"418\":1,\"433\":1,\"435\":1,\"459\":1,\"690\":1},\"1\":{\"14\":4,\"25\":2,\"33\":1,\"50\":2,\"57\":6,\"59\":3,\"60\":2,\"64\":4,\"71\":4,\"78\":1,\"79\":1,\"80\":3,\"91\":3,\"92\":1,\"94\":1,\"96\":1,\"108\":3,\"110\":1,\"173\":2,\"183\":1,\"239\":1,\"240\":2,\"241\":1,\"246\":5,\"266\":1,\"267\":2,\"274\":1,\"275\":1,\"285\":1,\"295\":1,\"298\":7,\"299\":1,\"304\":1,\"351\":1,\"355\":1,\"364\":2,\"372\":1,\"383\":2,\"386\":1,\"397\":1,\"401\":1,\"454\":3,\"455\":11,\"461\":4,\"516\":2,\"527\":1,\"532\":1,\"533\":2,\"545\":4,\"552\":1,\"554\":1,\"560\":1,\"561\":1,\"562\":1,\"564\":1,\"571\":1,\"580\":6,\"593\":4,\"599\":1,\"602\":1,\"604\":3,\"611\":8,\"612\":2,\"616\":1}}],[\"180π​\",{\"1\":{\"294\":1}}],[\"18\",{\"1\":{\"5\":1,\"9\":1,\"216\":4,\"219\":1,\"220\":1,\"221\":1,\"475\":2,\"562\":1,\"564\":1,\"571\":1,\"580\":1,\"599\":1,\"601\":1,\"602\":3,\"605\":2,\"630\":3}}],[\"1024\",{\"1\":{\"454\":2}}],[\"10​a=ak∗​\",{\"1\":{\"348\":1,\"351\":1}}],[\"10​a=a∗a=a∗​\",{\"1\":{\"342\":1}}],[\"100000\",{\"1\":{\"155\":6}}],[\"10000\",{\"1\":{\"154\":2,\"155\":4}}],[\"1000ms\",{\"1\":{\"142\":1}}],[\"1000\",{\"1\":{\"142\":1,\"154\":1,\"155\":4,\"156\":2,\"161\":1,\"162\":1,\"166\":1,\"167\":1,\"172\":4,\"449\":1,\"638\":1}}],[\"100~100之间的\",{\"1\":{\"71\":1}}],[\"100\",{\"1\":{\"71\":4,\"193\":1,\"229\":2,\"267\":1,\"274\":1,\"475\":1}}],[\"10\",{\"1\":{\"4\":1,\"9\":1,\"15\":2,\"25\":5,\"46\":4,\"71\":1,\"77\":1,\"79\":2,\"94\":1,\"96\":1,\"148\":1,\"184\":1,\"186\":4,\"193\":4,\"227\":5,\"229\":1,\"235\":1,\"236\":1,\"237\":1,\"238\":4,\"256\":1,\"257\":2,\"258\":2,\"267\":2,\"268\":2,\"281\":1,\"455\":1,\"475\":1,\"476\":1}}],[\"小刘\",{\"1\":{\"605\":2}}],[\"小张\",{\"1\":{\"605\":2}}],[\"小黑子\",{\"1\":{\"599\":1}}],[\"小美\",{\"1\":{\"599\":1,\"605\":2}}],[\"小强\",{\"1\":{\"599\":1}}],[\"小刚\",{\"1\":{\"599\":1}}],[\"小辣椒\",{\"1\":{\"538\":1}}],[\"小王\",{\"1\":{\"219\":1,\"599\":1}}],[\"小于0表示小于\",{\"1\":{\"14\":1}}],[\"小明\",{\"1\":{\"5\":1,\"9\":1,\"57\":4,\"216\":4,\"220\":1,\"221\":1,\"251\":1,\"580\":1}}],[\"小红\",{\"1\":{\"4\":1,\"57\":2,\"251\":1}}],[\"岁了\",{\"1\":{\"5\":1}}],[\"+log\",{\"1\":{\"678\":2}}],[\"+child\",{\"1\":{\"547\":1}}],[\"+c2​\",{\"1\":{\"295\":1}}],[\"+param\",{\"1\":{\"527\":1}}],[\"+object\",{\"1\":{\"527\":1}}],[\"+reader\",{\"1\":{\"448\":1}}],[\"+rtt−rkn​​\",{\"1\":{\"295\":1}}],[\"+scanner\",{\"1\":{\"532\":2}}],[\"+sex\",{\"1\":{\"527\":1}}],[\"+sid+\",{\"1\":{\"527\":1}}],[\"+socket\",{\"1\":{\"447\":2,\"448\":1,\"455\":2}}],[\"+str\",{\"1\":{\"192\":1,\"199\":1}}],[\"+η▽w​f\",{\"1\":{\"389\":1}}],[\"+η​\",{\"1\":{\"384\":1,\"395\":1}}],[\"+ηk​\",{\"1\":{\"382\":1}}],[\"+γs\",{\"1\":{\"331\":1,\"362\":1}}],[\"+γe\",{\"1\":{\"327\":1,\"330\":1}}],[\"+ζ2​moskn​​rate\",{\"1\":{\"295\":1}}],[\"+e\",{\"1\":{\"267\":1}}],[\"+text\",{\"1\":{\"448\":1}}],[\"+test\",{\"1\":{\"251\":1}}],[\"+this\",{\"1\":{\"251\":1}}],[\"+name\",{\"1\":{\"251\":2}}],[\"+name+\",{\"1\":{\"5\":1,\"527\":1}}],[\"+表示对前面这个字符匹配一次或多次\",{\"1\":{\"246\":1}}],[\"+=\",{\"1\":{\"245\":1}}],[\"+a\",{\"1\":{\"257\":5}}],[\"+array\",{\"1\":{\"236\":1}}],[\"+age+\",{\"1\":{\"5\":1}}],[\"+i+\",{\"1\":{\"524\":1}}],[\"+i\",{\"1\":{\"142\":1,\"147\":2,\"148\":2,\"173\":1}}],[\"++size\",{\"1\":{\"59\":1}}],[\"++modcount\",{\"1\":{\"59\":1}}],[\"++bincount\",{\"1\":{\"59\":1}}],[\"+\",{\"1\":{\"8\":2,\"25\":3,\"33\":1,\"48\":1,\"49\":1,\"65\":4,\"71\":1,\"139\":1,\"173\":1,\"174\":6,\"192\":1,\"215\":2,\"227\":1,\"237\":1,\"245\":5,\"246\":2,\"254\":1,\"258\":1,\"274\":1,\"293\":1,\"384\":1,\"395\":1,\"517\":9,\"527\":1,\"532\":2,\"547\":1,\"569\":2,\"599\":2,\"628\":1,\"667\":4,\"672\":3}}],[\"果直接创建对象\",{\"1\":{\"4\":1}}],[\"就算像这样进行了修改\",{\"1\":{\"569\":1}}],[\"就能够很好地解决缓存一致性问题\",{\"1\":{\"616\":1}}],[\"就能够直接将查询结果转化为一个实体类\",{\"1\":{\"554\":1}}],[\"就能够解决掉我们之前长长的一串代码\",{\"1\":{\"538\":1}}],[\"就存放在resultset中\",{\"1\":{\"519\":1}}],[\"就无法再进行回滚了\",{\"1\":{\"510\":1}}],[\"就直接去更新策略\",{\"1\":{\"367\":1}}],[\"就好了\",{\"1\":{\"348\":1}}],[\"就好像默认其是\",{\"1\":{\"281\":1}}],[\"就没有这个\",{\"1\":{\"285\":1}}],[\"就没办法了\",{\"1\":{\"229\":1}}],[\"就明确指出了在运行的时候会出现的异常\",{\"1\":{\"264\":1}}],[\"就近原则\",{\"1\":{\"251\":1}}],[\"就表示这个是一个数组类型\",{\"1\":{\"235\":1}}],[\"就支持像这样编写\",{\"1\":{\"227\":1}}],[\"就不再是通过预编译\",{\"1\":{\"559\":1}}],[\"就不太可行\",{\"1\":{\"419\":1}}],[\"就不需要是\",{\"1\":{\"410\":1}}],[\"就不能确保所选择的\",{\"1\":{\"369\":1}}],[\"就不会执行接口的默认方法\",{\"1\":{\"219\":1}}],[\"就不一定需要实现\",{\"1\":{\"218\":1}}],[\"就不是正常的\",{\"1\":{\"186\":1}}],[\"就连被定义为final字段的值都能强行修改\",{\"1\":{\"193\":1}}],[\"就保证三个线程的锁是一致的\",{\"1\":{\"155\":1}}],[\"就必须确保这样做是安全的\",{\"1\":{\"192\":1}}],[\"就必须等待当前同步代码块的内容执行完毕\",{\"1\":{\"155\":1}}],[\"就必须运行两个进程\",{\"1\":{\"138\":1}}],[\"就会重新读取\",{\"1\":{\"612\":1}}],[\"就会向下移动一行\",{\"1\":{\"525\":1}}],[\"就会直接交给jvm进行处理\",{\"1\":{\"267\":1}}],[\"就会报错\",{\"1\":{\"256\":1}}],[\"就会得到不同的对象了\",{\"1\":{\"227\":1}}],[\"就会结束循环\",{\"1\":{\"167\":1}}],[\"就会出现问题\",{\"1\":{\"154\":1}}],[\"就会暂时处于休眠状态\",{\"1\":{\"142\":1}}],[\"就可能导致各自的高速缓存数据不一致\",{\"1\":{\"154\":1}}],[\"就可以创建一个自定义的日志格式处理逻辑了\",{\"1\":{\"672\":1}}],[\"就可以编写为这种形式\",{\"1\":{\"664\":1}}],[\"就可以直接在二级缓存中命中了\",{\"1\":{\"612\":1}}],[\"就可以直接从缓存中读取\",{\"1\":{\"610\":1}}],[\"就可以直接就创出对象\",{\"1\":{\"255\":1}}],[\"就可以解决这样的问题\",{\"1\":{\"538\":1}}],[\"就可以通过set中提供的方法\",{\"1\":{\"525\":1}}],[\"就可以使用多重异常捕获\",{\"1\":{\"267\":1}}],[\"就可以使用tostring转换为字符串了\",{\"1\":{\"245\":1}}],[\"就可以使用非public方法了\",{\"1\":{\"191\":1}}],[\"就可以表示这个是哪一个包里的类了\",{\"1\":{\"120\":1}}],[\"就可以轻松地通过键找到对应的映射值\",{\"1\":{\"55\":1}}],[\"就可以执行定义好的方法了\",{\"1\":{\"5\":1}}],[\"就可以进行一定操作\",{\"1\":{\"4\":1}}],[\"就开始按顺序执行我们给定的程序\",{\"1\":{\"142\":1}}],[\"就需要给出列名\",{\"1\":{\"482\":1}}],[\"就需要新的算法进行解决\",{\"1\":{\"381\":1}}],[\"就需要将这三种类型都进行明确指定\",{\"1\":{\"281\":1}}],[\"就需要对异常进行捕获\",{\"1\":{\"267\":1}}],[\"就需要用到java多线程框架\",{\"1\":{\"138\":1}}],[\"就需要注意了\",{\"1\":{\"120\":1}}],[\"就像下面这个图一样\",{\"1\":{\"658\":1}}],[\"就像下面这样\",{\"1\":{\"117\":1}}],[\"就像包名一样\",{\"1\":{\"658\":1}}],[\"就像是我们之前使用association和collection那样\",{\"1\":{\"629\":1}}],[\"就像我们之前在使用constrator标签一样\",{\"1\":{\"628\":1}}],[\"就像我们遍历数组那样\",{\"1\":{\"31\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"510\":1}}],[\"就像hash表一样\",{\"1\":{\"508\":1}}],[\"就像使用普通类型那样\",{\"1\":{\"221\":1}}],[\"就像注释一样\",{\"1\":{\"203\":1}}],[\"就像在这个类定义的方法一样\",{\"1\":{\"121\":1}}],[\"就像你进了公司\",{\"1\":{\"67\":1}}],[\"就行了\",{\"1\":{\"67\":2,\"265\":2}}],[\"就跟我们之前的顺序表插入是一样的\",{\"1\":{\"24\":1}}],[\"就是inner标签的一个属性\",{\"1\":{\"545\":1}}],[\"就是一种一对一的联系\",{\"1\":{\"461\":1}}],[\"就是一个已经实现了抽象方法的对象\",{\"1\":{\"255\":1}}],[\"就是\",{\"1\":{\"372\":1}}],[\"就是前面\",{\"1\":{\"363\":1}}],[\"就是进行迭代\",{\"1\":{\"356\":1}}],[\"就是说如果这个函数结束时有异常\",{\"1\":{\"266\":1}}],[\"就是内存溢出错误\",{\"1\":{\"264\":1}}],[\"就是将表本身和表进行笛卡尔积计算\",{\"1\":{\"496\":1}}],[\"就是将一个已实现的方法\",{\"1\":{\"258\":1}}],[\"就是将当前集合变成当前集合与给定集合的并集\",{\"1\":{\"23\":1}}],[\"就是创建在内部的类\",{\"1\":{\"250\":1}}],[\"就是专门用于构造字符串的\",{\"1\":{\"245\":1}}],[\"就是0\",{\"1\":{\"235\":1}}],[\"就是null\",{\"1\":{\"235\":1}}],[\"就是精确到最后一位时\",{\"1\":{\"229\":1}}],[\"就是生产者在不断的生产\",{\"1\":{\"174\":1}}],[\"就是使用的对象锁\",{\"1\":{\"155\":1}}],[\"就是使用的类锁\",{\"1\":{\"155\":1}}],[\"就是类锁\",{\"1\":{\"155\":1}}],[\"就是对象锁\",{\"1\":{\"155\":1}}],[\"就是用于分割的\",{\"1\":{\"120\":1}}],[\"就是域名\",{\"1\":{\"120\":1}}],[\"就是在运行时进行类型检查\",{\"1\":{\"80\":1}}],[\"就是为了实现这种数据结构而存在的\",{\"1\":{\"55\":1}}],[\"就是不断向后寻找结点\",{\"1\":{\"33\":1}}],[\"就是直接按下标访问\",{\"1\":{\"33\":1}}],[\"就是重复\",{\"1\":{\"24\":1}}],[\"就是求当前集合与给定集合的交集\",{\"1\":{\"23\":1}}],[\"就是求当前集合与给定集合的差集\",{\"1\":{\"23\":1}}],[\"就是看给定集合是不是当前集合的子集\",{\"1\":{\"23\":1}}],[\"就是要操作\",{\"1\":{\"4\":1}}],[\"我看你<><><>是一点都不懂哦>>>\",{\"1\":{\"546\":1}}],[\"我的性别是\",{\"1\":{\"527\":1}}],[\"我希望将这两张表结合到一起来查看完整的数据\",{\"1\":{\"497\":1}}],[\"我会学习\",{\"1\":{\"219\":1,\"220\":1}}],[\"我姓🐴\",{\"1\":{\"198\":1}}],[\"我这里读取的是一个字符串或是一个个字符\",{\"1\":{\"126\":1}}],[\"我是日志信息\",{\"1\":{\"678\":2}}],[\"我是自定义日志格式\",{\"1\":{\"672\":2}}],[\"我是普通的日志\",{\"1\":{\"636\":2}}],[\"我是一个阳光开朗大男孩\",{\"1\":{\"580\":1}}],[\"我是编译时异常\",{\"1\":{\"266\":1}}],[\"我是学习方法\",{\"1\":{\"257\":2}}],[\"我是匿名内部类的实现\",{\"1\":{\"255\":1}}],[\"我是局部内部类\",{\"1\":{\"253\":1}}],[\"我是静态内部类\",{\"1\":{\"252\":1}}],[\"我是静态方法\",{\"1\":{\"117\":1,\"121\":1}}],[\"我是成员内部类\",{\"1\":{\"251\":2}}],[\"我是默认实现\",{\"1\":{\"219\":1}}],[\"我是工人\",{\"1\":{\"216\":1,\"218\":1}}],[\"我是测试方法\",{\"1\":{\"199\":1}}],[\"我是定时任务\",{\"1\":{\"165\":2}}],[\"我是另一个线程\",{\"1\":{\"140\":2}}],[\"我是代码块\",{\"1\":{\"9\":1}}],[\"我被构造了\",{\"1\":{\"9\":1}}],[\"我叫🐴nb\",{\"1\":{\"198\":1}}],[\"我叫\",{\"1\":{\"5\":1,\"527\":1}}],[\"我任性\",{\"1\":{\"4\":1}}],[\"我们刚刚在filehandler中见到的是默认生成的xmlformatter\",{\"1\":{\"649\":1}}],[\"我们创建的logger默认是不带任何handler对象的\",{\"1\":{\"646\":1}}],[\"我们已经体验到mybatis为我们带来的便捷了\",{\"1\":{\"621\":1}}],[\"我们已经知道如何使用mybatis进行各种查询操作\",{\"1\":{\"569\":1}}],[\"我们去掉类上的\",{\"1\":{\"611\":1}}],[\"我们首先来看看一对一查询\",{\"1\":{\"629\":1}}],[\"我们首先来看一下一级缓存\",{\"1\":{\"611\":1}}],[\"我们首先需要创建对象\",{\"1\":{\"251\":1}}],[\"我们基本上可以解决大部分的sql查询和批量处理场景了\",{\"1\":{\"605\":1}}],[\"我们都需要flushstatements\",{\"1\":{\"599\":1}}],[\"我们每一次执行sql语句\",{\"1\":{\"599\":1}}],[\"我们每次上菜的时候只从厨房端一个菜\",{\"1\":{\"599\":1}}],[\"我们每次都需要去找映射器对应操作的名称\",{\"1\":{\"570\":1}}],[\"我们接着来尝试将日志记录到我们本地的文件中\",{\"1\":{\"648\":1}}],[\"我们接着来测试一下回滚操作\",{\"1\":{\"593\":1}}],[\"我们接着来看mybatis\",{\"1\":{\"679\":1}}],[\"我们接着来看修改操作\",{\"1\":{\"591\":1}}],[\"我们接着来看修改相关操作\",{\"1\":{\"588\":1}}],[\"我们接着来看一对多查询\",{\"1\":{\"581\":1}}],[\"我们接着来看更方便的用法\",{\"1\":{\"571\":1}}],[\"我们现在循环地每三秒读取一次\",{\"1\":{\"616\":1}}],[\"我们现在同样需要使用resultmap来自定义映射规则\",{\"1\":{\"577\":1}}],[\"我们现在只拿到了一个inputstream\",{\"1\":{\"126\":1}}],[\"我们使用setuseparenthandlers方法来屏蔽所有父级提供的日志处理器\",{\"1\":{\"646\":1}}],[\"我们使用其他软件手动修改数据库中的数据\",{\"1\":{\"616\":1}}],[\"我们使用一个map作为参数\",{\"1\":{\"571\":1}}],[\"我们使用instanceof进行类型比较\",{\"1\":{\"186\":1}}],[\"我们放在最后一节进行讲解\",{\"1\":{\"570\":1}}],[\"我们主要还是以selectone和selectlist为主\",{\"1\":{\"564\":1}}],[\"我们再来看看之前在resultmap中配置的关联查询该如何编写\",{\"1\":{\"629\":1}}],[\"我们再来看一个例子\",{\"1\":{\"605\":1}}],[\"我们再来尝试编写一下查询一个列表\",{\"1\":{\"564\":1}}],[\"我们再来使用这个对象的泛型成员\",{\"1\":{\"15\":1}}],[\"我们输入的参数一旦出现\",{\"1\":{\"533\":1}}],[\"我们输入以下命令来看看能否访问所有数据库\",{\"1\":{\"501\":1}}],[\"我们该怎么去写\",{\"1\":{\"532\":1}}],[\"我们称为数据库驱动\",{\"1\":{\"515\":1}}],[\"我们仍可在old表中拿到被删除的数据\",{\"1\":{\"509\":1}}],[\"我们仍需要估计\",{\"1\":{\"364\":1}}],[\"我们平时所说的crud其实就是增删改查\",{\"1\":{\"472\":1}}],[\"我们平时使用的println方法就是printstream中的方法\",{\"1\":{\"127\":1}}],[\"我们要学习的就是以下四种类型的sql语言\",{\"1\":{\"472\":1}}],[\"我们要学习一下每一个表该如何去设计\",{\"1\":{\"463\":1}}],[\"我们要创建一个数组\",{\"1\":{\"235\":1}}],[\"我们便称为\",{\"1\":{\"441\":1}}],[\"我们定义\",{\"1\":{\"433\":1}}],[\"我们定义最优的策略为\",{\"1\":{\"433\":1}}],[\"我们定义的每一个状态其实就是一个public\",{\"1\":{\"221\":1}}],[\"我们先直接求解\",{\"1\":{\"427\":1}}],[\"我们先来看第一种方式\",{\"1\":{\"578\":1}}],[\"我们先来看看如果我们想模拟登陆一个用户\",{\"1\":{\"532\":1}}],[\"我们先来看看队列接口\",{\"1\":{\"43\":1}}],[\"我们先来测试一下它的特性\",{\"1\":{\"48\":1}}],[\"我们是无法估计的\",{\"1\":{\"421\":1}}],[\"我们是引入了\",{\"1\":{\"390\":1}}],[\"我们很难直接获得\",{\"1\":{\"386\":1}}],[\"我们有以下几种方法\",{\"1\":{\"386\":1}}],[\"我们得到的观测值是\",{\"1\":{\"384\":1}}],[\"我们采用的是\",{\"1\":{\"372\":1}}],[\"我们选取其\",{\"1\":{\"364\":1}}],[\"我们不需要删除这些多余的构造方法\",{\"1\":{\"569\":1}}],[\"我们不断地与环境进行交互\",{\"1\":{\"420\":1}}],[\"我们不能直接得到随机变量的值\",{\"1\":{\"384\":1}}],[\"我们不能通过之前的方法来求出q\",{\"1\":{\"362\":1}}],[\"我们不仅可以用来估计q\",{\"1\":{\"366\":1}}],[\"我们不仅可以通过构造方法\",{\"1\":{\"9\":1}}],[\"我们这里强行初始化为vπ0​​\",{\"1\":{\"355\":1}}],[\"我们这里要删除的是刚刚传入的值为10的integer对象\",{\"1\":{\"25\":1}}],[\"我们通常将\",{\"1\":{\"312\":1}}],[\"我们通过添加\",{\"1\":{\"540\":2}}],[\"我们通过实战来演示一下lombok的实用注解\",{\"1\":{\"540\":1}}],[\"我们通过以下例子来探究以下事务\",{\"1\":{\"510\":1}}],[\"我们通过\",{\"1\":{\"191\":1}}],[\"我们通过使用\",{\"1\":{\"117\":1}}],[\"我们通过保存键值对的形式来存储映射关系\",{\"1\":{\"55\":1}}],[\"我们对无人机的发射功率有一个约束\",{\"1\":{\"294\":1}}],[\"我们希望能够分不同情况处理不同类型的异常\",{\"1\":{\"267\":1}}],[\"我们希望cpu花费更多的时间去处理更重要的任务\",{\"1\":{\"145\":1}}],[\"我们抛出异常实际上就是将这个异常对象抛出\",{\"1\":{\"266\":1}}],[\"我们自定义异常也是从这两类中进行选择\",{\"1\":{\"265\":1}}],[\"我们自己写的都行\",{\"1\":{\"36\":1}}],[\"我们同样需要使用\",{\"1\":{\"630\":1}}],[\"我们同样需要使用对象来进行方法引用\",{\"1\":{\"258\":1}}],[\"我们同样可以进行简单的条件查询\",{\"1\":{\"564\":1}}],[\"我们同样可以使用\",{\"1\":{\"57\":1}}],[\"我们一般都使用\",{\"1\":{\"559\":1}}],[\"我们一般通过create\",{\"1\":{\"478\":1}}],[\"我们一般只会在类的内部自己使用\",{\"1\":{\"251\":1}}],[\"我们一般称为限定符\",{\"1\":{\"246\":1}}],[\"我们知道日志的默认打印级别为info\",{\"1\":{\"640\":1}}],[\"我们知道\",{\"1\":{\"243\":1,\"569\":1,\"679\":1}}],[\"我们如果需要控制单个方法的缓存\",{\"1\":{\"631\":1}}],[\"我们如果直接让\",{\"1\":{\"227\":1}}],[\"我们如果想一次性全部读取的话\",{\"1\":{\"91\":1}}],[\"我们如果想要在方法中访问到当前对象的属性\",{\"1\":{\"7\":1}}],[\"我们直接使用即可\",{\"1\":{\"516\":1}}],[\"我们直接使用成员变量即可\",{\"1\":{\"5\":1}}],[\"我们直接调用父类的实现就可以了\",{\"1\":{\"220\":1}}],[\"我们无法完全通过注解来实现之前的联合查询解析\",{\"1\":{\"629\":1}}],[\"我们无法在代码中直接使用此类型\",{\"1\":{\"199\":1}}],[\"我们无论通过什么方式访问\",{\"1\":{\"180\":1}}],[\"我们把它放到根目录下\",{\"1\":{\"199\":1}}],[\"我们来尝试编写一下\",{\"1\":{\"676\":1}}],[\"我们来尝试编写一个插入操作\",{\"1\":{\"589\":1}}],[\"我们来尝试以全注解的形式重现编写咱们的sql语句映射\",{\"1\":{\"621\":1}}],[\"我们来尝试一下直接读取实体类\",{\"1\":{\"554\":1}}],[\"我们来接着尝试一下使用回滚操作\",{\"1\":{\"534\":1}}],[\"我们来再次尝试编写一下在最开始我们查找某教师所有学生的sql语句\",{\"1\":{\"498\":1}}],[\"我们来试试看向我们刚刚创建的表中添加三条数据\",{\"1\":{\"482\":1}}],[\"我们来试试看修改成员字段之后\",{\"1\":{\"199\":1}}],[\"我们来试试看修改一些其他的类型\",{\"1\":{\"193\":1}}],[\"我们来试试看创建一个此类的对象并调用其方法\",{\"1\":{\"199\":1}}],[\"我们来看看这个例子\",{\"1\":{\"616\":1}}],[\"我们来看看这里面是怎么定义的\",{\"1\":{\"58\":1}}],[\"我们来看看下面这段代码\",{\"1\":{\"611\":1}}],[\"我们来看看实际执行的sql语句是什么\",{\"1\":{\"533\":1}}],[\"我们来看看如何从resultset中去获取数据\",{\"1\":{\"525\":1}}],[\"我们来看看以下这段代码会得到什么结果\",{\"1\":{\"156\":1}}],[\"我们来看看resize\",{\"1\":{\"60\":1}}],[\"我们也体会到lombok给我们带来的便捷\",{\"1\":{\"677\":1}}],[\"我们也没有导入student类\",{\"1\":{\"192\":1}}],[\"我们也可以利用这些属性来编写一个类似于的simpleformatter的日志格式\",{\"1\":{\"676\":1}}],[\"我们也可以利用反射机制来将查询结果映射为对象\",{\"1\":{\"527\":1}}],[\"我们也可以通过这种方式来获取我们的一些系统属性\",{\"1\":{\"666\":1}}],[\"我们也可以通过log方法来主动设定该条日志的输出级别\",{\"1\":{\"639\":1}}],[\"我们也可以通过下面的命令删除一个索引\",{\"1\":{\"508\":1}}],[\"我们也可以单独配置其不使用二级缓存\",{\"1\":{\"614\":1}}],[\"我们也可以直接将其绑定到一个接口上\",{\"1\":{\"589\":1}}],[\"我们也可以直接将这两个参数定义到形参列表中\",{\"1\":{\"571\":1}}],[\"我们也可以去创建一个回滚点来实现定点回滚\",{\"1\":{\"534\":1}}],[\"我们也可以去修改为其他的引擎\",{\"1\":{\"510\":1}}],[\"我们也可以进行关联查询来让mybatis自动解析结果并封装为对象\",{\"1\":{\"581\":1}}],[\"我们也可以进行分页\",{\"1\":{\"494\":1}}],[\"我们也可以进行近似\",{\"1\":{\"441\":1}}],[\"我们也可以可以同时添加多个排序\",{\"1\":{\"492\":1}}],[\"我们也可以添加where字句来限定查询目标\",{\"1\":{\"490\":1}}],[\"我们也可以一次性向数据库中插入多条数据\",{\"1\":{\"482\":1}}],[\"我们也可以定义多个\",{\"1\":{\"281\":1}}],[\"我们也可以定义泛型方法\",{\"1\":{\"14\":1}}],[\"我们也可以手动指定名称\",{\"1\":{\"678\":1}}],[\"我们也可以手动指定版本\",{\"1\":{\"132\":1}}],[\"我们也可以手动添加一个\",{\"1\":{\"571\":1}}],[\"我们也可以手动声明\",{\"1\":{\"9\":1}}],[\"我们也可以使用where来添加条件\",{\"1\":{\"484\":1}}],[\"我们也可以使用default关键字来为这些属性指定默认值\",{\"1\":{\"207\":1}}],[\"我们也可以使用stop\",{\"1\":{\"142\":1}}],[\"我们也可以使用scanner来扫描其他的输入流\",{\"1\":{\"128\":1}}],[\"我们也可以使用泛型来表示\",{\"1\":{\"14\":1}}],[\"我们也可以让它向文件中打印\",{\"1\":{\"127\":1}}],[\"我们也可以寻找子集合的位置\",{\"1\":{\"80\":1}}],[\"我们也可以将一个可修改的集合变成只读的集合\",{\"1\":{\"79\":1}}],[\"我们也可以对集合的元素进行快速填充\",{\"1\":{\"78\":1}}],[\"我们也可以只通过stream来完成所有数字的和\",{\"1\":{\"71\":1}}],[\"我们也可以为这种情况添加一个预备方案\",{\"1\":{\"57\":1}}],[\"我们也可以为构造方法设定参数\",{\"1\":{\"9\":1}}],[\"我们也可以自定义我们想要的日志打印格式\",{\"1\":{\"672\":1}}],[\"我们也可以自定义排序规则\",{\"1\":{\"50\":1}}],[\"我们也可以自定义比较规则\",{\"1\":{\"46\":1}}],[\"我们也可以在类中添加代码块\",{\"1\":{\"9\":1}}],[\"我们也可以不对任何对象进行引用\",{\"1\":{\"4\":1}}],[\"我们从\",{\"1\":{\"186\":1}}],[\"我们从开始\",{\"1\":{\"138\":1}}],[\"我们前面提到的stop\",{\"1\":{\"144\":1}}],[\"我们前面创建对象\",{\"1\":{\"9\":1}}],[\"我们需要进行配置\",{\"1\":{\"679\":1}}],[\"我们需要同时调整handler和logger的level属性\",{\"1\":{\"640\":1}}],[\"我们需要先创建一个类编写我们的动态sql操作\",{\"1\":{\"630\":1}}],[\"我们需要先修改访问权限\",{\"1\":{\"191\":1}}],[\"我们需要手动为其起个别名\",{\"1\":{\"583\":1}}],[\"我们需要配置一个collection标签来让其可以正确处理关联的集合结果\",{\"1\":{\"581\":1}}],[\"我们需要修改一下配置文件中的mapper文件目录\",{\"1\":{\"570\":1}}],[\"我们需要导入mybatis的依赖\",{\"1\":{\"552\":1}}],[\"我们需要一种更加简洁高效的方式来和数据库进行交互\",{\"1\":{\"544\":1}}],[\"我们需要一种更加安全的机制来维持秩序\",{\"1\":{\"154\":1}}],[\"我们需要提前给到preparedstatement一个sql语句\",{\"1\":{\"533\":1}}],[\"我们需要更多的用户来一起管理整个数据库\",{\"1\":{\"499\":1}}],[\"我们需要创建什么样子的表\",{\"1\":{\"462\":1}}],[\"我们需要从经验池\",{\"1\":{\"427\":1}}],[\"我们需要思考使用\",{\"1\":{\"389\":1}}],[\"我们需要保证策略是不断提升\",{\"1\":{\"353\":1}}],[\"我们需要找到一个\",{\"1\":{\"311\":1}}],[\"我们需要在映射器xml文件中添加\",{\"1\":{\"612\":1}}],[\"我们需要在resultmap中完整编写需要查询对象的属性对应关系以及在collection中编写关联查询的集合内类型相关属性对应关系\",{\"1\":{\"581\":1}}],[\"我们需要在java程序启动时\",{\"1\":{\"552\":1}}],[\"我们需要在里面添加1\",{\"1\":{\"281\":1}}],[\"我们需要在虚拟机参数中手动开启一下\",{\"1\":{\"268\":1}}],[\"我们需要在使用时手动指定注解的属性名称\",{\"1\":{\"207\":1}}],[\"我们需要用到反射机制\",{\"1\":{\"208\":1}}],[\"我们需要明确指定一下\",{\"1\":{\"120\":1}}],[\"我们需要结合具体的场景来决定\",{\"1\":{\"25\":1}}],[\"我们将\",{\"1\":{\"423\":1}}],[\"我们将类放到包中\",{\"1\":{\"120\":1}}],[\"我们将变量p2赋值为p1的值\",{\"1\":{\"4\":1}}],[\"我们之前在学习mybatis的时候学习了xml\",{\"1\":{\"664\":1}}],[\"我们之前在计算机组成原理中可能学习过缓存一致性问题\",{\"1\":{\"616\":1}}],[\"我们之前的例子就失效了\",{\"1\":{\"533\":1}}],[\"我们之前使用了executequery\",{\"1\":{\"519\":1}}],[\"我们之前使用的都是通过构造方法直接连接服务端\",{\"1\":{\"449\":1}}],[\"我们之前学习的类就是对现实世界数据的一种抽象\",{\"1\":{\"461\":1}}],[\"我们之前都是直接创建的类\",{\"1\":{\"120\":1}}],[\"我们之前一个结点只有键\",{\"1\":{\"58\":1}}],[\"我们实际上是将\",{\"1\":{\"118\":1}}],[\"我们并不会通过一个具体的对象去修改和使用静态属性\",{\"1\":{\"117\":1}}],[\"我们发现这个接口中定义了大量数据库操作的方法\",{\"1\":{\"553\":1}}],[\"我们发现除了普通的statement\",{\"1\":{\"518\":1}}],[\"我们发现浏览器是无法打开这个链接的\",{\"1\":{\"455\":1}}],[\"我们发现type实际上是class类的父接口\",{\"1\":{\"186\":1}}],[\"我们发现实际上效果是相同的\",{\"1\":{\"155\":1}}],[\"我们发现\",{\"1\":{\"147\":1,\"148\":1,\"156\":1,\"173\":1,\"192\":1,\"227\":1,\"501\":1,\"519\":1,\"532\":1,\"533\":3,\"538\":2,\"552\":1,\"570\":1,\"593\":1,\"636\":1,\"677\":1}}],[\"我们发现虽然后面的部分没有保存\",{\"1\":{\"108\":1}}],[\"我们发现得到的是一个optional类实例\",{\"1\":{\"71\":1}}],[\"我们惊奇地发现\",{\"1\":{\"80\":1}}],[\"我们想快速求得list中的最大值和最小值\",{\"1\":{\"76\":1}}],[\"我们想让每一个元素通过\",{\"1\":{\"71\":1}}],[\"我们想要遍历一个集合中所有的元素\",{\"1\":{\"33\":1}}],[\"我们用一堆随机数来进行更多流操作的演示\",{\"1\":{\"71\":1}}],[\"我们用就完事\",{\"1\":{\"60\":1}}],[\"我们还需要单独编写一个类来做这种事情\",{\"1\":{\"630\":1}}],[\"我们还需要理解其所描述的最优策略π∗\",{\"1\":{\"341\":1}}],[\"我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题\",{\"1\":{\"60\":1}}],[\"我们还可以使用注解进行动态sql的配置\",{\"1\":{\"630\":1}}],[\"我们还可以使用\",{\"1\":{\"540\":1}}],[\"我们还可以使用executeupdate\",{\"1\":{\"519\":1}}],[\"我们还可以使用方法引用\",{\"1\":{\"257\":1}}],[\"我们还可以添加having来限制分组条件\",{\"1\":{\"494\":1}}],[\"我们还可以在注解中定义一些属性\",{\"1\":{\"207\":1}}],[\"我们还可以在当前线程的工作不重要时\",{\"1\":{\"147\":1}}],[\"我们还可以对byte\",{\"1\":{\"199\":1}}],[\"我们还可以通过flat来对整个流进行进一步细分\",{\"1\":{\"71\":1}}],[\"我们还会回来看我们\",{\"1\":{\"50\":1}}],[\"我们只能关闭所有二级缓存\",{\"1\":{\"616\":1}}],[\"我们只能通过\",{\"1\":{\"382\":1}}],[\"我们只能使用对应的包装类\",{\"1\":{\"281\":1}}],[\"我们只能去创建它的子类对象\",{\"1\":{\"218\":1}}],[\"我们只能把它当做一个不得已才去使用的工具\",{\"1\":{\"193\":1}}],[\"我们只能简单的删除\",{\"1\":{\"48\":1}}],[\"我们只需要继承formatter类\",{\"1\":{\"672\":1}}],[\"我们只需要直接在其中编写sql语句即可\",{\"1\":{\"624\":1}}],[\"我们只需要直接拿来用就行了\",{\"1\":{\"23\":1}}],[\"我们只需要编写对应的映射器\",{\"1\":{\"621\":1}}],[\"我们只需要让查询出来的每一个用户都左连接分组信息即可\",{\"1\":{\"583\":1}}],[\"我们只需要告诉一个映射关系\",{\"1\":{\"554\":1}}],[\"我们只需要挑选在当前迭代下最大的\",{\"1\":{\"348\":1}}],[\"我们只需要在创建sqlsession时进行一些配置即可\",{\"1\":{\"599\":1}}],[\"我们只需要在mybatis的配置文件中进行编写即可\",{\"1\":{\"560\":1}}],[\"我们只需要在一张表中去查找数据即可\",{\"1\":{\"490\":1}}],[\"我们只需要在当前状态下\",{\"1\":{\"342\":1}}],[\"我们只需要在类名前面把完整的包名也给写上\",{\"1\":{\"120\":1}}],[\"我们只需要使用\",{\"1\":{\"5\":1}}],[\"我们在配置\",{\"1\":{\"629\":1}}],[\"我们在配置文件中添加这个mapper映射器\",{\"1\":{\"554\":1}}],[\"我们在查询时\",{\"1\":{\"610\":1}}],[\"我们在查询时mybatis就可以自动把额外信息也封装好了\",{\"1\":{\"578\":1}}],[\"我们在里面写入了一个select标签\",{\"1\":{\"554\":1}}],[\"我们在移动行数后\",{\"1\":{\"525\":1}}],[\"我们在方法中使用待确定类型的变量时\",{\"1\":{\"281\":1}}],[\"我们在重写方法时\",{\"1\":{\"266\":1}}],[\"我们在重写父类方法时\",{\"1\":{\"216\":1}}],[\"我们在之前其实已经接触过一些异常了\",{\"1\":{\"264\":1}}],[\"我们在编写程序时\",{\"1\":{\"156\":1}}],[\"我们在自己的包中也建一个名为string的类\",{\"1\":{\"120\":1}}],[\"我们在\",{\"1\":{\"118\":1}}],[\"我们在前面介绍了arrays\",{\"1\":{\"75\":1}}],[\"我们在创建时可以设定编码格式\",{\"1\":{\"477\":1}}],[\"我们在创建时\",{\"1\":{\"62\":1}}],[\"我们在正常插入一个键值对时\",{\"1\":{\"60\":1}}],[\"我们在获取所有键和所有值时\",{\"1\":{\"57\":1}}],[\"我们在获取一个不存在的映射时\",{\"1\":{\"57\":1}}],[\"我们在这里先不去探讨实现原理\",{\"1\":{\"48\":1}}],[\"我们在使用注解传参时\",{\"1\":{\"207\":1}}],[\"我们在使用\",{\"1\":{\"25\":1}}],[\"我们的内容是没有进入到数据库的\",{\"1\":{\"593\":1}}],[\"我们的数据插入后使用的是一个自增主键id\",{\"1\":{\"590\":1}}],[\"我们的数据可以交给数据库来帮助我们进行管理\",{\"1\":{\"460\":1}}],[\"我们的查询操作可能需要不止一个参数\",{\"1\":{\"571\":1}}],[\"我们的每一个异常也是一个类\",{\"1\":{\"264\":1}}],[\"我们的包就可以命名为com\",{\"1\":{\"120\":1}}],[\"我们的元素之间是两两对应的\",{\"1\":{\"55\":1}}],[\"我们的插入顺序虽然是10\",{\"1\":{\"46\":1}}],[\"我们的方法需要能够同时应对多种情况\",{\"1\":{\"8\":1}}],[\"我们会继续学习redis\",{\"1\":{\"616\":1}}],[\"我们会发现\",{\"1\":{\"554\":1,\"569\":1}}],[\"我们会使用接口的引用\",{\"1\":{\"25\":1}}],[\"我们会在日志中惊奇地发现\",{\"1\":{\"611\":1}}],[\"我们会在第六章多线程部分中讲解\",{\"1\":{\"215\":1}}],[\"我们会在第五章集合类中使用到\",{\"1\":{\"215\":1}}],[\"我们会在jvm篇视频教程中进行介绍\",{\"1\":{\"215\":1}}],[\"我们会在下一章多线程部分中进行介绍\",{\"1\":{\"23\":2}}],[\"我们会在后面讲解\",{\"1\":{\"554\":1}}],[\"我们会在后面继续了解\",{\"1\":{\"142\":1}}],[\"我们会在后面进行详细介绍\",{\"1\":{\"25\":1}}],[\"我们会在后面进行讲解\",{\"1\":{\"23\":1}}],[\"我们会在后面进行介绍\",{\"1\":{\"23\":1}}],[\"我们会在后面介绍\",{\"1\":{\"23\":1}}],[\"我们就暂时介绍到这里\",{\"1\":{\"632\":1}}],[\"我们就提到过批量执行语句的问题\",{\"1\":{\"599\":1}}],[\"我们就告诉了mybatis我们链接数据库的一些信息\",{\"1\":{\"552\":1}}],[\"我们就需要使用mybatis提前帮助我们规定好的标签来进行配置\",{\"1\":{\"552\":1}}],[\"我们就需要使用到泛型的上界定义\",{\"1\":{\"15\":1}}],[\"我们就需要执行大量的sql语句来完成\",{\"1\":{\"510\":1}}],[\"我们就需要了解数据库的关系规范化\",{\"1\":{\"463\":1}}],[\"我们就能很好地理清不同数据模型之间的关系和特点\",{\"1\":{\"461\":1}}],[\"我们就能快速得到文件的所有信息\",{\"1\":{\"98\":1}}],[\"我们就来尝试定义一个自己的注解\",{\"1\":{\"206\":1}}],[\"我们就将此class文件读取并解析为class了\",{\"1\":{\"199\":1}}],[\"我们就可以更加谨慎地进行一些操作了\",{\"1\":{\"534\":1}}],[\"我们就可以更加灵活地控制泛型的具体类型范围\",{\"1\":{\"15\":1}}],[\"我们就可以删除此触发器\",{\"1\":{\"509\":1}}],[\"我们就可以很好地存储这样带有一定联系的数据\",{\"1\":{\"461\":1}}],[\"我们就可以获取到对应的i\",{\"1\":{\"448\":1}}],[\"我们就可以通过使用外连接来进行查询\",{\"1\":{\"497\":1}}],[\"我们就可以通过\",{\"1\":{\"389\":1}}],[\"我们就可以得到\",{\"1\":{\"384\":1}}],[\"我们就可以实现两台计算机之间的通信\",{\"1\":{\"446\":1}}],[\"我们就可以实现外部加载甚至是网络加载一个类\",{\"1\":{\"199\":1}}],[\"我们就可以实现对集合中的元素的进行遍历\",{\"1\":{\"31\":1}}],[\"我们就可以直接通过set\",{\"1\":{\"193\":1}}],[\"我们就可以使用select语句来直接查询视图上的数据了\",{\"1\":{\"507\":1}}],[\"我们就可以使用biginteger来完成\",{\"1\":{\"229\":1}}],[\"我们就可以使用inputstreamreader来帮助我们实现\",{\"1\":{\"126\":1}}],[\"我们就可以使用\",{\"1\":{\"71\":1}}],[\"我们就可以把一个\",{\"1\":{\"71\":1}}],[\"我们就可以自定义\",{\"1\":{\"14\":1}}],[\"我们可以对cache标签进行一些配置\",{\"1\":{\"612\":1}}],[\"我们可以对一个集合进行二分搜索\",{\"1\":{\"77\":1}}],[\"我们可以来尝试自己配置一个用于控制台打印的handler处理器\",{\"1\":{\"647\":1}}],[\"我们可以来试验一下\",{\"1\":{\"611\":1}}],[\"我们可以来测试一下\",{\"1\":{\"44\":1}}],[\"我们可以提前将一部分内容放入缓存\",{\"1\":{\"610\":1}}],[\"我们可以提前准备好合适容量的byte数组来存放\",{\"1\":{\"91\":1}}],[\"我们可以像这样进行编写\",{\"1\":{\"602\":1}}],[\"我们可以在主类中使用日志打印\",{\"1\":{\"636\":1}}],[\"我们可以在获取sqlsession关闭自动提交来开启事务模式\",{\"1\":{\"593\":1}}],[\"我们可以在收到中断信号后\",{\"1\":{\"144\":1}}],[\"我们可以开启mybatis的日志来观察具体执行的操作\",{\"1\":{\"580\":1}}],[\"我们可以尝试接着来写一个同时查询id和年龄的查询操作\",{\"1\":{\"562\":1}}],[\"我们可以尝试让服务端一直运行来不断接受客户端的连接\",{\"1\":{\"447\":1}}],[\"我们可以添加一些用于条件判断的标签到xml的sql语句中\",{\"1\":{\"601\":1}}],[\"我们可以添加\",{\"1\":{\"540\":1}}],[\"我们可以添加transient关键字\",{\"1\":{\"133\":1}}],[\"我们可以断点调试一下\",{\"1\":{\"517\":1}}],[\"我们可以打开idea的数据库连接配置\",{\"1\":{\"516\":1}}],[\"我们可以这样来查看支持的引擎\",{\"1\":{\"510\":1}}],[\"我们可以手动编写一个带调试信息的无参构造\",{\"1\":{\"569\":1}}],[\"我们可以手动配一个resultmap来解决这种问题\",{\"1\":{\"563\":1}}],[\"我们可以手动为驱动管理器添加一个日志打印\",{\"1\":{\"517\":1}}],[\"我们可以手动调整其大小来优化传输效率\",{\"1\":{\"449\":1}}],[\"我们可以手动关闭单向的流\",{\"1\":{\"449\":1}}],[\"我们可以认为\",{\"1\":{\"435\":1}}],[\"我们可以写出\",{\"1\":{\"398\":1}}],[\"我们可以修改为噪音\",{\"1\":{\"384\":1}}],[\"我们可以设计如下方程\",{\"1\":{\"384\":1}}],[\"我们可以确保其可以遍历所有的\",{\"1\":{\"371\":1}}],[\"我们可以生成一个\",{\"1\":{\"363\":1}}],[\"我们可以生成一个统计实例来帮助我们快速进行统计\",{\"1\":{\"71\":1}}],[\"我们可以很轻松的求出各个情况下的q\",{\"1\":{\"362\":1}}],[\"我们可以分析出在该状态下采取哪个\",{\"1\":{\"333\":1}}],[\"我们可以选择在实现类明确泛型类型\",{\"1\":{\"282\":1}}],[\"我们可以下面的方式实现多种字符匹配\",{\"1\":{\"246\":1}}],[\"我们可以让他等于一个非常大的数字\",{\"1\":{\"229\":1}}],[\"我们可以快速获取到我们标记的注解\",{\"1\":{\"208\":1}}],[\"我们可以快速生成一个只读的list\",{\"1\":{\"25\":1}}],[\"我们可以发现\",{\"1\":{\"193\":1,\"515\":1}}],[\"我们可以获取到类中所有声明为public的方法\",{\"1\":{\"192\":1}}],[\"我们可以把这个容器想象成是一个货架\",{\"1\":{\"174\":1}}],[\"我们可以利用jstack命令来检测死锁\",{\"1\":{\"156\":1}}],[\"我们可以为成员变量\",{\"1\":{\"121\":1}}],[\"我们可以理解为是属于这个类的\",{\"1\":{\"117\":1}}],[\"我们可以通过一个注解快速生成构造方法\",{\"1\":{\"677\":1}}],[\"我们可以通过一些特定的算法进行求解\",{\"1\":{\"381\":1}}],[\"我们可以通过logger的getparent方法来获取其父logger对象\",{\"1\":{\"655\":1}}],[\"我们可以通过limit来限制查询的数量\",{\"1\":{\"494\":1}}],[\"我们可以通过gethandlers方法来获取logger对象中已经配置的handler对象\",{\"1\":{\"646\":1}}],[\"我们可以通过配置来进行调整\",{\"1\":{\"639\":1}}],[\"我们可以通过二级缓存来实现\",{\"1\":{\"612\":1}}],[\"我们可以通过sqlsessionfactory来创建多个新的会话\",{\"1\":{\"553\":1}}],[\"我们可以通过添加\",{\"1\":{\"540\":2}}],[\"我们可以通过下面的命令创建索引\",{\"1\":{\"508\":1}}],[\"我们可以通过使用getresultset\",{\"1\":{\"519\":1}}],[\"我们可以通过使用grant来为一个数据库用户进行授权\",{\"1\":{\"502\":1}}],[\"我们可以通过使用delete来删除表中的数据\",{\"1\":{\"484\":1}}],[\"我们可以通过\",{\"1\":{\"500\":1}}],[\"我们可以通过order\",{\"1\":{\"492\":1}}],[\"我们可以通过update语句来更新表中的数据\",{\"1\":{\"483\":1}}],[\"我们可以通过drop\",{\"1\":{\"480\":1}}],[\"我们可以通过add来添加一个新的列\",{\"1\":{\"479\":1}}],[\"我们可以通过alter\",{\"1\":{\"479\":1}}],[\"我们可以通过create\",{\"1\":{\"477\":1,\"500\":1,\"507\":1}}],[\"我们可以通过java来实现socket通信\",{\"1\":{\"446\":1}}],[\"我们可以通过前面所引入的\",{\"1\":{\"362\":1}}],[\"我们可以通过对应的迭代算法来求解贝尔曼最优公式\",{\"1\":{\"347\":1}}],[\"我们可以通过对象的引用来间接操作对象\",{\"1\":{\"4\":1}}],[\"我们可以通过类名直接使用\",{\"1\":{\"272\":1}}],[\"我们可以通过method对象的invoke\",{\"1\":{\"192\":1}}],[\"我们可以通过反射来无视权限修饰符\",{\"1\":{\"192\":1}}],[\"我们可以通过反射来调用类的方法\",{\"1\":{\"192\":1}}],[\"我们可以通过反射机制\",{\"1\":{\"179\":1}}],[\"我们可以通过调用getclass\",{\"1\":{\"570\":1}}],[\"我们可以通过调用getconnection\",{\"1\":{\"517\":1}}],[\"我们可以通过调用setsotimeout\",{\"1\":{\"449\":1}}],[\"我们可以通过调用foreachordered\",{\"1\":{\"173\":1}}],[\"我们可以通过调用cancel\",{\"1\":{\"167\":1}}],[\"我们可以通过此对象来创建任意类型的定时任务\",{\"1\":{\"166\":1}}],[\"我们可以通过创建一个timer类来让它进行定时任务调度\",{\"1\":{\"166\":1}}],[\"我们可以通过包的形式将这些类进行分类存放\",{\"1\":{\"120\":1}}],[\"我们可以通过它来获取文件的输入流\",{\"1\":{\"90\":1}}],[\"我们可以非常高效的从\",{\"1\":{\"48\":1}}],[\"我们可以直接使用一个静态变量log\",{\"1\":{\"678\":1}}],[\"我们可以直接使用foreach语法来快速遍历集合类\",{\"1\":{\"34\":1}}],[\"我们可以直接删除掉所有的mapper\",{\"1\":{\"621\":1}}],[\"我们可以直接让一个user对象作为参数传入\",{\"1\":{\"589\":1}}],[\"我们可以直接将其设置回去\",{\"1\":{\"534\":1}}],[\"我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值\",{\"1\":{\"227\":1}}],[\"我们可以直接将一个\",{\"1\":{\"43\":1}}],[\"我们可以直接创建静态内部类的对象\",{\"1\":{\"252\":1}}],[\"我们可以直接在类的内部定义成员内部类\",{\"1\":{\"251\":1}}],[\"我们可以直接通过接口名\",{\"1\":{\"219\":1}}],[\"我们可以直接通过method对象来获取这些信息\",{\"1\":{\"192\":1}}],[\"我们可以直接传入一个值\",{\"1\":{\"207\":1}}],[\"我们可以将查询的结果作为另一个查询的条件\",{\"1\":{\"498\":1}}],[\"我们可以将此数据库删除\",{\"1\":{\"477\":1}}],[\"我们可以将书籍信息进行单独拆分为另一张表\",{\"1\":{\"466\":1}}],[\"我们可以将该问题定义为一个\",{\"1\":{\"395\":1}}],[\"我们可以将这个问题可以转化为一个随机变量的方法\",{\"1\":{\"390\":1}}],[\"我们可以将这个只读的列表作为参数传入\",{\"1\":{\"25\":1}}],[\"我们可以将\",{\"1\":{\"386\":1,\"388\":1,\"389\":1}}],[\"我们可以将一个类定义为一个泛型类\",{\"1\":{\"281\":1}}],[\"我们可以将其名字设定为value\",{\"1\":{\"207\":1}}],[\"我们可以将方法标记为静态\",{\"1\":{\"117\":1}}],[\"我们可以将各种需要初始化的操作都在这里进行处理\",{\"1\":{\"9\":1}}],[\"我们可以使用此框架来实现日志的规范化打印\",{\"1\":{\"636\":1}}],[\"我们可以使用动态sql来一次性生成一个批量操作的sql语句\",{\"1\":{\"600\":1}}],[\"我们可以使用一个map\",{\"1\":{\"562\":1}}],[\"我们可以使用一个特殊的名字表示泛型\",{\"1\":{\"281\":1}}],[\"我们可以使用preparedstatement来解决\",{\"1\":{\"533\":1}}],[\"我们可以使用pow方法直接计算a的b次方\",{\"1\":{\"274\":1}}],[\"我们可以使用revoke来收回一个权限\",{\"1\":{\"502\":1}}],[\"我们可以使用断言表达式来对某些东西进行判断\",{\"1\":{\"268\":1}}],[\"我们可以使用append方法来讲字符串拼接到后面\",{\"1\":{\"245\":1}}],[\"我们可以使用它来对字符串进行拼接\",{\"1\":{\"245\":1}}],[\"我们可以使用getconstructor\",{\"1\":{\"191\":1}}],[\"我们可以使用threadlocal类\",{\"1\":{\"162\":1}}],[\"我们可以使用join\",{\"1\":{\"148\":1}}],[\"我们可以使用\",{\"1\":{\"9\":1,\"49\":1,\"57\":1,\"120\":1,\"625\":1,\"626\":1}}],[\"我们可以进行一次重载\",{\"1\":{\"8\":1}}],[\"修改默认情况下的打印等级\",{\"0\":{\"656\":1}}],[\"修改输出格式\",{\"0\":{\"649\":1}}],[\"修改日志的默认打印级别\",{\"0\":{\"640\":1}}],[\"修改对应\",{\"0\":{\"673\":1}}],[\"修改对应接口+注解\",{\"0\":{\"623\":1}}],[\"修改对象的属性\",{\"1\":{\"4\":1}}],[\"修改\",{\"0\":{\"591\":1}}],[\"修改语法树\",{\"1\":{\"539\":1}}],[\"修改数据\",{\"0\":{\"483\":1}}],[\"修改表\",{\"0\":{\"479\":1}}],[\"修改为\",{\"1\":{\"427\":1}}],[\"修改类的属性\",{\"0\":{\"193\":1}}],[\"修改访问权限\",{\"1\":{\"191\":1}}],[\"修改变量\",{\"1\":{\"191\":1}}],[\"修改键值对的值\",{\"1\":{\"56\":1}}],[\"修改相关操作\",{\"1\":{\"56\":1}}],[\"修改一个对象的属性并不会影响到其他对象\",{\"1\":{\"4\":1}}],[\"访问第三行第二列的元素\",{\"1\":{\"240\":1}}],[\"访问元素\",{\"0\":{\"237\":1}}],[\"访问权限控制\",{\"0\":{\"121\":1}}],[\"访问类的静态变量\",{\"1\":{\"118\":1}}],[\"访问\",{\"1\":{\"4\":1}}],[\"如梯度上升算法\",{\"1\":{\"433\":1}}],[\"如可以在target\",{\"1\":{\"304\":1}}],[\"如p\",{\"1\":{\"304\":1}}],[\"如a\",{\"1\":{\"299\":1}}],[\"如何设计一个优良的关系模型是最关键的内容\",{\"1\":{\"463\":1}}],[\"如何估计\",{\"0\":{\"363\":1}}],[\"如何将定义好的xml文件读取到java程序中\",{\"1\":{\"547\":1}}],[\"如何将\",{\"1\":{\"361\":1}}],[\"如何在没有模型\",{\"1\":{\"360\":1}}],[\"如何确保策略\",{\"1\":{\"353\":1}}],[\"如何通过\",{\"1\":{\"353\":1}}],[\"如何处理等式右边的\",{\"0\":{\"342\":1}}],[\"如何求解\",{\"0\":{\"341\":1}}],[\"如何得到最优策略\",{\"1\":{\"338\":1}}],[\"如何才能很好的去存可能出现的两种类型呢\",{\"1\":{\"280\":1}}],[\"如何获取我们编写的注解\",{\"1\":{\"208\":1}}],[\"如cas算法\",{\"1\":{\"155\":1}}],[\"如等待io请求\",{\"1\":{\"143\":1}}],[\"如读取和写入文本文件\",{\"1\":{\"88\":1}}],[\"如下\",{\"1\":{\"84\":1}}],[\"如果发现有默认配置优先使用配置里面的\",{\"1\":{\"667\":1}}],[\"如果发现其父类\",{\"1\":{\"204\":1}}],[\"如果将打印等级配置为off\",{\"1\":{\"640\":1}}],[\"如果遇到了多个参数的情况\",{\"1\":{\"630\":1}}],[\"如果对这种复杂查询有着一定需求的话\",{\"1\":{\"629\":1}}],[\"如果对于\",{\"1\":{\"381\":1}}],[\"如果mybatis缓存中存在数据\",{\"1\":{\"610\":1}}],[\"如果查询的id大于3\",{\"1\":{\"601\":1}}],[\"如果你还是觉得这种方式配置起来不如之前方便\",{\"1\":{\"627\":1}}],[\"如果你使用过\",{\"1\":{\"600\":1}}],[\"如果你实在需要使用对应的属性名称\",{\"1\":{\"571\":1}}],[\"如果你不需要转换为实体类\",{\"1\":{\"561\":1}}],[\"如果你觉得像这样每次都要写一个完整的类名太累了\",{\"1\":{\"560\":1}}],[\"如果你学习过sql的话\",{\"1\":{\"71\":1}}],[\"如果之前的配置文件编写错误\",{\"1\":{\"552\":1}}],[\"如果嫌一个一个改太麻烦\",{\"1\":{\"546\":1}}],[\"如果注解处理器产生了新的源文件\",{\"1\":{\"539\":1}}],[\"如果前面任何操作出现异常\",{\"1\":{\"534\":1}}],[\"如果单纯地使用statement来执行sql命令\",{\"1\":{\"533\":1}}],[\"如果允许这样的数据插入\",{\"1\":{\"532\":1}}],[\"如果成功就返回对应的\",{\"1\":{\"517\":1}}],[\"如果加载会提示\",{\"1\":{\"516\":1}}],[\"如果更新视图中的数据\",{\"1\":{\"507\":1}}],[\"如果忘记添加where字句来限定条件\",{\"1\":{\"483\":1}}],[\"如果修改管理员id\",{\"1\":{\"467\":1}}],[\"如果修改了a\",{\"1\":{\"256\":1}}],[\"如果设置了keeplive为\",{\"1\":{\"449\":1}}],[\"如果连接的双方发生意外而通知不到对方\",{\"1\":{\"449\":1}}],[\"如果接收端读取的是\",{\"1\":{\"448\":1}}],[\"如果服务端是\",{\"1\":{\"448\":1}}],[\"如果ϵ=1\",{\"1\":{\"372\":1}}],[\"如果经过了\",{\"1\":{\"369\":1}}],[\"如果从其他状态出发\",{\"1\":{\"369\":1}}],[\"如果该\",{\"1\":{\"366\":1}}],[\"如果γ接近0\",{\"1\":{\"304\":1}}],[\"如果agent在当前时刻t所执行的动作能够提高总mos\",{\"1\":{\"298\":1}}],[\"如果使用之前的selectone会导致异常\",{\"1\":{\"564\":1}}],[\"如果使用通配符\",{\"1\":{\"281\":1}}],[\"如果使用该方法\",{\"1\":{\"204\":1}}],[\"如果要存放基本数据类型的值\",{\"1\":{\"281\":1}}],[\"如果要让某个变量支持引用确定了任意类型的泛型\",{\"1\":{\"281\":1}}],[\"如果要往里面写入内容\",{\"1\":{\"126\":1}}],[\"如果类型不符合\",{\"1\":{\"281\":1}}],[\"如果大于10就抛出错误\",{\"1\":{\"268\":1}}],[\"如果\",{\"1\":{\"268\":1,\"381\":1}}],[\"如果判断失败会抛出错误\",{\"1\":{\"268\":1}}],[\"如果已经是主方法了\",{\"1\":{\"267\":1}}],[\"如果父类中的方法表明了会抛出某个异常\",{\"1\":{\"266\":1}}],[\"如果父类的方法是\",{\"1\":{\"216\":1}}],[\"如果传入了错误的参数导致程序无法正常运行\",{\"1\":{\"266\":1}}],[\"如果传入的对象为null\",{\"1\":{\"216\":1}}],[\"如果参数只有一个\",{\"1\":{\"257\":1}}],[\"如果不开启会直接覆盖重写\",{\"1\":{\"648\":1}}],[\"如果不满足\",{\"1\":{\"601\":1}}],[\"如果不自动提交\",{\"1\":{\"558\":1}}],[\"如果不需要\",{\"1\":{\"509\":1}}],[\"如果不经比较就很容易出现类型转换异常\",{\"1\":{\"280\":1}}],[\"如果不同的分支条件会出现不同的异常\",{\"1\":{\"266\":1}}],[\"如果不进行处理\",{\"1\":{\"264\":1}}],[\"如果不是\",{\"1\":{\"256\":1}}],[\"如果不加以限制\",{\"1\":{\"71\":1}}],[\"如果想用外部变量\",{\"1\":{\"256\":1}}],[\"如果想通过对象的形式去使用他们\",{\"1\":{\"226\":1}}],[\"如果直接使用加的话\",{\"1\":{\"245\":1}}],[\"如果程序中大量进行字符串的拼接似乎不太好\",{\"1\":{\"245\":1}}],[\"如果内容相同\",{\"1\":{\"244\":1}}],[\"如果同时存在其他参数\",{\"1\":{\"241\":1}}],[\"如果在最后添加了with\",{\"1\":{\"502\":1}}],[\"如果在插入数据时没有为该列提供值\",{\"1\":{\"475\":1}}],[\"如果在范围内\",{\"1\":{\"227\":1}}],[\"如果在向下找的过程中发现已经存在相同键的键值对了\",{\"1\":{\"59\":1}}],[\"如果值相同\",{\"1\":{\"227\":1}}],[\"如果方法体中只有一个返回语句\",{\"1\":{\"257\":1}}],[\"如果方法在接口中存在默认实现\",{\"1\":{\"219\":1}}],[\"如果方法内没有变量出现重名的情况\",{\"1\":{\"7\":1}}],[\"如果抽象方法在抽象类定义的是\",{\"1\":{\"218\":1}}],[\"如果子类是一个普通类\",{\"1\":{\"282\":1}}],[\"如果子类都访问不了\",{\"1\":{\"218\":1}}],[\"如果子线程修改了也是可以\",{\"1\":{\"163\":1}}],[\"如果希望调用父类原本的方法实现\",{\"1\":{\"216\":1}}],[\"如果数组里面只有一个内容\",{\"1\":{\"207\":1}}],[\"如果实在是需要使用别人定义为private的方法\",{\"1\":{\"192\":1}}],[\"如果这种情况\",{\"1\":{\"186\":1}}],[\"如果这个位置上什么都没有\",{\"1\":{\"59\":1}}],[\"如果一个会话结束\",{\"1\":{\"611\":1}}],[\"如果一个方法的参数需要的是一个接口的实现\",{\"1\":{\"257\":1}}],[\"如果一个接口中有且只有一个待实现的抽象方法\",{\"1\":{\"257\":1}}],[\"如果一个类的父类是泛型\",{\"1\":{\"186\":1}}],[\"如果一个包中有多个类\",{\"1\":{\"120\":1}}],[\"如果两个表中都带有此属性\",{\"1\":{\"495\":1}}],[\"如果两个线程同时执行\",{\"1\":{\"173\":1}}],[\"如果两个对象通过\",{\"1\":{\"84\":1}}],[\"如果两个对象使用equals方法相等\",{\"1\":{\"25\":1}}],[\"如果有一个参数和返回值的话\",{\"1\":{\"257\":1}}],[\"如果有初始值\",{\"1\":{\"217\":1}}],[\"如果有任务依次执行\",{\"1\":{\"167\":1}}],[\"如果有就可以继续获取到下一个元素\",{\"1\":{\"34\":1}}],[\"如果没有commit\",{\"1\":{\"612\":1}}],[\"如果没有其他线程唤醒自己\",{\"1\":{\"161\":1}}],[\"如果没有出现歧义\",{\"1\":{\"120\":1}}],[\"如果resume\",{\"1\":{\"156\":1}}],[\"如果仅仅是读取还好\",{\"1\":{\"154\":1}}],[\"如果存在多台服务器或者是多个程序都在使用mybatis操作同一个数据库\",{\"1\":{\"616\":1}}],[\"如果存在一个\",{\"1\":{\"369\":1}}],[\"如果存在\",{\"1\":{\"144\":1}}],[\"如果我和我的朋友同时在银行取我账户里面的钱\",{\"1\":{\"154\":1}}],[\"如果我希望两个任务同时进行\",{\"1\":{\"138\":1}}],[\"如果我们现在需要全面使用日志系统\",{\"1\":{\"677\":1}}],[\"如果我们在不屏蔽父级handler的情况下为子级配置一个handler\",{\"1\":{\"657\":1}}],[\"如果我们在提交事务之前\",{\"1\":{\"593\":1}}],[\"如果我们在方法中抛出了一个非运行时异常\",{\"1\":{\"266\":1}}],[\"如果我们的类中存在其他的构造方法覆盖掉默认的无参构造\",{\"1\":{\"569\":1}}],[\"如果我们的服务器要支持响应http请求\",{\"1\":{\"455\":1}}],[\"如果我们创建错误了\",{\"1\":{\"477\":1}}],[\"如果我们不希望服务端等待太长的时间\",{\"1\":{\"449\":1}}],[\"如果我们不希望某些属性参与到序列化中进行保存\",{\"1\":{\"133\":1}}],[\"如果我们强制让\",{\"1\":{\"409\":1}}],[\"如果我们要捕获的异常\",{\"1\":{\"267\":1}}],[\"如果我们要使用成员内部类\",{\"1\":{\"251\":1}}],[\"如果我们要使用一个集合类\",{\"1\":{\"25\":1}}],[\"如果我们确实不想在当前这个方法中进行处理\",{\"1\":{\"267\":1}}],[\"如果我们想从事务模式切换为原有的自动提交模式\",{\"1\":{\"534\":1}}],[\"如果我们想修改表结构\",{\"1\":{\"479\":1}}],[\"如果我们想直接作为接口抽象方法的实现\",{\"1\":{\"257\":1}}],[\"如果我们想要表示一个范围内的字符\",{\"1\":{\"246\":1}}],[\"如果我们我们将其权限改为private\",{\"1\":{\"251\":1}}],[\"如果我们仅仅是想要判断两个字符串的内容是否相同\",{\"1\":{\"244\":1}}],[\"如果我们已经明确了继承的泛型的类型\",{\"1\":{\"186\":1}}],[\"如果我们并不是希望收到中断信号就是结束程序\",{\"1\":{\"144\":1}}],[\"如果我们希望读取某个文件的内容\",{\"1\":{\"98\":1}}],[\"如果我们给类型变量设定了上界\",{\"1\":{\"16\":1}}],[\"如果某个方法明确指出会抛出哪些异常\",{\"1\":{\"267\":1}}],[\"如果某个类中存在静态方法或是静态变量\",{\"1\":{\"121\":1}}],[\"如果某个元素在当前集合中不存在\",{\"1\":{\"23\":1}}],[\"如果缓冲区中存在此数据\",{\"1\":{\"103\":1}}],[\"如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型\",{\"1\":{\"80\":1}}],[\"如果集合中本身没有元素\",{\"1\":{\"78\":1}}],[\"如果旧的数组不为空\",{\"1\":{\"60\":1}}],[\"如果旧的容量已经大于最大限制了\",{\"1\":{\"60\":1}}],[\"如果旧容量大于0\",{\"1\":{\"60\":1}}],[\"如果超过阈值\",{\"1\":{\"59\":1}}],[\"如果e不为空\",{\"1\":{\"59\":1}}],[\"如果当前链表的长度已经很长了\",{\"1\":{\"59\":1}}],[\"如果第一个结点是treenode类型的\",{\"1\":{\"59\":1}}],[\"如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同\",{\"1\":{\"59\":1}}],[\"如果底层哈希表没初始化\",{\"1\":{\"59\":1}}],[\"如果需要更加灵活地控制日志级别\",{\"1\":{\"639\":1}}],[\"如果需要让mybatis完全使用构造方法进行对象构建与赋值工作\",{\"1\":{\"569\":1}}],[\"如果需要使用多个的话\",{\"1\":{\"281\":1}}],[\"如果需要使用更大的数组\",{\"1\":{\"236\":1}}],[\"如果需要指定为外部的对象\",{\"1\":{\"251\":2}}],[\"如果需要完整学习正则表达式\",{\"1\":{\"246\":1}}],[\"如果需要维护顺序\",{\"1\":{\"57\":1}}],[\"如果需要再次进行遍历操作\",{\"1\":{\"34\":1}}],[\"如果出现键相同的情况\",{\"1\":{\"57\":1}}],[\"如果插入的数据与列一一对应\",{\"1\":{\"482\":1}}],[\"如果插入的长度小于定义长度时\",{\"1\":{\"474\":1}}],[\"如果插入时该列有明确值\",{\"1\":{\"475\":1}}],[\"如果插入重复元素\",{\"1\":{\"47\":1}}],[\"如果插入失败\",{\"1\":{\"43\":1}}],[\"如果o2比o1大\",{\"1\":{\"14\":1}}],[\"如果是自己编写的类型\",{\"1\":{\"559\":1}}],[\"如果是jdk内置的包装类型或是其他类型\",{\"1\":{\"559\":1}}],[\"如果是普通成员方法\",{\"1\":{\"258\":1}}],[\"如果是直接使用双引号创建的字符串\",{\"1\":{\"244\":1}}],[\"如果是基本数据类型\",{\"1\":{\"235\":1}}],[\"如果是基本类型的数组\",{\"1\":{\"281\":1}}],[\"如果是基本类型\",{\"1\":{\"4\":1,\"559\":1}}],[\"如果是\",{\"1\":{\"161\":1,\"285\":1}}],[\"如果是静态方法\",{\"1\":{\"155\":1}}],[\"如果是类\",{\"1\":{\"155\":1}}],[\"如果是文件夹\",{\"1\":{\"98\":1}}],[\"如果是其他类型的文件不适用\",{\"1\":{\"96\":1}}],[\"如果是多个单词\",{\"1\":{\"5\":1}}],[\"如果是引用类型\",{\"1\":{\"4\":1,\"235\":1}}],[\"如果是boolean的话\",{\"1\":{\"4\":1}}],[\"如\",{\"1\":{\"4\":1,\"88\":2,\"364\":1,\"367\":1}}],[\"即继承的子logger不能直接修改父logger的handler\",{\"1\":{\"656\":1}}],[\"即我们在java中所传给他的值\",{\"1\":{\"604\":1}}],[\"即我通过一个策略与环境进行交互生成一系列经验\",{\"1\":{\"408\":1}}],[\"即我通过这个策略与环境进行交互生成一系列经验\",{\"1\":{\"407\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"510\":1}}],[\"即外键列中的数据值必须对应于另一表的主键或唯一列中的某个值\",{\"1\":{\"475\":1}}],[\"即存在关键字段决定关键字段的情况\",{\"1\":{\"467\":1}}],[\"即此时策略\",{\"1\":{\"433\":1}}],[\"即此时的discounted\",{\"1\":{\"304\":1}}],[\"即基于一个策略\",{\"1\":{\"420\":1}}],[\"即各个状态的可能性为∣s∣1​\",{\"1\":{\"419\":1}}],[\"即函数\",{\"1\":{\"382\":1}}],[\"即不需要使用\",{\"1\":{\"516\":1}}],[\"即不需要完全精确地求出\",{\"1\":{\"367\":1}}],[\"即不具备terminal\",{\"1\":{\"304\":1}}],[\"即p\",{\"1\":{\"360\":1}}],[\"即j→∞\",{\"1\":{\"351\":1}}],[\"即求解右边的式子\",{\"1\":{\"348\":1}}],[\"即f\",{\"1\":{\"343\":1}}],[\"即a∗=argmaxa​q\",{\"1\":{\"342\":1}}],[\"即vπ​\",{\"1\":{\"334\":1}}],[\"即一个trajectory下的discounted\",{\"1\":{\"324\":1}}],[\"即无记忆的特性\",{\"1\":{\"305\":1}}],[\"即无人机作为空中基站\",{\"1\":{\"293\":1}}],[\"即表示具有终止状态terminal\",{\"1\":{\"304\":1}}],[\"即在策略\",{\"1\":{\"437\":1}}],[\"即在状态s1​下采用动作a1​获得的奖励r=1的概率\",{\"1\":{\"304\":1}}],[\"即在运行状态中\",{\"1\":{\"179\":1}}],[\"即状态s1​采用动作a1​转到状态s2​的概率\",{\"1\":{\"304\":1}}],[\"即ξ=\",{\"1\":{\"299\":1}}],[\"即xuav​\",{\"1\":{\"298\":1}}],[\"即γ≥γkn​​\",{\"1\":{\"294\":1}}],[\"即需要考虑地面不同用户的具体需求\",{\"1\":{\"289\":1}}],[\"即之后不能修改\",{\"1\":{\"256\":1}}],[\"即使会话2已经修改了数据\",{\"1\":{\"611\":1}}],[\"即使这里不指定具体类型\",{\"1\":{\"589\":1}}],[\"即使先估计了\",{\"1\":{\"364\":1}}],[\"即使用初始化块\",{\"1\":{\"255\":1}}],[\"即使是基本类型的数组\",{\"1\":{\"235\":1}}],[\"即使是最大的long类型\",{\"1\":{\"229\":1}}],[\"即使是两个不同的对象\",{\"1\":{\"216\":1}}],[\"即使强制类型转换\",{\"1\":{\"216\":1}}],[\"即使类名相同\",{\"1\":{\"120\":1}}],[\"即使值不同\",{\"1\":{\"57\":1}}],[\"即通过\",{\"1\":{\"108\":1,\"192\":1}}],[\"即对于损失函数中的\",{\"1\":{\"418\":1}}],[\"即对于数据\",{\"1\":{\"365\":1}}],[\"即对于每个状态\",{\"1\":{\"364\":1}}],[\"即对于给定策略\",{\"1\":{\"332\":1}}],[\"即对于\",{\"1\":{\"35\":1}}],[\"即可直接通过该接口执行我们的sql语句\",{\"1\":{\"621\":1}}],[\"即可在配置中直接解析其属性到insert语句中\",{\"1\":{\"589\":1}}],[\"即可以通过梯度下降\",{\"1\":{\"427\":1}}],[\"即可以进行套娃\",{\"1\":{\"109\":1}}],[\"即可创建对应的对象实例\",{\"1\":{\"191\":1}}],[\"即可\",{\"1\":{\"5\":1,\"156\":1,\"342\":1,\"362\":1}}],[\"即空指针异常\",{\"1\":{\"4\":1}}],[\"即\",{\"1\":{\"4\":1,\"218\":1,\"219\":1,\"238\":1,\"311\":1,\"348\":2,\"351\":2,\"353\":1,\"362\":1,\"363\":2,\"379\":1,\"384\":1,\"422\":1,\"612\":1}}],[\"对数据的修改就是永久的\",{\"1\":{\"510\":1}}],[\"对视图的修改就是对基本表的修改\",{\"1\":{\"507\":1}}],[\"对反射进行了限制\",{\"1\":{\"193\":1}}],[\"对\",{\"1\":{\"67\":1}}],[\"对应实体类如下\",{\"1\":{\"581\":1}}],[\"对应实体类属性名\",{\"1\":{\"563\":1}}],[\"对应数据库字段名\",{\"1\":{\"563\":1}}],[\"对应java进行调用\",{\"1\":{\"559\":1}}],[\"对应哪个数据库的jdbc驱动\",{\"1\":{\"552\":1}}],[\"对应支持http协议的响应内容\",{\"1\":{\"455\":1}}],[\"对应目标函数的真实梯度是\",{\"1\":{\"421\":1}}],[\"对应收敛性证明\",{\"1\":{\"389\":1}}],[\"对应一个向量\",{\"1\":{\"343\":1}}],[\"对应策略表示为\",{\"1\":{\"342\":1}}],[\"对应算法\",{\"0\":{\"313\":1}}],[\"对应状态中所有可选择的动作集合\",{\"1\":{\"304\":1}}],[\"对应s就是uav的部署位置\",{\"1\":{\"298\":1}}],[\"对应关系如下表\",{\"1\":{\"227\":1}}],[\"对应的实体类为\",{\"1\":{\"577\":1}}],[\"对应的vk+1​\",{\"1\":{\"348\":1}}],[\"对应的动作\",{\"1\":{\"342\":1}}],[\"对应的discounted\",{\"1\":{\"324\":1}}],[\"对应的class\",{\"1\":{\"186\":1}}],[\"对应的\",{\"1\":{\"186\":1,\"327\":2,\"331\":1,\"351\":1,\"379\":1,\"401\":1}}],[\"对应地\",{\"1\":{\"186\":1}}],[\"对应多个文件夹\",{\"1\":{\"120\":1}}],[\"对应缓冲流的close源码\",{\"1\":{\"107\":1}}],[\"对应\",{\"1\":{\"55\":1,\"308\":2,\"439\":1}}],[\"对出队顺序进行调整\",{\"1\":{\"46\":1}}],[\"对剩下的元素进行自定义遍历操作\",{\"1\":{\"32\":1}}],[\"对当前集合按照给定的规则进行排序操作\",{\"1\":{\"24\":1}}],[\"对于一对多查询\",{\"1\":{\"581\":1}}],[\"对于一个\",{\"1\":{\"366\":1}}],[\"对于策略\",{\"1\":{\"398\":1}}],[\"对于观测值g​\",{\"1\":{\"389\":1}}],[\"对于这个问题\",{\"1\":{\"386\":1}}],[\"对于这种成员内部类\",{\"1\":{\"251\":1}}],[\"对于函数\",{\"1\":{\"386\":1}}],[\"对于贝尔曼最优公式而言\",{\"1\":{\"340\":1,\"341\":1}}],[\"对于所有状态s\",{\"1\":{\"331\":1}}],[\"对于不同的策略\",{\"1\":{\"325\":1}}],[\"对于每个\",{\"1\":{\"366\":1}}],[\"对于每个智能体\",{\"1\":{\"298\":1}}],[\"对于每一个状态\",{\"1\":{\"304\":1}}],[\"对于动作空间而言\",{\"1\":{\"299\":1}}],[\"对于用户kn​存在特定的信噪比目标γkn​​\",{\"1\":{\"294\":1}}],[\"对于用户kn​∈kn​\",{\"1\":{\"293\":1}}],[\"对于无人机的总发射功率也均匀地分配给每个用户\",{\"1\":{\"294\":1}}],[\"对于无人机n\",{\"1\":{\"293\":1,\"294\":1}}],[\"对于指定区域\",{\"1\":{\"293\":1}}],[\"对于使用者来说\",{\"1\":{\"280\":1}}],[\"对于已经实现的方法\",{\"1\":{\"257\":1}}],[\"对于普通字符来说\",{\"1\":{\"246\":1}}],[\"对于变量来说\",{\"1\":{\"245\":1}}],[\"对于基本类型的数组来说\",{\"1\":{\"238\":1}}],[\"对于需要精确计算的场景\",{\"1\":{\"229\":1}}],[\"对于非常大的整数计算\",{\"1\":{\"229\":1}}],[\"对于引用类型\",{\"1\":{\"220\":1}}],[\"对于类中基本数据类型\",{\"1\":{\"220\":1}}],[\"对于类型变量来说是不支持的\",{\"1\":{\"15\":2}}],[\"对于人类的不同子类\",{\"1\":{\"219\":1}}],[\"对于成员方法\",{\"1\":{\"217\":1}}],[\"对于成员变量\",{\"1\":{\"217\":1}}],[\"对于任意一个对象\",{\"1\":{\"179\":1}}],[\"对于任意一个类\",{\"1\":{\"179\":1}}],[\"对于\",{\"1\":{\"84\":3,\"256\":1,\"333\":1,\"355\":3,\"362\":2,\"364\":1,\"366\":1,\"373\":1,\"415\":1,\"427\":1}}],[\"对于泛型类test\",{\"1\":{\"16\":1}}],[\"对于对象而言\",{\"1\":{\"4\":1}}],[\"对其进行修改\",{\"1\":{\"9\":1}}],[\"对象与多态\",{\"0\":{\"185\":1}}],[\"对象始终是相同的\",{\"1\":{\"182\":1}}],[\"对象序列化\",{\"0\":{\"131\":1}}],[\"对象流\",{\"0\":{\"130\":1}}],[\"对象再多\",{\"1\":{\"117\":1}}],[\"对象在创建之后\",{\"1\":{\"9\":1}}],[\"对象创建成功之后\",{\"1\":{\"4\":1}}],[\"对象实例的创建\",{\"1\":{\"4\":1}}],[\"对象\",{\"0\":{\"183\":1,\"184\":1,\"251\":1},\"1\":{\"4\":1,\"155\":1,\"182\":1,\"249\":1,\"258\":2}}],[\"=等\",{\"1\":{\"491\":1}}],[\"=θt​+αe\",{\"1\":{\"441\":1}}],[\"=dtvπ​\",{\"1\":{\"435\":1}}],[\"=i=1∑n​yt​−q^​\",{\"1\":{\"427\":1}}],[\"=−2e\",{\"1\":{\"421\":1}}],[\"=−c1​ln\",{\"1\":{\"295\":1}}],[\"=∣s∣1​s∈s∑​\",{\"1\":{\"419\":1}}],[\"=qt​\",{\"1\":{\"401\":1,\"405\":1}}],[\"=vt​\",{\"1\":{\"397\":1}}],[\"=vπ0​​\",{\"1\":{\"355\":1}}],[\"=w−\",{\"1\":{\"395\":1}}],[\"=wk​−αk​▽w​f\",{\"1\":{\"389\":1}}],[\"=wk​−αk​e\",{\"1\":{\"386\":1}}],[\"=wk​−αk​\",{\"1\":{\"384\":1,\"395\":1}}],[\"=▽w​j\",{\"1\":{\"389\":1}}],[\"=g\",{\"1\":{\"382\":1,\"389\":1}}],[\"=k1​\",{\"1\":{\"379\":1}}],[\"=k0​−1dkn​​−α\",{\"1\":{\"294\":1}}],[\"=n1​∑i=1n​xi​\",{\"1\":{\"379\":1}}],[\"=1\",{\"1\":{\"364\":1,\"420\":1,\"435\":1}}],[\"=argmaxπ​∑a​π\",{\"1\":{\"364\":1}}],[\"=argmaxa​qπk​​\",{\"1\":{\"351\":1}}],[\"=argmaxa​qk​\",{\"1\":{\"348\":1}}],[\"=a∑​πk​\",{\"1\":{\"351\":1}}],[\"=a∑​π\",{\"1\":{\"328\":1,\"329\":3,\"330\":1,\"333\":1,\"398\":1}}],[\"=πargmax​a∑​πk​\",{\"1\":{\"351\":1}}],[\"=πargmax​a∑​π\",{\"1\":{\"348\":1}}],[\"=πmax​\",{\"1\":{\"346\":1,\"347\":1}}],[\"=x∗\",{\"1\":{\"343\":1}}],[\"=x\",{\"1\":{\"343\":1}}],[\"=maxa​qk​\",{\"1\":{\"348\":1}}],[\"=maxπ​\",{\"1\":{\"343\":1}}],[\"=maxπ​∑a​π\",{\"1\":{\"342\":1}}],[\"=mean\",{\"1\":{\"330\":1}}],[\"=∑a​π\",{\"1\":{\"334\":1}}],[\"=∑a​qπ​\",{\"1\":{\"333\":1}}],[\"=∑r​p\",{\"1\":{\"333\":1}}],[\"=r∑​rp\",{\"1\":{\"438\":1}}],[\"=r∑​p\",{\"1\":{\"362\":1}}],[\"=rπ​\",{\"1\":{\"331\":1}}],[\"=rt+1​+γgt+1​​\",{\"1\":{\"327\":1}}],[\"=rt+1​+γ\",{\"1\":{\"327\":1}}],[\"=s∈s∑​d\",{\"1\":{\"440\":1}}],[\"=s∈s∑​dπ​\",{\"1\":{\"420\":1}}],[\"=s\",{\"1\":{\"329\":3}}],[\"=sin−1\",{\"1\":{\"294\":1}}],[\"=es∼d\",{\"1\":{\"440\":1}}],[\"=es∼d​\",{\"1\":{\"438\":1,\"440\":1}}],[\"=es∼η\",{\"1\":{\"311\":1}}],[\"=e\",{\"1\":{\"325\":1,\"327\":2,\"333\":1,\"334\":2,\"360\":2,\"362\":1,\"363\":1,\"386\":1,\"389\":4,\"398\":3,\"400\":1,\"404\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"426\":1,\"427\":3,\"436\":1,\"438\":1,\"440\":1}}],[\"=0\",{\"1\":{\"311\":1,\"381\":1,\"383\":2,\"384\":1,\"389\":2,\"395\":1}}],[\"=p\",{\"1\":{\"305\":2}}],[\"=3rtt+rkn​​\",{\"1\":{\"295\":1}}],[\"=ζ1​moskn​​delay\",{\"1\":{\"295\":1}}],[\"=γk0​σ2dkn​​α\",{\"1\":{\"294\":1}}],[\"=b2​ln\",{\"1\":{\"294\":1}}],[\"=bkn​​log2​\",{\"1\":{\"294\":1}}],[\"=b1​\",{\"1\":{\"294\":1}}],[\"=σ2pkn​​gkn​​\",{\"1\":{\"294\":1}}],[\"==>向右的箭头就是发送给mysql服务器的sql语句以及其参数列表\",{\"1\":{\"580\":1}}],[\"==>\",{\"1\":{\"580\":2}}],[\"====>\",{\"1\":{\"580\":2}}],[\"====​n→∞lim​n1​e\",{\"1\":{\"439\":1}}],[\"=========================\",{\"1\":{\"258\":1}}],[\"====================================\",{\"1\":{\"257\":2}}],[\"=================\",{\"1\":{\"258\":1}}],[\"==\",{\"1\":{\"25\":2,\"59\":9,\"60\":1,\"84\":6,\"142\":1,\"147\":1,\"148\":1,\"183\":1,\"186\":1,\"215\":1,\"216\":2,\"220\":1,\"227\":3,\"244\":3,\"266\":2,\"455\":1,\"517\":3,\"547\":1,\"602\":2,\"658\":3,\"667\":1}}],[\"=\",{\"1\":{\"4\":6,\"5\":3,\"7\":2,\"9\":16,\"14\":9,\"15\":8,\"16\":1,\"23\":4,\"24\":3,\"25\":26,\"30\":4,\"33\":3,\"34\":3,\"35\":1,\"43\":1,\"44\":1,\"45\":2,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"58\":1,\"59\":20,\"60\":14,\"64\":1,\"65\":5,\"66\":3,\"67\":2,\"71\":12,\"76\":1,\"77\":1,\"78\":1,\"79\":3,\"80\":4,\"84\":12,\"90\":4,\"91\":6,\"92\":2,\"93\":1,\"94\":5,\"96\":3,\"97\":1,\"98\":4,\"105\":1,\"107\":5,\"108\":2,\"109\":1,\"110\":1,\"112\":3,\"113\":1,\"117\":1,\"120\":1,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":5,\"132\":2,\"133\":6,\"138\":3,\"140\":2,\"142\":4,\"144\":1,\"145\":1,\"147\":4,\"148\":4,\"154\":5,\"155\":19,\"156\":4,\"161\":4,\"162\":3,\"163\":2,\"165\":4,\"166\":1,\"167\":4,\"172\":5,\"173\":2,\"174\":3,\"182\":3,\"183\":1,\"184\":1,\"186\":14,\"191\":9,\"192\":12,\"193\":7,\"199\":9,\"207\":1,\"208\":4,\"216\":5,\"218\":4,\"219\":4,\"220\":2,\"221\":3,\"227\":10,\"228\":3,\"229\":6,\"235\":6,\"236\":1,\"237\":2,\"238\":8,\"239\":3,\"240\":1,\"241\":1,\"244\":10,\"245\":13,\"246\":2,\"251\":11,\"252\":2,\"253\":2,\"254\":1,\"255\":4,\"256\":3,\"257\":5,\"258\":6,\"267\":3,\"268\":1,\"274\":2,\"275\":1,\"280\":5,\"281\":13,\"282\":4,\"285\":3,\"293\":1,\"304\":1,\"342\":1,\"348\":1,\"351\":1,\"372\":1,\"384\":1,\"395\":1,\"440\":1,\"447\":5,\"448\":11,\"449\":2,\"454\":13,\"455\":7,\"497\":2,\"498\":1,\"509\":1,\"516\":3,\"517\":12,\"524\":6,\"526\":2,\"527\":12,\"532\":5,\"533\":5,\"534\":9,\"538\":6,\"547\":8,\"552\":4,\"554\":3,\"558\":3,\"559\":2,\"560\":1,\"561\":2,\"562\":3,\"563\":2,\"564\":4,\"569\":11,\"570\":5,\"571\":5,\"578\":2,\"579\":2,\"580\":2,\"581\":2,\"582\":2,\"583\":3,\"591\":2,\"592\":1,\"593\":5,\"599\":3,\"601\":1,\"602\":3,\"604\":1,\"605\":2,\"611\":5,\"612\":4,\"614\":1,\"615\":1,\"616\":1,\"625\":4,\"626\":5,\"628\":10,\"629\":9,\"630\":5,\"631\":5,\"632\":4,\"636\":1,\"638\":8,\"639\":1,\"640\":2,\"646\":1,\"647\":1,\"648\":1,\"649\":1,\"655\":3,\"658\":4,\"665\":1,\"666\":2,\"667\":8,\"674\":1,\"676\":3,\"678\":1}}],[\"n→∞lim​n1​e\",{\"1\":{\"439\":2}}],[\"n=0∑∞​βnrt+n​\",{\"1\":{\"298\":1}}],[\"n∈n=\",{\"1\":{\"298\":1}}],[\"n∈1\",{\"1\":{\"293\":1}}],[\"n0​为用户所在位置的加性高斯白噪声\",{\"1\":{\"294\":1}}],[\"n个类型变量\",{\"1\":{\"281\":1}}],[\"n个\",{\"1\":{\"206\":1}}],[\"navigate\",{\"1\":{\"455\":1}}],[\"nanos\",{\"1\":{\"215\":1}}],[\"native\",{\"1\":{\"143\":1,\"183\":1,\"215\":7,\"264\":1}}],[\"namespace=\",{\"1\":{\"554\":1,\"570\":1}}],[\"name=test\",{\"1\":{\"664\":1}}],[\"name=小明\",{\"1\":{\"580\":1}}],[\"name=\",{\"1\":{\"552\":4,\"560\":1,\"580\":1,\"622\":1,\"679\":2}}],[\"name>\",{\"1\":{\"545\":1,\"546\":1}}],[\"named\",{\"1\":{\"183\":1}}],[\"name\",{\"1\":{\"4\":3,\"5\":2,\"7\":7,\"9\":14,\"15\":4,\"65\":5,\"84\":15,\"117\":1,\"121\":1,\"131\":5,\"132\":4,\"133\":5,\"140\":1,\"167\":2,\"174\":4,\"183\":1,\"186\":1,\"191\":5,\"192\":5,\"199\":2,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"221\":5,\"241\":1,\"251\":14,\"252\":4,\"253\":4,\"254\":2,\"280\":4,\"281\":4,\"475\":2,\"524\":1,\"527\":4,\"538\":9,\"554\":1,\"563\":1,\"569\":10,\"577\":1,\"578\":2,\"579\":2,\"580\":1,\"581\":3,\"582\":2,\"583\":9,\"589\":3,\"590\":2,\"599\":1,\"605\":3,\"624\":2,\"625\":4,\"626\":2,\"628\":6,\"666\":1}}],[\"noargsconstructor来快速生成全参构造和无参构造\",{\"1\":{\"540\":1}}],[\"no\",{\"1\":{\"517\":2,\"569\":1,\"679\":1}}],[\"nobody\",{\"1\":{\"517\":1}}],[\"normal\",{\"1\":{\"508\":1}}],[\"novel\",{\"1\":{\"289\":1}}],[\"nosuchfieldexception\",{\"1\":{\"193\":1}}],[\"nosuchmethodexception\",{\"1\":{\"191\":1,\"192\":1,\"193\":1,\"208\":1}}],[\"nonnull的成员字段\",{\"1\":{\"540\":1}}],[\"none\",{\"1\":{\"455\":1}}],[\"non\",{\"1\":{\"167\":1}}],[\"nom\",{\"1\":{\"145\":1}}],[\"notifyall\",{\"1\":{\"174\":1,\"215\":1}}],[\"notifyall其实和notify一样\",{\"1\":{\"161\":1}}],[\"notify\",{\"1\":{\"161\":4,\"215\":1}}],[\"not\",{\"1\":{\"139\":1,\"455\":1,\"475\":3,\"476\":1,\"477\":1,\"491\":3,\"517\":2,\"571\":1,\"682\":1}}],[\"nodelist\",{\"1\":{\"547\":4}}],[\"node<k\",{\"1\":{\"58\":3,\"59\":3,\"60\":4,\"61\":2}}],[\"node<e>\",{\"1\":{\"25\":7}}],[\"node\",{\"1\":{\"25\":1,\"60\":1,\"547\":4}}],[\"n\",{\"0\":{\"402\":1},\"1\":{\"59\":6,\"241\":1,\"246\":12,\"293\":2,\"296\":1,\"298\":2,\"355\":1,\"356\":1,\"427\":1,\"448\":4,\"455\":2,\"461\":2,\"474\":2}}],[\"net\",{\"1\":{\"449\":1,\"454\":1}}],[\"network\",{\"1\":{\"427\":5,\"429\":1}}],[\"networks\",{\"0\":{\"288\":1},\"1\":{\"289\":1,\"427\":1}}],[\"nextline\",{\"1\":{\"448\":1,\"532\":2,\"533\":2}}],[\"nextint方法可以指定创建0\",{\"1\":{\"274\":1}}],[\"nextint\",{\"1\":{\"274\":1}}],[\"nextindex\",{\"1\":{\"37\":1}}],[\"nextindex++\",{\"1\":{\"33\":1}}],[\"nextthreadnum\",{\"1\":{\"139\":1}}],[\"next\",{\"1\":{\"23\":1,\"24\":2,\"25\":4,\"30\":1,\"32\":3,\"33\":5,\"34\":1,\"36\":1,\"37\":1,\"58\":1,\"59\":2,\"61\":2,\"516\":1,\"525\":1,\"527\":2,\"532\":1,\"533\":1}}],[\"newdocumentbuilder\",{\"1\":{\"547\":1}}],[\"new表和old表\",{\"1\":{\"509\":1}}],[\"newestimatevt+1​\",{\"1\":{\"397\":1}}],[\"newinstance\",{\"1\":{\"191\":4,\"192\":3,\"199\":2,\"527\":1,\"547\":1}}],[\"newline\",{\"1\":{\"113\":1}}],[\"newlist\",{\"1\":{\"79\":2}}],[\"newoutputstream\",{\"1\":{\"110\":1}}],[\"newtasksmaybescheduled\",{\"1\":{\"167\":2}}],[\"newtab\",{\"1\":{\"60\":2}}],[\"newthr\",{\"1\":{\"60\":4}}],[\"newcap\",{\"1\":{\"60\":5}}],[\"newcapacity\",{\"1\":{\"25\":6}}],[\"newnode\",{\"1\":{\"59\":2}}],[\"newarr\",{\"1\":{\"14\":2}}],[\"new\",{\"1\":{\"4\":3,\"5\":1,\"14\":4,\"15\":3,\"16\":1,\"23\":1,\"25\":13,\"32\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":2,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"60\":2,\"64\":1,\"65\":10,\"66\":3,\"67\":2,\"71\":7,\"76\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":6,\"90\":2,\"91\":5,\"92\":2,\"93\":1,\"94\":3,\"96\":3,\"97\":1,\"98\":4,\"105\":2,\"107\":1,\"108\":4,\"109\":3,\"110\":2,\"112\":6,\"113\":2,\"118\":1,\"120\":1,\"126\":4,\"127\":2,\"128\":3,\"129\":4,\"131\":5,\"133\":5,\"139\":1,\"140\":2,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":11,\"156\":4,\"161\":3,\"162\":3,\"163\":3,\"165\":4,\"166\":2,\"167\":4,\"172\":3,\"173\":2,\"174\":10,\"182\":1,\"184\":1,\"186\":1,\"193\":1,\"199\":3,\"216\":4,\"219\":2,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":1,\"235\":5,\"236\":1,\"237\":1,\"238\":4,\"241\":1,\"244\":4,\"245\":2,\"251\":7,\"252\":1,\"253\":1,\"255\":4,\"256\":1,\"258\":2,\"266\":6,\"267\":3,\"274\":1,\"275\":1,\"280\":1,\"281\":5,\"282\":2,\"285\":6,\"447\":3,\"448\":10,\"449\":3,\"454\":7,\"455\":3,\"509\":1,\"516\":1,\"517\":6,\"524\":1,\"527\":3,\"532\":1,\"533\":1,\"552\":1,\"554\":2,\"558\":2,\"605\":3,\"625\":1,\"630\":1,\"632\":5,\"638\":7,\"639\":1,\"640\":2,\"647\":1,\"648\":1,\"649\":2,\"657\":1,\"665\":2,\"666\":1,\"667\":1,\"674\":1,\"676\":3}}],[\"numbers\",{\"1\":{\"360\":1}}],[\"number\",{\"1\":{\"15\":1,\"16\":2,\"186\":1,\"280\":1,\"295\":1}}],[\"number>\",{\"1\":{\"15\":3,\"16\":1}}],[\"nullpointerexception\",{\"1\":{\"267\":3,\"285\":1,\"517\":1,\"639\":1}}],[\"null\",{\"1\":{\"4\":1,\"25\":1,\"57\":1,\"59\":10,\"60\":3,\"64\":1,\"84\":2,\"90\":2,\"107\":4,\"127\":1,\"139\":1,\"216\":1,\"229\":1,\"267\":1,\"282\":2,\"285\":2,\"475\":6,\"476\":1,\"517\":13,\"527\":2,\"667\":3}}],[\"s2\",{\"1\":{\"611\":2}}],[\"s2​\",{\"1\":{\"366\":4}}],[\"s2​a3​​s5​a1​​\",{\"1\":{\"366\":1}}],[\"s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"366\":1}}],[\"s2​∣s1​\",{\"1\":{\"304\":1}}],[\"s1\",{\"1\":{\"611\":2}}],[\"s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"366\":1}}],[\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"366\":2}}],[\"s1​\",{\"1\":{\"331\":2,\"366\":4,\"397\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​\",{\"1\":{\"304\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​\",{\"1\":{\"304\":1}}],[\"s1​→a1​s2​\",{\"1\":{\"304\":1}}],[\"sneakythrows来自动生成try\",{\"1\":{\"540\":1}}],[\"sno\",{\"1\":{\"507\":1,\"509\":2}}],[\"sn​\",{\"1\":{\"331\":2}}],[\"smallint用于存储小的整数\",{\"1\":{\"474\":1}}],[\"s∣s\",{\"1\":{\"440\":1}}],[\"s∣a\",{\"1\":{\"342\":1,\"343\":1}}],[\"s∑​dπ​\",{\"1\":{\"439\":1}}],[\"sgdw\",{\"0\":{\"391\":1}}],[\"sgd的目标是\",{\"1\":{\"389\":1}}],[\"sgd\",{\"0\":{\"387\":1,\"389\":1,\"390\":1},\"1\":{\"386\":1,\"389\":3,\"390\":2,\"421\":1,\"440\":1}}],[\"s5​\",{\"1\":{\"366\":1}}],[\"s5​a1​​\",{\"1\":{\"366\":1}}],[\"s​=maxπ​∑a​π\",{\"1\":{\"343\":1}}],[\"sj​∣si​\",{\"1\":{\"331\":1}}],[\"s0​\",{\"1\":{\"305\":2,\"397\":1}}],[\"s∈s​\",{\"1\":{\"420\":1}}],[\"s∈s\",{\"1\":{\"305\":1,\"348\":1,\"351\":2,\"398\":2}}],[\"s=\",{\"1\":{\"304\":1}}],[\"specifiedformatter\",{\"1\":{\"667\":3}}],[\"spi\",{\"1\":{\"516\":1}}],[\"spatial\",{\"1\":{\"508\":1}}],[\"space\",{\"1\":{\"298\":2,\"304\":3}}],[\"splitable\",{\"1\":{\"173\":1}}],[\"split\",{\"1\":{\"71\":1,\"244\":2}}],[\"spliterator也用于遍历数据源中的元素\",{\"1\":{\"173\":1}}],[\"spliteratorunknownsize\",{\"1\":{\"36\":1}}],[\"spliterator<t>\",{\"1\":{\"36\":1}}],[\"spliterator<e>\",{\"1\":{\"23\":1,\"47\":1}}],[\"spliterators\",{\"1\":{\"23\":1,\"36\":1,\"47\":1}}],[\"spliterator\",{\"1\":{\"23\":4,\"36\":1,\"47\":3,\"173\":1}}],[\"slf4j\",{\"1\":{\"679\":1}}],[\"slove\",{\"0\":{\"332\":1}}],[\"slow\",{\"1\":{\"295\":1}}],[\"sleep\",{\"1\":{\"142\":1,\"143\":1,\"144\":1,\"154\":1,\"155\":4,\"156\":2,\"161\":1,\"162\":2,\"165\":2,\"172\":4,\"174\":2,\"221\":4,\"616\":1}}],[\"sqrt\",{\"1\":{\"274\":1}}],[\"sql类中提供了常见的select\",{\"1\":{\"630\":1}}],[\"sqlsession接口中为我们提供了事务操作相关的方法\",{\"1\":{\"593\":1}}],[\"sqlsession对象\",{\"1\":{\"553\":1,\"558\":1}}],[\"sqlsession\",{\"1\":{\"552\":1,\"554\":3,\"558\":4,\"570\":4,\"593\":2,\"611\":2,\"612\":3}}],[\"sqlsessionfactory对象是什么东西\",{\"1\":{\"553\":1}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"552\":1,\"554\":1,\"558\":1,\"632\":1}}],[\"sqlsessionfactory\",{\"1\":{\"552\":3,\"553\":1,\"554\":3,\"558\":4,\"593\":1,\"632\":1}}],[\"sqlexception\",{\"1\":{\"516\":1,\"517\":7,\"518\":2,\"524\":1,\"526\":1,\"527\":2,\"532\":1,\"533\":1,\"534\":4}}],[\"sql包\",{\"1\":{\"515\":1}}],[\"sql语句映射配置我们就编写好了\",{\"1\":{\"560\":1}}],[\"sql语句\",{\"1\":{\"534\":3}}],[\"sql语句中的等于判断是=\",{\"1\":{\"483\":1}}],[\"sql语句不区分大小写\",{\"1\":{\"472\":1}}],[\"sql数据类型\",{\"0\":{\"474\":1}}],[\"sql也支持注释\",{\"1\":{\"472\":1}}],[\"sql\",{\"0\":{\"472\":1},\"1\":{\"71\":1,\"460\":1,\"517\":1,\"518\":1,\"524\":1,\"544\":1,\"577\":1,\"600\":3,\"630\":1}}],[\"sss\",{\"1\":{\"676\":1}}],[\"ss\",{\"1\":{\"255\":2,\"676\":1}}],[\"should\",{\"1\":{\"517\":1}}],[\"show\",{\"1\":{\"501\":1,\"508\":1,\"509\":1,\"510\":1}}],[\"short\",{\"1\":{\"227\":3}}],[\"shutdowninput\",{\"1\":{\"449\":1}}],[\"shutdownoutput\",{\"1\":{\"449\":1}}],[\"shared\",{\"1\":{\"167\":1}}],[\"say\",{\"1\":{\"527\":3}}],[\"savepoint\",{\"1\":{\"510\":1,\"534\":3}}],[\"safari\",{\"1\":{\"455\":1}}],[\"safevarargs\",{\"1\":{\"204\":1}}],[\"sa​\",{\"1\":{\"401\":2}}],[\"sarsa\",{\"0\":{\"401\":1,\"402\":1,\"403\":1,\"424\":1},\"1\":{\"400\":3,\"401\":1,\"408\":1}}],[\"sa\",{\"1\":{\"377\":2}}],[\"samples\",{\"1\":{\"386\":1,\"427\":1}}],[\"sample\",{\"1\":{\"363\":1,\"384\":1,\"386\":1}}],[\"sampling\",{\"0\":{\"315\":1}}],[\"satisfying\",{\"1\":{\"383\":1}}],[\"satisfaction\",{\"1\":{\"289\":1}}],[\"satic\",{\"1\":{\"216\":1}}],[\"so\",{\"1\":{\"517\":2}}],[\"sockethandler\",{\"1\":{\"646\":2}}],[\"socket2\",{\"0\":{\"452\":1,\"453\":1}}],[\"sockettimeoutexception\",{\"1\":{\"449\":1}}],[\"socket也被翻译为套接字\",{\"1\":{\"446\":1}}],[\"socket\",{\"0\":{\"446\":1,\"447\":1,\"454\":1,\"690\":1},\"1\":{\"447\":8,\"448\":13,\"449\":10,\"454\":9,\"455\":7}}],[\"socket1\",{\"0\":{\"445\":1}}],[\"soloving\",{\"1\":{\"377\":1}}],[\"solution\",{\"1\":{\"332\":2}}],[\"soft\",{\"0\":{\"371\":1},\"1\":{\"370\":1,\"371\":2,\"372\":1,\"612\":1}}],[\"some\",{\"1\":{\"304\":1,\"401\":1}}],[\"someone\",{\"1\":{\"167\":1}}],[\"source\",{\"1\":{\"206\":1}}],[\"sorted\",{\"1\":{\"71\":2,\"112\":1}}],[\"sort\",{\"1\":{\"14\":3,\"24\":2,\"275\":1}}],[\"synchronize\",{\"1\":{\"517\":1}}],[\"synchronized关键字也可以作用于方法上\",{\"1\":{\"155\":1}}],[\"synchronized需要在括号中填入一个内容\",{\"1\":{\"155\":1}}],[\"synchronized\",{\"1\":{\"155\":8,\"156\":4,\"161\":2,\"167\":2,\"174\":2,\"517\":2}}],[\"syntax\",{\"1\":{\"246\":1}}],[\"system类中有一个getproperties方法用于存储所有系统相关的属性值\",{\"1\":{\"666\":1}}],[\"system\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"128\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"237\":2,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":2,\"275\":1,\"281\":1,\"447\":6,\"448\":10,\"449\":1,\"454\":1,\"455\":6,\"516\":1,\"517\":1,\"524\":1,\"527\":1,\"532\":2,\"533\":3,\"547\":1,\"554\":1,\"558\":1,\"560\":1,\"561\":1,\"562\":1,\"564\":3,\"569\":1,\"570\":2,\"571\":1,\"593\":2,\"611\":6,\"612\":2,\"616\":1,\"625\":1,\"646\":1,\"655\":2,\"658\":3,\"665\":1,\"666\":5,\"672\":3,\"678\":2}}],[\"script>\",{\"1\":{\"630\":1}}],[\"sc是不允许更新的\",{\"1\":{\"507\":1}}],[\"sc的基本表是sc\",{\"1\":{\"507\":1}}],[\"sc\",{\"1\":{\"507\":4}}],[\"scalar\",{\"1\":{\"433\":1}}],[\"scanner\",{\"1\":{\"128\":6,\"448\":4,\"449\":3,\"532\":3,\"533\":5}}],[\"schedule\",{\"1\":{\"166\":1,\"167\":2}}],[\"scoremap\",{\"1\":{\"65\":3}}],[\"score<string>\",{\"1\":{\"281\":3}}],[\"score<>\",{\"1\":{\"15\":3,\"281\":1}}],[\"score<\",{\"1\":{\"15\":3}}],[\"score<t>\",{\"1\":{\"281\":1}}],[\"score<t\",{\"1\":{\"15\":1}}],[\"score\",{\"1\":{\"15\":6,\"65\":5,\"280\":9,\"281\":4,\"290\":1}}],[\"src\",{\"1\":{\"110\":1,\"199\":1}}],[\"skipping\",{\"1\":{\"517\":1}}],[\"skip\",{\"1\":{\"91\":2,\"96\":1,\"517\":1}}],[\"simpledateformat\",{\"1\":{\"676\":2}}],[\"simpleformatter\",{\"1\":{\"649\":1}}],[\"simplest\",{\"0\":{\"309\":1}}],[\"sid=3\",{\"1\":{\"524\":1}}],[\"sid\",{\"1\":{\"497\":4,\"524\":1,\"527\":4,\"538\":9,\"554\":1,\"570\":2,\"582\":6,\"583\":2}}],[\"site\",{\"1\":{\"455\":1}}],[\"signed\",{\"1\":{\"455\":1}}],[\"si​\",{\"1\":{\"304\":2,\"427\":2}}],[\"single\",{\"1\":{\"367\":1,\"439\":1}}],[\"singletonlist\",{\"1\":{\"79\":1}}],[\"sin\",{\"1\":{\"294\":1}}],[\"since\",{\"1\":{\"183\":1}}],[\"size表示最大的缓存对象数量\",{\"1\":{\"612\":1}}],[\"size=\",{\"1\":{\"612\":1}}],[\"size++\",{\"1\":{\"25\":1}}],[\"size\",{\"1\":{\"23\":1,\"25\":6,\"47\":1,\"56\":1,\"67\":2,\"193\":2,\"631\":1}}],[\"sdawers\",{\"1\":{\"71\":1}}],[\"s\",{\"0\":{\"437\":1},\"1\":{\"30\":4,\"34\":2,\"139\":1,\"183\":1,\"191\":1,\"192\":2,\"246\":4,\"294\":1,\"295\":1,\"296\":1,\"298\":5,\"305\":5,\"311\":4,\"312\":1,\"325\":2,\"326\":1,\"327\":1,\"329\":10,\"330\":7,\"331\":4,\"333\":13,\"334\":4,\"338\":3,\"340\":4,\"342\":2,\"348\":11,\"351\":13,\"360\":3,\"362\":9,\"363\":8,\"364\":4,\"367\":1,\"369\":6,\"372\":6,\"397\":2,\"398\":7,\"400\":2,\"401\":3,\"404\":1,\"405\":3,\"416\":2,\"417\":2,\"418\":3,\"419\":4,\"420\":8,\"421\":7,\"426\":5,\"427\":28,\"435\":6,\"437\":1,\"438\":8,\"439\":2,\"440\":12,\"441\":4,\"517\":1,\"552\":1}}],[\"suitable\",{\"1\":{\"517\":2}}],[\"success\",{\"1\":{\"517\":1}}],[\"sub\",{\"1\":{\"244\":2}}],[\"substring\",{\"1\":{\"244\":2}}],[\"sublist\",{\"1\":{\"24\":1}}],[\"sun\",{\"1\":{\"186\":1}}],[\"suspend\",{\"1\":{\"156\":1}}],[\"supposed\",{\"1\":{\"289\":1}}],[\"suppresswarnings\",{\"1\":{\"24\":1,\"60\":1,\"183\":1,\"204\":1}}],[\"super\",{\"1\":{\"15\":2,\"23\":1,\"24\":1,\"32\":1,\"35\":1,\"36\":1,\"61\":1,\"214\":1,\"216\":3,\"218\":1,\"219\":1,\"220\":2,\"251\":2,\"265\":2}}],[\"summarystatistics\",{\"1\":{\"71\":2}}],[\"sum\",{\"1\":{\"8\":2,\"65\":1,\"71\":2,\"258\":5,\"493\":1,\"494\":2}}],[\"severe\",{\"1\":{\"638\":4,\"639\":1}}],[\"separator用于控制分隔符\",{\"1\":{\"604\":1}}],[\"separator=\",{\"1\":{\"604\":1,\"605\":1}}],[\"separately\",{\"1\":{\"139\":1}}],[\"session2\",{\"1\":{\"612\":3}}],[\"session\",{\"1\":{\"560\":1,\"561\":1,\"562\":1,\"564\":5,\"571\":1,\"593\":7,\"599\":2,\"604\":1,\"605\":1,\"611\":1,\"612\":2,\"616\":1}}],[\"select中编写一个xml配置动态sql\",{\"1\":{\"630\":1}}],[\"selectprovider\",{\"1\":{\"630\":1}}],[\"selectprovider来引用这边编写好的动态sql操作\",{\"1\":{\"630\":1}}],[\"selectdetailbyid\",{\"1\":{\"629\":2}}],[\"select代表的就是select标签\",{\"1\":{\"624\":1}}],[\"selectgroup\",{\"1\":{\"583\":2}}],[\"selectalluser\",{\"1\":{\"583\":1,\"623\":2,\"624\":1,\"626\":1,\"627\":1,\"628\":1}}],[\"selectbookbysid\",{\"1\":{\"582\":2}}],[\"select=\",{\"1\":{\"579\":1,\"582\":1,\"583\":1}}],[\"selectstusbysex\",{\"1\":{\"570\":2}}],[\"selectstubyid\",{\"1\":{\"570\":2,\"582\":1,\"612\":2}}],[\"selectstudent\",{\"1\":{\"554\":2,\"558\":1,\"570\":3,\"583\":1}}],[\"selectcursor\",{\"1\":{\"564\":1}}],[\"selectmap\",{\"1\":{\"564\":1}}],[\"selectuserdetailbyid\",{\"1\":{\"579\":2}}],[\"selectusersbyage\",{\"1\":{\"564\":2}}],[\"selectusers\",{\"1\":{\"564\":4}}],[\"selectuserbyidandage\",{\"1\":{\"561\":1,\"562\":2,\"563\":1,\"571\":5}}],[\"selectuserbyid\",{\"1\":{\"559\":4,\"560\":1,\"561\":1,\"564\":1,\"569\":1,\"577\":1,\"579\":1,\"593\":2,\"601\":1,\"602\":1,\"611\":6,\"614\":1,\"615\":1,\"616\":1,\"629\":1,\"630\":3,\"631\":1}}],[\"selectone\",{\"1\":{\"560\":1,\"561\":1,\"562\":1}}],[\"selectlist\",{\"1\":{\"554\":1,\"558\":1,\"564\":2}}],[\"select>\",{\"1\":{\"554\":1,\"559\":4,\"561\":1,\"562\":1,\"563\":1,\"564\":2,\"569\":1,\"570\":3,\"571\":1,\"577\":1,\"579\":2,\"582\":2,\"583\":3,\"601\":1,\"602\":1,\"614\":1,\"615\":1,\"623\":1,\"630\":1}}],[\"select返回的数据类似于一个excel表格\",{\"1\":{\"525\":1}}],[\"select\",{\"0\":{\"579\":1},\"1\":{\"490\":5,\"492\":2,\"493\":1,\"494\":4,\"495\":3,\"496\":1,\"497\":2,\"498\":2,\"507\":2,\"516\":1,\"532\":2,\"533\":2,\"554\":1,\"559\":2,\"561\":1,\"562\":1,\"563\":1,\"564\":3,\"569\":1,\"570\":3,\"571\":2,\"577\":1,\"578\":1,\"579\":2,\"580\":2,\"581\":1,\"582\":3,\"583\":4,\"601\":1,\"602\":1,\"614\":1,\"615\":1,\"623\":1,\"624\":2,\"626\":2,\"627\":2,\"628\":2,\"629\":5,\"630\":4,\"631\":2}}],[\"securityadmin等人员才有权力执行dcl\",{\"1\":{\"472\":1}}],[\"sec\",{\"1\":{\"455\":7}}],[\"servlet\",{\"1\":{\"515\":1}}],[\"server\",{\"1\":{\"447\":4,\"448\":5,\"454\":4,\"455\":5,\"460\":2}}],[\"serversocket\",{\"1\":{\"447\":4,\"448\":2,\"454\":2,\"455\":4}}],[\"serialversionuid\",{\"1\":{\"132\":1,\"133\":1}}],[\"serializable\",{\"1\":{\"25\":2,\"42\":1,\"58\":1,\"67\":1,\"131\":1,\"132\":1,\"133\":1,\"510\":1,\"638\":1}}],[\"sequence\",{\"1\":{\"343\":1}}],[\"see\",{\"1\":{\"139\":1,\"167\":1}}],[\"seely\",{\"1\":{\"65\":3}}],[\"setformatter\",{\"1\":{\"649\":1,\"674\":1}}],[\"setuseparenthandlers\",{\"1\":{\"646\":1}}],[\"setuseragebyid\",{\"1\":{\"591\":3}}],[\"setlevel\",{\"1\":{\"640\":2,\"656\":2}}],[\"setlogimpl\",{\"1\":{\"632\":1}}],[\"setlogwriter\",{\"1\":{\"517\":1}}],[\"setenvironment\",{\"1\":{\"632\":1}}],[\"settings>\",{\"1\":{\"580\":1}}],[\"setter来为当前类的所有字段生成get\",{\"1\":{\"540\":1}}],[\"setter\",{\"1\":{\"538\":1,\"540\":1}}],[\"setbeanproperty\",{\"1\":{\"569\":1}}],[\"set方法\",{\"1\":{\"538\":1,\"540\":1}}],[\"setautocommit\",{\"1\":{\"534\":6}}],[\"setaccessible\",{\"1\":{\"191\":1,\"192\":2,\"193\":4}}],[\"setreceivebuffersize\",{\"1\":{\"449\":1}}],[\"setkeepalive\",{\"1\":{\"449\":1}}],[\"setsex\",{\"1\":{\"538\":1,\"625\":1}}],[\"setsendbuffersize\",{\"1\":{\"449\":1}}],[\"setsid\",{\"1\":{\"538\":1}}],[\"setsavepoint\",{\"1\":{\"534\":1}}],[\"setstring\",{\"1\":{\"533\":2}}],[\"setstatus\",{\"1\":{\"221\":2}}],[\"setsotimeout\",{\"1\":{\"449\":1}}],[\"sets\",{\"1\":{\"305\":1}}],[\"setint\",{\"1\":{\"193\":1}}],[\"setdaemon\",{\"1\":{\"172\":3}}],[\"setpriority\",{\"1\":{\"145\":1}}],[\"setvalue\",{\"1\":{\"56\":1}}],[\"set<map\",{\"1\":{\"56\":1}}],[\"set<k>\",{\"1\":{\"56\":1}}],[\"set<string>\",{\"1\":{\"48\":3,\"49\":1}}],[\"set<e>\",{\"1\":{\"47\":1,\"67\":1}}],[\"set支持的功能其实也就和\",{\"1\":{\"47\":1}}],[\"set集合\",{\"1\":{\"47\":1}}],[\"set\",{\"0\":{\"47\":1},\"1\":{\"24\":3,\"37\":1,\"47\":2,\"48\":13,\"49\":3,\"50\":13,\"67\":3,\"84\":1,\"162\":2,\"163\":1,\"193\":3,\"199\":1,\"305\":3,\"483\":1,\"516\":3,\"524\":1,\"525\":1,\"527\":8,\"591\":1}}],[\"setname\",{\"1\":{\"7\":2,\"167\":1,\"538\":1,\"625\":1}}],[\"sex>\",{\"1\":{\"545\":1}}],[\"sex\",{\"1\":{\"4\":1,\"5\":1,\"9\":14,\"117\":1,\"121\":1,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"241\":1,\"527\":4,\"538\":9,\"554\":1,\"570\":3,\"582\":2,\"583\":2}}],[\"stdoutimpl\",{\"1\":{\"632\":1}}],[\"stdout\",{\"1\":{\"580\":1,\"679\":2}}],[\"steady\",{\"1\":{\"420\":1}}],[\"step\",{\"0\":{\"402\":1},\"1\":{\"351\":2,\"364\":2,\"439\":1}}],[\"st+2​→at+3​\",{\"1\":{\"324\":1,\"327\":1}}],[\"st+2​→at+2​rt+3​\",{\"1\":{\"324\":1,\"327\":1}}],[\"st+1​=s\",{\"1\":{\"329\":2}}],[\"st+1​→at+1​rt+2​\",{\"1\":{\"324\":1,\"327\":1}}],[\"st+1​∣at+1​\",{\"1\":{\"305\":3}}],[\"st+1​\",{\"1\":{\"298\":1,\"397\":4,\"401\":2,\"404\":1,\"405\":1,\"423\":2,\"424\":1,\"425\":2}}],[\"st​→at​rt+1​\",{\"1\":{\"324\":1,\"327\":1}}],[\"st​\",{\"1\":{\"305\":4,\"397\":12,\"401\":6,\"405\":5,\"421\":4,\"422\":4,\"423\":3,\"424\":2,\"425\":2,\"441\":1}}],[\"store\",{\"1\":{\"666\":1}}],[\"stochastic\",{\"0\":{\"385\":1},\"1\":{\"304\":1,\"338\":1,\"371\":1,\"377\":2}}],[\"stop\",{\"1\":{\"142\":1,\"143\":1,\"304\":1}}],[\"study<integer>\",{\"1\":{\"282\":1}}],[\"study<t>\",{\"1\":{\"282\":2}}],[\"study\",{\"1\":{\"219\":15,\"220\":2,\"221\":4,\"255\":6,\"256\":3,\"257\":18,\"258\":15,\"516\":1,\"524\":1,\"632\":1}}],[\"student\",{\"1\":{\"65\":14,\"186\":3,\"191\":15,\"192\":8,\"208\":2,\"216\":4,\"219\":2,\"220\":10,\"221\":6,\"255\":5,\"285\":6,\"497\":4,\"508\":1,\"509\":2,\"516\":1,\"524\":3,\"527\":11,\"538\":3,\"554\":5,\"558\":2,\"570\":7,\"582\":2,\"583\":2,\"625\":5}}],[\"students\",{\"1\":{\"65\":2}}],[\"statrts的解释\",{\"0\":{\"369\":1}}],[\"statement除了执行这样的dql语句外\",{\"1\":{\"519\":1}}],[\"statement\",{\"1\":{\"516\":3,\"518\":1,\"524\":5,\"526\":5,\"532\":3,\"533\":5,\"534\":19,\"588\":6,\"599\":1,\"630\":1}}],[\"statevalue\",{\"1\":{\"421\":1}}],[\"states中\",{\"1\":{\"304\":1}}],[\"states中限制action\",{\"1\":{\"304\":1}}],[\"states的任务\",{\"1\":{\"304\":1}}],[\"states的trajectory\",{\"1\":{\"304\":1}}],[\"states\",{\"1\":{\"304\":1,\"305\":1}}],[\"state\",{\"0\":{\"323\":1,\"325\":1,\"326\":1,\"332\":1,\"343\":1,\"396\":1,\"417\":1,\"435\":1},\"1\":{\"298\":2,\"304\":6,\"305\":4,\"322\":1,\"325\":4,\"326\":4,\"327\":1,\"330\":1,\"332\":1,\"333\":6,\"334\":2,\"337\":1,\"340\":1,\"341\":1,\"348\":1,\"351\":2,\"353\":1,\"355\":2,\"356\":1,\"360\":1,\"362\":3,\"364\":3,\"366\":6,\"367\":1,\"369\":2,\"371\":1,\"377\":1,\"396\":1,\"398\":2,\"400\":2,\"416\":1,\"420\":1,\"433\":1,\"435\":2,\"440\":1}}],[\"status>\",{\"1\":{\"221\":1}}],[\"status\",{\"1\":{\"221\":22,\"304\":1,\"475\":2}}],[\"stationary\",{\"0\":{\"420\":1},\"1\":{\"420\":2,\"437\":1}}],[\"statistics\",{\"1\":{\"71\":4}}],[\"static\",{\"1\":{\"4\":3,\"5\":1,\"14\":6,\"15\":3,\"16\":1,\"23\":1,\"25\":12,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"58\":1,\"61\":1,\"64\":1,\"65\":2,\"66\":3,\"67\":1,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":4,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":5,\"120\":2,\"121\":3,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":2,\"132\":2,\"133\":3,\"138\":1,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":2,\"155\":10,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":4,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":4,\"182\":1,\"183\":3,\"184\":1,\"186\":9,\"191\":3,\"192\":3,\"193\":3,\"198\":3,\"199\":2,\"206\":1,\"207\":3,\"208\":2,\"215\":2,\"219\":3,\"220\":1,\"221\":8,\"227\":5,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":2,\"254\":10,\"255\":3,\"256\":1,\"257\":4,\"258\":5,\"266\":3,\"267\":6,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":6,\"447\":3,\"448\":2,\"454\":2,\"455\":2,\"517\":4,\"524\":1,\"526\":1,\"527\":1,\"533\":1,\"534\":4,\"552\":1,\"554\":1,\"558\":4,\"630\":1,\"632\":1,\"636\":1,\"638\":8,\"640\":2,\"678\":2}}],[\"starts\",{\"0\":{\"365\":1,\"368\":1},\"1\":{\"365\":1,\"369\":2,\"370\":1}}],[\"start\",{\"1\":{\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":2,\"154\":2,\"155\":10,\"156\":2,\"161\":2,\"162\":2,\"163\":2,\"165\":6,\"167\":1,\"172\":3,\"174\":5,\"295\":1}}],[\"starting\",{\"1\":{\"139\":1,\"326\":1,\"333\":2}}],[\"str5\",{\"1\":{\"245\":4}}],[\"str4\",{\"1\":{\"244\":2,\"245\":4}}],[\"str3\",{\"1\":{\"244\":2,\"245\":4}}],[\"str2\",{\"1\":{\"244\":3,\"245\":4}}],[\"str1\",{\"1\":{\"244\":3,\"245\":4}}],[\"structured\",{\"1\":{\"472\":1}}],[\"structure\",{\"1\":{\"167\":1}}],[\"stream流\",{\"0\":{\"70\":1,\"71\":1}}],[\"streamsupport\",{\"1\":{\"23\":2,\"173\":1}}],[\"stream\",{\"1\":{\"23\":3,\"71\":11,\"109\":1,\"110\":2,\"127\":2,\"173\":1,\"199\":3,\"285\":3,\"448\":2,\"454\":3}}],[\"stream<e>\",{\"1\":{\"23\":2,\"173\":1}}],[\"str\",{\"1\":{\"14\":1,\"25\":7,\"71\":5,\"96\":3,\"186\":4,\"192\":1,\"199\":3,\"244\":8,\"246\":5}}],[\"string的拼接会在编译时进行各种优化\",{\"1\":{\"245\":1}}],[\"stringbuilder\",{\"0\":{\"245\":1},\"1\":{\"245\":5,\"676\":2}}],[\"string类重载了equals方法用于判断和比较内容是否相同\",{\"1\":{\"244\":1}}],[\"string类的加载器\",{\"1\":{\"198\":1}}],[\"string本身也是一个类\",{\"1\":{\"244\":1}}],[\"string>\",{\"1\":{\"57\":4,\"64\":1,\"66\":3}}],[\"strings这个变量就是一个string\",{\"1\":{\"241\":1}}],[\"strings\",{\"1\":{\"14\":3,\"241\":3,\"244\":2}}],[\"string\",{\"0\":{\"244\":1},\"1\":{\"4\":5,\"5\":3,\"7\":3,\"9\":14,\"14\":12,\"15\":8,\"16\":1,\"23\":1,\"25\":11,\"30\":5,\"34\":3,\"35\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":7,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":6,\"90\":2,\"91\":4,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":4,\"120\":6,\"121\":3,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":3,\"132\":2,\"133\":3,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":2,\"172\":2,\"173\":2,\"174\":3,\"182\":4,\"183\":2,\"184\":2,\"186\":14,\"191\":6,\"192\":12,\"193\":3,\"198\":6,\"199\":9,\"206\":1,\"207\":7,\"208\":3,\"215\":1,\"218\":8,\"219\":4,\"220\":3,\"221\":5,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":6,\"239\":1,\"240\":1,\"241\":8,\"242\":2,\"244\":18,\"245\":14,\"246\":4,\"251\":10,\"252\":3,\"253\":2,\"254\":2,\"255\":4,\"256\":1,\"257\":3,\"258\":8,\"265\":2,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":6,\"281\":8,\"282\":3,\"447\":3,\"448\":3,\"454\":2,\"455\":2,\"517\":4,\"518\":1,\"524\":1,\"526\":1,\"527\":4,\"532\":1,\"533\":2,\"534\":4,\"538\":10,\"552\":2,\"554\":3,\"558\":1,\"563\":1,\"569\":5,\"570\":1,\"577\":3,\"581\":2,\"583\":2,\"588\":6,\"599\":1,\"626\":1,\"628\":4,\"630\":1,\"636\":1,\"638\":1,\"667\":2,\"672\":2,\"676\":2,\"678\":2}}],[\"aug\",{\"1\":{\"580\":1}}],[\"autocommit\",{\"1\":{\"558\":3,\"599\":1}}],[\"automatically\",{\"1\":{\"516\":1}}],[\"a1\",{\"1\":{\"495\":2}}],[\"a1​\",{\"1\":{\"304\":2,\"305\":2,\"366\":1}}],[\"a∈a∑​π\",{\"1\":{\"440\":1}}],[\"a∈a∑​▽θ​π\",{\"1\":{\"440\":2}}],[\"ak​=k1​是满足上面三个条件的\",{\"1\":{\"383\":1}}],[\"ak​→0不要过快\",{\"1\":{\"383\":1}}],[\"ak​→0\",{\"1\":{\"383\":1}}],[\"ak​\",{\"1\":{\"382\":1}}],[\"ak∗​∣s\",{\"1\":{\"364\":1}}],[\"ak∗​\",{\"1\":{\"351\":1}}],[\"a3​\",{\"1\":{\"366\":2}}],[\"a4​\",{\"1\":{\"366\":2}}],[\"a2\",{\"1\":{\"495\":1}}],[\"a2​\",{\"1\":{\"366\":4}}],[\"a2c\",{\"0\":{\"310\":1}}],[\"a=ak∗​\",{\"1\":{\"348\":1,\"351\":1}}],[\"avatar=https\",{\"1\":{\"580\":1}}],[\"avatar\",{\"1\":{\"577\":1,\"578\":2,\"580\":1}}],[\"available\",{\"1\":{\"91\":2,\"98\":1,\"199\":1,\"571\":1}}],[\"avg\",{\"1\":{\"493\":1,\"507\":1}}],[\"avif\",{\"1\":{\"455\":1}}],[\"average\",{\"0\":{\"435\":1,\"438\":1},\"1\":{\"333\":2,\"439\":1}}],[\"a∑​π\",{\"1\":{\"330\":1,\"440\":1}}],[\"a∑​p\",{\"1\":{\"329\":1}}],[\"alt\",{\"1\":{\"569\":1,\"570\":1,\"577\":1,\"578\":2,\"581\":1,\"583\":1,\"599\":2,\"604\":1,\"605\":1,\"610\":1,\"611\":2,\"612\":1,\"616\":1,\"625\":1,\"648\":1,\"658\":1,\"676\":1}}],[\"alter\",{\"1\":{\"479\":2}}],[\"already\",{\"1\":{\"517\":1}}],[\"alias=\",{\"1\":{\"560\":1}}],[\"alive\",{\"1\":{\"455\":1}}],[\"alice\",{\"1\":{\"285\":1}}],[\"along\",{\"1\":{\"439\":1}}],[\"alogorithm\",{\"0\":{\"417\":1}}],[\"algorithms\",{\"0\":{\"421\":1},\"1\":{\"377\":1}}],[\"algorithm\",{\"0\":{\"347\":1,\"350\":1,\"354\":1,\"356\":1,\"357\":1,\"380\":1},\"1\":{\"343\":1,\"353\":2,\"355\":2,\"356\":1,\"361\":1,\"364\":1,\"383\":1}}],[\"allargsconstructor和\",{\"1\":{\"540\":1}}],[\"allargsconstructor\",{\"1\":{\"538\":1}}],[\"all|权限1\",{\"1\":{\"502\":2}}],[\"all\",{\"1\":{\"326\":1,\"338\":1,\"640\":2,\"656\":2}}],[\"a∼π​\",{\"1\":{\"311\":3,\"440\":1}}],[\"adriver\",{\"1\":{\"517\":6}}],[\"advantage\",{\"0\":{\"310\":1}}],[\"addhandler\",{\"1\":{\"647\":1,\"648\":1,\"657\":1}}],[\"addmappers\",{\"1\":{\"632\":1}}],[\"adduser\",{\"1\":{\"589\":2,\"590\":1}}],[\"addbatch\",{\"1\":{\"526\":2}}],[\"addifabsent\",{\"1\":{\"517\":1}}],[\"added\",{\"1\":{\"517\":1}}],[\"addlast\",{\"1\":{\"44\":1}}],[\"addfirst\",{\"1\":{\"44\":1}}],[\"addall\",{\"1\":{\"23\":1,\"24\":1,\"47\":1,\"48\":1,\"49\":1}}],[\"add\",{\"1\":{\"14\":2,\"23\":2,\"24\":1,\"25\":13,\"37\":1,\"43\":1,\"47\":1,\"48\":3,\"50\":6,\"71\":16,\"79\":2,\"80\":2,\"84\":1,\"155\":9,\"174\":3,\"193\":1,\"285\":2,\"479\":1}}],[\"a∣s\",{\"1\":{\"305\":1,\"311\":3,\"326\":1,\"328\":2,\"329\":5,\"330\":4,\"333\":3,\"334\":1,\"340\":2,\"342\":2,\"343\":1,\"348\":2,\"351\":3,\"364\":1,\"372\":1,\"398\":1,\"433\":1,\"438\":1,\"440\":14,\"441\":2}}],[\"attempting\",{\"1\":{\"517\":1}}],[\"at+1​\",{\"1\":{\"401\":2,\"424\":1,\"425\":1}}],[\"at\",{\"1\":{\"304\":1,\"305\":1,\"571\":1}}],[\"at​∣st​\",{\"1\":{\"441\":1}}],[\"at​=a\",{\"1\":{\"328\":1,\"329\":2,\"333\":2,\"334\":1,\"360\":1,\"362\":1,\"363\":1,\"404\":1}}],[\"at​\",{\"1\":{\"298\":1,\"401\":8,\"405\":5,\"424\":2,\"425\":2,\"441\":1}}],[\"ai​\",{\"1\":{\"304\":1,\"427\":2}}],[\"awgn\",{\"1\":{\"294\":1}}],[\"aerial\",{\"1\":{\"289\":1}}],[\"aeiou\",{\"1\":{\"246\":1}}],[\"a<t>\",{\"1\":{\"282\":2}}],[\"a<>\",{\"1\":{\"282\":1}}],[\"a<string>\",{\"1\":{\"282\":2}}],[\"aasd\",{\"1\":{\"207\":1}}],[\"aaaa\",{\"1\":{\"71\":1,\"242\":1}}],[\"aaa\",{\"1\":{\"14\":1,\"43\":1,\"44\":1,\"48\":4,\"80\":2,\"245\":1,\"285\":1}}],[\"annotationprocessor\",{\"1\":{\"539\":1}}],[\"annotationtype\",{\"1\":{\"208\":2}}],[\"annotation\",{\"1\":{\"208\":14}}],[\"aninterface\",{\"1\":{\"186\":2}}],[\"and\",{\"0\":{\"288\":1},\"1\":{\"167\":2,\"289\":2,\"299\":1,\"333\":1,\"334\":1,\"337\":1,\"338\":1,\"360\":1,\"427\":1,\"491\":1,\"516\":1,\"532\":2,\"533\":2,\"562\":1,\"563\":1,\"571\":2,\"601\":1,\"602\":3,\"630\":2}}],[\"any\",{\"1\":{\"139\":1,\"338\":1,\"343\":1,\"371\":1}}],[\"an\",{\"1\":{\"139\":1,\"304\":1,\"332\":1,\"333\":1}}],[\"abs方法可以求绝对值\",{\"1\":{\"274\":1}}],[\"abs\",{\"1\":{\"274\":1}}],[\"abstractset<e>\",{\"1\":{\"67\":1}}],[\"abstractsequentiallist<e>\",{\"1\":{\"25\":1,\"42\":1}}],[\"abstractmap<k\",{\"1\":{\"58\":1}}],[\"abstractlist<e>\",{\"1\":{\"25\":1}}],[\"abstract\",{\"1\":{\"16\":8,\"139\":1,\"218\":2,\"219\":1,\"255\":2}}],[\"abc\",{\"1\":{\"246\":2,\"625\":1}}],[\"abcabccaa\",{\"1\":{\"246\":1}}],[\"abcd\",{\"1\":{\"91\":3}}],[\"a是上一次计算的值\",{\"1\":{\"71\":1}}],[\"asc|desc\",{\"1\":{\"492\":3}}],[\"asdf\",{\"1\":{\"186\":1}}],[\"asdasda\",{\"1\":{\"71\":1}}],[\"association\",{\"1\":{\"581\":1}}],[\"association>\",{\"1\":{\"578\":1,\"583\":1}}],[\"associate\",{\"1\":{\"305\":1}}],[\"assisted\",{\"1\":{\"289\":1}}],[\"assertionerror\",{\"1\":{\"268\":1}}],[\"assert\",{\"1\":{\"268\":2}}],[\"assert断言表达式\",{\"1\":{\"268\":1}}],[\"assubclass\",{\"1\":{\"186\":2}}],[\"assdw\",{\"1\":{\"71\":1}}],[\"as\",{\"1\":{\"167\":2,\"343\":1,\"389\":1,\"507\":2,\"583\":2}}],[\"aslist\",{\"1\":{\"25\":2,\"30\":2,\"34\":2,\"35\":1,\"48\":1,\"49\":1,\"65\":1,\"71\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":4,\"173\":1,\"186\":1}}],[\"apache\",{\"1\":{\"569\":2,\"571\":2,\"601\":1}}],[\"apng\",{\"1\":{\"455\":1}}],[\"apptest\",{\"1\":{\"507\":1}}],[\"appears\",{\"1\":{\"366\":1}}],[\"append\",{\"1\":{\"97\":1,\"245\":7,\"676\":11}}],[\"approximation\",{\"0\":{\"415\":1,\"422\":1,\"423\":1,\"424\":1,\"425\":1},\"1\":{\"377\":1,\"432\":1}}],[\"approximate\",{\"1\":{\"367\":1}}],[\"approach\",{\"1\":{\"299\":2}}],[\"appropriate\",{\"1\":{\"167\":1}}],[\"application\",{\"1\":{\"455\":3,\"517\":1}}],[\"applets\",{\"1\":{\"515\":1}}],[\"applewebkit\",{\"1\":{\"455\":1}}],[\"apple\",{\"1\":{\"255\":3}}],[\"apply\",{\"1\":{\"24\":1}}],[\"api\",{\"1\":{\"71\":1,\"515\":1}}],[\"api添加了一个新的抽象称为\",{\"1\":{\"71\":1}}],[\"after\",{\"1\":{\"61\":1}}],[\"afternodeinsertion\",{\"1\":{\"59\":1}}],[\"afternodeaccess\",{\"1\":{\"59\":1}}],[\"active\",{\"1\":{\"475\":2}}],[\"actions\",{\"1\":{\"305\":1}}],[\"action\",{\"0\":{\"333\":1,\"400\":1,\"404\":1},\"1\":{\"32\":3,\"35\":3,\"36\":3,\"139\":1,\"298\":1,\"304\":3,\"305\":2,\"333\":8,\"334\":2,\"338\":2,\"342\":2,\"348\":1,\"351\":1,\"355\":2,\"360\":1,\"362\":5,\"364\":6,\"366\":9,\"367\":3,\"369\":4,\"371\":2,\"377\":1,\"400\":4,\"401\":1,\"404\":2,\"405\":1,\"416\":1}}],[\"actor\",{\"0\":{\"308\":1,\"309\":1,\"310\":1,\"314\":1,\"318\":1},\"1\":{\"308\":2}}],[\"academic\",{\"0\":{\"688\":1},\"2\":{\"300\":1,\"306\":1,\"319\":1,\"335\":1,\"344\":1,\"358\":1,\"375\":1,\"392\":1,\"413\":1,\"430\":1,\"443\":1}}],[\"accpeted\",{\"1\":{\"455\":1}}],[\"acc\",{\"1\":{\"139\":2}}],[\"accessors来控制生成getter和setter的样式\",{\"1\":{\"540\":1}}],[\"accesscontrolcontext\",{\"1\":{\"139\":2}}],[\"accepted\",{\"1\":{\"455\":1}}],[\"accept\",{\"1\":{\"32\":1,\"35\":1,\"36\":1,\"447\":2,\"448\":2,\"454\":1,\"455\":5}}],[\"are\",{\"1\":{\"571\":1}}],[\"arithmeticexception\",{\"1\":{\"266\":1}}],[\"arg0\",{\"1\":{\"571\":1}}],[\"arg1\",{\"1\":{\"571\":1}}],[\"arg\",{\"1\":{\"242\":2,\"628\":3}}],[\"args\",{\"1\":{\"4\":3,\"5\":1,\"14\":5,\"15\":3,\"16\":1,\"23\":1,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"48\":3,\"49\":1,\"50\":2,\"57\":4,\"64\":1,\"65\":1,\"66\":3,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":2,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":1,\"120\":2,\"121\":1,\"126\":2,\"127\":1,\"128\":2,\"129\":2,\"131\":1,\"133\":1,\"138\":1,\"140\":1,\"142\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":4,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":1,\"182\":1,\"183\":1,\"184\":1,\"186\":9,\"191\":2,\"192\":3,\"193\":3,\"198\":3,\"199\":1,\"206\":1,\"207\":3,\"208\":2,\"219\":2,\"220\":1,\"221\":1,\"227\":4,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":1,\"242\":3,\"244\":3,\"245\":3,\"246\":2,\"251\":2,\"252\":1,\"254\":1,\"255\":3,\"256\":1,\"257\":3,\"258\":5,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":1,\"281\":3,\"282\":2,\"447\":3,\"448\":2,\"454\":2,\"455\":2,\"524\":1,\"526\":1,\"533\":1,\"534\":4,\"552\":1,\"554\":1,\"558\":1,\"636\":1,\"638\":1,\"678\":2}}],[\"arrav\",{\"1\":{\"238\":1}}],[\"array就是我们要遍历的数组\",{\"1\":{\"237\":1}}],[\"arraydeque<>\",{\"1\":{\"45\":1}}],[\"array\",{\"1\":{\"25\":2,\"235\":2,\"236\":2,\"237\":4,\"238\":2}}],[\"arraylist源码部分\",{\"1\":{\"25\":1}}],[\"arraylist<e>\",{\"1\":{\"25\":1}}],[\"arraylist<>\",{\"1\":{\"23\":1,\"25\":6,\"71\":5,\"76\":1,\"78\":1,\"79\":1,\"80\":3,\"84\":1,\"173\":1,\"186\":1,\"193\":1}}],[\"arraylist<string>\",{\"1\":{\"23\":1,\"25\":1}}],[\"arraylist\",{\"0\":{\"25\":1},\"1\":{\"23\":2,\"25\":3,\"33\":1,\"186\":1,\"193\":1,\"285\":1}}],[\"arrays类\",{\"1\":{\"275\":2}}],[\"arrays\",{\"1\":{\"14\":9,\"24\":1,\"25\":4,\"30\":2,\"34\":2,\"35\":1,\"48\":1,\"49\":1,\"65\":1,\"71\":2,\"77\":1,\"78\":1,\"79\":1,\"80\":4,\"98\":1,\"173\":3,\"186\":1,\"275\":5,\"646\":1,\"655\":1}}],[\"arr\",{\"1\":{\"14\":12,\"173\":3,\"238\":8,\"240\":2,\"267\":2,\"275\":2}}],[\"a\",{\"1\":{\"4\":1,\"8\":4,\"16\":4,\"23\":1,\"24\":3,\"25\":3,\"30\":2,\"34\":2,\"35\":1,\"46\":2,\"47\":1,\"48\":1,\"49\":1,\"50\":2,\"64\":2,\"71\":6,\"84\":4,\"107\":1,\"139\":3,\"219\":1,\"227\":7,\"229\":1,\"239\":3,\"241\":1,\"246\":6,\"251\":2,\"256\":3,\"257\":5,\"258\":5,\"266\":4,\"267\":2,\"268\":2,\"281\":3,\"282\":7,\"285\":1,\"289\":1,\"298\":3,\"299\":2,\"304\":7,\"305\":5,\"311\":2,\"326\":3,\"328\":1,\"329\":3,\"330\":6,\"333\":13,\"334\":2,\"337\":1,\"338\":1,\"340\":3,\"342\":1,\"343\":2,\"348\":6,\"351\":6,\"355\":1,\"360\":3,\"362\":11,\"363\":8,\"364\":3,\"366\":2,\"367\":2,\"369\":6,\"371\":1,\"377\":1,\"398\":1,\"400\":4,\"401\":3,\"404\":3,\"405\":4,\"420\":1,\"426\":3,\"427\":22,\"438\":5,\"440\":9,\"441\":4,\"455\":1,\"517\":1,\"534\":4}}],[\"age=18\",{\"1\":{\"580\":1}}],[\"age=0\",{\"1\":{\"455\":1}}],[\"age>\",{\"1\":{\"545\":1}}],[\"agent从一个状态出发\",{\"1\":{\"333\":1}}],[\"agent从一个状态出发可以得到的平均return\",{\"1\":{\"333\":1}}],[\"agent可能走出的全部轨迹\",{\"1\":{\"304\":1}}],[\"agent将获得负奖励\",{\"1\":{\"298\":1}}],[\"agent\",{\"1\":{\"298\":1,\"304\":2,\"333\":2,\"439\":1,\"455\":1}}],[\"age已经初始化完\",{\"1\":{\"9\":1}}],[\"age\",{\"1\":{\"4\":1,\"5\":2,\"9\":18,\"117\":1,\"121\":1,\"186\":1,\"191\":1,\"192\":1,\"216\":2,\"218\":6,\"219\":2,\"220\":2,\"241\":1,\"475\":3,\"562\":3,\"563\":3,\"564\":2,\"569\":6,\"571\":7,\"577\":1,\"578\":2,\"579\":2,\"580\":1,\"581\":3,\"583\":3,\"589\":2,\"590\":2,\"591\":4,\"599\":1,\"601\":1,\"602\":3,\"605\":3,\"624\":2,\"625\":4,\"626\":1,\"628\":6,\"630\":3}}],[\"a+b=c\",{\"1\":{\"0\":1}}],[\"pwd=\",{\"1\":{\"532\":2,\"533\":2}}],[\"pk\",{\"1\":{\"476\":2}}],[\"pkn​\",{\"1\":{\"296\":1,\"298\":1}}],[\"pkn​​=pmax​\",{\"1\":{\"294\":1}}],[\"plain\",{\"1\":{\"544\":1}}],[\"platform\",{\"1\":{\"455\":1}}],[\"plos​μlos​+pnlos​μnlos​\",{\"1\":{\"294\":1}}],[\"plos​\",{\"1\":{\"294\":1}}],[\"pπ​\",{\"1\":{\"331\":1}}],[\"pπ​∈rn×n\",{\"1\":{\"331\":1}}],[\"pm​ax​\",{\"1\":{\"294\":1}}],[\"pmax​≥γσ2k0​dkn​​α\",{\"1\":{\"294\":1}}],[\"ppolicy\",{\"1\":{\"409\":1}}],[\"ppp\",{\"1\":{\"255\":1}}],[\"pp\",{\"1\":{\"255\":2,\"256\":2}}],[\"ppenguin\",{\"1\":{\"207\":1}}],[\"python等等都是支持正则表达式的\",{\"1\":{\"246\":1}}],[\"pi\",{\"1\":{\"351\":1,\"353\":1,\"355\":1}}],[\"pig\",{\"1\":{\"162\":1}}],[\"pid\",{\"1\":{\"156\":1}}],[\"parent\",{\"1\":{\"655\":2,\"656\":1}}],[\"parse\",{\"1\":{\"547\":1}}],[\"param来指定参数名称\",{\"1\":{\"630\":1}}],[\"param注解来指定某个参数的名称\",{\"1\":{\"571\":1}}],[\"param2\",{\"1\":{\"571\":4}}],[\"param1\",{\"1\":{\"571\":4}}],[\"params\",{\"1\":{\"569\":2}}],[\"param\",{\"1\":{\"527\":4,\"558\":1,\"571\":4,\"591\":2}}],[\"parameters\",{\"1\":{\"571\":1,\"580\":2}}],[\"parametertype=\",{\"1\":{\"559\":3,\"570\":1,\"582\":1,\"589\":1,\"590\":1,\"625\":1}}],[\"parameter\",{\"1\":{\"192\":3,\"571\":1,\"588\":3}}],[\"parameterizedtype\",{\"1\":{\"186\":7}}],[\"parallelsort\",{\"1\":{\"173\":1}}],[\"parallelstream就是利用了可拆分迭代器进行多线程操作\",{\"1\":{\"173\":1}}],[\"parallelstream\",{\"1\":{\"23\":1,\"173\":3}}],[\"password=123456\",{\"1\":{\"664\":1}}],[\"password\",{\"1\":{\"517\":4,\"552\":1}}],[\"pair\",{\"1\":{\"364\":1,\"366\":6,\"367\":1,\"369\":2,\"371\":1}}],[\"pattern\",{\"1\":{\"246\":1}}],[\"paths\",{\"1\":{\"110\":1}}],[\"package\",{\"1\":{\"120\":3,\"192\":1,\"198\":1,\"199\":1,\"220\":1,\"254\":3,\"255\":2}}],[\"pool\",{\"1\":{\"580\":1}}],[\"pooleddatasource\",{\"1\":{\"632\":2}}],[\"pooled\",{\"1\":{\"552\":1}}],[\"poor\",{\"1\":{\"295\":1}}],[\"pojos\",{\"1\":{\"544\":1}}],[\"poicy\",{\"0\":{\"410\":1}}],[\"point\",{\"1\":{\"343\":1}}],[\"postgresql\",{\"1\":{\"590\":1}}],[\"positive\",{\"1\":{\"371\":1,\"382\":1}}],[\"possible\",{\"1\":{\"326\":1}}],[\"policies\",{\"1\":{\"370\":1,\"372\":2}}],[\"policy版本\",{\"1\":{\"425\":1}}],[\"policyevaluation\",{\"1\":{\"362\":1}}],[\"policy\",{\"0\":{\"314\":1,\"316\":1,\"338\":1,\"350\":1,\"354\":1,\"355\":1,\"356\":1,\"357\":1,\"367\":1,\"371\":1,\"372\":1,\"373\":1,\"406\":2,\"407\":1,\"408\":1,\"411\":1,\"432\":1},\"1\":{\"304\":2,\"305\":1,\"308\":2,\"330\":1,\"332\":1,\"337\":1,\"338\":2,\"348\":3,\"351\":2,\"353\":1,\"354\":1,\"355\":11,\"356\":2,\"361\":1,\"362\":1,\"364\":4,\"367\":3,\"371\":2,\"372\":2,\"373\":1,\"396\":1,\"400\":1,\"405\":1,\"406\":2,\"407\":2,\"408\":4,\"409\":3,\"410\":2,\"429\":1,\"432\":2,\"433\":1}}],[\"polllast\",{\"1\":{\"44\":1}}],[\"pollfirst\",{\"1\":{\"44\":1}}],[\"poll\",{\"1\":{\"43\":3,\"46\":6,\"174\":1}}],[\"power\",{\"1\":{\"294\":1}}],[\"pow\",{\"1\":{\"274\":1}}],[\"pop\",{\"1\":{\"44\":3}}],[\"pu\",{\"1\":{\"355\":1}}],[\"puttreeval\",{\"1\":{\"59\":1}}],[\"putval\",{\"1\":{\"59\":2}}],[\"putifabsent\",{\"1\":{\"57\":2}}],[\"putall\",{\"1\":{\"56\":1}}],[\"put\",{\"0\":{\"59\":1},\"1\":{\"56\":1,\"57\":5,\"59\":1,\"64\":4,\"66\":3,\"84\":1,\"174\":1,\"517\":2}}],[\"push\",{\"1\":{\"44\":3}}],[\"public\",{\"1\":{\"4\":4,\"5\":2,\"9\":4,\"14\":8,\"15\":6,\"16\":5,\"23\":3,\"24\":1,\"25\":15,\"30\":2,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"36\":5,\"37\":1,\"42\":1,\"43\":2,\"44\":2,\"45\":1,\"46\":2,\"47\":1,\"48\":3,\"49\":1,\"50\":2,\"56\":1,\"57\":4,\"58\":2,\"59\":1,\"64\":1,\"65\":5,\"66\":3,\"67\":5,\"71\":7,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":3,\"84\":9,\"90\":2,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":2,\"112\":3,\"113\":1,\"117\":2,\"120\":5,\"121\":6,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"131\":2,\"132\":1,\"133\":2,\"138\":1,\"139\":3,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"154\":1,\"155\":6,\"156\":1,\"161\":1,\"162\":1,\"163\":1,\"165\":6,\"166\":2,\"167\":5,\"172\":2,\"173\":2,\"174\":2,\"182\":1,\"183\":2,\"184\":1,\"186\":11,\"191\":7,\"192\":8,\"193\":3,\"198\":5,\"199\":5,\"206\":4,\"207\":9,\"208\":3,\"215\":10,\"216\":3,\"218\":8,\"219\":9,\"220\":6,\"221\":13,\"227\":5,\"228\":1,\"229\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"240\":1,\"241\":5,\"242\":1,\"244\":3,\"245\":3,\"246\":2,\"251\":15,\"252\":5,\"253\":5,\"254\":9,\"255\":12,\"256\":2,\"257\":3,\"258\":8,\"265\":4,\"266\":1,\"267\":4,\"268\":1,\"274\":2,\"275\":1,\"280\":3,\"281\":9,\"282\":7,\"447\":3,\"448\":4,\"454\":4,\"455\":3,\"517\":2,\"524\":2,\"526\":1,\"527\":3,\"533\":1,\"534\":4,\"538\":9,\"552\":2,\"554\":3,\"558\":3,\"563\":1,\"564\":1,\"569\":6,\"570\":1,\"577\":2,\"581\":2,\"583\":2,\"589\":1,\"623\":1,\"624\":1,\"626\":1,\"628\":2,\"630\":2,\"631\":1,\"636\":2,\"638\":9,\"640\":2,\"665\":1,\"672\":3,\"676\":1,\"678\":4}}],[\"pe\",{\"1\":{\"351\":2,\"353\":1,\"355\":1,\"362\":1}}],[\"persistenceexception\",{\"1\":{\"569\":1}}],[\"person\",{\"1\":{\"4\":8,\"5\":3,\"9\":8,\"117\":3,\"120\":1,\"121\":2,\"216\":10,\"218\":3,\"219\":1,\"220\":1,\"241\":5}}],[\"permission\",{\"1\":{\"517\":1}}],[\"periods\",{\"1\":{\"295\":1}}],[\"people\",{\"1\":{\"131\":9,\"132\":2,\"133\":9}}],[\"penguin\",{\"1\":{\"110\":1,\"127\":1,\"131\":1,\"162\":1,\"191\":1,\"192\":4,\"219\":1,\"254\":1,\"255\":4,\"455\":1}}],[\"peeklast\",{\"1\":{\"44\":1}}],[\"peekfirst\",{\"1\":{\"44\":1}}],[\"peek\",{\"1\":{\"43\":1}}],[\"proxy2\",{\"1\":{\"570\":1}}],[\"projectlombok\",{\"1\":{\"539\":1}}],[\"problems\",{\"1\":{\"377\":1}}],[\"probability\",{\"1\":{\"304\":1,\"305\":4,\"371\":1,\"383\":1,\"418\":1}}],[\"prop\",{\"1\":{\"569\":2}}],[\"prop是要设置的值的字段信息\",{\"1\":{\"569\":1}}],[\"properties默认的日志级别\",{\"1\":{\"679\":1}}],[\"properties文件\",{\"1\":{\"666\":1}}],[\"properties格式的文件是java的一种配置文件\",{\"1\":{\"664\":1}}],[\"properties\",{\"1\":{\"517\":3,\"665\":8,\"666\":8,\"667\":1}}],[\"propertytokenizer\",{\"1\":{\"569\":1}}],[\"property=\",{\"1\":{\"563\":2,\"578\":8,\"579\":4,\"581\":6,\"582\":4,\"583\":10,\"626\":2}}],[\"property\",{\"1\":{\"305\":1,\"563\":1,\"626\":2,\"629\":2}}],[\"proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件\",{\"1\":{\"294\":1}}],[\"proposition1\",{\"1\":{\"294\":1}}],[\"proposed\",{\"1\":{\"289\":1}}],[\"process\",{\"0\":{\"305\":1},\"1\":{\"305\":1,\"420\":1}}],[\"profession\",{\"1\":{\"218\":4}}],[\"produces\",{\"1\":{\"167\":1}}],[\"protected\",{\"1\":{\"121\":2,\"215\":2,\"218\":7,\"255\":1,\"264\":1,\"266\":1}}],[\"preparing\",{\"1\":{\"580\":2}}],[\"preparestatement\",{\"1\":{\"518\":1,\"533\":1}}],[\"preparedstatement\",{\"1\":{\"518\":1,\"533\":1}}],[\"present\",{\"1\":{\"67\":1}}],[\"previousindex\",{\"1\":{\"37\":1}}],[\"previous\",{\"1\":{\"37\":1}}],[\"prev\",{\"1\":{\"25\":4}}],[\"predicate<\",{\"1\":{\"23\":1}}],[\"primary\",{\"1\":{\"475\":2,\"476\":3}}],[\"primitive\",{\"1\":{\"183\":2}}],[\"priority\",{\"1\":{\"145\":4}}],[\"priorityqueue<>\",{\"1\":{\"45\":1,\"46\":2}}],[\"printwriter\",{\"1\":{\"517\":1,\"524\":1}}],[\"print\",{\"1\":{\"237\":2,\"274\":1,\"448\":1,\"455\":1}}],[\"printstream也永远不会抛出异常\",{\"1\":{\"127\":1}}],[\"printstream也继承自filteroutputstream类\",{\"1\":{\"127\":1}}],[\"printstream\",{\"1\":{\"127\":3}}],[\"printstacktrace\",{\"1\":{\"90\":3,\"91\":3,\"92\":2,\"93\":1,\"94\":1,\"96\":2,\"97\":1,\"98\":1,\"105\":1,\"108\":2,\"112\":3,\"113\":1,\"126\":2,\"127\":1,\"129\":2,\"131\":1,\"133\":1,\"144\":1,\"148\":1,\"156\":2,\"161\":1,\"162\":1,\"165\":2,\"172\":2,\"174\":1,\"199\":2,\"267\":1,\"447\":3,\"448\":1,\"454\":1,\"455\":2,\"516\":1,\"526\":1,\"527\":1,\"532\":1,\"533\":1,\"534\":4,\"547\":1,\"558\":1}}],[\"println\",{\"1\":{\"4\":1,\"5\":1,\"9\":3,\"14\":4,\"25\":9,\"30\":2,\"34\":2,\"35\":1,\"43\":2,\"44\":2,\"46\":6,\"48\":7,\"49\":1,\"50\":2,\"57\":4,\"64\":2,\"65\":1,\"66\":3,\"71\":8,\"77\":1,\"78\":1,\"80\":3,\"84\":2,\"91\":6,\"96\":2,\"98\":9,\"105\":1,\"108\":8,\"112\":3,\"117\":2,\"121\":1,\"126\":1,\"127\":1,\"129\":1,\"131\":1,\"133\":1,\"138\":1,\"140\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":6,\"148\":6,\"154\":3,\"155\":8,\"156\":2,\"161\":4,\"162\":4,\"163\":1,\"165\":2,\"166\":1,\"167\":1,\"172\":2,\"173\":2,\"174\":2,\"183\":1,\"184\":5,\"186\":15,\"191\":2,\"192\":5,\"193\":4,\"198\":5,\"199\":2,\"208\":6,\"216\":2,\"218\":1,\"219\":2,\"220\":4,\"221\":1,\"227\":3,\"228\":1,\"229\":2,\"236\":1,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"245\":3,\"246\":2,\"251\":5,\"252\":1,\"253\":1,\"254\":7,\"255\":3,\"256\":1,\"257\":3,\"258\":2,\"267\":3,\"274\":1,\"275\":1,\"281\":1,\"447\":6,\"448\":8,\"454\":1,\"455\":5,\"516\":1,\"517\":7,\"524\":1,\"527\":1,\"532\":1,\"533\":2,\"547\":1,\"554\":1,\"558\":1,\"560\":1,\"561\":1,\"562\":1,\"564\":3,\"569\":1,\"570\":2,\"571\":1,\"593\":2,\"611\":6,\"612\":2,\"616\":1,\"625\":1,\"646\":1,\"655\":2,\"658\":3,\"665\":1,\"666\":2,\"672\":3,\"678\":2}}],[\"private\",{\"1\":{\"14\":2,\"15\":3,\"25\":5,\"65\":3,\"67\":2,\"121\":2,\"132\":1,\"133\":1,\"154\":1,\"155\":7,\"167\":3,\"174\":3,\"215\":1,\"216\":1,\"218\":2,\"221\":2,\"251\":2,\"252\":1,\"253\":1,\"257\":1,\"266\":2,\"267\":2,\"517\":1,\"527\":1,\"538\":6,\"558\":1,\"569\":1,\"632\":1}}],[\"p2\",{\"1\":{\"4\":1,\"216\":3}}],[\"p1\",{\"1\":{\"4\":2,\"216\":3}}],[\"p\",{\"1\":{\"4\":4,\"5\":4,\"59\":10,\"304\":1,\"305\":3,\"326\":2,\"329\":1,\"330\":2,\"348\":2,\"360\":1,\"362\":4,\"383\":1,\"501\":1}}],[\"是hashmap的同步加锁版\",{\"1\":{\"665\":1}}],[\"是通过添加注解来实现的\",{\"1\":{\"539\":1}}],[\"是通过一个容器来解决生产者和消费者的强耦合问题\",{\"1\":{\"174\":1}}],[\"是从1开始的\",{\"1\":{\"527\":1}}],[\"是数据库控制语言\",{\"1\":{\"472\":1}}],[\"是用来设置或更改数据库用户或角色权限的语句\",{\"1\":{\"472\":1}}],[\"是用来与环境进行交互\",{\"1\":{\"406\":1}}],[\"是用于描述数据库中要存储的现实世界实体的语言\",{\"1\":{\"472\":1}}],[\"是开发以数据为中心的应用程序必定会使用到的指令\",{\"1\":{\"472\":1}}],[\"是sql语言中\",{\"1\":{\"472\":1}}],[\"是string类型的\",{\"1\":{\"280\":1}}],[\"是由一批数据构成的有序集合\",{\"1\":{\"460\":1}}],[\"是由环境决定的\",{\"1\":{\"330\":1}}],[\"是获取对应流的内容\",{\"1\":{\"448\":1}}],[\"是把东西先到对应的流里\",{\"1\":{\"448\":1}}],[\"是操作系统底层提供的一项通信技术\",{\"1\":{\"446\":1}}],[\"是未知的\",{\"1\":{\"441\":1}}],[\"是各个\",{\"1\":{\"435\":1}}],[\"是我们需要进行优化的\",{\"1\":{\"433\":1}}],[\"是我们不断进行更新的策略\",{\"1\":{\"406\":1}}],[\"是直接建立一个基于策略的目标函数来进行梯度上升的优化\",{\"1\":{\"432\":1}}],[\"是直接继承自hashmap\",{\"1\":{\"61\":1}}],[\"是qπ​\",{\"1\":{\"401\":1}}],[\"是关于\",{\"1\":{\"397\":1}}],[\"是常数\",{\"1\":{\"395\":1}}],[\"是需要被优化的参数\",{\"1\":{\"386\":1}}],[\"是第\",{\"1\":{\"382\":2}}],[\"是针对\",{\"1\":{\"365\":1}}],[\"是针对一条trajectory所求的\",{\"1\":{\"326\":1}}],[\"是优于\",{\"1\":{\"353\":1}}],[\"是已知的\",{\"1\":{\"348\":1}}],[\"是依赖于策略π的\",{\"1\":{\"333\":1}}],[\"是基于一个给定策略\",{\"1\":{\"325\":1}}],[\"是\",{\"1\":{\"325\":1,\"334\":1,\"371\":1,\"398\":1,\"408\":2,\"409\":1,\"435\":1,\"600\":1}}],[\"是最优的\",{\"1\":{\"369\":1}}],[\"是最大报文长度\",{\"1\":{\"295\":1}}],[\"是最顶层的类\",{\"1\":{\"215\":1}}],[\"是网页大小\",{\"1\":{\"295\":1}}],[\"是与传输速率有关的延迟时间\",{\"1\":{\"295\":1}}],[\"是某个异常的父类\",{\"1\":{\"267\":1}}],[\"是某一类事物实际存在的每个个体\",{\"1\":{\"4\":1}}],[\"是继承\",{\"1\":{\"264\":1}}],[\"是无法访问到外部类的非静态内容的\",{\"1\":{\"252\":1}}],[\"是属于类的\",{\"1\":{\"252\":1}}],[\"是可以访问到外层的变量的\",{\"1\":{\"251\":1}}],[\"是可以的\",{\"1\":{\"238\":1}}],[\"是对现实世界数据特征的一种抽象\",{\"1\":{\"461\":1}}],[\"是对象所有的\",{\"1\":{\"251\":1}}],[\"是对一类事物的描述\",{\"1\":{\"4\":1}}],[\"是匹配所有空白符\",{\"1\":{\"246\":1}}],[\"是在基于\",{\"1\":{\"308\":1}}],[\"是在\",{\"1\":{\"274\":1,\"275\":1}}],[\"是在一开始就确定的\",{\"1\":{\"236\":1}}],[\"是在队尾进行插入\",{\"1\":{\"43\":1}}],[\"是只在代码中\",{\"1\":{\"205\":1}}],[\"是因为suspend\",{\"1\":{\"156\":1}}],[\"是因为集合类的实现方案有很多\",{\"1\":{\"31\":1}}],[\"是class类实例\",{\"1\":{\"155\":1}}],[\"是否开启自动提交\",{\"1\":{\"558\":1}}],[\"是否要满足子查询中的条件表达式\",{\"1\":{\"507\":1}}],[\"是否在集合中\",{\"1\":{\"491\":1}}],[\"是否成立\",{\"1\":{\"389\":1}}],[\"是否是收敛的\",{\"0\":{\"357\":1}}],[\"是否简洁\",{\"1\":{\"285\":1}}],[\"是否允许包含\",{\"1\":{\"285\":1}}],[\"是否支持增删元素\",{\"1\":{\"285\":1}}],[\"是否可变\",{\"1\":{\"285\":1}}],[\"是否可执行\",{\"1\":{\"98\":1}}],[\"是否可写\",{\"1\":{\"98\":1}}],[\"是否可读\",{\"1\":{\"98\":1}}],[\"是否为一个文件夹\",{\"1\":{\"98\":1}}],[\"是否为空\",{\"1\":{\"56\":1}}],[\"是根据q\",{\"1\":{\"298\":1}}],[\"是根据\",{\"1\":{\"84\":1}}],[\"是不同的\",{\"1\":{\"325\":1,\"408\":1}}],[\"是不是感觉非常简洁\",{\"1\":{\"257\":1}}],[\"是不是感觉这个工具类好像还挺好用的\",{\"1\":{\"80\":1}}],[\"是不是有点太浪费了\",{\"1\":{\"245\":1}}],[\"是不能\",{\"1\":{\"238\":1}}],[\"是不支持自动装箱和拆箱的\",{\"1\":{\"238\":1}}],[\"是不允许的\",{\"1\":{\"8\":1}}],[\"是以键值对的形式存在\",{\"1\":{\"55\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"544\":1}}],[\"是一种插件化注解api\",{\"1\":{\"539\":1}}],[\"是一种自动唤醒机制\",{\"1\":{\"161\":1}}],[\"是一致的\",{\"1\":{\"326\":1,\"407\":1}}],[\"是一个期望值\",{\"1\":{\"386\":1}}],[\"是一个随机变量\",{\"1\":{\"386\":1}}],[\"是一个\",{\"1\":{\"382\":1}}],[\"是一个黑盒\",{\"1\":{\"382\":1}}],[\"是一个必要条件\",{\"1\":{\"369\":1}}],[\"是一个contraction\",{\"1\":{\"343\":1}}],[\"是一个有关状态s的函数\",{\"1\":{\"325\":1}}],[\"是一个有序的集合\",{\"1\":{\"24\":1}}],[\"是一个非负整数\",{\"1\":{\"246\":2}}],[\"是一个新创建的线程\",{\"1\":{\"167\":1}}],[\"是一样的\",{\"1\":{\"62\":1}}],[\"是一起删除还是只删除一个呢\",{\"1\":{\"25\":1}}],[\"是为了方便日后如果我们想要更换不同的集合类实现\",{\"1\":{\"25\":1}}],[\"是为了完成某件事情而存在的\",{\"1\":{\"5\":1}}],[\"是集合类型的一个分支\",{\"1\":{\"24\":1}}],[\"是类的一个具体化个体\",{\"1\":{\"4\":1}}],[\"是抽象的\",{\"1\":{\"4\":1}}],[\"类进行存储成绩\",{\"1\":{\"280\":1}}],[\"类呢\",{\"1\":{\"280\":1}}],[\"类的子类\",{\"1\":{\"281\":1}}],[\"类的异常都是编译时异常\",{\"1\":{\"264\":1}}],[\"类的内部类它会单独生成一个\",{\"1\":{\"254\":1}}],[\"类的创建\",{\"1\":{\"4\":1}}],[\"类只能继承一个\",{\"1\":{\"219\":1}}],[\"类可以实现这个接口\",{\"1\":{\"219\":1}}],[\"类加载器就是用于加载一个类的\",{\"1\":{\"198\":1}}],[\"类加载器\",{\"0\":{\"198\":1}}],[\"类加载机制\",{\"0\":{\"180\":1}}],[\"类名称\",{\"1\":{\"676\":1}}],[\"类名\",{\"1\":{\"258\":3,\"649\":1}}],[\"类名上\",{\"1\":{\"203\":1}}],[\"类名必须和我们定义的保持一致\",{\"1\":{\"199\":1}}],[\"类名获取\",{\"1\":{\"182\":1}}],[\"类名的首字母通常是大写的\",{\"1\":{\"4\":1}}],[\"类还有三个方法我们从来没有使用过\",{\"1\":{\"161\":1}}],[\"类锁\",{\"1\":{\"155\":1}}],[\"类锁只有一个\",{\"1\":{\"155\":1}}],[\"类就是专用于集合的工具类\",{\"1\":{\"75\":1}}],[\"类似\",{\"1\":{\"71\":1,\"255\":1,\"510\":1}}],[\"类似于下面图中的日志格式\",{\"1\":{\"676\":1}}],[\"类似于一个插件\",{\"1\":{\"219\":1}}],[\"类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制\",{\"1\":{\"154\":1}}],[\"类似于c++中的namespace\",{\"1\":{\"120\":1}}],[\"类似于c++指针的情况\",{\"1\":{\"4\":1}}],[\"类似于vip用户可以优先结束排队\",{\"1\":{\"46\":1}}],[\"类型名称\",{\"1\":{\"559\":1}}],[\"类型的变量\",{\"1\":{\"281\":1}}],[\"类型的\",{\"1\":{\"241\":1}}],[\"类型的成绩了\",{\"1\":{\"15\":1}}],[\"类型为\",{\"1\":{\"186\":1}}],[\"类型比较\",{\"0\":{\"186\":1}}],[\"类型作为存储\",{\"1\":{\"96\":1}}],[\"类型擦除\",{\"0\":{\"16\":1}}],[\"类型\",{\"1\":{\"14\":2,\"235\":8,\"280\":1,\"281\":1,\"285\":1}}],[\"类型变量并不是只能在泛型类中才可以使用\",{\"1\":{\"14\":1}}],[\"类除了具有属性外\",{\"1\":{\"5\":1}}],[\"类\",{\"0\":{\"98\":1,\"181\":1,\"215\":1,\"244\":1,\"245\":1,\"252\":1},\"1\":{\"4\":1,\"23\":1,\"84\":1,\"155\":1,\"208\":1,\"217\":1,\"249\":1,\"264\":1,\"274\":1}}],[\"类与对象4\",{\"0\":{\"224\":1}}],[\"类与对象3\",{\"0\":{\"211\":1}}],[\"类与对象2\",{\"0\":{\"116\":1}}],[\"类与对象\",{\"0\":{\"4\":1}}],[\"类与对象1\",{\"0\":{\"3\":1}}],[\"dd\",{\"1\":{\"676\":1}}],[\"ddl\",{\"0\":{\"473\":1}}],[\"dtd\",{\"1\":{\"552\":3,\"554\":3}}],[\"driver=com\",{\"1\":{\"664\":1}}],[\"driverinfo\",{\"1\":{\"517\":2}}],[\"driveraction\",{\"1\":{\"517\":1}}],[\"driver\",{\"1\":{\"516\":6,\"517\":14,\"552\":2,\"632\":1,\"664\":1}}],[\"drivermanager是管理我们的数据库驱动的\",{\"1\":{\"517\":1}}],[\"drivermanager\",{\"0\":{\"517\":1},\"1\":{\"516\":1,\"517\":4,\"524\":1,\"526\":1,\"532\":1,\"533\":1,\"534\":4}}],[\"driven\",{\"1\":{\"289\":1}}],[\"drop\",{\"1\":{\"477\":1,\"479\":1,\"480\":1,\"507\":1,\"508\":1,\"509\":1}}],[\"df\",{\"1\":{\"476\":1}}],[\"db\",{\"1\":{\"472\":1}}],[\"dbcreator\",{\"1\":{\"472\":1}}],[\"dcl\",{\"0\":{\"499\":1},\"1\":{\"472\":1}}],[\"dml\",{\"0\":{\"481\":1,\"588\":1},\"1\":{\"472\":1}}],[\"dql\",{\"0\":{\"489\":1},\"1\":{\"472\":1}}],[\"dqn\",{\"0\":{\"426\":1},\"1\":{\"427\":1,\"429\":1}}],[\"d0​\",{\"1\":{\"437\":1}}],[\"dπ​\",{\"1\":{\"420\":2,\"437\":1}}],[\"dpg\",{\"0\":{\"318\":1}}],[\"dkn​​\",{\"1\":{\"294\":1}}],[\"dkn​​=hn2​\",{\"1\":{\"293\":1}}],[\"dkn​\",{\"1\":{\"294\":1}}],[\"dynamic\",{\"1\":{\"289\":1,\"330\":1}}],[\"difference\",{\"0\":{\"394\":1}}],[\"distributon\",{\"0\":{\"419\":1},\"1\":{\"420\":3}}],[\"distributed\",{\"1\":{\"360\":1}}],[\"distribution\",{\"0\":{\"420\":1},\"1\":{\"305\":1,\"418\":1,\"420\":1,\"437\":1}}],[\"distinct表示去重再统计\",{\"1\":{\"493\":1}}],[\"distinct\",{\"1\":{\"47\":1,\"71\":3,\"112\":1,\"490\":1,\"493\":7}}],[\"discounted\",{\"1\":{\"304\":1,\"327\":1,\"398\":1,\"422\":1}}],[\"divide\",{\"1\":{\"229\":1}}],[\"dormant\",{\"1\":{\"601\":1}}],[\"doctype\",{\"1\":{\"552\":1,\"554\":1}}],[\"documentbuilder\",{\"1\":{\"547\":1}}],[\"documentbuilderfactory\",{\"1\":{\"547\":2}}],[\"document\",{\"1\":{\"455\":1,\"547\":1}}],[\"documented\",{\"1\":{\"205\":1}}],[\"dog\",{\"1\":{\"524\":1}}],[\"download\",{\"1\":{\"539\":1}}],[\"down\",{\"1\":{\"293\":1}}],[\"doxy\",{\"1\":{\"246\":1}}],[\"does\",{\"1\":{\"246\":1,\"517\":1}}],[\"do\",{\"1\":{\"246\":3}}],[\"double用于存储双精度的小数\",{\"1\":{\"474\":1}}],[\"double\",{\"1\":{\"8\":3,\"227\":2}}],[\"da\",{\"1\":{\"517\":2}}],[\"dateformat\",{\"1\":{\"676\":2}}],[\"datetime用于混合存储日期+时间\",{\"1\":{\"474\":1}}],[\"date存储日期\",{\"1\":{\"474\":1}}],[\"date\",{\"1\":{\"174\":2,\"577\":1,\"676\":4}}],[\"datasource\",{\"1\":{\"632\":2,\"664\":4}}],[\"datasource>\",{\"1\":{\"552\":1}}],[\"data注解\",{\"1\":{\"611\":1}}],[\"data类似\",{\"1\":{\"540\":1}}],[\"data就不建议此类有继承关系\",{\"1\":{\"540\":1}}],[\"data能代表\",{\"1\":{\"540\":1}}],[\"databases\",{\"1\":{\"501\":1}}],[\"database来删除一个数据库\",{\"1\":{\"477\":1}}],[\"database来创建一个数据库\",{\"1\":{\"477\":1}}],[\"database\",{\"1\":{\"477\":3,\"569\":1}}],[\"data\",{\"1\":{\"167\":1,\"366\":1,\"454\":1,\"472\":4,\"515\":1,\"554\":2,\"563\":1,\"577\":2,\"581\":2,\"583\":2}}],[\"dataoutputstream\",{\"1\":{\"129\":4}}],[\"datainputstream\",{\"1\":{\"129\":4}}],[\"daily\",{\"0\":{\"683\":1},\"2\":{\"1\":1}}],[\"daily1\",{\"0\":{\"0\":1}}],[\"d\",{\"0\":{\"437\":1},\"1\":{\"71\":1,\"216\":1,\"218\":1,\"295\":3,\"360\":1,\"435\":2,\"437\":5,\"534\":1,\"547\":2}}],[\"detail表的查询操作\",{\"1\":{\"580\":1}}],[\"detail表的对应信息\",{\"1\":{\"579\":1}}],[\"detail=userdetail\",{\"1\":{\"580\":1}}],[\"detail\",{\"1\":{\"577\":1,\"578\":3,\"579\":2,\"580\":1,\"629\":2}}],[\"deterministic\",{\"0\":{\"318\":1,\"390\":1},\"1\":{\"299\":1,\"304\":1,\"338\":2}}],[\"development\",{\"1\":{\"552\":2,\"632\":1}}],[\"deny\",{\"1\":{\"472\":1}}],[\"deep\",{\"0\":{\"426\":1},\"1\":{\"426\":1}}],[\"deeptostring\",{\"1\":{\"275\":1}}],[\"decimal\",{\"1\":{\"476\":1}}],[\"decision\",{\"0\":{\"305\":1}}],[\"decode\",{\"1\":{\"228\":1}}],[\"demonstrating\",{\"1\":{\"289\":1}}],[\"dest\",{\"1\":{\"455\":1}}],[\"desc=description\",{\"1\":{\"664\":1}}],[\"description=我是一个阳光开朗大男孩\",{\"1\":{\"580\":1}}],[\"description\",{\"1\":{\"577\":1,\"578\":2,\"580\":1}}],[\"describes\",{\"1\":{\"420\":1}}],[\"desc>\",{\"1\":{\"545\":1}}],[\"descent\",{\"0\":{\"385\":1},\"1\":{\"386\":2}}],[\"descendingiterator\",{\"1\":{\"44\":1}}],[\"design\",{\"0\":{\"288\":1}}],[\"departmentname\",{\"1\":{\"476\":3}}],[\"departmentid\",{\"1\":{\"476\":2}}],[\"departments\",{\"1\":{\"475\":2,\"476\":2}}],[\"department\",{\"1\":{\"475\":2}}],[\"deployment\",{\"0\":{\"288\":1},\"1\":{\"289\":1}}],[\"deprecated\",{\"1\":{\"204\":1,\"516\":1}}],[\"deleteusers\",{\"1\":{\"604\":2}}],[\"deleteuserbyid\",{\"1\":{\"592\":1,\"593\":3,\"599\":1,\"604\":1}}],[\"delete>\",{\"1\":{\"592\":1,\"604\":1}}],[\"delete等操作时\",{\"1\":{\"509\":1}}],[\"delete时\",{\"1\":{\"509\":1}}],[\"delete三种指令为核心\",{\"1\":{\"472\":1}}],[\"delete\",{\"1\":{\"245\":1,\"472\":1,\"484\":2,\"509\":1,\"524\":1,\"588\":2,\"592\":1,\"604\":3,\"612\":1}}],[\"definition\",{\"1\":{\"472\":1}}],[\"defineclass\",{\"1\":{\"199\":3}}],[\"deflate\",{\"1\":{\"455\":1}}],[\"defaultformatter\",{\"1\":{\"667\":2}}],[\"defaultlevel\",{\"1\":{\"667\":2}}],[\"defaultbundle\",{\"1\":{\"638\":7,\"640\":2}}],[\"default=\",{\"1\":{\"552\":1}}],[\"default来指定默认值\",{\"1\":{\"540\":1}}],[\"default\",{\"1\":{\"23\":4,\"24\":2,\"25\":1,\"32\":2,\"35\":1,\"36\":2,\"47\":1,\"58\":1,\"60\":4,\"173\":1,\"207\":1,\"219\":2,\"475\":2,\"476\":1,\"477\":1}}],[\"deque<string>\",{\"1\":{\"44\":1,\"45\":1}}],[\"deque<e>\",{\"1\":{\"25\":1,\"42\":1,\"44\":1}}],[\"deque\",{\"0\":{\"42\":1,\"44\":1},\"1\":{\"44\":5,\"45\":1}}],[\"d1\",{\"2\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
