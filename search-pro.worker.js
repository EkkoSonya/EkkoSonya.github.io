const L=Object.entries,st=Object.fromEntries,nt="ENTRIES",T="KEYS",R="VALUES",_="";class k{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case R:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const D=g!==t[F],w=o[p+F]+ +D,A=o[p+F+1]+1,z=o[m+F]+1,V=o[m+F+1]=Math.min(w,A,z);V<l&&(l=V)}if(l>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=M(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new k(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new k(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new k(this,R)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)q(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},q=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)q(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=M(e);n.set(o+t,s),n.delete(o)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",N="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},H=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?J(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},U={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},X=Symbol("*"),At=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=dt[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){gt(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],D=at(y,m,e._documentCount,F,p,r),w=n*a*f*D,A=d.get(l);if(A){A.score+=w,lt(A.terms,t);const z=H(A.match,s);z?z.push(c):A.match[s]=[c]}else d.set(l,{score:w,terms:[t],match:{[s]:[c]}})}}return d},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:H(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...U.weights,...i},h=e._index.get(t.term),g=B(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);B(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);B(e,t.term,l,F,f,o,u,d,g)}return g},Q=(e,t,s={})=>{if(t===X)return At(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Q(e,g,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},Z=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===X&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Z(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class wt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...U,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new wt(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),bt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>j(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>j(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>j(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),L(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):bt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},et=(e,t,s={})=>Et(t,e,{fuzzy:.2,...s}).map(({suggestion:n})=>n),v=st(L(JSON.parse("{\"/\":{\"documentCount\":252,\"nextId\":252,\"documentIds\":{\"0\":\"2\",\"1\":\"2@0\",\"2\":\"2@1\",\"3\":\"3\",\"4\":\"3#主要动机\",\"5\":\"3#主要贡献\",\"6\":\"3#主要内容\",\"7\":\"3#系统结构\",\"8\":\"3#基本设置\",\"9\":\"3#信号模型\",\"10\":\"3#quality-of-experience-model\",\"11\":\"3#优化问题建立\",\"12\":\"3#解决方案\",\"13\":\"3#无人机的3d部署\",\"14\":\"3#无人机的动态移动设计\",\"15\":\"3@0\",\"16\":\"3@1\",\"17\":\"4\",\"18\":\"4#强化学习框架图\",\"19\":\"4#_1-基本概念\",\"20\":\"4#_2-markov-decision-process-mdp\",\"21\":\"4@0\",\"22\":\"4@1\",\"23\":\"5\",\"24\":\"5#_1-the-simplest-actor-critic-qac\",\"25\":\"5#_2-advantage-actor-critic-a2c\",\"26\":\"5#_2-1-baseline\",\"27\":\"5#_2-2-最好的-baseline\",\"28\":\"5#_2-3-对应算法\",\"29\":\"5#_3-off-policy-actor-critic\",\"30\":\"5#_3-1-重要性采样-importance-sampling\",\"31\":\"5#_3-2-off-policy\",\"32\":\"5#_3-3-伪代码\",\"33\":\"5#_4-deterministic-actor-critic-dpg\",\"34\":\"5@0\",\"35\":\"5@1\",\"36\":\"6\",\"37\":\"6#核心内容\",\"38\":\"6#_1-state-value\",\"39\":\"6#_1-1\",\"40\":\"6#_1-2-state-value\",\"41\":\"6#_1-3-state-value-与-return-的区别\",\"42\":\"6#_2-bellman-equation\",\"43\":\"6#_2-1-the-mean-of-immediate-rewards\",\"44\":\"6#_2-2-the-mean-of-future-rewards\",\"45\":\"6#_2-3-bellman-equation\",\"46\":\"6#_2-4-bellman-equation-matrix-vector-form\",\"47\":\"6#_3-why-to-slove-state-value\",\"48\":\"6#_4-action-value\",\"49\":\"6#_5-总结\",\"50\":\"6@0\",\"51\":\"6@1\",\"52\":\"7\",\"53\":\"7#_1-optimal-policy\",\"54\":\"7#_2-bellman-optimality-equation-boe\",\"55\":\"7#_2-1-基本形式\",\"56\":\"7#_2-2-如何求解\",\"57\":\"7#_2-2-1-如何处理等式右边的-最优策略\",\"58\":\"7#_2-求解-state-value\",\"59\":\"7@0\",\"60\":\"7@1\",\"61\":\"8\",\"62\":\"8#_1-value-iteration-algorithm\",\"63\":\"8#_1-1-具体步骤\",\"64\":\"8#_1-2-伪代码\",\"65\":\"8#_2-policy-iteration-algorithm\",\"66\":\"8#_2-1-算法描述\",\"67\":\"8#_2-2-伪代码\",\"68\":\"8#_2-3-一些问题\",\"69\":\"8#_3-truncated-policy-iteration-algorithm\",\"70\":\"8#_3-1-value-iteration-与-policy-iteration-算法比较\",\"71\":\"8#_3-2-truncated-policy-iteration-algorithm\",\"72\":\"8#truncated-policy-iteration-algorithm-是否是收敛的\",\"73\":\"8@0\",\"74\":\"8@1\",\"75\":\"9\",\"76\":\"9#_1-mc-basic\",\"77\":\"9#_1-1-算法思路\",\"78\":\"9#_1-2-如何估计\",\"79\":\"9#_1-3-具体算法\",\"80\":\"9#_2-mc-exploring-starts\",\"81\":\"9#_2-1-episode-的高效利用\",\"82\":\"9#_2-2-高效地更新-policy\",\"83\":\"9#_2-3-mc-exploring-starts\",\"84\":\"9#_2-4-exploring-statrts的解释\",\"85\":\"9#_3-mc-eplison-greedy\",\"86\":\"9#_3-1-soft-policy\",\"87\":\"9#_3-2-greedy-policy\",\"88\":\"9#_3-3-greedy-policy-引入-mc-based-算法中\",\"89\":\"9#_3-3-算法流程\",\"90\":\"9@0\",\"91\":\"9@1\",\"92\":\"10\",\"93\":\"10#_1-引言\",\"94\":\"10#_1-1-求均值的方法\",\"95\":\"10#_2-robbins-monto-rm-algorithm\",\"96\":\"10#_2-1-问题引入\",\"97\":\"10#_2-2-算法介绍\",\"98\":\"10#_2-3-收敛性分析\",\"99\":\"10#_2-4-应用于-mean-estimation-中\",\"100\":\"10#_3-stochastic-gradient-descent\",\"101\":\"10#_3-1-问题引入\",\"102\":\"10#_3-2-sgd-分析\",\"103\":\"10#mean-estimation-问题转化\",\"104\":\"10#sgd-正确性和收敛性分析\",\"105\":\"10#_3-3-sgd-另一种问题描述方法-deterministic-formulation\",\"106\":\"10#_3-4-bgd-mbgd-sgdw\",\"107\":\"10@0\",\"108\":\"10@1\",\"109\":\"11\",\"110\":\"11#_1-引入\",\"111\":\"11#_2-td-learning-of-state-value\",\"112\":\"11#_2-1-算法描述\",\"113\":\"11#_2-2-算法分析\",\"114\":\"11#_2-3-td-算法-与-mc-算法的比较\",\"115\":\"11#_3-td-learning-of-action-value\",\"116\":\"11#_3-1-sarsa\",\"117\":\"11#_3-2-n-step-sarsa\",\"118\":\"11#_3-3-expected-sarsa\",\"119\":\"11#_4-td-learning-of-optimal-action-value\",\"120\":\"11#_4-1-q-learning\",\"121\":\"11#_4-2-off-policy-on-policy\",\"122\":\"11#on-policy\",\"123\":\"11#off-policy\",\"124\":\"11#_4-3-q-learning-伪代码\",\"125\":\"11#off-poicy-版本\",\"126\":\"11#on-policy-版本\",\"127\":\"11#_5-td-算法的统一形式和总结\",\"128\":\"11@0\",\"129\":\"11@1\",\"130\":\"12\",\"131\":\"12#_1-引入\",\"132\":\"12#_2-alogorithm-of-state-value-estimation\",\"133\":\"12#_2-1-obejctive-function\",\"134\":\"12#uniform-distributon\",\"135\":\"12#stationary-distribution\",\"136\":\"12#_2-2-optimization-algorithms-优化算法\",\"137\":\"12#monte-carlo-learning-with-function-approximation\",\"138\":\"12#td-learning-with-function-approximation\",\"139\":\"12#_3-sarsa-with-function-approximation\",\"140\":\"12#_4-q-learning-with-function-approximation\",\"141\":\"12#_5-deep-q-learning-dqn\",\"142\":\"12#优化方法\",\"143\":\"12#经验回放-replay-buffer\",\"144\":\"12#伪代码\",\"145\":\"12@0\",\"146\":\"12@1\",\"147\":\"13\",\"148\":\"13#_1-基本思路\",\"149\":\"13#_2-目标函数定义\",\"150\":\"13#_2-1-average-state-value\",\"151\":\"13#另一种表达\",\"152\":\"13#d-s-的选择\",\"153\":\"13#_2-2-average-return-value\",\"154\":\"13#另一种表达-1\",\"155\":\"13#_3-目标函数梯度求解\",\"156\":\"13#_4-reinforce-梯度上升算法\",\"157\":\"13#reinforce-算法\",\"158\":\"13@0\",\"159\":\"13@1\",\"160\":\"14\",\"161\":\"14#类与对象\",\"162\":\"14#方法的创建与使用\",\"163\":\"14#方法的进阶使用\",\"164\":\"14#this-的使用\",\"165\":\"14#方法的重载\",\"166\":\"14#构造方法\",\"167\":\"14@0\",\"168\":\"14@1\",\"169\":\"15\",\"170\":\"15#静态变量和静态方法\",\"171\":\"15#静态变量初始化\",\"172\":\"15#包的访问与控制\",\"173\":\"15#包的声明和导入\",\"174\":\"15#访问权限控制\",\"175\":\"15@0\",\"176\":\"15@1\",\"177\":\"16\",\"178\":\"16#封装-继承和多态\",\"179\":\"16#封装\",\"180\":\"16#继承\",\"181\":\"16#object-类\",\"182\":\"16#方法重写-override\",\"183\":\"16#控制符-final\",\"184\":\"16#抽象类-abstract\",\"185\":\"16#接口-interface\",\"186\":\"16#object类中的-克隆方法\",\"187\":\"16#枚举类-enum\",\"188\":\"16@0\",\"189\":\"16@1\",\"190\":\"17\",\"191\":\"17#面向对象高级篇1\",\"192\":\"17#基本类型包装类\",\"193\":\"17#所有包装类如下\",\"194\":\"17#包装类的方法\",\"195\":\"17#特殊包装类\",\"196\":\"17@0\",\"197\":\"17@1\",\"198\":\"18\",\"199\":\"18#面向对象高级篇-2\",\"200\":\"18#数组\",\"201\":\"18#定义\",\"202\":\"18#方法\",\"203\":\"18#访问元素\",\"204\":\"18#特性\",\"205\":\"18#final性质\",\"206\":\"18#多维数组\",\"207\":\"18#可变长参数\",\"208\":\"18#main函数的-string-args\",\"209\":\"18#字符串\",\"210\":\"18#string-类\",\"211\":\"18#stringbuilder-类\",\"212\":\"18#正则表达式\",\"213\":\"18@0\",\"214\":\"18@1\",\"215\":\"19\",\"216\":\"19#面向对象高级篇-3\",\"217\":\"19#内部类\",\"218\":\"19#成员内部类-属于-对象\",\"219\":\"19#静态内部类-属于-类\",\"220\":\"19#局部内部类\",\"221\":\"19#静态内部类编译特性\",\"222\":\"19#匿名内部类\",\"223\":\"19#匿名内部类特性\",\"224\":\"19#lambda表达式\",\"225\":\"19#方法引用\",\"226\":\"19@0\",\"227\":\"19@1\",\"228\":\"20\",\"229\":\"20#面向对象高级篇-4\",\"230\":\"20#异常机制\",\"231\":\"20#异常类型\",\"232\":\"20#自定义异常\",\"233\":\"20#抛出异常-throw\",\"234\":\"20#异常的处理-try-catch-finally\",\"235\":\"20#断言表达式-assert\",\"236\":\"20@0\",\"237\":\"20@1\",\"238\":\"21\",\"239\":\"21#面向对象高级篇-6\",\"240\":\"21#常用工具类\",\"241\":\"21#数学工具类-math\",\"242\":\"21#数组工具类-arrays\",\"243\":\"21@0\",\"244\":\"21@1\",\"245\":\"22\",\"246\":\"23\",\"247\":\"24\",\"248\":\"25\",\"249\":\"26\",\"250\":\"27\",\"251\":\"28\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[10,6],\"4\":[1,45],\"5\":[1,29],\"6\":[1],\"7\":[1],\"8\":[1,44],\"9\":[1,105],\"10\":[4,82],\"11\":[1,34],\"12\":[1],\"13\":[1,157],\"14\":[1,67],\"15\":[null,null,1],\"16\":[null,null,6],\"17\":[2],\"18\":[1,1],\"19\":[2,118],\"20\":[6,54],\"21\":[null,null,1],\"22\":[null,null,1],\"23\":[4,19],\"24\":[7,2],\"25\":[6,8],\"26\":[3,28],\"27\":[3,8],\"28\":[3,3],\"29\":[5,10],\"30\":[6,3],\"31\":[4,4],\"32\":[2,1],\"33\":[6,3],\"34\":[null,null,1],\"35\":[null,null,1],\"36\":[2],\"37\":[1,5],\"38\":[3],\"39\":[1,16],\"40\":[4,27],\"41\":[7,36],\"42\":[3,35],\"43\":[8,10],\"44\":[7,23],\"45\":[4,47],\"46\":[8,34],\"47\":[6,34],\"48\":[3,72],\"49\":[2,29],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[2,16],\"53\":[3,36],\"54\":[6],\"55\":[3,28],\"56\":[2,8],\"57\":[5,21],\"58\":[4,75],\"59\":[null,null,1],\"60\":[null,null,1],\"61\":[4,6],\"62\":[4,18],\"63\":[2,53],\"64\":[3,1],\"65\":[4,3],\"66\":[3,70],\"67\":[2,1],\"68\":[3,44],\"69\":[5,6],\"70\":[7,71],\"71\":[6,23],\"72\":[5,1],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[6,51],\"76\":[3,16],\"77\":[2,61],\"78\":[3,33],\"79\":[3,49],\"80\":[4,10],\"81\":[4,63],\"82\":[3,52],\"83\":[5,1],\"84\":[4,33],\"85\":[4,9],\"86\":[4,25],\"87\":[4,39],\"88\":[7,12],\"89\":[2,1],\"90\":[null,null,1],\"91\":[null,null,1],\"92\":[2,33],\"93\":[2],\"94\":[2,32],\"95\":[5],\"96\":[3,17],\"97\":[2,31],\"98\":[3,44],\"99\":[6,41],\"100\":[4],\"101\":[3,57],\"102\":[4],\"103\":[3,8],\"104\":[2,67],\"105\":[6,11],\"106\":[5,1],\"107\":[null,null,1],\"108\":[null,null,1],\"109\":[4],\"110\":[2,50],\"111\":[6,10],\"112\":[3,36],\"113\":[2,37],\"114\":[7],\"115\":[6,23],\"116\":[3,37],\"117\":[5,3],\"118\":[3,2],\"119\":[7,21],\"120\":[4,24],\"121\":[6,7],\"122\":[2,9],\"123\":[2,17],\"124\":[5,17],\"125\":[3,10],\"126\":[3,1],\"127\":[3,2],\"128\":[null,null,1],\"129\":[null,null,1],\"130\":[6,11],\"131\":[2,12],\"132\":[6,9],\"133\":[4,15],\"134\":[2,22],\"135\":[2,52],\"136\":[4,40],\"137\":[6,19],\"138\":[5,15],\"139\":[5,10],\"140\":[6,13],\"141\":[6,21],\"142\":[1,110],\"143\":[4,3],\"144\":[1,13],\"145\":[null,null,1],\"146\":[null,null,1],\"147\":[5,10],\"148\":[2,38],\"149\":[2],\"150\":[5,22],\"151\":[1,5],\"152\":[3,21],\"153\":[4,20],\"154\":[1,27],\"155\":[2,60],\"156\":[3,40],\"157\":[2,1],\"158\":[null,null,1],\"159\":[null,null,1],\"160\":[2],\"161\":[1,85],\"162\":[1,56],\"163\":[1],\"164\":[2,23],\"165\":[1,20],\"166\":[1,75],\"167\":[null,null,1],\"168\":[null,null,1],\"169\":[2],\"170\":[1,52],\"171\":[1,27],\"172\":[1],\"173\":[1,90],\"174\":[1,60],\"175\":[null,null,1],\"176\":[null,null,1],\"177\":[2],\"178\":[2,16],\"179\":[1],\"180\":[1,4],\"181\":[2,79],\"182\":[1,74],\"183\":[1,14],\"184\":[1,73],\"185\":[1,141],\"186\":[2,73],\"187\":[1,72],\"188\":[null,null,1],\"189\":[null,null,1],\"190\":[2],\"191\":[1],\"192\":[1,9],\"193\":[1,97],\"194\":[1,25],\"195\":[1,69],\"196\":[null,null,1],\"197\":[null,null,1],\"198\":[5],\"199\":[2],\"200\":[1,5],\"201\":[1,47],\"202\":[1,40],\"203\":[1,29],\"204\":[1,32],\"205\":[1,22],\"206\":[1,24],\"207\":[1,43],\"208\":[1,25],\"209\":[1,15],\"210\":[2,65],\"211\":[2,60],\"212\":[1,148],\"213\":[null,null,1],\"214\":[null,null,1],\"215\":[2],\"216\":[2,6],\"217\":[1,3],\"218\":[4,93],\"219\":[4,34],\"220\":[1,35],\"221\":[1,42],\"222\":[1,84],\"223\":[1,35],\"224\":[1,53],\"225\":[1,67],\"226\":[null,null,1],\"227\":[null,null,1],\"228\":[2],\"229\":[2],\"230\":[1],\"231\":[1,50],\"232\":[1,23],\"233\":[1,57],\"234\":[1,104],\"235\":[1,26],\"236\":[null,null,1],\"237\":[null,null,1],\"238\":[2],\"239\":[2,5],\"240\":[1],\"241\":[1,59],\"242\":[1,45],\"243\":[null,null,1],\"244\":[null,null,1],\"245\":[1,3],\"246\":[1],\"247\":[1],\"248\":[1],\"249\":[1],\"250\":[1],\"251\":[1]},\"averageFieldLength\":[2.840035080503676,33.10220630383258,1],\"storedFields\":{\"0\":{\"h\":\"daily1\",\"t\":[\"a+b=c\"]},\"1\":{\"c\":[\"daily\"]},\"2\":{\"c\":[\"d1\"]},\"3\":{\"h\":\"Reinforcement Learning in Multiple-UAV Networks:Deployment and Movement Design\",\"t\":[\"2019 IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"4\":{\"h\":\"主要动机\",\"t\":[\"A novel framework is proposed for quality of experience driven deployment and dynamic movement of multiple unmanned aerial vehicles (UAVs).\",\"过去研究大多没有基于用户的移动(movement of users)来考虑无人机的机动性，更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署。\",\"考虑QoE, 而不是仅考虑吞吐量(throughput)，即需要考虑地面不同用户的具体需求。(QoE is invoked for demonstrating the users’ satisfaction, and it is supposed to be considered in UAV-assisted wireless networks)\",\"该文设计的是3D部署，过去研究主要考虑的是2D部署。\"]},\"5\":{\"h\":\"主要贡献\",\"t\":[\"提出了一个理想的由QoE驱动的多无人机协助通信框架。该框架将无人机部署在三维空间内，以 mean opinion score(MOS) 为指标。通过优化无人机的部署和动态移动来解决总用户MOS最大化问题。\",\"提出解决总用户MOS最大化问题的三步骤: \",\"通过GAK-mean算法获得初始单元划分。\",\"设计一种基于 q-learning 的部署方法，在初始时间假设用户处于静止下不断调整 UAVs 3D位置进行优化处理。\",\"设计一种基于 q-learning 的无人机3D动态运动设计算法。\",\"该文基于q-learning的方案来解决无人机的NP-hard 3D部署和移动问题，并与传统的基于遗传的学习算法进行对比。\",\"该文提出的算法具较快的收敛性，与K-means和IGK算法比具有较低的复杂度。\"]},\"6\":{\"h\":\"主要内容\"},\"7\":{\"h\":\"系统结构\"},\"8\":{\"h\":\"基本设置\",\"t\":[\"考虑无人机辅助无线网络的下行链路传输(down-link transmission)，即无人机作为空中基站。\",\"对于指定区域，会将其划分为N个簇，其中用户表示为K=K1​,…,KN​，其中KN​表示划分到集群N的用户，N∈1,2,…,N。\",\"每个用户只能属于一个集群，Kn​∩Kn′​=ϕ,n′=n,\",\"在任意时刻t，同一无人机通过FDMA同时为同一集群中的多个用户提供服务\",\"对于用户kn​∈Kn​，其坐标表示为wkn​​=[xkn​​(t),ykn​​(t)]T∈R2×1\",\"对于无人机n(飞行速度恒定)，其垂直高度表示为hn​(t)∈[hmin​,hmax​],0≤t≤Ts​，其水平坐标表示为qn​(t)=[xn​(t),yn​(t)]T∈R2×1,0≤t≤Ts​\",\"无人机n与用户kn​在时间t的距离表示为:\",\"dkn​​=hn2​(t)+[xn​(t)−xkn​​(t)]2+[yn​(t)−ykn​​(t)]2​\"]},\"9\":{\"h\":\"信号模型\",\"t\":[\"无人机往往有更高的LoS链接概率，该文中表示为:\",\"PLoS​(θkn​​)=b1​(π180​θkn​​−ζ)b2​PNLoS​=1−PLoS​\",\"其中θkn​​(t)=sin−1[dkn​(t)​hn​(t)​]，表示无人机与用户之间的仰角。b1​,b2​,ζ是由环境决定的常数。在实际应用中，为了在LoS信道概率和路径损耗之间取得平衡，需要合理选择无人机n的垂直高度hn​(t)。\",\"在时间t，从无人机n到用户kn​的信道功率增益(the channel power gain)为:\",\"gkn​​(t)=K0​−1dkn​​−α[t](PLos​μLoS​+PNLos​μNLoS​)−1\",\"其中K0​=(c4πfc​​)2，α是表示路径损耗指数(常数)，μLoS​,μNLoS​是表示LoS和NLoS链路的衰减因子，fc​是载波频率，c是光速。\",\"对于无人机n，其可用带宽为Bn​，将其平均分配给其∣Kn​∣个关联用户，其每个用户带宽表示为: Bkn​​=Bn​/Kn​. 该文中不同集群所利用的频谱是不同的，且无人机向关联用户的发射功率是恒定的。 同样，对于无人机的总发射功率也均匀地分配给每个用户，pkn​​=Pmax​/Kn​\",\"由于不同集群的频谱不同，可以减轻无人机对用户接收到的干扰。因此，在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为:\",\"Γkn​​(t)=σ2pkn​​gkn​​(t)​\",\"其中σ2=Bkn​​N0​, N0​为用户所在位置的加性高斯白噪声(AWGN)的功率谱密度。\",\"为了满足不同用户传输速率要求，对于用户kn​存在特定的信噪比目标γkn​​, 即Γ≥γkn​​.\",\"由此，存在Lemma1： 为了保证所有用户都能连接到网络，我们对无人机的发射功率有一个约束，可以表示为\",\"Pmax​≥γσ2K0​dkn​​α(t)μNLoS​\",\"根据香农定理: 信道容量C=B∗log(1+NS​)，且传输率永远都不可能超过信道容量C。 因此对于用户kn​的在时刻t的传输速率rkn​​(t)，表示为rkn​​(t)=Bkn​​log2​[1+σ2pkn​​gkn​​(t)​].\",\"Proposition1: 无人机n的高度需满足:\",\"dkn​​(t)sin[180π​(ζ+eM(t))]≤hn​(t)≤(γK0​σ2μLoS​Pmax​​)\",\"其中\",\"M(t)=b2​ln(b1​(μLoS​−μNLoS​)S(t)​−μLoS​−μNLoS​μNLoS​​​S(t)=γK0​σ2dkn​​α(t)Pm​ax​\",\"Proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件。 可知，其高度的下界是距离dkn​​(t)的函数；高度的上界是最大发射功率Pmax​的函数。 因此，随着无人机与用户之间距离和发射功率的变化，需要调整相应无人机的高度，以向用户提供可靠的服务。\"]},\"10\":{\"h\":\"Quality-of-Experience Model\",\"t\":[\"由于不同用户对于传输速率的需求是不同的，所以在无人机辅助通信网络中我们需要考虑QoE模型。\",\"在该文中，采用MOS作为用户QoS衡量的标准，具体如下:\",\"MOSkn​​(t)=ζ1​MOSkn​​delay(t)+ζ2​MOSkn​​rate(t)\",\"其中，ζ1​,ζ2​是系数，且ζ1​+ζ2​=1。\",\"根据MOS数值，共划分5个等级: excellent(4.5) very good(2~3.5) fair(1~2) poor(1)。\",\"在该文中考虑的是网页浏览应用传输情况，因此MOSkn​​delay(t)可以忽略，因此，此时的MOS模型定义如下:\",\"MOSkn​​(t)=−C1​ln[d(rkn​​(t))]+C2​\",\"d(rkn​​(t))是与传输速率有关的延迟时间，MOSkn​​(t)为t时刻的MOS评分，取值范围从1−4.5。C1​和C2​是通过分析web浏览应用程序的实验结果确定的常数，分别设为1.120和4.6746。\",\"d(rkn​​(t))=3RTT+rkn​​(t)FS​+L(rkn​​MSS​)+RTT−rkn​​(t)2MSS(2L−1)​\",\"其中，RTT[s]表示round trip time(数据包从发送端-接收端-发送端的时间)，FS[bit]是网页大小，MSS[bit]是最大报文长度，L=min[L1​,L2​]表示 the number of slow start cycles with idle periods。\",\"L1​=log2​(MSSrkn​​RTT​+1)−1,L2​=log2​(2MSSFS​+1)−1.\",\"用户rkn​​在一段时间Ts​内的MOS总和为:\",\"MOSrkn​​​=t=0∑Ts​​MOSkn​​(t)\"]},\"11\":{\"h\":\"优化问题建立\",\"t\":[\"假设功率Q=qn​(t),0≤t≤Ts​, 高度H=hn​(t),0≤t≤Ts​\",\"本文目的是优化无人机在每个时隙的位置，从而最大化所有用户的总MOS值。具体表述如下:\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​∑t=0Ts​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"该优化问题是一个non-convex问题，因为目标函数对于无人机的3D坐标是非凸的。\",\"总用户的MOS取决于无人机的发射功率、数量和位置(水平位置和高度)。\"]},\"12\":{\"h\":\"解决方案\"},\"13\":{\"h\":\"无人机的3D部署\",\"t\":[\"考虑以下场景，将上述优化问题简化:\",\"无人机n以可变高度悬停在用户上方，用户是保持静态的。 每架无人机的带宽和发射功率都均匀分配给每个用户。 因此我们将优化问题简化为区域分割问题。\",\"描述如下: 但即使仅考虑用户聚类，该问题依然是NP-hard问题\",\"C,Q,Hmax​MOStotal​=∑n=1N​∑kn​=1Kn​​MOSkn​​(t)s.t.Kn​∩Kn′​=ϕ,n′=n,∀n,hmin​≤hn​(t)≤hmax​,∀t,∀n,Γkn​(t)​≥γkn​​,∀t,∀kn​,∑kn​=1Kn​​pkn​​(t)≤Pmax​,∀t,∀kn​,pkn​(t)​≥0,∀kn​,∀t,​\",\"无人机-用户关联策略(用户区域划分算法)\",\"采用基于遗传算法的GAK-means算法 由于特定用户的MOS与该用户与无人机之间的距离有关，因此GAK-means可以视为获得无人机部署的低复杂度方案。\",\"根据N个用户，根据遗传算法找到CN​个最优个体作为簇的中心。\",\"将无人机部署在每个中心内，再将用户划分给距离最近的无人机\",\"重复步骤，再找到新的簇的各中心，再根据欧几里得距离重新划分，直到各个簇的成员没有太大变化，划分完毕。\",\"无人机3D部署算法\",\"根据所给定的用户划分情况，目标是获得无人机的最佳3D位置，来最大化MOS总和。 由于GAK-means的优化目标是最小化无人机与对应集群用户的欧氏距离，MOS主要是有关传输速率rkn​​的函数，因此MOS不仅与欧氏距离有关，还与LoS的概率有关。\",\"采用Q-learning算法\",\"智能体(agent): UAVn,n∈N={1,2,…,N}\",\"状态(state): 对于每个智能体，其状态为其3D坐标，定义为ξ=(xUAV​,yUAV​,hUAV​)\",\"状态空间(state space S): 这里采用离散化空间坐标，即xUAV​:{0,1,…,Xd​},yUAV​:0,1,…,Yd​,hUAV​:{hmin​,…,hmax​}，所以状态其实共有(XD​+1)×(Yd​+1)×(hmax​−hmin​+1)个\",\"动作空间(action space): 每次无人机会根据当前状态st​∈S，按照所给定策略J来执行一个动作at​∈A从而获得奖励rt​以及下一个状态st+1​ 该论文中在精度和模型复杂型上作出平衡，共考虑7个方向。 (1,0,0)：右转 (−1,0,0)：左转 (0,1,0)：前进 (0,−1,0)：后退 (0,0,1)：上行 (0,0,−1)：下行 (0,0,0)：静止\",\"状态转换模型: 当执行动作at​时，从状态st​到st+1​，并获得奖励rt​的这一过程可以用条件转移概率p(st+1​,rt​∣st​,at​)来表示。 Q-learning的优化目标是最大化长期收益\",\"Gt​=E[n=0∑∞​βnrt+n​]\",\"奖励(reward): 如果agent在当前时刻t所执行的动作能够提高总MOS，则无人机将获得正奖励。否则，agent将获得负奖励。\",\"xt​=⎩⎨⎧​1,−0.1,−1,​ifMOSnew​>MOSold​ifMOSnew​=MOSold​ifMOSnew​<MOSold​​\",\"具体代码：（策略为贪心策略）\",\"算法1\",\"个人理解：\",\"通过K-means来划分各个无人机所管理的用户簇。无人机的位置初始化也是随机部署的\",\"但每个无人机所管理的用户不同，其目标也应该不一样，不能用同一个Q-table管理，这里是每个无人机都有一张自己的Q-table，来进行迭代？ 还是同一张Q-table，只不过根据区域划分，不同的无人机agent的Q(s,a)的s是有范围的？(个人感觉是这个)\",\"最终输出的结果，应该是无人机最终停的位置即是部署的最佳位置(因为q-learning是优化长期目标)，发现在该位置静止是最优的，表示是最佳部署位置。\",\"最终输出结果，是根据Q-table来找出对应q(s,a)当a为静止时，最大的q(s,a)值，对应s就是UAV的部署位置\"]},\"14\":{\"h\":\"无人机的动态移动设计\",\"t\":[\"考虑用户在每个时隙移动的情况，由于用户在每个时隙都处于漫游状态，因此随着用户位置的变化，每个集群中无人机的最优位置也会发生变化，无人机需要进行移动。\",\"在本文中不考虑用户移动到其他集群的情况 因为在不考虑用户自由穿梭集群的情况，对于动作空间而言，仅需要考虑无人机的7个移动方向即可；但若考虑集群情况，动作空间包含两个部分：选择移动方向和选择关联用户。设无人机总数为N，∣Kn​∣为第n个簇的用户总数，则用户的关联动作数为2N∑n=1N​∣Kn​∣，∑n=1N​∣Kn​∣是总用户数，每个用户都需要判断是否与每个无人机关联，因此是2N 则总动作空间的大小为7+2N∑n=1N​∣Kn​∣会导致动作空间过大，Q-table过大。\",\"1.用户漫游模型 在设计无人机的移动之前，需考虑用户的移动性，这里有多种mobility modles可选择，如a deterministic approach, a hybrid approach, and a random walk model. 在本文中，采用的是the random walk model(Markovian mobility model) 每个用户的移动方向均匀分布在左、右、前、后四个方向。 用户的速度设为[0,cmax​]，其中cmax​表示用户的最大速度。\",\"2.基于q-learning的移动算法 与基于q-learning的部署算法不同的是，在此情况下，状态除了要考虑无人机的3D位置外，还需要考虑所有用户的2D位置。即ξ={xUAV​,yUAV​,hUAV​,xuser​,yuser​}(xuser​,yuser​)由用户的初始位置和运动模型决定，(xUAV​,yUAV​,hUAV​)由无人机的位置和它们在最后时隙采取的动作决定.\",\"训练阶段: \",\"测试阶段:\\n\"]},\"15\":{\"c\":[\"academic\"]},\"16\":{\"c\":[\"UAV\",\"IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY\"]},\"17\":{\"h\":\"RL1 - 基本概念\"},\"18\":{\"h\":\"强化学习框架图\",\"t\":[\"主要框架\"]},\"19\":{\"h\":\"1. 基本概念\",\"t\":[\"State(状态)：The status of the agent with respect to the environment.\",\"State Space(状态空间): 所有状态的集合。S={si​}i=1n​。\",\"Action(动作): 对于每一个状态，都有可选择的动作。\",\"Action space of a state: 对应状态中所有可选择的动作集合。A(si​)={ai​}i=1n​\",\"State transition(状态转换): s1​→a1​s2​。定义了agent与环境的交互行为。\",\"State transition probability: p(s2​∣s1​,a1​)，即状态s1​采用动作a1​转到状态s2​的概率。\",\"Policy π: 指导agent在当前状态下选择哪个动作。\",\"Reward(奖励): 在执行一个动作后获得的一个常数(依赖于当前状态和所采取的动作)。同样可以用条件概率的形式进行描述，如p(r=1∣s1​,a1​)，即在状态s1​下采用动作a1​获得的奖励r=1的概率。\",\"Trajectory：a state-action-reward chain.(可以有限，也可以是无限长的trajectory) s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​. 个人理解，trajectory是在策略给定下，agent可能走出的全部轨迹，并非只是一个单一的轨迹。\",\"Return of a trajectory：将对应的轨迹所获得的所有reward的总和，可以粗步衡量一个策略的好坏。\",\"Discounted return(of a trajectory)：为了应对具有无限步的trajectory的return=∞的情况。 s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​…. 此时该trajectory的return=0+0+0+1+1+⋯=∞。 引入discount rate, γ∈[0,1). 此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​ 显然，如果γ接近0，即此时的discounted return越短视，注重近期的reward；γ接近1，更远视，更注重长远的reward。\",\"Episode(trial)：When interacting with the environment following a policy, the agent may stop at some terminal states. The resulting trajectory is called an episode(or a trial)/ 即表示具有终止状态terminal states的trajectory，通常是具有有限步长的trajectory. 同理，这样的任务称为episodic tasks。\",\"continuing tasks：即不具备terminal states的任务，会与环境一直交互下去。 可以通过设置将episodic tasks转换成continuing tasks，如可以在target states中限制action space，控制其一直待在target states中。 Deterministic — Stochastic\"]},\"20\":{\"h\":\"2.Markov decision process(MDP)\",\"t\":[\"关键元素：\",\"Sets： \",\"State：the set of states S\",\"Action：the set of actions A(s) is associate for state s∈S\",\"Reward：the set of rewards R(s,a).\",\"Probability distribution： \",\"State transition probability p(s′∣s,a): 表示在状态s下采取动作a，转换到状态s′的概率。\",\"Reward probability p(r∣s,a): 表示在状态s下采取动作a，获得reward r 的概率。\",\"Policy：at state s, the probability to choose action a is π(a∣s). 表示在各状态执行各动作的概率。\",\"Markov property：即无记忆的特性。 p(st+1​∣at+1​,st​,…,a1​,s0​)=p(st+1​∣at+1​,st​)r(st+1​∣at+1​,st​,…,a1​,s0​)=p(rt+1​∣at+1​,st​)\",\"Markov process：在policy是确定的情况下，MDP就变为MP。\"]},\"21\":{\"c\":[\"academic\"]},\"22\":{\"c\":[\"强化学习\"]},\"23\":{\"h\":\"RL10 - Actor-Critic 方法\",\"t\":[\"actor: 对应 policy update\",\"critic: 对应 policy evaluation 或者 value evaluation\",\"20240830184236\",\"显然，是在基于 策略梯度上升 算法的基础上，将对于 Q 值的估计通过一个网络来进行描述，这个便成为 critic, 而对应的策略梯度上升算法就是对应 actor。\",\"20240830184312\"]},\"24\":{\"h\":\"1. The simplest actor-critic (QAC)\",\"t\":[\"20240830184330\",\"20240830184424\"]},\"25\":{\"h\":\"2. Advantage actor-critic (A2C)\",\"t\":[\"核心思想：在 QAC 的基础上来引入偏置量(baseline)，从而减小方差，提升采样的效率。\"]},\"26\":{\"h\":\"2.1 baseline\",\"t\":[\"在策略梯度算法中引入一个 baseline, 不会影响所求的梯度。 即:\",\"▽θ​J(θ)​=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)]=ES∼η,A∼π​[▽θ​ln(A∣S,θ)qπ​(S,A)−b(S)]​\",\"证明: 要证明加入baseline成立，只需要保证:\",\"ES∼η,A∼π​[▽θ​ln(A∣S,θ)b(S)]=0\",\"20240830185127\",\"作用:\",\"因此，我们需要找到一个 baseline 来保证这个梯度的方差最小即可。\"]},\"27\":{\"h\":\"2.2 最好的 baseline\",\"t\":[\"20240830185324\",\"在实际情况中，我们通常将 baseline 设置为 vπ​(s)\"]},\"28\":{\"h\":\"2.3 对应算法\",\"t\":[\"20240830185537\",\"20240830185556\",\"20240830185629\"]},\"29\":{\"h\":\"3. off-policy actor-critic\",\"t\":[\"通过 重要性采样 的方法，将处于 另一分布下 的策略所采集的数据来 运用到 策略更新 中。\"]},\"30\":{\"h\":\"3.1 重要性采样 (Importance sampling)\",\"t\":[\"20240830200056\",\"20240830200118\",\"20240830200138\"]},\"31\":{\"h\":\"3.2 off-policy\",\"t\":[\"20240830200248\",\"20240830200305\",\"20240830200320\",\"20240830200343\"]},\"32\":{\"h\":\"3.3 伪代码\",\"t\":[\"20240830200406\"]},\"33\":{\"h\":\"4. Deterministic actor-critic (DPG)\",\"t\":[\"1234\",\"20240830200608\",\"20240830200624\"]},\"34\":{\"c\":[\"academic\"]},\"35\":{\"c\":[\"强化学习\"]},\"36\":{\"h\":\"RL2 - 贝尔曼公式\"},\"37\":{\"h\":\"核心内容\",\"t\":[\"state value\",\"the Bellman equation\"]},\"38\":{\"h\":\"1.State value\"},\"39\":{\"h\":\"1.1\",\"t\":[\"引入随机变量后对应的discounted return的描述。 即一个trajectory下的discounted return。 由此可以推导出一个多步的trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的discounted return为：Gt​=Rt+1​+γRt+2​+γ2Rt+3​+…\",\"γ 为discounted rate\",\"Gt​也是一个随机变量\"]},\"40\":{\"h\":\"1.2 State value\",\"t\":[\"State value 是 Gt​ 的期望, 也称为 state value function 表示为 The expection(expected value or mean) of Gt​:\",\"vπ​(s)=E[Gt​∣St​=s]\",\"是一个有关状态s的函数.\",\"vπ​(s) 是基于一个给定策略 π , 对于不同的策略，所得到的 state value 是不同的.\",\"state value 可以用来衡量一个状态的价值.\"]},\"41\":{\"h\":\"1.3 State value 与 return 的区别\",\"t\":[\"Return 是针对一条trajectory所求的，而 State value 则是对多个 trajectory 求 return 再求平均值。 The state value is the mean of all possible returns that can be obtained starting from a state. 只有当所有东西都是确定性的(π(a∣s),p(r∣s,a),p(s′∣s,a))，state value 与 return 是一致的.\"]},\"42\":{\"h\":\"2. Bellman equation\",\"t\":[\"用来描述所有状态的state value的关系. 根据一个 random trajectory:\",\"St​→At​Rt+1​,St+1​→At+1​Rt+2​,St+2​→At+2​Rt+3​,St+2​→At+3​…\",\"对应的 discounted return Gt​ 为:\",\"Gt​​=Rt+1​+γRt+2​+γ2Rt+3​+…=Rt+1​+γ(Rt+2​+γRt+3​+…)=Rt+1​+γGt+1​​\",\"因此，对应的 state value 为:\",\"vπ​(s)​=E[Gt​∣St​=s]=E[Rt+1​+γGt+1​∣St​=s]=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s]​\",\"需要推导E[Rt+1​∣St​=s]和E[Gt+1​∣St​=s]的计算即可。\"]},\"43\":{\"h\":\"2.1 The mean of immediate rewards:\",\"t\":[\"E[Rt+1​∣St​=s]​=a∑​π(a∣s)E[Rt+1​∣St​=s,At​=a]=a∑​π(a∣s)r∑​p(r∣s,a)r​\"]},\"44\":{\"h\":\"2.2 The mean of future rewards:\",\"t\":[\"E[Gt+1​∣St​=s]​=s′∑​E[Gt+1​∣St​=s,St+1​=s′]=s′∑​E[Gt+1​∣St+1​=s′](无记忆性)=s′∑​vπ​(s′)p(s′∣s)=s′∑​vπ​(s′)a∑​p(s′∣s,a)π(a∣s)​\",\"个人推导：\",\"E[Gt+1​∣St​=s]​=a∑​π(a∣s)E[Gt+1​∣St​=s,At​=a]=a∑​π(a∣s)s′∑​E[Gt+1​∣St​=s,At​=a,St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)E[Gt+1​∣St+1​=s′]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​\"]},\"45\":{\"h\":\"2.3 Bellman equation\",\"t\":[\"vπ​(s)​=E[Rt+1​∣St​=s]+γE[Gt+1​∣St​=s],=mean of immediate rewards a∑​π(a∣s)r∑​p(r∣s,a)r​​+mean of future rewards γa∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s′)​​,=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)],∀s∈S.​\",\"该式子针对状态空间中的所有状态均成立.\",\"通过 Bootstrapping , 可以求解 state value.\",\"π(a∣s) 表示一个给定的策略. 求解Bellman equation 称为策略评估(Policy evaluation).\",\"p(r∣s,a),p(s′∣s,a) 是由环境决定的(dynamic model|environment model). 后续可能是未知的(model-free)，需要通过采样解决.\"]},\"46\":{\"h\":\"2.4 Bellman equation (Matrix-vector form)\",\"t\":[\" 此时,对于所有状态s，对应的 Bellman equation 为\",\"vπ​(s)=rπ​(s)+γs′∑​pπ​(s′∣s)vπ​(s′)​\",\"将所有状态的 Bellman equation 整合，重新修改为 matrix-vector form.\",\"vπ​=rπ​+γPπ​vπ​​\",\"其中,\",\"vπ​=[vπ​(s1​),…,vπ​(sn​)]T∈Rn\",\"rπ​=[rπ​(s1​),…,rπ​(sn​)]T∈Rn\",\"Pπ​∈Rn×n, where [Pπ​]ij​=pπ​(sj​∣si​), 表示状态转移矩阵.\"]},\"47\":{\"h\":\"3. Why to slove state value\",\"t\":[\"为了进行 Policy evaluation, 即对于给定策略，求出其对应状态的 state value 的过程。\",\"通过 Bellman euqation 进行求解。\",\"The closed-form solution(不常用):\",\"vπ​=(I−γpπ​)−1rπ​​\",\"An iterative solution(一种迭代策略):\",\"vk+1​=rπ​+γPπ​vk​​\",\"可以最开始均初始化为 0 , 然后进行不断迭代，可以得到一个序列v0​,v1​,v2​,…. 最终可以证明：vk​→vπ​=(I−γpπ​)−1rπ​,k→∞\"]},\"48\":{\"h\":\"4. Action value\",\"t\":[\"State value: agent从一个状态出发可以得到的平均return. the average return the agent can get starting from a state\",\"Action value: agent从一个状态出发，采取一个指定的action可以得到的平均return。 the average return the agent can get starting from a state and taking an action.\",\"通过求解 action value 我们可以分析出在该状态下采取哪个 action 收益最大. Action value 定义:\",\"qπ​(s,a)=E[Gt​∣St​=s,At​=a]​\",\"同样地，qπ​(s,a)是依赖于策略π的，并且与状态 s 和动作 a 有关.\",\"vπ​(s)E[Gt​∣St​=s]​​=a∑​qπ​(s,a)E[Gt​∣St​=s,At​=a]​​π(a∣s)\",\"因此，vπ​(s)=∑a​qπ​(s,a)π(a∣s) 由于,\",\"vπ​(s)=a∑​π(a∣s)[r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)]​\",\"所以，qπ​(s,a)=∑r​p(r∣s,a)r+γ∑s′​p(s′∣s,a)vπ​(s′)\",\"实际意义是：在当前状态s下采取动作 a 所获得的均值，加上 γ 的转到下一个状态的 state value 加权均值。\",\"引入 action value 后，对于 state value 实际意义的解释：在当前状态s下，根据策略π, 所有可能动作的 action value 的加权均值。\",\"state value 和 action value 可以互相转化。\"]},\"49\":{\"h\":\"5. 总结\",\"t\":[\"State value: vπ​(s)=E[Gt​∣St​=s]\",\"Action value: qπ​(s,a)=E[Gt​∣St​=s,At​=a]\",\"State value 是 action value 的根据策略π加权平均，即vπ​(s)=∑a​π(a∣s)q(s,a)\",\"The Bellman equation (elementwise form and matrix-vector form)\",\"求解 the Bellman equation (2种方法)\"]},\"50\":{\"c\":[\"academic\"]},\"51\":{\"c\":[\"强化学习\"]},\"52\":{\"h\":\"RL3 - 贝尔曼最优公式\",\"t\":[\"Core concepts: optimal state value and optimal policy\",\"A fundamental tool: the Bellman optimality equation (BOE)\"]},\"53\":{\"h\":\"1. Optimal policy\",\"t\":[\"最优策略的定义: A policy π∗ is optimal if π∗(s)≥vπ​(s) for all s and for any other policy π. 需要确定几件事:\",\"最优策略是否存在 存在，根据 the contraction mapping Theorem.\",\"最优策略是否唯一 唯一，根据 the contraction mapping Theorem.\",\"最优策略是 stochastic 还是 deterministic deterministic 且 greedy\",\"如何得到最优策略 选取状态中最大的 action value 作为下一步的 action\"]},\"54\":{\"h\":\"2. Bellman optimality equation (BOE)\"},\"55\":{\"h\":\"2.1 基本形式\",\"t\":[\"对于贝尔曼最优公式而言，其策略π表示的是最优策略，除了需要求解 state value 外，还需要求解最优策略π.elementwise form:\",\"vπ​(s)​=πmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)vπ​(s′)),∀s∈S=πmax​a∑​π(a∣s)q(a,s),∀s∈S​\",\"matrix-vector foem:\",\"v=πmax​(rπ​+γPπ​v)​\"]},\"56\":{\"h\":\"2.2 如何求解\",\"t\":[\"对于贝尔曼最优公式而言，区别于贝尔曼公式，只是求解各状态的 state value, 我们还需要理解其所描述的最优策略π∗ 具体分两步:\"]},\"57\":{\"h\":\"2.2.1 如何处理等式右边的 (最优策略)\",\"t\":[\"vπ​(s)=maxπ​∑a​π(a∣s)q(s,a), 为了让右边取到最大值的情况，我们只需要在当前状态下，保证选取最大的 action value 即可，对应策略表示为:\",\"π(a∣s)={10​a=a∗a=a∗​\",\"其中a∗表示在该状态下计算出来的最大 action value 对应的动作，即a∗=argmaxa​q(s∣a)\"]},\"58\":{\"h\":\"2. 求解 state value\",\"t\":[\"将 BOE 转换为 v=f(v) 的形式，其中f(v):=maxπ​(rπ​+γPπ​v)f(v)对应一个向量, [f(v)]s​=maxπ​∑a​π(a∣s)q(s∣a),∀s∈S\",\"求解方法：\",\"Fix point: f(x)=x\",\"Contraction mapping(contractive function): ∣∣f(x1​)−f(x2​)∣∣≤γ∣∣x1​−x2​∣∣\",\"由此可以根据Contraction Mapping Theorem: For any equation that has the form of x=f(x), if f is a contraction mapping, then\",\"Existence: 存在不动点x∗，满足f(x∗)=x∗\",\"Uniqueness: 不动点x∗是唯一的\",\"Algorithm: Consider a sequence xk​ where xk+1​=f(xk​), then xk​→x∗ as k→∞. Moreover, the convergence rate is exponentially fast.\",\"因此，可以通过Contraction Mapping Theorem来求解贝尔曼最优公式，因为其满足该理论，即f(v)是一个contraction mapping。\"]},\"59\":{\"c\":[\"academic\"]},\"60\":{\"c\":[\"强化学习\"]},\"61\":{\"h\":\"RL4 - 值迭代和策略迭代(动态规划)\",\"t\":[\"贝尔曼最优公式:\",\"v=f(v)=πmax​(rπ​+γPπ​v)\"]},\"62\":{\"h\":\"1. Value iteration algorithm\",\"t\":[\"根据 chapter 3 中涉及的 contraction mapping theorem, 我们可以通过对应的迭代算法来求解贝尔曼最优公式\",\"vk+1​=f(vk​)=πmax​(rπ​+γPπ​vk​),k=1,2,3…\",\"这种迭代算法称为 value iteration.\"]},\"63\":{\"h\":\"1.1 具体步骤\",\"t\":[\"共分为 2 步：\",\"Policy update 这步是更新策略π，即求解右边的式子，πk+1​=argmaxπ​(rπ​+γPπ​vk​), 其中vk​是给定的。 其对应的 elementwise form:\",\"πk+1​(s)=πargmax​a∑​π(a∣s)(r∑​p(r∣s,a)r+γs′∑​p(s′∣s,a)v(s′)),s∈S 由于 p(s′∣s,a),p(r∣s,a),v(s′) 是已知的，显然，这里的最优策略πk+1​是一个 greedy policy，我们只需要挑选在当前迭代下最大的 action value 就好了, 即:\",\"πk+1​(a∣s)={10​a=ak∗​(s)a=ak∗​(s)​ 其中ak∗​(s)=argmaxa​qk​(a,s).\",\"value update 根据 Policy update 的策略πk+1​, 求解下一步的vk+1​, 即\",\"vk+1​=rπk+1​​+γPπk+1​​vk​这里的vk​并不是 state value 由于πk+1​是 greedy 的，对应的vk+1​(s)=maxa​qk​(a,s)\"]},\"64\":{\"h\":\"1.2 伪代码\",\"t\":[\"20240810190018\"]},\"65\":{\"h\":\"2. Policy iteration algorithm\",\"t\":[\"算法迭代示意图:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\"]},\"66\":{\"h\":\"2.1 算法描述\",\"t\":[\"首先随机设计一个初始的策略π0​\",\"Step 1: policy evaluation (PE) 策略评估 该步骤是用来计算当前策略 πk​ 的 state value. 可以通过 Bellman equation 进行求解，即:\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"根据对应的 Elementwise form:\",\"vπk​(j+1)​(s)=a∑​πk​(a∣s)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​(j)​(s′)),s∈S\",\"由此进行迭代，直到设置的收敛条件为止，即j→∞ 或者 ∣∣vπk+1​(j+1)​(s)−vπk​(j)​(s)∣∣≤δ.\",\"Step 2: policy improvement (PI) 策略提升 该步骤是根据 PE 所求出的 state value, 根据 action value，来提升当前策略 πk​\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"对应的 Elementwise form:\",\"πk+1​(s)=πargmax​a∑​πk​(a∣s)qπk​​(s,a)(r∑​p(r∣s,a)r+s′∑​p(s′∣s,a)vπk​​(s′))​​,s∈S\",\"这里，显然是可以通过一个 greedy 的策略来进行选择，即:\",\"πk+1​(a∣s)={10​a=ak∗​(s),a=ak∗​(s).​\",\"其中 aK∗​(s)=argmaxa​qπk​​(s,a).\"]},\"67\":{\"h\":\"2.2 伪代码\",\"t\":[\"20240811002219\"]},\"68\":{\"h\":\"2.3 一些问题\",\"t\":[\"在 PE 步骤中，如何通过 Bellman equation 得到 state value vπk​​. 根据 chapter 2 中求解 Bellman equation 的方法 一种是可以直接通过矩阵求逆进行求解，即 vπk​​=(I−γPπk​​)−1rπk​​，实际不常用. 一种是通过迭代算法来求解\",\"vπk​(j+1)​=rπk​​+γPπk​​vπk​(j)​\",\"在 PI 步骤中，如何确保策略 πk+1​ 是优于 πk​的.\",\"为什么这个迭代算法最终可以找到最优策略 每次迭代都会使得策略进行提升，那么\",\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",\"我们需要保证策略是不断提升，且最终会收敛到最优策略v∗\",\"policy iteration algorithm 与 value iteration algorithm 之间存在什么关系.\"]},\"69\":{\"h\":\"3. Truncated policy iteration algorithm\",\"t\":[\"该算法是 value iteration 以及 policy iteration 一般化的推广\"]},\"70\":{\"h\":\"3.1 value iteration 与 policy iteration 算法比较\",\"t\":[\"Policy iteration: 需要初始化策略π0​, 之后进行迭代\",\"Policy evaluation (PE): 通过 Bellman equation 求解当前策略的 state value.\",\"vπk​​=rπk​​+γPπk​​vπk​​\",\"内嵌迭代算法求解.\",\"Policy improvement (PI): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vπk​​)\",\"Value iteration: 需要初始化猜测的 state value v0​\",\"Policy update (PU): 考虑 greedy 策略求解, 选取当前状态下最大的 action value.\",\"πk+1​=πargmax​(rπ​+γPπ​vk​)\",\"Value update (VU): 进行迭代\",\"vk+1​=rπk+1​​+γPπk+1​​vk​\",\"两个算法迭代过程十分类似: Policy iteration:\",\"π0​PE​vπ0​​PI​π1​PE​vπ1​​PI​π2​PE​vπ2​​PI​…\",\"Value iteration:\",\"u0​PU​π1′​VU​u1​PU​π2′​VU​u2​PU​…\",\"Policy iteration algorithm\",\"Value iteration algorithm\",\"Comments\",\"1) Policy:\",\"π0​\",\"N/A\",\"2) Value:\",\"vπ0​​=rπ0​​+γPπ0​​vπ0​​\",\"v0​:=vπ0​​\",\"对于 policy iteration，vπ0​​是通过迭代算法来求的; 而 value iteration 我们这里强行初始化为vπ0​​，方便后续比较\",\"3) Policy:\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"π1​=argmaxπ​(rπ​+γPπ​vπ0​​)\",\"在策略更新上，这两个算法是一致的。\",\"4) Value:\",\"vπ1​​=rπ1​​+γPπ1​​vπ1​​\",\"v1​=rπ1​​+γPπ1​​v0​\",\"对于 Policy iteration 而言, 这里需要通过迭代算法来精确求出 vπ1​​; 对于 Value iteration，则只是进行一次带入求解。\",\"5) Policy:\",\"π2​=argmaxπ​(rπ​+γPπ​vπ1​​)\",\"π2′​=argmaxπ​(rπ​+γPπ​v1​)\",\"⋮\",\"⋮\",\"⋮\",\"⋮\"]},\"71\":{\"h\":\"3.2 Truncated policy iteration algorithm\",\"t\":[\"20240811010933\",\"显然，在求解 Bellman equation 中，Value iteration 只是进行了一步求解，而 Policy iteration 进行了无穷多步来进行了真实的求解 state value，显然在现实运行算法中是无法做到的。 因此 Truncated policy iteration algorithm 就是进行迭代 n 步来求解。\"]},\"72\":{\"h\":\"truncated policy iteration algorithm 是否是收敛的\",\"t\":[\"20240811011334\"]},\"73\":{\"c\":[\"academic\"]},\"74\":{\"c\":[\"强化学习\"]},\"75\":{\"h\":\"RL5 - 蒙特卡洛方法 (Monte Carlo) model-free\",\"t\":[\"如何在没有模型 (即p(r∣s,a),p(s′∣s,a)等均未知) 的情况下进行估计 通过 Monte Carlo estimation. 其核心思想是： 若有一系列(i.i.d)样本采样，得到一个样本序列x1​,x2​,…,xN​ 那么对于随机变量X的估计可以为：\",\"E[x]≈xˉ=N1​j=1∑N​xj​\",\"该方法成立的数学依据是 大数定理 (Law of Large Numbers)样本必须是独立同分布(iid, independent and identically distributed)\",\"为什么考虑 mean estimation. 因为无论是 state value 还是 action value 其原始定义都是从期望出发的。\",\"vπ​(s)=E[Gt​∣St​=s];qπ​(s,a)=E[Gt​∣St​=s,At​=a]\"]},\"76\":{\"h\":\"1. MC Basic\",\"t\":[\"最简单的示例算法，用于解释 MC 的原理，但现实场景中不太经常使用，效率过低。\",\"核心思想：如何将 Policy iteration algorithm 转换为 model-free 的情况。\"]},\"77\":{\"h\":\"1.1 算法思路\",\"t\":[\"Policy iteration 算法的核心是 先根据当前策略计算出各个状态的 state value， 再将 state value 转换为 action value，更新策略的步骤就是选择此时 action value 最大的 action.\",\"{Policyevaluation:vπk​​=rπk​​+γPπk​​vπk​​Policyimprovement:πk+1​=argmaxπ​(rπ​+γPπ​vπk​​)​\",\"显然其核心关键就是在 PE 中 通过迭代算法求解 Bellman equation 的 state value后：\",\"对于 model-based 的情况, 因为 p(r∣s,a),p(s′∣s,a) 已知，我们可以很轻松的求出各个情况下的q(s,a)，从而选择每个状态下最大的 action value 即可。\",\"qπk​​(s,a)=r∑​p(r∣s,a)+γs′∑​p(s′∣s,a)vπk​​(s)\",\"对于 model-free 的情况，此时 p(r∣s,a),p(s′∣s,a) 未知，我们不能通过之前的方法来求出q(s,a)，需要从 action value 的定义出发，即：\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]\",\"从此可以发现，我们可以通过前面所引入的 mean estimation 方法，来进行求解 q(s,a).\"]},\"78\":{\"h\":\"1.2 如何估计\",\"t\":[\"从指定的 (s,a) 出发，根据策略 πk​, 我们可以生成一个 episode.\",\"这个 episode 的 return 为 g(s,a).\",\"显然，g(s,a) 就是前面 Gt​ 的一个 sample.\",\"假设我们有了一系列 从状态 s 出发, 采取动作 a 的 episodes, 即 g(j)(s,a). 那么我们可以对 qπk​​(s,a) 进行估计，即\",\"qπk​​(s,a)=E[Gt​∣St​=s,At​=a]≈N1​i=1∑N​g(i)(s,a).\"]},\"79\":{\"h\":\"1.3 具体算法\",\"t\":[\"与 Policy iteration algorithm 步骤类似 首先初始化一个随机的策略π0​，然后进行迭代，对于 kth 迭代，有：\",\"Step 1: Policy evaluation. 求在策略πk​下所有的 action value, q(s,a). 具体求解方法，如 1.2 节所述，只不过我们此时需要遍历所有的 action-state pair. 为什么不去求 state value，因为最终策略更新的核心仍然是 action value, 即使先估计了 state value, 我们仍需要估计 action value.\",\"Step 2: Policy improvement. 这是来求解 πk+1​(s)=argmaxπ​∑a​π(a∣s)qπk​​(s,a),foralls∈S 这个仍然与之前一致，采用 greedy policy，即对于每个状态，我们选取其 action value 最大的 action.πk+1​(ak∗​∣s)=1，其中ak∗​=argmaxa​qπk​​(s,a)\",\"20240811233346\"]},\"80\":{\"h\":\"2. MC Exploring Starts\",\"t\":[\"MC Exploring Starts 是针对 MC Basic 的一些改进，即对于数据(experience)更加高效利用。\"]},\"81\":{\"h\":\"2.1 Episode 的高效利用\",\"t\":[\"Visit: every time a state-action pair appears in the episode, it is called a visit of that state-action pair.\",\"考虑一个 episode, 跟随策略π,\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…\",\"对于 MC-Basic, 这一条 episode 仅用作估计 state-action pair (s1​,a2​) 的 action value q(s1​,a2​)，但存在一定的浪费, 对于一个 episode, 可以拆分为多个 episode, 从而进行多次利用.\",\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s2​a4​​s1​a2​​s2​a3​​s5​a1​​…s1​a2​​s2​a3​​s5​a1​​…s2​a3​​s5​a1​​…s5​a1​​…​[originalepisode][episodestartingfrom(s2​,a4​)][episodestartingfrom(s1​,a2​)][episodestartingfrom(s2​,a3​)][episodestartingfrom(s5​,a1​)]​\",\"这样，我们不仅可以用来估计q(s1​,a2​), 还可以估计q(s2​,a4​),q(s2​,a3​)…\",\"Data-efficient methods:\",\"first-visit method 记录在 episode 中第一次出现的 state-action pair, 如果该 state-action pair 再次出现, 不记录 action value 估计中.\",\"every-visit method 对于每个 state-action pair, 都记录 action value 估计中.\"]},\"82\":{\"h\":\"2.2 高效地更新 Policy\",\"t\":[\"什么时候更新策略也是一个影响效率的因素。\",\"方法1：如 MC Based 一样，在收集到了足够多的 从给定的 state-action pair 出发的 episodes 后, 通过 mean estimation 估计了q(s,a)后, 才进行更新。 缺点，等候时间过长，只有当所有 episodes 均收集完，才能进行 策略更新。\",\"方法2：直接 uses the return of a single episode to approximate the action value. 这类算法统称为：Generalized policy iteration (GPI). 它会在 Policy-evaluation 和 policy-improvement 中不断切换，即不需要完全精确地求出 action value，就直接去更新策略。\"]},\"83\":{\"h\":\"2.3 MC Exploring Starts\",\"t\":[\"20240812004534\"]},\"84\":{\"h\":\"2.4 Exploring Statrts的解释\",\"t\":[\"Exploring 表示对于每一个 action-state pair (s,a), 都需要有多个 episodes, 这样才能去估计相应的qπ​(s,a). 如果存在一个 action value 未能访问，就不能确保所选择的 action 是最优的。\",\"Starts 表示对于对应 action-state pair (s,a) 的 episodes，每次都是从对应的状态 s 出发，选择对应的动作 a 进行的采样。 如果从其他状态出发，得到的 episode，如果经过了 (s,a)，那么这称为 visit , 但目前无法保证 visit 一定可以遍历所给定的 (s,a).\",\"据目前而言，Exploring Starts 是一个必要条件.\"]},\"85\":{\"h\":\"3. MC Eplison-Greedy\",\"t\":[\"将 Exploring Starts 条件转换掉，通过采取 Soft Policies 的方法。\"]},\"86\":{\"h\":\"3.1 Soft Policy\",\"t\":[\"A policy is called soft if the probability to take any action is positive. 显然 soft policy 是 stochastic 的，并且如果按照这样一个策略，在 episode 足够长的情况下，我们可以确保其可以遍历所有的 state-action pair.\"]},\"87\":{\"h\":\"3.2 -greedy policy\",\"t\":[\"在这里，我们采用的是 ϵ-greedy policies, 其属于 soft policies.\",\"π(a∣s)={1−∣A(s)∣ϵ​(∣A(s)∣−1),∣A(s)∣ϵ​,​forthegreedyaction,fortheother∣A(s)∣−1action,​\",\"其中 ϵ∈[0,1] 且 ∣A(s)∣ 为状态 s 的动作数量.ϵ-greedy policy 可以平衡 exploitation 和 exploration. 显然ϵ=0, policy 就是 greedy 的; 如果ϵ=1, 此时就是随机策略，其探索性就很强.\"]},\"88\":{\"h\":\"3.3 -greedy policy 引入 MC-based 算法中\",\"t\":[\"对于 MC Basic 以及 MC Exploring 中的 policy improvement 中，找的是在所有可能策略中的最优策略，因此是一个确定的贪心策略。\",\"20240812011140\"]},\"89\":{\"h\":\"3.3 算法流程\",\"t\":[\"20240812010538\"]},\"90\":{\"c\":[\"academic\"]},\"91\":{\"c\":[\"强化学习\"]},\"92\":{\"h\":\"RL6 - 随机近似理论与随机梯度下降算法\",\"t\":[\"针对 mean estimation 问题进行研究，因为在 RL 中 无论是 state value 还是 action value 其定义都是一个均值 (means)\",\"Stochastic approximation(SA): SA refers to a broad class of stochastic iterative algorithms soloving root finding or optimization problems.\"]},\"93\":{\"h\":\"1. 引言\"},\"94\":{\"h\":\"1.1 求均值的方法\",\"t\":[\"第一种：直接通过 E[x]≈xˉ:=N1​∑i=1N​xi​，进行估计，只有当样本全部收集完才能估计.\",\"第二种: 增量式的迭代算法. 假设:\",\"wk+1​=k1​i=1∑k​xi​,k=1,2,…\",\"对应的\",\"wk​=k−11​i=1∑k−1​xi​,k=2,3,…\",\"那么，wk+1​可以由wk​推导出来，即\",\"wk+1​​=k1​∑i=1k​xi​​=k1​(∑i=1k−1​xi​+xk​)=k1​((k−1)wk​+xk​)​=wk​−k1​(wk​−xk​)​\",\"因此，wk+1​=wk​−k1​(wk​−xk​)\"]},\"95\":{\"h\":\"2. Robbins-Monto(RM) algorithm\"},\"96\":{\"h\":\"2.1 问题引入\",\"t\":[\"假设我们需要求解如下方程:\",\"g(w)=0\",\"其中, w∈R 且需要被求解出来，g:R→R 为一个函数方程. 显然，如果对于 g(w) 已知的情况，我们可以通过一些特定的算法进行求解。 如果 g(w) 未知，就需要新的算法进行解决。\"]},\"97\":{\"h\":\"2.2 算法介绍\",\"t\":[\"RM 算法就可以用来求解当 g(w) 未知时的情况，即函数 g(w) 是一个黑盒，我们只能通过 输入序列: wk​, 得到含有噪音的观测值序列: g​(wk​,ηk​) 具体解决如下:\",\"wk+1​=wk​−ak​g​(wk​,ηk​),k=1,2,3,…\",\"其中:\",\"wk​ 是第 k 次方程根的估计.\",\"g​(wk​,ηk​)=g(wk​)+ηk​ 是第 k 次的观测值(含噪音).\",\"ak​ 是一个 positive coefficient.\"]},\"98\":{\"h\":\"2.3 收敛性分析\",\"t\":[\"Robbins-Monro Theorem In the Robbins-Monro algorithm, if\",\"0<c1​≤▽w​g(w)≤c2​,forallw; 要求g(w)必须是递增的，确保根是存在且唯一的。\",\"∑k=1∞​ak​=∞ 且 ∑k=1∞​ak2​<∞;∑k=1∞​ak2​=∞ 保证 ak​→0,k→0∑k=1∞​ak​=∞ 保证 ak​→0不要过快.\",\"E[ηk​∣Hk​]=0 且 E[ηk2​∣Hk​]<∞; 其中Hk​=wk​,wk−1​,…, 那么 wk​ converges with probability 1 (w.p.1) to the root w∗ satisfying g(w∗)=0.\",\"ak​=k1​是满足上面三个条件的. 但实际上我们往往是选择一个非常小的常数。\"]},\"99\":{\"h\":\"2.4 应用于 mean estimation 中\",\"t\":[\"比如我们要估计某个随机变量X的 E[X] 我们可以设计如下方程:\",\"g(w)≐w−E[X].\",\"那么只要求解 g(w)=0, 我们就可以得到 E[X] 的值。 同样，我们不能直接得到随机变量的值，而是对应的样本 x，sample of X. 即，我们得到的观测值是:\",\"g​(w,x)≐w−x\",\"我们可以修改为噪音 η 的形式，\",\"g​(w,η)​=w−x​=w−x+E[X]−E[X]=(w−E[X])+(E[X]−x)​≐g(w)+η​\",\"因此我们可以通过 RM 算法来进行求解\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​(wk​−xk​)\"]},\"100\":{\"h\":\"3. Stochastic gradient descent\"},\"101\":{\"h\":\"3.1 问题引入\",\"t\":[\"需要求解一个优化问题:\",\"wargmin​J(w)=E[f(w,X)]\",\"其中，\",\"w 是需要被优化的参数\",\"X 是一个随机变量\",\"w 和 X 可以是标量，也可以是向量. 对于函数 f(⋅) 输出为标量.\",\"对于这个问题，我们有以下几种方法:\",\"Method 1: 梯度下降法 (gradient descent, GD)\",\"wk+1​=wk​−αk​▽w​E[f(wk​,X)]=wk​−αk​E[▽w​f(wk​,X)]\",\"但由于 j(w) 是一个期望值，我们很难直接获得.\",\"Method 2: batch gradient descent (BGD) 借用 MC 的思想，我们可以将:\",\"E[▽w​f(wk​,X)]≈n1​i=1∑n​▽w​f(wk​,xi​).\",\"因此\",\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f(wk​,xi​)\",\"但需要大量的 samples 收集完毕才能进行一次迭代.\",\"Method 3: 随机梯度下降(SGD) 考虑能否仅用一次 sample 进行迭代.\",\"wk+1​=wk​−αk​▽w​f(wk​,xk​)\",\"但能否保证其精确度，以及是否可以到最后优化的成果。\"]},\"102\":{\"h\":\"3.2 SGD 分析\"},\"103\":{\"h\":\"mean estimation 问题转化\",\"t\":[\"我们可以将 均值估计 问题 转化为 一个 优化问题 进行求解：\",\"20240814014058\"]},\"104\":{\"h\":\"SGD 正确性和收敛性分析\",\"t\":[\"从 GD 到 SGD:\",\"wk+1​=wk​−αk​E[▽w​f(wk​,X)]⇓wk+1​=wk​−αk​▽w​f(wk​,x)​\",\"显然我们可以将 ▽w​f(wk​,x) 视为 E[▽w​f(wk​,x)] 的一个观测值(含噪声):\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]+η▽w​f(wk​,x)−E[▽w​f(wk​,x)]​​\",\"因为\",\"▽w​f(wk​,x)=E[▽w​f(wk​,x)]\",\"因此，我们需要思考使用 SGD 时wk​→w∗ as k→∞ 是否成立。\",\"我们可以将 SGD 视为一个特殊情况下的 RM 算法 SGD的目标是 minimize\",\"J(w)=E[f(w,X)]\",\"而最小值问题，往往可以转化为导数为 0 的情况,\",\"▽w​J(w)=E[▽w​f(w,X)]=0\",\"显然，可以参考 RM 算法, 让\",\"g(w)=▽w​J(w)=E[▽w​f(w,X)]\",\"从而转换为一个 root-finding 问题. 相应的，对于观测值g​(w,η),\",\"g~​(w,η)​=∇w​f(w,x)=g(w)E[∇w​f(w,X)]​​+η∇w​f(w,x)−E[∇w​f(w,X)]​​.​\",\"因此，我们就可以通过 RM 算法进行求解g(w)=0,\",\"wk+1​=wk​−αk​g​(wk​,ηk​)=wk​−αk​▽w​f(wk​,xk​)\",\"对应收敛性证明\"]},\"105\":{\"h\":\"3.3 SGD 另一种问题描述方法 (deterministic formulation)\",\"t\":[\"在之前关于使用 SGD 算法的问题描述中，我们是引入了 随机变量 和 期望的情况. 我们可以将这个问题可以转化为一个随机变量的方法，从而引入 SGD 算法.\"]},\"106\":{\"h\":\"3.4 BGD MBGD SGDw\",\"t\":[\"20240814230747\"]},\"107\":{\"c\":[\"academic\"]},\"108\":{\"c\":[\"强化学习\"]},\"109\":{\"h\":\"RL7 - Temporal-Difference Learning\"},\"110\":{\"h\":\"1. 引入\",\"t\":[\"考虑一个复杂的均值估计问题: 计算\",\"ω=E[R+γv(X)],\",\"其中, R, X 均是随机变量，γ 是常数，v(⋅) 表示一个函数。 显然我们仍然可以通过 RM 算法进行求解，假设我们可以得到有关随机变量 R, X 的采样 {x},{r}\",\"g(w)g~​(w,η)​=w−E[R+γv(X)]=w−[r+γv(x)]=(w−E[R+γv(X)])+(E[R+γv(X)]−[r+γv(x)])≐g(w)+η​\",\"因此，我们可以将该问题定义为一个 root-finding 问题: g(w)=0. 相应的 RM 算法为:\",\"wk+1​=wk​−αk​g~​(wk​,ηk​)=wk​−αk​[wk​−[rk​+γv(xk​)]]\"]},\"111\":{\"h\":\"2. TD Learning of state value\",\"t\":[\"求解给定策略 π 的 state value，这样就可以与 policy improvement 结合去寻找最优策略。\"]},\"112\":{\"h\":\"2.1 算法描述\",\"t\":[\"算法所需的数据(experience): 根据给定的策略 π 所生成的数据 (s0​,r1​,s1​,…,st​,rt+1​,st+1​,…) or {(st​,rt+1​,st+1​)}\",\"相应的算法是:\",\"vt+1​(st​)vt+1​(s)​=vt​(st​)−αt​(st​)[vt​(st​)−[rt+1​+γvt​(st+1​)]]=vt​(s),∀s=st​,​\",\"其中 t=0,1,2,…, vt​(st​)是关于 vπ​(st​) 的估计。\",\"newestimatevt+1​(st​)​​=currentestimatevt​(st​)​​−αt​(st​)[vt​(st​)−TDtargetvt​ˉ​[rt+1​+γvt​(st+1​)]​​]​TDerrorδt​​\"]},\"113\":{\"h\":\"2.2 算法分析\",\"t\":[\"TD 算法是用来求解一个 给定策略 π 的 Bellman equation.\",\"根据 state value 的定义，对于策略 π 的 state value\",\"vπ​(s)=E[R+γG∣S=s],s∈S\",\"其中 G 是 discounted return。\",\"E[G∣S=s]=a∑​π(a∣s)s′∑​p(s′∣s,a)vπ​(s)=E[vπ​(S′)∣S=s]\",\"因此，我们可以写出 Bellman equation 的新形式，称为 Bellman expection equation\",\"vπ​(s)=E[E+γvπ​(S′)∣S=s],s∈S\"]},\"114\":{\"h\":\"2.3 TD 算法 与 MC 算法的比较\"},\"115\":{\"h\":\"3. TD Learning of action value\",\"t\":[\"Sarsa (state-action-reward-state-action) Sarsa 算法其目的是用于直接估计 action value, 从而可以在 policy improvement 中直接根据 action value 进行更新即可。\",\"Sarsa 算法同样是来求解 Bellman equation:\",\"qπ​(s,a)=E[R+γqπ​(S′,A′)∣s,a],∀s,a\"]},\"116\":{\"h\":\"3.1 Sarsa\",\"t\":[\"假设我们具有 some experience {(st​,at​,rt+1​,st+1​,at+1​)} 对应的 Sarsa 算法如下来进行估计 action value:\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(sa​,at​)−αt​(st​,at​)[qt​(sa​,at​)−[rt+1​+γqt​(st+1​,at+1​)]]=qt​(s,a),∀(s,a)=(st​,at​)​\",\"其中 t=0,1,2,…, qt​(st​,at​) 是qπ​(st​,at​)的估计。\",\"收敛性情况\",\"20240817000114\",\"伪代码\",\"20240817000134\",\"20240817000230\"]},\"117\":{\"h\":\"3.2 n-step Sarsa\",\"t\":[\"20240817000500\",\"20240817000601\",\"20240817000642\"]},\"118\":{\"h\":\"3.3 Expected Sarsa\",\"t\":[\"20240817000331\",\"20240817000409\"]},\"119\":{\"h\":\"4. TD Learning of optimal action value\",\"t\":[\"Q-learning 算法是用来解决 action value 形式下的贝尔曼最优公式 (Bellman optimality equation in terms of action value)\",\"q(s,a)=E[Rt+1​+γamax​q(St+1​,a)∣St​=s,At​=a],∀s,a\"]},\"120\":{\"h\":\"4.1 Q-learning\",\"t\":[\"Q-learning 直接估计的是 optimal action value，因此不需要进行 policy improvement。\",\"qt+1​(st​,at​)qt+1​(s,a)​=qt​(st​,at​)−αt​(st​,at​)[qt​(st​,at​)−[rt+1​+γa∈Amax​qt​(st+1​,a)]]=qt​(s,a),∀(s,a)=(st​,at​)​\"]},\"121\":{\"h\":\"4.2. off-policy | on-policy\",\"t\":[\"behavior policy: 是用来与环境进行交互，从而生成经验数据的策略\",\"target policy: 是我们不断进行更新的策略，最终优化的策略\"]},\"122\":{\"h\":\"on - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是一致的，即我通过这个策略与环境进行交互生成一系列经验，在通过经验来更新这个策略。\"]},\"123\":{\"h\":\"off - policy\",\"t\":[\"该算法中 behavior policy 和 target policy 是不同的，即我通过一个策略与环境进行交互生成一系列经验。再通过这些经验来不断改进更新另一个策略，这另一个策略会更新到最优的策略。\",\"Sarsa，MC 是 on-policy 的 Q-learning 是 off-policy 的\"]},\"124\":{\"h\":\"4.3 Q-learning 伪代码\",\"t\":[\"因为 Q-learning 是 off-policy 的，因此，如果我们强制让 target policy 与 behavior ppolicy 一致也是可以的，此时也可以是 on-policy 的。\"]},\"125\":{\"h\":\"off-poicy 版本\",\"t\":[\"20240818182057\",\"此时 target policy 就不需要是 ϵ−greedy 策略了，因为不需要 target policy 进行生成数据。\"]},\"126\":{\"h\":\"on-policy 版本\",\"t\":[\"20240818181917\"]},\"127\":{\"h\":\"5. TD 算法的统一形式和总结\",\"t\":[\"20240818182301\",\"20240818182231\"]},\"128\":{\"c\":[\"academic\"]},\"129\":{\"c\":[\"强化学习\"]},\"130\":{\"h\":\"RL8 - 值函数近似(Value Function Approximation)\",\"t\":[\"对于 q-value 的估计从 基于表格的 (tabular representation) 转换到 基于函数的 (function representation)\"]},\"131\":{\"h\":\"1. 引入\",\"t\":[\"通过使用一个函数来进行拟合 state values 或者 action values: v^(s,w)≈vπ​(s)， 其中w∈Rm是参数向量。\",\"可以提高存储效率\",\"提高泛化能力\"]},\"132\":{\"h\":\"2. Alogorithm of state value estimation\",\"t\":[\"目标: 寻找一个最优的参数w，使得v^(s,w)最接近真实的vπ​(s).\",\"共两步:\",\"定义目标函数\",\"优化目标函数的算法\"]},\"133\":{\"h\":\"2.1 Obejctive function\",\"t\":[\"J(w)=E[(vπ​(S)−v^(S,w))2]\",\"分析随机变量 S 的 probability distribution (即对于损失函数中的 expection 需要考虑怎样对状态进行平均):\"]},\"134\":{\"h\":\"uniform distributon\",\"t\":[\"认为所有状态都是同等重要的，即各个状态的可能性为∣S∣1​ 因此这种情况下的 objective function 可以写成:\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=∣S∣1​s∈S∑​(vπ​(s)−v^(s,w))2\",\"但实际情况可能并不是所有状态的概率都是一致的，基于给定策略下，一些状态可能很少被访问，另一些则频繁被访问，因此采用这种 objective function 就不太可行。\"]},\"135\":{\"h\":\"stationary distribution\",\"t\":[\"stationary: 表示是一种长时间的交互行为\",\"distributon: 表示是 状态 的分布\",\"通常也称为 steady-state distributon or limiting distributon.\",\"describes the long-run behavior of a Markov process. 即基于一个策略，我们不断地与环境进行交互，最终会达到一个平稳的状态，此时可以分析每一个状态在这个策略下的概率。\",\"设 {dπ​(s)}s∈S​ 表示 基于策略 π 下的 stationary distribution。其中 dπ​(s)≥0 且 ∑s∈S​dπ​(s)=1\",\"那么此时的 objective function 可以表示为：\",\"J(w)=E[(vπ​(S)−v^(S,w))2]=s∈S∑​dπ​(s)(vπ​(s)−v^(s,w))2\",\"20240820181406\",\"20240820181718\"]},\"136\":{\"h\":\"2.2 Optimization algorithms 优化算法\",\"t\":[\"目前的优化算法只是在估计给定策略的 statevalue\",\"minisize obejctive function J(w), 采用 梯度下降 算法:\",\"wk+1​=wk​−αk​▽w​J(wk​)\",\"对应目标函数的真实梯度是：\",\"▽w​j(w)​=▽w​E[(vπ​(S)−v^(S,w))2]=E[▽w​(vπ​(S)−v^(S,w))2]=−2E[(vπ​(S)−v^(S,w))▽w​v^(S,w)]​\",\"这里包含了一个 Expection，因此可以考虑 SGD 方法进行求解：\",\"wk+1​=wk​+αk​(vπ​(st​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\",\"其中st​是随机变量S的一个样本。 但这里还有一个难点，vπ​(st​) 我们是无法估计的，这是我们所求的量，因此需要用近似算法来进行替代，从而使得算法可行。\"]},\"137\":{\"h\":\"Monte Carlo learning with function approximation\",\"t\":[\"设 gt​ 表示在一个 episode 中，从状态 st​ 出发的 discounted return。因此我们用 gt​ 来近似 vπ​(st​), 即：\",\"wk+1​=wk​+αk​(gt​−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"138\":{\"h\":\"TD Learning with function approximation\",\"t\":[\"在 TD 算法中，我们将 rt+1​+γv^(st+1​,wt​) 来近似 vπ​(st​), 因此对应算法为：\",\"wk+1​=wk​+αk​(rt+1​+γv^(st+1​,wt​)−v^(st​,wt​))▽w​vt​^​(st​,wt​)\"]},\"139\":{\"h\":\"3. Sarsa with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γq^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"20240820184127\"]},\"140\":{\"h\":\"4. Q-learning with function approximation\",\"t\":[\"wk+1​=wk​+αk​(rt+1​+γa∈A(st+1​)max​q^​(st+1​,at+1​,wt​)−q^​(st​,at​,wt​))▽w​qt​^​(st​,at​,wt​)\",\"on-policy版本：\",\"20240820184405\"]},\"141\":{\"h\":\"5. Deep Q-learning (DQN)\",\"t\":[\"Deep Q-learning 目的是最小化目标函数(objective/loss function):\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"其中 (S,A,R,S′) 均是随机变量。\"]},\"142\":{\"h\":\"优化方法\",\"t\":[\"采用梯度下降。\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,w)−q^​(S,A,w))2]\",\"对于 q^​(S,A,w) 求解梯度还是很好求的。 但对于 maxa∈A(S′)​q^​(S′,a,w) 其求解梯度比较难求，在 DQN 中采用一个 固定 的方法进行解决。 尝试将 y≐R+γmaxa∈A(S′)​q^​(S′,a,w) 中的 w 进行固定求解，具体如下：\",\"引入两个网络：\",\"main network q^​(s,a,w)w 会一直进行更新，根据梯度下降的公式。\",\"target network q^​(s′,a,wT​) 并不是一直进行更新，而是等 main network 更新一定次数后，将该网络的 w 复制到 wT​ 中\",\"将 objective function 修改为：\",\"J(w)=E[(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))2]\",\"在计算 main network q^​(s,a,w) 的梯度时，将 q^​(S′,a,wT​) 中的 wT​ 固定不动，因此左侧那个类似 TD target 的就不是有关 w 的函数，不用进行求导，从而方便计算。 然后在更新了一定次数之后，在将 wT​=w 进行赋值。\",\"因此对应的损失函数的梯度可以修改为：\",\"▽w​J​=E[−2(R+γa∈A(S′)max​q^​(S′,a,wT​)−q^​(S,A,w))▽w​q^​(S,A,w)]=E[−2(YT​−q^​(S,A,w))▽w​q^​(S,A,w)]​\",\"一些细节:\",\"w 和 wT​ 表示 the main and target networks 的参数，在初始化的时候是设为相同的。\",\"在每一次迭代时，我们需要从经验池 (the replay buffer) 中取出一定数量的样本 (a mini-batch of samples {(s,a,r,s')}) 进行训练。\",\"网络的输入包括 状态 s 和 动作 a. 在训练求解梯度时，我们先直接求解 target network 的输出，视为 yT​≐r+γmaxa∈A(s′)​q^​(s′,a,wT​)。 然后我们通过 mini-batch 样本 {(s,a,yT​)}, 通过梯度的算法来最小化对应的损失函数, 假设有 N 个样本，那么对应的损失函数求解为：\",\"J(w)=i=1∑N​yT​−q^​(s,a,w) 即可以通过梯度下降，来更新参数值\",\"wt+1​=wt​+αt​N1​i=1∑N​(yT​−q^​(si​,ai​,wt​))⋅▽w​q^​(si​,ai​,wt​)\"]},\"143\":{\"h\":\"经验回放 (replay buffer)\",\"t\":[\"20240820230827\",\"20240820230920\",\"20240820230944\"]},\"144\":{\"h\":\"伪代码\",\"t\":[\"20240820231024\",\"但在发表 DQN 的文章中，不太一样，在原文是 on-policy 且 main network 的输出是不一样的。\",\"20240820231205\"]},\"145\":{\"c\":[\"academic\"]},\"146\":{\"c\":[\"强化学习\"]},\"147\":{\"h\":\"RL9 - 策略梯度法(Policy gradient)\",\"t\":[\"之前介绍的方法都是 value-based 的方法，从这章开始时基于 policy-based 的方法。\",\"policy function approximation 是直接建立一个基于策略的目标函数来进行梯度上升的优化。\"]},\"148\":{\"h\":\"1. 基本思路\",\"t\":[\"将基于表格表示的策略 转换为 基于函数表示的策略。 即此时策略 π 可以描述为：\",\"π(a∣s,θ)\",\"其中，θ∈Rm表示参数向量，是我们需要进行优化的。\",\"当策略是以表格的形式保存时，我们定义最优的策略为 在该策略下的所有 state value 都是最大的。\",\"当策略是以函数的形式存在时，我们定义 最优的策略 为 可以最大化一个确定的常数指标(certain scalar metrics).\",\"Policy gradient 的基本步骤：\",\"确定 metrics/objective function，来定义最优的策略：J(θ)\",\"进行优化，如梯度上升算法\",\"θt+1​=θt​+α▽θ​J(θt​)\"]},\"149\":{\"h\":\"2. 目标函数定义\"},\"150\":{\"h\":\"2.1 average state value\",\"t\":[\"vˉπ​=s∈S∑​d(s)vπ​(s)=dTvπ​\",\"vˉπ​ 显然是 state value 的加权平均。\",\"d(s)≥0 是各个 state 的权重\",\"∑s∈S​d(s)=1, 我们可以认为 d(s) 是 概率分布，因此该指标可以描述为:\",\"vˉπ​=ES∼d​[vπ​(S)]\"]},\"151\":{\"h\":\"另一种表达\",\"t\":[\"J(θ)=E[t=0∑∞​γtRt+1​]\",\"20240826173749\"]},\"152\":{\"h\":\"d(s)的选择\",\"t\":[\"d 与策略 π 无关 这种情况我们将 d 表示为 d0​, vˉπ​ 表示为 vˉπ0​. 这种情况下的 d 可以根据对各个状态的重要程度进行选择： 一种是将所有状态视为同等重要，一种则是有所偏向。\",\"d 与策略 π 有关 d 表示为 dπ​(s), 即在策略 π 下的 stationary distribution。\"]},\"153\":{\"h\":\"2.2 average return value\",\"t\":[\"rˉπ​=s∈S∑​dπ​(s)rπ​(s)=ES∼d​[rπ​(s)]\",\"其中:\",\"rπ​(s)r(s,a)​≐a∈A∑​π(a∣s)r(s,a)=E[R∣s,a]=r∑​rp(r∣s,a)​\",\"rπ​(s)表示在策略π下 状态s时可以得到的平均reward。r(s,a)表示在单步情况下(在状态s采用动作a)时的平均reward。\"]},\"154\":{\"h\":\"另一种表达\",\"t\":[\"假设 agent 跟随一个 给定的策略 然后生成了一个 trajectory以及对应的 rewards (Rt+1​,Rt+2​,…)\",\"对应 average single-step reward along this trajectory is\",\"====​n→∞lim​n1​E[Rt+1​+Rt+2​+⋯+Rt+n​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​∣St​=s0​]n→∞lim​n1​E[k=1∑n​Rt+k​]s∑​dπ​(s)rπ​(s)rˉπ​​\"]},\"155\":{\"h\":\"3. 目标函数梯度求解\",\"t\":[\"这里在视频没有详细介绍，只给出了梯度的公式：\",\"▽θ​J(θ)​=s∈S∑​η(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"其中\",\"J(θ) 可以是 vˉπ​,rˉπ​,vˉπ0​ 任何一种。\",\"\\\"=\\\" 有表示 严格等于 近似 以及 成比例等于\",\"η 表示 state 的权重或者分布\",\"具体推导过程:\",\"▽θ​lnπ(a∣s,θ)▽θ​J(θ)​=π(a∣s,θ)▽θ​π(a∣s,θ)​=s∈S∑​d(s)a∈A∑​▽θ​π(a∣s,θ)qπ​(s,a)=s∈S∑​d(s)a∈A∑​π(a∣s,θ)▽θ​lnπ(a∣s,θ)qπ​(s,a)=ES∼d​[a∑​π(s∣S,θ)▽θ​lnπ(a∣S,θ)qπ​(S,a)]=ES∼d,A∼π​[▽θ​lnπ(A∣S,θ)qπ​(S,A)]≐E[▽θ​lnπ(A∣S,θ)qπ​(S,A)]​\",\"根据这个式子我们就可以通过 SGD 方法，从而可以进行近似求解：\",\"▽θ​J(θ)≈▽θ​lnπ(a∣s,θ)qπ​(s,a)\",\"一些特性 这里的策略是随机性 的，因为我们需要计算的是 lnπ(a∣s,θ), 因此我们需要保证对于所有的 s,a,θ\",\"π(a∣s,θ)≥0\",\"20240826180244\"]},\"156\":{\"h\":\"4. REINFORCE 梯度上升算法\",\"t\":[\"梯度上升算法的本质就是最大化目标函数 J(θ)\",\"θt+1​​=θt​+α▽θ​J(θ)=θt​+αE[▽θ​lnπ(A∣S,θt​)qπ​(S,A)]​\",\"而对应的真实梯度可以用一个估计的梯度来替代:\",\"θt+1​=θt​+α▽θ​lnπ(at​∣st​,θt​)qπ​(s,a)\",\"但还存在 qπ​(s,a) 是未知的，我们也可以进行近似：\",\"θt+1​=θt​+α▽θ​lnπ(a∣s,θt​)qt​(st​,at​)\",\"这里可以用不同的方法来近似 qπ​(s,a).\",\"Monte-Carlo based method， 我们便称为 REINFORCE\",\"也可以采用基于 TD 的算法 或者 其他的算法。\",\"一些细节\",\"20240826181340\",\"20240826181538\",\"20240826181638\"]},\"157\":{\"h\":\"REINFORCE 算法\",\"t\":[\"20240826181712\"]},\"158\":{\"c\":[\"academic\"]},\"159\":{\"c\":[\"强化学习\"]},\"160\":{\"h\":\"Java - 类与对象1\"},\"161\":{\"h\":\"类与对象\",\"t\":[\"类: 是对一类事物的描述，是抽象的、概念上的定义.对象: 是某一类事物实际存在的每个个体，因而也被称为实例（instance）， 是类的一个具体化个体.\",\"类的创建: 类名的首字母通常是大写的.\",\"public class Person {//这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } \",\"对象实例的创建 new Person() :\",\"public static void main(String[] args) { Person p = new Person(); } \",\"对于对象而言，其变量名存储的是对象的引用（类似于c++指针的情况），并非是所对应的对象本身，即\",\"public static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p1存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p1 = new Person(); Person p2 = p1; // 我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制 } \",\"在创建了对象之后，就可以进行一定操作，如: 访问、修改对象的属性. 不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象. 关于对象类型的变量，我们也可以不对任何对象进行引用：\",\"public static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \\\"小红\\\"; //我任性，就是要操作 System.out.println(p.name); } \",\"会出现异常，即空指针异常. 对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？ 果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\"]},\"162\":{\"h\":\"方法的创建与使用\",\"t\":[\"类除了具有属性外，还可以定义一些方法来描述同一类的行为。 方法是语句的集合，是为了完成某件事情而存在的。 方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\",\"方法的定义如下:\",\"返回值类型 方法名称() { 方法体... } \",\"具体而言:\",\"public class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\\\"我叫 \\\"+name+\\\" 今年 \\\"+age+\\\" 岁了！\\\"); } } \",\"方法的调用:\",\"public static void main(String[] args) { Person p = new Person(); p.name = \\\"小明\\\"; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } \"]},\"163\":{\"h\":\"方法的进阶使用\"},\"164\":{\"h\":\"this 的使用\",\"t\":[\"有时候我们的方法中可能会出现一些与成员变量重名的变量：\",\"void setName(String name) { name = name; //出现重名时，优先使用作用域最接近的 //这里实际上是将方法参数的局部变量name赋值为本身 } \",\"我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\",\"void setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } \",\"当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\",\"String getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } \"]},\"165\":{\"h\":\"方法的重载\",\"t\":[\"有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况。\",\"一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\",\"int sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } \"]},\"166\":{\"h\":\"构造方法\",\"t\":[\"我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？ 要在对象创建时进行处理，我们可以使用**构造方法（构造器）**来完成。\",\"构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\",\"public class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \\\"小明\\\"; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \\\"男\\\"; } } \",\"构造方法会在new的时候自动执行, 当然，我们也可以为构造方法设定参数：\",\"public class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } \",\"注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法.\",\"当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\",\"public class Person { String name = \\\"未知\\\"; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \\\"男\\\"; } \",\"这里需要特别注意，成员变量的初始化，并不是在构造方法之后，而是在这之前就已经完成了.\",\"Person(String name, int age, String sex){ System.out.println(this.age); // 在赋值之前看看是否有初始值 // 这里是 this.age 而非 age // 此时this.age已经初始化完，但还未复制，this.age = 0 this.name = name; this.age = age; this.sex = sex; } \",\"我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\",\"public class Person { String name; int age; String sex; { System.out.println(\\\"我是代码块\\\"); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\\\"我被构造了\\\"); this.name = name; this.age = age; this.sex = sex; } } \"]},\"167\":{\"c\":[\"code\"]},\"168\":{\"c\":[\"java\"]},\"169\":{\"h\":\"Java - 类与对象2\"},\"170\":{\"h\":\"静态变量和静态方法\",\"t\":[\"Static 静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。 我们通过使用 static 关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。 一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\",\"一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\",\"public class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } \",\"public static void main(String[] args) { Person.info = \\\"让我看看\\\"; System.out.println(Person.info); } \",\"同样的，我们可以将方法标记为静态：\",\"static void test(){ System.out.println(\\\"我是静态方法\\\"); } \",\"静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样:\",\"因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值, 同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。 但是静态方法是可以访问到静态变量的.\"]},\"171\":{\"h\":\"静态变量初始化\",\"t\":[\"我们实际上是将 .class 文件丢给 JVM 去执行的，而每一个 .class 文件其实就是我们编写的一个类，我们在 Java 中使用一个类之前， JVM 并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\",\"访问类的静态变量，或者为静态变量赋值\",\"new 创建类的实例（隐式加载）\",\"调用类的静态方法\",\"子类初始化时\",\"其他的情况会在讲到反射时介绍\",\"所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\"]},\"172\":{\"h\":\"包的访问与控制\"},\"173\":{\"h\":\"包的声明和导入\",\"t\":[\"包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\",\"包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的 www.baidu.com ，后面的 baidu.com 就是域名，我们的包就可以命名为com.baidu，其中的.就是用于分割的，对应多个文件夹，比如com.test\",\"20240815234719\",\"我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了： 需要通过关键字 package，用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\",\"package com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } \",\"当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中） 而当我们需要使用其他包中的类时，需要先进行导入才可以： 需要通过关键字 import 导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类:\",\"import com.test.entity.Person; //使用import关键字导入其他包中的类 import com.test.entity.*; \",\"Java会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\",\"不同类的重名问题 在不同包下的类，即使类名相同，也是不同的两个类：\",\"package com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } \",\"由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\",\"public class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } \",\"我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\"]},\"174\":{\"h\":\"访问权限控制\",\"t\":[\"Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\",\"private - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。\",\"什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。\",\"protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）\",\"public - 公共，标记为公共的内容，允许在任何地方被访问。\",\"当前类\",\"同一个包下的类\",\"不同包下的子类\",\"不同包下的类\",\"public\",\"✅\",\"✅\",\"✅\",\"✅\",\"protected\",\"✅\",\"✅\",\"✅\",\"❌\",\"默认\",\"✅\",\"✅\",\"❌\",\"❌\",\"private\",\"✅\",\"❌\",\"❌\",\"❌\",\"默认的情况下，在当前包以外的其他包中无法访问。\",\"如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\",\"public class Person { String name; int age; String sex; public static void test(){ System.out.println(\\\"我是静态方法！\\\"); } } \",\"静态导入：\",\"import static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } \"]},\"175\":{\"c\":[\"code\"]},\"176\":{\"c\":[\"java\"]},\"177\":{\"h\":\"Java - 类与对象3\"},\"178\":{\"h\":\"封装 继承和多态\",\"t\":[\"封装、继承和多态是面向对象编程的三大特性。\",\"封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\",\"继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\",\"多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\",\"正是这三大特性，让我们的Java程序更加生动形象。\"]},\"179\":{\"h\":\"封装\"},\"180\":{\"h\":\"继承\",\"t\":[\"父类是 super 子类是 this\"]},\"181\":{\"h\":\"Object 类\",\"t\":[\"Object 是最顶层的类，所有其他类都是继承它的 方法： euqals toString clone hashcode\",\"public class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class<?> getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } \"]},\"182\":{\"h\":\"方法重写\",\"t\":[\"方法的重载是为某个方法提供更多种类 而方法的重写是覆盖原有的方法实现,重写方法要求与父类的定义完全一致 比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了\",\"public class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) && //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age && //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } \",\"在修改后 即使强制类型转换 但实际上还是在调用本身的方法\",\" Person p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); Person p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p1 = new Student(\\\"小明\\\", 18, \\\"男\\\"); // Object p2 = new Student(\\\"小明\\\", 18, \\\"男\\\"); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 \",\"我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用 super 关键字： satic 成员方法中不能用 super\",\"@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } \",\"如果父类的方法是 private, 那么无法重写\"]},\"183\":{\"h\":\"控制符\",\"t\":[\"final 对于成员变量，则表示只能赋一次值。只能在构造函数进行赋值(如果有初始值，构造函数也不能赋值)，其他地方不能修改 对于成员方法，会限制其子类不允许其重写所对应的成员变量 在 类 上 加 final, 表示这个类不能再被继承了\"]},\"184\":{\"h\":\"抽象类\",\"t\":[\"抽象类具有 抽象方法，正常实例化方法是无法创造抽象类的实例\",\"抽象方法是指：只保留方法的定义，并不编写方法的主体，具体的实现由 子类 来实现.\",\"要使用抽象类，我们只能去创建它的子类对象。\",\"抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类\",\"抽象方法的访问权限不能为 private, 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\",\"public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } \",\"而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法 不过如果子类也是抽象类，就不一定需要实现。\",\"public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \\\"工人\\\"); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\\\"我是工人，做题我并不擅长，只能得到 D\\\"); } } \",\"发现对于 抽象类 中定义的 抽象方法，其子类的对应的方法的访问权限需要高于抽象类中的方法，且同样不能使用 private。 即 如果抽象方法在抽象类定义的是 public, 子类对应必须是 public 不能是 protected; 而如果抽象类定义的是 protected，子类也可以定义 public\"]},\"185\":{\"h\":\"接口\",\"t\":[\"接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\",\"接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\",\"实际上接口的目标就是将类所具有某些的行为抽象出来。\",\"可以理解为 接口 相当于 只有抽象类中的抽象方法，甚至都不是一个类了。\",\"接口里只能定义对应的抽象方法，不过可以省略 abstract 定义 并且默认在类中实现的权限是 public\",\"定义接口 interface\",\"实现接口 implements\",\"接口可以实现很多个，只需要用 逗号 隔开即可，类只能继承一个、\",\"所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\",\"java8开始，接口中的方法可以存在默认实现，default 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\",\"接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法 接口中定义的静态变量只能是public static final的 接口中定义的静态方法也只能是public的 这些可以省 直接int a = 1static void test()这种即可 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容\",\"接口是可以继承 (extends) 自其他接口的, 并且接口没有继承数量限制，接口支持多继承 接口的继承相当于是对接口功能的融合罢了\",\"接口的默认方法是保底的，只要一个类的父类或者自身有对应方法，就不会执行接口的默认方法\",\"接口中如果定义了与 Object 同名的方法，不能使用默认，因为其他类就算继承这个接口，由于类本身都是继承 Object 的，这个默认方法没有任何作用\",\"比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\",\"接口定义:\",\"public interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } \",\"让类来使用这个接口\",\"public class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\\\"我会学习！\\\"); } } \",\"接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用，即\",\"public class Main { public static void main(String[] args) { Study study = new Teacher(\\\"penguin\\\",18,\\\"male\\\"); study.study() //这里的话只能使用接口中的方法，以及Object的方法 } } \",\"接口同样支持向下转型：\",\"public static void main(String[] args) { Study study = new Teacher(\\\"小王\\\", 27, \\\"男\\\"); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } \",\"从Java8开始，接口中可以存在让抽象方法的默认实现：\",\"public interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\\\"我是默认实现\\\"); } } \"]},\"186\":{\"h\":\"Object类中的 克隆方法\",\"t\":[\"这是浅拷贝，克隆出来的与原来的对象不是一个对象，但对象中的属性都是同一个地址\",\"克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\",\"浅拷贝： 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。\",\"深拷贝： 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。\",\"package java.lang; public interface Cloneable { //这个接口中什么都没定义 } \",\"具体实现克隆:\",\"public class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \\\"学生\\\"); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\\\"我会学习！\\\"); } } \",\"克隆实现：\",\"public static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } \"]},\"187\":{\"h\":\"枚举类\",\"t\":[\"public enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } \",\"使用枚举类也非常方便，就像使用普通类型那样：\",\"public class Student { private Status status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } \",\"使用就像对象的参数一样:\",\"Status.RUNNING Status.STUDY Status.SLEEP \",\"枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\",\"//这里使用javap命令对class文件进行反编译得到 Compiled from \\\"Status.java\\\" public final class com.test.Status extends java.lang.Enum<com.test.Status> { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } \",\"枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\",\"public enum Status { RUNNING(\\\"睡觉\\\"), STUDY(\\\"学习\\\"), SLEEP(\\\"睡觉\\\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } \",\"public static void main(String[] args) { Student student = new Student(\\\"小明\\\", 18, \\\"男\\\"); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } \"]},\"188\":{\"c\":[\"code\"]},\"189\":{\"c\":[\"java\"]},\"190\":{\"h\":\"Java - 类与对象4\"},\"191\":{\"h\":\"面向对象高级篇1\"},\"192\":{\"h\":\"基本类型包装类\",\"t\":[\"Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\"]},\"193\":{\"h\":\"所有包装类如下\",\"t\":[\"20241017002218\",\"其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\",\"byte -> Byte\",\"boolean -> Boolean\",\"short -> Short\",\"char -> Character\",\"int -> Integer\",\"long -> Long\",\"float -> Float\",\"double -> Double\",\"包装类型的自动装箱和拆箱机制 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想） 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\",\" public static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 // 不需要 Integer i = new Integer(10) // 这里本质上就是被自动包装成了一个Integer类型的对象， // 只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的 Integer i = 10; int a = i; } \",\"因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\",\" public static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } \",\"那么自动装箱的呢？\",\" public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\",\"但是如果超出这个缓存范围的话，就会得到不同的对象了：\",\"public static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } \",\"这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制。\"]},\"194\":{\"h\":\"包装类的方法\",\"t\":[\"包装类支持字符串直接转换\",\" public static void main(String[] args) { Integer i = new Integer(\\\"666\\\"); //直接将字符串的666，转换为数字666 System.out.println(i); // 字符串转Integer有多个方法： Integer i = Integer.valueOf(\\\"5555\\\"); Integer i = Integer.decode(\\\"0xA6\\\"); Integer.toHexString(166) } \"]},\"195\":{\"h\":\"特殊包装类\",\"t\":[\"BigInteger 和 BigDecimal 都在 java.math 中\",\"Void类 没啥意义 不能 new 只能 Void v = null\",\"BigInteger import java.math.BigInteger 用于计算超大数字，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字。 但不支持 自动装箱|拆箱机制，计算的话也只能通过 BigInteger 提供的方法进行计算。 一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\",\" public static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); BigInteger h = BigInteger.valueOf(100) // 乘法 BigInteger a = h.multiply(BigInteger.TEN) } \",\"BigDecimal import java.math.BigDecimal 浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算\",\"public static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } \"]},\"196\":{\"c\":[\"code\"]},\"197\":{\"c\":[\"java\"]},\"198\":{\"h\":\"Java - 数组 | 字符串 | 正则表达式\"},\"199\":{\"h\":\"面向对象高级篇 2\"},\"200\":{\"h\":\"数组\",\"t\":[\"数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素。\"]},\"201\":{\"h\":\"定义\",\"t\":[\"数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建） 即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用 new 关键字\",\"public static void main(String[] args) { int[] array = new int[10]; //类型[]就表示这个是一个数组类型 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } \",\"创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的 其他定义方法:\",\"类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 \"]},\"202\":{\"h\":\"方法\",\"t\":[\"数组的 length 是在一开始就确定的，而且是 final类型 的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\",\" public static void main(String[] args) { int[] array = new int[10]; System.out.println(\\\"当前数组长度为：\\\"+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } \",\"array 虽然是继承于 Object，但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现，所以可能不满足真实需求。\"]},\"203\":{\"h\":\"访问元素\",\"t\":[\"for 或者 foreach\",\" public static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i < array.length; i++) { System.out.print(array[i] + \\\" \\\"); } for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\\\" \\\"); //每一轮循环，i都会更新成数组中下一个元素 } } \"]},\"204\":{\"h\":\"特性\",\"t\":[\"这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\",\" public static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; // 这样是不能赋值的 会报错 } \",\"由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的, 即 int[] arr = new int[10] 是不能 Object[] arrav = arr 这样的\",\"但是如果是引用类型的话，是可以的,因为父类都是 Object\",\" public static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } \"]},\"205\":{\"h\":\"性质\",\"t\":[\" public static void main(String[] args) { final int[] a = {1,2,3,4}; // 值还是可以修改，只是数组的地址不准修改 a[0] = 4; // 允许 a = {2,4,8,7}; //不允许 } \"]},\"206\":{\"h\":\"多维数组\",\"t\":[\"既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的\",\"public static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } \"]},\"207\":{\"h\":\"可变长参数\",\"t\":[\"public void function(参数类型...参数名称) 这样参数名称所表示的就是一个数组\",\"public class Person { String name; int age; String sex; // 可以传入 0 - N 个类型的实参 public void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } } public static void main(String[] args) { Person person = new Person(); person.test(\\\"1！\\\", \\\"5！\\\", \\\"哥们在这跟你说唱\\\"); //这里我们可以自由传入任意数量的字符串 } \",\"注意，如果同时存在其他参数，那么可变长参数只能放在最后：\",\"public void test(int a, int b, String... strings){ } \"]},\"208\":{\"h\":\"函数的\",\"t\":[\"public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } \",\"可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：java com/test/Main lbwnb aaaa xxxxx 因此会读取命令行中的指令参数进行存储到 args 中。\"]},\"209\":{\"h\":\"字符串\",\"t\":[\"字符串类是一个比较特殊的类，它用于保存字符串。 我们知道，基本类型 char 可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组） Java中没有字符串这种基本类型，因此只能使用类来进行定义。 注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\"]},\"210\":{\"h\":\"String 类\",\"t\":[\"String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象, 也可以象征性 new 不过没必要 如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了\",\"public static void main(String[] args) { String str1 = \\\"Hello World\\\"; String str2 = \\\"Hello World\\\"; System.out.println(str1 == str2); // 这样就不同 String str3 = new String(\\\"Hello World\\\"); String str4 = new String(\\\"Hello World\\\"); System.out.println(str3 == str4); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } \",\"因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用 ==， String类重载了equals方法用于判断和比较内容是否相同\",\"获取长度 str.length()\",\"public static void main(String[] args) { String str = \\\"Hello World\\\"; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } \",\"字符串类中提供了很多方便我们操作的方法， 比如字符串的裁剪 (substring)、分割操作 (split)\",\" public static void main(String[] args) { String str = \\\"Hello World\\\"; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); String[] strings = str.split(\\\" \\\"); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } \",\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组: char[] chars = str.toCharArray()字符数组转字符串: String str = new String(chars)\"]},\"211\":{\"h\":\"StringBuilder 类\",\"t\":[\"StringBuilder 就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足\",\"public static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\\\"AAA\\\"); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\\\"BBB\\\"); builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } \",\"字符串支持使用 + 和 += 进行拼接操作, 但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\",\"对于变量来说\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } \",\"如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？ 这种情况实际上会被优化为下面的写法：\",\"public static void main(String[] args) { String str1 = \\\"你看\\\"; String str2 = \\\"这\\\"; String str3 = \\\"汉堡\\\"; String str4 = \\\"做滴\\\"; String str5 = \\\"行不行\\\"; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } \"]},\"212\":{\"h\":\"正则表达式\",\"t\":[\"str.match(正则表达式)\",\"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\",\"public static void main(String[] args) { String str = \\\"oooo\\\"; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\\\"o+\\\")); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } \",\"用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\",\"字符\",\"描述\",\"*\",\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \\\"z\\\" 以及 \\\"zoo\\\"。***** 等价于 {0,}。\",\"+\",\"匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \\\"zo\\\" 以及 \\\"zoo\\\"，但不能匹配 \\\"z\\\"。+ 等价于 {1,}。\",\"?\",\"匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \\\"do\\\" 、 \\\"does\\\"、 \\\"doxy\\\" 中的 \\\"do\\\" 。? 等价于 {0,1}。\",\"n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \\\"Bob\\\" 中的 o，但是能匹配 \\\"food\\\" 中的两个 o。\",\"n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \\\"Bob\\\" 中的 o，但能匹配 \\\"foooood\\\" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\",\"m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \\\"fooooood\\\" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\",\"如果我们想要表示一个范围内的字符，可以使用方括号：\",\"public static void main(String[] args) { String str = \\\"abcabccaa\\\"; System.out.println(str.matches(\\\"[abc]*\\\")); //表示abc这几个字符可以出现 0 - N 次 } \",\"对于普通字符来说，我们可以下面的方式实现多种字符匹配：\",\"字符\",\"描述\",\"[ABC]\",\"匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中所有的 e o u a 字母。\",\"[^ABC]\",\"匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \\\"google runoob taobao\\\" 中除了 e o u a 字母的所有字母。\",\"[A-Z]\",\"[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。\",\".\",\"匹配除换行符（\\\\n、\\\\r）之外的任何单个字符，相等于 [^\\\\n\\\\r]\",\"[\\\\s\\\\S]\",\"匹配所有。\\\\s 是匹配所有空白符，包括换行，\\\\S 非空白符，不包括换行。\",\"\\\\w\",\"匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\",\"当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\",\"正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\"]},\"213\":{\"c\":[\"code\"]},\"214\":{\"c\":[\"java\"]},\"215\":{\"h\":\"Java - 内部类\"},\"216\":{\"h\":\"面向对象高级篇 3\",\"t\":[\"静态 属于 类， 成员 属于 对象。\"]},\"217\":{\"h\":\"内部类\",\"t\":[\"内部类顾名思义，就是创建在内部的类。\"]},\"218\":{\"h\":\"成员内部类 (属于 对象)\",\"t\":[\"成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用\",\"成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的， 如果我们要使用成员内部类，那么就需要创造一个对象，才能去 new 一个成员内部类。\",\"我们可以直接在类的内部定义成员内部类：\",\"public class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\\\"我是成员内部类！\\\"); } } } \",\"public static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 inner.test(); } \",\"注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.\",\"这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\\\"我是成员内部类：\\\"+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } \",\"每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\",\"20241027012950\",\"public static void main(String[] args) { Test a = new Test(\\\"小明\\\"); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\\\"小红\\\"); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } \",\"那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个 (就近原则) 如果需要指定为外部的对象，那么需要在前面添加外部类型名称Test.this.\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\\\"方法参数的name = \\\"+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\\\"成员内部类的name = \\\"+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\\\"成员内部类的name = \\\"+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } \",\"包括对方法的调用和super关键字的使用，也是一样的：\",\"public class Inner { String name; public void test(String name){ this.toString(); //内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } \"]},\"219\":{\"h\":\"静态内部类 (属于 类)\",\"t\":[\"静态内部类就像静态方法和静态变量一样，是属于类的，不需要，依附任何对象我们可以直接创建使用。\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\\\"我是静态内部类！\\\"); } } } \",\"不需要依附任何对象，我们可以直接创建静态内部类的对象：\",\"public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } \",\"静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的\"]},\"220\":{\"h\":\"局部内部类\",\"t\":[\"(这种局部内部类的形式，使用频率很低，基本上不会用到) 局部内部类就像局部变量一样，可以在方法中定义。 基本定义是：(不需要声明访问权限，因为它作用范围就只是方法内)\",\"public 方法名(){ class 局部内部类名 { 内容 } } \",\"既然是在方法中声明的类，那作用范围也就只能在方法中了\",\"public class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 public void test(){ System.out.println(\\\"我是局部内部类\\\"); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } \"]},\"221\":{\"h\":\"静态内部类编译特性\",\"t\":[\"package com.test; import com.test.entity.Test; public class Main { public static void main(String[] args) { Test.Inner.test(); } } \",\"package com.test.entity; public class Test { static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"内部类静态方法\\\"); } } } \",\"结果是：\",\"20241027015244\",\"说明这种情况下，只是初始化了内部类的，并没有初始化内部类，因为并没有使用到外部类的任何静态变量，所以只初始化了内部类。 因为在编译的时候，类的内部类它会单独生成一个 .class，当你使用内部类静态方法，不会调用外部类的 class 只有在你使用到外部类的静态变量或方法后，才会初始化外部类, 但还是先初始化内部类。\",\"package com.test.entity; public class Test { public static String name = \\\"penguin\\\"; static { System.out.println(\\\"外部类初始化\\\"); } public static class Inner { static { System.out.println(\\\"内部类初始化\\\"); } public static void test(){ System.out.println(\\\"使用外部静态变量\\\" + name); System.out.println(\\\"内部类静态方法\\\"); } } } \",\"输出为：\",\"20241027015718\"]},\"222\":{\"h\":\"匿名内部类\",\"t\":[\"匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\",\"不能直接通过 new 的方式去创建一个抽象类或是接口对象，正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\",\"但我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象\",\"public abstract class Student { public abstract void test(); } \",\"public static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\\\"我是匿名内部类的实现!\\\"); } }; student.test(); } \",\"此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。 匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）\",\"同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类 这样就是一个实现 接口 中方法 的匿名类，但类名必须与接口一致。\",\"package com.test.entity; public interface Study { void study(); } \",\"public class Main { public static void main(String[] args) { Study ss = new Study() { @Override public void study() { System.out.println(\\\"penguin\\\"); } }; ss.study(); } } \",\"匿名对象本身不能定义新的属性。匿名对象的类是在创建时匿名生成的，但它继承自一个现有的类或实现了一个接口。因此，匿名类只能访问其父类的属性或方法，无法直接定义新的属性.\",\"在 Java 中，匿名对象通常不能直接给属性赋值，因为匿名对象没有类名，无法显式定义构造函数或初始化块 因此，为了在创建匿名对象时进行属性初始化，Java 提供了一种特殊的语法，即使用初始化块 {}。\",\"当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。 类似：\",\"package com.test.entity; public class Penguin { protected String apple; public void test(){ System.out.println(apple); } } \",\"public class Main { public static void main(String[] args) { Penguin pp = new Penguin(){ { apple = \\\"ppp\\\"; } }; pp.test(); } } \"]},\"223\":{\"h\":\"匿名内部类特性\",\"t\":[\"对于 匿名内部类 或者 Lambda 中，如果想用外部变量，只能使用 final 的变量，如果不是 final，会隐式修改为 final 即之后不能修改\",\"public static void main(String[] args) { int a = 10; // a = 20; // 如果修改了a 就会报错 Study pp = new Study{ @Override public void study(){ System.out.println(a); } } pp.test(); } \"]},\"224\":{\"h\":\"Lambda表达式\",\"t\":[\"如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式\",\"public static void main(String[] args) { Study study = () -> System.out.println(\\\"我是学习方法！\\\"); //是不是感觉非常简洁！ study.study(); } \",\"Lambda表达式的具体规范：\",\"标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }\",\"和匿名内部类不同，Lambda 仅支持接口，不支持抽象类\",\"接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\",\"如果有一个参数和返回值的话：\",\"public static void main(String[] args) { Study study = (a) -> { System.out.println(\\\"我是学习方法\\\"); return \\\"今天学会了\\\"+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } \",\"如果参数只有一个，那么可以省去小括号 如果方法体中只有一个返回语句，可以直接省去花括号和return关键字\",\"Study study = (a) -> { return \\\"今天学会了\\\"+a; //这种情况是可以简化的 }; ==================================== Study study = (a) -> \\\"今天学会了\\\"+a; ==================================== Study study = a -> \\\"今天学会了\\\"+a; \",\"如果一个方法的参数需要的是一个接口的实现:\",\"public static void main(String[] args) { test(a -> \\\"今天学会了\\\"+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } \",\"对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\"]},\"225\":{\"h\":\"方法引用\",\"t\":[\"方法引用 类名::方法名 就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义 参数一样，返回值一样 一样才行）\",\"public interface Study { int sum(int a, int b); //待实现的求和方法 } \",\"那么使用时候，可以直接使用Lambda表达式：\",\"public static void main(String[] args) { Study study = (a, b) -> a + b; } \",\"只不过还能更简单，因为Integer类中默认提供了求两个int值之和的静态方法：\",\"public static void main(String[] args) { Study study = (a, b) -> Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } ================= 方法引用 类名::方法名 ========================= public static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } \",\"方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。\",\"任何方法都可以通过方法引用作为实现：\",\"public interface Study { String study(); } \",\"如果是普通成员方法 (成员方法只能通过 对象 调用，不是静态方法)，我们同样需要使用对象来进行方法引用：\",\"public static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \\\"卡布奇诺今犹在，不见当年倒茶人。\\\"; } \",\"因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\",\"public static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } \",\"反正只要是符合接口中方法的定义的，都可以直接进行方法引用。\"]},\"226\":{\"c\":[\"code\"]},\"227\":{\"c\":[\"java\"]},\"228\":{\"h\":\"Java - 异常\"},\"229\":{\"h\":\"面向对象高级篇 4\"},\"230\":{\"h\":\"异常机制\"},\"231\":{\"h\":\"异常类型\",\"t\":[\"我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等. 他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自 Exception 类\",\"运行时异常 继承自 RuntimeException 在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。 所有的运行时异常都继承自 RuntimeExceptionRuntimeException 是继承 Exception\",\"编译时异常 继承 Exception 编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！ 默认继承自 Exception 类的异常都是编译时异常。 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\",\"protected native Object clone() throws CloneNotSupportedException; \",\"20241029001425\",\"错误 Error错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了。 比如 OutOfMemoryError 就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\"]},\"232\":{\"h\":\"自定义异常\",\"t\":[\"异常其实就两大类，一个是编译时异常 Exception，一个是运行时异常 RuntimeException。 我们自定义异常也是从这两类中进行选择。\",\"自定义编译时异常 编译时异常只需要继承 Exception 就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\",\"public class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } \",\"自定义运行时异常 运行时异常只需要继承 RuntimeException 就行了\",\"public class TestException extends RuntimeException{ public TestException(String message){ super(message); } } \"]},\"233\":{\"h\":\"抛出异常\",\"t\":[\"当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\",\"public static int test(int a, int b) { if(b == 0) throw new ArithmeticException(\\\"被除数不能为0\\\"); //throw new RuntimeException(\\\"被除数不能为0\\\"); //使用throw关键字来抛出异常 return a / b; } \",\"异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在 RuntimeException 的构造方法中我们可以写入原因。\",\"注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以，因为不这样就无法编译了： throws Exception\",\"就是说如果这个函数结束时有异常，要么自己处理好，要么就往上一级函数上 throw\",\"private static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\\\"我是编译时异常！\\\"); } \",\"如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\",\"private static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } \",\"最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\",\"@Override protected Object clone() { return new Object(); } \"]},\"234\":{\"h\":\"异常的处理\",\"t\":[\"当程序没有按照我们理想的样子运行而出现异常时（默认会交给 JVM 来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息） 现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获\",\"异常处理：要么一直 throw 交给上一级函数 最终到 main 给 jvm 处理; 要么在当前函数通过 try-catch 进行捕获。\",\"无论是否出现异常，都会在最后执行任务，可以交给 finally 语句块来处理，可以只跟 try 使用。\",\"public static void main(String[] args) { // try...catch 进行异常捕获 try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\\\"异常错误信息：\\\"+e.getMessage()); //获取异常的错误信息 } System.out.println(\\\"程序继续正常运行！\\\"); } \",\"如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用 try-catch 语句块进行异常的捕获，不然就无法通过编译.\",\"public static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } \",\"当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级： 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\",\"public static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } \",\"注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到\",\"public static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\\\"捕获到异常\\\"); } } \",\"当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 但是要注意一下顺序 try {} catch { xxxException | xxxException e }{ }\",\"try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } // 可以简写为 try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } \"]},\"235\":{\"h\":\"断言表达式\",\"t\":[\"我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下。\",\"assert断言表达式，如果 assert 后面的表达式判断结果为 false，将抛出 AssertionError 错误。\",\"比如我们可以判断变量的值，如果大于10就抛出错误：\",\"public static void main(String[] args) { int a = 10; assert a > 10; } \"]},\"236\":{\"c\":[\"code\"]},\"237\":{\"c\":[\"java\"]},\"238\":{\"h\":\"Java - 工具类\"},\"239\":{\"h\":\"面向对象高级篇 6\",\"t\":[\"工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\"]},\"240\":{\"h\":\"常用工具类\"},\"241\":{\"h\":\"数学工具类\",\"t\":[\"Math类 是在 java.util 中，因此可以直接调用。\",\"public static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } \",\"随机数生成 Random 类\",\"import java.util.Random; public static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i < 30; i++) { System.out.print(random.nextInt(100)+\\\" \\\"); //nextInt方法可以指定创建0 - x之内的随机数 } } \"]},\"242\":{\"h\":\"数组工具类\",\"t\":[\"Arrays类 是在 java.util 中，因此可以直接调用。\",\"一些方法：Arrays.toString | Arrays.sort | Arrays.fill | Arrays.copyOfArrays.deepToString 可以对 多维数组 打印\",\"Arrays类 用于便捷操作数组，比如我们想要打印数组，可以直接通过 toString 方法转换字符串：\",\"public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } \"]},\"243\":{\"c\":[\"code\"]},\"244\":{\"c\":[\"java\"]},\"245\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"246\":{\"h\":\"Daily\"},\"247\":{\"h\":\"UAV\"},\"248\":{\"h\":\"Academic\"},\"249\":{\"h\":\"强化学习\"},\"250\":{\"h\":\"Java\"},\"251\":{\"h\":\"Code\"}},\"dirtCount\":0,\"index\":[[\"打印\",{\"1\":{\"242\":1}}],[\"打印栈追踪信息\",{\"1\":{\"234\":1}}],[\"快速取最小值\",{\"1\":{\"241\":1}}],[\"快速取最大值\",{\"1\":{\"241\":1}}],[\"常用工具类\",{\"0\":{\"240\":1}}],[\"常数\",{\"1\":{\"9\":1}}],[\"便于我们去使用的类\",{\"1\":{\"239\":1}}],[\"工具类一般都会内置大量的静态方法\",{\"1\":{\"239\":1}}],[\"工具类就是专门为一些特定场景编写的\",{\"1\":{\"239\":1}}],[\"工具类\",{\"0\":{\"238\":1}}],[\"工人\",{\"1\":{\"184\":1}}],[\"断言表达式\",{\"0\":{\"235\":1}}],[\"永远都不会被捕获\",{\"1\":{\"234\":2}}],[\"父类型在前\",{\"1\":{\"234\":1}}],[\"父类是\",{\"1\":{\"180\":1}}],[\"捕获到异常\",{\"1\":{\"234\":1}}],[\"捕获异常\",{\"1\":{\"231\":1}}],[\"继续编写throws往上一级抛\",{\"1\":{\"234\":1}}],[\"继承自\",{\"1\":{\"231\":1}}],[\"继承自number类\",{\"1\":{\"193\":1}}],[\"继承\",{\"0\":{\"180\":1},\"1\":{\"178\":1,\"231\":1}}],[\"继承和多态是面向对象编程的三大特性\",{\"1\":{\"178\":1}}],[\"继承和多态\",{\"0\":{\"178\":1}}],[\"抛给上一级\",{\"1\":{\"234\":1}}],[\"抛出异常\",{\"0\":{\"233\":1}}],[\"明确会抛出ioexception\",{\"1\":{\"234\":1}}],[\"语句块进行异常的捕获\",{\"1\":{\"234\":1}}],[\"语句块来处理\",{\"1\":{\"234\":1}}],[\"程序继续正常运行\",{\"1\":{\"234\":1}}],[\"处理\",{\"1\":{\"234\":1}}],[\"给\",{\"1\":{\"234\":1}}],[\"给定的策略\",{\"1\":{\"154\":1}}],[\"给定策略\",{\"1\":{\"113\":1}}],[\"交给上一级函数\",{\"1\":{\"234\":1}}],[\"现在我们希望能够自己处理出现的问题\",{\"1\":{\"234\":1}}],[\"请调用方处理好\",{\"1\":{\"233\":1}}],[\"请注意在逗号和两个数之间不能有空格\",{\"1\":{\"212\":1}}],[\"函数调用方必须要对抛出的这个异常进行对应的处理才可以\",{\"1\":{\"233\":1}}],[\"函数的\",{\"0\":{\"208\":1}}],[\"被除数不能为0\",{\"1\":{\"233\":2}}],[\"错误\",{\"1\":{\"231\":1,\"235\":1}}],[\"算术异常等\",{\"1\":{\"231\":1}}],[\"算法是用来解决\",{\"1\":{\"119\":1}}],[\"算法是用来求解一个\",{\"1\":{\"113\":1}}],[\"算法如下来进行估计\",{\"1\":{\"116\":1}}],[\"算法同样是来求解\",{\"1\":{\"115\":1}}],[\"算法其目的是用于直接估计\",{\"1\":{\"115\":1}}],[\"算法分析\",{\"0\":{\"113\":1}}],[\"算法所需的数据\",{\"1\":{\"112\":1}}],[\"算法为\",{\"1\":{\"110\":1}}],[\"算法进行求解\",{\"1\":{\"110\":1}}],[\"算法进行求解g\",{\"1\":{\"104\":1}}],[\"算法\",{\"0\":{\"114\":1,\"157\":1},\"1\":{\"104\":2,\"105\":1,\"136\":1}}],[\"算法来进行求解\",{\"1\":{\"99\":1}}],[\"算法就可以用来求解当\",{\"1\":{\"97\":1}}],[\"算法介绍\",{\"0\":{\"97\":1}}],[\"算法流程\",{\"0\":{\"89\":1}}],[\"算法中\",{\"0\":{\"88\":1},\"1\":{\"138\":1}}],[\"算法的统一形式和总结\",{\"0\":{\"127\":1}}],[\"算法的比较\",{\"0\":{\"114\":1}}],[\"算法的问题描述中\",{\"1\":{\"105\":1}}],[\"算法的核心是\",{\"1\":{\"77\":1}}],[\"算法的基础上\",{\"1\":{\"23\":1}}],[\"算法思路\",{\"0\":{\"77\":1}}],[\"算法比较\",{\"0\":{\"70\":1}}],[\"算法描述\",{\"0\":{\"66\":1,\"112\":1}}],[\"算法迭代示意图\",{\"1\":{\"65\":1}}],[\"算法1\",{\"1\":{\"13\":1}}],[\"空指针异常\",{\"1\":{\"231\":1}}],[\"异常错误信息\",{\"1\":{\"234\":1}}],[\"异常处理\",{\"1\":{\"234\":1}}],[\"异常的处理\",{\"0\":{\"234\":1}}],[\"异常的抛出同样需要创建一个异常对象出来\",{\"1\":{\"233\":1}}],[\"异常对象携带了我们抛出异常时的一些信息\",{\"1\":{\"233\":1}}],[\"异常其实就两大类\",{\"1\":{\"232\":1}}],[\"异常就是不同寻常\",{\"1\":{\"231\":1}}],[\"异常类型\",{\"0\":{\"231\":1}}],[\"异常机制\",{\"0\":{\"230\":1}}],[\"异常\",{\"0\":{\"228\":1}}],[\"反正只要是符合接口中方法的定义的\",{\"1\":{\"225\":1}}],[\"卡布奇诺今犹在\",{\"1\":{\"225\":1}}],[\"任何方法都可以通过方法引用作为实现\",{\"1\":{\"225\":1}}],[\"任何一种\",{\"1\":{\"155\":1}}],[\"待实现的求和方法\",{\"1\":{\"225\":1}}],[\"返回值一样\",{\"1\":{\"225\":1}}],[\"返回值类型\",{\"1\":{\"162\":1}}],[\"今天学会了\",{\"1\":{\"224\":5}}],[\"今年\",{\"1\":{\"162\":1}}],[\"代码语句\",{\"1\":{\"224\":1}}],[\"代码块中的内容会在对象创建时仅执行一次\",{\"1\":{\"166\":1}}],[\"代码块同样会在对象构造之前进行\",{\"1\":{\"166\":1}}],[\"标准格式为\",{\"1\":{\"224\":1}}],[\"标记为native的方法是本地方法\",{\"1\":{\"181\":1}}],[\"标记为公共的内容\",{\"1\":{\"174\":1}}],[\"标记为受保护的内容可以能被类本身和同包中的其他类访问\",{\"1\":{\"174\":1}}],[\"标记为私有的内容无法被除当前类以外的任何位置访问\",{\"1\":{\"174\":1}}],[\"普通的类也可以\",{\"1\":{\"222\":1}}],[\"匿名类只能访问其父类的属性或方法\",{\"1\":{\"222\":1}}],[\"匿名对象通常不能直接给属性赋值\",{\"1\":{\"222\":1}}],[\"匿名对象的类是在创建时匿名生成的\",{\"1\":{\"222\":1}}],[\"匿名对象本身不能定义新的属性\",{\"1\":{\"222\":1}}],[\"匿名内部类特性\",{\"0\":{\"223\":1}}],[\"匿名内部类中同样可以使用类中的属性\",{\"1\":{\"222\":1}}],[\"匿名内部类是我们使用频率非常高的一种内部类\",{\"1\":{\"222\":1}}],[\"匿名内部类\",{\"0\":{\"222\":1},\"1\":{\"223\":1}}],[\"把未实现的方法实现了\",{\"1\":{\"222\":1}}],[\"把对象的属性和方法结合成一个独立的整体\",{\"1\":{\"178\":1}}],[\"说明这种情况下\",{\"1\":{\"221\":1}}],[\"结果是\",{\"1\":{\"221\":1}}],[\"结合去寻找最优策略\",{\"1\":{\"111\":1}}],[\"局部内部类直接使用类名就行\",{\"1\":{\"220\":1}}],[\"局部内部类名\",{\"1\":{\"220\":1}}],[\"局部内部类就像局部变量一样\",{\"1\":{\"220\":1}}],[\"局部内部类\",{\"0\":{\"220\":1}}],[\"整个内部类中都处于静态上下文\",{\"1\":{\"219\":1}}],[\"整合\",{\"1\":{\"46\":1}}],[\"依附任何对象我们可以直接创建使用\",{\"1\":{\"219\":1}}],[\"依附于b创建的对象\",{\"1\":{\"218\":1}}],[\"依附于a创建的对象\",{\"1\":{\"218\":1}}],[\"依然是就近原则\",{\"1\":{\"218\":1}}],[\"依赖于当前状态和所采取的动作\",{\"1\":{\"19\":1}}],[\"套娃了属于是\",{\"1\":{\"218\":1}}],[\"甚至连名字都没有\",{\"1\":{\"222\":1}}],[\"甚至还可以继续套娃一个成员内部类\",{\"1\":{\"218\":1}}],[\"甚至都不是一个类了\",{\"1\":{\"185\":1}}],[\"甚至都不是一个类\",{\"1\":{\"185\":1}}],[\"属于\",{\"0\":{\"218\":1,\"219\":1},\"1\":{\"216\":2}}],[\"属性默认就是这个值\",{\"1\":{\"166\":1}}],[\"9\",{\"1\":{\"212\":1,\"241\":1,\"242\":1}}],[\"非空白符\",{\"1\":{\"212\":1}}],[\"^\",{\"1\":{\"212\":1}}],[\"^aeiou\",{\"1\":{\"212\":1}}],[\"^abc\",{\"1\":{\"212\":1}}],[\"字母的所有字母\",{\"1\":{\"212\":1}}],[\"字母\",{\"1\":{\"212\":1}}],[\"字符\",{\"1\":{\"212\":2}}],[\"字符数组转字符串\",{\"1\":{\"210\":1}}],[\"字符数组和字符串之间是可以快速进行相互转换的字符串转字符数组\",{\"1\":{\"210\":1}}],[\"字符串支持使用\",{\"1\":{\"211\":1}}],[\"字符串类中提供了很多方便我们操作的方法\",{\"1\":{\"210\":1}}],[\"字符串类是一个比较特殊的类\",{\"1\":{\"209\":1}}],[\"字符串的内容比较\",{\"1\":{\"210\":1}}],[\"字符串中的字符一旦确定\",{\"1\":{\"209\":1}}],[\"字符串\",{\"0\":{\"198\":1,\"209\":1}}],[\"字符串转integer有多个方法\",{\"1\":{\"194\":1}}],[\"字符串内容的比较\",{\"1\":{\"182\":1}}],[\"至少匹配n\",{\"1\":{\"212\":1}}],[\"z0\",{\"1\":{\"212\":1}}],[\"za\",{\"1\":{\"212\":1}}],[\"z\",{\"1\":{\"212\":5}}],[\"zo+\",{\"1\":{\"212\":1}}],[\"zoo\",{\"1\":{\"212\":2}}],[\"zo\",{\"1\":{\"212\":2}}],[\"能匹配\",{\"1\":{\"212\":2}}],[\"例如\",{\"1\":{\"212\":8}}],[\"匹配字母\",{\"1\":{\"212\":1}}],[\"匹配字符串\",{\"1\":{\"212\":2}}],[\"匹配所有\",{\"1\":{\"212\":1}}],[\"匹配所有大写字母\",{\"1\":{\"212\":1}}],[\"匹配除换行符\",{\"1\":{\"212\":1}}],[\"匹配除了\",{\"1\":{\"212\":1}}],[\"匹配\",{\"1\":{\"212\":1}}],[\"匹配确定的\",{\"1\":{\"212\":1}}],[\"匹配前面的子表达式零次或一次\",{\"1\":{\"212\":1}}],[\"匹配前面的子表达式零次或多次\",{\"1\":{\"212\":1}}],[\"匹配前面的子表达式一次或多次\",{\"1\":{\"212\":1}}],[\"匹配成功返回true\",{\"1\":{\"212\":1}}],[\"限定符表如下\",{\"1\":{\"212\":1}}],[\"描述\",{\"1\":{\"212\":2}}],[\"描述了一种字符串匹配的模式\",{\"1\":{\"212\":1}}],[\"描述如下\",{\"1\":{\"13\":1}}],[\"行不行\",{\"1\":{\"211\":2}}],[\"做滴\",{\"1\":{\"211\":2}}],[\"做题我并不擅长\",{\"1\":{\"182\":1,\"184\":1}}],[\"汉堡\",{\"1\":{\"211\":2}}],[\"你看\",{\"1\":{\"211\":2}}],[\"删除2到4这个范围内的字符\",{\"1\":{\"211\":1}}],[\"弥补了字符串不能修改的不足\",{\"1\":{\"211\":1}}],[\"裁剪等操作\",{\"1\":{\"211\":1}}],[\"添加点内容的话\",{\"1\":{\"208\":1}}],[\"哥们在这跟你说唱\",{\"1\":{\"207\":1}}],[\"遍历打印数组中每一个元素\",{\"1\":{\"207\":1}}],[\"参数一样\",{\"1\":{\"225\":1}}],[\"参数直接写成lambda表达式\",{\"1\":{\"224\":1}}],[\"参数名称\",{\"1\":{\"207\":1,\"224\":1}}],[\"参数类型\",{\"1\":{\"207\":1,\"224\":1}}],[\"参数类型可能会多种多样\",{\"1\":{\"165\":1}}],[\"答案是可以的\",{\"1\":{\"206\":1}}],[\"7\",{\"1\":{\"205\":1,\"242\":1}}],[\"8\",{\"1\":{\"205\":1,\"242\":1}}],[\"允许\",{\"1\":{\"205\":1}}],[\"允许在任何地方被访问\",{\"1\":{\"174\":1}}],[\"性质\",{\"0\":{\"205\":1}}],[\"性别呢\",{\"1\":{\"166\":1}}],[\"性别\",{\"1\":{\"161\":1}}],[\"特性\",{\"0\":{\"204\":1}}],[\"特殊包装类\",{\"0\":{\"195\":1}}],[\"很遗憾\",{\"1\":{\"202\":1}}],[\"长度是在一开始创建数组的时候就确定好的\",{\"1\":{\"202\":1}}],[\"支持c语言样式\",{\"1\":{\"201\":1}}],[\"肯定是继承自object的\",{\"1\":{\"201\":1}}],[\"底层c++写的\",{\"1\":{\"201\":1}}],[\"底层是由c++实现的\",{\"1\":{\"181\":1}}],[\"面向对象高级篇\",{\"0\":{\"199\":1,\"216\":1,\"229\":1,\"239\":1}}],[\"面向对象高级篇1\",{\"0\":{\"191\":1}}],[\"精确到小数点后100位\",{\"1\":{\"195\":1}}],[\"浮点类型精度有限\",{\"1\":{\"195\":1}}],[\"乘法\",{\"1\":{\"195\":1}}],[\"轻轻松松\",{\"1\":{\"195\":1}}],[\"没错\",{\"1\":{\"225\":1}}],[\"没啥意义\",{\"1\":{\"195\":1}}],[\"没有方法体\",{\"1\":{\"184\":1}}],[\"没有返回值\",{\"1\":{\"162\":1}}],[\"6\",{\"0\":{\"239\":1},\"1\":{\"206\":1,\"242\":1}}],[\"666\",{\"1\":{\"194\":1}}],[\"6746\",{\"1\":{\"10\":1}}],[\"内存占用已经超出限制\",{\"1\":{\"231\":1}}],[\"内存也会消耗更多\",{\"1\":{\"193\":1}}],[\"内容\",{\"1\":{\"220\":1}}],[\"内部类静态方法\",{\"1\":{\"221\":2}}],[\"内部类初始化\",{\"1\":{\"221\":2}}],[\"内部类父类的tostring方法\",{\"1\":{\"218\":1}}],[\"内部类自己的tostring方法\",{\"1\":{\"218\":1}}],[\"内部类名称\",{\"1\":{\"218\":1}}],[\"内部类也是类\",{\"1\":{\"218\":1}}],[\"内部类顾名思义\",{\"1\":{\"217\":1}}],[\"内部类\",{\"0\":{\"215\":1,\"217\":1}}],[\"内部什么都没有\",{\"1\":{\"211\":1}}],[\"内嵌迭代算法求解\",{\"1\":{\"70\":1}}],[\"<\",{\"1\":{\"203\":1,\"241\":1}}],[\"<=\",{\"1\":{\"193\":1,\"212\":1}}],[\"<∞\",{\"1\":{\"98\":1}}],[\"虽然是继承于\",{\"1\":{\"202\":1}}],[\"虽然我们目前还没有学习数组\",{\"1\":{\"193\":1}}],[\"虽然a和b的值相同\",{\"1\":{\"193\":1}}],[\"虽然java语言是一个面向对象的语言\",{\"1\":{\"192\":1}}],[\"既然是在方法中声明的类\",{\"1\":{\"220\":1}}],[\"既然数组可以是任何类型的\",{\"1\":{\"206\":1}}],[\"既然能装箱\",{\"1\":{\"193\":1}}],[\"既然都有\",{\"1\":{\"185\":1}}],[\"覆盖原有构造方法\",{\"1\":{\"187\":1}}],[\"枚举的成员变量\",{\"1\":{\"187\":1}}],[\"枚举类型是普通的类\",{\"1\":{\"187\":1}}],[\"枚举类型使用起来就非常方便了\",{\"1\":{\"187\":1}}],[\"枚举类的语法稍微有一些不一样\",{\"1\":{\"187\":1}}],[\"枚举类\",{\"0\":{\"187\":1}}],[\"睡觉\",{\"1\":{\"187\":2}}],[\"睡觉这三个之中的其中一种\",{\"1\":{\"187\":1}}],[\"学习\",{\"1\":{\"187\":2}}],[\"学生\",{\"1\":{\"185\":1,\"186\":1}}],[\"学生和老师来说\",{\"1\":{\"185\":1}}],[\"全部拷贝为一个新的对象\",{\"1\":{\"186\":1}}],[\"深拷贝会将引用类型的所有内容\",{\"1\":{\"186\":1}}],[\"深拷贝\",{\"1\":{\"186\":1}}],[\"拷贝个基莫\",{\"1\":{\"186\":1}}],[\"浅拷贝\",{\"1\":{\"186\":1}}],[\"克隆实现\",{\"1\":{\"186\":1}}],[\"克隆操作可以完全复制一个对象的所有属性\",{\"1\":{\"186\":1}}],[\"克隆出来的与原来的对象不是一个对象\",{\"1\":{\"186\":1}}],[\"克隆方法\",{\"0\":{\"186\":1}}],[\"克隆当前对象\",{\"1\":{\"181\":1}}],[\"强制类型转换\",{\"1\":{\"185\":1}}],[\"强化学习\",{\"0\":{\"249\":1},\"2\":{\"22\":1,\"35\":1,\"51\":1,\"60\":1,\"74\":1,\"91\":1,\"108\":1,\"129\":1,\"146\":1,\"159\":1}}],[\"强化学习框架图\",{\"0\":{\"18\":1}}],[\"自定义运行时异常\",{\"1\":{\"232\":1}}],[\"自定义编译时异常\",{\"1\":{\"232\":1}}],[\"自定义异常\",{\"0\":{\"232\":1}}],[\"自动装箱|拆箱机制\",{\"1\":{\"195\":1}}],[\"自其他接口的\",{\"1\":{\"185\":1}}],[\"自我介绍需要用到当前对象的名字和年龄\",{\"1\":{\"162\":1}}],[\"自我介绍只需要完成就行\",{\"1\":{\"162\":1}}],[\"顶多说是多继承的一种替代方案\",{\"1\":{\"185\":1}}],[\"隔开即可\",{\"1\":{\"185\":1}}],[\"逗号\",{\"1\":{\"185\":1}}],[\"实现接口时\",{\"1\":{\"185\":1}}],[\"实现接口\",{\"1\":{\"185\":1}}],[\"实际上这里面就是方法体\",{\"1\":{\"224\":1}}],[\"实际上正则表达式内容非常多\",{\"1\":{\"212\":1}}],[\"实际上实现接口更像是一个类的功能列表\",{\"1\":{\"185\":1}}],[\"实际上接口的目标就是将类所具有某些的行为抽象出来\",{\"1\":{\"185\":1}}],[\"实际上main就是一个函数\",{\"1\":{\"162\":1}}],[\"实际不常用\",{\"1\":{\"68\":1}}],[\"实际意义的解释\",{\"1\":{\"48\":1}}],[\"实际意义是\",{\"1\":{\"48\":1}}],[\"相等于\",{\"1\":{\"212\":1}}],[\"相当于\",{\"1\":{\"185\":1}}],[\"相应的算法是\",{\"1\":{\"112\":1}}],[\"相应的\",{\"1\":{\"104\":1,\"110\":1}}],[\"他们都继承自\",{\"1\":{\"231\":1}}],[\"他们都具有学习这个能力\",{\"1\":{\"185\":1}}],[\"他们其实都是异常类型\",{\"1\":{\"231\":1}}],[\"他们可能会做不同的事情\",{\"1\":{\"173\":1}}],[\"他只代表某个确切的功能\",{\"1\":{\"185\":1}}],[\"大体内容其实普通类差不多\",{\"1\":{\"184\":1}}],[\"大数定理\",{\"1\":{\"75\":1}}],[\"抽象成接口来进行使用\",{\"1\":{\"185\":1}}],[\"抽象方法的访问权限不能为\",{\"1\":{\"184\":1}}],[\"抽象方法是指\",{\"1\":{\"184\":1}}],[\"抽象方法\",{\"1\":{\"184\":2}}],[\"抽象类中可以具有抽象方法\",{\"1\":{\"184\":1}}],[\"抽象类的子类也可以是一个抽象类\",{\"1\":{\"184\":1}}],[\"抽象类一般只用作继承使用\",{\"1\":{\"184\":1}}],[\"抽象类具有\",{\"1\":{\"184\":1}}],[\"抽象类\",{\"0\":{\"184\":1},\"1\":{\"184\":1}}],[\"上\",{\"1\":{\"183\":1}}],[\"上行\",{\"1\":{\"13\":1}}],[\"控制符\",{\"0\":{\"183\":1}}],[\"控制其一直待在target\",{\"1\":{\"19\":1}}],[\"调用\",{\"1\":{\"225\":1}}],[\"调用clone方法\",{\"1\":{\"186\":1}}],[\"调用父类的实现\",{\"1\":{\"182\":1}}],[\"调用类的静态方法\",{\"1\":{\"171\":1}}],[\"接口内部必须有且仅有一个抽象方法\",{\"1\":{\"224\":1}}],[\"接口也可以通过这种匿名内部类的形式\",{\"1\":{\"222\":1}}],[\"接口同样支持向下转型\",{\"1\":{\"185\":1}}],[\"接口跟抽象类一样\",{\"1\":{\"185\":1}}],[\"接口定义\",{\"1\":{\"185\":1}}],[\"接口的默认方法是保底的\",{\"1\":{\"185\":1}}],[\"接口的继承相当于是对接口功能的融合罢了\",{\"1\":{\"185\":1}}],[\"接口的使用和继承的概念有一定的出入\",{\"1\":{\"185\":1}}],[\"接口支持多继承\",{\"1\":{\"185\":1}}],[\"接口是可以继承\",{\"1\":{\"185\":1}}],[\"接口中可以存在让抽象方法的默认实现\",{\"1\":{\"185\":1}}],[\"接口中只能定义访问权限为public抽象方法\",{\"1\":{\"185\":1}}],[\"接口中如果定义了与\",{\"1\":{\"185\":1}}],[\"接口中定义的静态方法也只能是public的\",{\"1\":{\"185\":1}}],[\"接口中定义的静态变量只能是public\",{\"1\":{\"185\":1}}],[\"接口中不允许存在成员变量和成员方法\",{\"1\":{\"185\":1}}],[\"接口中的方法可以存在默认实现\",{\"1\":{\"185\":1}}],[\"接口不同于类\",{\"1\":{\"185\":1}}],[\"接口可以实现很多个\",{\"1\":{\"185\":1}}],[\"接口里只能定义对应的抽象方法\",{\"1\":{\"185\":1}}],[\"接口包含了一些列方法的定义\",{\"1\":{\"185\":1}}],[\"接口一般只代表某些功能的抽象\",{\"1\":{\"185\":1}}],[\"接口甚至比抽象类还抽象\",{\"1\":{\"185\":1}}],[\"接口\",{\"0\":{\"185\":1},\"1\":{\"185\":1,\"222\":1}}],[\"接着我们对三个属性挨个进行比较\",{\"1\":{\"182\":1}}],[\"接收端\",{\"1\":{\"10\":1}}],[\"先实现未实现的方法\",{\"1\":{\"222\":1}}],[\"先转换为当前类型\",{\"1\":{\"182\":1}}],[\"先根据当前策略计算出各个状态的\",{\"1\":{\"77\":1}}],[\"那作用范围也就只能在方法中了\",{\"1\":{\"220\":1}}],[\"那就是参数了\",{\"1\":{\"218\":1}}],[\"那肯定不相等\",{\"1\":{\"182\":1}}],[\"那么当发生这个异常时\",{\"1\":{\"234\":1}}],[\"那么所有在方法中可能会抛出的异常都需要注明\",{\"1\":{\"233\":1}}],[\"那么必须告知函数的调用方我们会抛出某个异常\",{\"1\":{\"233\":1}}],[\"那么使用时候\",{\"1\":{\"225\":1}}],[\"那么需要在前面添加外部类型名称\",{\"1\":{\"218\":1}}],[\"那么需要在前面添加外部类型名称test\",{\"1\":{\"218\":1}}],[\"那么如果内部类中也定义了同名的变量\",{\"1\":{\"218\":1}}],[\"那么就相当于到顶层了\",{\"1\":{\"234\":1}}],[\"那么就是b的\",{\"1\":{\"218\":1}}],[\"那么就是a的\",{\"1\":{\"218\":1}}],[\"那么就是不同的对象了\",{\"1\":{\"210\":1}}],[\"那么就像我们把成员变量访问权限变成私有一样\",{\"1\":{\"218\":1}}],[\"那么就需要创造一个对象\",{\"1\":{\"218\":1}}],[\"那么中间就需要产生4个字符串对象出来\",{\"1\":{\"211\":1}}],[\"那么始终都是同一个对象\",{\"1\":{\"210\":1}}],[\"那么始终都会得到同一个对象\",{\"1\":{\"193\":1}}],[\"那么可以省去小括号\",{\"1\":{\"224\":1}}],[\"那么可以使用this关键字\",{\"1\":{\"164\":1}}],[\"那么可变长参数只能放在最后\",{\"1\":{\"207\":1}}],[\"那么会直接返回已经提前创建好的对象\",{\"1\":{\"193\":1}}],[\"那么自动装箱的呢\",{\"1\":{\"193\":1}}],[\"那么是不相等的\",{\"1\":{\"193\":1}}],[\"那么实现类中不强制要求进行实现\",{\"1\":{\"185\":1}}],[\"那么实际上只是传递了对象的引用\",{\"1\":{\"161\":1}}],[\"那么还有什么意义呢\",{\"1\":{\"184\":1}}],[\"那么无法重写\",{\"1\":{\"182\":1}}],[\"那么同样可以使用\",{\"1\":{\"182\":1}}],[\"那么我们能否创建数组类型的数组呢\",{\"1\":{\"206\":1}}],[\"那么我们也可以给枚举类型添加独有的成员方法\",{\"1\":{\"187\":1}}],[\"那么我们就可以将学习这个能力\",{\"1\":{\"185\":1}}],[\"那么我们就可以将其重写了\",{\"1\":{\"182\":1}}],[\"那么我们可以继续踢皮球\",{\"1\":{\"234\":1}}],[\"那么我们可以将匿名内部类简写为lambda表达式\",{\"1\":{\"224\":1}}],[\"那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用\",{\"1\":{\"174\":1}}],[\"那么我们可以对\",{\"1\":{\"78\":1}}],[\"那么此时就出现了歧义\",{\"1\":{\"173\":1}}],[\"那么此时的\",{\"1\":{\"135\":1}}],[\"那么这些类如果都放在一起的话\",{\"1\":{\"173\":1}}],[\"那么这称为\",{\"1\":{\"84\":1}}],[\"那么其他的对象读取的就是被改变的值\",{\"1\":{\"170\":1}}],[\"那么通过这个类创建的所有对象\",{\"1\":{\"170\":1}}],[\"那么能否实现在对象创建时就为其指定名字\",{\"1\":{\"166\":1}}],[\"那么默认情况下可以不使用this关键字来明确表示当前对象\",{\"1\":{\"164\":1}}],[\"那么默认是null\",{\"1\":{\"161\":1}}],[\"那么默认是统一为0\",{\"1\":{\"161\":1}}],[\"那么创建对象之后能否直接访问呢\",{\"1\":{\"161\":1}}],[\"那么对象构造好之后\",{\"1\":{\"166\":1}}],[\"那么对象的属性都会存在初始值\",{\"1\":{\"161\":1}}],[\"那么对应的损失函数求解为\",{\"1\":{\"142\":1}}],[\"那么对于随机变量x的估计可以为\",{\"1\":{\"75\":1}}],[\"那么只要求解\",{\"1\":{\"99\":1}}],[\"那么\",{\"1\":{\"68\":1,\"94\":1,\"98\":1}}],[\"垃圾\",{\"1\":{\"181\":1}}],[\"唤醒所有等待当前对象锁的线程\",{\"1\":{\"181\":1}}],[\"唤醒一个等待当前对象锁的线程\",{\"1\":{\"181\":1}}],[\"十六进制哈希值\",{\"1\":{\"181\":1}}],[\"完整类名\",{\"1\":{\"181\":1}}],[\"完成自我介绍需要执行的所有代码就在这个花括号中编写\",{\"1\":{\"162\":1}}],[\"判断当前对象和给定对象是否相等\",{\"1\":{\"181\":1}}],[\">=\",{\"1\":{\"193\":1}}],[\">\",{\"1\":{\"181\":1,\"193\":8,\"224\":7,\"225\":2,\"235\":1}}],[\"获取异常的错误信息\",{\"1\":{\"234\":1}}],[\"获取长度\",{\"1\":{\"210\":1}}],[\"获取封装的成员变量\",{\"1\":{\"187\":1}}],[\"获取对象的哈希值\",{\"1\":{\"181\":1}}],[\"获取当前的类型class对象\",{\"1\":{\"181\":1}}],[\"获得reward\",{\"1\":{\"20\":1}}],[\"本质就是调用的构造方法\",{\"1\":{\"187\":1}}],[\"本地方法不是我们se中需要学习的内容\",{\"1\":{\"181\":1}}],[\"本文目的是优化无人机在每个时隙的位置\",{\"1\":{\"11\":1}}],[\"正常情况下是不会出错的\",{\"1\":{\"231\":1}}],[\"正常情况下\",{\"1\":{\"222\":1}}],[\"正常实例化方法是无法创造抽象类的实例\",{\"1\":{\"184\":1}}],[\"正好可以匹配\",{\"1\":{\"212\":1}}],[\"正则表达式并不是只有java才支持\",{\"1\":{\"212\":1}}],[\"正则表达式\",{\"0\":{\"198\":1,\"212\":1},\"1\":{\"212\":2}}],[\"正是这三大特性\",{\"1\":{\"178\":1}}],[\"正确性和收敛性分析\",{\"0\":{\"104\":1}}],[\"多个异常使用逗号隔开\",{\"1\":{\"233\":1}}],[\"多个不同的对象对同一消息作出响应\",{\"1\":{\"178\":1}}],[\"多维数组\",{\"0\":{\"206\":1},\"1\":{\"242\":1}}],[\"多态\",{\"1\":{\"178\":1}}],[\"叫子类\",{\"1\":{\"178\":1}}],[\"隐藏实现细节\",{\"1\":{\"178\":1}}],[\"隐式加载\",{\"1\":{\"171\":1}}],[\"封装成一个类\",{\"1\":{\"193\":1}}],[\"封装\",{\"0\":{\"178\":1,\"179\":1},\"1\":{\"178\":2}}],[\"❌\",{\"1\":{\"174\":6}}],[\"✅\",{\"1\":{\"174\":10}}],[\"公共\",{\"1\":{\"174\":1}}],[\"子类也可以定义\",{\"1\":{\"184\":1}}],[\"子类对应必须是\",{\"1\":{\"184\":1}}],[\"子类必须要实现抽象类所有的抽象方法\",{\"1\":{\"184\":1}}],[\"子类\",{\"1\":{\"184\":1}}],[\"子类是\",{\"1\":{\"180\":1}}],[\"子类实现了父类所有非私有化的属性和方法\",{\"1\":{\"178\":1}}],[\"子类我们会在下一章介绍\",{\"1\":{\"174\":1}}],[\"子类初始化时\",{\"1\":{\"171\":1}}],[\"受保护\",{\"1\":{\"174\":1}}],[\"什么都不写\",{\"1\":{\"174\":1}}],[\"什么时候更新策略也是一个影响效率的因素\",{\"1\":{\"82\":1}}],[\"私有\",{\"1\":{\"174\":1}}],[\"主方法的string参数是java\",{\"1\":{\"173\":1}}],[\"主要框架\",{\"1\":{\"18\":1}}],[\"主要内容\",{\"0\":{\"6\":1}}],[\"主要贡献\",{\"0\":{\"5\":1}}],[\"主要动机\",{\"0\":{\"4\":1}}],[\"编译时异常的子类有很多很多\",{\"1\":{\"232\":1}}],[\"编译时异常只需要继承\",{\"1\":{\"232\":1}}],[\"编译时异常明确指出可能会出现的异常\",{\"1\":{\"231\":1}}],[\"编译时异常\",{\"1\":{\"231\":1}}],[\"编译器是很聪明的\",{\"1\":{\"211\":1}}],[\"编译器不知道到底我们想用的是哪一个string类\",{\"1\":{\"173\":1}}],[\"编译出来就自带\",{\"1\":{\"166\":1}}],[\"使用运行时异常同样可以捕获到\",{\"1\":{\"234\":1}}],[\"使用\",{\"1\":{\"234\":1}}],[\"使用throws关键字告知调用方此方法会抛出哪些异常\",{\"1\":{\"233\":1}}],[\"使用throw关键字来抛出异常\",{\"1\":{\"233\":1}}],[\"使用new表示\",{\"1\":{\"225\":1}}],[\"使用双冒号来进行方法引用\",{\"1\":{\"225\":1}}],[\"使用外部静态变量\",{\"1\":{\"221\":1}}],[\"使用频率很低\",{\"1\":{\"220\":1}}],[\"使用split方法进行字符串分割\",{\"1\":{\"210\":1}}],[\"使用就像对象的参数一样\",{\"1\":{\"187\":1}}],[\"使用枚举类也非常方便\",{\"1\":{\"187\":1}}],[\"使用default关键字为接口中的方法添加默认实现\",{\"1\":{\"185\":1}}],[\"使用implements关键字来实现接口\",{\"1\":{\"185\":1}}],[\"使用import关键字导入其他包中的类\",{\"1\":{\"173\":1}}],[\"使用interface表示这是一个接口\",{\"1\":{\"185\":1}}],[\"使得java能够更好的体现面向对象的思想\",{\"1\":{\"192\":1}}],[\"使得持有当前对象锁的线程进入等待状态\",{\"1\":{\"181\":1}}],[\"使得v^\",{\"1\":{\"132\":1}}],[\"导入我们需要使用的类\",{\"1\":{\"173\":1}}],[\"比如是因为什么原因导致的异常\",{\"1\":{\"233\":1}}],[\"比如\",{\"1\":{\"231\":1}}],[\"比如object类中定义的clone方法\",{\"1\":{\"231\":1}}],[\"比如数组越界异常\",{\"1\":{\"231\":1}}],[\"比如这里就是通过空格分隔\",{\"1\":{\"210\":1}}],[\"比如字符串的裁剪\",{\"1\":{\"210\":1}}],[\"比如说\",{\"1\":{\"185\":1}}],[\"比如com\",{\"1\":{\"173\":1}}],[\"比如我们想要打印数组\",{\"1\":{\"242\":1}}],[\"比如我们可以判断变量的值\",{\"1\":{\"235\":1}}],[\"比如我们现在不希望使用object类中提供的equals方法\",{\"1\":{\"182\":1}}],[\"比如我们经常访问的\",{\"1\":{\"173\":1}}],[\"比如我们要估计某个随机变量x的\",{\"1\":{\"99\":1}}],[\"包括返回值\",{\"1\":{\"224\":1}}],[\"包括对方法的调用和super关键字的使用\",{\"1\":{\"218\":1}}],[\"包括对象内部的所有成员变量\",{\"1\":{\"186\":1}}],[\"包括对象的各个属性\",{\"1\":{\"181\":1}}],[\"包括换行\",{\"1\":{\"212\":1}}],[\"包括引用类型和基本类型\",{\"1\":{\"200\":1}}],[\"包装类支持字符串直接转换\",{\"1\":{\"194\":1}}],[\"包装类的方法\",{\"0\":{\"194\":1}}],[\"包装类型支持自动装箱\",{\"1\":{\"193\":1}}],[\"包装类型的自动装箱和拆箱机制\",{\"1\":{\"193\":1}}],[\"包装类实际上就是将我们的基本数据类型\",{\"1\":{\"193\":1}}],[\"包其实就是用来区分类位置的东西\",{\"1\":{\"173\":1}}],[\"包的命名规则同样是英文和数字的组合\",{\"1\":{\"173\":1}}],[\"包的声明和导入\",{\"0\":{\"173\":1}}],[\"包的访问与控制\",{\"0\":{\"172\":1}}],[\"创建random对象\",{\"1\":{\"241\":1}}],[\"创建出来的数组每个位置上都有默认值\",{\"1\":{\"201\":1}}],[\"创建对象越多\",{\"1\":{\"193\":1}}],[\"创建枚举需要添加参数\",{\"1\":{\"187\":1}}],[\"创建类的实例\",{\"1\":{\"171\":1}}],[\"创建一个变量指代我们刚刚创建好的对象\",{\"1\":{\"161\":1}}],[\"文件其实就是我们编写的一个类\",{\"1\":{\"171\":1}}],[\"文件丢给\",{\"1\":{\"171\":1}}],[\"去执行的\",{\"1\":{\"171\":1}}],[\"操作的都是同一个目标\",{\"1\":{\"170\":1}}],[\"静态内部类编译特性\",{\"0\":{\"221\":1}}],[\"静态内部类由于是静态的\",{\"1\":{\"219\":1}}],[\"静态内部类的类名同样是之前的格式\",{\"1\":{\"219\":1}}],[\"静态内部类就像静态方法和静态变量一样\",{\"1\":{\"219\":1}}],[\"静态内部类\",{\"0\":{\"219\":1}}],[\"静态\",{\"1\":{\"216\":1}}],[\"静态初始化\",{\"1\":{\"201\":1}}],[\"静态导入test方法\",{\"1\":{\"174\":1}}],[\"静态导入\",{\"1\":{\"174\":1}}],[\"静态方法使用\",{\"1\":{\"225\":1}}],[\"静态方法甚至是类指定访问权限\",{\"1\":{\"174\":1}}],[\"静态方法同样是属于类的\",{\"1\":{\"170\":1}}],[\"静态变量\",{\"1\":{\"174\":1}}],[\"静态变量初始化\",{\"0\":{\"171\":1}}],[\"静态变量和静态方法\",{\"0\":{\"170\":1}}],[\"静态的内容\",{\"1\":{\"170\":1}}],[\"静止\",{\"1\":{\"13\":1}}],[\"成员变量一样\",{\"1\":{\"218\":1}}],[\"成员变量的初始化\",{\"1\":{\"166\":1}}],[\"成员内部类的name\",{\"1\":{\"218\":2}}],[\"成员内部类的类型名称就是\",{\"1\":{\"218\":1}}],[\"成员内部类可以访问到外部的成员变量\",{\"1\":{\"218\":1}}],[\"成员内部类也可以使用访问权限控制\",{\"1\":{\"218\":1}}],[\"成员内部类和成员方法\",{\"1\":{\"218\":1}}],[\"成员内部类其实在某些情况下使用起来比较麻烦\",{\"1\":{\"218\":1}}],[\"成员内部类\",{\"0\":{\"218\":1}}],[\"成员\",{\"1\":{\"216\":1}}],[\"成员方法因为需要具体对象使用\",{\"1\":{\"225\":1}}],[\"成员方法只能通过\",{\"1\":{\"225\":1}}],[\"成员方法中不能用\",{\"1\":{\"182\":1}}],[\"成员方法\",{\"1\":{\"174\":1}}],[\"成比例等于\",{\"1\":{\"155\":1}}],[\"必须要进行异常的捕获\",{\"1\":{\"234\":1}}],[\"必须要考虑到出现异常的情况\",{\"1\":{\"231\":1}}],[\"必须要实现抽象类中所有抽象方法\",{\"1\":{\"184\":1}}],[\"必须留一个抽象方法出来\",{\"1\":{\"224\":1}}],[\"必须使用equals方法\",{\"1\":{\"182\":1}}],[\"必须调用我们自己定义的构造方法\",{\"1\":{\"166\":1}}],[\"必须是递增的\",{\"1\":{\"98\":1}}],[\"除非抛出的异常是一个运行时异常\",{\"1\":{\"234\":1}}],[\"除非我们手动重载一个无参构造\",{\"1\":{\"166\":1}}],[\"除了clone\",{\"1\":{\"202\":1}}],[\"除了需要求解\",{\"1\":{\"55\":1}}],[\"注解\",{\"1\":{\"182\":1}}],[\"注意只是相当于外部来说\",{\"1\":{\"219\":1}}],[\"注意\",{\"1\":{\"166\":1,\"173\":1,\"207\":1,\"209\":1,\"218\":1,\"233\":1,\"234\":2}}],[\"注重近期的reward\",{\"1\":{\"19\":1}}],[\"跟对象成员变量的默认值是一样的\",{\"1\":{\"201\":1}}],[\"跟普通的类一样\",{\"1\":{\"185\":1}}],[\"跟普通方法是一样的\",{\"1\":{\"166\":1}}],[\"跟随一个\",{\"1\":{\"154\":1}}],[\"跟随策略π\",{\"1\":{\"81\":1}}],[\"男\",{\"1\":{\"166\":2,\"182\":4,\"185\":1,\"186\":1,\"187\":1}}],[\"默认会让整个程序终止并打印栈追踪信息\",{\"1\":{\"234\":1}}],[\"默认会交给\",{\"1\":{\"234\":1}}],[\"默认继承自\",{\"1\":{\"231\":1}}],[\"默认private\",{\"1\":{\"187\":1}}],[\"默认实现是直接用等号判断\",{\"1\":{\"181\":1}}],[\"默认的情况下\",{\"1\":{\"174\":1}}],[\"默认\",{\"1\":{\"174\":2}}],[\"默认情况下直接运行什么都没有\",{\"1\":{\"208\":1}}],[\"默认情况下格式为\",{\"1\":{\"181\":1}}],[\"默认情况下\",{\"1\":{\"174\":1}}],[\"默认情况下包名是可以省略的\",{\"1\":{\"173\":1}}],[\"默认情况下每个类都会自带一个没有任何参数的无参构造方法\",{\"1\":{\"166\":1}}],[\"默认值为false\",{\"1\":{\"161\":1}}],[\"构造函数也不能赋值\",{\"1\":{\"183\":1}}],[\"构造器\",{\"1\":{\"166\":1}}],[\"构造方法也可以被引用\",{\"1\":{\"225\":1}}],[\"构造方法会在new的时候自动执行\",{\"1\":{\"166\":1}}],[\"构造方法会在对象创建时执行\",{\"1\":{\"166\":1}}],[\"构造方法不需要指定返回值\",{\"1\":{\"166\":1}}],[\"构造方法不需要填写返回值\",{\"1\":{\"166\":1}}],[\"构造方法\",{\"0\":{\"166\":1},\"1\":{\"166\":1}}],[\"各种属性都是默认值\",{\"1\":{\"166\":1}}],[\"优先使用作用域最接近的\",{\"1\":{\"164\":1}}],[\"优化\",{\"1\":{\"171\":1}}],[\"优化方法\",{\"0\":{\"142\":1}}],[\"优化算法\",{\"0\":{\"136\":1}}],[\"优化目标函数的算法\",{\"1\":{\"132\":1}}],[\"优化问题\",{\"1\":{\"103\":1}}],[\"优化问题建立\",{\"0\":{\"11\":1}}],[\"出现重名时\",{\"1\":{\"164\":1}}],[\"出发的\",{\"1\":{\"82\":1,\"137\":1}}],[\"出发\",{\"1\":{\"78\":2,\"84\":1}}],[\"运行时异常只需要继承\",{\"1\":{\"232\":1}}],[\"运行时异常\",{\"1\":{\"231\":1}}],[\"运用了封装的思想\",{\"1\":{\"193\":1}}],[\"运用到\",{\"1\":{\"29\":1}}],[\"运算符\",{\"1\":{\"162\":1}}],[\"小王\",{\"1\":{\"185\":1}}],[\"小明\",{\"1\":{\"162\":1,\"166\":1,\"182\":4,\"186\":1,\"187\":1,\"218\":1}}],[\"小红\",{\"1\":{\"161\":1,\"218\":1}}],[\"岁了\",{\"1\":{\"162\":1}}],[\"果直接创建对象\",{\"1\":{\"161\":1}}],[\"变量名称\",{\"1\":{\"201\":4}}],[\"变量的值就是当前对象的存放值\",{\"1\":{\"162\":1}}],[\"变量的类型就是对应的类名\",{\"1\":{\"161\":1}}],[\"变量使用之前需要先赋值\",{\"1\":{\"161\":1}}],[\"它是运行时异常的子类\",{\"1\":{\"234\":1}}],[\"它是局部内部类的简化版\",{\"1\":{\"222\":1}}],[\"它就像一个字符串编辑器\",{\"1\":{\"211\":1}}],[\"它用于保存字符串\",{\"1\":{\"209\":1}}],[\"它本身也是类\",{\"1\":{\"201\":1}}],[\"它的属性没有进行赋值\",{\"1\":{\"161\":1}}],[\"它会在\",{\"1\":{\"82\":1}}],[\"我会学习\",{\"1\":{\"185\":1,\"186\":1}}],[\"我是编译时异常\",{\"1\":{\"233\":1}}],[\"我是学习方法\",{\"1\":{\"224\":2}}],[\"我是匿名内部类的实现\",{\"1\":{\"222\":1}}],[\"我是局部内部类\",{\"1\":{\"220\":1}}],[\"我是静态内部类\",{\"1\":{\"219\":1}}],[\"我是静态方法\",{\"1\":{\"170\":1,\"174\":1}}],[\"我是成员内部类\",{\"1\":{\"218\":2}}],[\"我是默认实现\",{\"1\":{\"185\":1}}],[\"我是工人\",{\"1\":{\"182\":1,\"184\":1}}],[\"我是代码块\",{\"1\":{\"166\":1}}],[\"我被构造了\",{\"1\":{\"166\":1}}],[\"我叫\",{\"1\":{\"162\":1}}],[\"我任性\",{\"1\":{\"161\":1}}],[\"我们希望能够分不同情况处理不同类型的异常\",{\"1\":{\"234\":1}}],[\"我们抛出异常实际上就是将这个异常对象抛出\",{\"1\":{\"233\":1}}],[\"我们自定义异常也是从这两类中进行选择\",{\"1\":{\"232\":1}}],[\"我们同样需要使用对象来进行方法引用\",{\"1\":{\"225\":1}}],[\"我们还可以使用方法引用\",{\"1\":{\"224\":1}}],[\"我们还需要理解其所描述的最优策略π∗\",{\"1\":{\"56\":1}}],[\"我们首先需要创建对象\",{\"1\":{\"218\":1}}],[\"我们一般只会在类的内部自己使用\",{\"1\":{\"218\":1}}],[\"我们一般称为限定符\",{\"1\":{\"212\":1}}],[\"我们知道\",{\"1\":{\"209\":1}}],[\"我们要创建一个数组\",{\"1\":{\"201\":1}}],[\"我们如果直接让\",{\"1\":{\"193\":1}}],[\"我们如果想要在方法中访问到当前对象的属性\",{\"1\":{\"164\":1}}],[\"我们发现\",{\"1\":{\"193\":1}}],[\"我们直接调用父类的实现就可以了\",{\"1\":{\"186\":1}}],[\"我们直接使用成员变量即可\",{\"1\":{\"162\":1}}],[\"我们会在第六章多线程部分中讲解\",{\"1\":{\"181\":1}}],[\"我们会在第五章集合类中使用到\",{\"1\":{\"181\":1}}],[\"我们会在jvm篇视频教程中进行介绍\",{\"1\":{\"181\":1}}],[\"我们之前都是直接创建的类\",{\"1\":{\"173\":1}}],[\"我们的每一个异常也是一个类\",{\"1\":{\"231\":1}}],[\"我们的包就可以命名为com\",{\"1\":{\"173\":1}}],[\"我们的方法需要能够同时应对多种情况\",{\"1\":{\"165\":1}}],[\"我们在重写方法时\",{\"1\":{\"233\":1}}],[\"我们在重写父类方法时\",{\"1\":{\"182\":1}}],[\"我们在之前其实已经接触过一些异常了\",{\"1\":{\"231\":1}}],[\"我们在自己的包中也建一个名为string的类\",{\"1\":{\"173\":1}}],[\"我们在\",{\"1\":{\"171\":1}}],[\"我们实际上是将\",{\"1\":{\"171\":1}}],[\"我们并不会通过一个具体的对象去修改和使用静态属性\",{\"1\":{\"170\":1}}],[\"我们通过使用\",{\"1\":{\"170\":1}}],[\"我们通常将\",{\"1\":{\"27\":1}}],[\"我们前面创建对象\",{\"1\":{\"166\":1}}],[\"我们也可以在类中添加代码块\",{\"1\":{\"166\":1}}],[\"我们也可以为构造方法设定参数\",{\"1\":{\"166\":1}}],[\"我们也可以手动声明\",{\"1\":{\"166\":1}}],[\"我们也可以不对任何对象进行引用\",{\"1\":{\"161\":1}}],[\"我们也可以进行近似\",{\"1\":{\"156\":1}}],[\"我们便称为\",{\"1\":{\"156\":1}}],[\"我们定义的每一个状态其实就是一个public\",{\"1\":{\"187\":1}}],[\"我们定义\",{\"1\":{\"148\":1}}],[\"我们定义最优的策略为\",{\"1\":{\"148\":1}}],[\"我们先直接求解\",{\"1\":{\"142\":1}}],[\"我们将类放到包中\",{\"1\":{\"173\":1}}],[\"我们将变量p2赋值为p1的值\",{\"1\":{\"161\":1}}],[\"我们将\",{\"1\":{\"138\":1}}],[\"我们是无法估计的\",{\"1\":{\"136\":1}}],[\"我们是引入了\",{\"1\":{\"105\":1}}],[\"我们就可以使用biginteger来完成\",{\"1\":{\"195\":1}}],[\"我们就可以通过\",{\"1\":{\"104\":1}}],[\"我们就可以得到\",{\"1\":{\"99\":1}}],[\"我们很难直接获得\",{\"1\":{\"101\":1}}],[\"我们有以下几种方法\",{\"1\":{\"101\":1}}],[\"我们得到的观测值是\",{\"1\":{\"99\":1}}],[\"我们只能去创建它的子类对象\",{\"1\":{\"184\":1}}],[\"我们只能通过\",{\"1\":{\"97\":1}}],[\"我们只需要在类名前面把完整的包名也给写上\",{\"1\":{\"173\":1}}],[\"我们只需要在当前状态下\",{\"1\":{\"57\":1}}],[\"我们只需要使用\",{\"1\":{\"162\":1}}],[\"我们只需要挑选在当前迭代下最大的\",{\"1\":{\"63\":1}}],[\"我们采用的是\",{\"1\":{\"87\":1}}],[\"我们不仅可以通过构造方法\",{\"1\":{\"166\":1}}],[\"我们不仅可以用来估计q\",{\"1\":{\"81\":1}}],[\"我们不断地与环境进行交互\",{\"1\":{\"135\":1}}],[\"我们不能直接得到随机变量的值\",{\"1\":{\"99\":1}}],[\"我们不能通过之前的方法来求出q\",{\"1\":{\"77\":1}}],[\"我们选取其\",{\"1\":{\"79\":1}}],[\"我们仍需要估计\",{\"1\":{\"79\":1}}],[\"我们这里强行初始化为vπ0​​\",{\"1\":{\"70\":1}}],[\"我们需要在虚拟机参数中手动开启一下\",{\"1\":{\"235\":1}}],[\"我们需要明确指定一下\",{\"1\":{\"173\":1}}],[\"我们需要从经验池\",{\"1\":{\"142\":1}}],[\"我们需要思考使用\",{\"1\":{\"104\":1}}],[\"我们需要保证策略是不断提升\",{\"1\":{\"68\":1}}],[\"我们需要找到一个\",{\"1\":{\"26\":1}}],[\"我们可以下面的方式实现多种字符匹配\",{\"1\":{\"212\":1}}],[\"我们可以让他等于一个非常大的数字\",{\"1\":{\"195\":1}}],[\"我们可以直接创建静态内部类的对象\",{\"1\":{\"219\":1}}],[\"我们可以直接在类的内部定义成员内部类\",{\"1\":{\"218\":1}}],[\"我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值\",{\"1\":{\"193\":1}}],[\"我们可以直接通过接口名\",{\"1\":{\"185\":1}}],[\"我们可以为成员变量\",{\"1\":{\"174\":1}}],[\"我们可以理解为是属于这个类的\",{\"1\":{\"170\":1}}],[\"我们可以使用pow方法直接计算a的b次方\",{\"1\":{\"241\":1}}],[\"我们可以使用断言表达式来对某些东西进行判断\",{\"1\":{\"235\":1}}],[\"我们可以使用append方法来讲字符串拼接到后面\",{\"1\":{\"211\":1}}],[\"我们可以使用它来对字符串进行拼接\",{\"1\":{\"211\":1}}],[\"我们可以使用\",{\"1\":{\"166\":1,\"173\":1}}],[\"我们可以进行一次重载\",{\"1\":{\"165\":1}}],[\"我们可以认为\",{\"1\":{\"150\":1}}],[\"我们可以写出\",{\"1\":{\"113\":1}}],[\"我们可以将方法标记为静态\",{\"1\":{\"170\":1}}],[\"我们可以将各种需要初始化的操作都在这里进行处理\",{\"1\":{\"166\":1}}],[\"我们可以将该问题定义为一个\",{\"1\":{\"110\":1}}],[\"我们可以将这个问题可以转化为一个随机变量的方法\",{\"1\":{\"105\":1}}],[\"我们可以将\",{\"1\":{\"101\":1,\"103\":1,\"104\":1}}],[\"我们可以修改为噪音\",{\"1\":{\"99\":1}}],[\"我们可以设计如下方程\",{\"1\":{\"99\":1}}],[\"我们可以确保其可以遍历所有的\",{\"1\":{\"86\":1}}],[\"我们可以生成一个\",{\"1\":{\"78\":1}}],[\"我们可以通过类名直接使用\",{\"1\":{\"239\":1}}],[\"我们可以通过包的形式将这些类进行分类存放\",{\"1\":{\"173\":1}}],[\"我们可以通过对象的引用来间接操作对象\",{\"1\":{\"161\":1}}],[\"我们可以通过对应的迭代算法来求解贝尔曼最优公式\",{\"1\":{\"62\":1}}],[\"我们可以通过一些特定的算法进行求解\",{\"1\":{\"96\":1}}],[\"我们可以通过前面所引入的\",{\"1\":{\"77\":1}}],[\"我们可以很轻松的求出各个情况下的q\",{\"1\":{\"77\":1}}],[\"我们可以分析出在该状态下采取哪个\",{\"1\":{\"48\":1}}],[\"我们对无人机的发射功率有一个约束\",{\"1\":{\"9\":1}}],[\"关键字\",{\"1\":{\"182\":1,\"201\":1}}],[\"关键字来声明一个变量或一个方法为静态的\",{\"1\":{\"170\":1}}],[\"关键元素\",{\"1\":{\"20\":1}}],[\"关于对象类型的变量\",{\"1\":{\"161\":1}}],[\"修改一个对象的属性并不会影响到其他对象\",{\"1\":{\"161\":1}}],[\"修改对象的属性\",{\"1\":{\"161\":1}}],[\"修改为\",{\"1\":{\"142\":1}}],[\"访问第三行第二列的元素\",{\"1\":{\"206\":1}}],[\"访问元素\",{\"0\":{\"203\":1}}],[\"访问权限控制\",{\"0\":{\"174\":1}}],[\"访问类的静态变量\",{\"1\":{\"171\":1}}],[\"访问\",{\"1\":{\"161\":1}}],[\"年龄\",{\"1\":{\"161\":1,\"166\":1}}],[\"名字\",{\"1\":{\"161\":1}}],[\"概念上的定义\",{\"1\":{\"161\":1}}],[\"概率分布\",{\"1\":{\"150\":1}}],[\"类名\",{\"1\":{\"225\":3}}],[\"类名的首字母通常是大写的\",{\"1\":{\"161\":1}}],[\"类似\",{\"1\":{\"222\":1}}],[\"类似于一个插件\",{\"1\":{\"185\":1}}],[\"类似于c++中的namespace\",{\"1\":{\"173\":1}}],[\"类似于c++指针的情况\",{\"1\":{\"161\":1}}],[\"类的异常都是编译时异常\",{\"1\":{\"231\":1}}],[\"类的内部类它会单独生成一个\",{\"1\":{\"221\":1}}],[\"类的创建\",{\"1\":{\"161\":1}}],[\"类型的\",{\"1\":{\"207\":1}}],[\"类型\",{\"1\":{\"201\":8}}],[\"类只能继承一个\",{\"1\":{\"185\":1}}],[\"类可以实现这个接口\",{\"1\":{\"185\":1}}],[\"类除了具有属性外\",{\"1\":{\"162\":1}}],[\"类\",{\"0\":{\"181\":1,\"210\":1,\"211\":1,\"219\":1},\"1\":{\"161\":1,\"183\":1,\"216\":1,\"231\":1,\"241\":1}}],[\"类与对象4\",{\"0\":{\"190\":1}}],[\"类与对象3\",{\"0\":{\"177\":1}}],[\"类与对象2\",{\"0\":{\"169\":1}}],[\"类与对象\",{\"0\":{\"161\":1}}],[\"类与对象1\",{\"0\":{\"160\":1}}],[\"梯度上升算法的本质就是最大化目标函数\",{\"1\":{\"156\":1}}],[\"梯度上升算法\",{\"0\":{\"156\":1}}],[\"梯度下降\",{\"1\":{\"136\":1}}],[\"梯度下降法\",{\"1\":{\"101\":1}}],[\"近似\",{\"1\":{\"155\":1}}],[\"严格等于\",{\"1\":{\"155\":1}}],[\"时\",{\"1\":{\"181\":1}}],[\"时的平均reward\",{\"1\":{\"153\":1}}],[\"时wk​→w∗\",{\"1\":{\"104\":1}}],[\"确定\",{\"1\":{\"148\":1}}],[\"确保根是存在且唯一的\",{\"1\":{\"98\":1}}],[\"经验回放\",{\"0\":{\"143\":1}}],[\"网络的输入包括\",{\"1\":{\"142\":1}}],[\"然后创建子类对象\",{\"1\":{\"222\":1}}],[\"然后生成了一个\",{\"1\":{\"154\":1}}],[\"然后我们通过\",{\"1\":{\"142\":1}}],[\"然后在更新了一定次数之后\",{\"1\":{\"142\":1}}],[\"然后进行迭代\",{\"1\":{\"79\":1}}],[\"然后进行不断迭代\",{\"1\":{\"47\":1}}],[\"复制到\",{\"1\":{\"142\":1}}],[\"尝试将\",{\"1\":{\"142\":1}}],[\"固定不动\",{\"1\":{\"142\":1}}],[\"固定\",{\"1\":{\"142\":1}}],[\"目前各位小伙伴就暂时理解为会返回对象存放的内存地址\",{\"1\":{\"181\":1}}],[\"目前暂时不会用到\",{\"1\":{\"181\":3}}],[\"目前的优化算法只是在估计给定策略的\",{\"1\":{\"136\":1}}],[\"目的是最小化目标函数\",{\"1\":{\"141\":1}}],[\"目标函数梯度求解\",{\"0\":{\"155\":1}}],[\"目标函数定义\",{\"0\":{\"149\":1}}],[\"目标\",{\"1\":{\"132\":1}}],[\"目标是获得无人机的最佳3d位置\",{\"1\":{\"13\":1}}],[\"≥0\",{\"1\":{\"135\":1,\"150\":1,\"155\":1}}],[\"≥vπ​\",{\"1\":{\"53\":1}}],[\"下划线\",{\"1\":{\"212\":1}}],[\"下的\",{\"1\":{\"135\":1,\"152\":1}}],[\"下行\",{\"1\":{\"13\":1}}],[\"认为所有状态都是同等重要的\",{\"1\":{\"134\":1}}],[\"寻找一个最优的参数w\",{\"1\":{\"132\":1}}],[\"版本\",{\"0\":{\"125\":1,\"126\":1}}],[\"|\",{\"0\":{\"121\":1,\"198\":2},\"1\":{\"234\":2,\"242\":3}}],[\"形式下的贝尔曼最优公式\",{\"1\":{\"119\":1}}],[\"称为\",{\"1\":{\"113\":1}}],[\"称为策略评估\",{\"1\":{\"45\":1}}],[\"≐e\",{\"1\":{\"155\":1}}],[\"≐g\",{\"1\":{\"110\":1}}],[\"≐w−x\",{\"1\":{\"99\":1}}],[\"≐w−e\",{\"1\":{\"99\":1}}],[\"ω=e\",{\"1\":{\"110\":1}}],[\"计算10\",{\"1\":{\"195\":1}}],[\"计算的话也只能通过\",{\"1\":{\"195\":1}}],[\"计算\",{\"1\":{\"110\":1}}],[\"期望的情况\",{\"1\":{\"105\":1}}],[\"另一种表达\",{\"0\":{\"151\":1,\"154\":1}}],[\"另一种问题描述方法\",{\"0\":{\"105\":1}}],[\"另一些则频繁被访问\",{\"1\":{\"134\":1}}],[\"另一分布下\",{\"1\":{\"29\":1}}],[\"∇w​f\",{\"1\":{\"104\":2}}],[\"让程序继续运行下去\",{\"1\":{\"234\":1}}],[\"让类来使用这个接口\",{\"1\":{\"185\":1}}],[\"让我们的java程序更加生动形象\",{\"1\":{\"178\":1}}],[\"让我看看\",{\"1\":{\"170\":1}}],[\"让当前对象的name变量值等于参数传入的值\",{\"1\":{\"164\":1}}],[\"让\",{\"1\":{\"104\":1}}],[\"往往可以转化为导数为\",{\"1\":{\"104\":1}}],[\"=\",{\"1\":{\"116\":1,\"120\":1}}],[\"=e\",{\"1\":{\"104\":1}}],[\"=n\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"含噪声\",{\"1\":{\"104\":1}}],[\"含噪音\",{\"1\":{\"97\":1}}],[\"视为一个特殊情况下的\",{\"1\":{\"104\":1}}],[\"视为\",{\"1\":{\"104\":1,\"142\":1}}],[\"⇓wk+1​=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"到\",{\"1\":{\"104\":1}}],[\"转化为\",{\"1\":{\"103\":1}}],[\"转换到\",{\"1\":{\"130\":1}}],[\"转换到状态s\",{\"1\":{\"20\":1}}],[\"转换为数字666\",{\"1\":{\"194\":1}}],[\"转换为\",{\"1\":{\"58\":1,\"76\":1,\"77\":1,\"148\":1}}],[\"均为非负整数\",{\"1\":{\"212\":1}}],[\"均是随机变量\",{\"1\":{\"110\":1,\"141\":1}}],[\"均值估计\",{\"1\":{\"103\":1}}],[\"均收集完\",{\"1\":{\"82\":1}}],[\"分割字符串\",{\"1\":{\"210\":1}}],[\"分割操作\",{\"1\":{\"210\":1}}],[\"分析随机变量\",{\"1\":{\"133\":1}}],[\"分析\",{\"0\":{\"102\":1}}],[\"分别设为1\",{\"1\":{\"10\":1}}],[\"借用\",{\"1\":{\"101\":1}}],[\"▽w​q^​\",{\"1\":{\"142\":2}}],[\"▽w​qt​^​\",{\"1\":{\"139\":1,\"140\":1}}],[\"▽w​vt​^​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"▽w​v^\",{\"1\":{\"136\":1}}],[\"▽w​\",{\"1\":{\"136\":1}}],[\"▽w​j​=e\",{\"1\":{\"142\":1}}],[\"▽w​j\",{\"1\":{\"104\":1,\"136\":1}}],[\"▽w​f\",{\"1\":{\"101\":2,\"104\":10}}],[\"▽θ​π\",{\"1\":{\"155\":1}}],[\"▽θ​lnπ\",{\"1\":{\"155\":6,\"156\":1}}],[\"▽θ​ln\",{\"1\":{\"26\":3}}],[\"▽θ​j\",{\"1\":{\"26\":1,\"155\":3}}],[\"输出为\",{\"1\":{\"221\":1}}],[\"输出为标量\",{\"1\":{\"101\":1}}],[\"输入序列\",{\"1\":{\"97\":1}}],[\"⋅▽w​q^​\",{\"1\":{\"142\":1}}],[\"⋅\",{\"1\":{\"101\":1,\"110\":1}}],[\"η\",{\"1\":{\"99\":2,\"104\":2,\"110\":1,\"155\":1}}],[\"ηk2​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​∣hk​\",{\"1\":{\"98\":1}}],[\"ηk​\",{\"1\":{\"97\":3,\"99\":1,\"104\":1,\"110\":1}}],[\"应用于\",{\"0\":{\"99\":1}}],[\"应该是无人机最终停的位置即是部署的最佳位置\",{\"1\":{\"13\":1}}],[\"保证\",{\"1\":{\"98\":2}}],[\"保证选取最大的\",{\"1\":{\"57\":1}}],[\"要么在当前函数通过\",{\"1\":{\"234\":1}}],[\"要么一直\",{\"1\":{\"234\":1}}],[\"要么就往上一级函数上\",{\"1\":{\"233\":1}}],[\"要么自己处理好\",{\"1\":{\"233\":1}}],[\"要创建一个抽象类的实例对象\",{\"1\":{\"222\":1}}],[\"要使用抽象类\",{\"1\":{\"184\":1}}],[\"要是都不是这个类型还比什么\",{\"1\":{\"182\":1}}],[\"要给成员变量设定初始值\",{\"1\":{\"166\":1}}],[\"要在对象创建时进行处理\",{\"1\":{\"166\":1}}],[\"要求g\",{\"1\":{\"98\":1}}],[\"要证明加入baseline成立\",{\"1\":{\"26\":1}}],[\"收敛性情况\",{\"1\":{\"116\":1}}],[\"收敛性分析\",{\"0\":{\"98\":1}}],[\"收集完毕才能进行一次迭代\",{\"1\":{\"101\":1}}],[\"收益最大\",{\"1\":{\"48\":1}}],[\"次且最多匹配\",{\"1\":{\"212\":1}}],[\"次\",{\"1\":{\"212\":4}}],[\"次的观测值\",{\"1\":{\"97\":1}}],[\"次方程根的估计\",{\"1\":{\"97\":1}}],[\"问题\",{\"1\":{\"103\":1,\"104\":1,\"110\":1}}],[\"问题转化\",{\"0\":{\"103\":1}}],[\"问题引入\",{\"0\":{\"96\":1,\"101\":1}}],[\"问题进行研究\",{\"1\":{\"92\":1}}],[\"增量式的迭代算法\",{\"1\":{\"94\":1}}],[\"第二种\",{\"1\":{\"94\":1}}],[\"第一种\",{\"1\":{\"94\":1}}],[\"引言\",{\"0\":{\"93\":1}}],[\"引入两个网络\",{\"1\":{\"142\":1}}],[\"引入\",{\"0\":{\"88\":1,\"110\":1,\"131\":1},\"1\":{\"48\":1}}],[\"引入随机变量后对应的discounted\",{\"1\":{\"39\":1}}],[\"引入discount\",{\"1\":{\"19\":1}}],[\"针对\",{\"1\":{\"92\":1}}],[\"随着我们的程序不断变大\",{\"1\":{\"173\":1}}],[\"随着无人机与用户之间距离和发射功率的变化\",{\"1\":{\"9\":1}}],[\"随机数生成\",{\"1\":{\"241\":1}}],[\"随机变量\",{\"1\":{\"105\":1}}],[\"随机梯度下降\",{\"1\":{\"101\":1}}],[\"随机近似理论与随机梯度下降算法\",{\"0\":{\"92\":1}}],[\"找的是在所有可能策略中的最优策略\",{\"1\":{\"88\":1}}],[\"ϵ−greedy\",{\"1\":{\"125\":1}}],[\"ϵ∈\",{\"1\":{\"87\":1}}],[\"ϵ\",{\"1\":{\"87\":2}}],[\"足够长的情况下\",{\"1\":{\"86\":1}}],[\"条件转换掉\",{\"1\":{\"85\":1}}],[\"据目前而言\",{\"1\":{\"84\":1}}],[\"未能访问\",{\"1\":{\"84\":1}}],[\"未知时的情况\",{\"1\":{\"97\":1}}],[\"未知\",{\"1\":{\"77\":1,\"96\":1,\"166\":1}}],[\"直接作为接口中抽象方法的实现\",{\"1\":{\"225\":2}}],[\"直接创建一个匿名的接口实现类\",{\"1\":{\"222\":1}}],[\"直接在方法中创建局部内部类\",{\"1\":{\"220\":1}}],[\"直接在类中定义变量\",{\"1\":{\"161\":1}}],[\"直接指定值和大小\",{\"1\":{\"201\":1}}],[\"直接将字符串的666\",{\"1\":{\"194\":1}}],[\"直接写每个状态的名字即可\",{\"1\":{\"187\":1}}],[\"直接判断引用的对象是不是teacher类型\",{\"1\":{\"185\":1}}],[\"直接int\",{\"1\":{\"185\":1}}],[\"直接==\",{\"1\":{\"182\":1}}],[\"直接使用integer为我们通过好的求和方法\",{\"1\":{\"225\":1}}],[\"直接使用就可以\",{\"1\":{\"174\":1}}],[\"直接使用即可\",{\"1\":{\"173\":1}}],[\"直接赋值\",{\"1\":{\"166\":1}}],[\"直接估计的是\",{\"1\":{\"120\":1}}],[\"直接通过\",{\"1\":{\"94\":1}}],[\"直接\",{\"1\":{\"82\":1}}],[\"直到设置的收敛条件为止\",{\"1\":{\"66\":1}}],[\"直到各个簇的成员没有太大变化\",{\"1\":{\"13\":1}}],[\"才会初始化外部类\",{\"1\":{\"221\":1}}],[\"才能去\",{\"1\":{\"218\":1}}],[\"才能进行比较\",{\"1\":{\"182\":1}}],[\"才能进行\",{\"1\":{\"82\":1}}],[\"才进行更新\",{\"1\":{\"82\":1}}],[\"等价于\",{\"1\":{\"212\":6}}],[\"等候时间过长\",{\"1\":{\"82\":1}}],[\"等均未知\",{\"1\":{\"75\":1}}],[\"缺点\",{\"1\":{\"82\":1}}],[\"估计了q\",{\"1\":{\"82\":1}}],[\"估计中\",{\"1\":{\"81\":2}}],[\"高效地更新\",{\"0\":{\"82\":1}}],[\"高度h=hn​\",{\"1\":{\"11\":1}}],[\"高度的上界是最大发射功率pmax​的函数\",{\"1\":{\"9\":1}}],[\"都会在最后执行任务\",{\"1\":{\"234\":1}}],[\"都可以直接进行方法引用\",{\"1\":{\"225\":1}}],[\"都在\",{\"1\":{\"195\":1}}],[\"都有学习的能力\",{\"1\":{\"185\":1}}],[\"都有可选择的动作\",{\"1\":{\"19\":1}}],[\"都是string类型的一个实例对象\",{\"1\":{\"210\":1}}],[\"都是直接使用new关键字就能直接搞定了\",{\"1\":{\"166\":1}}],[\"都是最大的\",{\"1\":{\"148\":1}}],[\"都需要有多个\",{\"1\":{\"84\":1}}],[\"都记录\",{\"1\":{\"81\":1}}],[\"记录在\",{\"1\":{\"81\":1}}],[\"仅仅是se中就有700多个\",{\"1\":{\"232\":1}}],[\"仅支持接口\",{\"1\":{\"224\":1}}],[\"仅用作估计\",{\"1\":{\"81\":1}}],[\"仅需要考虑无人机的7个移动方向即可\",{\"1\":{\"14\":1}}],[\"节所述\",{\"1\":{\"79\":1}}],[\"有着不同程度的访问限制\",{\"1\":{\"174\":1}}],[\"有点混乱\",{\"1\":{\"173\":1}}],[\"有些时候并不需要创建那么多对象\",{\"1\":{\"193\":1}}],[\"有些时候\",{\"1\":{\"165\":1}}],[\"有时候我们的方法中可能会出现一些与成员变量重名的变量\",{\"1\":{\"164\":1}}],[\"有表示\",{\"1\":{\"155\":1}}],[\"有\",{\"1\":{\"79\":1}}],[\"有关注解我们会在最后一章进行介绍\",{\"1\":{\"182\":1}}],[\"有关锁的内容\",{\"1\":{\"181\":1}}],[\"有关\",{\"1\":{\"48\":1,\"152\":1}}],[\"迭代\",{\"1\":{\"79\":1}}],[\"首先实现cloneable接口\",{\"1\":{\"186\":1}}],[\"首先初始化一个随机的策略π0​\",{\"1\":{\"79\":1}}],[\"首先随机设计一个初始的策略π0​\",{\"1\":{\"66\":1}}],[\"≈▽θ​lnπ\",{\"1\":{\"155\":1}}],[\"≈vπ​\",{\"1\":{\"131\":1}}],[\"≈n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"≈n1​i=1∑n​g\",{\"1\":{\"78\":1}}],[\"≈xˉ\",{\"1\":{\"94\":1}}],[\"≈xˉ=n1​j=1∑n​xj​\",{\"1\":{\"75\":1}}],[\"假设有\",{\"1\":{\"142\":1}}],[\"假设我们具有\",{\"1\":{\"116\":1}}],[\"假设我们可以得到有关随机变量\",{\"1\":{\"110\":1}}],[\"假设我们需要求解如下方程\",{\"1\":{\"96\":1}}],[\"假设我们有了一系列\",{\"1\":{\"78\":1}}],[\"假设\",{\"1\":{\"94\":1,\"154\":1}}],[\"假设功率q=qn​\",{\"1\":{\"11\":1}}],[\"已知的情况\",{\"1\":{\"96\":1}}],[\"已知\",{\"1\":{\"77\":1}}],[\"效率过低\",{\"1\":{\"76\":1}}],[\"样本\",{\"1\":{\"142\":1}}],[\"样本必须是独立同分布\",{\"1\":{\"75\":1}}],[\"样本采样\",{\"1\":{\"75\":1}}],[\"若有一系列\",{\"1\":{\"75\":1}}],[\"蒙特卡洛方法\",{\"0\":{\"75\":1}}],[\"就行了\",{\"1\":{\"232\":2}}],[\"就明确指出了在运行的时候会出现的异常\",{\"1\":{\"231\":1}}],[\"就会直接交给jvm进行处理\",{\"1\":{\"234\":1}}],[\"就会报错\",{\"1\":{\"223\":1}}],[\"就会得到不同的对象了\",{\"1\":{\"193\":1}}],[\"就近原则\",{\"1\":{\"218\":1}}],[\"就表示这个是一个数组类型\",{\"1\":{\"201\":1}}],[\"就没办法了\",{\"1\":{\"195\":1}}],[\"就支持像这样编写\",{\"1\":{\"193\":1}}],[\"就像使用普通类型那样\",{\"1\":{\"187\":1}}],[\"就像在这个类定义的方法一样\",{\"1\":{\"174\":1}}],[\"就像下面这样\",{\"1\":{\"170\":1}}],[\"就需要对异常进行捕获\",{\"1\":{\"234\":1}}],[\"就需要注意了\",{\"1\":{\"173\":1}}],[\"就需要新的算法进行解决\",{\"1\":{\"96\":1}}],[\"就可以使用多重异常捕获\",{\"1\":{\"234\":1}}],[\"就可以使用tostring转换为字符串了\",{\"1\":{\"211\":1}}],[\"就可以直接就创出对象\",{\"1\":{\"222\":1}}],[\"就可以表示这个是哪一个包里的类了\",{\"1\":{\"173\":1}}],[\"就可以执行定义好的方法了\",{\"1\":{\"162\":1}}],[\"就可以进行一定操作\",{\"1\":{\"161\":1}}],[\"就不会执行接口的默认方法\",{\"1\":{\"185\":1}}],[\"就不一定需要实现\",{\"1\":{\"184\":1}}],[\"就不太可行\",{\"1\":{\"134\":1}}],[\"就不需要是\",{\"1\":{\"125\":1}}],[\"就不能确保所选择的\",{\"1\":{\"84\":1}}],[\"就直接去更新策略\",{\"1\":{\"82\":1}}],[\"就是说如果这个函数结束时有异常\",{\"1\":{\"233\":1}}],[\"就是内存溢出错误\",{\"1\":{\"231\":1}}],[\"就是将一个已实现的方法\",{\"1\":{\"225\":1}}],[\"就是一个已经实现了抽象方法的对象\",{\"1\":{\"222\":1}}],[\"就是创建在内部的类\",{\"1\":{\"217\":1}}],[\"就是专门用于构造字符串的\",{\"1\":{\"211\":1}}],[\"就是0\",{\"1\":{\"201\":1}}],[\"就是null\",{\"1\":{\"201\":1}}],[\"就是精确到最后一位时\",{\"1\":{\"195\":1}}],[\"就是用于分割的\",{\"1\":{\"173\":1}}],[\"就是域名\",{\"1\":{\"173\":1}}],[\"就是要操作\",{\"1\":{\"161\":1}}],[\"就是\",{\"1\":{\"87\":1}}],[\"就是前面\",{\"1\":{\"78\":1}}],[\"就是进行迭代\",{\"1\":{\"71\":1}}],[\"就好了\",{\"1\":{\"63\":1}}],[\"⋮\",{\"1\":{\"70\":4}}],[\"方便后续比较\",{\"1\":{\"70\":1}}],[\"方法转换字符串\",{\"1\":{\"242\":1}}],[\"方法引用其实本质上就相当于将其他方法的实现\",{\"1\":{\"225\":1}}],[\"方法引用\",{\"0\":{\"225\":1},\"1\":{\"225\":2}}],[\"方法名\",{\"1\":{\"220\":1,\"225\":4}}],[\"方法名称\",{\"1\":{\"162\":2}}],[\"方法名称同样可以随便起\",{\"1\":{\"162\":1}}],[\"方法参数的name\",{\"1\":{\"218\":1}}],[\"方法等\",{\"1\":{\"218\":1}}],[\"方法重写\",{\"0\":{\"182\":1}}],[\"方法体\",{\"1\":{\"162\":1}}],[\"方法的返回类型\",{\"1\":{\"165\":1}}],[\"方法的重载是为某个方法提供更多种类\",{\"1\":{\"182\":1}}],[\"方法的重载\",{\"0\":{\"165\":1}}],[\"方法的进阶使用\",{\"0\":{\"163\":1}}],[\"方法的调用\",{\"1\":{\"162\":1}}],[\"方法的定义如下\",{\"1\":{\"162\":1}}],[\"方法的创建与使用\",{\"0\":{\"162\":1}}],[\"方法是语句的集合\",{\"1\":{\"162\":1}}],[\"方法进行求解\",{\"1\":{\"136\":1}}],[\"方法2\",{\"1\":{\"82\":1}}],[\"方法1\",{\"1\":{\"82\":1}}],[\"方法\",{\"0\":{\"23\":1,\"202\":1},\"1\":{\"77\":1,\"155\":1,\"181\":1}}],[\"两个算法迭代过程十分类似\",{\"1\":{\"70\":1}}],[\"进行异常捕获\",{\"1\":{\"234\":1}}],[\"进行捕获\",{\"1\":{\"234\":1}}],[\"进行拼接操作\",{\"1\":{\"211\":1}}],[\"进行优化\",{\"1\":{\"148\":1}}],[\"进行训练\",{\"1\":{\"142\":1}}],[\"进行赋值\",{\"1\":{\"142\":1}}],[\"进行固定求解\",{\"1\":{\"142\":1}}],[\"进行生成数据\",{\"1\":{\"125\":1}}],[\"进行更新即可\",{\"1\":{\"115\":1}}],[\"进行的采样\",{\"1\":{\"84\":1}}],[\"进行估计\",{\"1\":{\"78\":1,\"94\":1}}],[\"进行了无穷多步来进行了真实的求解\",{\"1\":{\"71\":1}}],[\"进行迭代\",{\"1\":{\"70\":1,\"101\":1}}],[\"进行求解\",{\"1\":{\"47\":1,\"66\":1,\"103\":1}}],[\"之外的任何单个字符\",{\"1\":{\"212\":1}}],[\"之外\",{\"1\":{\"202\":1}}],[\"之前就是直接使用的\",{\"1\":{\"173\":1}}],[\"之前介绍的方法都是\",{\"1\":{\"147\":1}}],[\"之后进行迭代\",{\"1\":{\"70\":1}}],[\"之间存在什么关系\",{\"1\":{\"68\":1}}],[\"得到一个字符串数组\",{\"1\":{\"210\":1}}],[\"得到一个克隆的对象\",{\"1\":{\"186\":1}}],[\"得到一个样本序列x1​\",{\"1\":{\"75\":1}}],[\"得到含有噪音的观测值序列\",{\"1\":{\"97\":1}}],[\"得到的会是同一个对象\",{\"1\":{\"193\":1}}],[\"得到的\",{\"1\":{\"84\":1}}],[\"得到\",{\"1\":{\"68\":1}}],[\"一开始创建时\",{\"1\":{\"211\":1}}],[\"一定要用equals\",{\"1\":{\"210\":1}}],[\"一定可以遍历所给定的\",{\"1\":{\"84\":1}}],[\"一旦被声明为静态\",{\"1\":{\"170\":1}}],[\"一般出现错误可能jvm就无法继续正常运行了\",{\"1\":{\"231\":1}}],[\"一般情况\",{\"1\":{\"195\":1}}],[\"一般情况下只是为了进行一些额外的初始化工作而已\",{\"1\":{\"222\":1}}],[\"一般情况下\",{\"1\":{\"170\":1}}],[\"一般遇到以下情况时才会会加载类\",{\"1\":{\"171\":1}}],[\"一般使用驼峰命名法最规范\",{\"1\":{\"162\":1}}],[\"一般化的推广\",{\"1\":{\"69\":1}}],[\"一些方法\",{\"1\":{\"242\":1}}],[\"一些特性\",{\"1\":{\"155\":1}}],[\"一些细节\",{\"1\":{\"142\":1,\"156\":1}}],[\"一些状态可能很少被访问\",{\"1\":{\"134\":1}}],[\"一些问题\",{\"0\":{\"68\":1}}],[\"一致也是可以的\",{\"1\":{\"124\":1}}],[\"一个是运行时异常\",{\"1\":{\"232\":1}}],[\"一个是编译时异常\",{\"1\":{\"232\":1}}],[\"一个成员内部类\",{\"1\":{\"218\":1}}],[\"一个三行两列的数组\",{\"1\":{\"206\":1}}],[\"一个类可以附加很多个功能\",{\"1\":{\"185\":1}}],[\"一个类中可以包含多个同名的方法\",{\"1\":{\"165\":1}}],[\"一个对象改变了静态变量的值\",{\"1\":{\"170\":1}}],[\"一个\",{\"1\":{\"103\":1}}],[\"一样才行\",{\"1\":{\"225\":1}}],[\"一样\",{\"1\":{\"82\":1}}],[\"一种则是有所偏向\",{\"1\":{\"152\":1}}],[\"一种是将所有状态视为同等重要\",{\"1\":{\"152\":1}}],[\"一种是通过迭代算法来求解\",{\"1\":{\"68\":1}}],[\"一种是可以直接通过矩阵求逆进行求解\",{\"1\":{\"68\":1}}],[\"一种迭代策略\",{\"1\":{\"47\":1}}],[\"jvm发现任何异常都会立即终止程序运行\",{\"1\":{\"234\":1}}],[\"jvm\",{\"1\":{\"171\":2,\"234\":2}}],[\"java提供的基本类型包装类\",{\"1\":{\"192\":1}}],[\"java中没有字符串这种基本类型\",{\"1\":{\"209\":1}}],[\"java中的基本类型\",{\"1\":{\"192\":1}}],[\"java中引入了访问权限控制\",{\"1\":{\"174\":1}}],[\"java并不是纯面向对象的语言\",{\"1\":{\"192\":1}}],[\"java8开始\",{\"1\":{\"185\":1}}],[\"java会默认导入java\",{\"1\":{\"173\":1}}],[\"java\",{\"0\":{\"160\":1,\"169\":1,\"177\":1,\"190\":1,\"198\":1,\"215\":1,\"228\":1,\"238\":1,\"250\":1},\"1\":{\"171\":1,\"173\":1,\"186\":1,\"187\":3,\"195\":3,\"208\":1,\"222\":2,\"241\":2,\"242\":1},\"2\":{\"168\":1,\"176\":1,\"189\":1,\"197\":1,\"214\":1,\"227\":1,\"237\":1,\"244\":1}}],[\"j\",{\"1\":{\"66\":2,\"68\":1,\"78\":1,\"101\":1,\"104\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"148\":1,\"151\":1,\"155\":1,\"156\":1}}],[\"j+1\",{\"1\":{\"66\":2,\"68\":1}}],[\"步骤类似\",{\"1\":{\"79\":1}}],[\"步骤中\",{\"1\":{\"68\":2}}],[\"步来求解\",{\"1\":{\"71\":1}}],[\"步\",{\"1\":{\"63\":1}}],[\"动态规划\",{\"0\":{\"61\":1}}],[\"动作\",{\"1\":{\"19\":1,\"142\":1}}],[\"动作空间包含两个部分\",{\"1\":{\"14\":1}}],[\"动作空间\",{\"1\":{\"13\":1}}],[\"满足f\",{\"1\":{\"58\":1}}],[\"区别于贝尔曼公式\",{\"1\":{\"56\":1}}],[\"外部类初始化\",{\"1\":{\"221\":2}}],[\"外部类父类的tostring方法\",{\"1\":{\"218\":1}}],[\"外部类的tosrting方法\",{\"1\":{\"218\":1}}],[\"外部是无法访问到这个内部类的\",{\"1\":{\"218\":1}}],[\"外层\",{\"1\":{\"218\":1}}],[\"外\",{\"1\":{\"55\":1}}],[\"作为附加功能存在\",{\"1\":{\"185\":1}}],[\"作为下一步的\",{\"1\":{\"53\":1}}],[\"作用\",{\"1\":{\"26\":1}}],[\"选择对应的动作\",{\"1\":{\"84\":1}}],[\"选择移动方向和选择关联用户\",{\"1\":{\"14\":1}}],[\"选取当前状态下最大的\",{\"1\":{\"70\":2}}],[\"选取状态中最大的\",{\"1\":{\"53\":1}}],[\"唯一\",{\"1\":{\"53\":1}}],[\"存在不动点x∗\",{\"1\":{\"58\":1}}],[\"存在\",{\"1\":{\"53\":1}}],[\"存在lemma1\",{\"1\":{\"9\":1}}],[\"贝尔曼最优公式\",{\"0\":{\"52\":1},\"1\":{\"61\":1}}],[\"贝尔曼公式\",{\"0\":{\"36\":1}}],[\"总结\",{\"0\":{\"49\":1}}],[\"总用户的mos取决于无人机的发射功率\",{\"1\":{\"11\":1}}],[\"加\",{\"1\":{\"183\":1}}],[\"加权均值\",{\"1\":{\"48\":1}}],[\"加上\",{\"1\":{\"48\":1}}],[\"和匿名内部类不同\",{\"1\":{\"224\":1}}],[\"和\",{\"1\":{\"48\":1,\"82\":1,\"87\":1,\"101\":1,\"105\":1,\"122\":1,\"123\":1,\"142\":2,\"195\":1,\"211\":1,\"212\":1}}],[\"和动作\",{\"1\":{\"48\":1}}],[\"和e\",{\"1\":{\"42\":1}}],[\"采取动作\",{\"1\":{\"78\":1}}],[\"采取一个指定的action可以得到的平均return\",{\"1\":{\"48\":1}}],[\"采用梯度下降\",{\"1\":{\"142\":1}}],[\"采用\",{\"1\":{\"79\":1,\"136\":1}}],[\"采用的是the\",{\"1\":{\"14\":1}}],[\"采用q\",{\"1\":{\"13\":1}}],[\"采用基于遗传算法的gak\",{\"1\":{\"13\":1}}],[\"采用mos作为用户qos衡量的标准\",{\"1\":{\"10\":1}}],[\"k→0∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"k→∞\",{\"1\":{\"47\":1,\"58\":1,\"104\":1}}],[\"k\",{\"1\":{\"97\":2}}],[\"k−1\",{\"1\":{\"94\":1}}],[\"k=2\",{\"1\":{\"94\":1}}],[\"k=1∑n​rt+k​\",{\"1\":{\"154\":1}}],[\"k=1∑n​rt+k​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"k=1\",{\"1\":{\"62\":1,\"94\":1,\"97\":1}}],[\"kth\",{\"1\":{\"79\":1}}],[\"kn​∩kn\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"kn​\",{\"1\":{\"8\":1,\"9\":2}}],[\"无参构造方法被覆盖\",{\"1\":{\"187\":1}}],[\"无法继续申请内存了\",{\"1\":{\"231\":1}}],[\"无法显式定义构造函数或初始化块\",{\"1\":{\"222\":1}}],[\"无法直接定义新的属性\",{\"1\":{\"222\":1}}],[\"无法进行修改\",{\"1\":{\"209\":1}}],[\"无法表示一个非常大的数\",{\"1\":{\"195\":1}}],[\"无法使用this关键字\",{\"1\":{\"170\":1}}],[\"无法获取成员变量的值\",{\"1\":{\"170\":1}}],[\"无关\",{\"1\":{\"152\":1}}],[\"无论是否出现异常\",{\"1\":{\"234\":1}}],[\"无论是基本类型还是引用类型\",{\"1\":{\"186\":1}}],[\"无论是\",{\"1\":{\"92\":1}}],[\"无记忆性\",{\"1\":{\"44\":1}}],[\"无人机需要进行移动\",{\"1\":{\"14\":1}}],[\"无人机的动态移动设计\",{\"0\":{\"14\":1}}],[\"无人机的位置初始化也是随机部署的\",{\"1\":{\"13\":1}}],[\"无人机的3d部署\",{\"0\":{\"13\":1}}],[\"无人机3d部署算法\",{\"1\":{\"13\":1}}],[\"无人机\",{\"1\":{\"13\":1}}],[\"无人机n以可变高度悬停在用户上方\",{\"1\":{\"13\":1}}],[\"无人机n的高度需满足\",{\"1\":{\"9\":1}}],[\"无人机n与用户kn​在时间t的距离表示为\",{\"1\":{\"8\":1}}],[\"无人机往往有更高的los链接概率\",{\"1\":{\"9\":1}}],[\"用|隔开每种类型即可\",{\"1\":{\"234\":1}}],[\"用于便捷操作数组\",{\"1\":{\"242\":1}}],[\"用于规定给定组件必须要出现多少次才能满足匹配的\",{\"1\":{\"212\":1}}],[\"用于计算超大数字\",{\"1\":{\"195\":1}}],[\"用于指定当前类所处的包的\",{\"1\":{\"173\":1}}],[\"用于解释\",{\"1\":{\"76\":1}}],[\"用来描述所有状态的state\",{\"1\":{\"42\":1}}],[\"用户的速度设为\",{\"1\":{\"14\":1}}],[\"用户漫游模型\",{\"1\":{\"14\":1}}],[\"用户区域划分算法\",{\"1\":{\"13\":1}}],[\"用户关联策略\",{\"1\":{\"13\":1}}],[\"用户是保持静态的\",{\"1\":{\"13\":1}}],[\"用户rkn​​在一段时间ts​内的mos总和为\",{\"1\":{\"10\":1}}],[\"求一个数的算术平方根\",{\"1\":{\"241\":1}}],[\"求均值的方法\",{\"0\":{\"94\":1}}],[\"求在策略πk​下所有的\",{\"1\":{\"79\":1}}],[\"求解梯度还是很好求的\",{\"1\":{\"142\":1}}],[\"求解给定策略\",{\"1\":{\"111\":1}}],[\"求解当前策略的\",{\"1\":{\"70\":1}}],[\"求解下一步的vk+1​\",{\"1\":{\"63\":1}}],[\"求解方法\",{\"1\":{\"58\":1}}],[\"求解\",{\"0\":{\"58\":1},\"1\":{\"49\":1}}],[\"求解bellman\",{\"1\":{\"45\":1}}],[\"求出其对应状态的\",{\"1\":{\"47\":1}}],[\"求\",{\"1\":{\"41\":1}}],[\"也支持向下转型\",{\"1\":{\"204\":1}}],[\"也只能表示64bit的数据\",{\"1\":{\"195\":1}}],[\"也只有这一个静态的变量或方法\",{\"1\":{\"170\":1}}],[\"也会进行拷贝\",{\"1\":{\"186\":1}}],[\"也就是只包含方法的定义\",{\"1\":{\"185\":1}}],[\"也就是直接判断是否为同一个对象\",{\"1\":{\"181\":1}}],[\"也就是说依然是采用的object中的默认实现\",{\"1\":{\"202\":1}}],[\"也就是说数组的长度一旦确定\",{\"1\":{\"202\":1}}],[\"也就是说这个方法只有定义\",{\"1\":{\"184\":1}}],[\"也就是说\",{\"1\":{\"170\":1}}],[\"也是一样的\",{\"1\":{\"218\":1}}],[\"也是以对象的形式存在的\",{\"1\":{\"201\":1}}],[\"也是支持拆箱的\",{\"1\":{\"193\":1}}],[\"也是不同的两个类\",{\"1\":{\"173\":1}}],[\"也是尽量使用小写字母开头的单词\",{\"1\":{\"162\":1}}],[\"也可以象征性\",{\"1\":{\"210\":1}}],[\"也可以被子类访问\",{\"1\":{\"174\":1}}],[\"也可以用来将我们的类进行分类\",{\"1\":{\"173\":1}}],[\"也可以理解为是所有对象共享的内容\",{\"1\":{\"170\":1}}],[\"也可以直接在定义时赋值\",{\"1\":{\"166\":1}}],[\"也可以不同\",{\"1\":{\"165\":1}}],[\"也可以采用基于\",{\"1\":{\"156\":1}}],[\"也可以是向量\",{\"1\":{\"101\":1}}],[\"也可以是无限长的trajectory\",{\"1\":{\"19\":1}}],[\"也称为\",{\"1\":{\"40\":1}}],[\"核心内容\",{\"0\":{\"37\":1}}],[\"核心思想\",{\"1\":{\"25\":1,\"76\":1}}],[\"伪代码\",{\"0\":{\"32\":1,\"64\":1,\"67\":1,\"124\":1,\"144\":1},\"1\":{\"116\":1}}],[\"中方法\",{\"1\":{\"222\":1}}],[\"中除了\",{\"1\":{\"212\":1}}],[\"中字符的所有字符\",{\"1\":{\"212\":1}}],[\"中所有的\",{\"1\":{\"212\":1}}],[\"中定义的\",{\"1\":{\"184\":1}}],[\"中使用一个类之前\",{\"1\":{\"171\":1}}],[\"中取出一定数量的样本\",{\"1\":{\"142\":1}}],[\"中采用一个\",{\"1\":{\"142\":1}}],[\"中直接根据\",{\"1\":{\"115\":1}}],[\"中的前三个\",{\"1\":{\"212\":1}}],[\"中的所有字符\",{\"1\":{\"212\":1}}],[\"中的所有\",{\"1\":{\"212\":1}}],[\"中的两个\",{\"1\":{\"212\":1}}],[\"中的\",{\"1\":{\"88\":1,\"142\":2,\"212\":3}}],[\"中不断切换\",{\"1\":{\"82\":1}}],[\"中第一次出现的\",{\"1\":{\"81\":1}}],[\"中求解\",{\"1\":{\"68\":1}}],[\"中涉及的\",{\"1\":{\"62\":1}}],[\"中\",{\"0\":{\"99\":1},\"1\":{\"29\":1,\"71\":1,\"77\":1,\"88\":1,\"92\":1,\"137\":1,\"142\":1,\"195\":1,\"208\":1,\"222\":1,\"223\":1,\"241\":1,\"242\":1}}],[\"重写方法可以添加\",{\"1\":{\"182\":1}}],[\"重写方法要求与父类的定义完全一致\",{\"1\":{\"182\":2}}],[\"重新修改为\",{\"1\":{\"46\":1}}],[\"重要性采样\",{\"0\":{\"30\":1},\"1\":{\"29\":1}}],[\"重复步骤\",{\"1\":{\"13\":1}}],[\"30\",{\"1\":{\"241\":1}}],[\"3的结果\",{\"1\":{\"195\":1}}],[\"3\",{\"0\":{\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":2,\"41\":1,\"45\":1,\"47\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"79\":1,\"83\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":2,\"89\":2,\"98\":1,\"100\":1,\"101\":1,\"102\":1,\"105\":2,\"106\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":2,\"124\":1,\"139\":1,\"155\":1,\"216\":1},\"1\":{\"62\":2,\"70\":1,\"94\":1,\"97\":1,\"101\":1,\"195\":1,\"205\":1,\"206\":1,\"210\":1,\"212\":1,\"241\":1,\"242\":1}}],[\"3d部署和移动问题\",{\"1\":{\"5\":1}}],[\"3d位置进行优化处理\",{\"1\":{\"5\":1}}],[\"只会复制对象的地址\",{\"1\":{\"186\":1}}],[\"只要重写的内容中不会抛出对应的异常我们可以直接省去\",{\"1\":{\"233\":1}}],[\"只要是实现这个接口的类\",{\"1\":{\"185\":1}}],[\"只要一个类的父类或者自身有对应方法\",{\"1\":{\"185\":1}}],[\"只保留方法的定义\",{\"1\":{\"184\":1}}],[\"只能使用\",{\"1\":{\"223\":1}}],[\"只能对其进行继承\",{\"1\":{\"222\":1}}],[\"只能表示内部类对象\",{\"1\":{\"218\":1}}],[\"只能重新创建\",{\"1\":{\"202\":1,\"209\":1}}],[\"只能\",{\"1\":{\"195\":1}}],[\"只能内部使用\",{\"1\":{\"187\":1}}],[\"只能作为一个附属功能加在主体上\",{\"1\":{\"185\":1}}],[\"只能在构造函数进行赋值\",{\"1\":{\"183\":1}}],[\"只能得到\",{\"1\":{\"182\":1,\"184\":1}}],[\"只能被类本身和同包中的其他类访问\",{\"1\":{\"174\":1}}],[\"只有在运行的时候才知道会不会出错\",{\"1\":{\"231\":1}}],[\"只有在你使用到外部类的静态变量或方法后\",{\"1\":{\"221\":1}}],[\"只有在类不在同一个包下时才需要进行导入\",{\"1\":{\"173\":1}}],[\"只有抽象类中的抽象方法\",{\"1\":{\"185\":1}}],[\"只有是当前类型的对象\",{\"1\":{\"182\":1}}],[\"只有当样本全部收集完才能估计\",{\"1\":{\"94\":1}}],[\"只有当所有\",{\"1\":{\"82\":1}}],[\"只有当所有东西都是确定性的\",{\"1\":{\"41\":1}}],[\"只需要用\",{\"1\":{\"185\":1}}],[\"只需要在类名前面添加包名就行了\",{\"1\":{\"173\":1}}],[\"只需要\",{\"1\":{\"162\":1}}],[\"只需要保证\",{\"1\":{\"26\":1}}],[\"只给出了梯度的公式\",{\"1\":{\"155\":1}}],[\"只不过默认情况下没有开启断言\",{\"1\":{\"235\":1}}],[\"只不过还能更简单\",{\"1\":{\"225\":1}}],[\"只不过意义不大\",{\"1\":{\"222\":1}}],[\"只不过它比较特殊\",{\"1\":{\"210\":1}}],[\"只不过我们此时需要遍历所有的\",{\"1\":{\"79\":1}}],[\"只不过根据区域划分\",{\"1\":{\"13\":1}}],[\"只是初始化了内部类的\",{\"1\":{\"221\":1}}],[\"只是数组的地址不准修改\",{\"1\":{\"205\":1}}],[\"只是语法上为了简单\",{\"1\":{\"193\":1}}],[\"只是不用我们去写\",{\"1\":{\"166\":1}}],[\"只是进行了一步求解\",{\"1\":{\"71\":1}}],[\"只是求解各状态的\",{\"1\":{\"56\":1}}],[\"证明\",{\"1\":{\"26\":1}}],[\"θt+1​=θt​+α▽θ​lnπ\",{\"1\":{\"156\":2}}],[\"θt+1​=θt​+α▽θ​j\",{\"1\":{\"148\":1}}],[\"θt+1​​=θt​+α▽θ​j\",{\"1\":{\"156\":1}}],[\"θt​\",{\"1\":{\"148\":1,\"156\":3}}],[\"θ∈rm表示参数向量\",{\"1\":{\"148\":1}}],[\"θ\",{\"1\":{\"26\":4,\"148\":2,\"151\":1,\"155\":20,\"156\":2}}],[\"θkn​​\",{\"1\":{\"9\":1}}],[\"提供了一种特殊的语法\",{\"1\":{\"222\":1}}],[\"提供的方法进行计算\",{\"1\":{\"195\":1}}],[\"提升clone方法的访问权限\",{\"1\":{\"186\":1}}],[\"提升采样的效率\",{\"1\":{\"25\":1}}],[\"提高泛化能力\",{\"1\":{\"131\":1}}],[\"提出解决总用户mos最大化问题的三步骤\",{\"1\":{\"5\":1}}],[\"提出了一个理想的由qoe驱动的多无人机协助通信框架\",{\"1\":{\"5\":1}}],[\"而错误是致命问题\",{\"1\":{\"231\":1}}],[\"而字符串则是一系列字符的序列\",{\"1\":{\"209\":1}}],[\"而且是\",{\"1\":{\"202\":1}}],[\"而且如果是子类\",{\"1\":{\"184\":1}}],[\"而bigdecimal可以实现小数的精确计算\",{\"1\":{\"195\":1}}],[\"而实际上指向的还是原来的那个对象\",{\"1\":{\"186\":1}}],[\"而如果抽象类定义的是\",{\"1\":{\"184\":1}}],[\"而具体的实现\",{\"1\":{\"184\":1}}],[\"而方法的重写是覆盖原有的方法实现\",{\"1\":{\"182\":1}}],[\"而当我们需要使用其他包中的类时\",{\"1\":{\"173\":1}}],[\"而每一个\",{\"1\":{\"171\":1}}],[\"而非\",{\"1\":{\"166\":1}}],[\"而不是类所有的\",{\"1\":{\"218\":1}}],[\"而不是在对象创建的时候分配\",{\"1\":{\"171\":1}}],[\"而不是具体的某个对象\",{\"1\":{\"170\":1}}],[\"而不是对象本身的复制\",{\"1\":{\"161\":1}}],[\"而不是本体\",{\"1\":{\"161\":1}}],[\"而不是仅考虑吞吐量\",{\"1\":{\"4\":1}}],[\"而对应的真实梯度可以用一个估计的梯度来替代\",{\"1\":{\"156\":1}}],[\"而对应的策略梯度上升算法就是对应\",{\"1\":{\"23\":1}}],[\"而是在需要时才会去加载\",{\"1\":{\"171\":1}}],[\"而是在这之前就已经完成了\",{\"1\":{\"166\":1}}],[\"而是通过这个类去使用\",{\"1\":{\"170\":1}}],[\"而是等\",{\"1\":{\"142\":1}}],[\"而是对应的样本\",{\"1\":{\"99\":1}}],[\"而最小值问题\",{\"1\":{\"104\":1}}],[\"而言\",{\"1\":{\"70\":1}}],[\"而\",{\"1\":{\"41\":1,\"70\":1,\"71\":1}}],[\"策略梯度法\",{\"0\":{\"147\":1}}],[\"策略梯度上升\",{\"1\":{\"23\":1}}],[\"策略了\",{\"1\":{\"125\":1}}],[\"策略求解\",{\"1\":{\"70\":2}}],[\"策略提升\",{\"1\":{\"66\":1}}],[\"策略评估\",{\"1\":{\"66\":1}}],[\"策略更新\",{\"1\":{\"29\":1,\"82\":1}}],[\"策略为贪心策略\",{\"1\":{\"13\":1}}],[\"void类\",{\"1\":{\"195\":1}}],[\"void\",{\"1\":{\"161\":3,\"162\":2,\"164\":2,\"170\":2,\"173\":2,\"174\":2,\"181\":7,\"182\":1,\"184\":2,\"185\":7,\"186\":2,\"187\":2,\"193\":4,\"194\":1,\"195\":3,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":1,\"207\":4,\"208\":1,\"210\":3,\"211\":3,\"212\":2,\"218\":6,\"219\":2,\"220\":2,\"221\":3,\"222\":8,\"223\":2,\"224\":4,\"225\":5,\"233\":2,\"234\":6,\"235\":1,\"241\":2,\"242\":1}}],[\"vˉπ0​\",{\"1\":{\"152\":1,\"155\":1}}],[\"vˉπ​=es∼d​\",{\"1\":{\"150\":1}}],[\"vˉπ​=s∈s∑​d\",{\"1\":{\"150\":1}}],[\"vˉπ​\",{\"1\":{\"150\":1,\"152\":1,\"155\":1}}],[\"v^\",{\"1\":{\"131\":1}}],[\"vt​\",{\"1\":{\"112\":3}}],[\"vt+1​\",{\"1\":{\"112\":2}}],[\"visit\",{\"1\":{\"81\":4,\"84\":2}}],[\"vu\",{\"1\":{\"70\":1}}],[\"v0​\",{\"1\":{\"70\":2}}],[\"vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ1​​=rπ1​​+γpπ1​​vπ1​​\",{\"1\":{\"70\":1}}],[\"vπ0​​是通过迭代算法来求的\",{\"1\":{\"70\":1}}],[\"vπ0​​=rπ0​​+γpπ0​​vπ0​​\",{\"1\":{\"70\":1}}],[\"vπ0​​≤vπ1​​≤vπ2​​⋯≤vπk​​≤⋯≤v∗\",{\"1\":{\"68\":1}}],[\"vπk​​=\",{\"1\":{\"68\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​policyimprovement\",{\"1\":{\"77\":1}}],[\"vπk​​=rπk​​+γpπk​​vπk​​\",{\"1\":{\"66\":1,\"70\":1}}],[\"vπk​​\",{\"1\":{\"66\":1,\"68\":1,\"77\":1}}],[\"vπk​\",{\"1\":{\"66\":2,\"68\":1}}],[\"vπ​=\",{\"1\":{\"46\":1,\"47\":1}}],[\"vπ​=rπ​+γpπ​vπ​​\",{\"1\":{\"46\":1}}],[\"vπ​\",{\"1\":{\"27\":1,\"40\":2,\"42\":1,\"44\":1,\"45\":3,\"46\":4,\"48\":5,\"49\":1,\"55\":2,\"57\":1,\"75\":1,\"112\":1,\"113\":4,\"133\":1,\"134\":2,\"135\":2,\"136\":5,\"137\":1,\"138\":1,\"150\":2}}],[\"v\",{\"1\":{\"58\":5,\"61\":1,\"63\":2,\"110\":1,\"195\":1}}],[\"v=f\",{\"1\":{\"58\":1,\"61\":1}}],[\"v=πmax​\",{\"1\":{\"55\":1}}],[\"vk​\",{\"1\":{\"62\":1}}],[\"vk​→vπ​=\",{\"1\":{\"47\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​\",{\"1\":{\"70\":1}}],[\"vk+1​=rπk+1​​+γpπk+1​​vk​这里的vk​并不是\",{\"1\":{\"63\":1}}],[\"vk+1​=rπ​+γpπ​vk​​\",{\"1\":{\"47\":1}}],[\"vk+1​=f\",{\"1\":{\"62\":1}}],[\"v2​\",{\"1\":{\"47\":1}}],[\"v1​=rπ1​​+γpπ1​​v0​\",{\"1\":{\"70\":1}}],[\"v1​\",{\"1\":{\"47\":1}}],[\"valueof\",{\"1\":{\"187\":1,\"193\":1,\"194\":1,\"195\":4}}],[\"values\",{\"1\":{\"131\":2,\"187\":1}}],[\"value后\",{\"1\":{\"77\":1}}],[\"value的关系\",{\"1\":{\"42\":1}}],[\"value\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1,\"58\":1,\"62\":1,\"70\":1,\"111\":1,\"115\":1,\"119\":1,\"130\":1,\"132\":1,\"150\":1,\"153\":1},\"1\":{\"23\":1,\"37\":1,\"40\":5,\"41\":3,\"42\":1,\"45\":1,\"47\":1,\"48\":10,\"49\":4,\"52\":1,\"53\":1,\"55\":1,\"56\":1,\"57\":2,\"62\":1,\"63\":3,\"66\":3,\"68\":2,\"69\":1,\"70\":12,\"71\":2,\"75\":2,\"77\":6,\"79\":6,\"81\":3,\"82\":2,\"84\":1,\"92\":2,\"111\":1,\"113\":2,\"115\":2,\"116\":1,\"119\":2,\"120\":1,\"130\":1,\"147\":1,\"148\":1,\"150\":1,\"195\":1}}],[\"vector\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"very\",{\"1\":{\"10\":1}}],[\"vehicles\",{\"1\":{\"4\":1}}],[\"vehicular\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"或者是false\",{\"1\":{\"201\":1}}],[\"或者为静态变量赋值\",{\"1\":{\"171\":1}}],[\"或者\",{\"1\":{\"23\":1,\"66\":1,\"131\":1,\"156\":1,\"203\":1,\"223\":1}}],[\"∣\",{\"1\":{\"87\":1}}],[\"∣−1action\",{\"1\":{\"87\":1}}],[\"∣−1\",{\"1\":{\"87\":1}}],[\"∣a\",{\"1\":{\"87\":3}}],[\"∣ϵ​\",{\"1\":{\"87\":2}}],[\"∣∣≤δ\",{\"1\":{\"66\":1}}],[\"∣∣≤γ∣∣x1​−x2​∣∣\",{\"1\":{\"58\":1}}],[\"∣∣vπk+1​\",{\"1\":{\"66\":1}}],[\"∣∣f\",{\"1\":{\"58\":1}}],[\"∣st​=s\",{\"1\":{\"119\":1}}],[\"∣s=s\",{\"1\":{\"113\":2}}],[\"∣s\",{\"1\":{\"20\":1,\"41\":1,\"44\":4,\"45\":3,\"46\":1,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"113\":1,\"115\":1}}],[\"∣kn​∣为第n个簇的用户总数\",{\"1\":{\"14\":1}}],[\"会将子类的也捕获\",{\"1\":{\"234\":1}}],[\"会将其划分为n个簇\",{\"1\":{\"8\":1}}],[\"会隐式修改为\",{\"1\":{\"223\":1}}],[\"会报错\",{\"1\":{\"204\":1}}],[\"会直接复制值给拷贝对象\",{\"1\":{\"186\":1}}],[\"会限制其子类不允许其重写所对应的成员变量\",{\"1\":{\"183\":1}}],[\"会由jvm来调用一次此方法进行资源释放之类的操作\",{\"1\":{\"181\":1}}],[\"会在类刚加载的时候就分配\",{\"1\":{\"171\":1}}],[\"会覆盖掉默认的那一个无参构造方法\",{\"1\":{\"166\":1}}],[\"会出现异常\",{\"1\":{\"161\":1}}],[\"会一直进行更新\",{\"1\":{\"142\":1}}],[\"会与环境一直交互下去\",{\"1\":{\"19\":1}}],[\"这时我们就可以手动抛出一个异常来终止程序继续运行下去\",{\"1\":{\"233\":1}}],[\"这\",{\"1\":{\"211\":2}}],[\"这些方法并没有被重写\",{\"1\":{\"202\":1}}],[\"这些可以省\",{\"1\":{\"185\":1}}],[\"这同样不是se中需要学习的内容\",{\"1\":{\"181\":1}}],[\"这种局部内部类的形式\",{\"1\":{\"220\":1}}],[\"这种即可\",{\"1\":{\"185\":1}}],[\"这种情况是可以简化的\",{\"1\":{\"224\":1}}],[\"这种情况实际上会被优化为下面的写法\",{\"1\":{\"211\":1}}],[\"这种情况下的\",{\"1\":{\"152\":1}}],[\"这种情况我们将\",{\"1\":{\"152\":1}}],[\"这种迭代算法称为\",{\"1\":{\"62\":1}}],[\"这是为了提升效率\",{\"1\":{\"193\":1}}],[\"这是因为\",{\"1\":{\"193\":1}}],[\"这是浅拷贝\",{\"1\":{\"186\":1}}],[\"这是强制要求的\",{\"1\":{\"184\":1}}],[\"这是我们所求的量\",{\"1\":{\"136\":1}}],[\"这是来求解\",{\"1\":{\"79\":1}}],[\"这另一个策略会更新到最优的策略\",{\"1\":{\"123\":1}}],[\"这类算法统称为\",{\"1\":{\"82\":1}}],[\"这样参数名称所表示的就是一个数组\",{\"1\":{\"207\":1}}],[\"这样的异常称为运行时异常\",{\"1\":{\"231\":1}}],[\"这样的\",{\"1\":{\"204\":1}}],[\"这样的任务称为episodic\",{\"1\":{\"19\":1}}],[\"这样是不能赋值的\",{\"1\":{\"204\":1}}],[\"这样就是一个实现\",{\"1\":{\"222\":1}}],[\"这样就不同\",{\"1\":{\"210\":1}}],[\"这样就不会得到同一个对象了\",{\"1\":{\"193\":1}}],[\"这样就可以与\",{\"1\":{\"111\":1}}],[\"这样才能去估计相应的qπ​\",{\"1\":{\"84\":1}}],[\"这样\",{\"1\":{\"81\":1}}],[\"这一条\",{\"1\":{\"81\":1}}],[\"这个参数就是异常的原因\",{\"1\":{\"232\":1}}],[\"这个抽象类直接就定义好了\",{\"1\":{\"222\":1}}],[\"这个长度是字符的数量\",{\"1\":{\"210\":1}}],[\"这个接口中什么都没定义\",{\"1\":{\"186\":1}}],[\"这个默认方法没有任何作用\",{\"1\":{\"185\":1}}],[\"这个注解默认情况下可以省略\",{\"1\":{\"182\":1}}],[\"这个方法我们会在jvm篇视频教程中详细介绍\",{\"1\":{\"181\":1}}],[\"这个我们会在最后一章的反射中进行讲解\",{\"1\":{\"181\":1}}],[\"这个类在初始化时会对类中其他本地方法进行注册\",{\"1\":{\"181\":1}}],[\"这个仍然与之前一致\",{\"1\":{\"79\":1}}],[\"这个\",{\"1\":{\"78\":1}}],[\"这个便成为\",{\"1\":{\"23\":1}}],[\"这两个算法是一致的\",{\"1\":{\"70\":1}}],[\"这步是更新策略π\",{\"1\":{\"63\":1}}],[\"这里发生的是数组越界异常\",{\"1\":{\"234\":1}}],[\"这里仅仅是对正则表达式的简单使用\",{\"1\":{\"212\":1}}],[\"这里字符串是oooo\",{\"1\":{\"212\":1}}],[\"这里进行4次加法运算\",{\"1\":{\"211\":1}}],[\"这里我们选择使用父类的带参构造\",{\"1\":{\"232\":1}}],[\"这里我们需要特别注意一下\",{\"1\":{\"218\":1}}],[\"这里我们可以自由传入任意数量的字符串\",{\"1\":{\"207\":1}}],[\"这里我们定义一个info静态变量\",{\"1\":{\"170\":1}}],[\"这里ceiling表示向上取整\",{\"1\":{\"195\":1}}],[\"这里会有一个integercache\",{\"1\":{\"193\":1}}],[\"这里本质上就是被自动包装成了一个integer类型的对象\",{\"1\":{\"193\":1}}],[\"这里使用javap命令对class文件进行反编译得到\",{\"1\":{\"187\":1}}],[\"这里向上抛出一下异常\",{\"1\":{\"186\":1}}],[\"这里是\",{\"1\":{\"166\":1}}],[\"这里是每个无人机都有一张自己的q\",{\"1\":{\"13\":1}}],[\"这里需要特别说一下\",{\"1\":{\"204\":1}}],[\"这里需要特别注意\",{\"1\":{\"166\":1}}],[\"这里需要通过迭代算法来精确求出\",{\"1\":{\"70\":1}}],[\"这里没有使用this\",{\"1\":{\"164\":1}}],[\"这里实际上是将方法参数的局部变量name赋值为本身\",{\"1\":{\"164\":1}}],[\"这里编写代码跟我们之前在main中是一样的\",{\"1\":{\"162\":1}}],[\"这里定义的人类具有三个属性\",{\"1\":{\"161\":1}}],[\"这里可以用不同的方法来近似\",{\"1\":{\"156\":1}}],[\"这里的name是其所依附对象的\",{\"1\":{\"218\":1}}],[\"这里的话只能使用接口中的方法\",{\"1\":{\"185\":1}}],[\"这里的p1存放的是对象的引用\",{\"1\":{\"161\":1}}],[\"这里的a存放的是具体的某个值\",{\"1\":{\"161\":1}}],[\"这里的策略是随机性\",{\"1\":{\"155\":1}}],[\"这里的最优策略πk+1​是一个\",{\"1\":{\"63\":1}}],[\"这里在视频没有详细介绍\",{\"1\":{\"155\":1}}],[\"这里包含了一个\",{\"1\":{\"136\":1}}],[\"这里\",{\"1\":{\"66\":1}}],[\"这里有多种mobility\",{\"1\":{\"14\":1}}],[\"这里采用离散化空间坐标\",{\"1\":{\"13\":1}}],[\"通常也称为\",{\"1\":{\"135\":1}}],[\"通常是具有有限步长的trajectory\",{\"1\":{\"19\":1}}],[\"通过自动装箱转换的integer对象\",{\"1\":{\"193\":1}}],[\"通过添加abstract关键字\",{\"1\":{\"184\":1}}],[\"通过梯度的算法来最小化对应的损失函数\",{\"1\":{\"142\":1}}],[\"通过使用一个函数来进行拟合\",{\"1\":{\"131\":1}}],[\"通过采取\",{\"1\":{\"85\":1}}],[\"通过迭代算法求解\",{\"1\":{\"77\":1}}],[\"通过求解\",{\"1\":{\"48\":1}}],[\"通过\",{\"1\":{\"29\":1,\"45\":1,\"47\":1,\"70\":1,\"75\":1,\"82\":1}}],[\"通过k\",{\"1\":{\"13\":1}}],[\"通过gak\",{\"1\":{\"5\":1}}],[\"通过优化无人机的部署和动态移动来解决总用户mos最大化问题\",{\"1\":{\"5\":1}}],[\"更新一定次数后\",{\"1\":{\"142\":1}}],[\"更新策略的步骤就是选择此时\",{\"1\":{\"77\":1}}],[\"更加高效利用\",{\"1\":{\"80\":1}}],[\"更注重长远的reward\",{\"1\":{\"19\":1}}],[\"更远视\",{\"1\":{\"19\":1}}],[\"更多地是考虑多架无人机的二维部署或单架无人机在地面用户保持静止情况下的部署\",{\"1\":{\"4\":1}}],[\"显然是\",{\"1\":{\"150\":1}}],[\"显然是可以通过一个\",{\"1\":{\"66\":1}}],[\"显然我们仍然可以通过\",{\"1\":{\"110\":1}}],[\"显然我们可以将\",{\"1\":{\"104\":1}}],[\"显然ϵ=0\",{\"1\":{\"87\":1}}],[\"显然其核心关键就是在\",{\"1\":{\"77\":1}}],[\"显然在现实运行算法中是无法做到的\",{\"1\":{\"71\":1}}],[\"显然\",{\"1\":{\"19\":1,\"23\":1,\"63\":1,\"71\":1,\"78\":1,\"86\":1,\"96\":1,\"104\":1}}],[\"γa∑​π\",{\"1\":{\"45\":1}}],[\"γ\",{\"1\":{\"39\":1,\"48\":1,\"110\":1}}],[\"γ接近1\",{\"1\":{\"19\":1}}],[\"γ∈\",{\"1\":{\"19\":1}}],[\"γkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"γkn​​\",{\"1\":{\"9\":1}}],[\"γk0​σ2μlos​pmax​​\",{\"1\":{\"9\":1}}],[\"此时发生异常再往上抛出的话\",{\"1\":{\"234\":1}}],[\"此时这里创建出来的student对象\",{\"1\":{\"222\":1}}],[\"此时我们怎么去明确要使用的是哪一个\",{\"1\":{\"218\":1}}],[\"此时由于三个属性完全一致\",{\"1\":{\"182\":1}}],[\"此时this\",{\"1\":{\"166\":1}}],[\"此时变量没有引用任何对象\",{\"1\":{\"161\":1}}],[\"此时可以分析每一个状态在这个策略下的概率\",{\"1\":{\"135\":1}}],[\"此时也可以是\",{\"1\":{\"124\":1}}],[\"此时就是随机策略\",{\"1\":{\"87\":1}}],[\"此时\",{\"1\":{\"46\":1,\"77\":1,\"125\":1}}],[\"此时对应的discountedrate=0+γ0+γ20+γ31+γ41+⋯=γ31−γ1​\",{\"1\":{\"19\":1}}],[\"此时该trajectory的return=0+0+0+1+1+⋯=∞\",{\"1\":{\"19\":1}}],[\"此时的mos模型定义如下\",{\"1\":{\"10\":1}}],[\"指导agent在当前状态下选择哪个动作\",{\"1\":{\"19\":1}}],[\"π2\",{\"1\":{\"70\":1}}],[\"π2​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"π1​=argmaxπ​\",{\"1\":{\"70\":2}}],[\"π180​θkn​​−ζ\",{\"1\":{\"9\":1}}],[\"π0​\",{\"1\":{\"70\":1}}],[\"π0​pe​vπ0​​pi​π1​pe​vπ1​​pi​π2​pe​vπ2​​pi​\",{\"1\":{\"65\":1,\"70\":1}}],[\"πk​的\",{\"1\":{\"68\":1}}],[\"πk​\",{\"1\":{\"66\":2,\"78\":1}}],[\"πk+1​=πargmax​\",{\"1\":{\"66\":1,\"70\":2}}],[\"πk+1​=argmaxπ​\",{\"1\":{\"63\":1,\"77\":1}}],[\"πk+1​\",{\"1\":{\"63\":2,\"66\":2,\"68\":1,\"79\":2}}],[\"π∗\",{\"1\":{\"53\":2}}],[\"π\",{\"1\":{\"19\":1,\"20\":1,\"40\":1,\"41\":1,\"44\":1,\"45\":1,\"48\":1,\"53\":1,\"57\":1,\"87\":1,\"111\":1,\"112\":1,\"113\":2,\"135\":1,\"148\":2,\"152\":3,\"155\":1}}],[\"定义接口\",{\"1\":{\"185\":1}}],[\"定义目标函数\",{\"1\":{\"132\":1}}],[\"定义\",{\"0\":{\"201\":1},\"1\":{\"48\":1,\"185\":1}}],[\"定义了agent与环境的交互行为\",{\"1\":{\"19\":1}}],[\"定义为ξ=\",{\"1\":{\"13\":1}}],[\"所处的包和对应的目录是一一对应的\",{\"1\":{\"173\":1}}],[\"所生成的数据\",{\"1\":{\"112\":1}}],[\"所求出的\",{\"1\":{\"66\":1}}],[\"所有的运行时异常都继承自\",{\"1\":{\"231\":1}}],[\"所有包装类如下\",{\"0\":{\"193\":1}}],[\"所有其他类都是继承它的\",{\"1\":{\"181\":1}}],[\"所有被标记为静态的内容\",{\"1\":{\"171\":1}}],[\"所有可能动作的\",{\"1\":{\"48\":1}}],[\"所有状态的集合\",{\"1\":{\"19\":1}}],[\"所获得的均值\",{\"1\":{\"48\":1}}],[\"所得到的\",{\"1\":{\"40\":1}}],[\"所以只初始化了内部类\",{\"1\":{\"221\":1}}],[\"所以相对外部来说\",{\"1\":{\"219\":1}}],[\"所以可能不满足真实需求\",{\"1\":{\"202\":1}}],[\"所以说默认就可以直接使用\",{\"1\":{\"241\":1}}],[\"所以说只能使用\",{\"1\":{\"225\":1}}],[\"所以说里面也可以有成员变量\",{\"1\":{\"218\":1}}],[\"所以说int类型的数组时不能被object类型的数组变量接收的\",{\"1\":{\"204\":1}}],[\"所以说可以直接向上转型\",{\"1\":{\"201\":1}}],[\"所以说==判断为假\",{\"1\":{\"193\":1}}],[\"所以说两个不同的对象\",{\"1\":{\"193\":1}}],[\"所以说照着写就行了\",{\"1\":{\"186\":1}}],[\"所以说有些人说接口其实就是java中的多继承\",{\"1\":{\"185\":1}}],[\"所以说不能为私有\",{\"1\":{\"184\":1}}],[\"所以说判断结果为真\",{\"1\":{\"182\":1}}],[\"所以说我们需要明确指定\",{\"1\":{\"173\":1}}],[\"所以说我们在静态方法中\",{\"1\":{\"170\":1}}],[\"所以说没有包这个概念\",{\"1\":{\"173\":1}}],[\"所以说静态内容一定会在第一个对象初始化之前完成加载\",{\"1\":{\"171\":1}}],[\"所以说\",{\"1\":{\"170\":1,\"225\":1}}],[\"所以说直接就使用了\",{\"1\":{\"164\":1}}],[\"所以说使用void\",{\"1\":{\"162\":1}}],[\"所以\",{\"1\":{\"48\":1,\"201\":1}}],[\"所以状态其实共有\",{\"1\":{\"13\":1}}],[\"所以在无人机辅助通信网络中我们需要考虑qoe模型\",{\"1\":{\"10\":1}}],[\"else\",{\"1\":{\"233\":1}}],[\"elementwise\",{\"1\":{\"49\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"error错误比异常更严重\",{\"1\":{\"231\":1}}],[\"equals\",{\"1\":{\"181\":1,\"182\":4,\"210\":1}}],[\"equation\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"45\":1,\"46\":2,\"49\":2,\"52\":1,\"58\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"euqals\",{\"1\":{\"181\":1}}],[\"euqation\",{\"1\":{\"47\":1}}],[\"enum<com\",{\"1\":{\"187\":1}}],[\"enum表示这是一个枚举类\",{\"1\":{\"187\":1}}],[\"enum\",{\"1\":{\"187\":2}}],[\"entity\",{\"1\":{\"173\":5,\"174\":1,\"221\":3,\"222\":2}}],[\"environment\",{\"1\":{\"19\":2}}],[\"e+γvπ​\",{\"1\":{\"113\":1}}],[\"eplison\",{\"0\":{\"85\":1}}],[\"episodestartingfrom\",{\"1\":{\"81\":4}}],[\"episodes\",{\"1\":{\"78\":1,\"82\":2,\"84\":2}}],[\"episode\",{\"0\":{\"81\":1},\"1\":{\"19\":2,\"78\":2,\"81\":6,\"82\":1,\"84\":1,\"86\":1,\"137\":1}}],[\"efficient\",{\"1\":{\"81\":1}}],[\"every\",{\"1\":{\"81\":2}}],[\"evaluation\",{\"1\":{\"23\":2,\"45\":1,\"47\":1,\"66\":1,\"70\":1,\"79\":1,\"82\":1}}],[\"es\",{\"1\":{\"212\":1}}],[\"estimation\",{\"0\":{\"99\":1,\"103\":1,\"132\":1},\"1\":{\"75\":2,\"77\":1,\"82\":1,\"92\":1}}],[\"es∼η\",{\"1\":{\"26\":1}}],[\"e\",{\"1\":{\"43\":2,\"44\":4,\"48\":2,\"75\":1,\"94\":1,\"98\":2,\"99\":3,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"212\":2,\"234\":8}}],[\"exception\",{\"1\":{\"231\":4,\"232\":3,\"233\":3}}],[\"excellent\",{\"1\":{\"10\":1}}],[\"extends\",{\"1\":{\"184\":1,\"185\":2,\"186\":1,\"187\":1,\"232\":2}}],[\"exam\",{\"1\":{\"182\":2,\"184\":2}}],[\"expression\",{\"1\":{\"212\":1}}],[\"exploration\",{\"1\":{\"87\":1}}],[\"exploring\",{\"0\":{\"80\":1,\"83\":1,\"84\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1,\"88\":1}}],[\"exploitation\",{\"1\":{\"87\":1}}],[\"exponentially\",{\"1\":{\"58\":1}}],[\"expected\",{\"0\":{\"118\":1},\"1\":{\"40\":1}}],[\"expection\",{\"1\":{\"40\":1,\"113\":1,\"133\":1,\"136\":1}}],[\"experience\",{\"0\":{\"10\":1},\"1\":{\"4\":1,\"80\":1,\"112\":1,\"116\":1}}],[\"existence\",{\"1\":{\"58\":1}}],[\"测试阶段\",{\"1\":{\"14\":1}}],[\"训练阶段\",{\"1\":{\"14\":1}}],[\"与策略\",{\"1\":{\"152\":2}}],[\"与\",{\"0\":{\"41\":1,\"70\":1,\"114\":1},\"1\":{\"41\":1,\"68\":1,\"79\":1,\"124\":1}}],[\"与基于q\",{\"1\":{\"14\":1}}],[\"与k\",{\"1\":{\"5\":1}}],[\"基于函数表示的策略\",{\"1\":{\"148\":1}}],[\"基于函数的\",{\"1\":{\"130\":1}}],[\"基于策略\",{\"1\":{\"135\":1}}],[\"基于给定策略下\",{\"1\":{\"134\":1}}],[\"基于表格的\",{\"1\":{\"130\":1}}],[\"基于q\",{\"1\":{\"14\":1}}],[\"基本定义是\",{\"1\":{\"220\":1}}],[\"基本上不会用到\",{\"1\":{\"220\":1}}],[\"基本类型\",{\"1\":{\"209\":1}}],[\"基本类型包装类\",{\"0\":{\"192\":1}}],[\"基本类型的比较跟之前一样\",{\"1\":{\"182\":1}}],[\"基本思路\",{\"0\":{\"148\":1}}],[\"基本形式\",{\"0\":{\"55\":1}}],[\"基本概念\",{\"0\":{\"17\":1,\"19\":1}}],[\"基本设置\",{\"0\":{\"8\":1}}],[\"后面加上花括号\",{\"1\":{\"222\":1}}],[\"后面的表达式判断结果为\",{\"1\":{\"235\":1}}],[\"后面的\",{\"1\":{\"173\":1}}],[\"后\",{\"1\":{\"48\":1,\"82\":2}}],[\"后续可能是未知的\",{\"1\":{\"45\":1}}],[\"后四个方向\",{\"1\":{\"14\":1}}],[\"后退\",{\"1\":{\"13\":1}}],[\"前\",{\"1\":{\"14\":1}}],[\"前进\",{\"1\":{\"13\":1}}],[\"右\",{\"1\":{\"14\":1}}],[\"右转\",{\"1\":{\"13\":1}}],[\"world\",{\"1\":{\"210\":6}}],[\"worker\",{\"1\":{\"184\":2}}],[\"www\",{\"1\":{\"173\":1,\"212\":1}}],[\"wt+1​=wt​+αt​n1​i=1∑n​\",{\"1\":{\"142\":1}}],[\"wt​=w\",{\"1\":{\"142\":1}}],[\"wt​\",{\"1\":{\"136\":2,\"137\":2,\"138\":4,\"139\":3,\"140\":3,\"142\":10}}],[\"wait\",{\"1\":{\"181\":3}}],[\"wargmin​j\",{\"1\":{\"101\":1}}],[\"walk\",{\"1\":{\"14\":2}}],[\"w−e\",{\"1\":{\"99\":1,\"110\":1}}],[\"w∗\",{\"1\":{\"98\":2}}],[\"w∈r\",{\"1\":{\"96\":1}}],[\"w\",{\"1\":{\"96\":3,\"97\":2,\"98\":3,\"99\":5,\"101\":5,\"104\":15,\"110\":4,\"131\":1,\"132\":1,\"133\":2,\"134\":3,\"135\":3,\"136\":6,\"141\":3,\"142\":21,\"212\":1}}],[\"wk−1​\",{\"1\":{\"98\":1}}],[\"wk​−\",{\"1\":{\"110\":1}}],[\"wk​−xk​\",{\"1\":{\"94\":2,\"99\":1}}],[\"wk​\",{\"1\":{\"97\":6,\"98\":1,\"99\":1,\"101\":6,\"104\":12,\"110\":1,\"136\":1}}],[\"wk​+xk​\",{\"1\":{\"94\":1}}],[\"wk​=k−11​i=1∑k−1​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​=wk​+αk​\",{\"1\":{\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1}}],[\"wk+1​=wk​−αk​g~​\",{\"1\":{\"110\":1}}],[\"wk+1​=wk​−αk​g​\",{\"1\":{\"99\":1,\"104\":1}}],[\"wk+1​=wk​−αk​e\",{\"1\":{\"104\":1}}],[\"wk+1​=wk​−αk​▽w​j\",{\"1\":{\"136\":1}}],[\"wk+1​=wk​−αk​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​▽w​e\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−αk​n1​i=1∑n​▽w​f\",{\"1\":{\"101\":1}}],[\"wk+1​=wk​−ak​g​\",{\"1\":{\"97\":1}}],[\"wk+1​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"wk+1​=k1​i=1∑k​xi​\",{\"1\":{\"94\":1}}],[\"wk+1​​=k1​∑i=1k​xi​​=k1​\",{\"1\":{\"94\":1}}],[\"wk+1​可以由wk​推导出来\",{\"1\":{\"94\":1}}],[\"why\",{\"0\":{\"47\":1}}],[\"where\",{\"1\":{\"46\":1,\"58\":1}}],[\"when\",{\"1\":{\"19\":1}}],[\"with\",{\"0\":{\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"10\":1,\"19\":2,\"98\":1}}],[\"wireless\",{\"1\":{\"4\":1}}],[\"如梯度上升算法\",{\"1\":{\"148\":1}}],[\"如\",{\"1\":{\"79\":1,\"82\":1,\"161\":1}}],[\"如何估计\",{\"0\":{\"78\":1}}],[\"如何将\",{\"1\":{\"76\":1}}],[\"如何在没有模型\",{\"1\":{\"75\":1}}],[\"如何确保策略\",{\"1\":{\"68\":1}}],[\"如何通过\",{\"1\":{\"68\":1}}],[\"如何处理等式右边的\",{\"0\":{\"57\":1}}],[\"如何求解\",{\"0\":{\"56\":1}}],[\"如何得到最优策略\",{\"1\":{\"53\":1}}],[\"如可以在target\",{\"1\":{\"19\":1}}],[\"如果大于10就抛出错误\",{\"1\":{\"235\":1}}],[\"如果判断失败会抛出错误\",{\"1\":{\"235\":1}}],[\"如果已经是主方法了\",{\"1\":{\"234\":1}}],[\"如果某个方法明确指出会抛出哪些异常\",{\"1\":{\"234\":1}}],[\"如果某个类中存在静态方法或是静态变量\",{\"1\":{\"174\":1}}],[\"如果父类中的方法表明了会抛出某个异常\",{\"1\":{\"233\":1}}],[\"如果父类的方法是\",{\"1\":{\"182\":1}}],[\"如果传入了错误的参数导致程序无法正常运行\",{\"1\":{\"233\":1}}],[\"如果传入的对象为null\",{\"1\":{\"182\":1}}],[\"如果不同的分支条件会出现不同的异常\",{\"1\":{\"233\":1}}],[\"如果不进行处理\",{\"1\":{\"231\":1}}],[\"如果不是\",{\"1\":{\"223\":1}}],[\"如果参数只有一个\",{\"1\":{\"224\":1}}],[\"如果有一个参数和返回值的话\",{\"1\":{\"224\":1}}],[\"如果有初始值\",{\"1\":{\"183\":1}}],[\"如果一个方法的参数需要的是一个接口的实现\",{\"1\":{\"224\":1}}],[\"如果一个接口中有且只有一个待实现的抽象方法\",{\"1\":{\"224\":1}}],[\"如果一个包中有多个类\",{\"1\":{\"173\":1}}],[\"如果修改了a\",{\"1\":{\"223\":1}}],[\"如果想用外部变量\",{\"1\":{\"223\":1}}],[\"如果想通过对象的形式去使用他们\",{\"1\":{\"192\":1}}],[\"如果需要指定为外部的对象\",{\"1\":{\"218\":2}}],[\"如果需要完整学习正则表达式\",{\"1\":{\"212\":1}}],[\"如果需要使用更大的数组\",{\"1\":{\"202\":1}}],[\"如果直接使用加的话\",{\"1\":{\"211\":1}}],[\"如果程序中大量进行字符串的拼接似乎不太好\",{\"1\":{\"211\":1}}],[\"如果我们要捕获的异常\",{\"1\":{\"234\":1}}],[\"如果我们要使用成员内部类\",{\"1\":{\"218\":1}}],[\"如果我们确实不想在当前这个方法中进行处理\",{\"1\":{\"234\":1}}],[\"如果我们在方法中抛出了一个非运行时异常\",{\"1\":{\"233\":1}}],[\"如果我们想直接作为接口抽象方法的实现\",{\"1\":{\"224\":1}}],[\"如果我们想要表示一个范围内的字符\",{\"1\":{\"212\":1}}],[\"如果我们我们将其权限改为private\",{\"1\":{\"218\":1}}],[\"如果我们仅仅是想要判断两个字符串的内容是否相同\",{\"1\":{\"210\":1}}],[\"如果我们强制让\",{\"1\":{\"124\":1}}],[\"如果内容相同\",{\"1\":{\"210\":1}}],[\"如果同时存在其他参数\",{\"1\":{\"207\":1}}],[\"如果在范围内\",{\"1\":{\"193\":1}}],[\"如果值相同\",{\"1\":{\"193\":1}}],[\"如果方法体中只有一个返回语句\",{\"1\":{\"224\":1}}],[\"如果方法在接口中存在默认实现\",{\"1\":{\"185\":1}}],[\"如果方法内没有变量出现重名的情况\",{\"1\":{\"164\":1}}],[\"如果抽象方法在抽象类定义的是\",{\"1\":{\"184\":1}}],[\"如果子类都访问不了\",{\"1\":{\"184\":1}}],[\"如果希望调用父类原本的方法实现\",{\"1\":{\"182\":1}}],[\"如果没有出现歧义\",{\"1\":{\"173\":1}}],[\"如果是普通成员方法\",{\"1\":{\"225\":1}}],[\"如果是直接使用双引号创建的字符串\",{\"1\":{\"210\":1}}],[\"如果是基本数据类型\",{\"1\":{\"201\":1}}],[\"如果是基本类型\",{\"1\":{\"161\":1}}],[\"如果是多个单词\",{\"1\":{\"162\":1}}],[\"如果是引用类型\",{\"1\":{\"161\":1,\"201\":1}}],[\"如果是boolean的话\",{\"1\":{\"161\":1}}],[\"如果\",{\"1\":{\"96\":1,\"235\":1}}],[\"如果对于\",{\"1\":{\"96\":1}}],[\"如果ϵ=1\",{\"1\":{\"87\":1}}],[\"如果经过了\",{\"1\":{\"84\":1}}],[\"如果从其他状态出发\",{\"1\":{\"84\":1}}],[\"如果存在一个\",{\"1\":{\"84\":1}}],[\"如果该\",{\"1\":{\"81\":1}}],[\"如果γ接近0\",{\"1\":{\"19\":1}}],[\"如果agent在当前时刻t所执行的动作能够提高总mos\",{\"1\":{\"13\":1}}],[\"如p\",{\"1\":{\"19\":1}}],[\"如a\",{\"1\":{\"14\":1}}],[\"需考虑用户的移动性\",{\"1\":{\"14\":1}}],[\"需要由子类来完成\",{\"1\":{\"184\":1}}],[\"需要先进行导入才可以\",{\"1\":{\"173\":1}}],[\"需要在类的最上面添加package关键字来指明当前类所处的包\",{\"1\":{\"173\":1}}],[\"需要通过关键字\",{\"1\":{\"173\":2}}],[\"需要通过采样解决\",{\"1\":{\"45\":1}}],[\"需要考虑怎样对状态进行平均\",{\"1\":{\"133\":1}}],[\"需要求解一个优化问题\",{\"1\":{\"101\":1}}],[\"需要从\",{\"1\":{\"77\":1}}],[\"需要初始化猜测的\",{\"1\":{\"70\":1}}],[\"需要初始化策略π0​\",{\"1\":{\"70\":1}}],[\"需要确定几件事\",{\"1\":{\"53\":1}}],[\"需要推导e\",{\"1\":{\"42\":1}}],[\"需要调整相应无人机的高度\",{\"1\":{\"9\":1}}],[\"需要合理选择无人机n的垂直高度hn​\",{\"1\":{\"9\":1}}],[\"∑s∈s​d\",{\"1\":{\"150\":1}}],[\"∑s∈s​dπ​\",{\"1\":{\"135\":1}}],[\"∑k=1∞​ak2​=∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak2​<∞\",{\"1\":{\"98\":1}}],[\"∑k=1∞​ak​=∞\",{\"1\":{\"98\":1}}],[\"∑kn​=1kn​​pkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"∑i=1k−1​xi​+xk​\",{\"1\":{\"94\":1}}],[\"∑​pπ​\",{\"1\":{\"46\":1}}],[\"∑​p\",{\"1\":{\"44\":2,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2,\"77\":1,\"113\":1}}],[\"∑​vπ​\",{\"1\":{\"44\":2}}],[\"∑​e\",{\"1\":{\"44\":3}}],[\"∑n=1n​∣kn​∣是总用户数\",{\"1\":{\"14\":1}}],[\"则等价于\",{\"1\":{\"212\":1}}],[\"则表示只能赋一次值\",{\"1\":{\"183\":1}}],[\"则只是进行一次带入求解\",{\"1\":{\"70\":1}}],[\"则是对多个\",{\"1\":{\"41\":1}}],[\"则总动作空间的大小为7+2n∑n=1n​∣kn​∣会导致动作空间过大\",{\"1\":{\"14\":1}}],[\"则用户的关联动作数为2n∑n=1n​∣kn​∣\",{\"1\":{\"14\":1}}],[\"则无人机将获得正奖励\",{\"1\":{\"13\":1}}],[\"设\",{\"1\":{\"135\":1,\"137\":1}}],[\"设置为\",{\"1\":{\"27\":1}}],[\"设无人机总数为n\",{\"1\":{\"14\":1}}],[\"设计一种基于\",{\"1\":{\"5\":2}}],[\"对其进行修改\",{\"1\":{\"166\":1}}],[\"对象再多\",{\"1\":{\"170\":1}}],[\"对象在创建之后\",{\"1\":{\"166\":1}}],[\"对象创建成功之后\",{\"1\":{\"161\":1}}],[\"对象实例的创建\",{\"1\":{\"161\":1}}],[\"对象\",{\"0\":{\"218\":1},\"1\":{\"161\":1,\"216\":1,\"225\":2}}],[\"对应关系如下表\",{\"1\":{\"193\":1}}],[\"对应多个文件夹\",{\"1\":{\"173\":1}}],[\"对应目标函数的真实梯度是\",{\"1\":{\"136\":1}}],[\"对应收敛性证明\",{\"1\":{\"104\":1}}],[\"对应一个向量\",{\"1\":{\"58\":1}}],[\"对应策略表示为\",{\"1\":{\"57\":1}}],[\"对应的vk+1​\",{\"1\":{\"63\":1}}],[\"对应的动作\",{\"1\":{\"57\":1}}],[\"对应的\",{\"1\":{\"42\":2,\"46\":1,\"66\":1,\"94\":1,\"116\":1}}],[\"对应的discounted\",{\"1\":{\"39\":1}}],[\"对应算法\",{\"0\":{\"28\":1}}],[\"对应\",{\"1\":{\"23\":2,\"154\":1}}],[\"对应状态中所有可选择的动作集合\",{\"1\":{\"19\":1}}],[\"对应s就是uav的部署位置\",{\"1\":{\"13\":1}}],[\"对于已经实现的方法\",{\"1\":{\"224\":1}}],[\"对于这种成员内部类\",{\"1\":{\"218\":1}}],[\"对于这个问题\",{\"1\":{\"101\":1}}],[\"对于普通字符来说\",{\"1\":{\"212\":1}}],[\"对于变量来说\",{\"1\":{\"211\":1}}],[\"对于基本类型的数组来说\",{\"1\":{\"204\":1}}],[\"对于需要精确计算的场景\",{\"1\":{\"195\":1}}],[\"对于非常大的整数计算\",{\"1\":{\"195\":1}}],[\"对于引用类型\",{\"1\":{\"186\":1}}],[\"对于类中基本数据类型\",{\"1\":{\"186\":1}}],[\"对于人类的不同子类\",{\"1\":{\"185\":1}}],[\"对于成员方法\",{\"1\":{\"183\":1}}],[\"对于成员变量\",{\"1\":{\"183\":1}}],[\"对于对象而言\",{\"1\":{\"161\":1}}],[\"对于策略\",{\"1\":{\"113\":1}}],[\"对于观测值g​\",{\"1\":{\"104\":1}}],[\"对于函数\",{\"1\":{\"101\":1}}],[\"对于一个\",{\"1\":{\"81\":1}}],[\"对于贝尔曼最优公式而言\",{\"1\":{\"55\":1,\"56\":1}}],[\"对于\",{\"1\":{\"48\":1,\"70\":3,\"77\":2,\"79\":1,\"81\":1,\"88\":1,\"130\":1,\"142\":1,\"223\":1}}],[\"对于所有状态s\",{\"1\":{\"46\":1}}],[\"对于不同的策略\",{\"1\":{\"40\":1}}],[\"对于每个\",{\"1\":{\"81\":1}}],[\"对于每个智能体\",{\"1\":{\"13\":1}}],[\"对于每一个状态\",{\"1\":{\"19\":1}}],[\"对于动作空间而言\",{\"1\":{\"14\":1}}],[\"对于用户kn​存在特定的信噪比目标γkn​​\",{\"1\":{\"9\":1}}],[\"对于用户kn​∈kn​\",{\"1\":{\"8\":1}}],[\"对于无人机的总发射功率也均匀地分配给每个用户\",{\"1\":{\"9\":1}}],[\"对于无人机n\",{\"1\":{\"8\":1,\"9\":1}}],[\"对于指定区域\",{\"1\":{\"8\":1}}],[\"值还是可以修改\",{\"1\":{\"205\":1}}],[\"值函数近似\",{\"0\":{\"130\":1}}],[\"值迭代和策略迭代\",{\"0\":{\"61\":1}}],[\"值的估计通过一个网络来进行描述\",{\"1\":{\"23\":1}}],[\"值\",{\"1\":{\"13\":1}}],[\"最后再提一下\",{\"1\":{\"233\":1}}],[\"最后面分号可以不打\",{\"1\":{\"187\":1}}],[\"最近的是参数\",{\"1\":{\"218\":1}}],[\"最少匹配\",{\"1\":{\"212\":1}}],[\"最好是一个域名的格式\",{\"1\":{\"173\":1}}],[\"最好的\",{\"0\":{\"27\":1}}],[\"最优的策略\",{\"1\":{\"148\":1}}],[\"最优策略\",{\"0\":{\"57\":1}}],[\"最优策略是\",{\"1\":{\"53\":1}}],[\"最优策略是否唯一\",{\"1\":{\"53\":1}}],[\"最优策略是否存在\",{\"1\":{\"53\":1}}],[\"最优策略的定义\",{\"1\":{\"53\":1}}],[\"最接近真实的vπ​\",{\"1\":{\"132\":1}}],[\"最大的\",{\"1\":{\"77\":1,\"79\":1}}],[\"最大的q\",{\"1\":{\"13\":1}}],[\"最简单的示例算法\",{\"1\":{\"76\":1}}],[\"最终到\",{\"1\":{\"234\":1}}],[\"最终会达到一个平稳的状态\",{\"1\":{\"135\":1}}],[\"最终优化的策略\",{\"1\":{\"121\":1}}],[\"最终可以证明\",{\"1\":{\"47\":1}}],[\"最终输出结果\",{\"1\":{\"13\":1}}],[\"最终输出的结果\",{\"1\":{\"13\":1}}],[\"当代码可能出现多种类型的异常时\",{\"1\":{\"234\":1}}],[\"当程序没有按照我们理想的样子运行而出现异常时\",{\"1\":{\"234\":1}}],[\"当别人调用我们的方法时\",{\"1\":{\"233\":1}}],[\"当你使用内部类静态方法\",{\"1\":{\"221\":1}}],[\"当我们字符串编辑完成之后\",{\"1\":{\"211\":1}}],[\"当我们使用同一个包中的类时\",{\"1\":{\"173\":1}}],[\"当前数组长度为\",{\"1\":{\"202\":1}}],[\"当前类\",{\"1\":{\"174\":1}}],[\"当对象被判定为已经不再使用的\",{\"1\":{\"181\":1}}],[\"当然前提是方法定义\",{\"1\":{\"225\":1}}],[\"当然\",{\"1\":{\"164\":1,\"166\":3,\"173\":2,\"184\":1,\"212\":1,\"222\":1,\"234\":1}}],[\"当策略是以函数的形式存在时\",{\"1\":{\"148\":1}}],[\"当策略是以表格的形式保存时\",{\"1\":{\"148\":1}}],[\"当a为静止时\",{\"1\":{\"13\":1}}],[\"当执行动作at​时\",{\"1\":{\"13\":1}}],[\"发现对于\",{\"1\":{\"184\":1}}],[\"发现在该位置静止是最优的\",{\"1\":{\"13\":1}}],[\"发送端的时间\",{\"1\":{\"10\":1}}],[\"不然就无法通过编译\",{\"1\":{\"234\":1}}],[\"不见当年倒茶人\",{\"1\":{\"225\":1}}],[\"不是静态方法\",{\"1\":{\"225\":1}}],[\"不是基本类型\",{\"1\":{\"193\":1}}],[\"不支持抽象类\",{\"1\":{\"224\":1}}],[\"不会调用外部类的\",{\"1\":{\"221\":1}}],[\"不会影响所求的梯度\",{\"1\":{\"26\":1}}],[\"不包括换行\",{\"1\":{\"212\":1}}],[\"不要使用\",{\"1\":{\"210\":1}}],[\"不允许\",{\"1\":{\"205\":1}}],[\"不允许进行修改\",{\"1\":{\"202\":1}}],[\"不需要声明访问权限\",{\"1\":{\"220\":1}}],[\"不需要依附任何对象\",{\"1\":{\"219\":1}}],[\"不需要\",{\"1\":{\"193\":1,\"219\":1}}],[\"不过没必要\",{\"1\":{\"210\":1}}],[\"不过可以省略\",{\"1\":{\"185\":1}}],[\"不过如果子类也是抽象类\",{\"1\":{\"184\":1}}],[\"不能直接通过\",{\"1\":{\"222\":1}}],[\"不能直接创建对象\",{\"1\":{\"185\":1}}],[\"不能匹配\",{\"1\":{\"212\":2}}],[\"不能随便进行修改\",{\"1\":{\"202\":1}}],[\"不能\",{\"1\":{\"195\":1}}],[\"不能使用默认\",{\"1\":{\"185\":1}}],[\"不能使用==\",{\"1\":{\"182\":1}}],[\"不能是\",{\"1\":{\"184\":1}}],[\"不能用同一个q\",{\"1\":{\"13\":1}}],[\"不同包下的类\",{\"1\":{\"174\":1}}],[\"不同包下的子类\",{\"1\":{\"174\":1}}],[\"不同的访问权限\",{\"1\":{\"174\":1}}],[\"不同的无人机agent的q\",{\"1\":{\"13\":1}}],[\"不同类的重名问题\",{\"1\":{\"173\":1}}],[\"不同对象的属性是分开独立存放的\",{\"1\":{\"161\":1}}],[\"不太一样\",{\"1\":{\"144\":1}}],[\"不用进行求导\",{\"1\":{\"142\":1}}],[\"不记录\",{\"1\":{\"81\":1}}],[\"不动点x∗是唯一的\",{\"1\":{\"58\":1}}],[\"不常用\",{\"1\":{\"47\":1}}],[\"还没学异常\",{\"1\":{\"186\":1}}],[\"还可以定义一些方法来描述同一类的行为\",{\"1\":{\"162\":1}}],[\"还可以估计q\",{\"1\":{\"81\":1}}],[\"还需要求解最优策略π\",{\"1\":{\"55\":1}}],[\"还需要考虑所有用户的2d位置\",{\"1\":{\"14\":1}}],[\"还是\",{\"1\":{\"53\":1,\"75\":1,\"92\":1}}],[\"还是同一张q\",{\"1\":{\"13\":1}}],[\"还与los的概率有关\",{\"1\":{\"13\":1}}],[\"但它继承自一个现有的类或实现了一个接口\",{\"1\":{\"222\":1}}],[\"但类名必须与接口一致\",{\"1\":{\"222\":1}}],[\"但我们可以在方法中使用匿名内部类\",{\"1\":{\"222\":1}}],[\"但能匹配\",{\"1\":{\"212\":1}}],[\"但能否保证其精确度\",{\"1\":{\"101\":1}}],[\"但不一定会导致致命的问题\",{\"1\":{\"231\":1}}],[\"但不能匹配\",{\"1\":{\"212\":1}}],[\"但不推荐\",{\"1\":{\"201\":1}}],[\"但不支持\",{\"1\":{\"195\":1}}],[\"但对象中的属性都是同一个地址\",{\"1\":{\"186\":1}}],[\"但对于\",{\"1\":{\"142\":1}}],[\"但还是先初始化内部类\",{\"1\":{\"221\":1}}],[\"但还未复制\",{\"1\":{\"166\":1}}],[\"但还存在\",{\"1\":{\"156\":1}}],[\"但是要注意一下顺序\",{\"1\":{\"234\":1}}],[\"但是必须保证其他方法有默认实现\",{\"1\":{\"224\":1}}],[\"但是可以直接new了\",{\"1\":{\"219\":1}}],[\"但是可以存在静态变量和静态方法\",{\"1\":{\"185\":1}}],[\"但是能匹配\",{\"1\":{\"212\":1}}],[\"但是拼接字符串实际上底层需要进行很多操作\",{\"1\":{\"211\":1}}],[\"但是如果我们使用构造方法主动创建两个新的对象\",{\"1\":{\"210\":1}}],[\"但是如果我们在运行时\",{\"1\":{\"208\":1}}],[\"但是如果是引用类型的话\",{\"1\":{\"204\":1}}],[\"但是如果超出这个缓存范围的话\",{\"1\":{\"193\":1}}],[\"但是\",{\"1\":{\"202\":1}}],[\"但是只能在定义时赋值\",{\"1\":{\"201\":1}}],[\"但是编程不可见\",{\"1\":{\"201\":1}}],[\"但是biginteger没有这些限制\",{\"1\":{\"195\":1}}],[\"但是各位小伙伴只需要知道\",{\"1\":{\"193\":1}}],[\"但是并不是同一个对象\",{\"1\":{\"193\":1}}],[\"但是java中的基本数据类型却不是面向对象的\",{\"1\":{\"192\":1}}],[\"但是它继承自enum类\",{\"1\":{\"187\":1}}],[\"但是推荐打上\",{\"1\":{\"187\":1}}],[\"但是像这样的拷贝操作其实也分为浅拷贝和深拷贝\",{\"1\":{\"186\":1}}],[\"但是我个人认为这种说法是错的\",{\"1\":{\"185\":1}}],[\"但是我们也可以将接口实现类的对象以接口的形式去使用\",{\"1\":{\"185\":1}}],[\"但是我们发现\",{\"1\":{\"166\":1}}],[\"但是我们前面说了\",{\"1\":{\"161\":1}}],[\"但是同样需要有访问权限的情况下才可以\",{\"1\":{\"174\":1}}],[\"但是现在\",{\"1\":{\"173\":1}}],[\"但是静态方法是可以访问到静态变量的\",{\"1\":{\"170\":1}}],[\"但是仅返回类型不同\",{\"1\":{\"165\":1}}],[\"但是需要的形式参数不一样\",{\"1\":{\"165\":1}}],[\"但是当前作用域下只有对象属性的name变量\",{\"1\":{\"164\":1}}],[\"但是规则跟变量的命名差不多\",{\"1\":{\"162\":1}}],[\"但在发表\",{\"1\":{\"144\":1}}],[\"但这里还有一个难点\",{\"1\":{\"136\":1}}],[\"但实际上还是在调用本身的方法\",{\"1\":{\"182\":1}}],[\"但实际上我们往往是选择一个非常小的常数\",{\"1\":{\"98\":1}}],[\"但实际情况可能并不是所有状态的概率都是一致的\",{\"1\":{\"134\":1}}],[\"但需要大量的\",{\"1\":{\"101\":1}}],[\"但由于\",{\"1\":{\"101\":1}}],[\"但目前无法保证\",{\"1\":{\"84\":1}}],[\"但存在一定的浪费\",{\"1\":{\"81\":1}}],[\"但现实场景中不太经常使用\",{\"1\":{\"76\":1}}],[\"但若考虑集群情况\",{\"1\":{\"14\":1}}],[\"但每个无人机所管理的用户不同\",{\"1\":{\"13\":1}}],[\"但即使仅考虑用户聚类\",{\"1\":{\"13\":1}}],[\"否则报错\",{\"1\":{\"234\":1}}],[\"否则我们必须要使用\",{\"1\":{\"234\":1}}],[\"否则返回false\",{\"1\":{\"212\":1}}],[\"否则会无法通过编译\",{\"1\":{\"184\":1}}],[\"否则要创建这个类的对象\",{\"1\":{\"166\":1}}],[\"否则\",{\"1\":{\"13\":1}}],[\"奖励\",{\"1\":{\"13\":1,\"19\":1}}],[\"并在控制台打印栈追踪信息\",{\"1\":{\"234\":1}}],[\"并直接创建实例对象\",{\"1\":{\"222\":1}}],[\"并没有初始化内部类\",{\"1\":{\"221\":1}}],[\"并返回一个新的子串对象\",{\"1\":{\"210\":1}}],[\"并根据实际需求扩展出新的行为\",{\"1\":{\"178\":1}}],[\"并提供对外访问的接口\",{\"1\":{\"178\":1}}],[\"并不编写方法的主体\",{\"1\":{\"184\":1}}],[\"并不会在一开始就去加载它\",{\"1\":{\"171\":1}}],[\"并不是说只有抽象类和接口才可以像这样创建匿名内部类\",{\"1\":{\"222\":1}}],[\"并不是基本数据类型\",{\"1\":{\"201\":1}}],[\"并不是在构造方法之后\",{\"1\":{\"166\":1}}],[\"并不是一直进行更新\",{\"1\":{\"142\":1}}],[\"并非是所对应的对象本身\",{\"1\":{\"161\":1}}],[\"并非只是一个单一的轨迹\",{\"1\":{\"19\":1}}],[\"并且接口没有继承数量限制\",{\"1\":{\"185\":1}}],[\"并且默认在类中实现的权限是\",{\"1\":{\"185\":1}}],[\"并且也导入了我们自己定义的string类\",{\"1\":{\"173\":1}}],[\"并且方法名称与类名相同\",{\"1\":{\"166\":2}}],[\"并且如果按照这样一个策略\",{\"1\":{\"86\":1}}],[\"并且与状态\",{\"1\":{\"48\":1}}],[\"并获得奖励rt​的这一过程可以用条件转移概率p\",{\"1\":{\"13\":1}}],[\"并与传统的基于遗传的学习算法进行对比\",{\"1\":{\"5\":1}}],[\"左转\",{\"1\":{\"13\":1}}],[\"共两步\",{\"1\":{\"132\":1}}],[\"共分为\",{\"1\":{\"63\":1}}],[\"共考虑7个方向\",{\"1\":{\"13\":1}}],[\"共划分5个等级\",{\"1\":{\"10\":1}}],[\"按照所给定策略j来执行一个动作at​∈a从而获得奖励rt​以及下一个状态st+1​\",{\"1\":{\"13\":1}}],[\"个类型的实参\",{\"1\":{\"207\":1}}],[\"个样本\",{\"1\":{\"142\":1}}],[\"个人推导\",{\"1\":{\"44\":1}}],[\"个人感觉是这个\",{\"1\":{\"13\":1}}],[\"个人理解\",{\"1\":{\"13\":1,\"19\":1}}],[\"个\",{\"1\":{\"13\":1}}],[\"×\",{\"1\":{\"13\":2}}],[\"0xa6\",{\"1\":{\"194\":1}}],[\"0<c1​≤▽w​g\",{\"1\":{\"98\":1}}],[\"0\",{\"1\":{\"13\":17,\"14\":1,\"19\":1,\"47\":1,\"87\":1,\"104\":1,\"166\":1,\"203\":1,\"205\":1,\"207\":1,\"210\":1,\"212\":5,\"233\":1,\"241\":1,\"242\":1}}],[\"0≤t≤ts​\",{\"1\":{\"8\":2,\"11\":2}}],[\"状态s时可以得到的平均reward\",{\"1\":{\"153\":1}}],[\"状态转换\",{\"1\":{\"19\":1}}],[\"状态转换模型\",{\"1\":{\"13\":1}}],[\"状态除了要考虑无人机的3d位置外\",{\"1\":{\"14\":1}}],[\"状态空间\",{\"1\":{\"13\":1,\"19\":1}}],[\"状态\",{\"1\":{\"13\":1,\"19\":1,\"135\":1,\"142\":1,\"187\":1}}],[\"智能体\",{\"1\":{\"13\":1}}],[\"来处理\",{\"1\":{\"234\":1}}],[\"来实现\",{\"1\":{\"184\":1}}],[\"来完成\",{\"1\":{\"166\":1}}],[\"来明确表示当前类的示例对象本身\",{\"1\":{\"164\":1}}],[\"来定义最优的策略\",{\"1\":{\"148\":1}}],[\"来更新参数值\",{\"1\":{\"142\":1}}],[\"来近似\",{\"1\":{\"137\":1,\"138\":1}}],[\"来进行求解\",{\"1\":{\"77\":1}}],[\"来进行迭代\",{\"1\":{\"13\":1}}],[\"来提升当前策略\",{\"1\":{\"66\":1}}],[\"来保证这个梯度的方差最小即可\",{\"1\":{\"26\":1}}],[\"来表示\",{\"1\":{\"13\":1}}],[\"来最大化mos总和\",{\"1\":{\"13\":1}}],[\"来考虑无人机的机动性\",{\"1\":{\"4\":1}}],[\"划分完毕\",{\"1\":{\"13\":1}}],[\"再通过这些经验来不断改进更新另一个策略\",{\"1\":{\"123\":1}}],[\"再次出现\",{\"1\":{\"81\":1}}],[\"再将\",{\"1\":{\"77\":1}}],[\"再将用户划分给距离最近的无人机\",{\"1\":{\"13\":1}}],[\"再求平均值\",{\"1\":{\"41\":1}}],[\"再根据欧几里得距离重新划分\",{\"1\":{\"13\":1}}],[\"再找到新的簇的各中心\",{\"1\":{\"13\":1}}],[\"每一轮循环\",{\"1\":{\"203\":1}}],[\"每次运算都会生成一个新的对象\",{\"1\":{\"211\":1}}],[\"每次都是从对应的状态\",{\"1\":{\"84\":1}}],[\"每次迭代都会使得策略进行提升\",{\"1\":{\"68\":1}}],[\"每次无人机会根据当前状态st​∈s\",{\"1\":{\"13\":1}}],[\"每个对象中都有一个单独的类定义\",{\"1\":{\"218\":1}}],[\"每个对象都有这样的一个类定义\",{\"1\":{\"218\":1}}],[\"每个对象都有一个自己的空间\",{\"1\":{\"161\":1}}],[\"每个类可以创建一个对象\",{\"1\":{\"218\":1}}],[\"每个用双引号括起来的字符串\",{\"1\":{\"210\":1}}],[\"每个用户的移动方向均匀分布在左\",{\"1\":{\"14\":1}}],[\"每个用户都需要判断是否与每个无人机关联\",{\"1\":{\"14\":1}}],[\"每个用户只能属于一个集群\",{\"1\":{\"8\":1}}],[\"每个集群中无人机的最优位置也会发生变化\",{\"1\":{\"14\":1}}],[\"每架无人机的带宽和发射功率都均匀分配给每个用户\",{\"1\":{\"13\":1}}],[\"将抛出\",{\"1\":{\"235\":1}}],[\"将无法通过编译\",{\"1\":{\"231\":1}}],[\"将无人机部署在每个中心内\",{\"1\":{\"13\":1}}],[\"将其中的抽象方法实现\",{\"1\":{\"222\":1}}],[\"将其平均分配给其∣kn​∣个关联用户\",{\"1\":{\"9\":1}}],[\"将匹配\",{\"1\":{\"212\":1}}],[\"将匹配的子串替换或者从某个串中取出符合某个条件的子串等\",{\"1\":{\"212\":1}}],[\"将这些值提前做成包装类放在数组中存放\",{\"1\":{\"193\":1}}],[\"将int类型值作为包装类型使用\",{\"1\":{\"193\":1}}],[\"将当前对象转换为string的形式\",{\"1\":{\"181\":1}}],[\"将main类放到com\",{\"1\":{\"173\":1}}],[\"将基于表格表示的策略\",{\"1\":{\"148\":1}}],[\"将该网络的\",{\"1\":{\"142\":1}}],[\"将\",{\"1\":{\"58\":1,\"85\":1,\"142\":2}}],[\"将所有状态的\",{\"1\":{\"46\":1}}],[\"将处于\",{\"1\":{\"29\":1}}],[\"将对于\",{\"1\":{\"23\":1}}],[\"将对应的轨迹所获得的所有reward的总和\",{\"1\":{\"19\":1}}],[\"将上述优化问题简化\",{\"1\":{\"13\":1}}],[\"解决方案\",{\"0\":{\"12\":1}}],[\"水平位置和高度\",{\"1\":{\"11\":1}}],[\"数学工具类\",{\"0\":{\"241\":1}}],[\"数字\",{\"1\":{\"212\":1}}],[\"数组工具类\",{\"0\":{\"242\":1}}],[\"数组同样支持向上转型\",{\"1\":{\"204\":1}}],[\"数组的\",{\"1\":{\"202\":1}}],[\"数组大小\",{\"1\":{\"201\":2}}],[\"数组类型比较特殊\",{\"1\":{\"201\":1}}],[\"数组可以代表任何相同类型的一组内容\",{\"1\":{\"200\":1}}],[\"数组是相同类型数据的有序集合\",{\"1\":{\"200\":1}}],[\"数组\",{\"0\":{\"198\":1,\"200\":1}}],[\"数量和位置\",{\"1\":{\"11\":1}}],[\"数据包从发送端\",{\"1\":{\"10\":1}}],[\"因而也被称为实例\",{\"1\":{\"161\":1}}],[\"因为不这样就无法编译了\",{\"1\":{\"233\":1}}],[\"因为不需要\",{\"1\":{\"125\":1}}],[\"因为现在只需要一个string类型的返回值\",{\"1\":{\"225\":1}}],[\"因为integer类中默认提供了求两个int值之和的静态方法\",{\"1\":{\"225\":1}}],[\"因为匿名对象没有类名\",{\"1\":{\"222\":1}}],[\"因为它本质上就相当于是对应类型的子类\",{\"1\":{\"222\":1}}],[\"因为它作用范围就只是方法内\",{\"1\":{\"220\":1}}],[\"因为并没有使用到外部类的任何静态变量\",{\"1\":{\"221\":1}}],[\"因为成员内部类本身就是某个对象所有的\",{\"1\":{\"218\":1}}],[\"因为父类都是\",{\"1\":{\"204\":1}}],[\"因为同样是类\",{\"1\":{\"201\":1}}],[\"因为超出了缓存的范围\",{\"1\":{\"193\":1}}],[\"因为小的数使用频率非常高\",{\"1\":{\"193\":1}}],[\"因为包装类是一个类\",{\"1\":{\"193\":1}}],[\"因为底层是c++实现\",{\"1\":{\"186\":1}}],[\"因为其他类就算继承这个接口\",{\"1\":{\"185\":1}}],[\"因为其满足该理论\",{\"1\":{\"58\":1}}],[\"因为抽象方法一定要由子类实现\",{\"1\":{\"184\":1}}],[\"因为都直接在一个缺省的包中\",{\"1\":{\"173\":1}}],[\"因为this关键字代表的是当前的对象本身\",{\"1\":{\"170\":1}}],[\"因为静态方法属于类的\",{\"1\":{\"170\":1}}],[\"因为我们需要计算的是\",{\"1\":{\"155\":1}}],[\"因为在编译的时候\",{\"1\":{\"221\":1}}],[\"因为在\",{\"1\":{\"92\":1}}],[\"因为在不考虑用户自由穿梭集群的情况\",{\"1\":{\"14\":1}}],[\"因为最终策略更新的核心仍然是\",{\"1\":{\"79\":1}}],[\"因为\",{\"1\":{\"77\":1,\"104\":1,\"124\":1}}],[\"因为无论是\",{\"1\":{\"75\":1}}],[\"因为q\",{\"1\":{\"13\":1}}],[\"因为目标函数对于无人机的3d坐标是非凸的\",{\"1\":{\"11\":1}}],[\"因此可以直接调用\",{\"1\":{\"241\":1,\"242\":1}}],[\"因此可以考虑\",{\"1\":{\"136\":1}}],[\"因此只能使用类来进行定义\",{\"1\":{\"209\":1}}],[\"因此会读取命令行中的指令参数进行存储到\",{\"1\":{\"208\":1}}],[\"因此该指标可以描述为\",{\"1\":{\"150\":1}}],[\"因此左侧那个类似\",{\"1\":{\"142\":1}}],[\"因此对应的损失函数的梯度可以修改为\",{\"1\":{\"142\":1}}],[\"因此对应算法为\",{\"1\":{\"138\":1}}],[\"因此对于用户kn​的在时刻t的传输速率rkn​​\",{\"1\":{\"9\":1}}],[\"因此需要用近似算法来进行替代\",{\"1\":{\"136\":1}}],[\"因此采用这种\",{\"1\":{\"134\":1}}],[\"因此这种情况下的\",{\"1\":{\"134\":1}}],[\"因此不需要进行\",{\"1\":{\"120\":1}}],[\"因此我们不需要手动指定\",{\"1\":{\"173\":1}}],[\"因此我们需要保证对于所有的\",{\"1\":{\"155\":1}}],[\"因此我们用\",{\"1\":{\"137\":1}}],[\"因此我们可以通过\",{\"1\":{\"99\":1}}],[\"因此我们将优化问题简化为区域分割问题\",{\"1\":{\"13\":1}}],[\"因此是一个确定的贪心策略\",{\"1\":{\"88\":1}}],[\"因此是2n\",{\"1\":{\"14\":1}}],[\"因此随着用户位置的变化\",{\"1\":{\"14\":1}}],[\"因此mos不仅与欧氏距离有关\",{\"1\":{\"13\":1}}],[\"因此moskn​​delay\",{\"1\":{\"10\":1}}],[\"因此gak\",{\"1\":{\"13\":1}}],[\"因此\",{\"1\":{\"9\":2,\"10\":1,\"26\":1,\"42\":1,\"48\":1,\"58\":1,\"71\":1,\"94\":1,\"101\":1,\"104\":2,\"110\":1,\"113\":1,\"124\":1,\"210\":1,\"222\":2}}],[\"∀\",{\"1\":{\"116\":1,\"120\":1}}],[\"∀s\",{\"1\":{\"115\":1,\"119\":1}}],[\"∀s=st​\",{\"1\":{\"112\":1}}],[\"∀s∈s​\",{\"1\":{\"55\":1}}],[\"∀s∈s=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"∀s∈s\",{\"1\":{\"45\":1,\"58\":1}}],[\"∀kn​\",{\"1\":{\"11\":3,\"13\":3}}],[\"∀t\",{\"1\":{\"11\":4,\"13\":4}}],[\"∀n\",{\"1\":{\"11\":2,\"13\":2}}],[\"具体实现克隆\",{\"1\":{\"186\":1}}],[\"具体的实现由\",{\"1\":{\"184\":1}}],[\"具体而言\",{\"1\":{\"162\":1}}],[\"具体推导过程\",{\"1\":{\"155\":1}}],[\"具体解决如下\",{\"1\":{\"97\":1}}],[\"具体求解方法\",{\"1\":{\"79\":1}}],[\"具体算法\",{\"0\":{\"79\":1}}],[\"具体步骤\",{\"0\":{\"63\":1}}],[\"具体分两步\",{\"1\":{\"56\":1}}],[\"具体代码\",{\"1\":{\"13\":1}}],[\"具体表述如下\",{\"1\":{\"11\":1}}],[\"具体如下\",{\"1\":{\"10\":1,\"142\":1}}],[\"从java8开始\",{\"1\":{\"185\":1}}],[\"从已知的一个类中派生出一个新的类\",{\"1\":{\"178\":1}}],[\"从这章开始时基于\",{\"1\":{\"147\":1}}],[\"从\",{\"1\":{\"104\":1}}],[\"从给定的\",{\"1\":{\"82\":1}}],[\"从状态\",{\"1\":{\"78\":1,\"137\":1}}],[\"从状态st​到st+1​\",{\"1\":{\"13\":1}}],[\"从指定的\",{\"1\":{\"78\":1}}],[\"从此可以发现\",{\"1\":{\"77\":1}}],[\"从而可以进行近似求解\",{\"1\":{\"155\":1}}],[\"从而可以在\",{\"1\":{\"115\":1}}],[\"从而方便计算\",{\"1\":{\"142\":1}}],[\"从而使得算法可行\",{\"1\":{\"136\":1}}],[\"从而生成经验数据的策略\",{\"1\":{\"121\":1}}],[\"从而引入\",{\"1\":{\"105\":1}}],[\"从而转换为一个\",{\"1\":{\"104\":1}}],[\"从而进行多次利用\",{\"1\":{\"81\":1}}],[\"从而选择每个状态下最大的\",{\"1\":{\"77\":1}}],[\"从而减小方差\",{\"1\":{\"25\":1}}],[\"从而最大化所有用户的总mos值\",{\"1\":{\"11\":1}}],[\"从无人机n到用户kn​的信道功率增益\",{\"1\":{\"9\":1}}],[\"是某个异常的父类\",{\"1\":{\"234\":1}}],[\"是某一类事物实际存在的每个个体\",{\"1\":{\"161\":1}}],[\"是继承\",{\"1\":{\"231\":1}}],[\"是无法访问到外部类的非静态内容的\",{\"1\":{\"219\":1}}],[\"是属于类的\",{\"1\":{\"219\":1}}],[\"是可以访问到外层的变量的\",{\"1\":{\"218\":1}}],[\"是可以的\",{\"1\":{\"204\":1}}],[\"是对象所有的\",{\"1\":{\"218\":1}}],[\"是对一类事物的描述\",{\"1\":{\"161\":1}}],[\"是匹配所有空白符\",{\"1\":{\"212\":1}}],[\"是在\",{\"1\":{\"241\":1,\"242\":1}}],[\"是在一开始就确定的\",{\"1\":{\"202\":1}}],[\"是在基于\",{\"1\":{\"23\":1}}],[\"是不是感觉非常简洁\",{\"1\":{\"224\":1}}],[\"是不是有点太浪费了\",{\"1\":{\"211\":1}}],[\"是不能\",{\"1\":{\"204\":1}}],[\"是不支持自动装箱和拆箱的\",{\"1\":{\"204\":1}}],[\"是不允许的\",{\"1\":{\"165\":1}}],[\"是不同的\",{\"1\":{\"40\":1,\"123\":1}}],[\"是为了完成某件事情而存在的\",{\"1\":{\"162\":1}}],[\"是类的一个具体化个体\",{\"1\":{\"161\":1}}],[\"是抽象的\",{\"1\":{\"161\":1}}],[\"是未知的\",{\"1\":{\"156\":1}}],[\"是各个\",{\"1\":{\"150\":1}}],[\"是我们需要进行优化的\",{\"1\":{\"148\":1}}],[\"是我们不断进行更新的策略\",{\"1\":{\"121\":1}}],[\"是直接建立一个基于策略的目标函数来进行梯度上升的优化\",{\"1\":{\"147\":1}}],[\"是用来与环境进行交互\",{\"1\":{\"121\":1}}],[\"是qπ​\",{\"1\":{\"116\":1}}],[\"是关于\",{\"1\":{\"112\":1}}],[\"是常数\",{\"1\":{\"110\":1}}],[\"是否成立\",{\"1\":{\"104\":1}}],[\"是否是收敛的\",{\"0\":{\"72\":1}}],[\"是需要被优化的参数\",{\"1\":{\"101\":1}}],[\"是第\",{\"1\":{\"97\":2}}],[\"是最顶层的类\",{\"1\":{\"181\":1}}],[\"是最优的\",{\"1\":{\"84\":1}}],[\"是最大报文长度\",{\"1\":{\"10\":1}}],[\"是针对\",{\"1\":{\"80\":1}}],[\"是针对一条trajectory所求的\",{\"1\":{\"41\":1}}],[\"是优于\",{\"1\":{\"68\":1}}],[\"是已知的\",{\"1\":{\"63\":1}}],[\"是依赖于策略π的\",{\"1\":{\"48\":1}}],[\"是由环境决定的\",{\"1\":{\"45\":1}}],[\"是一个非负整数\",{\"1\":{\"212\":2}}],[\"是一个期望值\",{\"1\":{\"101\":1}}],[\"是一个随机变量\",{\"1\":{\"101\":1}}],[\"是一个\",{\"1\":{\"97\":1}}],[\"是一个黑盒\",{\"1\":{\"97\":1}}],[\"是一个必要条件\",{\"1\":{\"84\":1}}],[\"是一个contraction\",{\"1\":{\"58\":1}}],[\"是一个有关状态s的函数\",{\"1\":{\"40\":1}}],[\"是一致的\",{\"1\":{\"41\":1,\"122\":1}}],[\"是基于一个给定策略\",{\"1\":{\"40\":1}}],[\"是\",{\"1\":{\"40\":1,\"49\":1,\"86\":1,\"113\":1,\"123\":2,\"124\":1,\"150\":1}}],[\"是根据q\",{\"1\":{\"13\":1}}],[\"是网页大小\",{\"1\":{\"10\":1}}],[\"是与传输速率有关的延迟时间\",{\"1\":{\"10\":1}}],[\"取值范围从1−4\",{\"1\":{\"10\":1}}],[\"rˉπ​\",{\"1\":{\"155\":1}}],[\"rˉπ​​\",{\"1\":{\"154\":1}}],[\"rˉπ​=s∈s∑​dπ​\",{\"1\":{\"153\":1}}],[\"runtimeexceptionruntimeexception\",{\"1\":{\"231\":1}}],[\"runtimeexception\",{\"1\":{\"231\":1,\"232\":3,\"233\":2,\"234\":2}}],[\"runoob\",{\"1\":{\"212\":3}}],[\"running\",{\"1\":{\"187\":5}}],[\"run\",{\"1\":{\"135\":1}}],[\"r1​\",{\"1\":{\"112\":1}}],[\"rk​+γv\",{\"1\":{\"110\":1}}],[\"rkn​​mss​\",{\"1\":{\"10\":1}}],[\"rkn​​\",{\"1\":{\"10\":3}}],[\"r→r\",{\"1\":{\"96\":1}}],[\"rm\",{\"0\":{\"95\":1},\"1\":{\"97\":1,\"99\":1,\"104\":3,\"110\":2}}],[\"roundingmode是舍入模式\",{\"1\":{\"195\":1}}],[\"roundingmode\",{\"1\":{\"195\":1}}],[\"robbins\",{\"0\":{\"95\":1},\"1\":{\"98\":2}}],[\"root\",{\"1\":{\"92\":1,\"98\":1,\"104\":1,\"110\":1}}],[\"r+s\",{\"1\":{\"66\":2}}],[\"r+γa∈a\",{\"1\":{\"141\":1,\"142\":3}}],[\"r+γqπ​\",{\"1\":{\"115\":1}}],[\"r+γg∣s=s\",{\"1\":{\"113\":1}}],[\"r+γv\",{\"1\":{\"110\":6}}],[\"r+γ∑s\",{\"1\":{\"48\":1}}],[\"r+γs\",{\"1\":{\"45\":1,\"48\":1,\"55\":1,\"63\":1}}],[\"rπ​+γpπ​v1​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ1​​\",{\"1\":{\"70\":1}}],[\"rπ​+γpπ​vπ0​​\",{\"1\":{\"70\":2}}],[\"rπ​+γpπ​vπk​​\",{\"1\":{\"66\":1,\"70\":1,\"77\":1}}],[\"rπ​+γpπ​vk​\",{\"1\":{\"62\":1,\"63\":1,\"70\":1}}],[\"rπ​+γpπ​v\",{\"1\":{\"55\":1,\"58\":1,\"61\":1}}],[\"rπ​\",{\"1\":{\"46\":2,\"153\":4,\"154\":1}}],[\"rπ​=\",{\"1\":{\"46\":1}}],[\"r​​+mean\",{\"1\":{\"45\":1}}],[\"r​\",{\"1\":{\"43\":1}}],[\"r∑​p\",{\"1\":{\"43\":1,\"45\":2,\"48\":1,\"55\":1,\"63\":1,\"66\":2}}],[\"rl9\",{\"0\":{\"147\":1}}],[\"rl8\",{\"0\":{\"130\":1}}],[\"rl7\",{\"0\":{\"109\":1}}],[\"rl\",{\"1\":{\"92\":1}}],[\"rl6\",{\"0\":{\"92\":1}}],[\"rl5\",{\"0\":{\"75\":1}}],[\"rl4\",{\"0\":{\"61\":1}}],[\"rl3\",{\"0\":{\"52\":1}}],[\"rl2\",{\"0\":{\"36\":1}}],[\"rl10\",{\"0\":{\"23\":1}}],[\"rl1\",{\"0\":{\"17\":1}}],[\"r∣s\",{\"1\":{\"20\":1,\"41\":1,\"43\":1,\"45\":3,\"48\":2,\"55\":1,\"63\":2,\"66\":2,\"75\":1,\"77\":3,\"153\":2}}],[\"r\",{\"1\":{\"20\":3,\"110\":3,\"141\":1,\"142\":1,\"153\":3,\"212\":2}}],[\"rate\",{\"1\":{\"19\":1,\"39\":1,\"58\":1}}],[\"random\",{\"1\":{\"14\":2,\"42\":1,\"241\":6}}],[\"r=1∣s1​\",{\"1\":{\"19\":1}}],[\"regexp\",{\"1\":{\"212\":2}}],[\"regular\",{\"1\":{\"212\":1}}],[\"registernatives\",{\"1\":{\"181\":2}}],[\"reinforce\",{\"0\":{\"156\":1,\"157\":1},\"1\":{\"156\":1}}],[\"reinforcement\",{\"0\":{\"3\":1}}],[\"replay\",{\"0\":{\"143\":1},\"1\":{\"142\":1}}],[\"representation\",{\"1\":{\"130\":2}}],[\"refers\",{\"1\":{\"92\":1}}],[\"result\",{\"1\":{\"211\":2}}],[\"resulting\",{\"1\":{\"19\":1}}],[\"respect\",{\"1\":{\"19\":1}}],[\"returns\",{\"1\":{\"41\":1}}],[\"return为\",{\"1\":{\"39\":1}}],[\"return的描述\",{\"1\":{\"39\":1}}],[\"return越短视\",{\"1\":{\"19\":1}}],[\"return\",{\"0\":{\"41\":1,\"153\":1},\"1\":{\"19\":2,\"39\":1,\"41\":3,\"42\":1,\"48\":2,\"78\":1,\"82\":1,\"113\":1,\"137\":1,\"164\":1,\"165\":2,\"181\":2,\"182\":3,\"186\":1,\"187\":2,\"193\":2,\"224\":2,\"225\":1,\"233\":2}}],[\"rewards\",{\"0\":{\"43\":1,\"44\":1},\"1\":{\"20\":1,\"45\":2,\"154\":1}}],[\"reward\",{\"1\":{\"13\":1,\"19\":2,\"20\":2,\"115\":1,\"154\":1}}],[\"rt+2​\",{\"1\":{\"154\":1}}],[\"rt+2​+γrt+3​+\",{\"1\":{\"42\":1}}],[\"rt+1​+rt+2​+⋯+rt+n​∣st​=s0​\",{\"1\":{\"154\":1}}],[\"rt+1​+γq^​\",{\"1\":{\"139\":1}}],[\"rt+1​+γqt​\",{\"1\":{\"116\":1}}],[\"rt+1​+γv^\",{\"1\":{\"138\":2}}],[\"rt+1​+γvt​\",{\"1\":{\"112\":2}}],[\"rt+1​+γa∈a\",{\"1\":{\"140\":1}}],[\"rt+1​+γa∈amax​qt​\",{\"1\":{\"120\":1}}],[\"rt+1​+γamax​q\",{\"1\":{\"119\":1}}],[\"rt+1​+γgt+1​∣st​=s\",{\"1\":{\"42\":1}}],[\"rt+1​\",{\"1\":{\"112\":2,\"116\":1,\"154\":1}}],[\"rt+1​∣st​=s\",{\"1\":{\"42\":2,\"43\":2,\"45\":1}}],[\"rt+1​∣at+1​\",{\"1\":{\"20\":1}}],[\"rt​∣st​\",{\"1\":{\"13\":1}}],[\"rtt\",{\"1\":{\"10\":1}}],[\"5个变量连续加\",{\"1\":{\"211\":1}}],[\"5555\",{\"1\":{\"194\":1}}],[\"5\",{\"0\":{\"49\":1,\"127\":1,\"141\":1},\"1\":{\"10\":3,\"70\":1,\"206\":1,\"207\":1,\"241\":1,\"242\":1}}],[\"404\",{\"1\":{\"245\":1}}],[\"4\",{\"0\":{\"33\":1,\"46\":1,\"48\":1,\"84\":1,\"99\":1,\"106\":1,\"119\":1,\"120\":1,\"121\":1,\"124\":1,\"140\":1,\"156\":1,\"229\":1},\"1\":{\"10\":1,\"70\":1,\"205\":3,\"206\":1,\"211\":1,\"241\":1,\"242\":1}}],[\"根据这个式子我们就可以通过\",{\"1\":{\"155\":1}}],[\"根据梯度下降的公式\",{\"1\":{\"142\":1}}],[\"根据给定的策略\",{\"1\":{\"112\":1}}],[\"根据策略\",{\"1\":{\"78\":1}}],[\"根据策略π\",{\"1\":{\"48\":1}}],[\"根据对应的\",{\"1\":{\"66\":1}}],[\"根据\",{\"1\":{\"53\":2,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"113\":1}}],[\"根据一个\",{\"1\":{\"42\":1}}],[\"根据所给定的用户划分情况\",{\"1\":{\"13\":1}}],[\"根据遗传算法找到cn​个最优个体作为簇的中心\",{\"1\":{\"13\":1}}],[\"根据n个用户\",{\"1\":{\"13\":1}}],[\"根据mos数值\",{\"1\":{\"10\":1}}],[\"根据香农定理\",{\"1\":{\"9\":1}}],[\"可变长参数\",{\"0\":{\"207\":1}}],[\"可见性\",{\"1\":{\"174\":1}}],[\"可写可不写\",{\"1\":{\"173\":1}}],[\"可能会创建各种各样的类\",{\"1\":{\"173\":1}}],[\"可知\",{\"1\":{\"9\":1}}],[\"可以对\",{\"1\":{\"242\":1}}],[\"可以简写为\",{\"1\":{\"234\":1}}],[\"可以只跟\",{\"1\":{\"234\":1}}],[\"可以交给\",{\"1\":{\"234\":1}}],[\"可以直接通过\",{\"1\":{\"242\":1}}],[\"可以直接使用lambda表达式\",{\"1\":{\"225\":1}}],[\"可以直接省去花括号和return关键字\",{\"1\":{\"224\":1}}],[\"可以有多个方法\",{\"1\":{\"224\":1}}],[\"可以有限\",{\"1\":{\"19\":1}}],[\"可以在方法中定义\",{\"1\":{\"220\":1}}],[\"可以到\",{\"1\":{\"212\":1}}],[\"可以使用方括号\",{\"1\":{\"212\":1}}],[\"可以匹配\",{\"1\":{\"212\":1}}],[\"可以用来检查一个串是否含有某种子串\",{\"1\":{\"212\":1}}],[\"可以用来衡量一个状态的价值\",{\"1\":{\"40\":1}}],[\"可以保存一个2字节的unicode字符\",{\"1\":{\"209\":1}}],[\"可以看到\",{\"1\":{\"208\":1}}],[\"可以传入\",{\"1\":{\"207\":1}}],[\"可以理解为\",{\"1\":{\"185\":1}}],[\"可以将复制一个完全一样的对象出来\",{\"1\":{\"181\":1}}],[\"可以相同\",{\"1\":{\"165\":1}}],[\"可以是跑步\",{\"1\":{\"187\":1}}],[\"可以是\",{\"1\":{\"155\":1}}],[\"可以是标量\",{\"1\":{\"101\":1}}],[\"可以根据对各个状态的重要程度进行选择\",{\"1\":{\"152\":1}}],[\"可以最大化一个确定的常数指标\",{\"1\":{\"148\":1}}],[\"可以最开始均初始化为\",{\"1\":{\"47\":1}}],[\"可以描述为\",{\"1\":{\"148\":1}}],[\"可以写成\",{\"1\":{\"134\":1}}],[\"可以提高存储效率\",{\"1\":{\"131\":1}}],[\"可以参考\",{\"1\":{\"104\":1}}],[\"可以平衡\",{\"1\":{\"87\":1}}],[\"可以拆分为多个\",{\"1\":{\"81\":1}}],[\"可以通过这个成员内部类又创建出更多对象\",{\"1\":{\"218\":1}}],[\"可以通过\",{\"1\":{\"66\":1}}],[\"可以通过contraction\",{\"1\":{\"58\":1}}],[\"可以通过设置将episodic\",{\"1\":{\"19\":1}}],[\"可以互相转化\",{\"1\":{\"48\":1}}],[\"可以得到一个序列v0​\",{\"1\":{\"47\":1}}],[\"可以求解\",{\"1\":{\"45\":1}}],[\"可以粗步衡量一个策略的好坏\",{\"1\":{\"19\":1}}],[\"可以忽略\",{\"1\":{\"10\":1}}],[\"可以表示为\",{\"1\":{\"9\":1,\"135\":1}}],[\"可以减轻无人机对用户接收到的干扰\",{\"1\":{\"9\":1}}],[\"≤c2​\",{\"1\":{\"98\":1}}],[\"≤pmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hmax​\",{\"1\":{\"11\":1,\"13\":1}}],[\"≤hn​\",{\"1\":{\"9\":1}}],[\"≤\",{\"1\":{\"9\":1}}],[\"ζ2​是系数\",{\"1\":{\"10\":1}}],[\"ζ1​\",{\"1\":{\"10\":1}}],[\"ζ+em\",{\"1\":{\"9\":1}}],[\"ζ是由环境决定的常数\",{\"1\":{\"9\":1}}],[\"19\",{\"1\":{\"241\":1}}],[\"166\",{\"1\":{\"194\":1}}],[\"1static\",{\"1\":{\"185\":1}}],[\"18\",{\"1\":{\"162\":1,\"166\":1,\"182\":4,\"185\":1,\"186\":1,\"187\":1}}],[\"180π​\",{\"1\":{\"9\":1}}],[\"100\",{\"1\":{\"195\":2,\"234\":1,\"241\":1}}],[\"10\",{\"1\":{\"161\":1,\"166\":1,\"193\":5,\"195\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":4,\"223\":1,\"224\":2,\"225\":2,\"234\":2,\"235\":2}}],[\"10​a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"10​a=a∗a=a∗​\",{\"1\":{\"57\":1}}],[\"1−∣a\",{\"1\":{\"87\":1}}],[\"128~127之间的值自动装箱为integer类型的对象\",{\"1\":{\"193\":1}}],[\"128~127之间的所有值\",{\"1\":{\"193\":1}}],[\"128\",{\"1\":{\"193\":4}}],[\"1234\",{\"1\":{\"33\":1}}],[\"120和4\",{\"1\":{\"10\":1}}],[\"1\",{\"0\":{\"19\":1,\"24\":1,\"26\":1,\"30\":1,\"38\":1,\"39\":2,\"40\":1,\"41\":1,\"43\":1,\"53\":1,\"55\":1,\"57\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"70\":1,\"76\":1,\"77\":2,\"78\":1,\"79\":1,\"81\":1,\"86\":1,\"93\":1,\"94\":2,\"96\":1,\"101\":1,\"110\":1,\"112\":1,\"116\":1,\"120\":1,\"131\":1,\"133\":1,\"148\":1,\"150\":1},\"1\":{\"10\":1,\"13\":7,\"14\":1,\"19\":1,\"66\":1,\"70\":1,\"79\":2,\"87\":1,\"98\":2,\"101\":1,\"112\":1,\"116\":1,\"205\":1,\"206\":2,\"207\":1,\"212\":5,\"233\":1,\"234\":2,\"241\":1,\"242\":1}}],[\"1~2\",{\"1\":{\"10\":1}}],[\"1+σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"1+ns​\",{\"1\":{\"9\":1}}],[\"表示所有小写字母\",{\"1\":{\"212\":1}}],[\"表示abc这几个字符可以出现\",{\"1\":{\"212\":1}}],[\"表示当前数组长度\",{\"1\":{\"202\":1}}],[\"表示long的最大值\",{\"1\":{\"195\":1}}],[\"表示类支持接口代表的功能\",{\"1\":{\"185\":1}}],[\"表示类具有的属性\",{\"1\":{\"161\":1}}],[\"表示这个类具有克隆的功能\",{\"1\":{\"186\":1}}],[\"表示这个类是一个抽象类\",{\"1\":{\"184\":1}}],[\"表示这个类不能再被继承了\",{\"1\":{\"183\":1}}],[\"表示导入这个包中全部的类\",{\"1\":{\"173\":1}}],[\"表示是\",{\"1\":{\"135\":1}}],[\"表示是一种长时间的交互行为\",{\"1\":{\"135\":1}}],[\"表示是最佳部署位置\",{\"1\":{\"13\":1}}],[\"表示一个区间\",{\"1\":{\"212\":1}}],[\"表示一个函数\",{\"1\":{\"110\":1}}],[\"表示一个给定的策略\",{\"1\":{\"45\":1}}],[\"表示对于对应\",{\"1\":{\"84\":1}}],[\"表示对于每一个\",{\"1\":{\"84\":1}}],[\"表示状态转移矩阵\",{\"1\":{\"46\":1}}],[\"表示为\",{\"1\":{\"40\":1,\"152\":3}}],[\"表示为rkn​​\",{\"1\":{\"9\":1}}],[\"表示在单步情况下\",{\"1\":{\"153\":1}}],[\"表示在策略π下\",{\"1\":{\"153\":1}}],[\"表示在一个\",{\"1\":{\"137\":1}}],[\"表示在各状态执行各动作的概率\",{\"1\":{\"20\":1}}],[\"表示在状态s下采取动作a\",{\"1\":{\"20\":2}}],[\"表示\",{\"1\":{\"10\":1,\"135\":1,\"142\":1,\"155\":1}}],[\"表示round\",{\"1\":{\"10\":1}}],[\"表示无人机与用户之间的仰角\",{\"1\":{\"9\":1}}],[\"且同样不能使用\",{\"1\":{\"184\":1}}],[\"且需要被求解出来\",{\"1\":{\"96\":1}}],[\"且最终会收敛到最优策略v∗\",{\"1\":{\"68\":1}}],[\"且\",{\"1\":{\"53\":1,\"87\":1,\"98\":2,\"135\":1,\"144\":1}}],[\"且ζ1​+ζ2​=1\",{\"1\":{\"10\":1}}],[\"且传输率永远都不可能超过信道容量c\",{\"1\":{\"9\":1}}],[\"且无人机向关联用户的发射功率是恒定的\",{\"1\":{\"9\":1}}],[\"信道容量c=b∗log\",{\"1\":{\"9\":1}}],[\"信号模型\",{\"0\":{\"9\":1}}],[\"由无人机的位置和它们在最后时隙采取的动作决定\",{\"1\":{\"14\":1}}],[\"由用户的初始位置和运动模型决定\",{\"1\":{\"14\":1}}],[\"由于string的构造方法在创建对象时也会得到一个string类型的结果\",{\"1\":{\"225\":1}}],[\"由于基本数据类型和引用类型不同\",{\"1\":{\"204\":1}}],[\"由于类本身都是继承\",{\"1\":{\"185\":1}}],[\"由于默认导入了系统自带的string类\",{\"1\":{\"173\":1}}],[\"由于πk+1​是\",{\"1\":{\"63\":1}}],[\"由于\",{\"1\":{\"48\":1,\"63\":1}}],[\"由于用户在每个时隙都处于漫游状态\",{\"1\":{\"14\":1}}],[\"由于gak\",{\"1\":{\"13\":1}}],[\"由于特定用户的mos与该用户与无人机之间的距离有关\",{\"1\":{\"13\":1}}],[\"由于不同用户对于传输速率的需求是不同的\",{\"1\":{\"10\":1}}],[\"由于不同集群的频谱不同\",{\"1\":{\"9\":1}}],[\"由此进行迭代\",{\"1\":{\"66\":1}}],[\"由此可以根据contraction\",{\"1\":{\"58\":1}}],[\"由此可以推导出一个多步的trajectory\",{\"1\":{\"39\":1}}],[\"由此\",{\"1\":{\"9\":1}}],[\"同时告知上一级方法执行出现了问题\",{\"1\":{\"233\":1}}],[\"同时也使得基本类型能够支持对象操作\",{\"1\":{\"192\":1}}],[\"同时具体实现还需要由主体来实现\",{\"1\":{\"185\":1}}],[\"同名的方法\",{\"1\":{\"185\":1}}],[\"同上\",{\"1\":{\"181\":4,\"201\":1}}],[\"同一消息根据不同的对象而采用各种不同的方法\",{\"1\":{\"178\":1}}],[\"同一个包下的类\",{\"1\":{\"174\":1}}],[\"同一无人机通过fdma同时为同一集群中的多个用户提供服务\",{\"1\":{\"8\":1}}],[\"同理\",{\"1\":{\"19\":1}}],[\"同样可以捕获到\",{\"1\":{\"234\":1}}],[\"同样可以用条件概率的形式进行描述\",{\"1\":{\"19\":1}}],[\"同样需要使用\",{\"1\":{\"201\":1}}],[\"同样需要将接口中所有的抽象方法全部实现\",{\"1\":{\"185\":1}}],[\"同样的\",{\"1\":{\"170\":2,\"193\":1,\"222\":1}}],[\"同样地\",{\"1\":{\"48\":1}}],[\"同样\",{\"1\":{\"9\":1,\"99\":1}}],[\"μnlos​\",{\"1\":{\"9\":1}}],[\"μnlos​是表示los和nlos链路的衰减因子\",{\"1\":{\"9\":1}}],[\"μlos​−μnlos​\",{\"1\":{\"9\":1}}],[\"μlos​\",{\"1\":{\"9\":1}}],[\"α是表示路径损耗指数\",{\"1\":{\"9\":1}}],[\"google\",{\"1\":{\"212\":2}}],[\"good\",{\"1\":{\"10\":1}}],[\"g∣s=s\",{\"1\":{\"113\":1}}],[\"g~​\",{\"1\":{\"104\":1,\"110\":1}}],[\"gd\",{\"1\":{\"101\":1,\"104\":1}}],[\"gradient\",{\"0\":{\"100\":1,\"147\":1},\"1\":{\"101\":2,\"148\":1}}],[\"greedy\",{\"0\":{\"85\":1,\"87\":1,\"88\":1},\"1\":{\"53\":1,\"63\":2,\"66\":1,\"70\":2,\"79\":1,\"87\":3}}],[\"g​\",{\"1\":{\"97\":2,\"99\":2}}],[\"gpi\",{\"1\":{\"82\":1}}],[\"generalized\",{\"1\":{\"82\":1}}],[\"getmessage\",{\"1\":{\"234\":1}}],[\"getstatus\",{\"1\":{\"187\":2}}],[\"getclass\",{\"1\":{\"181\":2}}],[\"getname\",{\"1\":{\"164\":1,\"181\":1,\"187\":2}}],[\"get\",{\"1\":{\"48\":2}}],[\"g\",{\"1\":{\"78\":3,\"96\":4,\"97\":2,\"98\":1,\"99\":2,\"104\":1,\"110\":2,\"113\":1}}],[\"gt+1​∣st+1​=s\",{\"1\":{\"44\":2}}],[\"gt+1​∣st​=s\",{\"1\":{\"42\":2,\"44\":5,\"45\":1}}],[\"gt​−v^\",{\"1\":{\"137\":1}}],[\"gt​​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"42\":1}}],[\"gt​∣st​=s\",{\"1\":{\"40\":1,\"42\":1,\"48\":3,\"49\":2,\"75\":2,\"77\":1,\"78\":1}}],[\"gt​\",{\"1\":{\"40\":2,\"42\":1,\"78\":1,\"137\":2}}],[\"gt​也是一个随机变量\",{\"1\":{\"39\":1}}],[\"gt​=rt+1​+γrt+2​+γ2rt+3​+\",{\"1\":{\"39\":1}}],[\"gt​=e\",{\"1\":{\"13\":1}}],[\"gkn​​\",{\"1\":{\"9\":1}}],[\"gain\",{\"1\":{\"9\":1}}],[\"ceiling\",{\"1\":{\"195\":1}}],[\"certain\",{\"1\":{\"148\":1}}],[\"cloneable\",{\"1\":{\"186\":2}}],[\"clonenotsupportedexception\",{\"1\":{\"181\":1,\"186\":2,\"231\":1}}],[\"clone\",{\"1\":{\"181\":2,\"186\":6,\"231\":1,\"233\":1}}],[\"closed\",{\"1\":{\"47\":1}}],[\"classnotfoundexception\",{\"1\":{\"233\":2}}],[\"class<\",{\"1\":{\"181\":1}}],[\"class\",{\"1\":{\"92\":1,\"161\":1,\"162\":1,\"166\":4,\"170\":1,\"171\":2,\"173\":3,\"174\":2,\"181\":1,\"182\":1,\"184\":2,\"185\":2,\"186\":1,\"187\":2,\"207\":1,\"218\":7,\"219\":2,\"220\":3,\"221\":7,\"222\":4,\"232\":2}}],[\"copyofarrays\",{\"1\":{\"242\":1}}],[\"compiled\",{\"1\":{\"187\":1}}],[\"com\",{\"1\":{\"173\":8,\"174\":1,\"187\":6,\"208\":1,\"212\":1,\"221\":4,\"222\":2}}],[\"comments\",{\"1\":{\"70\":1}}],[\"code\",{\"0\":{\"251\":1},\"2\":{\"167\":1,\"175\":1,\"188\":1,\"196\":1,\"213\":1,\"226\":1,\"236\":1,\"243\":1}}],[\"coefficient\",{\"1\":{\"97\":1}}],[\"core\",{\"1\":{\"52\":1}}],[\"converges\",{\"1\":{\"98\":1}}],[\"convergence\",{\"1\":{\"58\":1}}],[\"convex问题\",{\"1\":{\"11\":1}}],[\"consider\",{\"1\":{\"58\":1}}],[\"considered\",{\"1\":{\"4\":1}}],[\"contractive\",{\"1\":{\"58\":1}}],[\"contraction\",{\"1\":{\"53\":2,\"58\":2,\"62\":1}}],[\"continuing\",{\"1\":{\"19\":1}}],[\"concepts\",{\"1\":{\"52\":1}}],[\"catch\",{\"1\":{\"234\":10}}],[\"cache\",{\"1\":{\"193\":1}}],[\"carlo\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"can\",{\"1\":{\"41\":1,\"48\":2}}],[\"called\",{\"1\":{\"19\":1,\"81\":1,\"86\":1}}],[\"critic\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"choose\",{\"1\":{\"20\":1}}],[\"chars\",{\"1\":{\"210\":2}}],[\"character\",{\"1\":{\"193\":1}}],[\"char\",{\"1\":{\"193\":1,\"209\":1,\"210\":1}}],[\"chapter\",{\"1\":{\"62\":1,\"68\":1}}],[\"chain\",{\"1\":{\"19\":1}}],[\"channel\",{\"1\":{\"9\":1}}],[\"cmax​\",{\"1\":{\"14\":1}}],[\"c\",{\"1\":{\"11\":1,\"13\":1}}],[\"cycles\",{\"1\":{\"10\":1}}],[\"c1​和c2​是通过分析web浏览应用程序的实验结果确定的常数\",{\"1\":{\"10\":1}}],[\"c是光速\",{\"1\":{\"9\":1}}],[\"c4πfc​​\",{\"1\":{\"9\":1}}],[\"为一个函数方程\",{\"1\":{\"96\":1}}],[\"为状态\",{\"1\":{\"87\":1}}],[\"为什么不去求\",{\"1\":{\"79\":1}}],[\"为什么考虑\",{\"1\":{\"75\":1}}],[\"为什么这个迭代算法最终可以找到最优策略\",{\"1\":{\"68\":1}}],[\"为discounted\",{\"1\":{\"39\":1}}],[\"为t时刻的mos评分\",{\"1\":{\"10\":1}}],[\"为了在创建匿名对象时进行属性初始化\",{\"1\":{\"222\":1}}],[\"为了在los信道概率和路径损耗之间取得平衡\",{\"1\":{\"9\":1}}],[\"为了优化效率\",{\"1\":{\"210\":1}}],[\"为了支持小数加法\",{\"1\":{\"165\":1}}],[\"为了让右边取到最大值的情况\",{\"1\":{\"57\":1}}],[\"为了进行\",{\"1\":{\"47\":1}}],[\"为了应对具有无限步的trajectory的return=∞的情况\",{\"1\":{\"19\":1}}],[\"为了保证所有用户都能连接到网络\",{\"1\":{\"9\":1}}],[\"为了满足不同用户传输速率要求\",{\"1\":{\"9\":1}}],[\"为\",{\"1\":{\"9\":1,\"42\":2,\"46\":1,\"78\":1,\"148\":1}}],[\"为指标\",{\"1\":{\"5\":1}}],[\"​≐a∈a∑​π\",{\"1\":{\"153\":1}}],[\"​≐g\",{\"1\":{\"99\":1}}],[\"​q^​\",{\"1\":{\"142\":3}}],[\"​tderrorδt​​\",{\"1\":{\"112\":1}}],[\"​forthegreedyaction\",{\"1\":{\"87\":1}}],[\"​vu​u2​pu​\",{\"1\":{\"70\":1}}],[\"​vu​u1​pu​π2\",{\"1\":{\"70\":1}}],[\"​p\",{\"1\":{\"48\":1}}],[\"​​−αt​\",{\"1\":{\"112\":1}}],[\"​​=currentestimatevt​\",{\"1\":{\"112\":1}}],[\"​​=a∑​qπ​\",{\"1\":{\"48\":1}}],[\"​​+η∇w​f\",{\"1\":{\"104\":1}}],[\"​​π\",{\"1\":{\"48\":1}}],[\"​​\",{\"1\":{\"45\":1,\"66\":1,\"104\":2,\"112\":1}}],[\"​=π\",{\"1\":{\"155\":1}}],[\"​=πmax​a∑​π\",{\"1\":{\"55\":1}}],[\"​=▽w​e\",{\"1\":{\"136\":1}}],[\"​=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"​=vt​\",{\"1\":{\"112\":1}}],[\"​=∇w​f\",{\"1\":{\"104\":1}}],[\"​=w−e\",{\"1\":{\"110\":1}}],[\"​=w−x​=w−x+e\",{\"1\":{\"99\":1}}],[\"​=wk​−k1​\",{\"1\":{\"94\":1}}],[\"​=argmaxπ​\",{\"1\":{\"70\":1}}],[\"​=a∑​π\",{\"1\":{\"43\":1,\"44\":1}}],[\"​=rπk​​+γpπk​​vπk​\",{\"1\":{\"68\":1}}],[\"​=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"​=s∈s∑​η\",{\"1\":{\"155\":1}}],[\"​=s\",{\"1\":{\"44\":1}}],[\"​=e\",{\"1\":{\"42\":1,\"45\":1}}],[\"​=es∼η\",{\"1\":{\"26\":1}}],[\"​=ϕ\",{\"1\":{\"8\":1,\"11\":1,\"13\":1}}],[\"​ifmosnew​>mosold​ifmosnew​=mosold​ifmosnew​<mosold​​\",{\"1\":{\"13\":1}}],[\"​≥0\",{\"1\":{\"11\":1,\"13\":1}}],[\"​≥γkn​​\",{\"1\":{\"11\":1,\"13\":1}}],[\"​−μlos​−μnlos​μnlos​​​s\",{\"1\":{\"9\":1}}],[\"​\",{\"1\":{\"9\":3,\"10\":1,\"11\":1,\"13\":1,\"26\":1,\"42\":1,\"44\":2,\"45\":1,\"46\":1,\"48\":2,\"55\":1,\"63\":1,\"66\":5,\"68\":1,\"77\":1,\"81\":2,\"87\":1,\"94\":1,\"104\":2,\"112\":1,\"116\":1,\"120\":1,\"136\":1,\"142\":1,\"153\":1,\"155\":2,\"156\":1}}],[\"​hn​\",{\"1\":{\"9\":1}}],[\"bbb\",{\"1\":{\"211\":1}}],[\"builder\",{\"1\":{\"211\":8}}],[\"buffer\",{\"0\":{\"143\":1},\"1\":{\"142\":1}}],[\"bigdecimal\",{\"1\":{\"195\":6}}],[\"biginteger\",{\"1\":{\"195\":10}}],[\"bit\",{\"1\":{\"10\":2}}],[\"byte类型的包装类也有类似的机制\",{\"1\":{\"193\":1}}],[\"byte\",{\"1\":{\"193\":2}}],[\"bgd\",{\"0\":{\"106\":1},\"1\":{\"101\":1}}],[\"baidu\",{\"1\":{\"173\":3}}],[\"batch\",{\"1\":{\"101\":1,\"142\":2}}],[\"based\",{\"0\":{\"88\":1},\"1\":{\"77\":1,\"82\":1,\"147\":2,\"156\":1}}],[\"baseline\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"25\":1,\"26\":2,\"27\":1}}],[\"basic\",{\"0\":{\"76\":1},\"1\":{\"80\":1,\"81\":1,\"88\":1}}],[\"broad\",{\"1\":{\"92\":1}}],[\"bob\",{\"1\":{\"212\":2}}],[\"boolean\",{\"1\":{\"181\":1,\"182\":1,\"193\":2}}],[\"bootstrapping\",{\"1\":{\"45\":1}}],[\"boe\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"58\":1}}],[\"b\",{\"1\":{\"26\":1,\"165\":4,\"193\":6,\"207\":1,\"218\":2,\"225\":5,\"233\":3}}],[\"bkn​​=bn​\",{\"1\":{\"9\":1}}],[\"b2​\",{\"1\":{\"9\":1}}],[\"b2​pnlos​=1−plos​\",{\"1\":{\"9\":1}}],[\"b1​\",{\"1\":{\"9\":2}}],[\"behavior\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"135\":1}}],[\"bellman\",{\"0\":{\"42\":1,\"45\":1,\"46\":1,\"54\":1},\"1\":{\"37\":1,\"46\":2,\"47\":1,\"49\":2,\"52\":1,\"66\":1,\"68\":2,\"70\":1,\"71\":1,\"77\":1,\"113\":3,\"115\":1,\"119\":1}}],[\"be\",{\"1\":{\"4\":1,\"41\":1}}],[\"ppp\",{\"1\":{\"222\":1}}],[\"pp\",{\"1\":{\"222\":2,\"223\":2}}],[\"ppolicy\",{\"1\":{\"124\":1}}],[\"python等等都是支持正则表达式的\",{\"1\":{\"212\":1}}],[\"pattern\",{\"1\":{\"212\":1}}],[\"package\",{\"1\":{\"173\":3,\"186\":1,\"221\":3,\"222\":2}}],[\"pair\",{\"1\":{\"79\":1,\"81\":6,\"82\":1,\"84\":2,\"86\":1}}],[\"printstacktrace\",{\"1\":{\"234\":1}}],[\"print\",{\"1\":{\"203\":2,\"241\":1}}],[\"println\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"170\":2,\"174\":1,\"182\":2,\"184\":1,\"185\":2,\"186\":4,\"187\":1,\"193\":3,\"194\":1,\"195\":2,\"202\":1,\"206\":1,\"207\":1,\"208\":1,\"210\":6,\"211\":3,\"212\":2,\"218\":5,\"219\":1,\"220\":1,\"221\":7,\"222\":3,\"223\":1,\"224\":3,\"225\":2,\"234\":3,\"241\":1,\"242\":1}}],[\"private\",{\"1\":{\"174\":2,\"181\":1,\"182\":1,\"184\":2,\"187\":2,\"218\":2,\"219\":1,\"220\":1,\"224\":1,\"233\":2,\"234\":2}}],[\"profession\",{\"1\":{\"184\":4}}],[\"protected\",{\"1\":{\"174\":2,\"181\":2,\"184\":7,\"222\":1,\"231\":1,\"233\":1}}],[\"problems\",{\"1\":{\"92\":1}}],[\"probability\",{\"1\":{\"19\":1,\"20\":4,\"86\":1,\"98\":1,\"133\":1}}],[\"property\",{\"1\":{\"20\":1}}],[\"proposition1展示了无人机为相关用户提供可靠服务所需的高度的必要条件\",{\"1\":{\"9\":1}}],[\"proposition1\",{\"1\":{\"9\":1}}],[\"proposed\",{\"1\":{\"4\":1}}],[\"process\",{\"0\":{\"20\":1},\"1\":{\"20\":1,\"135\":1}}],[\"p2\",{\"1\":{\"161\":1,\"182\":3}}],[\"p1\",{\"1\":{\"161\":2,\"182\":3}}],[\"public\",{\"1\":{\"161\":4,\"162\":2,\"166\":4,\"170\":2,\"173\":5,\"174\":6,\"181\":10,\"182\":3,\"184\":8,\"185\":9,\"186\":6,\"187\":13,\"193\":5,\"194\":1,\"195\":2,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":1,\"207\":5,\"208\":1,\"210\":3,\"211\":3,\"212\":2,\"218\":15,\"219\":5,\"220\":5,\"221\":9,\"222\":12,\"223\":2,\"224\":3,\"225\":8,\"232\":4,\"233\":1,\"234\":4,\"235\":1,\"241\":2,\"242\":1}}],[\"pu\",{\"1\":{\"70\":1}}],[\"pi\",{\"1\":{\"66\":1,\"68\":1,\"70\":1}}],[\"penguin\",{\"1\":{\"185\":1,\"221\":1,\"222\":4}}],[\"person\",{\"1\":{\"161\":8,\"162\":3,\"166\":8,\"170\":3,\"173\":1,\"174\":2,\"182\":10,\"184\":3,\"185\":1,\"186\":1,\"207\":5}}],[\"periods\",{\"1\":{\"10\":1}}],[\"pe\",{\"1\":{\"66\":2,\"68\":1,\"70\":1,\"77\":1}}],[\"pπ​\",{\"1\":{\"46\":1}}],[\"pπ​∈rn×n\",{\"1\":{\"46\":1}}],[\"p\",{\"1\":{\"19\":1,\"20\":3,\"41\":2,\"44\":1,\"45\":2,\"63\":2,\"75\":1,\"77\":4,\"98\":1,\"161\":4,\"162\":4}}],[\"pkn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"pkn​​=pmax​\",{\"1\":{\"9\":1}}],[\"pow\",{\"1\":{\"241\":1}}],[\"power\",{\"1\":{\"9\":1}}],[\"poicy\",{\"0\":{\"125\":1}}],[\"point\",{\"1\":{\"58\":1}}],[\"positive\",{\"1\":{\"86\":1,\"97\":1}}],[\"possible\",{\"1\":{\"41\":1}}],[\"policies\",{\"1\":{\"85\":1,\"87\":2}}],[\"policy版本\",{\"1\":{\"140\":1}}],[\"policyevaluation\",{\"1\":{\"77\":1}}],[\"policy\",{\"0\":{\"29\":1,\"31\":1,\"53\":1,\"65\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"86\":1,\"87\":1,\"88\":1,\"121\":2,\"122\":1,\"123\":1,\"126\":1,\"147\":1},\"1\":{\"19\":2,\"20\":1,\"23\":2,\"45\":1,\"47\":1,\"52\":1,\"53\":2,\"63\":3,\"66\":2,\"68\":1,\"69\":1,\"70\":11,\"71\":2,\"76\":1,\"77\":1,\"79\":4,\"82\":3,\"86\":2,\"87\":2,\"88\":1,\"111\":1,\"115\":1,\"120\":1,\"121\":2,\"122\":2,\"123\":4,\"124\":3,\"125\":2,\"144\":1,\"147\":2,\"148\":1}}],[\"poor\",{\"1\":{\"10\":1}}],[\"pm​ax​\",{\"1\":{\"9\":1}}],[\"pmax​≥γσ2k0​dkn​​α\",{\"1\":{\"9\":1}}],[\"plos​μlos​+pnlos​μnlos​\",{\"1\":{\"9\":1}}],[\"plos​\",{\"1\":{\"9\":1}}],[\"−2\",{\"1\":{\"142\":2}}],[\"−q^​\",{\"1\":{\"139\":1,\"140\":1,\"141\":1,\"142\":3}}],[\"−v^\",{\"1\":{\"133\":1,\"134\":2,\"135\":2,\"136\":4,\"138\":1}}],[\"−vπk​\",{\"1\":{\"66\":1}}],[\"−tdtargetvt​ˉ​\",{\"1\":{\"112\":1}}],[\"−αt​\",{\"1\":{\"112\":1,\"116\":1,\"120\":1}}],[\"−\",{\"1\":{\"110\":1,\"112\":1,\"116\":1,\"120\":1}}],[\"−x\",{\"1\":{\"99\":1}}],[\"−xkn​​\",{\"1\":{\"8\":1}}],[\"−e\",{\"1\":{\"99\":1,\"104\":2}}],[\"−f\",{\"1\":{\"58\":1}}],[\"−b\",{\"1\":{\"26\":1}}],[\"−0\",{\"1\":{\"13\":1}}],[\"−1rπk​​\",{\"1\":{\"68\":1}}],[\"−1rπ​\",{\"1\":{\"47\":1}}],[\"−1rπ​​\",{\"1\":{\"47\":1}}],[\"−1\",{\"1\":{\"9\":1,\"10\":2,\"13\":4}}],[\"−ykn​​\",{\"1\":{\"8\":1}}],[\"+e\",{\"1\":{\"234\":1}}],[\"+test\",{\"1\":{\"218\":1}}],[\"+this\",{\"1\":{\"218\":1}}],[\"+name\",{\"1\":{\"218\":2}}],[\"+name+\",{\"1\":{\"162\":1}}],[\"+表示对前面这个字符匹配一次或多次\",{\"1\":{\"212\":1}}],[\"+=\",{\"1\":{\"211\":1}}],[\"+a\",{\"1\":{\"224\":5}}],[\"+array\",{\"1\":{\"202\":1}}],[\"+age+\",{\"1\":{\"162\":1}}],[\"+η▽w​f\",{\"1\":{\"104\":1}}],[\"+η​\",{\"1\":{\"99\":1,\"110\":1}}],[\"+ηk​\",{\"1\":{\"97\":1}}],[\"+γs\",{\"1\":{\"46\":1,\"77\":1}}],[\"+γe\",{\"1\":{\"42\":1,\"45\":1}}],[\"+rtt−rkn​​\",{\"1\":{\"10\":1}}],[\"+c2​\",{\"1\":{\"10\":1}}],[\"+ζ2​moskn​​rate\",{\"1\":{\"10\":1}}],[\"+\",{\"1\":{\"8\":1,\"99\":1,\"110\":1,\"165\":2,\"181\":2,\"193\":1,\"203\":1,\"211\":5,\"212\":2,\"221\":1,\"225\":1,\"241\":1}}],[\"yt​\",{\"1\":{\"142\":1}}],[\"yt​≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yt​−q^​\",{\"1\":{\"142\":2}}],[\"y≐r+γmaxa∈a\",{\"1\":{\"142\":1}}],[\"yuser​\",{\"1\":{\"14\":2}}],[\"yuav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"yd​+1\",{\"1\":{\"13\":1}}],[\"yd​\",{\"1\":{\"13\":1}}],[\"yn​\",{\"1\":{\"8\":2}}],[\"ykn​​\",{\"1\":{\"8\":1}}],[\"x之内的随机数\",{\"1\":{\"241\":1}}],[\"xxxexception\",{\"1\":{\"234\":2}}],[\"xxxxx\",{\"1\":{\"208\":1}}],[\"xi​\",{\"1\":{\"101\":2}}],[\"xk+1​=f\",{\"1\":{\"58\":1}}],[\"xk​→x∗\",{\"1\":{\"58\":1}}],[\"xk​\",{\"1\":{\"58\":2,\"101\":1,\"104\":1,\"110\":1}}],[\"xkn​​\",{\"1\":{\"8\":1}}],[\"x∗\",{\"1\":{\"58\":1}}],[\"x=f\",{\"1\":{\"58\":1}}],[\"x2​\",{\"1\":{\"58\":1,\"75\":1}}],[\"x1​\",{\"1\":{\"58\":1}}],[\"x\",{\"1\":{\"58\":2,\"75\":1,\"94\":1,\"99\":10,\"101\":6,\"104\":17,\"110\":9}}],[\"xuser​\",{\"1\":{\"14\":2}}],[\"xuav​\",{\"1\":{\"13\":1,\"14\":2}}],[\"xt​=⎩⎨⎧​1\",{\"1\":{\"13\":1}}],[\"xd​+1\",{\"1\":{\"13\":1}}],[\"xd​\",{\"1\":{\"13\":1}}],[\"xn​\",{\"1\":{\"8\":2,\"75\":1}}],[\"=========================\",{\"1\":{\"225\":1}}],[\"====================================\",{\"1\":{\"224\":2}}],[\"=================\",{\"1\":{\"225\":1}}],[\"====​n→∞lim​n1​e\",{\"1\":{\"154\":1}}],[\"==\",{\"1\":{\"181\":1,\"182\":2,\"186\":1,\"193\":3,\"210\":3,\"233\":2}}],[\"=θt​+αe\",{\"1\":{\"156\":1}}],[\"=dtvπ​\",{\"1\":{\"150\":1}}],[\"=i=1∑n​yt​−q^​\",{\"1\":{\"142\":1}}],[\"=−2e\",{\"1\":{\"136\":1}}],[\"=−c1​ln\",{\"1\":{\"10\":1}}],[\"=∣s∣1​s∈s∑​\",{\"1\":{\"134\":1}}],[\"=qt​\",{\"1\":{\"116\":1,\"120\":1}}],[\"=vt​\",{\"1\":{\"112\":1}}],[\"=vπ0​​\",{\"1\":{\"70\":1}}],[\"=w−\",{\"1\":{\"110\":1}}],[\"=wk​−αk​▽w​f\",{\"1\":{\"104\":1}}],[\"=wk​−αk​e\",{\"1\":{\"101\":1}}],[\"=wk​−αk​\",{\"1\":{\"99\":1,\"110\":1}}],[\"=▽w​j\",{\"1\":{\"104\":1}}],[\"=g\",{\"1\":{\"97\":1,\"104\":1}}],[\"=k1​\",{\"1\":{\"94\":1}}],[\"=k0​−1dkn​​−α\",{\"1\":{\"9\":1}}],[\"=n1​∑i=1n​xi​\",{\"1\":{\"94\":1}}],[\"=1\",{\"1\":{\"79\":1,\"135\":1,\"150\":1}}],[\"=argmaxπ​∑a​π\",{\"1\":{\"79\":1}}],[\"=argmaxa​qπk​​\",{\"1\":{\"66\":1}}],[\"=argmaxa​qk​\",{\"1\":{\"63\":1}}],[\"=a∑​πk​\",{\"1\":{\"66\":1}}],[\"=a∑​π\",{\"1\":{\"43\":1,\"44\":3,\"45\":1,\"48\":1,\"113\":1}}],[\"=πargmax​a∑​πk​\",{\"1\":{\"66\":1}}],[\"=πargmax​a∑​π\",{\"1\":{\"63\":1}}],[\"=πmax​\",{\"1\":{\"61\":1,\"62\":1}}],[\"=x∗\",{\"1\":{\"58\":1}}],[\"=x\",{\"1\":{\"58\":1}}],[\"=maxa​qk​\",{\"1\":{\"63\":1}}],[\"=maxπ​\",{\"1\":{\"58\":1}}],[\"=maxπ​∑a​π\",{\"1\":{\"57\":1}}],[\"=mean\",{\"1\":{\"45\":1}}],[\"=∑a​π\",{\"1\":{\"49\":1}}],[\"=∑a​qπ​\",{\"1\":{\"48\":1}}],[\"=∑r​p\",{\"1\":{\"48\":1}}],[\"=r∑​rp\",{\"1\":{\"153\":1}}],[\"=r∑​p\",{\"1\":{\"77\":1}}],[\"=rπ​\",{\"1\":{\"46\":1}}],[\"=rt+1​+γgt+1​​\",{\"1\":{\"42\":1}}],[\"=rt+1​+γ\",{\"1\":{\"42\":1}}],[\"=s∈s∑​d\",{\"1\":{\"155\":1}}],[\"=s∈s∑​dπ​\",{\"1\":{\"135\":1}}],[\"=s\",{\"1\":{\"44\":3}}],[\"=sin−1\",{\"1\":{\"9\":1}}],[\"=es∼d\",{\"1\":{\"155\":1}}],[\"=es∼d​\",{\"1\":{\"153\":1,\"155\":1}}],[\"=es∼η\",{\"1\":{\"26\":1}}],[\"=e\",{\"1\":{\"40\":1,\"42\":2,\"48\":1,\"49\":2,\"75\":2,\"77\":1,\"78\":1,\"101\":1,\"104\":4,\"113\":3,\"115\":1,\"119\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"141\":1,\"142\":3,\"151\":1,\"153\":1,\"155\":1}}],[\"=0\",{\"1\":{\"26\":1,\"96\":1,\"98\":2,\"99\":1,\"104\":2,\"110\":1}}],[\"=p\",{\"1\":{\"20\":2}}],[\"=3rtt+rkn​​\",{\"1\":{\"10\":1}}],[\"=ζ1​moskn​​delay\",{\"1\":{\"10\":1}}],[\"=γk0​σ2dkn​​α\",{\"1\":{\"9\":1}}],[\"=b2​ln\",{\"1\":{\"9\":1}}],[\"=bkn​​log2​\",{\"1\":{\"9\":1}}],[\"=b1​\",{\"1\":{\"9\":1}}],[\"=σ2pkn​​gkn​​\",{\"1\":{\"9\":1}}],[\"=\",{\"1\":{\"8\":1,\"19\":1,\"57\":1,\"63\":1,\"66\":1,\"87\":1,\"99\":1,\"110\":1,\"155\":1,\"161\":6,\"162\":3,\"164\":2,\"166\":16,\"170\":1,\"173\":1,\"182\":5,\"184\":4,\"185\":4,\"186\":2,\"187\":3,\"193\":10,\"194\":3,\"195\":6,\"201\":6,\"202\":1,\"203\":2,\"204\":8,\"205\":3,\"206\":1,\"207\":1,\"210\":10,\"211\":13,\"212\":2,\"218\":11,\"219\":2,\"220\":2,\"221\":1,\"222\":4,\"223\":3,\"224\":5,\"225\":6,\"234\":3,\"235\":1,\"241\":2,\"242\":1}}],[\"html\",{\"1\":{\"212\":1}}],[\"https\",{\"1\":{\"212\":1}}],[\"h\",{\"1\":{\"195\":2}}],[\"high\",{\"1\":{\"193\":1}}],[\"hello\",{\"1\":{\"162\":2,\"210\":6,\"220\":1}}],[\"hashcode\",{\"1\":{\"181\":3}}],[\"has\",{\"1\":{\"58\":1}}],[\"hard问题\",{\"1\":{\"13\":1}}],[\"hard\",{\"1\":{\"5\":1}}],[\"hybrid\",{\"1\":{\"14\":1}}],[\"huav​\",{\"1\":{\"13\":2,\"14\":2}}],[\"hmax​−hmin​+1\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​moskn​​\",{\"1\":{\"13\":1}}],[\"hmax​mostotal​=∑n=1n​∑kn​=1kn​​∑t=0ts​​moskn​​\",{\"1\":{\"11\":1}}],[\"hmax​\",{\"1\":{\"8\":1,\"13\":1}}],[\"hmin​≤hn​\",{\"1\":{\"11\":1,\"13\":1}}],[\"hmin​\",{\"1\":{\"8\":1,\"13\":1}}],[\"∈\",{\"1\":{\"8\":1}}],[\"飞行速度恒定\",{\"1\":{\"8\":1}}],[\"其实枚举类型的本质就是一个普通的类\",{\"1\":{\"187\":1}}],[\"其子类的对应的方法的访问权限需要高于抽象类中的方法\",{\"1\":{\"184\":1}}],[\"其他很多语言比如javascript\",{\"1\":{\"212\":1}}],[\"其他定义方法\",{\"1\":{\"201\":1}}],[\"其他地方不能修改\",{\"1\":{\"183\":1}}],[\"其他的情况会在讲到反射时介绍\",{\"1\":{\"171\":1}}],[\"其他的算法\",{\"1\":{\"156\":1}}],[\"其变量名存储的是对象的引用\",{\"1\":{\"161\":1}}],[\"其求解梯度比较难求\",{\"1\":{\"142\":1}}],[\"其定义都是一个均值\",{\"1\":{\"92\":1}}],[\"其探索性就很强\",{\"1\":{\"87\":1}}],[\"其属于\",{\"1\":{\"87\":1}}],[\"其原始定义都是从期望出发的\",{\"1\":{\"75\":1}}],[\"其核心思想是\",{\"1\":{\"75\":1}}],[\"其对应的\",{\"1\":{\"63\":1}}],[\"其策略π表示的是最优策略\",{\"1\":{\"55\":1}}],[\"其目标也应该不一样\",{\"1\":{\"13\":1}}],[\"其状态为其3d坐标\",{\"1\":{\"13\":1}}],[\"其高度的下界是距离dkn​​\",{\"1\":{\"9\":1}}],[\"其每个用户带宽表示为\",{\"1\":{\"9\":1}}],[\"其可用带宽为bn​\",{\"1\":{\"9\":1}}],[\"其水平坐标表示为qn​\",{\"1\":{\"8\":1}}],[\"其垂直高度表示为hn​\",{\"1\":{\"8\":1}}],[\"其坐标表示为wkn​​=\",{\"1\":{\"8\":1}}],[\"其中存放的每一个数据称为数组的一个元素\",{\"1\":{\"200\":1}}],[\"其中能够表示数字的基本类型包装类\",{\"1\":{\"193\":1}}],[\"其中public和abstract关键字可以省略\",{\"1\":{\"185\":1}}],[\"其中的\",{\"1\":{\"173\":1}}],[\"其中st​是随机变量s的一个样本\",{\"1\":{\"136\":1}}],[\"其中w∈rm是参数向量\",{\"1\":{\"131\":1}}],[\"其中hk​=wk​\",{\"1\":{\"98\":1}}],[\"其中ak∗​=argmaxa​qπk​​\",{\"1\":{\"79\":1}}],[\"其中ak∗​\",{\"1\":{\"63\":1}}],[\"其中a∗表示在该状态下计算出来的最大\",{\"1\":{\"57\":1}}],[\"其中vk​是给定的\",{\"1\":{\"63\":1}}],[\"其中f\",{\"1\":{\"58\":1}}],[\"其中cmax​表示用户的最大速度\",{\"1\":{\"14\":1}}],[\"其中\",{\"1\":{\"9\":1,\"10\":2,\"46\":1,\"66\":1,\"87\":1,\"96\":1,\"97\":1,\"101\":1,\"110\":1,\"112\":1,\"113\":1,\"116\":1,\"135\":1,\"141\":1,\"148\":1,\"153\":1,\"155\":1,\"212\":1}}],[\"其中σ2=bkn​​n0​\",{\"1\":{\"9\":1}}],[\"其中k0​=\",{\"1\":{\"9\":1}}],[\"其中kn​表示划分到集群n的用户\",{\"1\":{\"8\":1}}],[\"其中θkn​​\",{\"1\":{\"9\":1}}],[\"其中用户表示为k=k1​\",{\"1\":{\"8\":1}}],[\"在编译阶段就需要进行处理\",{\"1\":{\"231\":1}}],[\"在编译阶段无法感知代码是否会出现问题\",{\"1\":{\"231\":1}}],[\"在new的时候\",{\"1\":{\"222\":1}}],[\"在内部类中使用this关键字\",{\"1\":{\"218\":1}}],[\"在成员内部类中\",{\"1\":{\"218\":1}}],[\"在成员变量初始化之后执行\",{\"1\":{\"166\":1}}],[\"在c中就是一个字符数组\",{\"1\":{\"209\":1}}],[\"在运行时动态创建\",{\"1\":{\"201\":1}}],[\"在修改后\",{\"1\":{\"182\":1}}],[\"在回收之前\",{\"1\":{\"181\":1}}],[\"在当前包以外的其他包中无法访问\",{\"1\":{\"174\":1}}],[\"在当前状态s下\",{\"1\":{\"48\":1}}],[\"在当前状态s下采取动作\",{\"1\":{\"48\":1}}],[\"在不同包下的类\",{\"1\":{\"173\":1}}],[\"在放入包中\",{\"1\":{\"173\":1}}],[\"在静态方法中\",{\"1\":{\"170\":1}}],[\"在赋值之前看看是否有初始值\",{\"1\":{\"166\":1}}],[\"在我们自己定义一个构造方法之后\",{\"1\":{\"166\":1}}],[\"在创建了对象之后\",{\"1\":{\"161\":1}}],[\"在状态s采用动作a\",{\"1\":{\"153\":1}}],[\"在该策略下的所有\",{\"1\":{\"148\":1}}],[\"在该文中考虑的是网页浏览应用传输情况\",{\"1\":{\"10\":1}}],[\"在该文中\",{\"1\":{\"10\":1}}],[\"在原文是\",{\"1\":{\"144\":1}}],[\"在训练求解梯度时\",{\"1\":{\"142\":1}}],[\"在每一次迭代时\",{\"1\":{\"142\":1}}],[\"在初始化的时候是设为相同的\",{\"1\":{\"142\":1}}],[\"在初始时间假设用户处于静止下不断调整\",{\"1\":{\"5\":1}}],[\"在将\",{\"1\":{\"142\":1}}],[\"在计算\",{\"1\":{\"142\":1}}],[\"在通过经验来更新这个策略\",{\"1\":{\"122\":1}}],[\"在之前关于使用\",{\"1\":{\"105\":1}}],[\"在这里\",{\"1\":{\"87\":1}}],[\"在收集到了足够多的\",{\"1\":{\"82\":1}}],[\"在求解\",{\"1\":{\"71\":1}}],[\"在策略更新上\",{\"1\":{\"70\":1}}],[\"在策略梯度算法中引入一个\",{\"1\":{\"26\":1}}],[\"在实际情况中\",{\"1\":{\"27\":1}}],[\"在实际应用中\",{\"1\":{\"9\":1}}],[\"在\",{\"1\":{\"25\":1,\"68\":2,\"86\":1,\"138\":1,\"142\":1,\"183\":1,\"222\":1,\"233\":1}}],[\"在policy是确定的情况下\",{\"1\":{\"20\":1}}],[\"在执行一个动作后获得的一个常数\",{\"1\":{\"19\":1}}],[\"在此情况下\",{\"1\":{\"14\":1}}],[\"在本文中\",{\"1\":{\"14\":1}}],[\"在本文中不考虑用户移动到其他集群的情况\",{\"1\":{\"14\":1}}],[\"在设计无人机的移动之前\",{\"1\":{\"14\":1}}],[\"在时刻t关联到无人机n的地面用户kn​的接受到的信噪比表示为\",{\"1\":{\"9\":1}}],[\"在时间t\",{\"1\":{\"9\":1}}],[\"在任意时刻t\",{\"1\":{\"8\":1}}],[\"27\",{\"1\":{\"185\":1}}],[\"2种方法\",{\"1\":{\"49\":1}}],[\"20\",{\"1\":{\"223\":1,\"225\":2,\"241\":1}}],[\"20241029001425\",{\"1\":{\"231\":1}}],[\"20241027015718\",{\"1\":{\"221\":1}}],[\"20241027015244\",{\"1\":{\"221\":1}}],[\"20241027012950\",{\"1\":{\"218\":1}}],[\"20241017002218\",{\"1\":{\"193\":1}}],[\"20240826181712\",{\"1\":{\"157\":1}}],[\"20240826181638\",{\"1\":{\"156\":1}}],[\"20240826181538\",{\"1\":{\"156\":1}}],[\"20240826181340\",{\"1\":{\"156\":1}}],[\"20240826180244\",{\"1\":{\"155\":1}}],[\"20240826173749\",{\"1\":{\"151\":1}}],[\"20240820231205\",{\"1\":{\"144\":1}}],[\"20240820231024\",{\"1\":{\"144\":1}}],[\"20240820230944\",{\"1\":{\"143\":1}}],[\"20240820230920\",{\"1\":{\"143\":1}}],[\"20240820230827\",{\"1\":{\"143\":1}}],[\"20240820184405\",{\"1\":{\"140\":1}}],[\"20240820184127\",{\"1\":{\"139\":1}}],[\"20240820181718\",{\"1\":{\"135\":1}}],[\"20240820181406\",{\"1\":{\"135\":1}}],[\"20240815234719\",{\"1\":{\"173\":1}}],[\"20240818182231\",{\"1\":{\"127\":1}}],[\"20240818182301\",{\"1\":{\"127\":1}}],[\"20240818182057\",{\"1\":{\"125\":1}}],[\"20240818181917\",{\"1\":{\"126\":1}}],[\"20240817000409\",{\"1\":{\"118\":1}}],[\"20240817000331\",{\"1\":{\"118\":1}}],[\"20240817000642\",{\"1\":{\"117\":1}}],[\"20240817000601\",{\"1\":{\"117\":1}}],[\"20240817000500\",{\"1\":{\"117\":1}}],[\"20240817000230\",{\"1\":{\"116\":1}}],[\"20240817000134\",{\"1\":{\"116\":1}}],[\"20240817000114\",{\"1\":{\"116\":1}}],[\"20240814230747\",{\"1\":{\"106\":1}}],[\"20240814014058\",{\"1\":{\"103\":1}}],[\"20240812010538\",{\"1\":{\"89\":1}}],[\"20240812011140\",{\"1\":{\"88\":1}}],[\"20240812004534\",{\"1\":{\"83\":1}}],[\"20240811233346\",{\"1\":{\"79\":1}}],[\"20240811011334\",{\"1\":{\"72\":1}}],[\"20240811010933\",{\"1\":{\"71\":1}}],[\"20240811002219\",{\"1\":{\"67\":1}}],[\"20240810190018\",{\"1\":{\"64\":1}}],[\"20240830200624\",{\"1\":{\"33\":1}}],[\"20240830200608\",{\"1\":{\"33\":1}}],[\"20240830200406\",{\"1\":{\"32\":1}}],[\"20240830200343\",{\"1\":{\"31\":1}}],[\"20240830200320\",{\"1\":{\"31\":1}}],[\"20240830200305\",{\"1\":{\"31\":1}}],[\"20240830200248\",{\"1\":{\"31\":1}}],[\"20240830200138\",{\"1\":{\"30\":1}}],[\"20240830200118\",{\"1\":{\"30\":1}}],[\"20240830200056\",{\"1\":{\"30\":1}}],[\"20240830185629\",{\"1\":{\"28\":1}}],[\"20240830185556\",{\"1\":{\"28\":1}}],[\"20240830185537\",{\"1\":{\"28\":1}}],[\"20240830185324\",{\"1\":{\"27\":1}}],[\"20240830185127\",{\"1\":{\"26\":1}}],[\"20240830184424\",{\"1\":{\"24\":1}}],[\"20240830184330\",{\"1\":{\"24\":1}}],[\"20240830184312\",{\"1\":{\"23\":1}}],[\"20240830184236\",{\"1\":{\"23\":1}}],[\"2019\",{\"1\":{\"3\":1}}],[\"2l−1\",{\"1\":{\"10\":1}}],[\"2mssfs​+1\",{\"1\":{\"10\":1}}],[\"2mss\",{\"1\":{\"10\":1}}],[\"2~3\",{\"1\":{\"10\":1}}],[\"2​\",{\"1\":{\"8\":1}}],[\"2+\",{\"1\":{\"8\":1}}],[\"2\",{\"0\":{\"20\":1,\"25\":1,\"26\":1,\"27\":2,\"28\":1,\"31\":1,\"40\":1,\"42\":1,\"43\":1,\"44\":2,\"45\":1,\"46\":1,\"54\":1,\"55\":1,\"56\":2,\"57\":2,\"58\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":2,\"68\":1,\"71\":1,\"78\":1,\"80\":1,\"81\":1,\"82\":2,\"83\":1,\"84\":1,\"87\":1,\"95\":1,\"96\":1,\"97\":2,\"98\":1,\"99\":1,\"102\":1,\"111\":1,\"112\":1,\"113\":2,\"114\":1,\"117\":1,\"121\":1,\"132\":1,\"133\":1,\"136\":2,\"149\":1,\"150\":1,\"153\":2,\"199\":1},\"1\":{\"8\":1,\"9\":1,\"13\":1,\"14\":1,\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"70\":1,\"79\":2,\"94\":1,\"97\":1,\"101\":1,\"112\":1,\"116\":1,\"133\":1,\"134\":2,\"135\":2,\"136\":2,\"141\":1,\"142\":2,\"205\":2,\"206\":2,\"211\":1,\"212\":2,\"241\":1,\"242\":1}}],[\"即之后不能修改\",{\"1\":{\"223\":1}}],[\"即使用初始化块\",{\"1\":{\"222\":1}}],[\"即使是基本类型的数组\",{\"1\":{\"201\":1}}],[\"即使是最大的long类型\",{\"1\":{\"195\":1}}],[\"即使是两个不同的对象\",{\"1\":{\"182\":1}}],[\"即使强制类型转换\",{\"1\":{\"182\":1}}],[\"即使类名相同\",{\"1\":{\"173\":1}}],[\"即使先估计了\",{\"1\":{\"79\":1}}],[\"即空指针异常\",{\"1\":{\"161\":1}}],[\"即在策略\",{\"1\":{\"152\":1}}],[\"即在状态s1​下采用动作a1​获得的奖励r=1的概率\",{\"1\":{\"19\":1}}],[\"即此时策略\",{\"1\":{\"148\":1}}],[\"即此时的discounted\",{\"1\":{\"19\":1}}],[\"即基于一个策略\",{\"1\":{\"135\":1}}],[\"即各个状态的可能性为∣s∣1​\",{\"1\":{\"134\":1}}],[\"即我通过一个策略与环境进行交互生成一系列经验\",{\"1\":{\"123\":1}}],[\"即我通过这个策略与环境进行交互生成一系列经验\",{\"1\":{\"122\":1}}],[\"即函数\",{\"1\":{\"97\":1}}],[\"即不需要完全精确地求出\",{\"1\":{\"82\":1}}],[\"即不具备terminal\",{\"1\":{\"19\":1}}],[\"即对于损失函数中的\",{\"1\":{\"133\":1}}],[\"即对于数据\",{\"1\":{\"80\":1}}],[\"即对于每个状态\",{\"1\":{\"79\":1}}],[\"即对于给定策略\",{\"1\":{\"47\":1}}],[\"即p\",{\"1\":{\"75\":1}}],[\"即j→∞\",{\"1\":{\"66\":1}}],[\"即求解右边的式子\",{\"1\":{\"63\":1}}],[\"即f\",{\"1\":{\"58\":1}}],[\"即a∗=argmaxa​q\",{\"1\":{\"57\":1}}],[\"即可以通过梯度下降\",{\"1\":{\"142\":1}}],[\"即可\",{\"1\":{\"57\":1,\"77\":1,\"162\":1}}],[\"即vπ​\",{\"1\":{\"49\":1}}],[\"即一个trajectory下的discounted\",{\"1\":{\"39\":1}}],[\"即\",{\"1\":{\"26\":1,\"63\":2,\"66\":2,\"68\":1,\"77\":1,\"78\":2,\"94\":1,\"99\":1,\"137\":1,\"161\":1,\"184\":1,\"185\":1,\"204\":1}}],[\"即无记忆的特性\",{\"1\":{\"20\":1}}],[\"即无人机作为空中基站\",{\"1\":{\"8\":1}}],[\"即表示具有终止状态terminal\",{\"1\":{\"19\":1}}],[\"即状态s1​采用动作a1​转到状态s2​的概率\",{\"1\":{\"19\":1}}],[\"即ξ=\",{\"1\":{\"14\":1}}],[\"即xuav​\",{\"1\":{\"13\":1}}],[\"即γ≥γkn​​\",{\"1\":{\"9\":1}}],[\"即需要考虑地面不同用户的具体需求\",{\"1\":{\"4\":1}}],[\"lbwnb\",{\"1\":{\"208\":1,\"225\":2}}],[\"length方法可以求字符串长度\",{\"1\":{\"210\":1}}],[\"length属性是int类型的值\",{\"1\":{\"202\":1}}],[\"length\",{\"1\":{\"202\":2,\"203\":1,\"210\":2}}],[\"learning是优化长期目标\",{\"1\":{\"13\":1}}],[\"learning的部署算法不同的是\",{\"1\":{\"14\":1}}],[\"learning的移动算法\",{\"1\":{\"14\":1}}],[\"learning的优化目标是最大化长期收益\",{\"1\":{\"13\":1}}],[\"learning的方案来解决无人机的np\",{\"1\":{\"5\":1}}],[\"learning算法\",{\"1\":{\"13\":1}}],[\"learning\",{\"0\":{\"3\":1,\"109\":1,\"111\":1,\"115\":1,\"119\":1,\"120\":1,\"124\":1,\"137\":1,\"138\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"119\":1,\"120\":1,\"123\":1,\"124\":1,\"141\":1}}],[\"lnπ\",{\"1\":{\"155\":1}}],[\"low\",{\"1\":{\"193\":2}}],[\"loss\",{\"1\":{\"141\":1}}],[\"long\",{\"1\":{\"135\":1,\"181\":2,\"193\":3,\"195\":1}}],[\"limiting\",{\"1\":{\"135\":1}}],[\"link\",{\"1\":{\"8\":1}}],[\"lambda表达式的具体规范\",{\"1\":{\"224\":1}}],[\"lambda表达式\",{\"0\":{\"224\":1}}],[\"lambda\",{\"1\":{\"223\":1,\"224\":1}}],[\"lang包下的类\",{\"1\":{\"241\":1}}],[\"lang包下的\",{\"1\":{\"173\":1}}],[\"lang\",{\"1\":{\"173\":1,\"186\":1,\"187\":2}}],[\"lang这个包下的所有类\",{\"1\":{\"173\":1}}],[\"large\",{\"1\":{\"75\":1}}],[\"law\",{\"1\":{\"75\":1}}],[\"l2​=log2​\",{\"1\":{\"10\":1}}],[\"l2​\",{\"1\":{\"10\":1}}],[\"l1​=log2​\",{\"1\":{\"10\":1}}],[\"l1​\",{\"1\":{\"10\":1}}],[\"l=min\",{\"1\":{\"10\":1}}],[\"考虑能否仅用一次\",{\"1\":{\"101\":1}}],[\"考虑一个复杂的均值估计问题\",{\"1\":{\"110\":1}}],[\"考虑一个\",{\"1\":{\"81\":1}}],[\"考虑\",{\"1\":{\"70\":2}}],[\"考虑用户在每个时隙移动的情况\",{\"1\":{\"14\":1}}],[\"考虑以下场景\",{\"1\":{\"13\":1}}],[\"考虑无人机辅助无线网络的下行链路传输\",{\"1\":{\"8\":1}}],[\"考虑qoe\",{\"1\":{\"4\":1}}],[\"系统结构\",{\"0\":{\"7\":1}}],[\"的构造方法中我们可以写入原因\",{\"1\":{\"233\":1}}],[\"的变量\",{\"1\":{\"223\":1}}],[\"的匿名类\",{\"1\":{\"222\":1}}],[\"的方式去创建一个抽象类或是接口对象\",{\"1\":{\"222\":1}}],[\"的方式使用静态内容\",{\"1\":{\"185\":1}}],[\"的方法进行解决\",{\"1\":{\"142\":1}}],[\"的方法\",{\"1\":{\"29\":1,\"68\":1,\"85\":1,\"147\":2}}],[\"的使用\",{\"0\":{\"164\":1}}],[\"的算法\",{\"1\":{\"156\":1}}],[\"的选择\",{\"0\":{\"152\":1}}],[\"的权重或者分布\",{\"1\":{\"155\":1}}],[\"的权重\",{\"1\":{\"150\":1}}],[\"的加权平均\",{\"1\":{\"150\":1}}],[\"的加权均值\",{\"1\":{\"48\":1}}],[\"的基本步骤\",{\"1\":{\"148\":1}}],[\"的基础上来引入偏置量\",{\"1\":{\"25\":1}}],[\"的文章中\",{\"1\":{\"144\":1}}],[\"的输出是不一样的\",{\"1\":{\"144\":1}}],[\"的输出\",{\"1\":{\"142\":1}}],[\"的参数\",{\"1\":{\"142\":1}}],[\"的就不是有关\",{\"1\":{\"142\":1}}],[\"的梯度时\",{\"1\":{\"142\":1}}],[\"的分布\",{\"1\":{\"135\":1}}],[\"的新形式\",{\"1\":{\"113\":1}}],[\"的定义\",{\"1\":{\"113\":1}}],[\"的定义出发\",{\"1\":{\"77\":1}}],[\"的估计从\",{\"1\":{\"130\":1}}],[\"的估计\",{\"1\":{\"112\":1,\"116\":1}}],[\"的采样\",{\"1\":{\"110\":1}}],[\"的思想\",{\"1\":{\"101\":1}}],[\"的值\",{\"1\":{\"99\":1}}],[\"的动作数量\",{\"1\":{\"87\":1}}],[\"的高效利用\",{\"0\":{\"81\":1}}],[\"的一些改进\",{\"1\":{\"80\":1}}],[\"的一个观测值\",{\"1\":{\"104\":1}}],[\"的一个\",{\"1\":{\"78\":1}}],[\"的情况\",{\"1\":{\"76\":1,\"77\":2,\"104\":1}}],[\"的情况下进行估计\",{\"1\":{\"75\":1}}],[\"的原理\",{\"1\":{\"76\":1}}],[\"的\",{\"1\":{\"63\":1,\"66\":1,\"77\":1,\"78\":2,\"81\":1,\"84\":1,\"86\":1,\"87\":1,\"111\":1,\"113\":2,\"123\":2,\"124\":2,\"133\":1,\"155\":1,\"185\":1,\"202\":1}}],[\"的策略来进行选择\",{\"1\":{\"66\":1}}],[\"的策略πk+1​\",{\"1\":{\"63\":1}}],[\"的策略所采集的数据来\",{\"1\":{\"29\":1}}],[\"的形式\",{\"1\":{\"58\":1,\"99\":1,\"225\":2}}],[\"的根据策略π加权平均\",{\"1\":{\"49\":1}}],[\"的转到下一个状态的\",{\"1\":{\"48\":1}}],[\"的过程\",{\"1\":{\"47\":1}}],[\"的计算即可\",{\"1\":{\"42\":1}}],[\"的区别\",{\"0\":{\"41\":1}}],[\"的期望\",{\"1\":{\"40\":1}}],[\"的概率\",{\"1\":{\"20\":2}}],[\"的s是有范围的\",{\"1\":{\"13\":1}}],[\"的函数\",{\"1\":{\"9\":1,\"142\":1}}],[\"的功率谱密度\",{\"1\":{\"9\":1}}],[\"的无人机3d动态运动设计算法\",{\"1\":{\"5\":1}}],[\"的部署方法\",{\"1\":{\"5\":1}}],[\"以及object的方法\",{\"1\":{\"185\":1}}],[\"以及是否可以到最后优化的成果\",{\"1\":{\"101\":1}}],[\"以及\",{\"1\":{\"69\":1,\"88\":1,\"155\":1,\"212\":2}}],[\"以向用户提供可靠的服务\",{\"1\":{\"9\":1}}],[\"以\",{\"1\":{\"5\":1}}],[\"该咋写咋写\",{\"1\":{\"224\":1}}],[\"该怎么处理\",{\"1\":{\"195\":1}}],[\"该算法中\",{\"1\":{\"122\":1,\"123\":1}}],[\"该算法是\",{\"1\":{\"69\":1}}],[\"该方法成立的数学依据是\",{\"1\":{\"75\":1}}],[\"该步骤是根据\",{\"1\":{\"66\":1}}],[\"该步骤是用来计算当前策略\",{\"1\":{\"66\":1}}],[\"该式子针对状态空间中的所有状态均成立\",{\"1\":{\"45\":1}}],[\"该论文中在精度和模型复杂型上作出平衡\",{\"1\":{\"13\":1}}],[\"该问题依然是np\",{\"1\":{\"13\":1}}],[\"该优化问题是一个non\",{\"1\":{\"11\":1}}],[\"该文中不同集群所利用的频谱是不同的\",{\"1\":{\"9\":1}}],[\"该文中表示为\",{\"1\":{\"9\":1}}],[\"该文提出的算法具较快的收敛性\",{\"1\":{\"5\":1}}],[\"该文基于q\",{\"1\":{\"5\":1}}],[\"该文设计的是3d部署\",{\"1\":{\"4\":1}}],[\"该框架将无人机部署在三维空间内\",{\"1\":{\"5\":1}}],[\"过去研究主要考虑的是2d部署\",{\"1\":{\"4\":1}}],[\"过去研究大多没有基于用户的移动\",{\"1\":{\"4\":1}}],[\"sqrt\",{\"1\":{\"241\":1}}],[\"ss\",{\"1\":{\"222\":2}}],[\"syntax\",{\"1\":{\"212\":1}}],[\"system\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"170\":2,\"174\":1,\"182\":2,\"184\":1,\"185\":2,\"186\":4,\"187\":1,\"193\":3,\"194\":1,\"195\":2,\"202\":1,\"203\":2,\"206\":1,\"207\":1,\"208\":1,\"210\":6,\"211\":3,\"212\":2,\"218\":5,\"219\":1,\"220\":1,\"221\":7,\"222\":3,\"223\":1,\"224\":3,\"225\":2,\"234\":3,\"241\":2,\"242\":1}}],[\"split\",{\"1\":{\"210\":2}}],[\"space\",{\"1\":{\"13\":2,\"19\":3}}],[\"short\",{\"1\":{\"193\":3}}],[\"sleep\",{\"1\":{\"187\":4}}],[\"slove\",{\"0\":{\"47\":1}}],[\"slow\",{\"1\":{\"10\":1}}],[\"sub\",{\"1\":{\"210\":2}}],[\"substring\",{\"1\":{\"210\":2}}],[\"super\",{\"1\":{\"180\":1,\"182\":3,\"184\":1,\"185\":1,\"186\":2,\"218\":2,\"232\":2}}],[\"supposed\",{\"1\":{\"4\":1}}],[\"sum\",{\"1\":{\"165\":2,\"225\":5}}],[\"s∣s\",{\"1\":{\"155\":1}}],[\"s∣a\",{\"1\":{\"57\":1,\"58\":1}}],[\"s∑​dπ​\",{\"1\":{\"154\":1}}],[\"scalar\",{\"1\":{\"148\":1}}],[\"score\",{\"1\":{\"5\":1}}],[\"sgdw\",{\"0\":{\"106\":1}}],[\"sgd的目标是\",{\"1\":{\"104\":1}}],[\"sgd\",{\"0\":{\"102\":1,\"104\":1,\"105\":1},\"1\":{\"101\":1,\"104\":3,\"105\":2,\"136\":1,\"155\":1}}],[\"s5​\",{\"1\":{\"81\":1}}],[\"s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​\",{\"1\":{\"81\":4}}],[\"s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s2​∣s1​\",{\"1\":{\"19\":1}}],[\"sex\",{\"1\":{\"161\":1,\"162\":1,\"166\":14,\"170\":1,\"174\":1,\"182\":2,\"184\":6,\"185\":2,\"186\":2,\"207\":1}}],[\"sequence\",{\"1\":{\"58\":1}}],[\"setname\",{\"1\":{\"164\":2}}],[\"set\",{\"1\":{\"20\":3}}],[\"setstatus\",{\"1\":{\"187\":2}}],[\"sets\",{\"1\":{\"20\":1}}],[\"s​=maxπ​∑a​π\",{\"1\":{\"58\":1}}],[\"sort\",{\"1\":{\"242\":1}}],[\"soloving\",{\"1\":{\"92\":1}}],[\"solution\",{\"1\":{\"47\":2}}],[\"soft\",{\"0\":{\"86\":1},\"1\":{\"85\":1,\"86\":2,\"87\":1}}],[\"some\",{\"1\":{\"19\":1,\"116\":1}}],[\"sj​∣si​\",{\"1\":{\"46\":1}}],[\"sn​\",{\"1\":{\"46\":2}}],[\"satic\",{\"1\":{\"182\":1}}],[\"satisfying\",{\"1\":{\"98\":1}}],[\"satisfaction\",{\"1\":{\"4\":1}}],[\"sa​\",{\"1\":{\"116\":2}}],[\"sarsa\",{\"0\":{\"116\":1,\"117\":1,\"118\":1,\"139\":1},\"1\":{\"115\":3,\"116\":1,\"123\":1}}],[\"sa\",{\"1\":{\"92\":2}}],[\"samples\",{\"1\":{\"101\":1,\"142\":1}}],[\"sample\",{\"1\":{\"78\":1,\"99\":1,\"101\":1}}],[\"sampling\",{\"0\":{\"30\":1}}],[\"s0​\",{\"1\":{\"20\":2,\"112\":1}}],[\"s∈s​\",{\"1\":{\"135\":1}}],[\"s∈s\",{\"1\":{\"20\":1,\"63\":1,\"66\":2,\"113\":2}}],[\"s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":1}}],[\"s1​a2​​s2​a4​​s1​a2​​s2​a3​​s5​a1​​\",{\"1\":{\"81\":2}}],[\"s1​\",{\"1\":{\"46\":2,\"81\":4,\"112\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​r=1→​a2​​s9​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​r=0→​a2​​s2​r=0→​a2​​s5​r=0→​a2​​s8​r=1→​a2​​s9​\",{\"1\":{\"19\":1}}],[\"s1​→a1​s2​\",{\"1\":{\"19\":1}}],[\"simplest\",{\"0\":{\"24\":1}}],[\"si​\",{\"1\":{\"19\":2,\"142\":2}}],[\"single\",{\"1\":{\"82\":1,\"154\":1}}],[\"sin\",{\"1\":{\"9\":1}}],[\"s=\",{\"1\":{\"19\":1}}],[\"str5\",{\"1\":{\"211\":4}}],[\"str\",{\"1\":{\"210\":8,\"212\":5}}],[\"str4\",{\"1\":{\"210\":2,\"211\":4}}],[\"str3\",{\"1\":{\"210\":2,\"211\":4}}],[\"str2\",{\"1\":{\"210\":3,\"211\":4}}],[\"str1\",{\"1\":{\"210\":3,\"211\":4}}],[\"string的拼接会在编译时进行各种优化\",{\"1\":{\"211\":1}}],[\"stringbuilder\",{\"0\":{\"211\":1},\"1\":{\"211\":5}}],[\"string类重载了equals方法用于判断和比较内容是否相同\",{\"1\":{\"210\":1}}],[\"string本身也是一个类\",{\"1\":{\"210\":1}}],[\"strings这个变量就是一个string\",{\"1\":{\"207\":1}}],[\"strings\",{\"1\":{\"207\":3,\"210\":2}}],[\"string\",{\"0\":{\"210\":1},\"1\":{\"161\":5,\"162\":3,\"164\":3,\"166\":14,\"170\":4,\"173\":6,\"174\":3,\"181\":1,\"184\":8,\"185\":4,\"186\":3,\"187\":5,\"193\":4,\"194\":1,\"195\":2,\"201\":1,\"202\":1,\"203\":1,\"204\":6,\"205\":1,\"206\":1,\"207\":8,\"208\":2,\"210\":18,\"211\":14,\"212\":4,\"218\":10,\"219\":3,\"220\":2,\"221\":2,\"222\":4,\"223\":1,\"224\":3,\"225\":8,\"232\":2,\"234\":4,\"235\":1,\"241\":2,\"242\":1}}],[\"study\",{\"1\":{\"185\":15,\"186\":2,\"187\":4,\"222\":6,\"223\":3,\"224\":18,\"225\":15}}],[\"student\",{\"1\":{\"182\":4,\"185\":2,\"186\":10,\"187\":6,\"222\":5}}],[\"steady\",{\"1\":{\"135\":1}}],[\"step\",{\"0\":{\"117\":1},\"1\":{\"66\":2,\"79\":2,\"154\":1}}],[\"st+2​→at+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+2​→at+2​rt+3​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​=s\",{\"1\":{\"44\":2}}],[\"st+1​→at+1​rt+2​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st+1​∣at+1​\",{\"1\":{\"20\":3}}],[\"st+1​\",{\"1\":{\"13\":1,\"112\":4,\"116\":2,\"119\":1,\"120\":1,\"138\":2,\"139\":1,\"140\":2}}],[\"st​→at​rt+1​\",{\"1\":{\"39\":1,\"42\":1}}],[\"st​\",{\"1\":{\"20\":4,\"112\":12,\"116\":6,\"120\":5,\"136\":4,\"137\":4,\"138\":3,\"139\":2,\"140\":2,\"156\":1}}],[\"stochastic\",{\"0\":{\"100\":1},\"1\":{\"19\":1,\"53\":1,\"86\":1,\"92\":2}}],[\"stop\",{\"1\":{\"19\":1}}],[\"static\",{\"1\":{\"161\":3,\"162\":1,\"170\":5,\"173\":2,\"174\":3,\"181\":2,\"185\":3,\"186\":1,\"187\":8,\"193\":5,\"194\":1,\"195\":2,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":1,\"207\":1,\"208\":1,\"210\":3,\"211\":3,\"212\":2,\"218\":2,\"219\":2,\"221\":10,\"222\":3,\"223\":1,\"224\":4,\"225\":5,\"233\":3,\"234\":6,\"235\":1,\"241\":2,\"242\":1}}],[\"stationary\",{\"0\":{\"135\":1},\"1\":{\"135\":2,\"152\":1}}],[\"statrts的解释\",{\"0\":{\"84\":1}}],[\"status>\",{\"1\":{\"187\":1}}],[\"status\",{\"1\":{\"19\":1,\"187\":22}}],[\"statevalue\",{\"1\":{\"136\":1}}],[\"states中\",{\"1\":{\"19\":1}}],[\"states中限制action\",{\"1\":{\"19\":1}}],[\"states的任务\",{\"1\":{\"19\":1}}],[\"states的trajectory\",{\"1\":{\"19\":1}}],[\"states\",{\"1\":{\"19\":1,\"20\":1}}],[\"state\",{\"0\":{\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"58\":1,\"111\":1,\"132\":1,\"150\":1},\"1\":{\"13\":2,\"19\":6,\"20\":4,\"37\":1,\"40\":4,\"41\":4,\"42\":1,\"45\":1,\"47\":1,\"48\":6,\"49\":2,\"52\":1,\"55\":1,\"56\":1,\"63\":1,\"66\":2,\"68\":1,\"70\":2,\"71\":1,\"75\":1,\"77\":3,\"79\":3,\"81\":6,\"82\":1,\"84\":2,\"86\":1,\"92\":1,\"111\":1,\"113\":2,\"115\":2,\"131\":1,\"135\":1,\"148\":1,\"150\":2,\"155\":1}}],[\"starts\",{\"0\":{\"80\":1,\"83\":1},\"1\":{\"80\":1,\"84\":2,\"85\":1}}],[\"starting\",{\"1\":{\"41\":1,\"48\":2}}],[\"start\",{\"1\":{\"10\":1}}],[\"s\",{\"0\":{\"152\":1},\"1\":{\"9\":1,\"10\":1,\"11\":1,\"13\":5,\"20\":5,\"26\":4,\"27\":1,\"40\":2,\"41\":1,\"42\":1,\"44\":10,\"45\":7,\"46\":4,\"48\":13,\"49\":4,\"53\":3,\"55\":4,\"57\":2,\"63\":11,\"66\":13,\"75\":3,\"77\":9,\"78\":8,\"79\":4,\"82\":1,\"84\":6,\"87\":6,\"112\":2,\"113\":7,\"115\":2,\"116\":3,\"119\":1,\"120\":3,\"131\":2,\"132\":2,\"133\":3,\"134\":4,\"135\":8,\"136\":7,\"141\":5,\"142\":28,\"150\":6,\"152\":1,\"153\":8,\"154\":2,\"155\":12,\"156\":4,\"212\":4}}],[\"q^​\",{\"1\":{\"142\":5}}],[\"qt​\",{\"1\":{\"116\":2,\"120\":1,\"156\":1}}],[\"qt+1​\",{\"1\":{\"116\":2,\"120\":2}}],[\"qπk​​\",{\"1\":{\"66\":1,\"77\":2,\"78\":2,\"79\":1}}],[\"qπ​\",{\"1\":{\"26\":2,\"48\":3,\"49\":1,\"75\":1,\"115\":1,\"155\":8,\"156\":4}}],[\"qac\",{\"0\":{\"24\":1},\"1\":{\"25\":1}}],[\"q\",{\"0\":{\"120\":1,\"124\":1,\"140\":1,\"141\":1},\"1\":{\"5\":2,\"11\":1,\"13\":2,\"14\":1,\"23\":1,\"49\":1,\"55\":1,\"57\":1,\"58\":1,\"77\":1,\"79\":1,\"81\":2,\"119\":2,\"120\":1,\"123\":1,\"124\":1,\"130\":1,\"141\":1}}],[\"qoe\",{\"1\":{\"4\":1}}],[\"quality\",{\"0\":{\"10\":1},\"1\":{\"4\":1}}],[\"util\",{\"1\":{\"241\":2,\"242\":1}}],[\"u\",{\"1\":{\"212\":2}}],[\"uses\",{\"1\":{\"82\":1}}],[\"users\",{\"1\":{\"4\":2}}],[\"u0​pu​π1\",{\"1\":{\"70\":1}}],[\"uniform\",{\"0\":{\"134\":1}}],[\"uniqueness\",{\"1\":{\"58\":1}}],[\"unmanned\",{\"1\":{\"4\":1}}],[\"update\",{\"1\":{\"23\":1,\"63\":3,\"70\":2}}],[\"uavn\",{\"1\":{\"13\":1}}],[\"uavs\",{\"1\":{\"4\":1,\"5\":1}}],[\"uav\",{\"0\":{\"3\":1,\"247\":1},\"1\":{\"4\":1},\"2\":{\"16\":1}}],[\"o\",{\"1\":{\"212\":15}}],[\"o+\",{\"1\":{\"212\":2}}],[\"oooo\",{\"1\":{\"212\":1}}],[\"override\",{\"1\":{\"182\":3,\"184\":1,\"185\":1,\"186\":2,\"222\":2,\"223\":1,\"233\":1}}],[\"outofmemoryerror\",{\"1\":{\"231\":1}}],[\"out\",{\"1\":{\"161\":1,\"162\":1,\"166\":3,\"170\":2,\"174\":1,\"182\":2,\"184\":1,\"185\":2,\"186\":4,\"187\":1,\"193\":3,\"194\":1,\"195\":2,\"202\":1,\"203\":2,\"206\":1,\"207\":1,\"208\":1,\"210\":6,\"211\":3,\"212\":2,\"218\":5,\"219\":1,\"220\":1,\"221\":7,\"222\":3,\"223\":1,\"224\":3,\"225\":2,\"234\":3,\"241\":2,\"242\":1}}],[\"obj\",{\"1\":{\"181\":2,\"182\":4,\"201\":1}}],[\"object类中的\",{\"0\":{\"186\":1}}],[\"object\",{\"0\":{\"181\":1},\"1\":{\"181\":4,\"182\":3,\"185\":2,\"186\":1,\"201\":1,\"202\":1,\"204\":5,\"231\":1,\"233\":2,\"234\":3}}],[\"objective\",{\"1\":{\"134\":2,\"135\":1,\"141\":1,\"142\":1,\"148\":1}}],[\"obejctive\",{\"0\":{\"133\":1},\"1\":{\"136\":1}}],[\"obtained\",{\"1\":{\"41\":1}}],[\"other\",{\"1\":{\"53\":1}}],[\"optimization\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"optimality\",{\"0\":{\"54\":1},\"1\":{\"52\":1,\"119\":1}}],[\"optimal\",{\"0\":{\"53\":1,\"119\":1},\"1\":{\"52\":2,\"53\":1,\"120\":1}}],[\"opinion\",{\"1\":{\"5\":1}}],[\"originalepisode\",{\"1\":{\"81\":1}}],[\"or\",{\"1\":{\"19\":1,\"40\":1,\"92\":1,\"112\":1,\"135\":1}}],[\"off\",{\"0\":{\"29\":1,\"31\":1,\"121\":1,\"123\":1,\"125\":1},\"1\":{\"123\":1,\"124\":1}}],[\"of\",{\"0\":{\"10\":1,\"43\":1,\"44\":1,\"111\":1,\"115\":1,\"119\":1,\"132\":1},\"1\":{\"4\":3,\"10\":1,\"19\":4,\"20\":3,\"40\":1,\"41\":1,\"45\":2,\"58\":1,\"75\":1,\"81\":1,\"82\":1,\"92\":1,\"99\":1,\"119\":1,\"135\":1,\"142\":1}}],[\"on\",{\"0\":{\"121\":1,\"122\":1,\"126\":1},\"1\":{\"3\":1,\"123\":1,\"124\":1,\"140\":1,\"144\":1},\"2\":{\"16\":1}}],[\"float\",{\"1\":{\"193\":2}}],[\"fill\",{\"1\":{\"242\":1}}],[\"filenotfoundexception\",{\"1\":{\"233\":2}}],[\"finally\",{\"1\":{\"234\":1}}],[\"final类型\",{\"1\":{\"202\":1}}],[\"final的status类型成员变量\",{\"1\":{\"187\":1}}],[\"final的\",{\"1\":{\"185\":1}}],[\"finalize\",{\"1\":{\"181\":1}}],[\"final\",{\"1\":{\"181\":6,\"183\":2,\"187\":5,\"205\":1,\"218\":2,\"219\":1,\"220\":1,\"223\":3}}],[\"finding\",{\"1\":{\"92\":1,\"104\":1,\"110\":1}}],[\"first\",{\"1\":{\"81\":1}}],[\"fix\",{\"1\":{\"58\":1}}],[\"false\",{\"1\":{\"182\":2,\"235\":1}}],[\"fast\",{\"1\":{\"58\":1}}],[\"fair\",{\"1\":{\"10\":1}}],[\"f\",{\"1\":{\"58\":4,\"101\":3,\"104\":1}}],[\"fundamental\",{\"1\":{\"52\":1}}],[\"function\",{\"0\":{\"130\":1,\"133\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"40\":1,\"58\":1,\"130\":1,\"134\":2,\"135\":1,\"136\":1,\"141\":1,\"142\":1,\"147\":1,\"148\":1,\"207\":1}}],[\"future\",{\"0\":{\"44\":1},\"1\":{\"45\":1}}],[\"free\",{\"0\":{\"75\":1},\"1\":{\"45\":1,\"76\":1,\"77\":1}}],[\"from\",{\"1\":{\"41\":1,\"48\":2,\"187\":1}}],[\"framework\",{\"1\":{\"4\":1}}],[\"found\",{\"1\":{\"245\":1}}],[\"fooooood\",{\"1\":{\"212\":1}}],[\"foooood\",{\"1\":{\"212\":1}}],[\"food\",{\"1\":{\"212\":1}}],[\"foem\",{\"1\":{\"55\":1}}],[\"following\",{\"1\":{\"19\":1}}],[\"foreach\",{\"1\":{\"203\":1}}],[\"forallw\",{\"1\":{\"98\":1}}],[\"foralls∈s\",{\"1\":{\"79\":1}}],[\"fortheother∣a\",{\"1\":{\"87\":1}}],[\"formulation\",{\"0\":{\"105\":1}}],[\"form\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"47\":1,\"49\":2,\"55\":1,\"58\":1,\"63\":1,\"66\":2}}],[\"for\",{\"1\":{\"4\":2,\"20\":1,\"53\":2,\"58\":1,\"203\":3,\"207\":1,\"208\":1,\"210\":1,\"241\":1}}],[\"fs\",{\"1\":{\"10\":1}}],[\"fs​+l\",{\"1\":{\"10\":1}}],[\"fc​是载波频率\",{\"1\":{\"9\":1}}],[\"not\",{\"1\":{\"245\":1}}],[\"notifyall\",{\"1\":{\"181\":1}}],[\"notify\",{\"1\":{\"181\":1}}],[\"novel\",{\"1\":{\"4\":1}}],[\"nanos\",{\"1\":{\"181\":1}}],[\"native\",{\"1\":{\"181\":7,\"231\":1}}],[\"name\",{\"1\":{\"161\":3,\"162\":2,\"164\":7,\"166\":14,\"170\":1,\"174\":1,\"182\":2,\"184\":6,\"185\":2,\"186\":2,\"187\":5,\"207\":1,\"218\":14,\"219\":4,\"220\":4,\"221\":2}}],[\"nullpointerexception\",{\"1\":{\"234\":3}}],[\"null\",{\"1\":{\"161\":1,\"182\":1,\"195\":1,\"234\":1}}],[\"numbers\",{\"1\":{\"75\":1}}],[\"number\",{\"1\":{\"10\":1}}],[\"n→∞lim​n1​e\",{\"1\":{\"154\":2}}],[\"nextint方法可以指定创建0\",{\"1\":{\"241\":1}}],[\"nextint\",{\"1\":{\"241\":1}}],[\"new\",{\"1\":{\"161\":3,\"162\":1,\"171\":1,\"173\":1,\"182\":4,\"185\":2,\"186\":1,\"187\":1,\"193\":4,\"194\":1,\"195\":1,\"201\":5,\"202\":1,\"203\":1,\"204\":4,\"207\":1,\"210\":4,\"211\":2,\"218\":7,\"219\":1,\"220\":1,\"222\":4,\"223\":1,\"225\":2,\"233\":6,\"234\":3,\"241\":1,\"242\":1}}],[\"newestimatevt+1​\",{\"1\":{\"112\":1}}],[\"network\",{\"1\":{\"142\":5,\"144\":1}}],[\"networks\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"142\":1}}],[\"n=0∑∞​βnrt+n​\",{\"1\":{\"13\":1}}],[\"n∈n=\",{\"1\":{\"13\":1}}],[\"n∈1\",{\"1\":{\"8\":1}}],[\"n0​为用户所在位置的加性高斯白噪声\",{\"1\":{\"9\":1}}],[\"n\",{\"0\":{\"117\":1},\"1\":{\"8\":2,\"11\":1,\"13\":2,\"70\":1,\"71\":1,\"142\":1,\"207\":1,\"212\":9}}],[\"t=0∑∞​γtrt+1​\",{\"1\":{\"151\":1}}],[\"t=0\",{\"1\":{\"112\":1,\"116\":1}}],[\"td\",{\"0\":{\"111\":1,\"114\":1,\"115\":1,\"119\":1,\"127\":1,\"138\":1},\"1\":{\"113\":1,\"138\":1,\"142\":1,\"156\":1}}],[\"t∈rn\",{\"1\":{\"46\":2}}],[\"t∈r2×1\",{\"1\":{\"8\":2}}],[\"taobao\",{\"1\":{\"212\":2}}],[\"tabular\",{\"1\":{\"130\":1}}],[\"table过大\",{\"1\":{\"14\":1}}],[\"table来找出对应q\",{\"1\":{\"13\":1}}],[\"table\",{\"1\":{\"13\":2}}],[\"table管理\",{\"1\":{\"13\":1}}],[\"target\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":2,\"142\":4}}],[\"take\",{\"1\":{\"86\":1}}],[\"taking\",{\"1\":{\"48\":1}}],[\"tasks转换成continuing\",{\"1\":{\"19\":1}}],[\"tasks\",{\"1\":{\"19\":3}}],[\"ten\",{\"1\":{\"195\":1}}],[\"teacher\",{\"1\":{\"185\":7}}],[\"testexception\",{\"1\":{\"232\":4}}],[\"test这个包中\",{\"1\":{\"173\":1}}],[\"test\",{\"1\":{\"170\":1,\"173\":7,\"174\":4,\"185\":2,\"187\":7,\"204\":1,\"207\":3,\"208\":1,\"218\":25,\"219\":6,\"220\":4,\"221\":11,\"222\":7,\"223\":1,\"224\":2,\"233\":3,\"234\":4}}],[\"terms\",{\"1\":{\"119\":1}}],[\"terminal\",{\"1\":{\"19\":1}}],[\"temporal\",{\"0\":{\"109\":1}}],[\"technology\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"timeout\",{\"1\":{\"181\":2}}],[\"time\",{\"1\":{\"10\":1,\"81\":1}}],[\"try\",{\"1\":{\"234\":9}}],[\"truncated\",{\"0\":{\"69\":1,\"71\":1,\"72\":1},\"1\":{\"71\":1}}],[\"trial\",{\"1\":{\"19\":2}}],[\"trip\",{\"1\":{\"10\":1}}],[\"trajectory以及对应的\",{\"1\":{\"154\":1}}],[\"trajectory是在策略给定下\",{\"1\":{\"19\":1}}],[\"trajectory\",{\"1\":{\"19\":4,\"41\":1,\"42\":1,\"154\":1}}],[\"transition\",{\"1\":{\"19\":2,\"20\":1}}],[\"transmission\",{\"1\":{\"8\":1}}],[\"transactions\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"t\",{\"1\":{\"8\":11,\"9\":20,\"10\":12,\"11\":8,\"13\":6}}],[\"tochararray\",{\"1\":{\"210\":1}}],[\"tohexstring\",{\"1\":{\"181\":1,\"194\":1}}],[\"tostring\",{\"1\":{\"181\":2,\"211\":2,\"218\":4,\"234\":1,\"242\":3}}],[\"tool\",{\"1\":{\"52\":1}}],[\"to\",{\"0\":{\"47\":1},\"1\":{\"4\":1,\"19\":1,\"20\":1,\"82\":1,\"86\":1,\"92\":1,\"98\":1}}],[\"throw\",{\"1\":{\"233\":6,\"234\":3}}],[\"throwable\",{\"1\":{\"181\":1}}],[\"throws\",{\"1\":{\"181\":5,\"186\":2,\"231\":1,\"233\":3,\"234\":4}}],[\"throughput\",{\"1\":{\"4\":1}}],[\"this\",{\"0\":{\"164\":1},\"1\":{\"154\":1,\"164\":1,\"166\":12,\"180\":1,\"181\":1,\"182\":3,\"184\":4,\"187\":2,\"218\":6,\"219\":1,\"220\":1}}],[\"that\",{\"1\":{\"41\":1,\"58\":1,\"81\":1}}],[\"then\",{\"1\":{\"58\":2}}],[\"theorem来求解贝尔曼最优公式\",{\"1\":{\"58\":1}}],[\"theorem\",{\"1\":{\"53\":2,\"58\":1,\"62\":1,\"98\":1}}],[\"the\",{\"0\":{\"24\":1,\"43\":1,\"44\":1},\"1\":{\"4\":1,\"9\":1,\"10\":1,\"19\":6,\"20\":4,\"37\":1,\"40\":1,\"41\":2,\"47\":1,\"48\":4,\"49\":2,\"52\":1,\"53\":2,\"58\":2,\"81\":1,\"82\":2,\"86\":1,\"98\":2,\"135\":1,\"142\":2}}],[\"ioexception\",{\"1\":{\"234\":6}}],[\"i都会更新成数组中下一个元素\",{\"1\":{\"203\":1}}],[\"i+\",{\"1\":{\"203\":1}}],[\"i++\",{\"1\":{\"203\":1,\"241\":1}}],[\"i就是每一个数组中的元素\",{\"1\":{\"203\":1}}],[\"identically\",{\"1\":{\"75\":1}}],[\"idle\",{\"1\":{\"10\":1}}],[\"iid\",{\"1\":{\"75\":1}}],[\"i\",{\"1\":{\"75\":2,\"78\":1,\"193\":9,\"194\":4,\"195\":6,\"203\":4,\"241\":2}}],[\"i−γpπk​​\",{\"1\":{\"68\":1}}],[\"i−γpπ​\",{\"1\":{\"47\":2}}],[\"if\",{\"1\":{\"53\":1,\"58\":1,\"86\":1,\"98\":1,\"182\":2,\"185\":1,\"193\":1,\"233\":2}}],[\"ij​=pπ​\",{\"1\":{\"46\":1}}],[\"implements\",{\"1\":{\"185\":2,\"186\":1}}],[\"import\",{\"1\":{\"173\":3,\"174\":1,\"195\":2,\"221\":1,\"241\":1}}],[\"importance\",{\"0\":{\"30\":1}}],[\"improvement\",{\"1\":{\"66\":1,\"70\":1,\"79\":1,\"82\":1,\"88\":1,\"111\":1,\"115\":1,\"120\":1}}],[\"immediate\",{\"0\":{\"43\":1},\"1\":{\"45\":1}}],[\"i=1n​\",{\"1\":{\"19\":2}}],[\"iteration\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"70\":2,\"71\":1,\"72\":1},\"1\":{\"62\":1,\"68\":2,\"69\":2,\"70\":10,\"71\":3,\"76\":1,\"77\":1,\"79\":1,\"82\":1}}],[\"iterative\",{\"1\":{\"47\":1,\"92\":1}}],[\"it\",{\"1\":{\"4\":1,\"81\":1}}],[\"is\",{\"1\":{\"4\":3,\"19\":1,\"20\":2,\"41\":1,\"53\":1,\"58\":2,\"81\":1,\"86\":2,\"154\":1}}],[\"ieee\",{\"1\":{\"3\":1},\"2\":{\"16\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"234\":2}}],[\"independent\",{\"1\":{\"75\":1}}],[\"inner2\",{\"1\":{\"218\":2}}],[\"inner1\",{\"1\":{\"218\":2}}],[\"inner\",{\"1\":{\"218\":12,\"219\":5,\"220\":5,\"221\":3}}],[\"info\",{\"1\":{\"170\":3}}],[\"interface\",{\"1\":{\"185\":3,\"186\":1,\"222\":1,\"225\":2}}],[\"interruptedexception\",{\"1\":{\"181\":3}}],[\"interacting\",{\"1\":{\"19\":1}}],[\"integercache会默认缓存\",{\"1\":{\"193\":1}}],[\"integercache\",{\"1\":{\"193\":4}}],[\"integer\",{\"1\":{\"181\":1,\"193\":13,\"194\":7,\"204\":1,\"225\":2}}],[\"int\",{\"1\":{\"161\":2,\"162\":1,\"165\":3,\"166\":7,\"170\":1,\"174\":1,\"181\":2,\"184\":3,\"185\":1,\"186\":1,\"193\":3,\"201\":2,\"202\":2,\"203\":5,\"204\":4,\"205\":1,\"206\":1,\"207\":3,\"223\":1,\"225\":3,\"233\":4,\"234\":4,\"235\":1,\"241\":1,\"242\":2}}],[\"instanceof\",{\"1\":{\"182\":1,\"185\":1}}],[\"instance\",{\"1\":{\"161\":1}}],[\"invoked\",{\"1\":{\"4\":1}}],[\"in\",{\"0\":{\"3\":1},\"1\":{\"4\":1,\"81\":1,\"98\":1,\"119\":1}}],[\"min\",{\"1\":{\"241\":1}}],[\"mini\",{\"1\":{\"142\":2}}],[\"minisize\",{\"1\":{\"136\":1}}],[\"minimize\",{\"1\":{\"104\":1}}],[\"multiply\",{\"1\":{\"195\":1}}],[\"multiple\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"mbgd\",{\"0\":{\"106\":1}}],[\"message\",{\"1\":{\"232\":4}}],[\"metrics\",{\"1\":{\"148\":2}}],[\"method\",{\"1\":{\"81\":2,\"101\":3,\"156\":1}}],[\"methods\",{\"1\":{\"81\":1}}],[\"means\",{\"1\":{\"92\":1}}],[\"means来划分各个无人机所管理的用户簇\",{\"1\":{\"13\":1}}],[\"means的优化目标是最小化无人机与对应集群用户的欧氏距离\",{\"1\":{\"13\":1}}],[\"means可以视为获得无人机部署的低复杂度方案\",{\"1\":{\"13\":1}}],[\"means算法\",{\"1\":{\"13\":1}}],[\"means和igk算法比具有较低的复杂度\",{\"1\":{\"5\":1}}],[\"mean算法获得初始单元划分\",{\"1\":{\"5\":1}}],[\"mean\",{\"0\":{\"43\":1,\"44\":1,\"99\":1,\"103\":1},\"1\":{\"5\":1,\"40\":1,\"41\":1,\"75\":1,\"77\":1,\"82\":1,\"92\":1}}],[\"mc\",{\"0\":{\"76\":1,\"80\":1,\"83\":1,\"85\":1,\"88\":1,\"114\":1},\"1\":{\"76\":1,\"80\":2,\"81\":1,\"82\":1,\"88\":2,\"101\":1,\"123\":1}}],[\"mdp就变为mp\",{\"1\":{\"20\":1}}],[\"mdp\",{\"0\":{\"20\":1}}],[\"matches\",{\"1\":{\"212\":2}}],[\"matches方法用于对给定正则表达式进行匹配\",{\"1\":{\"212\":1}}],[\"match\",{\"1\":{\"212\":1}}],[\"math也是java\",{\"1\":{\"241\":1}}],[\"math类\",{\"1\":{\"241\":1}}],[\"math\",{\"1\":{\"195\":3,\"241\":5}}],[\"matrix\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"49\":1,\"55\":1}}],[\"male\",{\"1\":{\"185\":1}}],[\"main\",{\"1\":{\"142\":4,\"144\":1,\"161\":3,\"162\":1,\"170\":1,\"173\":4,\"174\":2,\"185\":3,\"186\":1,\"187\":1,\"193\":4,\"194\":1,\"195\":2,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":1,\"207\":1,\"208\":2,\"210\":3,\"211\":3,\"212\":2,\"218\":2,\"219\":1,\"221\":2,\"222\":5,\"223\":1,\"224\":3,\"225\":9,\"234\":5,\"235\":1,\"241\":2,\"242\":1}}],[\"max\",{\"1\":{\"195\":1,\"241\":1}}],[\"maxa∈a\",{\"1\":{\"142\":1}}],[\"max​q^​\",{\"1\":{\"140\":1,\"141\":1,\"142\":3}}],[\"mapping\",{\"1\":{\"53\":2,\"58\":5,\"62\":1}}],[\"markov\",{\"0\":{\"20\":1},\"1\":{\"20\":2,\"135\":1}}],[\"markovian\",{\"1\":{\"14\":1}}],[\"may\",{\"1\":{\"19\":1}}],[\"mssrkn​​rtt​+1\",{\"1\":{\"10\":1}}],[\"mss\",{\"1\":{\"10\":1}}],[\"m\",{\"1\":{\"9\":1,\"212\":3}}],[\"monro\",{\"1\":{\"98\":2}}],[\"monto\",{\"0\":{\"95\":1}}],[\"monte\",{\"0\":{\"75\":1,\"137\":1},\"1\":{\"75\":1,\"156\":1}}],[\"moreover\",{\"1\":{\"58\":1}}],[\"mobility\",{\"1\":{\"14\":1}}],[\"modles可选择\",{\"1\":{\"14\":1}}],[\"model|environment\",{\"1\":{\"45\":1}}],[\"model\",{\"0\":{\"10\":1,\"75\":1},\"1\":{\"14\":3,\"45\":2,\"76\":1,\"77\":2}}],[\"mos主要是有关传输速率rkn​​的函数\",{\"1\":{\"13\":1}}],[\"mosrkn​​​=t=0∑ts​​moskn​​\",{\"1\":{\"10\":1}}],[\"moskn​​\",{\"1\":{\"10\":3}}],[\"mos\",{\"1\":{\"5\":1}}],[\"movement\",{\"0\":{\"3\":1},\"1\":{\"4\":2}}],[\"aeiou\",{\"1\":{\"212\":1}}],[\"aerial\",{\"1\":{\"4\":1}}],[\"abs方法可以求绝对值\",{\"1\":{\"241\":1}}],[\"abs\",{\"1\":{\"241\":1}}],[\"abstract\",{\"1\":{\"184\":2,\"185\":1,\"222\":2}}],[\"abc\",{\"1\":{\"212\":2}}],[\"abcabccaa\",{\"1\":{\"212\":1}}],[\"aaa\",{\"1\":{\"211\":1}}],[\"aaaa\",{\"1\":{\"208\":1}}],[\"arithmeticexception\",{\"1\":{\"233\":1}}],[\"arg\",{\"1\":{\"208\":2}}],[\"args\",{\"1\":{\"161\":3,\"162\":1,\"170\":1,\"173\":2,\"174\":1,\"185\":2,\"186\":1,\"187\":1,\"193\":4,\"194\":1,\"195\":2,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":1,\"207\":1,\"208\":3,\"210\":3,\"211\":3,\"212\":2,\"218\":2,\"219\":1,\"221\":1,\"222\":3,\"223\":1,\"224\":3,\"225\":5,\"234\":4,\"235\":1,\"241\":2,\"242\":1}}],[\"arrav\",{\"1\":{\"204\":1}}],[\"arrays\",{\"1\":{\"242\":5}}],[\"arrays类\",{\"1\":{\"242\":2}}],[\"array就是我们要遍历的数组\",{\"1\":{\"203\":1}}],[\"array\",{\"1\":{\"201\":2,\"202\":2,\"203\":4,\"204\":2}}],[\"arr\",{\"1\":{\"204\":8,\"206\":2,\"234\":2,\"242\":2}}],[\"age已经初始化完\",{\"1\":{\"166\":1}}],[\"age\",{\"1\":{\"161\":1,\"162\":2,\"166\":18,\"170\":1,\"174\":1,\"182\":2,\"184\":6,\"185\":2,\"186\":2,\"207\":1}}],[\"agent从一个状态出发\",{\"1\":{\"48\":1}}],[\"agent从一个状态出发可以得到的平均return\",{\"1\":{\"48\":1}}],[\"agent可能走出的全部轨迹\",{\"1\":{\"19\":1}}],[\"agent将获得负奖励\",{\"1\":{\"13\":1}}],[\"agent\",{\"1\":{\"13\":1,\"19\":2,\"48\":2,\"154\":1}}],[\"a∈a∑​π\",{\"1\":{\"155\":1}}],[\"a∈a∑​▽θ​π\",{\"1\":{\"155\":2}}],[\"ak​=k1​是满足上面三个条件的\",{\"1\":{\"98\":1}}],[\"ak​→0不要过快\",{\"1\":{\"98\":1}}],[\"ak​→0\",{\"1\":{\"98\":1}}],[\"ak​\",{\"1\":{\"97\":1}}],[\"ak∗​∣s\",{\"1\":{\"79\":1}}],[\"ak∗​\",{\"1\":{\"66\":1}}],[\"a3​\",{\"1\":{\"81\":2}}],[\"a4​\",{\"1\":{\"81\":2}}],[\"a2​\",{\"1\":{\"81\":4}}],[\"a2c\",{\"0\":{\"25\":1}}],[\"apple\",{\"1\":{\"222\":3}}],[\"append\",{\"1\":{\"211\":7}}],[\"appears\",{\"1\":{\"81\":1}}],[\"approximation\",{\"0\":{\"130\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1},\"1\":{\"92\":1,\"147\":1}}],[\"approximate\",{\"1\":{\"82\":1}}],[\"approach\",{\"1\":{\"14\":2}}],[\"a=ak∗​\",{\"1\":{\"63\":1,\"66\":1}}],[\"as\",{\"1\":{\"58\":1,\"104\":1}}],[\"assertionerror\",{\"1\":{\"235\":1}}],[\"assert\",{\"1\":{\"235\":2}}],[\"assert断言表达式\",{\"1\":{\"235\":1}}],[\"associate\",{\"1\":{\"20\":1}}],[\"assisted\",{\"1\":{\"4\":1}}],[\"along\",{\"1\":{\"154\":1}}],[\"alogorithm\",{\"0\":{\"132\":1}}],[\"algorithms\",{\"0\":{\"136\":1},\"1\":{\"92\":1}}],[\"algorithm\",{\"0\":{\"62\":1,\"65\":1,\"69\":1,\"71\":1,\"72\":1,\"95\":1},\"1\":{\"58\":1,\"68\":2,\"70\":2,\"71\":1,\"76\":1,\"79\":1,\"98\":1}}],[\"all\",{\"1\":{\"41\":1,\"53\":1}}],[\"average\",{\"0\":{\"150\":1,\"153\":1},\"1\":{\"48\":2,\"154\":1}}],[\"a∑​π\",{\"1\":{\"45\":1,\"155\":1}}],[\"a∑​p\",{\"1\":{\"44\":1}}],[\"a∼π​\",{\"1\":{\"26\":3,\"155\":1}}],[\"advantage\",{\"0\":{\"25\":1}}],[\"a∣s\",{\"1\":{\"20\":1,\"26\":3,\"41\":1,\"43\":2,\"44\":5,\"45\":4,\"48\":3,\"49\":1,\"55\":2,\"57\":2,\"58\":1,\"63\":2,\"66\":3,\"79\":1,\"87\":1,\"113\":1,\"148\":1,\"153\":1,\"155\":14,\"156\":2}}],[\"any\",{\"1\":{\"53\":1,\"58\":1,\"86\":1}}],[\"an\",{\"1\":{\"19\":1,\"47\":1,\"48\":1}}],[\"and\",{\"0\":{\"3\":1},\"1\":{\"4\":2,\"14\":1,\"48\":1,\"49\":1,\"52\":1,\"53\":1,\"75\":1,\"142\":1}}],[\"at+1​\",{\"1\":{\"116\":2,\"139\":1,\"140\":1}}],[\"at\",{\"1\":{\"19\":1,\"20\":1}}],[\"at​∣st​\",{\"1\":{\"156\":1}}],[\"at​=a\",{\"1\":{\"43\":1,\"44\":2,\"48\":2,\"49\":1,\"75\":1,\"77\":1,\"78\":1,\"119\":1}}],[\"at​\",{\"1\":{\"13\":1,\"116\":8,\"120\":5,\"139\":2,\"140\":2,\"156\":1}}],[\"a1​\",{\"1\":{\"19\":2,\"20\":2,\"81\":1}}],[\"ai​\",{\"1\":{\"19\":1,\"142\":2}}],[\"actor\",{\"0\":{\"23\":1,\"24\":1,\"25\":1,\"29\":1,\"33\":1},\"1\":{\"23\":2}}],[\"actions\",{\"1\":{\"20\":1}}],[\"action\",{\"0\":{\"48\":1,\"115\":1,\"119\":1},\"1\":{\"13\":1,\"19\":3,\"20\":2,\"48\":8,\"49\":2,\"53\":2,\"57\":2,\"63\":1,\"66\":1,\"70\":2,\"75\":1,\"77\":5,\"79\":6,\"81\":9,\"82\":3,\"84\":4,\"86\":2,\"92\":1,\"115\":4,\"116\":1,\"119\":2,\"120\":1,\"131\":1}}],[\"academic\",{\"0\":{\"248\":1},\"2\":{\"15\":1,\"21\":1,\"34\":1,\"50\":1,\"59\":1,\"73\":1,\"90\":1,\"107\":1,\"128\":1,\"145\":1,\"158\":1}}],[\"awgn\",{\"1\":{\"9\":1}}],[\"a\",{\"1\":{\"4\":1,\"13\":3,\"14\":2,\"19\":7,\"20\":5,\"26\":2,\"41\":3,\"43\":1,\"44\":3,\"45\":6,\"48\":13,\"49\":2,\"52\":1,\"53\":1,\"55\":3,\"57\":1,\"58\":2,\"63\":6,\"66\":6,\"70\":1,\"75\":3,\"77\":11,\"78\":8,\"79\":3,\"81\":2,\"82\":2,\"84\":6,\"86\":1,\"92\":1,\"113\":1,\"115\":4,\"116\":3,\"119\":3,\"120\":4,\"135\":1,\"141\":3,\"142\":22,\"153\":5,\"155\":9,\"156\":4,\"161\":1,\"165\":4,\"185\":1,\"193\":7,\"195\":1,\"205\":3,\"207\":1,\"212\":6,\"218\":2,\"223\":3,\"224\":5,\"225\":5,\"233\":4,\"234\":2,\"235\":2}}],[\"a+b=c\",{\"1\":{\"0\":1}}],[\"doxy\",{\"1\":{\"212\":1}}],[\"does\",{\"1\":{\"212\":1}}],[\"do\",{\"1\":{\"212\":3}}],[\"double\",{\"1\":{\"165\":3,\"193\":2}}],[\"down\",{\"1\":{\"8\":1}}],[\"d0​\",{\"1\":{\"152\":1}}],[\"dqn\",{\"0\":{\"141\":1},\"1\":{\"142\":1,\"144\":1}}],[\"dπ​\",{\"1\":{\"135\":2,\"152\":1}}],[\"divide\",{\"1\":{\"195\":1}}],[\"difference\",{\"0\":{\"109\":1}}],[\"distributon\",{\"0\":{\"134\":1},\"1\":{\"135\":3}}],[\"distributed\",{\"1\":{\"75\":1}}],[\"distribution\",{\"0\":{\"135\":1},\"1\":{\"20\":1,\"133\":1,\"135\":1,\"152\":1}}],[\"discounted\",{\"1\":{\"19\":1,\"42\":1,\"113\":1,\"137\":1}}],[\"data\",{\"1\":{\"81\":1}}],[\"daily\",{\"0\":{\"246\":1},\"2\":{\"1\":1}}],[\"daily1\",{\"0\":{\"0\":1}}],[\"dpg\",{\"0\":{\"33\":1}}],[\"d\",{\"0\":{\"152\":1},\"1\":{\"10\":3,\"75\":1,\"150\":2,\"152\":5,\"182\":1,\"184\":1}}],[\"dkn​​\",{\"1\":{\"9\":1}}],[\"dkn​​=hn2​\",{\"1\":{\"8\":1}}],[\"dkn​\",{\"1\":{\"9\":1}}],[\"dynamic\",{\"1\":{\"4\":1,\"45\":1}}],[\"driven\",{\"1\":{\"4\":1}}],[\"delete\",{\"1\":{\"211\":1}}],[\"decode\",{\"1\":{\"194\":1}}],[\"decision\",{\"0\":{\"20\":1}}],[\"default\",{\"1\":{\"185\":2}}],[\"deeptostring\",{\"1\":{\"242\":1}}],[\"deep\",{\"0\":{\"141\":1},\"1\":{\"141\":1}}],[\"describes\",{\"1\":{\"135\":1}}],[\"descent\",{\"0\":{\"100\":1},\"1\":{\"101\":2}}],[\"design\",{\"0\":{\"3\":1}}],[\"deterministic\",{\"0\":{\"33\":1,\"105\":1},\"1\":{\"14\":1,\"19\":1,\"53\":2}}],[\"demonstrating\",{\"1\":{\"4\":1}}],[\"deployment\",{\"0\":{\"3\":1},\"1\":{\"4\":1}}],[\"d1\",{\"2\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(et(t,v[s],n)):e==="search"?self.postMessage(tt(t,v[s],n)):self.postMessage({suggestions:et(t,v[s],n),results:tt(t,v[s],n)})};
//# sourceMappingURL=index.js.map
