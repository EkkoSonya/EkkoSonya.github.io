"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[1195],{83671:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}},29360:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>g,data:()=>y});var t=a(7847);const e=a.p+"assets/img/34.22bf4095.png",p=a.p+"assets/img/35.6a38ce67.png",o=a.p+"assets/img/36.6b37213c.png",c=(0,t.Lk)("h2",{id:"营业状态设置1",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#营业状态设置1"},[(0,t.Lk)("span",null,"营业状态设置1")])],-1),l=(0,t.Lk)("h3",{id:"redis介绍",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#redis介绍"},[(0,t.Lk)("span",null,"Redis介绍")])],-1),i=(0,t.Lk)("p",null,[(0,t.eW)("Redis是一个基于"),(0,t.Lk)("strong",null,"内存"),(0,t.eW)("的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的"),(0,t.Lk)("strong",null,"存储中间件"),(0,t.eW)("。")],-1),u=(0,t.Lk)("strong",null,"官网",-1),k={href:"https://redis.io",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Lk)("strong",null,"中文网",-1),d={href:"https://www.redis.net.cn/",target:"_blank",rel:"noopener noreferrer"},m=(0,t.Fv)('<p><strong>key-value结构存储：</strong></p><p><strong>主要特点：</strong></p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）</li><li>企业应用广泛</li></ul><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><p><strong>关系型数据库(RDBMS)：</strong></p><ul><li>Mysql</li><li>Oracle</li><li>DB2</li><li>SQLServer</li></ul><p><strong>非关系型数据库(NoSql)：</strong></p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h4 id="基本命令" tabindex="-1"><a class="header-anchor" href="#基本命令"><span>基本命令</span></a></h4><p>启动：<code>redis-server.exe redis.conf</code></p><p>启动时默认创建了 16 个数据库</p><p>连接: <code>redis-cli.exe</code></p><p>通过redis-cli.exe命令默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：</p><ul><li>-h ip地址</li><li>-p 端口号</li><li>-a 密码（如果需要）</li></ul><h3 id="redis数据类型" tabindex="-1"><a class="header-anchor" href="#redis数据类型"><span>Redis数据类型</span></a></h3><h4 id="_5种常用数据类型" tabindex="-1"><a class="header-anchor" href="#_5种常用数据类型"><span>5种常用数据类型</span></a></h4><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set / zset</li></ul><h4 id="各自特点" tabindex="-1"><a class="header-anchor" href="#各自特点"><span>各自特点</span></a></h4><figure><img src="'+e+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构 (适合存对象)</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList (可以左右插入，适合存储跟顺序有关系的数据)</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(sorted set/zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素 (适合各种排行榜数据)</li></ul><h3 id="redis常用命令" tabindex="-1"><a class="header-anchor" href="#redis常用命令"><span>Redis常用命令</span></a></h3><p>在Mysql中是通过Sql语句来操作的，与数据类型无关，但在Redis中是不一样的，是根据数据类型不同，命令也不同</p><h4 id="字符串操作命令" tabindex="-1"><a class="header-anchor" href="#字符串操作命令"><span>字符串操作命令</span></a></h4><p>Redis 中字符串类型常用命令：</p><ul><li><code>SET key value</code>: 设置指定key的值</li><li><code>GET key</code>: 获取指定key的值</li><li><code>SETEX key seconds value</code>: 设置指定key的值，并将 key 的过期时间设为 seconds 秒 (短信验证码)</li><li><code>SETNX key value</code>: 只有在 key 不存在时设置 key 的值 (分布式锁)</li></ul>',27),v={href:"https://www.redis.net.cn",target:"_blank",rel:"noopener noreferrer"},b=(0,t.Fv)('<h4 id="哈希操作命令-h" tabindex="-1"><a class="header-anchor" href="#哈希操作命令-h"><span>哈希操作命令 <code>H</code></span></a></h4><p>Redis hash 是一个<code>string</code>类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><code>HSET key field value</code>: 将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>: 获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>: 删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>: 获取哈希表中所有字段</li><li><code>HVALS key</code>: 获取哈希表中所有值</li></ul><p>比如，存一个人的示例对象，key为对应id, 然后 field 和 value 为对应属性和值</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="列表操作命令-l-r-br" tabindex="-1"><a class="header-anchor" href="#列表操作命令-l-r-br"><span>列表操作命令 <code>L|R|BR</code></span></a></h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><code>LPUSH key value1 [value2]</code>: 将一个或多个值插入到列表头部 (这样插入顺序是 value2 value1 相反的)</li><li><code>RPUSH key value1 [value2]</code>: 在列表中添加一个或多个值到列表尾部</li><li><code>LRANGE key start stop</code>: 获取列表指定范围内的元素 (全部返回 <code>lrange list 0 -1</code>)</li><li><code>RPOP key</code>: 移除并获取列表最后一个元素</li><li><code>LLEN key</code>: 获取列表长度</li><li><code>BRPOP key1 [key2 ] timeout</code>: 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</li></ul><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="集合操作命令-s" tabindex="-1"><a class="header-anchor" href="#集合操作命令-s"><span>集合操作命令 <code>S</code></span></a></h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><code>SADD key member1 [member2]</code>: 向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>: 返回集合中的所有成员</li><li><code>SCARD key</code>: 获取集合的成员数</li><li><code>SINTER key1 [key2]</code>: 返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>: 返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>: 移除集合中一个或多个成员</li></ul><h4 id="有序集合操作命令-z" tabindex="-1"><a class="header-anchor" href="#有序集合操作命令-z"><span>有序集合操作命令 <code>Z</code></span></a></h4><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会<strong>关联一个double类型的分数</strong>。常用命令：</p><p>常用命令：</p><ul><li><code>ZADD key score1 member1 [score2 member2]</code>: 向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>: 通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>: 有序集合中对指定成员的分数加上增量 increment</li><li><code>ZREM key member [member ...]</code>: 移除有序集合中的一个或多个成员</li></ul><h4 id="通用命令" tabindex="-1"><a class="header-anchor" href="#通用命令"><span>通用命令</span></a></h4><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li><code>KEYS pattern</code>: 查找所有符合给定模式(pattern)的 key</li><li><code>EXISTS key</code>: 检查给定 key 是否存在</li><li><code>TYPE key</code> : 返回 key 所储存的值的类型</li><li><code>DEL key</code>:该命令用于在 key 存在是删除 key</li></ul>',19),h={},g=(0,a(83671).A)(h,[["render",function(n,s){const a=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[c,l,i,(0,t.Lk)("p",null,[u,(0,t.eW)(": "),(0,t.Lk)("a",k,[(0,t.eW)("https://redis.io"),(0,t.bF)(a)]),r,(0,t.eW)(": "),(0,t.Lk)("a",d,[(0,t.eW)("https://www.redis.net.cn/"),(0,t.bF)(a)])]),m,(0,t.Lk)("p",null,[(0,t.eW)("更多命令可以参考Redis中文网："),(0,t.Lk)("a",v,[(0,t.eW)("https://www.redis.net.cn"),(0,t.bF)(a)])]),b])}]]),y=JSON.parse('{"path":"/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article7.html","title":"Javassm - item1-7 (营业状态设置1)","lang":"zh-CN","frontmatter":{"title":"Javassm - item1-7 (营业状态设置1)","date":"2025-11-12T00:00:00.000Z","category":["code"],"tag":["java_item"],"order":-0.6,"description":"营业状态设置1 Redis介绍 Redis是一个基于内存的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件。 官网: https://redis.io 中文网: https://www.redis.net.cn/ key-value结构存储： 主要特点： 基于内存存储，读写性能高 适合存储热点数据（热点商品、资讯、新闻...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/1-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/article7.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"Javassm - item1-7 (营业状态设置1)"}],["meta",{"property":"og:description","content":"营业状态设置1 Redis介绍 Redis是一个基于内存的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件。 官网: https://redis.io 中文网: https://www.redis.net.cn/ key-value结构存储： 主要特点： 基于内存存储，读写性能高 适合存储热点数据（热点商品、资讯、新闻..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-12T18:11:03.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:published_time","content":"2025-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-12T18:11:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Javassm - item1-7 (营业状态设置1)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-12T18:11:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"营业状态设置1","slug":"营业状态设置1","link":"#营业状态设置1","children":[{"level":3,"title":"Redis介绍","slug":"redis介绍","link":"#redis介绍","children":[{"level":4,"title":"基本命令","slug":"基本命令","link":"#基本命令","children":[]}]},{"level":3,"title":"Redis数据类型","slug":"redis数据类型","link":"#redis数据类型","children":[{"level":4,"title":"5种常用数据类型","slug":"_5种常用数据类型","link":"#_5种常用数据类型","children":[]},{"level":4,"title":"各自特点","slug":"各自特点","link":"#各自特点","children":[]}]},{"level":3,"title":"Redis常用命令","slug":"redis常用命令","link":"#redis常用命令","children":[{"level":4,"title":"字符串操作命令","slug":"字符串操作命令","link":"#字符串操作命令","children":[]},{"level":4,"title":"哈希操作命令 H","slug":"哈希操作命令-h","link":"#哈希操作命令-h","children":[]},{"level":4,"title":"列表操作命令 L|R|BR","slug":"列表操作命令-l-r-br","link":"#列表操作命令-l-r-br","children":[]},{"level":4,"title":"集合操作命令 S","slug":"集合操作命令-s","link":"#集合操作命令-s","children":[]},{"level":4,"title":"有序集合操作命令 Z","slug":"有序集合操作命令-z","link":"#有序集合操作命令-z","children":[]},{"level":4,"title":"通用命令","slug":"通用命令","link":"#通用命令","children":[]}]}]}],"git":{"createdTime":1762971063000,"updatedTime":1762971063000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"code/java_item/1-苍穹外卖/article7.md","localizedDate":"2025年11月12日","excerpt":"<h2>营业状态设置1</h2>\\n<h3>Redis介绍</h3>\\n<p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的<strong>存储中间件</strong>。</p>\\n<p><strong>官网</strong>: <a href=\\"https://redis.io\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://redis.io</a>\\n<strong>中文网</strong>: <a href=\\"https://www.redis.net.cn/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.redis.net.cn/</a></p>","autoDesc":true}')},85470:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>g,data:()=>y});var t=a(7847);const e=a.p+"assets/img/36.7e4da618.png",p=a.p+"assets/img/37.365f6c23.png",o=a.p+"assets/img/38.9032f203.png",c=a.p+"assets/img/39.cbfb709e.png",l=a.p+"assets/img/40.aafbba3a.png",i=a.p+"assets/img/41.3fd4d113.png",u=a.p+"assets/img/42.45968471.png",k=a.p+"assets/img/43.dd4c2663.png",r=a.p+"assets/img/44.61180580.png",d=a.p+"assets/img/45.20b08ef1.png",m=(0,t.Fv)('<h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h2><p>之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁</p><h3 id="集群环境下的并发问题" tabindex="-1"><a class="header-anchor" href="#集群环境下的并发问题"><span>集群环境下的并发问题</span></a></h3><p>1、我们将服务启动两份，端口分别为8081和8082</p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</p><p>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因</p><figure><img src="'+e+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>在这种情况下，我们就需要使用分布式锁来解决这个问题</p><h3 id="基本原理和实现方式对比" tabindex="-1"><a class="header-anchor" href="#基本原理和实现方式对比"><span>基本原理和实现方式对比</span></a></h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="分布式锁条件" tabindex="-1"><a class="header-anchor" href="#分布式锁条件"><span>分布式锁条件</span></a></h4><ul><li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p>安全性：安全也是程序中必不可少的一环</p></li></ul><h4 id="常见分布式锁" tabindex="-1"><a class="header-anchor" href="#常见分布式锁"><span>常见分布式锁</span></a></h4><ul><li><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p></li><li><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p></li><li><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p></li></ul><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="redis分布式锁的实现思路" tabindex="-1"><a class="header-anchor" href="#redis分布式锁的实现思路"><span>Redis分布式锁的实现思路</span></a></h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁 <code>SETNX lock thread1</code></li><li>超时释放：获取锁时添加一个超时时间 <code>EXPIRE lock 10</code></li><li>确保原子性，用一个命令 <code>SET lock thread1 NX EX 10</code></li></ul></li><li><p>释放锁：</p><ul><li>手动释放 <code>DEL key</code></li></ul></li></ul><p>核心思路：</p><p>我们利用 redis 命令 <code>SET lock thread1 NX EX 10</code>，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key，返回1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑</p><p>没有抢到锁的，采用非阻塞的方法，直接表示获取锁失败，</p><figure><img src="'+c+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="redis分布式锁实现1" tabindex="-1"><a class="header-anchor" href="#redis分布式锁实现1"><span>Redis分布式锁实现1</span></a></h3><p>加锁逻辑 (非阻塞模式)</p><h4 id="锁实现" tabindex="-1"><a class="header-anchor" href="#锁实现"><span>锁实现</span></a></h4><h5 id="接口" tabindex="-1"><a class="header-anchor" href="#接口"><span>接口</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILock</span> <span class="token punctuation">{</span>\n    <span class="token doc-comment comment">/**\n     * 尝试获取锁\n     * <span class="token keyword">@param</span> <span class="token parameter">timeoutSec</span>\n     * <span class="token keyword">@return</span>\n     */</span>\n    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token doc-comment comment">/**\n     * 释放锁\n     */</span>\n    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="simpleredislock" tabindex="-1"><a class="header-anchor" href="#simpleredislock"><span><code>SimpleRedisLock</code></span></a></h5><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleRedisLock</span> <span class="token keyword">implements</span> <span class="token class-name">ILock</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">StringRedisTemplate</span> stringRedisTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>stringRedisTemplate <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;lock:&quot;</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取线程标示</span>\n        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 获取锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="修改业务代码" tabindex="-1"><a class="header-anchor" href="#修改业务代码"><span>修改业务代码</span></a></h5><p>根据用户ID来尝试去Redis中获取锁，如果成功，就执行创建订单逻辑，失败就返回 (不能重复下单)，然后再等事务对应的代码执行结束，数据库更新后再释放锁，从而避免并发时的重复下单</p><p>这样在同一时间内，同一个用户即使同时发很多请求，也只有一个请求可以获取并行锁进入尝试创建订单的逻辑，这样当用户之前没有订单时，也不会发生多线程进入查询得到0订单的情况</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">seckillVoucher</span><span class="token punctuation">(</span><span class="token class-name">Long</span> voucherId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 查询优惠券</span>\n    <span class="token class-name">SeckillVoucher</span> voucher <span class="token operator">=</span> seckillVoucherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 判断秒杀是否开始和结束</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;秒杀尚未开始&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;秒杀已经结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 判断库存是否充足</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>voucher<span class="token punctuation">.</span><span class="token function">getStock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;库存不足&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token class-name">Long</span> userId <span class="token operator">=</span> <span class="token class-name">UserHolder</span><span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 创建锁对象(新增代码)</span>\n    <span class="token class-name">SimpleRedisLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRedisLock</span><span class="token punctuation">(</span><span class="token string">&quot;order:&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">,</span> stringRedisTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁对象</span>\n    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 加锁失败</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;不允许重复下单&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取代理对象(事务)</span>\n        <span class="token class-name">IVoucherOrderService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IVoucherOrderService</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">createVoucherOrder</span><span class="token punctuation">(</span>voucherId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="redis分布式锁误删情况" tabindex="-1"><a class="header-anchor" href="#redis分布式锁误删情况"><span>Redis分布式锁误删情况</span></a></h3><h4 id="情况分析" tabindex="-1"><a class="header-anchor" href="#情况分析"><span>情况分析</span></a></h4><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁</p><p>然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><figure><img src="'+l+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>解决方案</strong></p><p>就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除</p><p>假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑</p><p>当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><figure><img src="'+i+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="解决误删情况" tabindex="-1"><a class="header-anchor" href="#解决误删情况"><span>解决误删情况</span></a></h4><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><p>因为此时后端服务分布式，可能有多个端口对应多个JVM，因此不<strong>同的线程生成的UUID是不同的</strong>，可以进行区分</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><figure><img src="'+u+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h5 id="加锁" tabindex="-1"><a class="header-anchor" href="#加锁"><span>加锁</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;lock:&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeoutSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取线程标示</span>\n    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁</span>\n    <span class="token class-name">Boolean</span> success <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> timeoutSec<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="释放锁" tabindex="-1"><a class="header-anchor" href="#释放锁"><span>释放锁</span></a></h5><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取线程标示</span>\n    <span class="token class-name">String</span> threadId <span class="token operator">=</span> <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取锁中的标示</span>\n    <span class="token class-name">String</span> id <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 判断标示是否一致</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>threadId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 释放锁</span>\n        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="分布式锁的原子性问题" tabindex="-1"><a class="header-anchor" href="#分布式锁的原子性问题"><span>分布式锁的原子性问题</span></a></h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，<strong>正准备删除锁</strong>，阻塞了一段时间 (JVM垃圾回收等)，导致<strong>此时他的锁到期</strong>了</p><p>那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的<strong>原子性</strong>问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生</p><figure><img src="'+k+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性</p>',65),v={href:"https://www.runoob.com/lua/lua-tutorial.html",target:"_blank",rel:"noopener noreferrer"},b=(0,t.Fv)('<p>这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现<code>拿锁比锁删锁</code>是一个原子性动作了</p><h5 id="lua中redis提供的调用函数" tabindex="-1"><a class="header-anchor" href="#lua中redis提供的调用函数"><span>lua中Redis提供的调用函数</span></a></h5><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;命令名称&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;其它参数&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如，我们要执行<code>set name jack</code>，则脚本是这样：</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token operator">#</span> 执行 set name jack\nredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;set&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;jack&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token operator">#</span> 先执行 set name jack\nredis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;set&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Rose&#39;</span><span class="token punctuation">)</span>\n<span class="token operator">#</span> 再执行 get name\n<span class="token keyword">local</span> name <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span>\n<span class="token operator">#</span> 返回\n<span class="token keyword">return</span> name\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="redis执行lua脚本-eval" tabindex="-1"><a class="header-anchor" href="#redis执行lua脚本-eval"><span>Redis执行lua脚本 <code>EVAL</code></span></a></h5><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下</p><div class="language-redis line-numbers-mode" data-ext="redis" data-title="redis"><pre class="language-redis"><code>EVAL &quot;return redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)&quot; 0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果脚本中的key、value不想写死，可以作为参数传递</p><p>key类型参数会放入<code>KEYS</code>数组，其它参数会放入<code>ARGV</code>数组(这里数组起始元素是从1开始的)</p><p>在脚本中可以从KEYS和ARGV数组获取这些参数：</p><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="java调用lua脚本解决原子性问题" tabindex="-1"><a class="header-anchor" href="#java调用lua脚本解决原子性问题"><span>java调用lua脚本解决原子性问题</span></a></h4><h5 id="释放锁的逻辑" tabindex="-1"><a class="header-anchor" href="#释放锁的逻辑"><span>释放锁的逻辑</span></a></h5><p>释放锁的业务流程是这样的</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span>\n<span class="token comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;GET&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>\n  <span class="token comment">-- 一致，则删除锁</span>\n  <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;DEL&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">end</span>\n<span class="token comment">-- 不一致，则直接返回</span>\n<span class="token keyword">return</span> <span class="token number">0</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="具体代码" tabindex="-1"><a class="header-anchor" href="#具体代码"><span>具体代码</span></a></h5><p>我们的<code>RedisTemplate</code>中，可以利用execute方法去执行lua脚本，参数对应关系就如下</p><figure><img src="'+d+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>Java代码</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">;</span>\n<span class="token keyword">static</span> <span class="token punctuation">{</span>\n    <span class="token constant">UNLOCK_SCRIPT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">&quot;unlock.lua&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用lua脚本</span>\n    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>\n            <span class="token constant">UNLOCK_SCRIPT</span><span class="token punctuation">,</span>\n            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token constant">KEY_PREFIX</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span>\n            <span class="token constant">ID_PREFIX</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>在之前的逻辑上，已经实现了单个JVM时的 一人一单 和 阻止超卖的情况，主要逻辑也封装在了 <code>createVoucherOrder</code> 函数中</p><p>但是当开了多个服务，存在多个 JVM 时，此时处理 一人一单 的逻辑就不行了, 因为本质是通过不同的 <code>userId.toString().intern()</code> 在通过 <code>synchronized</code> 来创建悲观锁使得同一时刻一个用户只能有一个请求可以创建订单，这样就解决了一人一单</p><p>但是 多个JVM时，这种锁就没用了，因为不同的JVM对象是不同的。</p><p>所以需要考虑别的方法，采用分布式锁来解决，即多个JVM去Redis获取锁，这样就不会有问题了，但是会出现<strong>误删</strong>和<strong>原子性</strong>的情况，所以又要解决</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁 <ul><li>特性： <ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission</p><p>死锁 —— 添加过期时间</p><p>误删 —— 删之前判断一下当前这把锁是否是属于自己的</p><p>原子性问题 —— lua表达式来解决</p><p>锁不住 (过期时间到了之后续期) —— <code>redission</code></p>',39),h={},g=(0,a(83671).A)(h,[["render",function(n,s){const a=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[m,(0,t.Lk)("p",null,[(0,t.eW)("Lua是一种编程语言，它的基本语法可以参考网站："),(0,t.Lk)("a",v,[(0,t.eW)("https://www.runoob.com/lua/lua-tutorial.html"),(0,t.bF)(a)])]),b])}]]),y=JSON.parse('{"path":"/code/java_item/2-hmdp/article7.html","title":"item2-7 (优惠券秒杀2 - 分布式锁)","lang":"zh-CN","frontmatter":{"title":"item2-7 (优惠券秒杀2 - 分布式锁)","category":["code"],"tag":["java_item"],"order":-0.6,"description":"分布式锁 之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁 集群环境下的并发问题 1、我们将服务启动两份，端口分别为8081和8082 2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/java_item/2-hmdp/article7.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"item2-7 (优惠券秒杀2 - 分布式锁)"}],["meta",{"property":"og:description","content":"分布式锁 之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁 集群环境下的并发问题 1、我们将服务启动两份，端口分别为8081和8082 2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-09T16:42:22.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java_item"}],["meta",{"property":"article:modified_time","content":"2025-12-09T16:42:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"item2-7 (优惠券秒杀2 - 分布式锁)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-09T16:42:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[{"level":3,"title":"集群环境下的并发问题","slug":"集群环境下的并发问题","link":"#集群环境下的并发问题","children":[]},{"level":3,"title":"基本原理和实现方式对比","slug":"基本原理和实现方式对比","link":"#基本原理和实现方式对比","children":[{"level":4,"title":"分布式锁条件","slug":"分布式锁条件","link":"#分布式锁条件","children":[]},{"level":4,"title":"常见分布式锁","slug":"常见分布式锁","link":"#常见分布式锁","children":[]}]},{"level":3,"title":"Redis分布式锁的实现思路","slug":"redis分布式锁的实现思路","link":"#redis分布式锁的实现思路","children":[]},{"level":3,"title":"Redis分布式锁实现1","slug":"redis分布式锁实现1","link":"#redis分布式锁实现1","children":[{"level":4,"title":"锁实现","slug":"锁实现","link":"#锁实现","children":[{"level":5,"title":"接口","slug":"接口","link":"#接口","children":[]},{"level":5,"title":"SimpleRedisLock","slug":"simpleredislock","link":"#simpleredislock","children":[]},{"level":5,"title":"修改业务代码","slug":"修改业务代码","link":"#修改业务代码","children":[]}]}]},{"level":3,"title":"Redis分布式锁误删情况","slug":"redis分布式锁误删情况","link":"#redis分布式锁误删情况","children":[{"level":4,"title":"情况分析","slug":"情况分析","link":"#情况分析","children":[]},{"level":4,"title":"解决误删情况","slug":"解决误删情况","link":"#解决误删情况","children":[{"level":5,"title":"加锁","slug":"加锁","link":"#加锁","children":[]},{"level":5,"title":"释放锁","slug":"释放锁","link":"#释放锁","children":[]}]}]},{"level":3,"title":"分布式锁的原子性问题","slug":"分布式锁的原子性问题","link":"#分布式锁的原子性问题","children":[{"level":4,"title":"Lua脚本","slug":"lua脚本","link":"#lua脚本","children":[{"level":5,"title":"lua中Redis提供的调用函数","slug":"lua中redis提供的调用函数","link":"#lua中redis提供的调用函数","children":[]},{"level":5,"title":"Redis执行lua脚本 EVAL","slug":"redis执行lua脚本-eval","link":"#redis执行lua脚本-eval","children":[]}]},{"level":4,"title":"java调用lua脚本解决原子性问题","slug":"java调用lua脚本解决原子性问题","link":"#java调用lua脚本解决原子性问题","children":[{"level":5,"title":"释放锁的逻辑","slug":"释放锁的逻辑","link":"#释放锁的逻辑","children":[]},{"level":5,"title":"具体代码","slug":"具体代码","link":"#具体代码","children":[]}]}]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1765127830000,"updatedTime":1765298542000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":2}]},"readingTime":{"minutes":12.35,"words":3704},"filePathRelative":"code/java_item/2-hmdp/article7.md","localizedDate":"2025年12月7日","excerpt":"<h2>分布式锁</h2>\\n<p>之前的加锁只能解决单机模式下的并发问题，不能解决集群模式下的并发，这种情况就需要分布式锁</p>\\n<h3>集群环境下的并发问题</h3>\\n<p>1、我们将服务启动两份，端口分别为8081和8082</p>\\n<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p>\\n<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</p>\\n<p>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因</p>","autoDesc":true}')},8103:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>i,data:()=>u});var t=a(7847);const e=a.p+"assets/img/19.dd23de99.png",p=a.p+"assets/img/20.63fb17f9.png",o=a.p+"assets/img/21.c04bad5d.png",c=[(0,t.Fv)('<h2 id="juc7" tabindex="-1"><a class="header-anchor" href="#juc7"><span>JUC7</span></a></h2><h3 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器"><span>并发容器</span></a></h3><p>重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的）</p><p>在单线程模式下，集合类提供的容器可以说是非常方便了，但在多线程环境下，这些数据结构还能正常工作吗</p><h4 id="传统容器线程安全问题" tabindex="-1"><a class="header-anchor" href="#传统容器线程安全问题"><span>传统容器线程安全问题</span></a></h4><p>测试一下，100个线程同时向ArrayList中添加元素：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不出意外的话，肯定是会报错的：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 49\n    at java.util.ArrayList.add(ArrayList.java:465)\n    at com.ekko.Main.lambda$main$0(Main.java:16)\n    at java.lang.Thread.run(Thread.java:750)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么我们来看看报的什么错，从栈追踪信息可以看出，是add方法出现了问题：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>\n    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>   \n    <span class="token comment">// 这一句出现了数组越界</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，同一时间其他线程也在疯狂向数组中添加元素，那么这个时候有可能在<code>ensureCapacityInternal</code>（确认容量足够）执行之后，<code>elementData[size++] = e;</code>执行之前，其他线程插入了元素，导致size的值超出了数组容量。</p><p>这些在单线程的情况下不可能发生的问题，在多线程下就慢慢出现了。</p><p>我们再来看看比较常用的HashMap呢？</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>\n                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token string">&quot;lbwnb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过测试发现，虽然没有报错，但是最后的键值对的数量没有达到预期</p><p>实际上它还有可能导致Entry对象出现环状数据结构，引起死循环。</p><h4 id="并发容器介绍" tabindex="-1"><a class="header-anchor" href="#并发容器介绍"><span>并发容器介绍</span></a></h4><p>怎么才能解决并发情况下的容器问题呢？</p><p>首先想到的肯定是给方法前面加个<code>synchronzed</code>关键字，这样总不会抢了吧，在之前我们可以使用Vector或是Hashtable来解决，但是它们的效率实在是太低了，完全依靠锁来解决问题，因此现在已经很少再使用它们。</p><p>JUC提供了专用于并发场景下的容器</p><h5 id="并发实现类-——-copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#并发实现类-——-copyonwritearraylist"><span>并发实现类 —— <code>CopyOnWriteArrayList</code></span></a></h5><p>比如我们刚刚使用的ArrayList，在多线程环境下是没办法使用的，我们可以将其替换为JUC提供的多线程专用集合类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token comment">// 这里使用CopyOnWriteArrayList来保证线程安全</span>\n    <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="add-源码分析" tabindex="-1"><a class="header-anchor" href="#add-源码分析"><span><code>add()</code>源码分析</span></a></h6><p>先看它是如何进行<code>add()</code>操作的：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>\n    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   \n    <span class="token comment">// 直接加锁，保证同一时间只有一个线程进行添加操作</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取当前存储元素的数组</span>\n        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n        <span class="token comment">// 直接复制一份数组</span>\n        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 修改复制出来的数组</span>\n        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>\n        <span class="token comment">// 将元素数组设定为复制出来的数组</span>\n        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）</p><h6 id="get-源码分析" tabindex="-1"><a class="header-anchor" href="#get-源码分析"><span><code>get()</code>源码分析</span></a></h6><p>接着我们来看读操作：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，<code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于前面的读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题。</p><h5 id="并发实现类-——-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#并发实现类-——-concurrenthashmap"><span>并发实现类 —— <code>ConcurrentHashMap</code></span></a></h5><p>HashMap的并发容器<code>ConcurrentHashMap</code>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>\n                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>finalI <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里的<code>ConcurrentHashMap</code>就没有出现之前HashMap的问题了。</p><p>因为线程之间会争抢同一把锁，在<code>LongAdder</code>的时候有一种压力分散思想，既然每个线程都想抢锁，那我就干脆多搞几把锁，让你们每个人都能拿到，这样就不会存在等待的问题了</p><p>而JDK7之前，<code>ConcurrentHashMap</code>的原理也比较类似，它将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p><figure><img src="'+e+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h6 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h6><p>这里我们重点讲解JDK8之后它是怎么实现的，它采用了CAS算法配合锁机制实现，</p><p>在JDK8下的HashMap是的结构：</p><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>HashMap就是利用了哈希表，哈希表的本质其实就是一个用于存放后续节点的头结点的数组</p><p>数组里面的每一个元素都是一个头结点（也可以说就是一个链表）</p><p>当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。</p><p>当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！</p><p>当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p><h6 id="构造方法分析" tabindex="-1"><a class="header-anchor" href="#构造方法分析"><span>构造方法分析</span></a></h6><p>由于ConcurrentHashMap的源码比较复杂，所以我们先从最简单的构造方法开始下手：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Creates a new, empty map with the default initial table size (16).\n */</span>\n<span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token doc-comment comment">/**\n * Creates a new, empty map with an initial table size\n * accommodating the specified number of elements without the need\n * to dynamically resize.\n *\n * <span class="token keyword">@param</span> <span class="token parameter">initialCapacity</span> The implementation performs internal\n * sizing to accommodate this many elements.\n * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IllegalArgumentException</span></span> if the initial capacity of\n * elements is negative\n */</span>\n<span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>\n                <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span>\n                <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token doc-comment comment">/**\n * Creates a new map with the same mappings as the given map.\n *\n * <span class="token keyword">@param</span> <span class="token parameter">m</span> the map\n */</span>\n<span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>\n    <span class="token function">putAll</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 HashMap</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal initial capacity: &quot;</span> <span class="token operator">+</span>\n                                            initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>\n        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal load factor: &quot;</span> <span class="token operator">+</span>\n                                            loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token doc-comment comment">/**\n * Constructs an empty <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tt</span><span class="token punctuation">&gt;</span></span><span class="token code-section"><span class="token line"><span class="token code language-java"><span class="token class-name">HashMap</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tt</span><span class="token punctuation">&gt;</span></span> with the specified initial\n * capacity and the default load factor (0.75).\n *\n * <span class="token keyword">@param</span>  <span class="token parameter">initialCapacity</span> the initial capacity.\n * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IllegalArgumentException</span></span> if the initial capacity is negative.\n */</span>\n<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的构造方法和HashMap的构造方法有很大的出入，但是大体的结构和HashMap是差不多的，也是维护了一个哈希表，并且哈希表中存放的是链表或是红黑树</p><h6 id="put-源码分析" tabindex="-1"><a class="header-anchor" href="#put-源码分析"><span><code>put()</code>源码分析</span></a></h6><p>直接来看<code>put()</code>操作是如何实现的，只要看明白这个，基本上就懂了：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>\n<span class="token doc-comment comment">/**\n * The array of bins. Lazily initialized upon first insertion.\n * Size is always a power of two. Accessed directly by iterators.\n */</span>\n<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">HASH_BITS</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 有点小乱，如果看着太乱，可以在IDEA中折叠一下代码块，不然有点难受</span>\n<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 键值不能为空，基操</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n    \n    <span class="token comment">// 计算键的hash值，用于确定在哈希表中的位置</span>\n    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">//一会用来记录链表长度的</span>\n    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 无限循环，而且还是并发包中的类，盲猜一波CAS自旋锁</span>\n    <span class="token comment">// table: The array of bins</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>\n        \n        <span class="token comment">// 如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// n 表示该哈希表的长度, HashMap 的容量，且必须是 2 的幂，如 16, 32</span>\n        <span class="token comment">// (n - 1) &amp; hash</span>\n        <span class="token comment">// 当 n 是 2 的幂时，(n - 1) &amp; hash 的效果等同于 hash % n，但位运算 &amp; 的性能比 % 高得多</span>\n        <span class="token comment">// i = (n - 1) &amp; hash (记录索引)</span>\n        <span class="token comment">// f = tabAt(tab, i) 获取节点并赋值</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果哈希表该位置为null</span>\n            <span class="token comment">// 没有任何元素</span>\n            <span class="token comment">// 直接CAS插入结点作为头结即可</span>\n            <span class="token comment">// 注意这里会将f设置当前哈希表位置上的头结点</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  \n                <span class="token keyword">break</span><span class="token punctuation">;</span>                   \n                <span class="token comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span>\n        <span class="token punctuation">}</span> \n        \n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>\n            <span class="token comment">// MOVER == -1</span>\n            <span class="token comment">// 头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span>\n            <span class="token comment">// 帮助进行迁移，完事之后再来下一次循环</span>\n            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>   \n        \n        <span class="token comment">// 特殊情况都完了，这里就该是正常情况了</span>\n        <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// f 当前 bin 的头结点</span>\n            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token comment">// 分 bin 加锁</span>\n            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>   \n                <span class="token comment">// 在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点</span>\n                <span class="token comment">// 这里直接把它作为锁加锁了</span>\n                <span class="token comment">// 防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    \n                        <span class="token comment">// 头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span>\n                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>实现细节略\n                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   \n                        <span class="token comment">// 肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作</span>\n                        <span class="token comment">// 在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span>\n                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>实现细节略\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n\n           <span class="token comment">// 根据链表长度决定是否要进化为红黑树</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>\n                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>   \n                    <span class="token comment">// 注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>\n                <span class="token keyword">break</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>怎么样，是不是感觉看着挺复杂，其实也还好，总结一下就是：</p><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h6 id="get-源码分析-1" tabindex="-1"><a class="header-anchor" href="#get-源码分析-1"><span><code>get()</code>源码分析</span></a></h6><p>我们接着来看看<code>get()</code>操作：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算哈希值</span>\n    \n    <span class="token comment">// table 是 bin的总数</span>\n    <span class="token comment">// (tab = table) != null 判断bins是否为空</span>\n    <span class="token comment">// (n = tab.length) &gt; 0 赋值n为bins的长度，并判断是否为空</span>\n    <span class="token comment">// (e = tabAt(tab, (n - 1) &amp; h)) != null</span>\n    <span class="token comment">// 与运算代替取模哈希 找对应的 bin 的头结点是否存在</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>\n        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        \n        <span class="token comment">// 如果头结点就是我们要找的，那直接返回值就行了</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n       <span class="token comment">// 要么是正在扩容，要么就是红黑树，负数只有这两种情况</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n       \n       <span class="token comment">// 确认无误，肯定在列表里，开找</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>\n                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n   <span class="token comment">//没找到只能null了</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h6><p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p><p>其实这里也只是简单地介绍了一下它的运行机制，ConcurrentHashMap真正的难点在于扩容和迁移操作，我们主要了解的是他的并发执行机制，有关它的其他实现细节，这里暂时不进行讲解</p>',65)],l={},i=(0,a(83671).A)(l,[["render",function(n,s){return(0,t.uX)(),(0,t.CE)("div",null,c)}]]),u=JSON.parse('{"path":"/code/%E5%85%AB%E8%82%A1/JUC/article7.html","title":"JUC7 - 并发容器","lang":"zh-CN","frontmatter":{"title":"JUC7 - 并发容器","date":"2025-12-29T00:00:00.000Z","category":["code"],"tag":["java","juc"],"order":-0.5,"description":"JUC7 并发容器 重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的） 在单线程模式下，集合类提供的容器可以说是非常方便了，但在多线程环境下，这些数据结构还能正常工作吗 传统容器线程安全问...","head":[["meta",{"property":"og:url","content":"http://ekkosonya.cn/code/%E5%85%AB%E8%82%A1/JUC/article7.html"}],["meta",{"property":"og:site_name","content":"EkkoSonya\'s Blog"}],["meta",{"property":"og:title","content":"JUC7 - 并发容器"}],["meta",{"property":"og:description","content":"JUC7 并发容器 重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的） 在单线程模式下，集合类提供的容器可以说是非常方便了，但在多线程环境下，这些数据结构还能正常工作吗 传统容器线程安全问..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-30T16:05:43.000Z"}],["meta",{"property":"article:author","content":"EkkoSonya"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"juc"}],["meta",{"property":"article:published_time","content":"2025-12-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-30T16:05:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC7 - 并发容器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-30T16:05:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"EkkoSonya\\",\\"url\\":\\"http://ekkosonya.cn\\"}]}"]]},"headers":[{"level":2,"title":"JUC7","slug":"juc7","link":"#juc7","children":[{"level":3,"title":"并发容器","slug":"并发容器","link":"#并发容器","children":[{"level":4,"title":"传统容器线程安全问题","slug":"传统容器线程安全问题","link":"#传统容器线程安全问题","children":[]},{"level":4,"title":"并发容器介绍","slug":"并发容器介绍","link":"#并发容器介绍","children":[{"level":5,"title":"并发实现类 —— CopyOnWriteArrayList","slug":"并发实现类-——-copyonwritearraylist","link":"#并发实现类-——-copyonwritearraylist","children":[]},{"level":5,"title":"并发实现类 —— ConcurrentHashMap","slug":"并发实现类-——-concurrenthashmap","link":"#并发实现类-——-concurrenthashmap","children":[]}]}]}]}],"git":{"createdTime":1767110743000,"updatedTime":1767110743000,"contributors":[{"name":"EkkoSonya","email":"ekkosonya@163.com","commits":1}]},"readingTime":{"minutes":10.2,"words":3061},"filePathRelative":"code/八股/JUC/article7.md","localizedDate":"2025年12月29日","excerpt":"<h2>JUC7</h2>\\n<h3>并发容器</h3>\\n<p>重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的）</p>\\n<p>在单线程模式下，集合类提供的容器可以说是非常方便了，但在多线程环境下，这些数据结构还能正常工作吗</p>\\n<h4>传统容器线程安全问题</h4>\\n<p>测试一下，100个线程同时向ArrayList中添加元素：</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">Main</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> args<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token class-name\\">List</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">&gt;</span></span> list <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ArrayList</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token class-name\\">Runnable</span> r <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">-&gt;</span> <span class=\\"token punctuation\\">{</span>\\n            <span class=\\"token keyword\\">for</span> <span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> i <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span> i <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">100</span><span class=\\"token punctuation\\">;</span> i<span class=\\"token operator\\">++</span><span class=\\"token punctuation\\">)</span>\\n                list<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">add</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"1\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token keyword\\">for</span> <span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> i <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span> i <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">100</span><span class=\\"token punctuation\\">;</span> i<span class=\\"token operator\\">++</span><span class=\\"token punctuation\\">)</span>\\n            <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Thread</span><span class=\\"token punctuation\\">(</span>r<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">start</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token class-name\\">TimeUnit</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">SECONDS</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">sleep</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span>list<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">size</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}')}}]);